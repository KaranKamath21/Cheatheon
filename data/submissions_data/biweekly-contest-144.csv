username,userslug,contest_rank,question_id,language,code,submission_id
kmjp,kmjp,1,3591,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll E[26][26]={};
        int i,x,y;
        FOR(x,26) FOR(y,26) E[x][y]=(x==y)?0:1LL<<50;
        FOR(x,26) E[x][(x+1)%26]=nextCost[x];
        FOR(x,26) E[x][(x+25)%26]=previousCost[x];
        FOR(i,26) FOR(x,26) FOR(y,26) E[x][y]=min(E[x][y],E[x][i]+E[i][y]);
        ll ret=0;
        FOR(i,s.size()) ret+=E[s[i]-'a'][t[i]-'a'];
        return ret;
    }
};
",1460801168
kmjp,kmjp,1,3625,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    bool canAliceWin(int n) {
		int i;
		FOR(i,100) {
			int del=10-i;
			if(n>=del) {
				n-=del;
			}
			else {
				return (i%2);;
			}
		}
        return 0;
    }
};
",1460796159
kmjp,kmjp,1,3647,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


int C[202020];
const int def=-1<<20;
template<class V,int NV> class SegTree_3 {
public:
	vector<V> val, ma;
	SegTree_3(){
		int i;
		val.resize(NV*2,0); ma.resize(NV*2,0);
		FOR(i,NV) val[i+NV]=ma[i+NV]=def;
		for(i=NV-1;i>=1;i--) ma[i]=max(ma[2*i],ma[2*i+1]);
	};
	
	V getval(int x,int y,int l=0,int r=NV,int k=1) {
		if(r<=x || y<=l || y<=x) return def;
		if(x<=l && r<=y) return ma[k];
		return val[k]+max(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));
	}
	
	void update(int x,int y, V v,int l=0,int r=NV,int k=1) {
		if(l>=r||y<=x) return;
		if(x<=l && r<=y) {
			val[k]+=v;
			ma[k]+=v;
		}
		else if(l < y && x < r) {
			update(x,y,v,l,(l+r)/2,k*2);
			update(x,y,v,(l+r)/2,r,k*2+1);
			ma[k]=val[k]+max(ma[k*2],ma[k*2+1]);
		}
	}
};
SegTree_3<int,1<<20> st;

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
		int i;
		int N=nums.size();
		FOR(i,N+1) C[i]=0;
		FORR(q,queries) C[q[0]]++,C[q[1]+1]--;
		FOR(i,N) {
			if(i) {
				C[i]+=C[i-1];
			}
			if(nums[i]>C[i]) return -1;
			nums[i]-=C[i];
			st.update(i,i+1,-st.getval(i,i+1)+nums[i]);
		}
		int ret=0;
		sort(ALL(queries));
		reverse(ALL(queries));
		FORR(q,queries) {
			int x=st.getval(q[0],q[1]+1);
			if(x<0) {
				ret++;
				st.update(q[0],q[1]+1,1);
			}
			
		}
		
		return ret;
        
        
    }
};
",1460829420
kmjp,kmjp,1,3648,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

ll from[1010],to[1010];

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int N=fruits.size();
        ll ret=0;
        int x,y,loop;
        FOR(x,N) ret+=fruits[x][x];
        FOR(loop,2) {
			FOR(x,N) FOR(y,N) if(x<y) swap(fruits[x][y],fruits[y][x]);
			FOR(x,N) from[x]=-1LL<<60;
			from[N-1]=fruits[0][N-1];
			for(y=1;y<N-1;y++) {
				FOR(x,N) to[x]=-1LL<<60;
				FOR(x,N) if(from[x]>=0) {
					if(x<N-1) to[x+1]=max(to[x+1],from[x]+fruits[y][x+1]);
					to[x-1]=max(to[x-1],from[x]+fruits[y][x-1]);
					to[x]=max(to[x],from[x]+fruits[y][x]);
				}
				swap(from,to);
			}
			cout<<from[N-1]<<endl;
			ret+=from[N-1];
			
		}
        return ret;
    }
};
",1460822949
AntonRaichuk,AntonRaichuk,3,3591,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll r = 0;
        REP(i,s.size()){
            ll t1 = 0, t2 = 0;
            char c = s[i];
            while(c!=t[i]){
                t1 += nextCost[c-'a'];
                if(c=='z')c='a';
                else c++;
            }
            c=s[i];
            while(c!=t[i]){
                t2 += previousCost[c-'a'];
                if(c=='a')c='z';
                else c--;
            }

            r += min(t1,t2);
        }
        return r;        
    }
};",1460801076
AntonRaichuk,AntonRaichuk,3,3625,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    bool canAliceWin(int n) {
        int t = 10;
        int c = 0;
        while(1){
            if(n<t)return c==1;
            n-=t;
            c^=1;
            t--;
        }
        
    }
};",1460796192
AntonRaichuk,AntonRaichuk,3,3647,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

struct Node{
    Node* lf;
    Node* rg;
    int l,r;
    int mx;
    int add;
    Node(){
        lf=rg=0;
        l=r=0;
        mx=add=0;
    }
};


vi a;

Node* buildTree(int l,int r){
    Node* c = new Node();
    c->l=l;
    c->r=r;
    if(l==r){
        c->mx=a[l];
    }else{
        c->lf=buildTree(l,(l+r)/2);
        c->rg=buildTree((l+r)/2+1,r);
        c->mx=max(c->lf->mx,c->rg->mx);
    }
    return c;
}

int getmax(Node* c){
    return c->mx+c->add;    
}
void add(Node* c, int l,int r, int v){
    if(r<c->l || l>c->r)return;
    if(l<=c->l && c->r<=r){
        c->add+=v;
    }else{
        add(c->lf,l,r,v);
        add(c->rg,l,r,v);
        c->mx=max(getmax(c->lf),getmax(c->rg));
    }
}

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        a=nums;
        vector<pii> t;
        Node* root=buildTree(0,a.size()-1);
        REP(i,q.size())t.pb({q[i][1], q[i][0]}),add(root,q[i][0],q[i][1],-1);
        if(getmax(root) > 0)return -1;
        SORT(t);
        int r=0;
        REP(i,t.size()){
            int from = t[i].second;
            int to = t[i].first;
            add(root,from,to,1);
            if(getmax(root)<=0)r++;
            else add(root,from,to,-1);
        }
        return r;
    }
};",1460822786
AntonRaichuk,AntonRaichuk,3,3648,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

vector<vi> a;
int n;
int d[1111];
int d2[1111];
void update(int pos,int val){
    if(d2[pos]==-1 || d2[pos]<val)d2[pos]=val;
}

int solve(){
    CL(d,-1);
    d[n-1]=a[n-1][0];
    REP(i,n-1){
        CL(d2,-1);

        REP(j,n)if(d[j]!=-1){
            if(j-1>=i+1)update(j-1,d[j]+a[i+1][j-1]);
            if(j>=i+1)update(j,d[j]+a[i+1][j]);
            if(j+1<=n-1)update(j+1,d[j]+a[i+1][j+1]);
        }
        
        memcpy(d,d2,sizeof d);
    }
    return d[n-1];
}


class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        a=f;
        n=a.size();
        int r = 0;
        REP(i,n)r+=a[i][i],a[i][i]=0;
        r += solve();
        REP(i,n)REP(j,i)swap(a[i][j],a[j][i]);
        r += solve();
        return r;
    }
};",1460835761
Ethan,ethanrao,5,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0; 
        int n = s.length();
        
        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a'; 
            int target = t[i] - 'a'; 
            
            int ff = (target - start + 26) % 26;
            int bb = (start - target + 26) % 26;
            
            long long ct1 = 0, ct2 = 0;
            for (int j = 0; j < ff; ++j) {
                ct1 += nextCost[(start + j) % 26];
            }

            for (int j = 0; j < bb; ++j) {
                ct2 += previousCost[(start - j + 26) % 26];
            }
            ans += min(ct1, ct2);
        }
        
        return ans;
    }
};",1460822153
Ethan,ethanrao,5,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int now = n, t = 10;
        int flag = 1;
        while(now>=0){
            if(now==0){
                if(flag == 1) return false;
                else return true;
            }
            if(now>=t){
                now -= t;
            }
            else{
                // cout<<flag<<endl;
                if(flag == 1) return false;
                else return true;
            }
            flag = -flag;
            t--;
        }
        return true;
    }
};
",1460821143
Ethan,ethanrao,5,3647,cpp,"class Solution {
public:
    struct node{
        int l, r;
    };
    struct cmp{
      bool operator()(node a, node b){
          return a.r < b.r;
      }  
    };
    std::priority_queue <node, std::vector <node>, cmp> q;
    int a[100005], lazy[400005], m[400005];
    inline void down(int x){
        if(lazy[x] == 0) return ;
        lazy[x * 2] += lazy[x];
        lazy[x * 2 + 1] += lazy[x];
        m[x * 2] -= lazy[x];
        m[x * 2 + 1] -= lazy[x];
        lazy[x] = 0;
        return ;
    }
    inline void up(int x){
        m[x] = std::max(m[x * 2], m[x * 2 + 1]);
        return ;
    }
    inline void upd(int x, int l, int r, int L, int R){
        if(l == L && r == R){
            lazy[x] += 1;
            m[x] -= 1;
            return ;
        }
        int mid = l + r >> 1;
        down(x);
        if(R <= mid) upd(x * 2, l, mid, L, R);
        else if(L >= mid + 1) upd(x * 2 + 1, mid + 1, r, L, R);
        else {
            upd(x * 2, l, mid, L, mid);
            upd(x * 2 + 1, mid + 1, r, mid + 1, R);
        }
        up(x);
        return ;
    }
    void build(int x, int l, int r){
        if(l == r){
            m[x] = a[l];
            lazy[x] = 0;
            return ;
        }
        int mid = l + r >> 1;
        build(x * 2, l, mid);
        build(x * 2 + 1, mid + 1, r);
        up(x);
        return ;
    }
    int ask(int x, int l, int r, int y){
        if(l == r) return m[x];
        int mid = l + r >> 1;
        down(x);
        if(y <= mid) return ask(x * 2, l, mid, y);
        else return ask(x * 2 + 1, mid + 1, r, y);
    }
    std::vector <node> vc[100005];
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), cnt = 0;
        for(int i = 1; i <= n; ++i) a[i] = nums[i - 1];
        for(int i = 0; i < queries.size(); ++i) vc[queries[i][0] + 1].push_back((node){queries[i][0] + 1, queries[i][1] + 1});
        build(1, 1, n);
        for(int i = 1; i <= n; ++i){
            for(int j = 0; j < vc[i].size(); ++j)
                q.push(vc[i][j]);
            while(ask(1, 1, n, i) >= 1){
                if(q.size() == 0) return -1;
                node u = q.top(); q.pop();
                if(u.r < i) return -1;
                upd(1, 1, n, u.l, u.r);
                cnt += 1;
            }
        }
        return queries.size() - cnt;
    }
};",1460820540
Ethan,ethanrao,5,3648,cpp,"class Solution {
public:
    int dp[1005][1005];
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ans = 0, ans1 = 0, ans2 = 0, ans3 = 0;
        int n = f.size();
        for(int i = 0; i < n; ++i) ans1 += f[i][i];
        dp[n - 1][0] = f[n - 1][0];
        for(int i = 0; i <= n - 2; ++i) dp[i][0] = -1e9;
        for(int y = 1; y <= n - 1; ++y)
            for(int x = y; x <= n - 1; ++x){
                dp[x][y] = -1e9;
                if(x - 1 >= y - 1 && dp[x - 1][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y - 1]);
                if(x >= y - 1 && dp[x][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x][y - 1]);
                if(x + 1 >= y - 1 && dp[x + 1][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x + 1][y - 1]);
                if(dp[x][y] != -1e9){
                    if(x != y) dp[x][y] += f[x][y];
                    else ;
                }
            }
        ans2 = dp[n - 1][n - 1];
        dp[0][n - 1] = f[0][n - 1];
        for(int i = 0; i <= n - 2; ++i) dp[0][i] = -1e9;
        for(int x = 1; x <= n - 1; ++x)
            for(int y = x; y <= n - 1; ++y){
                dp[x][y] = -1e9;
                if(x - 1 <= y - 1 && dp[x - 1][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y - 1]);
                if(x - 1 <= y && dp[x - 1][y] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y]);
                if(x - 1 <= y + 1 && dp[x - 1][y + 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y + 1]);
                if(dp[x][y] != -1e9){
                    if(x != y) dp[x][y] += f[x][y];
                    else ;
                }
            }
        ans3 = dp[n - 1][n - 1];
        ans = ans1 + ans2 + ans3;
        return ans;
    }
};",1460836200
Naruto,Naruto_x,7,3591,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def shiftDistance(self, s: str, t: str, ncost: list[int], pcost: list[int]) -> int:
        sizee = 26
        INF = float('inf')
        cost = [[INF] * sizee for i in range(sizee)]
        for i in range(sizee):
            cost[i][i] = 0
        for c in range(sizee):
            nchar = (c + 1) % sizee
            prevc = (c - 1 + sizee) % sizee
            cost[c][nchar] = min(cost[c][nchar], ncost[c])
            cost[c][prevc] = min(cost[c][prevc], pcost[c])

        for k in range(sizee):
            for i in range(sizee):
                for j in range(sizee):
                    if cost[i][k] < INF and cost[k][j] < INF:
                        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])

        tot = 0
        n = len(s)
        for i in range(n):
            if s[i] == t[i]:
                continue 
            f1 = ord(s[i]) - ord('a')
            f2 = ord(t[i]) - ord('a')
            if cost[f1][f2] == INF:
                return -1  
            tot += cost[f1][f2]

        return tot",1460831814
Naruto,Naruto_x,7,3625,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def canAliceWin(self, n: int) -> bool:
        alicee = True
        s1 = 10
        while True:
            if n >= s1:
                n -= s1
                s1 -= 1
                alicee = not alicee
            else:
                if alicee:
                    return False
                else:
                    return True
            if s1 <= 0:
                if alicee:
                    return False
                else:
                    return True
",1460832436
Naruto,Naruto_x,7,3647,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
    
class SegmentTree:
    def __init__(self, size):
        self.n = size
        self.tree = [0] * (4 * size)
        self.lazy = [0] * (4 * size)

    def build(self, cap, node, l, r):
        if l == r:
            self.tree[node] = cap[l]
            return
        mid = (l + r) // 2
        self.build(cap, 2 * node, l, mid)
        self.build(cap, 2 * node + 1, mid + 1, r)
        self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])

    def down(self, node, l, r):
        if self.lazy[node] != 0:
            mid = (l + r) // 2
            self.tree[2 * node] += self.lazy[node]
            self.lazy[2 * node] += self.lazy[node]
            self.tree[2 * node + 1] += self.lazy[node]
            self.lazy[2 * node + 1] += self.lazy[node]
            # Reset lazy value
            self.lazy[node] = 0

    def update_range(self, node, l, r, ul, ur, delta):
        if ul > r or ur < l:
            return
        if ul <= l and r <= ur:
            self.tree[node] += delta
            self.lazy[node] += delta
            return
        self.down(node, l, r)
        mid = (l + r) // 2
        self.update_range(2 * node, l, mid, ul, ur, delta)
        self.update_range(2 * node + 1, mid + 1, r, ul, ur, delta)
        self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])

    def query1(self, node, l, r, ql, qr):
        if ql > r or qr < l:
            return float('inf')
        if ql <= l and r <= qr:
            return self.tree[node]
        self.down(node, l, r)
        mid = (l + r) // 2
        return min(self.query1(2 * node, l, mid, ql, qr),
                   self.query1(2 * node + 1, mid + 1, r, ql, qr))

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        q = len(queries)

        diff1 = [0] * (n + 1)
        for l, r in queries:
            diff1[l] += 1
            if r + 1 < len(diff1):
                diff1[r + 1] -= 1

        tot = [0] * n
        tot[0] = diff1[0]
        for i in range(1, n):
            tot[i] = tot[i - 1] + diff1[i]

        for i in range(n):
            if tot[i] < nums[i]:
                return -1

        cap = [tot[i] - nums[i] for i in range(n)]
        queries.sort(key=lambda x: (x[1], x[0]))

        st = SegmentTree(n)
        st.build(cap, 1, 0, n - 1)

        k = 0
        for l, r in queries:
            curr = st.query1(1, 0, n - 1, l, r)
            if curr >= 1:
                k += 1
                st.update_range(1, 0, n - 1, l, r, -1)

        return k
        
        


",1460830453
Naruto,Naruto_x,7,3648,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def maxCollectedFruits(self, fruits: list[list[int]]) -> int:
        n = len(fruits)
        def solve1(fruits, n):
            sum1 = 0
            for k in range(n):
                sum1 += fruits[k][k]
                fruits[k][k] = 0
            return sum1

        def solve2(fruits, n):
            dp2 = [[float('-inf')] * n for i in range(n)]
            dp2[0][n - 1] = fruits[0][n - 1]
        
            for k in range(1, n):
                mn1 = max(0, n - 1 - k)
                mx1 = min(n - 1, n - 1 + k)
                for c in range(mn1, mx1 + 1):
                    prev1 = float('-inf')
                    if c - 1 >= 0:
                        prev1 = max(prev1, dp2[k - 1][c - 1])
                    prev1 = max(prev1, dp2[k - 1][c])
                    if c + 1 < n:
                        prev1 = max(prev1, dp2[k - 1][c + 1])
                    if prev1 != float('-inf'):
                        dp2[k][c] = prev1 + fruits[k][c]
            return dp2[n - 1][n - 1]

        def solve3(fruits, n):
            dp3 = [[float('-inf')] * n for i in range(n)]
            dp3[0][n - 1] = fruits[n - 1][0]
        
            for k in range(1, n):
                mn2 = max(0, n - 1 - k)
                mx2 = min(n - 1, n - 1 + k)
                for r in range(mn2, mx2 + 1):
                    prev1 = float('-inf')
                    if r - 1 >= 0:
                        prev1 = max(prev1, dp3[k - 1][r - 1])
                    prev1 = max(prev1, dp3[k - 1][r])
                    if r + 1 < n:
                        prev1 = max(prev1, dp3[k - 1][r + 1])
                    if prev1 != float('-inf'):
                        dp3[k][r] = prev1 + fruits[r][k]
            return dp3[n - 1][n - 1]

        sum1 = solve1(fruits, n)
        sum2 = solve2(fruits, n)
        sum3 = solve3(fruits, n)
        ans = sum1 + sum2 + sum3
        return int(ans)


",1460839431
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        dist = {}
        for i in range(26):
            for j in range(26):
                if i == j:
                    dist[i,j] = 0
                    continue
                fcost = 0
                cur = i
                while cur != j:
                    fcost += nextCost[cur]
                    cur = (cur + 1) % 26
                pcost = 0
                cur = i
                while cur != j:
                    pcost += previousCost[cur]
                    cur = (cur - 1) % 26
                dist[i,j] = min(fcost, pcost)
        ret = 0
        for i in range(len(s)):
            a, b = ord(s[i])-97, ord(t[i])-97
            ret += dist[a,b]
        return ret
                        ",1460808432
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        turn = 0
        while 1:
            if cur > n:
                return turn == 1
            n -= cur
            turn = 1 - turn
            cur -= 1",1460796436
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        h = []
        n = len(nums)
        queries.sort()
        q = deque(queries)
        cur = 0
        end = defaultdict(int)
        take = 0
        for i in range(n):
            cur -= end[i]
            while q and q[0][0] <= i:
                heapq.heappush(h, -(1+q[0][1]))
                q.popleft()
            while cur < nums[i]:
                while 1:
                    if not h:
                        return -1
                    x = heapq.heappop(h)
                    x = -x
                    if x > i:
                        end[x] += 1
                        cur += 1
                        take += 1
                        # print(x)
                        break
                    else:
                        return -1
        return len(queries) - take",1460825221
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3648,python3,"class Solution:
    def maxCollectedFruits(self, g: List[List[int]]) -> int:
        n = len(g)
        a = 0
        for i in range(n):
            a += g[i][i]
            g[i][i] = 0

        @cache
        def dp1(i, j):
            if i >= n:
                return -inf
            cur = g[i][j]
            if (i, j) == (n-1, n-1):
                return cur
            ret = -inf
            for k in range(j-1, j+2):
                if 0 <= k < n:
                    ret = max(ret, dp1(i+1, k))
            return cur + ret

        @cache
        def dp2(i, j):
            if j >= n:
                return -inf
            cur = g[i][j]
            if (i, j) == (n-1, n-1):
                return cur
            ret = -inf
            for k in range(i-1, i+2):
                if 0 <= k < n:
                    ret = max(ret, dp2(k, j+1))
            return cur + ret

        return a + dp1(0, n-1) + dp2(n-1, 0)",1460842155
Anas Maged,Anas_Maged,13,3591,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = sz(s);
        ll a[26][26], b[26][26], cost[26][26];
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < 26; j++){
                a[i][j] = b[i][j] = cost[i][j] = LLONG_MAX;
            }
        }
        for(int i = 0; i < 26; i++){
            a[i][i] = 0;
            ll last = 0;
            for(int k = 0, j = (i - 1 + 26) % 26; k < 25; k++, j = (j - 1 + 26) % 26){
                last += previousCost[(j + 1) % 26];
                a[i][j] = last;
            }
        }
        for(int i = 0; i < 26; i++){
            b[i][i] = 0;
            ll last = 0;
            for(int k = 0, j = (i + 1) % 26; k < 25; k++, j = (j + 1 + 26) % 26){
                last += nextCost[(j - 1 + 26) % 26];
                b[i][j] = last;
            }
        }

        for(int i = 0; i < 26; i++){
            for(int j = 0; j < 26; j++){
                cost[i][j] = min(a[i][j], b[i][j]);
            }
        }
        
        for(int i = 0; i < n; i++){
            int c1 = s[i] - 'a', c2 = t[i] - 'a';
            ans += cost[c1][c2];
        }
        return ans;
    }
};",1460821013
Anas Maged,Anas_Maged,13,3625,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    bool canAliceWin(int n) {
        bool turn = false;
        for(int i = 10; i >= 1; i--){
            if(n < i) break;
            n -= i;
            turn = !turn;
        }
        return turn;
    }
};",1460796394
Anas Maged,Anas_Maged,13,3647,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        int n = sz(a);
        vector<vector<int>> r(n);
        for(auto it : q){
            r[it[0]].push_back(it[1]);
        }

        int take = 0;
        priority_queue<int> have;
        int cnt = 0;
        vector<int> rem(n + 1);
        for(int i = 0; i < n; i++){
            cnt += rem[i];
            for(int x : r[i]) have.push(x);
            a[i] -= cnt;
            while(a[i] > 0){
                if(have.empty() || have.top() < i){
                    return -1;
                }
                cnt++;
                rem[have.top() + 1]--;
                a[i]--;
                have.pop();
            }
        }
        return sz(have);
    }
};",1460830206
Anas Maged,Anas_Maged,13,3648,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = a.size();
        int ans = 0;
        for(int i = 0; i < n; i++){
            ans += a[i][i];
            a[i][i] = 0;
        }

        vector<vector<int>> dp(n, vector<int>(n, -1));
        auto rec1 = [&](auto& self, int i, int j) -> int{
            if(i == n || j == n || i < 0 || j < 0 || i < j) return 0;
            int& ret = dp[i][j];
            if(~ret) return ret;
            ret = max(self(self, i + 1, j + 1), self(self, i - 1, j + 1));
            ret = max(ret, self(self, i, j + 1));
            ret += a[i][j];
            return ret;
        };
        ans += rec1(rec1, n - 1, 0);
        dp = vector<vector<int>>(n, vector<int>(n, -1));
        auto rec2 = [&](auto& self, int i, int j) -> int{
            if(i == n || j == n || i < 0 || j < 0 || j < i) return 0;
            int& ret = dp[i][j];
            if(~ret) return ret;
            ret = max(self(self, i + 1, j + 1), self(self, i + 1, j - 1));
            ret = max(ret, self(self, i + 1, j));
            ret += a[i][j];
            return ret;
        };
        ans += rec2(rec2, 0, n - 1);
        return ans;
    }
};",1460844919
brahim Hanif eker,ihceker,17,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll ans=0;
        for(int i=0;i<(int)s.size();i++){
            if(s[i]==t[i])continue;
            ll sum=0,sum2=0;
            char c=s[i];
            while(c!=t[i]){
                sum+=nextCost[c-'a'];
                c++;
                if(c>'z')c='a';
            }
            c=s[i];
            while(c!=t[i]){
                sum2+=previousCost[c-'a'];
                c--;
                if(c<'a')c='z';
            }
            ans+=min(sum,sum2);
        }
        return ans;
    }
};",1460803313
brahim Hanif eker,ihceker,17,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn=0,move=10;
        while(n-move>=0){
            n-=move;
            move--;
            turn^=1;
        }
        return turn;
    }
};",1460796215
brahim Hanif eker,ihceker,17,3647,cpp,"class Solution {
public:
    struct FenwickTree{
        vector<int>f;
        FenwickTree(int N){
            f.resize(N+5);
        }
        void update(int x,int y){
            for(int i=x;i<(int)f.size();i+=(i&-i)){
                f[i]+=y;
            }
            return;
        }
        int query(int x){
            int y=0;
            for(int i=x;i>=1;i-=(i&-i)){
                y+=f[i];
            }
            return y;
        }
    };
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n=(int)nums.size();
        int m=(int)queries.size();
        FenwickTree ft(n);
        vector<vector<int>>q(n);
        for(int i=0;i<(int)queries.size();i++){
            q[queries[i][0]].push_back(queries[i][1]);
        }
        for(int i=0;i<n;i++){
            sort(q[i].begin(),q[i].end());
            reverse(q[i].begin(),q[i].end());
        }
        priority_queue<pair<int,int>>pq;
        for(int i=0;i<n;i++){
            nums[i]-=ft.query(i+1);
            for(int j=0;j<(int)q[i].size();j++){
                pq.push({q[i][j],i});
            }
            while(nums[i]>0 && !pq.empty() && pq.top().first>=i){
                nums[i]--;
                pair<int,int>cur=pq.top();
                pq.pop();
                ft.update(cur.second+1,1);
                ft.update(cur.first+2,-1);
            }
            if(nums[i]>0)return -1;
        }
        return (int)pq.size();
    }
};",1460832139
brahim Hanif eker,ihceker,17,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& arr) {
        int n=(int)arr.size();
        vector<vector<int>>dp(n,vector<int>(n));
        dp[n-1][0]=arr[n-1][0];
        for(int j=1;j<n;j++){
            for(int i=n-1;i>=n-j-1;i--){
                dp[i][j]=max({dp[i][j-1],(i-1>=n-(j-1)-1?dp[i-1][j-1]:0),(i+1<n?dp[i+1][j-1]:0)})+(i==j?0:arr[i][j]);
            }
        }
        vector<vector<int>>dp2(n,vector<int>(n));
        dp2[0][n-1]=arr[0][n-1];
        for(int i=1;i<n;i++){
            for(int j=n-1;j>=n-i-1;j--){
                dp2[i][j]=max({dp2[i-1][j],(j-1>=n-(i-1)-1?dp2[i-1][j-1]:0),(j+1<n?dp2[i-1][j+1]:0)})+(i==j?0:arr[i][j]);
            }
        }
        int ans=0;
        for(int i=0;i<n;i++){
            ans+=arr[i][i];
        }
        return ans+dp[n-1][n-1]+dp2[n-1][n-1];
    }
};",1460851937
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const long long INF = 0X3F3F3F3F3F3F3F3FLL;
        vector<vector<long long> > d(26, vector<long long>(26, INF));
        for (int i = 0; i < 26; ++i)
            d[i][i] = 0;
        for (int i = 0, j = 0; i < 26; ++i) {
            j = (i + 1) % 26;
            d[i][j] = min(1LL * nextCost[i], d[i][j]);
            d[j][i] = min(1LL * previousCost[j], d[j][i]);
        }
        for (int z = 0; z < 26; ++z)
            for (int i = 0; i < 26; ++i)
                for (int j = 0; j < 26; ++j)
                    d[i][j] = min(d[i][z] + d[z][j], d[i][j]);
        long long result = 0;
        int n = s.size();
        for (int i = 0; i < n; ++i)
            result += d[s[i] - 'a'][t[i] - 'a'];
        return result;
    }
};",1460809270
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = true;
         int x = 10;
        while (true) {
            if (n < x) {
                if (alice)
                    return false;
                return true;
            }
            n -= x;
            --x;
            alice = !alice;
        }
        return true;
    }
};",1460798235
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3647,cpp,"template<class T>
class SegmentTree {
protected:

    const int ninf = 0xc0c0c0c0, inf = 0x3f3f3f3f;

private:

    int length;
    mutable std::vector<T> maximum, lazy;

    void down(const int i) const {
        if (lazy[i]) {
            const int l = i << 1, r = l | 1;
            lazy[l] += lazy[i];
            lazy[r] += lazy[i];
            maximum[l] += lazy[i];
            maximum[r] += lazy[i];
            lazy[i] = 0;
        }
    }

    void modify(const int q, const T value, const int i, const int l, const int r) {
        if (q < l || r < q)
            return;
        if (l == r) {
            maximum[i] = value;
            return;
        }
        down(i);
        const int m = l + r >> 1;
        modify(q, value, i << 1, l, m);
        modify(q, value, i << 1 | 1, m + 1, r);
        maximum[i] = std::max(maximum[i << 1], maximum[i << 1 | 1]);
    }

    void update(const int ql, const int qr, const T value, const int i, const int l, const int r) {
        if (qr < l || r < ql)
            return;
        if (ql <= l && r <= qr) {
            maximum[i] += value;
            lazy[i] += value;
            return;
        }
        down(i);
        const int m = l + r >> 1;
        update(ql, qr, value, i << 1, l, m);
        update(ql, qr, value, i << 1 | 1, m + 1, r);
        maximum[i] = std::max(maximum[i << 1], maximum[i << 1 | 1]);
    }

    T query(const int ql, const int qr, const int i, const int l, const int r) const {
        if (qr < l || r < ql)
            return ninf;
        if (ql <= l && r <= qr)
            return maximum[i];
        down(i);
        const int m = l + r >> 1;
        return std::max(query(ql, qr, i << 1, l, m), query(ql, qr, i << 1 | 1, m + 1, r));
    }

    void build(const int i, const int l, const int r) {
        maximum[i] = inf;
        lazy[i] = 0;
        if (l == r)
            return;
        const int m = l + r >> 1;
        build(i << 1, l, m);
        build(i << 1 | 1, m + 1, r);
    }

public:

    SegmentTree(): length(0) {};
    SegmentTree(int n): length(n) {
        n = length + 5 << 2;
        maximum.resize(n, ninf);
        lazy.resize(n);
    };

    void update(const int ql, const int qr, const int value) {
        update(ql, qr, value, 1, 1, length);
    }

    void resize(int m) {
        length = m;
        m = length + 5 << 2;
        maximum.resize(m, ninf);
        lazy.resize(m);
//        reload();
    }

    void reload() {
        std::fill(maximum.begin(), maximum.end(), inf);
        std::fill(lazy.begin(), lazy.end(), 0);
    }

    void modify(const int q, const T value) {
        modify(q, value, 1, 1, length);
    }

    T query(const int ql, const int qr) const {
        return query(ql, qr, 1, 1, length);
    }

    void build() {
        build(1, 1, length);
    }

    T top() const {
        return maximum[1];
    }

    int getLength() const {
        return this -> length;
    }

    virtual ~SegmentTree() {}

};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        SegmentTree<int> m;
        int result = 0;
        int n = nums.size(), q = queries.size();

        m.resize(n);
        
        for (int i = 0; i < n; ++i)
            m.modify(i + 1, nums[i]);
        for (int i = 0; i < q; ++i)
            m.update(queries[i].front() + 1, queries[i].back() + 1, -1);

        if (m.top() > 0)
            return -1;
        
        sort(queries.begin(), queries.end(), [&](const auto &L, const auto &R) -> bool {
            const int a = L.back() - L.front(), b = R.back() - R.front();
            if (a == b)
                return L < R;
            return a < b;
        });
        
        for (const auto &v : queries) {
            const int l = v.front() + 1, r = v.back() + 1;
            //cout << l << ' ' << r << ' ' << m.query(l, r) << '\n';
            if (m.query(l, r) >= 0)
                   continue;
             ++result;
            m.update(l, r, 1);
        }
        return result;
    }
};",1460830354
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int> >& f) {
        int n = f.size(), NINF = 0XC0C0C0C0;
        int res = 0;
        vector<vector<int> > u(n, vector<int>(n, -1)), l(u);

        function<int(int, int)> U = [&](int x, int y) -> int {
            if (x < 0 || x >= n || y < 0 || y >= n || x > y)
                return NINF;
            if (x == n - 1 && y == n - 1)
                return 0;
            if (u[x][y] < 0) {
                u[x][y] = max({0, U(x + 1, y), U(x + 1, y - 1), U(x + 1, y + 1)});
                if (x != y)
                    u[x][y] += f[x][y];
            }
            return u[x][y];
        };

        function<int(int, int)> L = [&](int x, int y) -> int {
            if (x < 0 || x >= n || y < 0 || y >= n || x < y)
                return NINF;
            if (x == n - 1 && y == n - 1)
                return 0;
            if (l[x][y] < 0) {
                l[x][y] = max({0, L(x, y + 1), L(x - 1, y + 1), L(x + 1, y + 1)});
                if (x != y)
                    l[x][y] += f[x][y];
            }
            return l[x][y];
        };
        
        for (int i = 0; i < n; ++i)
            res += f[i][i];

        res += U(0, n - 1) + L(n - 1, 0);
        
        return res;
    }
};",1460846323
Aibar Kuanyshbay,kaikaikaikaikai,27,3591,cpp,"class Solution {
public:
    long long cost1(char s, char t, vector<int>& nc) {
        int x = s - 'a';
        int y = t - 'a';
        long long cost = 0;
        while (x != y) {
            cost += nc[x];
            x = (x + 1) % 26;
        }
        return cost;
    }
    long long cost2(char s, char t, vector<int>& nc) {
        int x = s - 'a';
        int y = t - 'a';
        long long cost = 0;
        while (x != y) {
            cost += nc[x];
            x = (x + 25) % 26;
        }
        return cost;
    }
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i])
                continue;
            ans += min(cost1(s[i], t[i], nc), cost2(s[i], t[i], pc));
        }
        return ans;
    }
};",1460807728
Aibar Kuanyshbay,kaikaikaikaikai,27,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; i >= 1; i--) {
            n -= i;
            if (n < 0) {
                if (i % 2 == 0)
                    return 0;
                return 1;
            }
        }   
        return 0;
    }
};",1460797564
Aibar Kuanyshbay,kaikaikaikaikai,27,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& qu) {
        int n = a.size();
        int m = qu.size();
        vector<int> b(n, 0);
        vector<vector<pair<int, int>>> v(n);
        for (int i = 0; i < m; i++) {
            int l = qu[i][0], r = qu[i][1];
            v[l].push_back({i, 1});
            if (r + 1 < n)
                v[r + 1].push_back({i, 0});
        }
        int ans = 0;
        set<pair<int, int>> s;
        for (int i = 0; i < n; i++) {
            if (i > 0)
                b[i] += b[i - 1];

            for (auto j : v[i]) {
                int ind = j.first, t = j.second;
                if (t == 1)
                    s.insert({qu[ind][1], ind});
                else 
                    s.erase({qu[ind][1], ind});
            }            
            while (b[i] < a[i]) {
                if (s.size() == 0)
                    return -1;
                auto pr = *s.rbegin();
                s.erase(pr);
                ans++;
                b[i]++;
                if (pr.first + 1 < n)
                    b[pr.first + 1]--;
            }
        }
        return m - ans;
    }
};",1460840859
Aibar Kuanyshbay,kaikaikaikaikai,27,3648,cpp,"class Solution {
public:
    int calcDP(int n, vector<vector<int>>& f) {
        vector<vector<int>> dp(n, vector<int> (n, 0));
        dp[n - 1][0] = f[n - 1][0];
        for (int i = 0; i < n - 1; i++)
            dp[i][0] = -(int)1e9;
        for (int j = 1; j < n; j++)
            for (int i = 0; i < n; i++) {
                dp[i][j] = -(int)1e9;
                dp[i][j] = max(dp[i][j], dp[i][j - 1] + f[i][j]);
                if (i > 0)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + f[i][j]);
                if (i + 1 < n)
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + f[i][j]);
            }
        return dp[n - 1][n - 1];
    }
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ans = 0;
        int n = f.size();
        for (int i = 0; i < n; i++) {
            ans += f[i][i];
            f[i][i] = 0;
        }
        ans += calcDP(n, f);
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                swap(f[i][j], f[j][i]);
        ans += calcDP(n, f);
        return ans;
    }
};",1460862116
Ian Wong,ianwong1999,28,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        int n = s.size();
        
        for (int i = 0; i < n; i++) {
            int x = s[i] - 'a';
            int y = t[i] - 'a';
            
            auto f = [&] (int d, auto& vec) {
                int p = x;
                int q = y;
                long long ret = 0;
                
                while (p != q) {
                    ret += vec[p];
                    p = (p + d + 26) % 26;
                }
                
                return ret;
            };
            
            res += min(f(1, nextCost), f(-1, previousCost));
        }
        
        return res;
    }
};",1460802211
Ian Wong,ianwong1999,28,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cur = 10;
        bool state = false;
        
        while (true) {
            if (n - cur < 0) {
                return state;
            }
            
            n-= cur;
            cur--;
            state ^= true;
        }
    }
};",1460796593
Ian Wong,ianwong1999,28,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> pref(n + 1);
        
        sort(queries.begin(), queries.end(), [&](const auto& l, const auto& r) {
            return l[0] < r[0];
        });
        
        int pt = 0;
        int take = 0;
        priority_queue<int> pq;
        
        for (int i = 0; i < n; i++) {
            if (i) pref[i] += pref[i - 1];
            nums[i] -= pref[i];
            if (nums[i] <= 0) continue;
            
            while (pt < (int)queries.size() && queries[pt][0] <= i) {
                pq.push(queries[pt][1]);
                pt++;
            }
            
            while (!pq.empty() && pq.top() < i) pq.pop();

            
            while (nums[i] > 0 && !pq.empty()) {
                if (pq.top() < i) {
                    pq.pop();
                    continue;
                }
                nums[i]--;
                pref[i]++;
                pref[pq.top() + 1]--;
                take++;
                pq.pop();
            }
            
            if (nums[i] > 0) return -1;
        }
        
        return (int)queries.size() - take;
    }
};",1460834030
Ian Wong,ianwong1999,28,3648,cpp,"class Solution {
public:
    int dp[1055][1055];
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res = 0;
        int n = fruits.size();
        
        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        
        auto f = [&]() {
            memset(dp, 0, sizeof(dp));
            
            for (int j = 0; j < n; j++) {
                int lim;
                
                if (j < n / 2) lim = n - j - 1;
                else lim = n - (n - j);
                
                for (int i = lim; i < n; i++) {
                    if (j == 0) {
                        dp[i][j] = fruits[i][j];
                        continue;
                    }
                    for (int d = -1; d <= 1; d++) {
                        int k = i + d;
                        
                        if (0 <= k && k < n) {
                            dp[i][j] = max(dp[i][j], dp[k][j - 1] + fruits[i][j]);
                        }
                    }
                }
            }
            res += dp[n - 1][n - 1];
        };

        f();
        auto temp = fruits;
        
        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {
            fruits[j][n - i - 1] = temp[i][j];
        }
        f();
        return res;
    }
};",1460857378
ywj568-en,ywj568-en,29,3591,cpp,"using ll = long long;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        int n = s.length();
        ll ans = 0;
        for (int i = 0; i < n; i++) {
            char ch = s[i];
            ll t1 = 0;
            while (ch != t[i]) {
                t1 += nc[ch - 'a'];
                ch = (ch - 'a' + 1) % 26 + 'a';
            }
            ch = s[i];
            ll t2 = 0;
            while (ch != t[i]) {
                t2 += pc[ch - 'a'];
                ch = (ch - 'a' - 1 + 26) % 26 + 'a';
            }
            ans += min(t1, t2);
        }
        return ans;
    }
};",1460815165
ywj568-en,ywj568-en,29,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool t = false;
        int c = 10;
        while (n >= c) {
            n -= c;
            c--;
            t = !t;
        }
        return t;
    }
};",1460800460
ywj568-en,ywj568-en,29,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& qr) {
        int n = nums.size(), q = qr.size();
        vector<vector<int>> sl(n), sr(n);
        for (int i = 0; i < q; i++) {
            int l = qr[i][0], r = qr[i][1];
            sl[l].push_back(r);
            sr[r].push_back(l);
        }
        multiset<int> ms;
        vector<int> d(n + 1);
        int cur = 0, ans = 0;
        for (int i = 0; i < n; i++) {
            for (int r : sl[i]) ms.insert(r);
            while (!ms.empty() && *ms.begin() < i) ms.erase(ms.begin());
            cur += d[i];
            while (cur < nums[i]) {
                if (ms.empty()) return -1;
                auto it = prev(ms.end());
                cur++;
                ans++;
                d[(*it) + 1]--;
                ms.erase(it);
            }
        }
        return q - ans;
    }
};",1460850252
ywj568-en,ywj568-en,29,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++) {
            for (int j = n - i - 1; j < n; j++) {
                if (i == 0) dp[i][j] = fruits[i][j];
                else {
                    int t1 = j == 0 ? 0 : dp[i - 1][j - 1];
                    int t2 = dp[i - 1][j];
                    int t3 = j == n - 1 ? 0 : dp[i - 1][j + 1];
                    dp[i][j] = max({t1, t2, t3}) + fruits[i][j];
                }
            }
        }
        ans += dp[n - 1][n - 1];
        dp.assign(n, vector<int>(n, 0));
        for (int j = 0; j < n; j++) {
            for (int i = n - j - 1; i < n; i++) {
                if (j == 0) dp[i][j] = fruits[i][j];
                else {
                    int t1 = i == 0 ? 0 : dp[i - 1][j - 1];
                    int t2 = dp[i][j - 1];
                    int t3 = i == n - 1 ? 0 : dp[i + 1][j - 1];
                    dp[i][j] = max({t1, t2, t3}) + fruits[i][j];
                }
            }
        }
        ans += dp[n - 1][n - 1];
        return ans;
    }
};",1460864796
scanhex,scanhex,31,3591,cpp,"
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const long long oo=0x3f3f3f3f3f3f3f3f;
        vector<vector<long long>> c(26, vector<long long>(26, oo));
        for (int i = 0; i < 26; ++i) {
            c[i][i] = 0;
            c[i][(i+1)%26] = nextCost[i];
            c[i][(i+25)%26] = previousCost[i];
        }
        for (int k = 0; k < 26; ++k)
            for (int i = 0; i < 26; ++i)
                for (int j = 0; j < 26; ++j)
                    c[i][j] = min(c[i][j], c[i][k] + c[k][j]);
        long long ans = 0;
        for (int i = 0; i < s.size(); ++i)
            ans += c[s[i]-'a'][t[i]-'a'];
        return ans;
    }
};
",1460827933
scanhex,scanhex,31,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i in range(11):
            if n < 10 - i:
                return i % 2 == 1
            n -= 10 - i",1460826001
scanhex,scanhex,31,3647,cpp,"class Solution {
public:
  int maxRemoval(vector<int> &nums, vector<vector<int>> &queries) {
    int n = nums.size(), q = queries.size();
    vector<vector<int>> op(n);
    for (int i = 0; i < q; ++i)
      op[queries[i][0]].push_back(queries[i][1] + 1);
    multiset<int> st;
    multiset<int> added;
    int ans = 0;
    int cntop = 0;
    for (int i = 0; i < n; ++i) {
      while (st.size() && *st.begin() <= i) {
        st.erase(st.begin());
      }
      while (added.size() && *added.begin() <= i) {
        added.erase(added.begin());
      }
      for (int r : op[i]) {
        st.insert(r);
      }
      while (added.size() < nums[i]) {
        if (st.empty())
          return -1;
        ++ans;
        added.insert(*prev(st.end()));
        st.erase(prev(st.end()));
      }
    }
    return q - ans;
  }
};
",1460846004
scanhex,scanhex,31,3648,cpp,"
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>> fruits) {
        int n = fruits.size();
        int c = 0;
        for (int i = 0; i < n; ++i) {
            c += fruits[i][i];
            fruits[i][i] = 0;
        }
        const int oo=0x3f3f3f3f;
        vector<vector<int>> dp1(n, vector<int>(n, -oo));
        dp1[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                dp1[i][j] = dp1[i - 1][j] + fruits[i][j];
                if (j - 1 > 0) 
                    dp1[i][j] = max(dp1[i][j], dp1[i - 1][j - 1] + fruits[i][j]);
                if (j + 1 < n)
                    dp1[i][j] = max(dp1[i][j], dp1[i - 1][j + 1] + fruits[i][j]);
            }
        }
        vector<vector<int>>dp2(n, vector<int>(n, -oo));
        dp2[n - 1][0] = fruits[n - 1][0];
        for(int j = 1; j < n; ++j) {
            for (int i = 0; i < n; ++i) {
                dp2[i][j] = dp2[i][j - 1] + fruits[i][j];
                if (i - 1 > 0)
                    dp2[i][j] = max(dp2[i][j], dp2[i - 1][j - 1] + fruits[i][j]);
                if (i + 1 < n)
                    dp2[i][j] = max(dp2[i][j], dp2[i + 1][j - 1] + fruits[i][j]);
            }
        }
        return c + dp1[n - 1][n - 1] + dp2[n - 1][n - 1];
    }
};

",1460812917
lilPeep,stupidRR,32,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0ll;
        for(int i=0;i<s.size();i++)
        {
            int a=s[i]-'a';
            int b=t[i]-'a';
            long long way1=0;
            long long way2=0;
            while(a!=b)
            {
                way1=(way1+nextCost[a]);
                a=(a+1)%26;
            }
            a=s[i]-'a';
            while(a!=b)
            {
                way2=(way2+previousCost[a]);
                a=(a+25)%26;
            }
            ans=ans+std::min(way1,way2);
        }
        return ans;
    }
};",1460819734
lilPeep,stupidRR,32,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn=0;
        int sub=10;
        while(sub>0 && n>=sub)
        {
            n=n-sub;
            sub--;
            turn=1-turn;
        }
        return (turn);
    }
};",1460796737
lilPeep,stupidRR,32,3647,cpp,"// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }


struct segment_change {
    // Use a sentinel value rather than a boolean to save significant memory (4-8 bytes per object).
    static const int SENTINEL = numeric_limits<int>::lowest();

    // Note that to_set goes first, and to_add goes after.
    // TODO: check if these values can overflow int.
    int to_set, to_add;

    // TODO: make sure the default constructor is the identity segment_change.
    segment_change(int _to_add = 0, int _to_set = SENTINEL) : to_set(_to_set), to_add(_to_add) {}

    bool has_set() const {
        return to_set != SENTINEL;
    }

    bool has_change() const {
        return has_set() || to_add != 0;
    }

    // Return the combined result of applying this segment_change followed by `other`.
    // TODO: make sure to check for sentinel values.
    segment_change combine(const segment_change &other) const {
        if (other.has_set())
            return other;

        return segment_change(to_add + other.to_add, to_set);
    }
};

struct segment {
    // TODO: check if these values can overflow int.
    int maximum;
    int64_t sum;
    int first, last, max_diff;

    // TODO: make sure the default constructor is the identity segment.
    segment(int _maximum = numeric_limits<int>::lowest(), int64_t _sum = 0, int _first = 0, int _last = 0,
            int _max_diff = -1) : maximum(_maximum), sum(_sum), first(_first), last(_last), max_diff(_max_diff) {}

    bool empty() const {
        return max_diff < 0;
    }

    void apply(int length, const segment_change &change) {
        if (change.has_set()) {
            maximum = change.to_set;
            sum = int64_t(length) * change.to_set;
            first = last = change.to_set;
            max_diff = 0;
        }

        maximum += change.to_add;
        sum += int64_t(length) * change.to_add;
        first += change.to_add;
        last += change.to_add;
    }

    void join(const segment &other) {
        if (empty()) {
            *this = other;
            return;
        } else if (other.empty()) {
            return;
        }

        maximum = max(maximum, other.maximum);
        sum += other.sum;
        max_diff = max({max_diff, other.max_diff, abs(last - other.first)});
        last = other.last;
    }

    // TODO: decide whether to re-implement this for better performance. Mainly relevant when segments contain arrays.
    void join(const segment &seg0, const segment &seg1) {
        *this = seg0;
        join(seg1);
    }
};

struct seg_tree {
    static int highest_bit(unsigned x) {
        return x == 0 ? -1 : 31 - __builtin_clz(x);
    }

    int tree_n = 0;
    vector<segment> tree;
    vector<segment_change> changes;

    seg_tree(int n = -1) {
        if (n >= 0)
            init(n);
    }

    void init(int n) {
        tree_n = 1;

        while (tree_n < n)
            tree_n *= 2;

        tree.assign(2 * tree_n, {});
        changes.assign(tree_n, {});
    }

    // Builds our tree from an array in O(n).
    void build(const vector<segment> &initial) {
        int n = int(initial.size());
        init(n);
        copy(initial.begin(), initial.end(), tree.begin() + tree_n);

        for (int position = tree_n - 1; position > 0; position--)
            tree[position].join(tree[2 * position], tree[2 * position + 1]);
    }

    void _apply_and_combine(int position, int length, const segment_change &change) {
        tree[position].apply(length, change);

        if (position < tree_n)
            changes[position] = changes[position].combine(change);
    }

    void _push_down(int position, int length) {
        if (changes[position].has_change()) {
            _apply_and_combine(2 * position, length / 2, changes[position]);
            _apply_and_combine(2 * position + 1, length / 2, changes[position]);
            changes[position] = segment_change();
        }
    }

    template<typename T_range_op>
    void _process_range(int position, int start, int end, int a, int b, bool needs_join, T_range_op &&range_op) {
        if (a <= start && end <= b) {
            range_op(position, end - start);
            return;
        }

        if (position >= tree_n)
            return;

        _push_down(position, end - start);
        int mid = (start + end) / 2;
        if (a < mid) _process_range(2 * position, start, mid, a, b, needs_join, range_op);
        if (b > mid) _process_range(2 * position + 1, mid, end, a, b, needs_join, range_op);
        if (needs_join) tree[position].join(tree[2 * position], tree[2 * position + 1]);
    }

    segment query(int a, int b) {
        assert(0 <= a && a <= b && b <= tree_n);
        segment answer;

        _process_range(1, 0, tree_n, a, b, false, [&](int position, int) -> void {
            answer.join(tree[position]);
        });

        return answer;
    }

    segment query_full() const {
        return tree[1];
    }

    segment query_single(int index) {
        assert(0 <= index && index < tree_n);
        int position = tree_n + index;

        for (int up = highest_bit(tree_n); up > 0; up--)
            _push_down(position >> up, 1 << up);

        return tree[position];
    }

    void update(int a, int b, const segment_change &change) {
        assert(0 <= a && a <= b && b <= tree_n);

        _process_range(1, 0, tree_n, a, b, true, [&](int position, int length) -> void {
            _apply_and_combine(position, length, change);
        });
    }

    void update_single(int index, const segment &seg) {
        assert(0 <= index && index < tree_n);
        int position = tree_n + index;

        for (int up = highest_bit(tree_n); up > 0; up--)
            _push_down(position >> up, 1 << up);

        tree[position] = seg;

        while (position > 1) {
            position /= 2;
            tree[position].join(tree[2 * position], tree[2 * position + 1]);
        }
    }

    vector<segment> to_array(int n) {
        for (int i = 1; i < tree_n; i++)
            _push_down(i, tree_n >> highest_bit(i));

        return vector<segment>(tree.begin() + tree_n, tree.begin() + tree_n + n);
    }

    // Finds the end of the last prefix of the subarray [a, b) satisfying `should_join` via binary search in O(log n).
    // Return value will be between a - 1 and b, inclusive.
    template<typename T_bool>
    int find_last_subarray(T_bool &&should_join, int a, int b) {
        assert(0 <= a && a <= b && b <= tree_n);
        segment current;

        // Check the degenerate case.
        if (!should_join(current, current))
            return a - 1;

        return y_combinator([&](auto search, int position, int start, int end) -> int {
            if (end <= a) {
                return end;
            } else if (a <= start && end <= b && should_join(current, tree[position])) {
                current.join(tree[position]);
                return end;
            } else if (end - start == 1) {
                return start;
            }

            _push_down(position, end - start);
            int mid = (start + end) / 2;
            int left = search(2 * position, start, mid);
            return left < mid ? left : search(2 * position + 1, mid, end);
        })(1, 0, tree_n);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n=nums.size();
        vector<int> pre(n+1);

        seg_tree tree(n);
        tree.build(vector<segment>(n, segment(0, 0, 0, 0, 0)));
        for(auto query : queries)
        {
            int l=query[0];
            int r=query[1];
            pre[l]++;
            pre[r+1]--;
            tree.update(l, r+1, segment_change(int(-1)));
        }
        for(int i=1;i<=n;i++)
            pre[i]+=pre[i-1];
        
        for(int i=0;i<n;i++)
        {
            if(nums[i]>pre[i])
                return -1;
            tree.update(i, i+1, segment_change(int( nums[i] )));
        }

        int ans=0;
        sort(queries.begin(),queries.end(),[&](vector<int>&a,vector<int>&b){
            return a[1]<b[1];
        });

        for(auto query : queries)
        {
            int l=query[0];
            int r=query[1];
            tree.update(l, r+1, segment_change(int(1)));
            if(tree.query(l,r+1).maximum <= 0 )
                ans++;
            else
                tree.update(l, r+1, segment_change(int(-1)));
        }

        return ans;
    
    }
};",1460866908
lilPeep,stupidRR,32,3648,cpp,"class Solution {
    int solve(vector<vector<int>>&grid,int row,int col,int type)
    {
        int n=grid.size();
        vector<vector<int>> dp(n,vector<int>(n));
        dp[row][col]=grid[row][col];
        queue< pair<int,int> > bfs;
        bfs.push({row,col});
        int moves=n-1;
        while(moves--)
        {
            set< pair<int,int> > nbfs;
            while( !bfs.empty() )
            {
                auto [row,col]=bfs.front();
                bfs.pop();
                
                if(type==0)
                {
                    for(int j=-1;j<=1;j++)
                    {
                        if( row+j>=0 && row+j<n )
                        {
                            dp[row+j][col+1]=std::max(dp[row+j][col+1],dp[row][col]+grid[row+j][col+1]);
                            nbfs.insert({row+j,col+1});
                        }
                    }
                }
                else
                {
                    for(int j=-1;j<=1;j++)
                    {
                        if( col+j>=0 && col+j<n )
                        {
                            dp[row+1][col+j]=std::max(dp[row+1][col+j],dp[row][col]+grid[row+1][col+j]);
                            nbfs.insert({row+1,col+j});
                        }
                    }
                }
            }
            
            for(auto &[a,b] : nbfs)
                bfs.push({a,b});
        }
        
        return dp[n-1][n-1];
    }
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        long long ans=0ll;
        int n=fruits.size();
        vector<vector<int>> grid(n,vector<int>(n));
        vector<vector<int>> grid2(n,vector<int>(n));
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(i==j)
                    ans=ans+fruits[i][j];
                else if(i>j)
                    grid[i][j]=fruits[i][j];
                else
                    grid2[i][j]=fruits[i][j];
            }
        }
        
        return ans+solve(grid,n-1,0,0)+solve(grid2,0,n-1,1);
    }
};",1460842123
LucasLyu,Lucas595,36,3591,python3,"from typing import List


class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
        
        for i in range(len(s)):
            start_char = s[i]
            end_char = t[i]
            
            forward_distance = (ord(end_char) - ord(start_char)) % 26
            forward_cost = sum(nextCost[(ord(start_char) - ord('a') + j) % 26] for j in range(forward_distance))
            
            backward_distance = (ord(start_char) - ord(end_char)) % 26
            backward_cost = sum(previousCost[(ord(start_char) - ord('a') - j) % 26] for j in range(backward_distance))

            total_cost += min(forward_cost, backward_cost)
        
        return total_cost",1460817689
LucasLyu,Lucas595,36,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        
        stones_to_remove = 10
        alice_turn = True
        
        while n >= 0:
            if n < stones_to_remove:
                return not alice_turn
            n -= stones_to_remove
            stones_to_remove -= 1
            alice_turn = not alice_turn
        
        return True",1460802757
LucasLyu,Lucas595,36,3647,python3,"from typing import List
import heapq

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        q = len(queries)
        
        diff = [0] * (n + 1)
        for query in queries:
            li, ri = query
            diff[li] +=1
            if ri +1 < len(diff):
                diff[ri +1] -=1
        
        coverage = [0] * n
        current = 0
        for j in range(n):
            current += diff[j]
            coverage[j] = current
        
        for j in range(n):
            if coverage[j] < nums[j]:
                return -1
        
        if sum(nums) ==0:
            return q
        
        sorted_queries = sorted(queries, key=lambda x: (x[0], -x[1]))
        
        heap = []
        kept_queries = 0
        delta = [0] * (n + 2)
        coverage_assigned = 0
        q_idx =0
        
        for j in range(n):
            coverage_assigned += delta[j]
            
            while q_idx < q and sorted_queries[q_idx][0] <=j:
                ri = sorted_queries[q_idx][1]
                heapq.heappush(heap, -ri)
                q_idx +=1
            
            while heap and -heap[0] <j:
                heapq.heappop(heap)
            
            needed = nums[j] - coverage_assigned
            if needed >0:
                if len(heap) < needed:
                    return -1 
                
                for _ in range(needed):
                    if not heap:
                        return -1
                    r_i = -heapq.heappop(heap)
                    kept_queries +=1
                    coverage_assigned +=1
                    if j <= r_i:
                        delta[j] +=1
                        delta[r_i +1] -=1
        return q - kept_queries",1460850074
LucasLyu,Lucas595,36,3648,python3,"from typing import List

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        
        sum1 = 0
        for i in range(n):
            sum1 += fruits[i][i]
        
        dp_prev = [-10**9] * n
        dp_prev[n-1] = fruits[0][n-1] if not (0 == n-1 and 0 != n-1) else fruits[0][n-1]
        for t in range(1, n):
            dp_curr = [-10**9] * n
            for j in range(n):
                if j ==t and t !=n-1:
                    fruit = 0
                else:
                    fruit = fruits[t][j]
                for delta_j in (-1,0,1):
                    prev_j = j - delta_j
                    if 0 <= prev_j <n:
                        if dp_prev[prev_j] != -10**9:
                            dp_curr[j] = max(dp_curr[j], dp_prev[prev_j] + fruit)
            dp_prev = dp_curr
        sum2 = dp_prev[n-1]
        
        dp_prev = [-10**9] * n
        dp_prev[n-1] = fruits[n-1][0] if not (n-1 ==0 and 0 !=n-1) else fruits[n-1][0]
        for t in range(1, n):
            dp_curr = [-10**9] * n
            for i in range(n):
                if i ==t and t !=n-1:
                    fruit = 0
                else:
                    fruit = fruits[i][t]
                for delta_i in (-1,0,1):
                    prev_i = i - delta_i
                    if 0 <= prev_i <n:
                        if dp_prev[prev_i] != -10**9:
                            dp_curr[i] = max(dp_curr[i], dp_prev[prev_i] + fruit)
            dp_prev = dp_curr
        sum3 = dp_prev[n-1]
        
        total = sum1 + sum2 + sum3
        total -= 2 * fruits[n-1][n-1]
        
        return total",1460841274
Andrey,A_Le_K,40,3591,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 1
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

inline int toi(char c)
{
    return c-'a';
}
const int A=26;

ll solve(const int from, const int to, vector<int>& nextCost, vector<int>& previousCost)
{
    ll cost1=0, cost2=0;
    
    for(int i=from; i!=to; i=(i+1)%A) {
        cost1+=nextCost[i];
    }
    for(int i=from; i!=to; i=(i-1+A)%A)
    {
        cost2+=previousCost[i];
    }
    
    return min(cost1, cost2);
}

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const int n=s.size();
        ll result=0;
        
        FOR(i, n) {
            const int si=toi(s[i]), ti=toi(t[i]);
            result+=solve(si, ti, nextCost,  previousCost);
        }
        
        return result;
    }
};",1460805889
Andrey,A_Le_K,40,3625,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 1
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif


class Solution {
public:
    bool canAliceWin(int n) {
        for(int d=10; d>=1; d--) {
            if(n<d) 
            {
                if(d%2==0) return false;
                return true;
            }
            else n-=d;
        }
        assert(false);
        return true;
    }
};",1460797670
Andrey,A_Le_K,40,3647,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 0
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif


class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& queries) {
        dbg(""========"");
        const int n=a.size();
        const int q=queries.size();
        vector<pii> lr;
        
        vector<vector<int>> starts_at(n+1);
        
        dbg(n, q);
        
        vector<int> delta(n+1, 0);
        for( auto qq: queries) {
            const int l=qq[0], r=qq[1];
            lr.pb({l, r}); 
            
            delta[l]++;
            delta[r+1]--;
            
            starts_at[l].pb(r);
        }
        
        dbg(delta);
        
        vector<int> S=delta;
        FOR(i, n) {
            S[i+1]+=S[i];
        }
        
        dbg(S);
        
        const int NOANS=-1;
        FOR(i, n) if(a[i]>S[i]) return NOANS;
        
        //int currently_removed=0;
        int min_intervals_to_take=0;
        
        //int balance_intervals=0;
        multiset<int> currently_open_Rs; // Rs of [L, R]
        int balance=0;
        
        vector<int> balance_deltas(n+1, 0);
        
        //for(int i=0; i<n; i)
        FOR(i, n) {
            dbg(i, balance, balance_deltas, currently_open_Rs);
            
            balance-=balance_deltas[i];
            int current_a=a[i]-balance;
            
            for(int r: starts_at[i]) currently_open_Rs.insert(r);
            
            while(current_a>0) {
                assert(!currently_open_Rs.empty());
                auto it=currently_open_Rs.end(); --it;
                int r=*it; currently_open_Rs.erase(it);
                
                balance++;
                current_a--;
                balance_deltas[r+1]++;
                min_intervals_to_take++;
            }
            
            while(!currently_open_Rs.empty())
            {
                auto it=currently_open_Rs.begin();
                if(*it<=i) {
                    currently_open_Rs.erase(it);
                } else break;
            }
        }
        
        dbg(min_intervals_to_take);
        return q-min_intervals_to_take;
        //return -42;
    }
};",1460865068
Andrey,A_Le_K,40,3648,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 0
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif


class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& g) {
        const int n=g.size();
        
        //vector<vector<int>> dp(n, vector<int>(n, 0));
        const ll INF=1e18;
        vector<vector<ll>> dp_up(n, vector<ll>(n, -INF));
        vector<vector<ll>> dp_down(n, vector<ll>(n, -INF));
        
        dbg(""up, down got"");
        
        //auto dp_up=g;
        //auto dp_down=g;
        dp_up[0][n-1]=g[0][n-1];
        dp_down[n-1][0]=g[n-1][0];
        
        FOR(i, n) {
            if(i+1>=n) continue;
            FOR(j, n) {
                const ll curr=dp_up[i][j];
                if(0<=j-1)  domax(dp_up[i+1][j-1], curr+g[i+1][j-1]);
                            domax(dp_up[i+1][j  ], curr+g[i+1][j  ]);
                if(j+1<n)   domax(dp_up[i+1][j+1], curr+g[i+1][j+1]);
            }

        }
        
        dbg(""done up"");
        
        FOR(j, n) {
            if(j+1>=n) continue;
            FOR(i, n) {
                const ll curr=dp_down[i][j];
                if(0<=i-1)  domax(dp_down[i-1][j+1], curr+g[i-1][j+1]);
                            domax(dp_down[i  ][j+1], curr+g[i  ][j+1]);
                if(i+1<n)   domax(dp_down[i+1][j+1], curr+g[i+1][j+1]);
            }            
        }
        
        dbg(""done down"");
        
        ll sum_diag=0;
        FOR(i, n) sum_diag+=g[i][i];
        const ll res1=dp_up[n-2][n-1];
        const ll res2=dp_down[n-1][n-2];
        
        const ll result=sum_diag+res1+res2;
        
        dbg(sum_diag, res1, res2, result);
        
        return result;
    }
};",1460840312
Boris Williams,boriswilliams,47,3591,python3,"def ind(c: str) -> int:
    return ord(c) - 97

class Solution:
    def shiftDistance(self, s: str, t: str, nc: List[int], pc: List[int]) -> int:
        
        cnc = [0]*(2*len(nc))
        for i in range(1, 2*len(nc)):
            cnc[i] = cnc[i-1] + nc[(i-1)%len(nc)]
        cpc = [0]*(2*len(pc))
        for i in range(1, 2*len(pc)):
            cpc[i] = cpc[i-1] + pc[(i)%len(pc)]
        
        r = 0
        for i in range(len(s)):
            j, k = ind(s[i]), ind(t[i])
            if k < j:
                k += 26
            v = cnc[k] - cnc[j]
            j, k = ind(s[i]), ind(t[i])
            if j < k:
                j += 26
            v = min(v, cpc[j] - cpc[k])
            r += v
        return r",1460823160
Boris Williams,boriswilliams,47,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        r = False
        x = 10
        while n >= x:
            n -= x
            x -= 1
            r = not r
        return r",1460796803
Boris Williams,boriswilliams,47,3647,python3,"class Solution:
    def maxRemoval(self, a: List[int], queries: List[List[int]]) -> int:
        n = len(a)
        start = len(queries)
        heapq.heapify(queries) # sorted by smallest start
        available = [] # sorted by largest end
        curr = [] # sorted by smallest end
        used = 0
        for i in range(n):
            while queries and queries[0][0] == i:
                heapq.heappush(available, -heapq.heappop(queries)[1])
            while curr and curr[0] < i:
                heapq.heappop(curr)
            #print(i)
            #print('queries', queries)
            #print('available', available)
            a[i] -= len(curr)
            while a[i] > 0 and available and -available[0] >= i:
                a[i] -= 1
                used += 1
                heapq.heappush(curr, -heapq.heappop(available))
            #print('active', curr)
            if a[i] > 0:
                #print(a, i, a[i])
                return -1
        return start - used",1460867990
Boris Williams,boriswilliams,47,3648,python3,"class Solution:
    def maxCollectedFruits(self, a: List[List[int]]) -> int:
        n = len(a)
        r = 0
        for i in range(n):
            r += a[i][i]
            a[i][i] = 0
        tr = [-1]*n
        tr[-1] = a[0][-1]
        for i in range(1, n):
            temp = [-1]*n
            for j in range(n):
                for k in range(max(j-1, 0), min(j+2, n)):
                    temp[j] = max(temp[j], tr[k])
                if temp[j] != -1:
                    temp[j] += a[i][j]
            tr = temp
        r += tr[-1]
        bl = [-1]*n
        bl[-1] = a[-1][0]
        for j in range(1, n):
            temp = [-1]*n
            for i in range(n):
                for k in range(max(i-1, 0), min(i+2, n)):
                    temp[i] = max(temp[i], bl[k])
                if temp[i] != -1:
                    temp[i] += a[i][j]
            bl = temp
        r += bl[-1]
        return r",1460845473
papapolak,papapolak,49,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        result = 0
        for i in range(1, len(nextCost)):
            nextCost[i] += nextCost[i-1]
            previousCost[i] += previousCost[i-1]
        nextCost.insert(0, 0)
        previousCost.insert(0, 0)
        # print(previousCost)
        for i, (x, y) in enumerate(zip(s, t)):
            if x == y:
                continue
            x = ord(x) - 97
            y = ord(y) - 97
            if x < y:
                res_next = nextCost[y] - nextCost[x]
            else:
                res_next = nextCost[-1] - nextCost[x] + nextCost[y]
            if x > y:
                res_prev = previousCost[x+1] - previousCost[y+1]
            else:
                res_prev = previousCost[x+1] + previousCost[-1] - previousCost[y+1]
            # print(x, y, res_next, res_prev, previousCost[y], previousCost[-1], previousCost[x+1])
            
            #     res_next = sum(nextCost[x:y])
            # else:
            #     res_next = sum(nextCost[x:]) + sum(nextCost[:y])
            # if x > y:
            #     res_prev = sum(previousCost[y+1:x+1])
            # else:
            #     res_prev = sum(previousCost[:x+1]) + sum(previousCost[y+1:])
            result += min(res_next, res_prev)
        return result",1460840275
papapolak,papapolak,49,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i in range(10, 0, -1):
            if n < i:
                return i % 2 == 1
            n -= i
        return False",1460797511
papapolak,papapolak,49,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        backlog = []
        remained = []
        j = 0
        for i in range(len(nums)):
            # print(i)
            while j != len(queries) and queries[j][0] == i:
                heappush(backlog, -queries[j][1])
                j += 1
            while remained and remained[0] < i:
                heappop(remained)
            # print(backlog, remained)
            while nums[i] > len(remained):
                if not backlog or -backlog[0] < i:
                    return -1
                heappush(remained, -heappop(backlog))
        return len(backlog)",1460855512
papapolak,papapolak,49,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        
        result = 0
        for i in range(n):
            result += fruits[i][i]
            
        lst = [fruits[n-1][0]]
        for i in range(1, n-1):
            new_list = [fruits[j][i] for j in range(n-i-1, n)]
            for j in range(len(new_list)):
                new_list[j] += max(lst[max(0, j-2):j+1])
            lst = new_list
        result += lst[-1]
            
        lst = [fruits[0][n-1]]
        for i in range(1, n-1):
            new_list = [fruits[i][j] for j in range(n-i-1, n)]
            for j in range(len(new_list)):
                new_list[j] += max(lst[max(0, j-2):j+1])
            lst = new_list
        result += lst[-1]

        return result",1460875149
sveng101,sveng101,51,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ord_a = ord(""a"")
        def char2Num(l: str) -> int:
            return ord(l) - ord_a

        nxt_arr_cumu = [0]
        prev_arr_cumu = [0]
        for i in range(26):
            nxt_arr_cumu.append(nxt_arr_cumu[-1] + nextCost[i])
            prev_arr_cumu.append(prev_arr_cumu[-1] + previousCost[i])
        #print(nxt_arr_cumu)
        #print(prev_arr_cumu)
        def minCost(l1: str, l2: str) -> int:
            if l1 == l2: return 0
            num1 = char2Num(l1)
            num2 = char2Num(l2)
            #print(l1, num1, l2, num2)
            if num2 > num1:
                nc = nxt_arr_cumu[num2] - nxt_arr_cumu[num1]
                pc = prev_arr_cumu[num1 + 1] + prev_arr_cumu[-1] - prev_arr_cumu[num2 + 1]
            else:
                nc = nxt_arr_cumu[num2] + nxt_arr_cumu[-1] - nxt_arr_cumu[num1]
                pc = prev_arr_cumu[num1 + 1] - prev_arr_cumu[num2 + 1]
            #print(nc, pc)
            return min(nc, pc)

        return sum(minCost(l1, l2) for l1, l2 in zip(s, t))",1460826891
sveng101,sveng101,51,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        diff = 10
        res = True
        while n >= 0:
            n -= diff
            res = not res
            #print(n, res)
            diff -= 1
        return res",1460803276
sveng101,sveng101,51,3647,python3,"import heapq
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        ends_incl_heap = []
        ends_excl_heap = []
        queries.sort()

        n_q = len(queries)
        q_i = 0
        curr_cover = 0
        res = 0
        for i, num in enumerate(nums):
            #print(i, num, q_i, curr_cover)
            while ends_incl_heap and ends_incl_heap[0] < i:
                heapq.heappop(ends_incl_heap)
                curr_cover -= 1
            while q_i < n_q and queries[q_i][0] <= i:
                heapq.heappush(ends_excl_heap, -queries[q_i][1])
                q_i += 1
            #print(ends_excl_heap)
            while curr_cover < num:
                if not ends_excl_heap or -ends_excl_heap[0] < i: return -1
                j = -heapq.heappop(ends_excl_heap)
                heapq.heappush(ends_incl_heap, j)
                res += 1
                curr_cover += 1
            #print(ends_excl_heap)
            #print(ends_incl_heap)
        return n_q - res
                ",1460847198
sveng101,sveng101,51,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        res = sum(fruits[i][i] for i in range(n))

        curr = [fruits[n - 2][n - 1]]
        #print(curr)
        for i1 in reversed(range(n - 2)):
            l = min(len(curr) + 1, i1 + 1)
            i2 = n
            prev = curr
            curr = []
            
            for j in range(l):
                i2 -= 1
                ans = -float(""inf"")
                if j > 0:
                    ans = max(ans, prev[j - 1])
                if j < len(prev):
                    ans = max(ans, prev[j])
                if j + 1 < len(prev):
                    ans = max(ans, prev[j + 1])
                curr.append(ans + fruits[i1][~j])
            #print(curr)
        res += curr[0]

        curr = [fruits[n - 1][n - 2]]
        #print(curr)
        for i1 in reversed(range(n - 2)):
            l = min(len(curr) + 1, i1 + 1)
            i2 = n
            prev = curr
            curr = []
            
            for j in range(l):
                i2 -= 1
                ans = -float(""inf"")
                if j > 0:
                    ans = max(ans, prev[j - 1])
                if j < len(prev):
                    ans = max(ans, prev[j])
                if j + 1 < len(prev):
                    ans = max(ans, prev[j + 1])
                curr.append(ans + fruits[~j][i1])
            #print(curr)
        res += curr[0]

        return res",1460875524
Yifeng,gaoyf1235,52,3591,cpp,"class Solution {
    using ll = long long;
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll res = 0;
        int n = s.size();
        for(int i = 0; i < n; i++){
            if(s[i] != t[i]){
                auto si = s[i] - 'a';
                auto ti = t[i] - 'a';
                ll c1 = 0;
                auto c = si;
                while(c != ti){
                    c1 += nextCost[c];
                    c = (c + 1) % 26;
                }
                ll c2 = 0;
                c = si;
                while(c != ti){
                    c2 += previousCost[c];
                    c = (c + 25) % 26;
                }
                res += min(c1, c2);
            }
        }
        return res;
    }
};",1460811794
Yifeng,gaoyf1235,52,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int t = 0;
        int x = 10;
        while(n >= x){
            t = 1 - t;
            n -= x;
            x--;
        }
        return t == 1;
    }
};",1460797003
Yifeng,gaoyf1235,52,3647,cpp,"class Solution {
    
    template<typename T>
    using MinHeap = priority_queue<T, std::vector<T>, std::greater<T>>;

    template<typename T>
    using MaxHeap = priority_queue<T>;
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        auto mx = max_element(nums.begin(), nums.end());
        vector<vector<int>> lrs(n);
        for(auto& q : queries){
            auto l = q[0];
            auto r = q[1];
            lrs[l].push_back(r);
        }
        int res = 0;
        MaxHeap<int> pq;
        multiset<int> has;
        for(int i = 0; i < n; i++){
            auto x = nums[i];
            for(auto& r : lrs[i]){
                pq.push(r);
            }
            while(has.size() < x && !pq.empty()){
                auto t = pq.top();
                pq.pop();
                if(t >= i){
                    has.insert(t);
                    res++;
                }
            }
            if(has.size() < x) {
                return -1;
            }
            has.erase(i);
        }
        return queries.size() - res;
    }
};",1460846671
Yifeng,gaoyf1235,52,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int res = 0;
        for(int i = 0; i < n; i++){
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<int> dp(n, INT_MIN);
        dp[n-1] = fruits[n-1][0];
        for(int i = 1; i < n; i++){
            vector<int> ndp(n, INT_MIN);
            for(int r = n - 1; r >= 0; r--){
                if(dp[r] == INT_MIN) break;
                for(int k = -1; k <= 1; k++){
                    if(r + k >= 0 && r + k < n){
                        ndp[r+k] = max(ndp[r+k], dp[r] + fruits[r+k][i]);
                    }
                }
            }
            dp = ndp;
        }
        res += dp[n-1];
        
        dp = vector<int>(n, INT_MIN);
        dp[n-1] = fruits[0][n-1];
        for(int i = 1; i < n; i++){
            vector<int> ndp(n, INT_MIN);
            for(int c = n - 1; c >= 0; c--){
                if(dp[c] == INT_MIN) break;
                for(int k = -1; k <= 1; k++){
                    if(c + k >= 0 && c + k < n){
                        ndp[c+k] = max(ndp[c+k], dp[c] + fruits[i][c+k]);
                    }
                }
            }
            dp = ndp;
        }
        res += dp[n-1];
        return res;
        
    }
};",1460869595
joylintp,joylintp,53,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ret = 0;
        vector<long long> preNext(27), prePrev(27);
        for (int i = 1; i <= 26; i++)
        {
            preNext[i] = preNext[i - 1] + nextCost[i - 1];
            prePrev[i] = prePrev[i - 1] + previousCost[i - 1];
        }
        for (int i = 0; i < s.size(); i++)
        {
            long long next = 0, prev = 0;
            if (s[i] < t[i])
            {
                next = preNext[t[i] - 'a'] - preNext[s[i] - 'a'];
                prev = prePrev[26] - (prePrev[t[i] - 'a' + 1] - prePrev[s[i] - 'a' + 1]);
            }
            else if (s[i] > t[i])
            {
                prev = prePrev[s[i] - 'a' + 1] - prePrev[t[i] - 'a' + 1];
                next = preNext[26] - (preNext[s[i] - 'a'] - preNext[t[i] - 'a']);
            }
            else;
            ret += min(prev, next);
        }
        return ret;
    }
};",1460834825
joylintp,joylintp,53,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; ; i--)
        {
            if (n < i)
                return i % 2;
            n -= i;
        }
    }
};",1460814468
joylintp,joylintp,53,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());

        int idx = 0, cur = 0;
        vector<int> cnt(nums.size());
        priority_queue<int> pool;
        for (int i = 0; i < nums.size(); i++)
        {
            while (idx < queries.size() && queries[idx][0] <= i)
                pool.push(queries[idx][1]), idx++;
            while (!pool.empty() && cur < nums[i])
            {
                int x = pool.top();
                pool.pop();
                if (x >= i)
                    cur++, cnt[x]++;
            }
            if (cur < nums[i])
                return -1;
            cur -= cnt[i];
        }

        int ret = queries.size();
        for (int &x : cnt)
            ret -= x;
        return ret;
    }
};",1460851337
joylintp,joylintp,53,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int N = fruits.size(), ret = 0;
        for (int i = 0; i < N; i++)
            ret += fruits[i][i];

        vector<vector<int>> dp(N, vector(N, (int)-1e9));
        dp[N - 1][0] = fruits[N - 1][0];
        for (int j = 1; j < N; j++)
            for (int i = j + 1; i < N; i++)
            {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j]);
                dp[i][j] = max(dp[i][j], dp[i][j - 1] + fruits[i][j]);
                if (i + 1 < N)
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + fruits[i][j]);
            }
        dp[0][N - 1] = fruits[0][N - 1];
        for (int i = 1; i < N; i++)
            for (int j = i + 1; j < N; j++)
            {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j]);
                dp[i][j] = max(dp[i][j], dp[i - 1][j] + fruits[i][j]);
                if (j + 1 < N)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + fruits[i][j]);
            }
        return ret + dp[N - 2][N - 1] + dp[N - 1][N - 2];
    }
};",1460869663
xymabinogi,xymabinogi,54,3591,cpp,"using i64 = long long;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& pre) {
        int n = s.length();
        i64 res = 0;
        for (int i = 0; i < n; i++){
            if (s[i] == t[i]) continue;
            //fwd
            i64 x = 0, y = 0;
            auto v = s[i];
            while(v != t[i]){
                x += nxt[v - 'a'];
                v++;
                if (v > 'z') v = 'a';
            }
            v = s[i];
            while(v != t[i]){
                y += pre[v - 'a'];
                v--;
                if (v < 'a') v = 'z';
            }
            res += min(x, y);
            
            
        }
        return res;
    }
};",1460819488
xymabinogi,xymabinogi,54,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ok = false;
        int v = 10;
        while(true){
            if (n >= v){
                ok ^= 1;
                n -= v;
                v -= 1;
            }
            else return ok;
        }
        return 0;
    }
};",1460796878
xymabinogi,xymabinogi,54,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size();
        priority_queue<int> pq;
        priority_queue<int, vector<int>, greater<int>> used;
        sort(q.begin(), q.end());
        
        int cur = 0;
        int m = q.size();
        int cnt = 0;
        for (int i = 0, j = 0; i < n; i++){
            while(j < m and q[j][0] <= i){
                pq.push(q[j][1]);
                j++;
            }
            while(!used.empty() and used.top() < i){
                cur--;
                used.pop();
            }
            while(cur < nums[i]){
                if (pq.empty() or pq.top() < i) return -1;
                int v = pq.top(); pq.pop();
                cnt++;
                cur++;
                used.push(v);
            }
            //cout << i <<"" ""<< j <<"" ""<< cnt <<"" ""<< cur << ""--\n"";
        }
       // cout << cnt << ""------\n"";
        return m - cnt;
        
    }
};",1460839547
xymabinogi,xymabinogi,54,3648,cpp,"const int INF = 1 << 25;
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& g) {
        int n = g.size();
        vector dp1(n, vector<int>(n, -INF)), dp2(n, vector<int>(n, -INF));
        dp1[n - 1][0] = g[n - 1][0];
        
        for (int j = 1; j < n; j++){
            for (int i = j; i < n; i++){
                dp1[i][j] = (i == j ? 0 : g[i][j]);
                int mx = -INF;
                if (i) mx = max(mx, dp1[i - 1][j - 1]);
                mx = max(mx, dp1[i][j - 1]);
                if (i + 1 < n) mx = max(mx, dp1[i + 1][j - 1]);
                dp1[i][j] += mx;
            }
        }
        
        dp2[0][n - 1] = g[0][n - 1];
        for (int i = 1; i < n; i++){
            for (int j = i; j < n; j++){
                dp2[i][j] = (i == j ? 0 : g[i][j]);
                int mx = -INF;
                if (j) mx = max(mx, dp2[i - 1][j - 1]);
                mx = max(mx, dp2[i - 1][j]);
                if (j + 1 < n) mx = max(mx, dp2[i - 1][j + 1]);
                dp2[i][j] += mx;
            }
        }
        int res = dp1[n - 1][n - 1] + dp2[n - 1][n - 1];
        for (int i = 0; i < n; i++){
            res += g[i][i];
        }
        
        return res;

    }
};",1460863421
washedup,rejudge_thiz,55,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n=s.size();
        using ll=long long;
        array<array<ll,26>,26> f{},b{};
        for(int i=0;i<26;i++){
            for(int j=1;j<26;j++) f[i][(i+j)%26]=f[i][(i+j-1)%26]+nextCost[(i+j-1)%26];
            for(int j=1;j<26;j++) b[i][(i-j+26)%26]=b[i][(i-j+27)%26]+previousCost[(i-j+27)%26];
        }
        ll re = 0;
        for(int i=0;i<n;i++){
            re+=min(f[s[i]-'a'][t[i]-'a'],b[s[i]-'a'][t[i]-'a']);
        }
        return re;
    }
};",1460811816
washedup,rejudge_thiz,55,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i=10,a=true;
        while(n>=i){
            n-=i;
            a=!a;
            i--;
        }
        return !a;
    }
};",1460797732
washedup,rejudge_thiz,55,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(),q=queries.size();
        vector<pair<int,int>> v(q);
        vector<int> seg(2*n);
        auto add = [&](int l,int r){
            for(l+=n,r+=n;l<r;l>>=1,r>>=1){
                if(l&1) seg[l++]++;
                if(r&1) seg[--r]++;
            }
        };
        auto query = [&](int p){
            int re =seg[p+=n];
            while(p>1){
                p>>=1;re+=seg[p];
            }
            return re;
        };
        for(int i=0;i<q;i++) v[i]={queries[i][0],queries[i][1]};
        sort(v.begin(),v.end(),[](auto a,auto b){
            return a.first==b.first ? a.second > b.second : a.first < b.first;
        });
        int id=0;
        auto comp = [](const pair<int,int>& a,const pair<int,int>& b){
            return a.second < b.second;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comp)> pq(comp);
        for(int i=0;i<n;i++){
            while(id < q && v[id].first <= i) pq.push(v[id++]);
            int k = query(i);
            while(k<nums[i] && !pq.empty()){
                auto [l,r] = pq.top();
                pq.pop();
                add(l,r+1);
                if(r>=i) k++;
            }
            if(k<nums[i]) return -1;
        }
        return pq.size();
    }
};",1460828470
washedup,rejudge_thiz,55,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int re=0,n=fruits.size();
        for(int i=0;i<n;i++) re+=fruits[i][i];
        vector<vector<int>> dp1(n,vector<int>(n,-1)),dp2(n,vector<int>(n,-1));
        dp1[0][n-1]=fruits[0][n-1];
        for(int i=0;i+1<n;i++){
            for(int j=n-1;j>i && dp1[i][j]!=-1;j--){
                if(j<n && j>i+1) dp1[i+1][j]=max(dp1[i+1][j],dp1[i][j]+fruits[i+1][j]);
                if(j-1<n && j-1>i+1) dp1[i+1][j-1]=max(dp1[i+1][j-1],dp1[i][j]+fruits[i+1][j-1]);
                if(j+1<n && j+1>i+1) dp1[i+1][j+1]=max(dp1[i+1][j+1],dp1[i][j]+fruits[i+1][j+1]);
            }
        }
        dp2[n-1][0]=fruits[n-1][0];
        for(int i=0;i+1<n;i++){
            for(int j=n-1;j>i && dp2[j][i]!=-1;j--){
                if(j<n && j>i+1) dp2[j][i+1]=max(dp2[j][i+1],dp2[j][i]+fruits[j][i+1]);
                if(j-1<n && j-1>i+1) dp2[j-1][i+1]=max(dp2[j-1][i+1],dp2[j][i]+fruits[j-1][i+1]);
                if(j+1<n && j+1>i+1) dp2[j+1][i+1]=max(dp2[j+1][i+1],dp2[j][i]+fruits[j+1][i+1]);
            }
        }
        return dp1[n-2][n-1]+dp2[n-1][n-2]+re;
    }
};",1460857169
hongyili,hongyili,56,3591,python3,"class Solution:
    def helper(self, f, t):
        key = f, t
        if key in self.mem:
            return self.mem[key]
        p = f
        c = 0
        while p != t:
            c += self.nextCost[p]
            p += 1
            p %= 26
        r = c
        p = f
        c = 0
        while p != t:
            c += self.previousCost[p]
            p -= 1
            p %= 26
        r = min(r, c)
        self.mem[key] = r
        return self.mem[key]
        
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        self.c_to_i = {c: i for i, c in enumerate('abcdefghijklmnopqrstuvwxyz')}
        assert len(self.c_to_i) == 26
        self.nextCost = nextCost
        self.previousCost = previousCost
        self.mem = {}
        rst = 0
        for c1, c2 in zip(s, t):
            rst += self.helper(self.c_to_i[c1], self.c_to_i[c2])
        return rst",1460813574
hongyili,hongyili,56,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rmv = 10
        a = True
        while rmv > 0 and n >= rmv:
            n -= rmv
            rmv -= 1
            a = not a
        return not a
        ",1460796998
hongyili,hongyili,56,3647,python3,"from sortedcontainers import SortedList
import heapq


class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries = [(stt, end) for stt, end in queries]
        queries.sort()
        q = 0
        h = []
        ends = SortedList()
        rr = 0
        for i, v in enumerate(nums):
            j = ends.bisect_left(i)
            already = len(ends) - j
            v -= already
            while q < len(queries) and queries[q][0] <= i:
                heapq.heappush(h, -queries[q][1])
                q += 1
            while v > 0:
                if len(h) == 0 or -h[0] < i:
                    return -1
                end = -heapq.heappop(h)
                v -= 1
                ends.add(end)
                rr += 1
        return len(queries) - rr
                
        ",1460848691
hongyili,hongyili,56,3648,python3,"class Solution:
    def helper(self, i, j):
        key = i, j
        if key in self.mem:
            return self.mem[key]
        if self.n - j > self.n - i:
            self.mem[key] = -float('inf')
            return self.mem[key]
        
        #assert i < self.n
        #assert j < self.n
        
        cur = 0 if i == j else self.fruits[i][j]
        add = 0
        for nj in [j-1, j, j+1]:
            if nj < 0 or nj >= self.n:
                continue
            add = max(add, self.helper(i+1, nj))
        self.mem[key] = cur + add
        return self.mem[key]
    
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        self.fruits = fruits
        self.n = len(fruits)
        self.mem = {(self.n-1, self.n-1): 0}
        rst = self.helper(0, self.n-1)
        
        for i in range(self.n):
            rst += self.fruits[i][i]
            for j in range(i+1, self.n):
                self.fruits[i][j], self.fruits[j][i] = self.fruits[j][i], self.fruits[i][j]
        self.mem = {(self.n-1, self.n-1): 0}
        rst += self.helper(0, self.n-1)
        return rst",1460877113
Dipanshu Pandey,callmepandey,57,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int i = 0;i<s.size();++i) {
            char current = s[i];
            long long forward = 0;
            while(current != t[i]) {
                
                forward += 1ll * nextCost[current - 'a'];
                
                if(current == 'z') current = 'a';
                else current++;
            }
            current = s[i];
            long long backward = 0;
            while(current != t[i]) {
                backward += 1ll * previousCost[current - 'a'];
                if(current == 'a') current = 'z';
                else current--;
            }
            ans += min(forward , backward);
        }
        return ans;
    }
};",1460805413
Dipanshu Pandey,callmepandey,57,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool win = false;
        int current = 10;
        while(n && current <= n) {
            n -= current;
            current--;
            win ^= 1;
        }
        return win;
    }
};",1460796270
Dipanshu Pandey,callmepandey,57,3647,cpp,"template <typename T>
class SegmentTree {
private:
    int n;                      // Size of the input array
    vector<T> arr;              // Input array
    vector<T> tree;             // Segment Tree
    vector<T> lazy;             // Lazy array for postponed updates
    function<T(T, T)> combine;  // Combine function for the segment tree (min)

    // Build the segment tree
    void buildTree(int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }

        int mid = (start + end) / 2;
        buildTree(2 * node, start, mid);
        buildTree(2 * node + 1, mid + 1, end);

        tree[node] = combine(tree[2 * node], tree[2 * node + 1]);
    }

    // Propagate lazy updates to children
    void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node]; // Apply lazy value to the current node

            if (start != end) { // Not a leaf node
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }

            lazy[node] = 0; // Clear lazy value for the current node
        }
    }

    // Update range [l, r] by adding `val` with lazy propagation
    void updateRange(int node, int start, int end, int l, int r, T val) {
        propagate(node, start, end); // Ensure any pending updates are applied

        if (start > end || start > r || end < l) {
            return; // No overlap
        }

        if (start >= l && end <= r) { // Complete overlap
            lazy[node] += val;
            propagate(node, start, end);
            return;
        }

        // Partial overlap
        int mid = (start + end) / 2;
        updateRange(2 * node, start, mid, l, r, val);
        updateRange(2 * node + 1, mid + 1, end, l, r, val);

        tree[node] = combine(tree[2 * node], tree[2 * node + 1]);
    }

    // Query the range [l, r] for the minimum value
    T queryRange(int node, int start, int end, int l, int r) {
        propagate(node, start, end); // Ensure any pending updates are applied

        if (start > end || start > r || end < l) {
            return numeric_limits<T>::max(); // No overlap
        }

        if (start >= l && end <= r) { // Complete overlap
            return tree[node];
        }

        // Partial overlap
        int mid = (start + end) / 2;
        T leftResult = queryRange(2 * node, start, mid, l, r);
        T rightResult = queryRange(2 * node + 1, mid + 1, end, l, r);

        return combine(leftResult, rightResult);
    }

public:
    // Constructor
    SegmentTree(const vector<T>& input, const function<T(T, T)>& combineFunc)
        : combine(combineFunc) {
        n = input.size();
        arr = input;
        tree.resize(4 * n, numeric_limits<T>::max());
        lazy.resize(4 * n, 0);
        buildTree(1, 0, n - 1);
    }

    // Update range [l, r] with value 'val'
    void update(int l, int r, T val) {
        updateRange(1, 0, n - 1, l, r, val);
    }

    // Query range [l, r] for the minimum value
    T query(int l, int r) {
        return queryRange(1, 0, n - 1, l, r);
    }
};

// Usage:
// auto combine = [](int a, int b) { return min(a, b); };
// SegmentTree<int> segmentTree(arr, combine);


class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        
        int n = nums.size();
        vector <int> prefix(n + 1 , 0);
        unordered_map < int , vector <int> > end;
        vector <int> arr(n , 0);
        for(auto &a : queries) {
            
            prefix[a[0]]++;
            prefix[a[1] + 1]--;
            
            end[a[1]].push_back(a[0]);
        }
        
        

        for(int i = 0;i<n;++i) {
            if(i)
                prefix[i] += prefix[i - 1];
            if(prefix[i] < nums[i]) return -1;
            arr[i] = prefix[i] - nums[i];
            
        }
        
        auto combine = [](int a, int b) { return min(a , b); };
        SegmentTree<int> segmentTree(arr, combine);
        
        int ans = 0;
        for(int i = 0;i<n;++i) {
            for(int j : end[i]) {
                int x = segmentTree.query(j , i);
                
                if(x > 0) {
                    ++ans;
                    segmentTree.update(j , i , -1);
                }
            }
        }
        
        return ans;
        
    }
};",1460844671
Dipanshu Pandey,callmepandey,57,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        for(int i = 0;i<n;++i) {
            ans += fruits[i][i];
        }
        vector < vector <int> > dp(n , vector <int> (n , -1));
        int zero = 0, mx = -1e6;
        function < int(int,int) > forDown = [&](int i,int j) -> int{
            
            if(i < 0 or i >= n) return mx;
            if(j < 0 or j >= n) return mx;
            if(i == n - 1 && j == n - 1) return zero;
            if(j == n - 1) return mx;
            if(i == j) return mx;
            int &ans = dp[i][j];
            if(ans != -1) return ans;
            ans = fruits[i][j];
            int xans = max({forDown(i - 1 , j + 1) , forDown(i , j + 1) , forDown(i + 1 , j + 1)});
            ans += xans;
            return ans;
        };
        int ans1 = forDown(n - 1 , 0);
        dp = vector < vector <int> >(n , vector <int> (n , -1));
        function < int(int,int) > forUp = [&](int i,int j) -> int{
            if(i < 0 or i >= n) return mx;
            if(j < 0 or j >= n) return mx;
            if(i == n - 1 && j == n - 1) return zero;
            if(i == n - 1) return mx;
            if(i == j) return mx;
            int &ans = dp[i][j];
            if(ans != -1) return ans;
            ans = fruits[i][j];
            int xans = max({forUp(i + 1 , j - 1) , forUp(i + 1 , j) , forUp(i + 1 , j + 1)});
            ans += xans;
            return ans;
        };
        int ans2 = forUp(0 , n - 1);
        cout << ans1 << ' ' << ans2 << endl;
        return ans + ans1 + ans2;       
    }
};",1460871348
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {

        long long cost = 0;

        for (int i = 0; i < (int) s.size(); i++) {
            long long up = 0;
            {
                int c = s[i] - 'a';
                int goal = t[i] - 'a';
                while (c != goal) {
                    up += nextCost[c];
                    c = (c + 1) % 26;
                }
            }
             long long down = 0;
            {
                int c = s[i] - 'a';
                int goal = t[i] - 'a';
                while (c != goal) {
                    down += previousCost[c];
                    c = (c - 1 + 26) % 26;
                }
            }
            cost += min(up, down);
        }

        return cost;
        
    }
};",1460811196
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        int remove = 10;
        int turn = 0;
        while (true) {
            if (n - remove < 0) {
                return turn;
            }
            n -= remove;
            turn ^= 1;
            --remove;
        }
        
        
    }
};",1460804626
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int best_way = 0;

        multiset<int> can_pick;

        map<int, vector<int> > start;
        map<int, int > remove;
        
        for (auto& arr : queries) {
            int l = arr[0];
            int r = arr[1];
          //  --l; --r;
            start[l].emplace_back(r);
        }
        int active = 0;
        for (int i = 0; i < (int) nums.size(); i++) {

            for (auto& R : start[i]) can_pick.insert(R);
            while (!can_pick.empty() && *can_pick.begin() < i) can_pick.erase(can_pick.begin());
            active -= remove[i];

            if (active < nums[i]) {
                int add = nums[i] - active;
                if (can_pick.size() < add) return -1;
                while (add--) {
                    ++active;
                    ++best_way;
                    auto it = --can_pick.end();
                    remove[*it + 1]++;
                    can_pick.erase(it);
                }
            }
            
        }

        
        
        return (int) queries.size() - best_way;
    }
};",1460832557
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res = 0;
        const int n = (int) fruits.size();
        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector< pair<int, int> > dir;
        vector< vector<int> > dp;

        const int INF = 1e9;
        int f = -1;
        auto calc = [&](auto&& self, int sr, int sc) {
            
            if (f == 0) {
                if (sr <= sc) return 0;
            } else {
                if (sr >= sc) return 0;
            }
            //cout << sr << ' ' << sc << '\n';
            int& res = dp[sr][sc];
            if (~res) return res;
            res = -INF;
            for (auto& [dr, dc] : dir) {
                int nr = sr + dr;
                int nc = sc + dc;
                if (nr < 0 || nr >= n) continue;
                if (nc < 0 || nc >= n) continue;
                res = max(res, self(self, nr, nc));
            }
            res += fruits[sr][sc];
            return res;
        };
        
        auto solve = [&](int sr, int sc) {
            dp = vector< vector<int> > (n, vector<int>(n, -1));
            return calc(calc, sr, sc);
        };
        dir.clear(); dir = { {-1, +1}, {+0 , +1}, {+1 , +1}};
        f = 0;
        int mx1 = solve(n - 1, 0);
        
       // cout << ""GOT IT: "" << mx1 << '\n';
        dir.clear(); dir = { {+1, -1}, {+1 , +0}, {+1 , +1}};
        f = 1;
        int mx2 = solve(0, n - 1);
     //   cout << mx2 << '\n';
        
        res += mx1;
        res += mx2;
        return res;
    }
};",1460865116
tomarin,tomarint,60,3591,rust,"impl Solution {
    pub fn shift_distance(s: String, t: String, next_cost: Vec<i32>, previous_cost: Vec<i32>) -> i64 {
        let s = s.as_bytes();
        let t = t.as_bytes();
        let n = s.len();
        let mut ans = 0;
        let next_cost = next_cost.iter().map(|&x| x as i64).collect::<Vec<i64>>();
        let previous_cost = previous_cost.iter().map(|&x| x as i64).collect::<Vec<i64>>();
        for i in 0..n {
            let mut cur = s[i];
            let mut ans1 = 0;
            while cur != t[i] {
                ans1 += next_cost[(cur - b'a') as usize];
                cur = if cur == b'z' { b'a' } else { cur + 1 };
            }
            let mut ans2 = 0;
            let mut cur = s[i];
            while cur != t[i] {
                ans2 += previous_cost[(cur - b'a') as usize];
                cur = if cur == b'a' { b'z' } else { cur - 1 };
            }
            ans += ans1.min(ans2);
        }
        ans
    }
}",1460821771
tomarin,tomarint,60,3625,rust,"impl Solution {
    pub fn can_alice_win(n: i32) -> bool {
        let mut n = n;
        let mut alice = true;
        for i in 0..10 {
            let take = 10 - i;
            if n >= take {
                n -= take;
                alice = !alice;
                continue;
            }
            break;
        }
        !alice
    }
}",1460800632
tomarin,tomarint,60,3647,rust,"#[derive(Clone)]
struct FenwickTree {
    n: usize,
    data: Vec<i64>,
}
impl FenwickTree {
    fn new(n: usize) -> FenwickTree {
        FenwickTree {
            n: n,
            data: vec![0; n + 1],
        }
    }
    // --- sum ---
    fn add(&mut self, i: usize, x: i64) {
        let mut i = i + 1;
        while i <= self.n {
            self.data[i] += x;
            i += i & i.wrapping_neg();
        }
    }
    fn sum(&self, i: usize) -> i64 {
        let mut i = i + 1;
        let mut s = 0;
        while i > 0 {
            s += self.data[i];
            i -= i & i.wrapping_neg();
        }
        s
    }
}

impl Solution {
    pub fn max_removal(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {
        let n = nums.len();
        let mut ft = FenwickTree::new(n+2);
        let mut queries = queries
            .iter()
            .map(|v| (v[0] as usize, v[1] as i64))
            .collect::<Vec<_>>();
        queries.sort();
        let mut qi = 0;
        let mut que = std::collections::BinaryHeap::new();
        let mut ans = 0;
        for i in 0..n {
            while qi < queries.len() && queries[qi].0 == i {
                que.push(queries[qi].1);
                qi += 1;
            }
            let mut val = nums[i] as i64;
            if val <= ft.sum(i) {
                continue;
            }
            while val > ft.sum(i) {
                if let Some(x) = que.pop() {
                    ft.add(i, 1);
                    ft.add(x as usize + 1, -1);
                    ans += 1;
                } else {
                    return -1;
                }
            }
        }
        queries.len() as i32 - ans
    }
}",1460853746
tomarin,tomarint,60,3648,rust,"impl Solution {
    pub fn max_collected_fruits(fruits: Vec<Vec<i32>>) -> i32 {
        // 
        let n = fruits.len();
        let fruits = fruits.into_iter().map(|v| v.into_iter().map(|v| v as i64).collect::<Vec<_>>()).collect::<Vec<_>>();
        let mut dp = vec![vec![i64::MIN; n]; n];
        dp[0][n-1] = fruits[0][n-1];
        for h in 1..n-1 {
            for w in 0..n {
                let mut max = i64::MIN;
                for i in -1..=1 {
                    let nw = w as i32 + i;
                    if nw < 0 || nw >= n as i32 { continue; }
                    max = max.max(dp[h-1][nw as usize]);
                }
                if max == i64::MIN { continue; }
                dp[h][w] = max + fruits[h][w];
            }
        }
        let ans1 = dp[n-2][n-1];
        let mut ans = ans1;

        // 
        let mut dp = vec![vec![i64::MIN; n]; n];
        dp[n-1][0] = fruits[n-1][0];
        for w in 1..n-1 {
            for h in 0..n {
                let mut max = i64::MIN;
                for i in -1..=1 {
                    let nh = h as i32 + i;
                    if nh < 0 || nh >= n as i32 { continue; }
                    max = max.max(dp[nh as usize][w-1]);
                }
                if max == i64::MIN { continue; }
                dp[h][w] = max + fruits[h][w];
            }
        }
        let ans2 = dp[n-1][n-2];
        let mut ans = ans1 + ans2;
        for i in 0..n {
            ans += fruits[i][i];
        }
        ans as i32
    }
}",1460871745
Jb1u4WvKYq,Jb1u4WvKYq,62,3591,cpp,"typedef long long ll;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        ll num = s.size(), ans=0;
        vector<ll> pren(27),prep(27);
        for(int i=1;i<=26;i++){
            pren[i] = n[i-1]+pren[i-1];
            prep[i] = p[i-1]+prep[i-1];
        }
        for(int i=0;i<num;i++){
            int a =s[i]-'a',b = t[i]-'a';
            ll temp=LLONG_MAX;
            if(a==b) continue;
            if(a<b){
                temp = min(temp,pren[b]-pren[a]);
                temp = min(temp,prep[26]-(prep[b+1]-prep[a+1]));
            }
            else{
                temp = min(temp,prep[a+1]-prep[b+1]);
                temp = min(temp,pren[26]-(pren[a]-pren[b]));
            }
            ans +=temp;
        }
        return ans;
    }
};",1460817703
Jb1u4WvKYq,Jb1u4WvKYq,62,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        return help(n,10);
    }
    bool help(int n,int take){
        if(n<take) return false;
        return !help(n-take,take-1);
    }
};",1460797277
Jb1u4WvKYq,Jb1u4WvKYq,62,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(),ans=0,cur=0,id=0,m =queries.size();
        vector<int> end(n+1);
        priority_queue<int> q;
        sort(queries.begin(),queries.end());
        for(int i=0;i<n;i++){
            cur-=end[i];
            while(id<queries.size()&&queries[id][0]==i){
                q.push(queries[id][1]);
                id++;
            }
            if(nums[i]<=cur) continue;
            else{
                int req = nums[i]-cur;
                while(req){
                    if(q.empty())return -1;
                    int temp = q.top();
                    q.pop();
                    if(temp<i){
                        continue;
                    }
                    req--;
                    end[temp+1]++;
                    ans++;
                    cur++;
                }
            }
        }
        return m-ans;
    }
};",1460850900
Jb1u4WvKYq,Jb1u4WvKYq,62,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ans=0,n = f.size();
        for(int i=0;i<n;i++){
            ans+=f[i][i];
            f[i][i]=0;
        }
        vector<vector<int>> dp(n,vector<int>(n,-1)),dp1(n,vector<int>(n,-1));
        dp[n-1][n-1] = f[n-1][n-1];
        for(int i=n-2;i>=0;i--){
            for(int j=0;j<n;j++){
                int temp=-1;
                if(j+1<n&&dp[i+1][j+1]!=-1) temp = max(temp,dp[i+1][j+1]);
                if(j<n&&dp[i+1][j]!=-1) temp = max(temp,dp[i+1][j]);
                if(j-1>=0&&dp[i+1][j-1]!=-1) temp = max(temp,dp[i+1][j-1]);
                if(temp==-1) dp[i][j]=-1;
                else dp[i][j] =temp+f[i][j];
            }
        }
        dp1[n-1][n-1] = f[n-1][n-1];
        for(int j=n-2;j>=0;j--){
            for(int i=0;i<n;i++){
                int temp=-1;
                if(i+1<n&&dp1[i+1][j+1]!=-1) temp = max(temp,dp1[i+1][j+1]);
                if(i<n&&dp1[i][j+1]!=-1) temp = max(temp,dp1[i][j+1]);
                if(i-1>=0&&dp1[i-1][j+1]!=-1) temp = max(temp,dp1[i-1][j+1]);
                if(temp==-1) dp1[i][j]=-1;
                else dp1[i][j] =temp+f[i][j];
            }
        }
        return dp1[n-1][0]+dp[0][n-1]+ans;
    }
};",1460872254
congthanh2000,congthanh2000,63,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;
            long long w1 = 0, w2 = 0;
            int c1 = s[i] - 'a';
            while (c1 != t[i] - 'a') {
                w1 += nextCost[c1];
                c1 = (c1 + 1) % 26;
            }
            int c2 = s[i] - 'a';
            while (c2 != t[i] - 'a') {
                w2 += previousCost[c2];
                c2 = (c2 + 25) % 26;
            }
            ans += min(w1, w2);
        }
        return ans;
    }
};",1460808152
congthanh2000,congthanh2000,63,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int d = 0, p = 10;
        while (n >= p) {
            n -= p;
            p--;
            d ^= 1;
        }
        return d;
    }
};",1460803183
congthanh2000,congthanh2000,63,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> add(n);
        for (int i = 0; i < queries.size(); i++) {
            int L = queries[i][0], R = queries[i][1], value = 1;
            add[L].push_back(R);
        }
        multiset<int> setR;
        int need = 0;
        vector<int> prefix_sum(n + 1, 0);
        for (int i = 0; i < n; i++) {
            if (i) prefix_sum[i] += prefix_sum[i - 1];
            for (int R : add[i]) {
                setR.insert(R);
            }
            while (setR.size() && *setR.begin() < i) {
                need++;
                setR.erase(setR.begin());
            }
            while (nums[i] > prefix_sum[i] && setR.size()) {
                auto it = setR.end(); it--;
                int R = *it;
                prefix_sum[i]++;
                prefix_sum[R + 1]--;
                setR.erase(it);
            }
            if (nums[i] > prefix_sum[i]) {
                return -1;
            }
        }
        return need + setR.size();
    }
};",1460848922
congthanh2000,congthanh2000,63,3648,cpp,"const int lim = 1e9;
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i = 0; i < n; i++) ans += fruits[i][i];
        fruits[n - 1][n - 1] = 0;
        vector<vector<int>> dp(n, vector<int>(n, -lim));
        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 0; j < n; j++) {
            for (int i = n - 1; i >= 0; i--) {
                if (dp[i][j] >= 0) {
                    for (int dx = -1; dx <= 1; dx++) {
                        int ni = i + dx;
                        int nj = j + 1;
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n && (nj < ni || (nj == n - 1 && ni == n - 1))) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + fruits[ni][nj]);
                        }
                    }
                }
            }
        }
        ans += dp[n - 1][n - 1];
        dp = vector<vector<int>>(n, vector<int>(n, -lim));
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 0; i < n; i++) {
            for (int j = n - 1; j >= 0; j--) {
                if (dp[i][j] >= 0) { 
                    for (int dy = -1; dy <= 1; dy++) {
                        int ni = i + 1;
                        int nj = j + dy;
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n && (nj > ni || (nj == n - 1 && ni == n - 1))) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + fruits[ni][nj]);
                        }
                    }
                }
            }
        }
        return ans + dp[n - 1][n - 1];
    }
};",1460865946
Kiril Minkov,xmentex,64,3591,golang,"func shiftDistance(s string, t string, nextCost []int, prevCost []int) int64 {
    res := int64(0)
    
    for i := 0; i < len(s); i++ {
        v := int(s[i] - 'a')
        u := int(t[i] - 'a')
        
        if u == v {
            continue
        }
        x := int64(0)
        for i := 0; i <= 26; i++ {
            x += int64(nextCost[ (v + i) % 26 ])
            if (v + i + 1) % 26 == u {
                break
            }
        }
        y := int64(0)
        for i := 0; i <= 26; i++ {
            y += int64(prevCost[ v ])
            v--
            if v < 0 {
                v = 25
            }
            if v == u {
                break
            }
        }
        
        res += min(x, y)        
    }
    
    return res
}",1460850289
Kiril Minkov,xmentex,64,3625,golang,"func canAliceWin(n int) bool {
    for i := 10; i >= 1; i-- {
        if n < i {
            return i % 2 == 1
        }
        n -= i
    }   
    return false
}",1460850464
Kiril Minkov,xmentex,64,3647,golang,"
import (
	""container/heap""
)

type item struct {
	item  Item
	index int
}

type heapImpl struct {
	p               *pq
	items           map[interface{}]*item
	key             func(Item) interface{}
	DisableIndexing bool
}

func (h *heapImpl) Push(i Item) {
	it := &item{i, 0}
	h.addItem(it)
	heap.Push(h.p, it)
}

func (h *heapImpl) Pop() Item {
	res := heap.Pop(h.p).(*item)
	h.removeItem(res.item)
	return res.item
}

func (h *heapImpl) Top() Item {
	if len(h.p.items) > 0 {
		return h.p.items[0].item
	}
	return nil
}

func (h *heapImpl) Len() int {
	return len(h.p.items)
}

func (h *heapImpl) Update(o Item, n Item) {
	old := h.items[h.key(o)]
	new := &item{n, old.index}
	h.removeItem(old.item)
	h.p.items[old.index] = new
	heap.Fix(h.p, old.index)
	h.addItem(new)
}

func (h *heapImpl) Remove(i Item) {
	index := h.items[h.key(i)].index
	h.removeItem(i)
	heap.Remove(h.p, index)
}

func (h *heapImpl) Get(key interface{}) Item {
	return h.items[key].item
}

func (h *heapImpl) removeItem(item Item) {
	if !h.DisableIndexing {
		delete(h.items, h.key(item))
	}
}

func (h *heapImpl) addItem(item *item) {
	if !h.DisableIndexing {
		h.items[h.key(item.item)] = item
	}
}

// A PriorityQueue implements heap.Interface and holds Items.
type pq struct {
	items []*item
}

func (pq pq) Len() int { return len(pq.items) }

func (pq pq) Less(i, j int) bool {
	// We want Pop to give us the highest, not lowest, priority so we use greater than here.
	return pq.items[i].item.Compare(pq.items[j].item)
}

func (pq pq) Swap(i, j int) {
	pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
	pq.items[i].index = i
	pq.items[j].index = j
}

func (pq *pq) Push(x interface{}) {
	n := len(pq.items)
	item := x.(*item)
	item.index = n
	pq.items = append(pq.items, item)
}

func (pq *pq) Pop() interface{} {
	old := pq.items
	n := len(old)
	item := old[n-1]
	old[n-1] = nil  // avoid memory leak
	item.index = -1 // for safety
	pq.items = old[0 : n-1]
	return item
}

func NewHeapWithKey(getKey func(Item) interface{}) Heap {
	return &heapImpl{
		&pq{
			[]*item{},
		},
		make(map[interface{}]*item),
		getKey,
		false,
	}
}

func NewHeap() Heap {
	return NewHeapWithKey(func(i Item) interface{} { return i })
}

type Item interface {
	Compare(left Item) bool
}

type Heap interface {
	Push(i Item)
	Pop() Item
	Top() Item
	Len() int
	Update(old Item, new Item)
	Remove(item Item)
	Get(key interface{}) Item
}

type MinInt int

func (i MinInt) Compare(j Item) bool {
	return i < j.(MinInt)
}

type MaxInt int

func (i MaxInt) Compare(j Item) bool {
	return i > j.(MaxInt)
}

func maxRemoval(nums []int, queries [][]int) int {
    n := len(nums)
    q := make([][]int, n)  
    e := make([]int, n)
    for _, v := range queries {
        q[v[0]] = append(q[v[0]], v[1])     
    }
    
    h := NewHeap()
    
    res := 0
    
    cur := 0
    for i := 0; i < n; i++ {
        for _, v := range q[i] {
            h.Push(MaxInt(v))
        }
        
        for cur < nums[i] {
            if h.Len() == 0 {
                return -1
            }
            v := int(h.Pop().(MaxInt))
            if v < i {
                continue
            } 
            res++
            e[v]++
            cur++
        }
        
        cur -= e[i]
    }
    
    return len(queries) - res
}",1460850079
Kiril Minkov,xmentex,64,3648,golang,"func maxCollectedFruits(arr [][]int) int {
    res := 0
    n := len(arr)
    for i := 0; i < n; i++ {
        res += arr[i][i]
    }
    
    f := make([][]int, n)
    for i := 0; i < n; i++ {
        f[i] = make([]int, n)
        for j := 0; j < n; j++ {
            f[i][j] = -1
        }
    }
    
    f[0][n-1] = arr[0][n-1]
    for i := 1; i < n; i++ {
        for j := i + 1; j < n; j++ {
            if f[i-1][j] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j] + arr[i][j]) 
            }
            if j - 1 >= 0 && f[i-1][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j-1] + arr[i][j])
            }
            if j + 1 < n && f[i-1][j+1] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j+1] + arr[i][j])   
            }
        }
    }
    res += f[n-2][n-1]
    
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            f[i][j] = -1
        }
    }
    
    f[n-1][0] = arr[n-1][0]
    
    for j := 1; j < n ; j++ {
        for i := j; i < n; i++ {
            if f[i][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i][j-1] + arr[i][j])
            } 
            if i - 1 >= 0 && f[i-1][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j-1] + arr[i][j])
            }
            if i + 1 < n && f[i+1][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i+1][j-1] + arr[i][j])
            }
        } 
    }
    
    res += f[n-1][n-2]
    
    return res
}",1460878838
kasi nathan,kasinathansj,65,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        for(int i = 0 ; i < s.length() ; i++){
            int c1 = s.charAt(i)-'a';
            int c2 = t.charAt(i)-'a';
            int p1 = c1;
            long ans1 = 0;
            while(p1!=c2){
                ans1 += nextCost[p1];
                p1 = (p1+1)%26;
            }
            int p2 = c1;
            long ans2 = 0;
            while(p2!=c2){
                ans2 += previousCost[p2];
                p2 = (p2-1+26)%26;
            }
            // System.out.println(ans1+"" ""+ans2);
            ans += Math.min(ans1 , ans2);
        }
        return ans;
    }
}",1460810863
kasi nathan,kasinathansj,65,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int a = 1;
        int can = 10;
        while(n-can>=0&&can>0){
            n-=can;
            a++;
            can--;
        }
        if(a%2==0)return true;
        return false;
    }
}",1460797014
kasi nathan,kasinathansj,65,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries,(a,b)->{
            return a[0]-b[0];
        });
        int ans = 0;
        PriorityQueue<int[]> pq1 = new PriorityQueue<>((a,b)->b[1]-a[1]);
        PriorityQueue<int[]> pq2 = new PriorityQueue<>((a,b)->a[1]-b[1]);
        int p = 0;
        int ap = 0;
        // for(int a[] : queries){
        //     System.out.println(Arrays.toString(a));
        // }
        for(int i : nums){
            while(ap<queries.length&&queries[ap][0]<=p&&queries[ap][1]>=p){
                pq1.add(queries[ap++]);
            }
            while(pq2.size()!=0&&pq2.peek()[1] < p){
                pq2.remove();
            }
            i -= pq2.size();
            while(pq1.size()!=0&&i>0){
                if(pq1.peek()[1]>=p){
                    pq2.add(pq1.poll());
                    ans++;
                    i--;
                }else{
                    return -1;
                }
            }
            // System.out.println(pq1.size()+"" ""+pq2.size()+"" ""+i);
            if(i>0)return -1;
            p++;
        }
        return queries.length-ans;
    }
}",1460851010
kasi nathan,kasinathansj,65,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int ans = 0;
        for(int i = 0 ; i < fruits.length ; i++){
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        int dp1[] = new int[fruits.length];
        int dp2[] = new int[fruits.length];
        int n = fruits.length;
        dp1[fruits.length-1] = fruits[0][fruits.length-1];
        for(int i = 1 ; i < fruits.length ; i++){
            int d1 = Math.min(i,n-i);
            for(int j = 0 ; j <= d1 ; j++){
                int sum1 = 0;
                int sum2 = 0;
                int sum3 = 0;
                int ind = n-1-j;
                if(ind-1>=0)sum1 = dp1[ind-1];
                if(ind+1<n)sum2 = dp1[ind+1];
                sum3 = dp1[ind];
                dp2[ind] = Math.max(sum1 , Math.max(sum2,sum3));
                dp2[ind] += fruits[i][ind];
            }
            int pre[] = dp1;
            dp1 = dp2;
            dp2 = pre;
            Arrays.fill(dp2,0);
        }
        ans += dp1[n-1];
        Arrays.fill(dp1,0);
        dp1[n-1] = fruits[n-1][0];
        for(int i = 1 ; i < fruits.length ; i++){
            int d1 = Math.min(i,n-i);
            for(int j = 0 ; j <= d1 ; j++){
                int sum1 = 0;
                int sum2 = 0;
                int sum3 = 0;
                int ind = n-1-j;
                if(ind-1>=0)sum1 = dp1[ind-1];
                if(ind+1<n)sum2 = dp1[ind+1];
                sum3 = dp1[ind];
                dp2[ind] = Math.max(sum1 , Math.max(sum2,sum3));
                dp2[ind] += fruits[ind][i];
            }
            int pre[] = dp1;
            dp1 = dp2;
            dp2 = pre;
            Arrays.fill(dp2,0);
            // System.out.println(Arrays.toString(dp1));
        }
        ans += dp1[n-1];
        return ans;
    }
}",1460878854
Mac,cowmane,67,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = (int)s.size();
        long long ans = 0;
        for (int i=0; i<n; i++) {
            long long up_cost = 0;
            for (int j=s[i]-'a'; j!=t[i]-'a'; j = (j+1)%26) {
                up_cost += nextCost[j];
            }
            long long down_cost = 0;
            for (int j=s[i]-'a'; j!=t[i]-'a'; j = (j-1+26)%26) {
                down_cost += previousCost[j];
            }
            ans += min(up_cost, down_cost);
        }
        return ans;
    }
};",1460811885
Mac,cowmane,67,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i=10; i>=1; i--) {
            if (n<i) {
                return i%2==1;
            }
            n -= i;
        }
        return false;
    }
};",1460804734
Mac,cowmane,67,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> query_ends(n);
        for (auto query : queries) {
            query_ends[query[0]].push_back(query[1]);
        }
        vector<int> diff(n+1);
        int cur_diff = 0;
        
        
        multiset<int> ms;
        int used = 0;
        for (int i=0; i<n; i++) {
            cur_diff += diff[i]; // update difference array
            nums[i] += cur_diff; // use active queries
            for (int e : query_ends[i]) {
                ms.insert(e);
            }
            while (nums[i]>0) {
                while (!ms.empty() && *ms.begin() < i) {
                    ms.erase(ms.begin());
                }
                if (ms.empty()) {
                    return -1; // cant use anything
                }
                int mx = *ms.rbegin();
                cur_diff--;
                nums[i]--;
                diff[mx+1]++;
                ms.erase(ms.find(mx));
                used++;
            }
        }
        return queries.size() - used;
    }
};",1460826361
Mac,cowmane,67,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int score = 0; // forced moves diagonal
        for (int i=0; i<n; i++) {
            score += fruits[i][i];
            fruits[i][i] = 0;
        }
        // Solve horizontal guy
        vector<int> dp(n,-1e9);
        dp[n-1] = fruits[n-1][0];
        for (int c=1; c<n; c++) {
            vector<int> ndp(n,-1e9);
            for (int r=0; r<n; r++) {
                ndp[r] = dp[r]+fruits[r][c];
                if (r>0) {
                    ndp[r] = max(ndp[r], dp[r-1]+fruits[r][c]);
                }
                if (r<n-1) {
                    ndp[r] = max(ndp[r], dp[r+1]+fruits[r][c]);
                }
            }
            swap(dp,ndp);
        }
        score += dp[n-1];
        
        // Solve vertical guy
        dp = vector<int>(n,-1e9);
        dp[n-1] = fruits[0][n-1];
        for (int r=1; r<n; r++) {
            vector<int> ndp(n,-1e9);
            for (int c=0; c<n; c++) {
                ndp[c] = dp[c]+fruits[r][c];
                if (c>0) {
                    ndp[c] = max(ndp[c], dp[c-1]+fruits[r][c]);
                }
                if (c<n-1) {
                    ndp[c] = max(ndp[c], dp[c+1]+fruits[r][c]);
                }
            }
            swap(dp,ndp);
        }
        score += dp[n-1];
        
        return score;
    }
};",1460860390
Xiaomeng Yang,yangxm,69,3591,cpp,"using i64 = long long;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
      int n = s.length();
      i64 ret = 0;
      for (int i = 0; i < n; ++i) {
        int u = s[i] - 'a', v = t[i] - 'a';
        i64 x = 0, y = 0;
        for (int j = u; j != v; j = (j + 1) % 26) {
          x += (i64)nextCost[j];
        }
        for (int j = u; j != v; j = (j + 25) % 26) {
          y += (i64)previousCost[j];
        }
        ret += min(x, y);
      }
      return ret;
    }
};",1460805505
Xiaomeng Yang,yangxm,69,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
      int ret = 0, cur = 10;
      while (n >= cur) {
        n -= cur;
        ret ^= 1;
        --cur;
      }
      return ret;
    }
};",1460797491
Xiaomeng Yang,yangxm,69,3647,cpp,"#define X first
#define Y second

using Pii = pair<int, int>;

constexpr int MAX = 200010;

struct SegmentTree {
  int c[MAX << 1], cap;

  void Reset(int n) {
    for (cap = 1; cap < n; cap <<= 1);
    fill(c, c + cap * 2, 0);
  }

  void Update(int k, int v) {
    k += cap;
    for (c[k] += v; k > 1; k >>= 1) {
      c[k >> 1] = c[k] + c[k ^ 1];
    }
  }

  int Query(int l, int r) const {
    int ret = 0;
    l += cap;
    r += cap;
    while (l < r) {
      if (l & 1) {
        ret += c[l++];
      }
      if (r & 1) {
        ret += c[--r];
      }
      l >>= 1;
      r >>= 1;
    }
    return ret;
  }
} st;

int a[MAX];
Pii q[MAX];
map<Pii, int> mp;

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
      int n = nums.size(), m = 0, k = queries.size(), ret = 0;
      for (int i = 0; i < n; ++i) {
        a[i] = nums[i];
        m = max(m, a[i]);
      }
      for (int i = 0; i < k; ++i) {
        q[i] = make_pair(queries[i][0], queries[i][1] + 1);
      }
      sort(q, q + k);
      st.Reset(n + 1);
      mp.clear();
      int p = 0;
      for (int i = 0; i < n; ++i) {
        int cur = st.Query(0, i + 1);
        for (; p < k && q[p].X <= i; ++p) {
          ++mp[make_pair(q[p].Y, q[p].X)];
        }
        int d = max(a[i] - cur, 0);
        for (int j = 0; j < d; ++j) {
          auto it = mp.end();
          if (it == mp.begin()) {
            return -1;
          }
          --it;
          auto [rr, ll] = it->X;
          if (rr <= i) {
            return -1;
          }
          st.Update(ll, 1);
          st.Update(rr, -1);
          if (!(--it->Y)) {
            mp.erase(it);
          }
        }
        ret += d;
      }
      return k - ret;
    }
};",1460848501
Xiaomeng Yang,yangxm,69,3648,cpp,"constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;

int mat[MAX][MAX], dp[2][MAX];

int Calc1(int n) {
  int x = 0;
  fill(dp[0], dp[0] + n, -INF);
  dp[0][n - 1] = mat[0][n - 1];
  for (int i = 1; i < n; ++i) {
    x ^= 1;
    fill(dp[x], dp[x] + n, -INF);
    for (int j = i; j < n; ++j) {
      int cur = max(dp[x ^ 1][j - 1], dp[x ^ 1][j]);
      if (j < n - 1) {
        cur = max(cur, dp[x ^ 1][j + 1]);
      }
      dp[x][j] = cur + mat[i][j];
    }
  }
  return dp[x][n - 1];
}

int Calc2(int n) {
  int x = 0;
  fill(dp[0], dp[0] + n, -INF);
  dp[0][n - 1] = mat[n - 1][0];
  for (int i = 1; i < n; ++i) {
    x ^= 1;
    fill(dp[x], dp[x] + n, -INF);
    for (int j = i; j < n; ++j) {
      int cur = max(dp[x ^ 1][j - 1], dp[x ^ 1][j]);
      if (j < n - 1) {
        cur = max(cur, dp[x ^ 1][j + 1]);
      }
      dp[x][j] = cur + mat[j][i];
    }
  }
  return dp[x][n - 1];
}

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
      int n = fruits.size(), ret = 0;
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
          mat[i][j] = fruits[i][j];
        }
        ret += mat[i][i];
        mat[i][i] = 0;
      }
      int x = Calc1(n);
      ret += x;
      int y = Calc2(n);
      ret += y;
      return ret;
    }
};",1460868486
Agnibha Chakraborty,zanj0,70,3591,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	lli GetNextCost(lli from, lli to, vector<int>& cost) {
		lli ret = 0;
		while (from != to) {
			ret += cost[from];
			from += 1;
			from %= (lli)cost.size();
		}
		return ret;
	}

	lli GetPrevCost(lli from, lli to, vector<int>& cost) {
		lli ret = 0;
		while (from != to) {
			ret += cost[from];
			from -= 1;
			from += (lli)cost.size();
			from %= (lli)cost.size();
		}
		return ret;
	}
	long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
		lli ret = 0;
		for (int i = 0; i < s.size(); i++) {
			lli from = s[i] - 'a';
			lli to = t[i] - 'a';
			ret += min(GetNextCost(from, to, nextCost), GetPrevCost(from, to, previousCost));
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460806012
Agnibha Chakraborty,zanj0,70,3625,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	bool canAliceWin(int n) {
		bool alice = true;
		int curr = 10;
		while (1) {
			if (curr > n) {
				return !alice;
			}
			n -= curr;
			curr--;
			alice = !alice;
		}
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460796374
Agnibha Chakraborty,zanj0,70,3647,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

class SegmentTree {
public:
	lli* tree;
	lli* lazy;
	SegmentTree(lli n) {
		tree = new lli[4 * n + 5]();
		lazy = new lli[4 * n + 5]();
        
	}
	lli left(lli x) {
		return 2 * x + 1;
	}
	lli right(lli x) {
		return 2 * x + 2;
	}
	lli operate(lli a, lli b) {
		return max(a, b);
	}
	void pull(lli node) {
		tree[node] = operate(tree[left(node)], tree[right(node)]);
	}
	void push(lli low, lli high, lli node) {
		if (lazy[node]!=0 ) {
            // cout << node << "" ->"" << lazy[node]<< endl;
			tree[node] += lazy[node];
		}
		if (low != high) {
			lazy[left(node)] += lazy[node];
			lazy[right(node)] += lazy[node];
		}
		lazy[node] = 0;
	}
	void buildTree(lli low, lli high, lli node, vector <int>& arr) {
		if (low == high) {
            // cout << low << "" "" << arr[low] << endl;
			tree[node] = arr[low];
			return;
		}
		lli mid = low + (high - low) / 2;
		buildTree(low, mid, left(node), arr);
		buildTree(mid + 1, high, right(node), arr);
		pull(node);
	}
	lli query(lli low, lli high, lli node, lli qlow, lli qhigh) {
		push(low, high, node);
		if (qlow > high || qhigh < low) return INT_MIN;
		if (qlow <= low && qhigh >= high) {
			return tree[node];
		}
		lli mid = low + (high - low) / 2;
		lli l = query(low, mid, left(node), qlow, qhigh);
		lli r = query(mid + 1, high, right(node), qlow, qhigh);
		return operate(l, r);
	}
	void update(lli low, lli high, lli node, lli ulow, lli uhigh, lli val) {
		push(low, high, node);
		if (ulow > high || uhigh < low) return;
		if (ulow <= low && uhigh >= high) {
			lazy[node] += val;
			push(low, high, node);
			return;
		}
		lli mid = low + (high - low) / 2;
		update(low, mid, left(node), ulow, uhigh, val);
		update(mid + 1, high, right(node), ulow, uhigh, val);
		pull(node);

	}

};
struct Data {
	int first_pt, second_pt, open;

};
class Solution {
public:
	int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
		int ret = 0;
		int n = nums.size();
		vector<Data> v;
		vector<vector<int>> open(n), close(n);
		for (auto& it : queries) {
			open[it[0]].pb(it[1]);
			close[it[1]].pb(it[0]);
		}
		for (int i = 0; i < n; i++)sort(close[i].begin(), close[i].end());
		SegmentTree segment_tree = SegmentTree(n);
		segment_tree.buildTree(0, n - 1, 0, nums);
        // cout << ""YES""
		for (int i = 0; i < n; i++) {
			for (auto& it : open[i]) {
                // cout <<  segment_tree.query(0, n - 1, 0, i, it) << endl;
                
				segment_tree.update(0, n - 1, 0, i, it, -1);
                // cout << ""Update: ""  << i << ""  "" << it << endl;
                // cout <<  segment_tree.query(0, n - 1, 0, i, it) << endl;
			}
			for (auto& it : close[i]) {
                lli q = segment_tree.query(0, n - 1, 0, it, i);
                // cout << it << "" "" << i << "" "" << q << endl;
				if (q < 0) {
					segment_tree.update(0, n - 1, 0, it, i, 1);
					ret++;
				}
			}
		}
		return segment_tree.query(0, n - 1, 0, 0, n - 1) > 0 ?-1:ret;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460853782
Agnibha Chakraborty,zanj0,70,3648,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e4

typedef long long int lli;

class Solution {
public:
	lli n;
	lli Dfs1(lli i, lli j, vector<vector<int>>& grid, vector<vector<lli>>& dp) {
		if (i == n - 1) {
			return j == n - 1 ? grid[i][j] : -inf;
		}
		if (i < 0 || i >= n || j < 0 || j >= n)return -inf;
		if (dp[i][j] != -1) return dp[i][j];
		lli ret = 0;
		ret = grid[i][j] + Dfs1(i + 1, j - 1, grid, dp);
		ret = max(ret, grid[i][j] + Dfs1(i + 1, j , grid, dp));
		ret = max(ret, grid[i][j] + Dfs1(i + 1, j + 1 , grid, dp));
		return dp[i][j] = ret;
	}

	lli Dfs2(lli i, lli j, vector<vector<int>>& grid, vector<vector<lli>>& dp) {
		if (j == n - 1) {
			return i == n - 1 ? grid[i][j] : -inf;
		}
		if (i < 0 || i >= n || j < 0 || j >= n)return -inf;
		if (dp[i][j] != -1) return dp[i][j];
		lli ret = 0;
		ret = grid[i][j] + Dfs2(i - 1, j + 1, grid, dp);
		ret = max(ret, grid[i][j] + Dfs2(i, j + 1 , grid, dp));
		ret = max(ret, grid[i][j] + Dfs2(i + 1, j + 1 , grid, dp));
		return dp[i][j] = ret;
	}
	int maxCollectedFruits(vector<vector<int>>& fruits) {
		lli ret = 0;
		n = fruits.size();
		for (int i = 0; i < n; i++)ret += fruits[i][i];

		vector<vector<int>> grid1 = fruits;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (j <= i) grid1[i][j] = -inf;
			}
		}
		grid1[n - 1][n - 1] = 0;

		vector<vector<int>> grid2 = fruits;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (j >= i) grid2[i][j] = -inf;
			}
		}
		grid2[n - 1][n - 1] = 0;
		vector<vector<lli>> dp1(n, vector<lli>(n, -1));
		vector<vector<lli>> dp2(n, vector<lli>(n, -1));

		lli value1 = Dfs1(0, n - 1, grid1, dp1);
		lli value2 = Dfs2(n - 1, 0, grid2, dp2);
		// cout << ret << "" "" << value1 << "" "" << value2 << endl;
		return ret + value1 + value2;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460882775
Javier,JavOliva,71,3591,cpp,"typedef long long ll;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        ll best_cost = 0;
        for (int i = 0; i < n; i ++){
            char a1 = s[i];
            char a2 = s[i];
            ll c1 = 0, c2 = 0;
            while(a1 != t[i]){
                c1 += nextCost[a1 - 'a'];
                a1 ++;
                if (a1 == 'z' + 1)
                    a1 = 'a';
            }
            while(a2 != t[i]){
                c2 += previousCost[a2 - 'a'];
                a2 --;
                if (a2 + 1 == 'a')
                    a2 = 'z';
            }
            best_cost += min(c1, c2);
        }
        return best_cost;
    }
};",1460811061
Javier,JavOliva,71,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10;
        while(n >= remove and remove > 0){
            n -= remove;
            remove --;
        }
        return remove % 2 != 0;
    }
};",1460799708
Javier,JavOliva,71,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();
        priority_queue<int> pq;
        vector<vector<int> > weas(n + 1);
        for (int i = 0; i < q; i ++){
            int l = queries[i][0];
            int r = queries[i][1];
            weas[l].push_back(r);
        }
        vector<int> sumas(n + 1);
        int j = 0;
        int eliminados = 0;
        for (int i = 0; i < n; i ++){
            if (i > 0)
                sumas[i] += sumas[i - 1];
            for (int r : weas[i])
                pq.push(r);
            while (nums[i] - sumas[i] > 0){
                if (pq.empty()){
                    return -1;
                }
                int r = pq.top();
                pq.pop();
                if (r < i){
                    continue;
                }
                sumas[i] ++;
                sumas[r + 1] --;
            }
        }
        return pq.size();
    }
};",1460832462
Javier,JavOliva,71,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int sum = 0;
        int n = fruits.size();
        for (int i = 0; i < n; i ++){
            sum += fruits[i][i];
            fruits[i][i] = 0;
        }
        auto solve = [&](){
            vector<vector<int> > dp(n, vector<int>(n));
            vector<vector<bool> > usable(n, vector<bool>(n));
            int lim = 0;
            for (int i = n - 1; i >= 0; i --){
                for (int j = lim; j < n - lim; j ++){
                    usable[j][i] = 1;
                }
                lim ++;
            }
            // for (int i = 0; i < n; i ++){
            //     for (int j = 0; j < n; j ++){
            //         if (usable[i][j]){
            //             cout << ""1 "";
            //         }
            //         else{
            //             cout << ""0 "";
            //         }
            //     }
            //     cout << endl;
            // }
            for (int i = n - 1; i >= 0; i --){
                for (int j = 0; j < n; j ++){
                    if (usable[i][j]){
                        dp[i][j] += fruits[i][j];
                        if (i == n - 1)
                            continue;
                        for (int k = -1; k <= 1; k ++){
                            if (j + k >= 0 and j + k < n and usable[i + 1][j + k])
                                dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i + 1][j + k]);
                        }
                        
                    }
                }
            }
            // for (int i = 0; i < n; i ++){
            //     for (int j = 0; j < n; j ++){
            //         cout << dp[i][j] << "" "";
            //     }
            //     cout << endl;
            // }
            return dp[0][n - 1];
        };
        sum += solve();
        vector<vector<int> > fruits2(n, vector<int>(n));
        for (int i = 0; i < n; i ++){
            for (int j = 0; j < n; j ++){
                fruits2[i][j] = fruits[j][i];
            }
        }
        swap(fruits, fruits2);
        sum += solve();
        return sum;
    }
};",1460883016
Rejas Raj,celestialcoder,72,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> a(26, vector<long long>(26));
        for (int i = 0; i < 26; i++) {
            long long curr = 0;
            for (int j = 0; j < 26; j++) {
                int k = (i + j) % 26;
                a[i][k] = curr;
                curr += nextCost[k];
            }
            curr = 0;
            for (int j = 0; j < 26; j++) {
                int k = (i - j + 26) % 26;
                a[i][k] = min(a[i][k], curr);
                curr += previousCost[k];
            }
        }
        long long ans = 0;
        for (int i = 0; i < s.length(); i++) {
            ans += a[s[i] - 'a'][t[i] - 'a'];
        }
        return ans;
    }
};",1460812735
Rejas Raj,celestialcoder,72,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int k = 10;
        bool ans = false;
        while (n > 0) {
            if (n < k) {
                return ans;
            }
            n -= k, k--, ans = !ans;
        }
        return ans;
    }
};",1460796364
Rejas Raj,celestialcoder,72,3647,cpp,"class Solution {
public:
    void build(vector<int>& st, vector<int>& a, int ss, int se, int si) {
        if (ss > se) {
            return;
        }
        if (ss == se) {
            st[si] = a[ss];
            return;
        }
        int m = (ss + se) / 2;
        build(st, a, ss, m, si * 2 + 1), build(st, a, m + 1, se, si * 2 + 2);
        st[si] = min(st[si * 2 + 1], st[si * 2 + 2]);
    }
    int query(vector<int>& st, vector<int>& l, int ss, int se, int qs, int qe, int si) {
        if (l[si]) {
            st[si] += l[si];
            if (ss != se) {
                l[si * 2 + 1] += l[si];
                l[si * 2 + 2] += l[si];
            }
            l[si] = 0;
        }
        if (ss > se || ss > qe || qs > se) {
            return 1e9;
        }
        if (qs <= ss && se <= qe) {
            return st[si];
        }
        int m = (ss + se) / 2;
        return min(query(st, l, ss, m, qs, qe, si * 2 + 1), query(st, l, m + 1, se, qs, qe, si * 2 + 2));
    }
    void update(vector<int>& st, vector<int>& l, int ss, int se, int qs, int qe, int si, int k) {
        if (ss > se) {
            return;
        }
        if (l[si]) {
            st[si] += l[si];
            if (ss != se) {
                l[si * 2 + 1] += l[si];
                l[si * 2 + 2] += l[si];
            }
            l[si] = 0;
        }
        if (ss > se || ss > qe || qs > se) {
            return;
        }
        if (qs <= ss && se <= qe) {
            st[si] += k;
            if (ss != se) {
                l[si * 2 + 1] += k;
                l[si * 2 + 2] += k;
            }
            return;
        }
        int m = (ss + se) / 2;
        update(st, l, ss, m, qs, qe, si * 2 + 1, k), update(st, l, m + 1, se, qs, qe, si * 2 + 2, k);
        st[si] = min(st[si * 2 + 1], st[si * 2 + 2]);
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> a(n + 1);
        for (auto& query : queries) {
            a[query[0]]++, a[query[1] + 1]--;
        }
        vector<int> p(n + 1);
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] + a[i];
        }
        for (int i = 0; i < n; i++) {
            nums[i] = p[i + 1] - nums[i];
            if (nums[i] < 0) {
                return -1;
            }
        }
        vector<vector<int>> g(n);
        vector<int> st(4 * n), l(4 * n);
        build(st, nums, 0, n - 1, 0);
        int ans = 0;
        for (auto& query : queries) {
            g[query[1]].push_back(query[0]);
        }
        for (int i = 0; i < n; i++) {
            sort(g[i].begin(), g[i].end());
            for (int j : g[i]) {
                if (query(st, l, 0, n - 1, j, i, 0) > 0) {
                    update(st, l, 0, n - 1, j, i, 0, -1), ans++;
                }
            }
        }
        return ans;
    }
};",1460883056
Rejas Raj,celestialcoder,72,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size(), ans = 0;
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
        }
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = n - 1 - i; j < n; j++) {
                dp[i][j] = fruits[i][j];
                if (!i) {
                    continue;
                }
                dp[i][j] = fruits[i][j] + dp[i - 1][j];
                if (j) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i - 1][j - 1]);
                }
                if (j < n - 1) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i - 1][j + 1]);
                }
            }
        }
        ans += dp[n - 2][n - 1];
        for (int i = 0; i < n; i++) {
            dp[i].clear();
        }
        for (int j = 0; j < n; j++) {
            for (int i = n - 1 - j; i < n; i++) {
                dp[i][j] = fruits[i][j];
                if (!j) {
                    continue;
                }
                dp[i][j] = fruits[i][j] + dp[i][j - 1];
                if (i) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i - 1][j - 1]);
                }
                if (i < n - 1) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i + 1][j - 1]);
                }
            }
        }
        ans += dp[n - 1][n - 2];
        return ans;
    }
};",1460849554
__keep_it_simple__,__keep_it_simple__,73,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        for (int i = 0; i < s.size(); i++) {
            int a = s[i] - 'a', b = t[i] - 'a';
            long long x = 0, y = 0;
            int na = a;
            while (na != b) {
                x += nextCost[na];
                na = (na + 1) % 26;
            }
            na = a;
            while (na != b) {
                y += previousCost[na];
                na = (na - 1 + 26) % 26;
            }
            res += min(x, y);
        }
        return res;
    }
};",1460820579
__keep_it_simple__,__keep_it_simple__,73,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; i >= 1; i--) {
            n -= i;
            if (n < 0) {
                if (i % 2 == 0) return false;
                else return true;
            }
        }
        return false;
    }
};",1460797994
__keep_it_simple__,__keep_it_simple__,73,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int N = nums.size();
        vector<vector<int>> pos(N);
        priority_queue<int> pq;
        for (auto &arr: queries) {
            int l = arr[0], r = arr[1];
            if (l < N) pos[l].emplace_back(min(r, N - 1));
        }
        int acc = 0;
        vector<int> pref(N);
        int res = 0;
        for (int i = 0; i < N; i++) {
            for (auto x: pos[i]) pq.emplace(x);
            acc += pref[i];
            int sub = min(nums[i], acc);
            nums[i] -= sub;
            pref[i] = 0;
            while (nums[i] > 0 && !pq.empty() && pq.top() >= i) {
                int x = pq.top(); pq.pop();
                acc++;
                nums[i]--;
                if (x + 1 < N) pref[x + 1]--;
            }
            if (nums[i] > 0) return -1;
            acc += pref[i];
        }
        return pq.size();
    }
};",1460857009
__keep_it_simple__,__keep_it_simple__,73,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& grid) {
        int N = grid.size(), res = 0;
        const int INF = 1e9;
        for (int i = 0; i < N; i++) {
            res += grid[i][i];
            grid[i][i] = 0;
        }
        int x = 0, y = 0;
        vector<vector<int>> dp(N, vector<int>(N, -INF));
        dp[0][N - 1] = grid[0][N - 1];
        for (int i = 1; i < N; i++) for (int j = 0; j < N; j++) {
            int max_prev = dp[i-1][j];
            if (j > 0) max_prev = max(max_prev, dp[i-1][j-1]);
            if (j + 1 < N) max_prev = max(max_prev, dp[i-1][j+1]);
            if (max_prev >= 0) dp[i][j] = grid[i][j] + max_prev;
        }
        x = dp[N-1][N-1];
        dp.assign(N, vector<int>(N, -INF));
        dp[N - 1][0] = grid[N - 1][0];
        for (int j = 1; j < N; j++) for (int i = 0; i < N; i++) {
            int max_prev = dp[i][j - 1];
            if (i > 0) max_prev = max(max_prev, dp[i - 1][j - 1]);
            if (i + 1 < N) max_prev = max(max_prev, dp[i + 1][j - 1]);
            if (max_prev >= 0) dp[i][j] = grid[i][j] + max_prev;
        }
        y = dp[N-1][N-1];

        return res + x + y;
    }
};",1460877227
Pavlo Soroka,Chasey,78,3591,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<ll> pref1(27, 0); REP(i, 26) pref1[i+1] = pref1[i] + nextCost[i];
        vector<ll> pref2(27, 0); REP(i, 26) pref2[i+1] = pref2[i] + previousCost[i];
        vector<vector<ll>> dp(26, vector<ll>(26, 0));
        REP(i, 26) {
            REP(j, 26) {
                if (i == j) continue;
                if (i > j) {
                    ll sub1 = pref2[i+1] - pref2[j+1];
                    ll sub2 = pref1[26]-pref1[i] + pref1[j];
                    dp[i][j] = min(sub1, sub2);
                } else {
                    ll sub1 = pref1[j] - pref1[i];
                    ll sub2 = pref2[i+1] + pref2[26] - pref2[j+1];
                    dp[i][j] = min(sub1, sub2);                    
                }
            }
        }
        ll res = 0;
        ll n = s.size();
        REP(i, n) res += dp[s[i]-'a'][t[i]-'a'];
        return res;
    }
};",1460819862
Pavlo Soroka,Chasey,78,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int start = 10;
        bool res = false;
        while (n >= start) {
            n -= start;
            start--;
            res = !res;
        }
        return res;
    }
};",1460796329
Pavlo Soroka,Chasey,78,3647,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        SORT(queries); ll m = queries.size(); ll j = 0;
        priority_queue<ll> pq; // dropped
        map<ll, ll> picked;
        ll curr = 0;
        ll totalPicked = 0;
        ll n = nums.size();
        REP(i, n) {
            while (j < m && queries[j][0] <= i) { pq.push(queries[j][1]); j++; }
            curr += picked[i];
            while (curr < nums[i]) {
                if (pq.size() == 0) return -1;
                auto p = pq.top(); pq.pop();
                if (p < i) return -1;
                curr++;
                picked[p+1]--;
                totalPicked++;
            }
        }
        return m - totalPicked;
    }
};",1460858310
Pavlo Soroka,Chasey,78,3648,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        ll n = fruits.size();
        ll res = 0;
        REP(i, n) { res += fruits[i][i]; fruits[i][i] = 0; }
        REP(i, n) REP(j, n) if (i+j < n-1) fruits[i][j] = 0;

        vector<vector<ll>> dp1(n, vector<ll>(n, 0));
        dp1[0][n-1] = fruits[0][n-1];
        FOR(i, 1, n) {
            REP(j, n) {
                ll sub = dp1[i-1][j];
                if (j > 0) sub = max(sub, dp1[i-1][j-1]);
                if (j+1 < n) sub = max(sub, dp1[i-1][j+1]);
                dp1[i][j] = fruits[i][j]+sub;
            }
        }

        vector<vector<ll>> dp2(n, vector<ll>(n, 0));
        dp2[n-1][0] = fruits[n-1][0];
        FOR(j, 1, n) {
            REP(i, n) {
                ll sub = dp2[i][j-1];
                if (i > 0) sub = max(sub, dp2[i-1][j-1]);
                if (i+1 < n) sub = max(sub, dp2[i+1][j-1]);
                dp2[i][j] = fruits[i][j]+sub;
            }
        }
        
        return res + dp1[n-1][n-1] + dp2[n-1][n-1];
    }
};",1460879164
PyIsTheBestLang,PyIsTheBestLang,79,3591,python3,"
def min(a, b):
    return a if a < b else b


class Solution:
    def shiftDistance(self, ss: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        n = len(ss)
        ans = 0
        for i in range(n):
            pre = ord(ss[i])-ord('a')
            post = ord(t[i]) - ord('a')
            cur = math.inf
            s = pre
            cost = 0
            while s != post:
                cost += nextCost[s]
                s = (s+1)%26
            cur = cost
            
            s = pre
            cost2 = 0
            while s != post:
                cost2 += previousCost[s]
                s = (s-1)%26
            ans += min(cur, cost2)
        return ans",1460867987
PyIsTheBestLang,PyIsTheBestLang,79,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        
        pre = 10
        x = n
        for i in range(n+1):
            if pre > x or pre == 0:
                return i%2 == 1
            x -= pre
            pre -= 1
        ",1460867861
PyIsTheBestLang,PyIsTheBestLang,79,3647,python3,"
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        dct = [[] for _ in range(n)]
        for i, j in queries:
            dct[i].append(j)
        ans = 0
        diff = [0]*n
        pre = []
        for i in range(n):
            diff[i] += diff[i-1] if i else 0
            nums[i] += diff[i]
            for x in dct[i]:
                heappush(pre, -x)
            if nums[i] > 0:
                if nums[i] > len(pre):
                    return -1

                for _ in range(nums[i]):
                    x = -heappop(pre)
                    if x < i:
                        return -1
                    diff[i] -= 1
                    if x+1<n:
                        diff[x+1] += 1
        return len(pre)",1460869759
PyIsTheBestLang,PyIsTheBestLang,79,3648,python3,"def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b



class Solution:

    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:

        n = len(fruits)
        ans = 0
        for i in range(n):
            #print(i, fruits[i][i])
            ans += fruits[i][i]
            fruits[i][i] = 0

        @lru_cache(None)
        def dfs1(i1, j1):
            #print(i1, j1)
            if i1 == j1:
                return 0
            cur = fruits[i1][j1]
            nex = -math.inf
            for a, b in [[-1, 1], [0, 1], [1, 1]]:
                if 0<=i1+a<n and 0<=j1+b<n:
                    nex = max(nex, dfs1(i1+a, j1+b))
            #print(i1, j1, i2, j2, cur+nex)
            return cur + nex

        @lru_cache(None)
        def dfs2(i2, j2):
            if i2 == j2:
                return 0
            cur = fruits[i2][j2]
            nex = -math.inf
            for a2, b2 in [[1, -1], [1, 0], [1, 1]]:
                if 0<=i2+a2<n and 0<=j2+b2<n:
                    nex = max(nex, dfs2(i2+a2, j2+b2))
            return cur + nex
        ans += dfs1(n-1, 0)
        ans += dfs2(0, n-1)
        #print(ans)
        dfs1.cache_clear()
        dfs2.cache_clear()
        return ans

    def maxCollectedFruits2(self, fruits: List[List[int]]) -> int:

        n = len(fruits)
        ans = 0
        for i in range(n):
            #print(i, fruits[i][i])
            ans += fruits[i][i]
            fruits[i][i] = 0

        @lru_cache(None)
        def dfs(i1, j1, i2, j2):
            if i1 == j1 or i2 == j2:
                return 0
            cur = fruits[i1][j1] + fruits[i2][j2]

            if (i1, j1) == (i2, j2):
                cur -= fruits[i1][j1]
            nex = -math.inf
            for a, b in [[-1, 1], [0, 1], [1, 1]]:
                if abs(n-1-i1-a)+abs(n-1-j1-b) + abs(n-1-i1)+abs(j1) <= n-1 and 0<=i1+a<n and 0<=j1+b<n:
                    for a2, b2 in [[1, -1], [1, 0], [1, 1]]:
                        if abs(n - 1 - i2 - a2) + abs(n - 1 - j2 - b2) + abs(i2) + abs(n-1-j2) <= n-1 and 0<=i2+a2<n and 0<=j2+b2<n:
                            nex = max(nex, dfs(i1+a, j1+b, i2+a2, j2+b2))
            #print(i1, j1, i2, j2, cur+nex)
            return cur + nex

        #print(ans)
        ans += dfs(n-1, 0, 0, n-1)
        #print(ans)
        dfs.cache_clear()
        return ans
",1460873223
Kinon,Kinon,80,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long dpnxt[32], dpprv[32];
        dpnxt[0] = 0; dpprv[0] = 0;
        for(int i=0; i<26; i++){
            dpnxt[i+1] = dpnxt[i] + nextCost[i];
            dpprv[i+1] = dpprv[i] + previousCost[i];
        }
        long long ans = 0;
        for(int i=0; i<s.length(); i++){
            long long nxt = 0, prv = 0;
            for(int j=s[i]-'a'; j!=t[i]-'a'; j=(j+1)%26){
                nxt = nxt + nextCost[j];
            }
            for(int j=s[i]-'a'; j!=t[i]-'a'; j=(j+25)%26){
                prv = prv + previousCost[j];
            }
            ans += min(nxt, prv);
        }
        return ans;
    }
};",1460821186
Kinon,Kinon,80,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10; i>=0; i--){
            if(n < i){
                return (i%2 == 1);
            }
            n -= i;
        }
        return true;
    }
};",1460801083
Kinon,Kinon,80,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        multiset<int> pos, neg;
        vector<pair<int, int>> pq;
        for(int i=0; i<queries.size(); i++) pq.push_back({queries[i][0], queries[i][1]});
        sort(pq.begin(), pq.end());
        int ans = 0, pqidx = 0, cur = 0;
        for(int i=0; i<nums.size(); i++){
            while(pqidx < pq.size() && pq[pqidx].first == i){
                neg.insert(-pq[pqidx].second);
                pqidx++;
            }
            while(cur < nums[i] && neg.size() > 0 && -*(neg.begin()) >= i){
                int temp = -*(neg.begin());
                cur++; ans++;
                neg.erase(neg.begin());
                pos.insert(temp);
            }
            if(cur < nums[i]) return -1;
            while(pos.size() > 0 && *(pos.begin()) == i){
                cur--; 
                pos.erase(pos.begin());
            }
        }
        return queries.size() - ans;
    }
};",1460852257
Kinon,Kinon,80,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        //vector<vector<int>> temp;
        //vector<int> row;
        //for(int i=0; i<n*2; i++) row.push_back(0);
        //for(int i=0; i<n*2; i++) temp.push_back(row);
        
        for(int i=1; i<n; i++){
            fruits[i][i] += fruits[i-1][i-1];
            fruits[i-1][i-1] = 0;
            for(int j=0; j+i-1 < n-1; j++){
                fruits[i-1][j] = 0;
            }
        }
        for(int i=1; i<n-1; i++){
            for(int j=i+1; j<n; j++){
                int a = max(fruits[i-1][j-1], fruits[i-1][j]);
                int b = max(fruits[j-1][i-1], fruits[j][i-1]);
                if(j<n-1){
                    a = max(fruits[i-1][j+1], a);
                    b = max(fruits[j+1][i-1], b);
                }
                fruits[i][j] += a;
                fruits[j][i] += b;
            }
        }
        return fruits[n-2][n-1] + fruits[n-1][n-1] + fruits[n-1][n-2];
    }
};",1460879521
Teemu Ryyti,delivery,87,3591,cpp,"using ll = long long;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        int n = s.size();
        ll ans = 0;
        vector<vector<ll>> d(26, vector<ll> (26, INT64_MAX));
        for (int i = 0; i < 26; ++i) {
            d[i][i] = 0;
            d[i][(i +1) % 26] = nc[i];
            d[i][(i + 25) % 26] = pc[i];
        }
        for (int k = 0; k < 26; ++k) {
            for (int i = 0; i < 26; ++i) {
                for (int j = 0; j < 26; ++j) {
                    if (d[i][k] != INT64_MAX && d[k][j] != INT64_MAX)
                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
                }
            }
        }
        
        for (int i = 0; i < n; ++i) {
            ans += d[s[i]-'a'][t[i]-'a'];
        }
        
        return ans;
    }
};",1460817385
Teemu Ryyti,delivery,87,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int c = 10;
        for (int i = 0; i < 100; ++i) {
            if (n < c) {
                return i % 2 == 1;
            }
            n -= c;
            --c;
        }
        return true;
    }
};",1460799975
Teemu Ryyti,delivery,87,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& qq) {
        sort(qq.begin(), qq.end());
        int ans = qq.size();
        multiset<int> have, open;
        int j = -1;
        for (int i = 0; i < nums.size(); ++i) {
            while (!open.empty() && *open.begin() < i) {
                open.erase(open.find(*open.begin()));
            }
            while (!have.empty() && *have.begin() < i) {
                have.erase(have.find(*have.begin()));
            }
            while (j + 1 < qq.size() && qq[j + 1][0] == i) {
                ++j;
                open.insert(qq[j][1]);
            }
                        //cout << i << "" "" << open.size() << "" "" << have.size() << ""\n"";
            if (have.size() < nums[i]) {
                if (open.size() + have.size() < nums[i]) {
                    return -1;
                }
                while (have.size() < nums[i]) {
                    int r = *open.rbegin();
                    have.insert(r);
                    open.erase(open.find(r));
                    --ans;
                }
            }
        }
        return ans;
    }
};",1460840683
Teemu Ryyti,delivery,87,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int n = f.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += f[i][i];
        }
        
        {
            vector<vector<int>> d(n, vector<int> (n));
            d[0][n-1] = f[0][n-1];
            for (int i = 1; i < n - 1; ++i) {
                for (int j = max(i + 1, n - 1 - i); j < n; ++j) {
                    d[i][j] = max(d[i-1][j], d[i-1][j-1]);
                    if (j + 1 < n) {
                        d[i][j] = max(d[i][j], d[i-1][j+1]);
                    }
                    d[i][j] += f[i][j];
                }
            }
            ans += d[n-2][n-1];
        }
        {
            vector<vector<int>> d(n, vector<int> (n));
            d[0][n-1] = f[n-1][0];
            for (int i = 1; i < n - 1; ++i) {
                for (int j =  max(i + 1, n - 1 - i); j < n; ++j) {
                    d[i][j] = max(d[i-1][j], d[i-1][j-1]);
                    if (j + 1 < n) {
                        d[i][j] = max(d[i][j], d[i-1][j+1]);
                    }
                    d[i][j] += f[j][i];
                }
            }
            ans += d[n-2][n-1];

        }
        return ans;
    }
};",1460864009
Peter Lin,inversionpeter,89,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long counts = 0, cost1, cost2;
        for (int i = 0; i != s.size(); ++i) {
            cost1 = cost2 = 0;
            char c = s[i];
            while (c != t[i]) {
                cost1 += nextCost[c - 'a'];
                c = (c - 'a' + 1) % 26 + 'a';
            }
            c = s[i];
            while (c != t[i]) {
                cost2 += previousCost[c - 'a'];
                c = (c - 'a' + 25) % 26 + 'a';
            }
            counts += min(cost1, cost2);
        }
        return counts;
    }
};",1460806150
Peter Lin,inversionpeter,89,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int nowAlice = true, nowStone = 10;
        while (n) {
            if (n >= nowStone) {
                n -= nowStone;
            }
            else {
                break;
            }
            nowAlice = !nowAlice;
            --nowStone;
        }
        return nowAlice ? false : true;
    }
};",1460796589
Peter Lin,inversionpeter,89,3647,cpp,"vector <vector <int>> events;
bool picked[100000];

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int nowAt = 0, nowEvent = 0, totalDecrements = 0, pick = 0;
        set <pair <int, int>> rightEnds;
        events.clear();
        memset(picked, false, sizeof(picked));
        for (int i = 0; i != queries.size(); ++i) {
            events.push_back({ queries[i][0], 0, i });
            events.push_back({ queries[i][1] + 1, 1, i });
        }
        sort(events.begin(), events.end());
        while (nowAt != nums.size()) {
            while (nowEvent != events.size() && events[nowEvent][0] == nowAt) {
                int index = events[nowEvent][2];
                if (events[nowEvent][1]) {
                    if (picked[index]) {
                        --totalDecrements;
                    }
                    rightEnds.erase({ queries[index][1], index });
                }
                else {
                    rightEnds.insert({ queries[index][1], index });
                }
                ++nowEvent;
            }
            for (int i = totalDecrements; i < nums[nowAt]; ++i) {
                if (rightEnds.empty()) {
                    return -1;
                }
                ++pick;
                ++totalDecrements;
                picked[(*prev(rightEnds.end())).second] = true;
                rightEnds.erase(prev(rightEnds.end()));
            }
            ++nowAt;
        }
        return queries.size() - pick;
    }
};",1460882727
Peter Lin,inversionpeter,89,3648,cpp,"int DP[1000][1000];

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        memset(DP, 0, sizeof(DP));
        int counts = 0, length = fruits.size(), half = (length >> 1) - 1;
        for (int i = 0; i < length; ++i) {
            counts += fruits[i][i];
        }
        DP[0][length - 1] = fruits[0][length - 1];
        for (int i = 1; i <= half; ++i) {
            for (int j = 0; j <= i; ++j) {
                DP[i][length - j - 1] = max(DP[i][length - j - 1], DP[i - 1][length - j - 1]);
                if (j) {
                    DP[i][length - j - 1] = max(DP[i][length - j - 1], DP[i - 1][length - j]);
                }
                DP[i][length - j - 1] = max(DP[i][length - j - 1], DP[i - 1][length - j - 2]);
                DP[i][length - j - 1] += fruits[i][length - j - 1];
            }
        }
        for (int i = half - !(length & 1), _i = half + 1; i >= 0; --i, ++_i) {
            for (int j = 0; j <= i; ++j) {
                DP[_i][length - j - 1] = max(DP[_i][length - j - 1], DP[_i - 1][length - j - 1]);
                if (j) {
                    DP[_i][length - j - 1] = max(DP[_i][length - j - 1], DP[_i - 1][length - j]);
                }
                DP[_i][length - j - 1] = max(DP[_i][length - j - 1], DP[_i - 1][length - j - 2]);
                DP[_i][length - j - 1] += fruits[_i][length - j - 1];
            }
        }
        DP[length - 1][0] = fruits[length - 1][0];
        for (int i = 1; i <= half; ++i) {
            for (int j = 0; j <= i; ++j) {
                DP[length - j - 1][i] = max(DP[length - j - 1][i], DP[length - j - 1][i - 1]);
                if (j) {
                    DP[length - j - 1][i] = max(DP[length - j - 1][i], DP[length - j][i - 1]);
                }
                DP[length - j - 1][i] = max(DP[length - j - 1][i], DP[length - j - 2][i - 1]);
                DP[length - j - 1][i] += fruits[length - j - 1][i];
            }
        }
        for (int i = half - !(length & 1), _i = half + 1; i >= 0; --i, ++_i) {
            for (int j = 0; j <= i; ++j) {
                DP[length - j - 1][_i] = max(DP[length - j - 1][_i], DP[length - j - 1][_i - 1]);
                if (j) {
                    DP[length - j - 1][_i] = max(DP[length - j - 1][_i], DP[length - j][_i - 1]);
                }
                DP[length - j - 1][_i] = max(DP[length - j - 1][_i], DP[length - j - 2][_i - 1]);
                DP[length - j - 1][_i] += fruits[length - j - 1][_i];
            }
        }
        return counts + DP[length - 2][length - 1] + DP[length - 1][length - 2];
    }
};",1460858757
luciaa,luciaa,91,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        for c1, c2 in zip(s, t):
            i1, i2 = ord(c1) - ord('a'), ord(c2) - ord('a') 
            l, r = (i1 - i2) % 26, (i2 - i1) % 26
            res += min(
                sum(previousCost[(i1 - j) % 26] for j in range(l)), 
                sum(nextCost[(i1 + j) % 26] for j in range(r)))
        return res",1460824111
luciaa,luciaa,91,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for q in range(10, 0, -1):
            if n >= q:
                n -= q
            else:
                return q % 2 != 0
        return False
        ",1460799633
luciaa,luciaa,91,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        can, have = [], []
        used = 0
        qi = 0
        for i, e in enumerate(nums):
            while have and have[0] < i:
                heapq.heappop(have)
            while qi < len(queries) and queries[qi][0] <= i:
                heapq.heappush(can, -queries[qi][1])
                qi += 1
            while len(have) < e and can and i <= -can[0]:
                heapq.heappush(have, -heapq.heappop(can))
                used += 1
            if len(have) < e:
                return -1
        return len(queries) - used
        ",1460859452
luciaa,luciaa,91,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        @cache
        def topright(r, c):
            if r == n - 1 and c == n - 1:
                return 0
            if r < 0 or r > n - 1 or c < 0 or c > n - 1:
                return -inf
            cur = fruits[r][c] if r != c else 0
            return cur + max(
                topright(r + 1, c - 1),
                topright(r + 1, c),
                topright(r + 1, c + 1))

        @cache
        def bottomleft(r, c):
            if r == n - 1 and c == n - 1:
                return 0
            if r < 0 or r > n - 1 or c < 0 or c > n - 1:
                return -inf
            cur = fruits[r][c] if r != c else 0
            return cur + max(
                bottomleft(r - 1, c + 1),
                bottomleft(r, c + 1),
                bottomleft(r + 1, c + 1))

        res = sum(fruits[r][r] for r in range(n))
        res += topright(0, n - 1)
        res += bottomleft(n - 1, 0)
        print(res)
        return res
        ",1460889163
zsq007,zsq007,92,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nextCost = list(accumulate(nextCost, initial = 0))
        previousCost = list(accumulate(previousCost, initial = 0))
        dist = [[0]*26 for _ in range(26)]
        for i in range(26):
            for j in range(i):
                dist[i][j] = min(nextCost[26] - nextCost[i] + nextCost[j], previousCost[i+1] - previousCost[j+1])
                dist[j][i] = min(previousCost[26] - previousCost[i+1] + previousCost[j+1], nextCost[i] - nextCost[j])
        # print(nextCost)
        # print(previousCost)

        # for d in dist:
        #     print(d)

        return sum(dist[ord(a)-97][ord(b)-97] for a,b in zip(s,t))",1460825884
zsq007,zsq007,92,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        p = 10
        res = False
        while n >= p:
            n -= p
            p -= 1
            res = not res
        return res",1460797709
zsq007,zsq007,92,3647,python3,"from sortedcontainers import SortedList
        
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        queries.sort()
        avail = SortedList()
        used = []
        j, m = 0, len(queries)
        acc, res = 0, 0

        for i in range(n):
            while used and used[0] == i:
                heappop(used)
                acc -= 1
            while avail and avail[0] == i:
                avail.remove(i)
                res += 1
            while j < m and queries[j][0] == i:
                # heappush(avail, -queries[j][1]-1)
                avail.add(queries[j][1]+1)
                j += 1
            while acc < nums[i] and avail:
                # heappush(used, heappop(avail))
                heappush(used, avail.pop(-1))
                acc += 1
            if acc < nums[i]:
                return -1

        return res + len(avail)",1460883420
zsq007,zsq007,92,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        for j in range(1, n-1):
            fruits[0][j] = -inf
        fruits[0].append(-inf)

        for i in range(1, n-1):
            fruits[i][0] = -inf
        fruits.append([-inf]*n)

        for i in range(1, n-1):
            for j in range(i+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i-1][j], fruits[i-1][j+1])
            fruits[i].append(-inf)

        for j in range(1, n-1):
            for i in range(j+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i][j-1], fruits[i+1][j-1])

        return fruits[n-2][n-1] + fruits[n-1][n-2] + sum(fruits[i][i] for i in range(n))",1460870340
Sreesh Maheshwar,sreeshmaheshwar,93,3591,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prv) {
        vt<ll> pn(26 + 1);
        forn(26) pn[i + 1] = pn[i] + nxt[i];
        
        vt<ll> pp(26 + 1);
        forn(26) pp[i + 1] = pp[i] + prv[i];

        vt<vt<ll>>dp(26,vt<ll>(26, (ll) 1e18));
        forn(i, 26) forn(j, 26) {
            if (i == j) dp[i][j] = 0;
            if (i < j) {
                ll x = pn[j] - pn[i];
                dp[i][j] = x;
                // umin(dp[i][j], pn.back() - x);
    
                ll y = pp[j + 1] - pp[i + 1];
                // umin(dp[i][j], y);
                umin(dp[i][j], pp.back() - y);
            } else {
                ll x = pn[i] - pn[j];
                // dp[i][j] = x;
                umin(dp[i][j], pn.back() - x);
    
                ll y = pp[i + 1] - pp[j + 1];
                umin(dp[i][j], y);
                // umin(dp[i][j], pp.back() - y);
            }
        }
        int n = sz(s);
        ll ans = 0;
        forn(n) {
            // if(s[i]>t[i])swap(s[i], t[i]);
            ans += dp[s[i] - 'a'][t[i] - 'a'];
        }
        return ans;
    }
};",1460868921
Sreesh Maheshwar,sreeshmaheshwar,93,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0;
        int now = 10;
        while (true) {
            if (n - now < 0) return turn;
            n -= now;
            now--;
            turn ^= 1;
        } 
        return 0;
    }
};",1460872315
Sreesh Maheshwar,sreeshmaheshwar,93,3647,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

namespace atcoder {

/** 
 * Atcoder Library Code (Lazy Segment Tree), credited to AtCoder. Taken from
 * https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp
 */

inline int ceil_pow2(int n) {
    int x = 0;
    while ((1U << x) < (unsigned int)(n)) x++;
    return x;
}

template <class S,
          S (*op)(S, S),
          S (*e)(),
          class F,
          S (*mapping)(F, S),
          F (*composition)(F, F),
          F (*id)()>
struct lazy_segtree {
  public:
    lazy_segtree() : lazy_segtree(0) {}

    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}

    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {
        log = ceil_pow2(_n);
        size = 1 << log;
        d = std::vector<S>(2 * size, e());
        lz = std::vector<F>(size, id());
        for (int i = 0; i < _n; i++) d[size + i] = v[i];
        for (int i = size - 1; i >= 1; i--) {
            update(i);
        }
    }

    void set(int p, S x) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        d[p] = x;
        for (int i = 1; i <= log; i++) update(p >> i);
    }

    S get(int p) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        return d[p];
    }

    S prod(int l, int r) {
        assert(0 <= l && l <= r && r <= _n);
        if (l == r) return e();
        l += size;
        r += size;
        for (int i = log; i >= 1; i--) {
            if (((l >> i) << i) != l) push(l >> i);
            if (((r >> i) << i) != r) push((r - 1) >> i);
        }
        S sml = e(), smr = e();
        while (l < r) {
            if (l & 1) sml = op(sml, d[l++]);
            if (r & 1) smr = op(d[--r], smr);
            l >>= 1;
            r >>= 1;
        }
        return op(sml, smr);
    }

    S all_prod() { return d[1]; }

    void apply(int p, F f) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        d[p] = mapping(f, d[p]);
        for (int i = 1; i <= log; i++) update(p >> i);
    }

    void apply(int l, int r, F f) {
        assert(0 <= l && l <= r && r <= _n);
        if (l == r) return;
        l += size;
        r += size;
        for (int i = log; i >= 1; i--) {
            if (((l >> i) << i) != l) push(l >> i);
            if (((r >> i) << i) != r) push((r - 1) >> i);
        }
        {
            int l2 = l, r2 = r;
            while (l < r) {
                if (l & 1) all_apply(l++, f);
                if (r & 1) all_apply(--r, f);
                l >>= 1;
                r >>= 1;
            }
            l = l2;
            r = r2;
        }
        for (int i = 1; i <= log; i++) {
            if (((l >> i) << i) != l) update(l >> i);
            if (((r >> i) << i) != r) update((r - 1) >> i);
        }
    }

    template <bool (*g)(S)> int max_right(int l) {
        return max_right(l, [](S x) { return g(x); });
    }

    template <class G> int max_right(int l, G g) {
        assert(0 <= l && l <= _n);
        assert(g(e()));
        if (l == _n) return _n;
        l += size;
        for (int i = log; i >= 1; i--) push(l >> i);
        S sm = e();
        do {
            while (l % 2 == 0) l >>= 1;
            if (!g(op(sm, d[l]))) {
                while (l < size) {
                    push(l);
                    l = (2 * l);
                    if (g(op(sm, d[l]))) {
                        sm = op(sm, d[l]);
                        l++;
                    }
                }
                return l - size;
            }
            sm = op(sm, d[l]);
            l++;
        } while ((l & -l) != l);
        return _n;
    }

    template <bool (*g)(S)> int min_left(int r) {
        return min_left(r, [](S x) { return g(x); });
    }

    template <class G> int min_left(int r, G g) {
        assert(0 <= r && r <= _n);
        assert(g(e()));
        if (r == 0) return 0;
        r += size;
        for (int i = log; i >= 1; i--) push((r - 1) >> i);
        S sm = e();
        do {
            r--;
            while (r > 1 && (r % 2)) r >>= 1;
            if (!g(op(d[r], sm))) {
                while (r < size) {
                    push(r);
                    r = (2 * r + 1);
                    if (g(op(d[r], sm))) {
                        sm = op(d[r], sm);
                        r--;
                    }
                }
                return r + 1 - size;
            }
            sm = op(d[r], sm);
        } while ((r & -r) != r);
        return 0;
    }

  private:
    int _n, size, log;
    std::vector<S> d;
    std::vector<F> lz;

    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }

    void all_apply(int k, F f) {
        d[k] = mapping(f, d[k]);
        if (k < size) lz[k] = composition(f, lz[k]);
    }

    void push(int k) {
        all_apply(2 * k, lz[k]);
        all_apply(2 * k + 1, lz[k]);
        lz[k] = id();
    }
};

}  // namespace atcoder

struct segment_change {
    // TODO: overflow - must hold composition also!
    int64_t to_add = 0;

    segment_change() {}
    segment_change(int64_t _to_add) : to_add(_to_add) {}
};

// change represented by g's application followed by f's application
segment_change compose(segment_change f, segment_change g) {
    return segment_change(f.to_add + g.to_add);
}

const ll INF = 1e18;

struct segment {
    // TODO: overflow - must hold application and combination also!
    int64_t minimum = -INF;

    segment() {}
    segment(int64_t _minimum) : minimum(_minimum) {}
};

segment apply(segment_change change, segment a) {
    if (a.minimum == -INF) return segment(-INF);
    return segment(a.minimum + change.to_add);
}

segment combine(segment a, segment b) {
    return segment(max(a.minimum, b.minimum));
}

segment segment_e() { return segment(); }
segment_change segment_change_id() { return segment_change(); }
using lazy_segtree = atcoder::lazy_segtree<segment, combine, segment_e, 
    segment_change, apply, compose, segment_change_id>;

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& qs) {
        int n = sz(a);
        int q = sz(qs);

        vt<segment> segs;
        forn(n) segs.pb(segment(a[i]));
        lazy_segtree st(segs);

        sort(all(qs), [&](vt<int>& lhs, vt<int>& rhs) -> bool {
            return lhs[1] < rhs[1];
        });

        for (auto v : qs) {
            int l = v[0], r = v[1];
            st.apply(l, r + 1, -1);
        }
        int c = 0;
        for (auto v : qs) {
            int l = v[0], r = v[1]; r++;
            if (st.prod(l, r).minimum < 0) {
                st.apply(l, r, 1);
                c += 1;
            }
        }

        if (st.prod(0, n).minimum > 0) return -1;
        return c;
    }
};",1460849208
Sreesh Maheshwar,sreeshmaheshwar,93,3648,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = sz(a);
        // dp[i][j] is max to get to i, j, can never go above diagonal
        int x = 0;
        {
            const vector<pair<int, int>> DIRECTIONS = {{-1, +1}, {0, +1}, {+1, +1}};
            vt<vt<int>> dp(n, vt<int>(n, -1));
            dp[n - 1][0] = a[n - 1][0];
            for (int j = 0; j < n; ++j) {
                for (int i = 0; i < n; ++i) {
                    if (dp[i][j] < 0) continue;
                    for (auto [di, dj] : DIRECTIONS) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (0 <= min(ni, nj) && max(ni, nj) < n && i > j) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + a[ni][nj]);
                        }
                    } 
                }
            }
            x = dp[n - 1][n - 1] - a[n - 1][n - 1];
        }
        int y = 0;
        {
            const vector<pair<int, int>> DIRECTIONS = {{+1, -1}, {+1, 0}, {+1, +1}};
            vt<vt<int>> dp(n, vt<int>(n, -1));
            dp[0][n - 1] = a[0][n - 1];
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (dp[i][j] < 0) continue;
                    for (auto [di, dj] : DIRECTIONS) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (0 <= min(ni, nj) && max(ni, nj) < n && i < j) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + a[ni][nj]);
                        }
                    } 
                }
            }
            y = dp[n - 1][n - 1] - a[n - 1][n - 1];
        }
        int z = 0;
        for (int i = 0; i < n; ++i) {
            z += a[i][i];
        }
        return z + x + y;
    }
};",1460821538
kesshb,kesshb,94,3591,java,"class Solution {
  public static void main(String... args) {
    Solution solution = new Solution();

  }

  int n;

  public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
    int n = s.length();
    long result = 0L;
    for (int i = 0; i < n; i++) {
      result += cost(s, t, nextCost, previousCost, i);
    }
    return result;
  }

  private long cost(String s, String t, int[] nextCost, int[] previousCost, int i) {
    long forward = 0L, back = 0L;
    char sc = s.charAt(i), tc = t.charAt(i);
    if (sc == tc) {
      return 0L;
    }
    while (sc != tc) {
      forward += nextCost[sc - 'a'];
      sc = (char) ((sc - 'a' + 1) % 26 + 'a');
    }
    sc = s.charAt(i);
    while (sc != tc) {
      back += previousCost[sc - 'a'];
      sc = (char) ((sc - 'a' - 1 + 26) % 26 + 'a');
    }
    return Math.min(forward, back);
  }
}",1460810217
kesshb,kesshb,94,3625,java,"class Solution {
  public boolean canAliceWin(int n) {
    boolean win = false;
    int curr = 10;
    while (curr <= n) {
      n -= curr--;
      win = !win;
    }
    return win;
  }
}",1460796406
kesshb,kesshb,94,3647,java,"class Solution {

  public static void main(String... args) {
    Solution solution = new Solution();
    int[] nums = {2, 0, 2};
    int[][] queries = {{0, 2}, {0, 2}, {1, 1}};
    System.out.println(solution.maxRemoval(nums, queries));
  }

  public int maxRemoval(int[] nums, int[][] queries) {
    int n = nums.length;
    int q = queries.length;
    int[] sweep = new int[n + 1];
    for (int[] query : queries) {
      sweep[query[0]]++;
      sweep[query[1] + 1]--;
    }
    if (!zero(nums, sweep)) {
      return -1;
    }
    Queue<int[]> quer = new PriorityQueue<>((a, b) -> {
      if (a[0] == b[0]) {
        return b[1] - a[1];
      }
      return a[0] - b[0];
    });
    for (int[] query : queries) {
      quer.add(query);
    }
    Queue<Integer> gone = new PriorityQueue<>((a, b) -> a - b);
    Queue<Integer> reserve = new PriorityQueue<>((a, b) -> b - a);
    int curr = 0;
    int size = 0;
    for (int i = 0; i < n; i++) {
      while (!gone.isEmpty() && gone.peek() <= i) {
        curr--;
        gone.poll();
      }
      int end = nums[i] - curr;
      for (int j = 0; j < end; j++) {
        if ((quer.isEmpty() || quer.peek()[0] > i) && reserve.isEmpty()) {
          break;
        }
        int fromRes = -1, fromQuer = -1;
        if (!reserve.isEmpty()) {
          fromRes = reserve.peek();
        }
        if (!quer.isEmpty() && quer.peek()[0] <= i) {
          fromQuer = quer.peek()[1];
        }
        if (fromRes >= fromQuer) {
          gone.add(reserve.poll() + 1);
          curr++;
          size++;
        } else {
          int[] query = quer.poll();
          gone.add(query[1] + 1);
          curr++;
          size++;
        }
      }
      while (!quer.isEmpty() && quer.peek()[0] <= i) {
        reserve.add(quer.poll()[1]);
      }
    }
    return q - size;
  }

  private boolean zero(int[] nums, int[] sweep) {
    int curr = 0;
    for (int i = 0; i < nums.length; i++) {
      curr += sweep[i];
      if (nums[i] > curr) {
        return false;
      }
    }
    return true;
  }
}",1460864063
kesshb,kesshb,94,3648,java,"class Solution {
 
  public static void main(String... args) {
    Solution solution = new Solution();
    int[][] fruits = new int[][] {{1,2,3,4},{5,6,8,7},{9,10,11,12},{13,14,15,16}};
    System.out.println(solution.maxCollectedFruits(fruits));
  }

  private int[][] dirsBot = new int[][] {{1, 1}, {0, 1}, {-1, 1}};
  private int[][] dirsTop = new int[][] {{1, -1}, {1, 0}, {1, 1}};

  int n;

  public int maxCollectedFruits(int[][] fruits) {
    int res = 0;
    n = fruits.length;
    for (int i = 0; i < n; i++) {
      res += fruits[i][i];
      fruits[i][i] = 0;
    }
    int[][] dp = new int[n][n];
    for (int i = 0; i < n; i++) {
      Arrays.fill(dp[i], -1);
    }
    res += dpBot(dp, fruits, n - 1, 0);
    dp = new int[n][n];
    for (int i = 0; i < n; i++) {
      Arrays.fill(dp[i], -1);
    }
    res += dpTop(dp, fruits, 0, n - 1);
    return res;
  }

  private int dpTop(int[][] dp, int[][] fruits, int i, int j) {
    if (i > j) {
      return -10000000;
    }
    if (i == n - 1) {
      return j == n - 1 ? 0 : -10000000;
    }
    if (dp[i][j] != -1) {
      return dp[i][j];
    }
    int res = fruits[i][j];
    for (int[] dir : dirsTop) {
      int x = i + dir[0];
      int y = j + dir[1];
      if (isValid(x, y)) {
        res = Math.max(res, fruits[i][j] + dpTop(dp, fruits, x, y));
      }
    }
    return dp[i][j] = res;
  }

  private int dpBot(int[][] dp, int[][] fruits, int i, int j) {
    if (i < j) {
      return -10000000;
    }
    if (j == n - 1) {
      return i == n - 1 ? 0 : -10000000;
    }
    if (dp[i][j] != -1) {
      return dp[i][j];
    }
    int res = fruits[i][j];
    for (int[] dir : dirsBot) {
      int x = i + dir[0];
      int y = j + dir[1];
      if (isValid(x, y)) {
        res = Math.max(res, fruits[i][j] + dpBot(dp, fruits, x, y));
      }
    }
    return dp[i][j] = res;
  }

  private boolean isValid(int x, int y) {
    return x >= 0 && x < n && y >= 0 && y < n;
  }
}",1460890567
g129512,g129512,95,3591,python3,"from typing import List


class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n=len(s)
        res=0

        def c1(x,y):
            res=0
            while x!=y:
                res+=nextCost[x]
                x+=1
                x%=26
            return res
        def c2(x,y):
            res=0
            while x!=y:
                res+=previousCost[x]
                x-=1
                x%=26
            return res

        for i in range(n):
            res+=min(c1(ord(s[i])-ord('a'), ord(t[i])-ord('a')),
                     c2(ord(s[i])-ord('a'), ord(t[i])-ord('a')))
        return res
        ",1460873871
g129512,g129512,95,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        x=10
        for i in range(100):
            if n<x:
                return i%2==1
            n-=x
            x-=1
        ",1460876619
g129512,g129512,95,3647,python3,"import heapq
from typing import List


class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n=len(nums)
        q=[]
        res=len(queries)
        queries.sort(key=lambda x:-x[0])
        h=0
        diff=[0]*(n+1)
        for i in range(n):
            h+=diff[i]
            while queries!=[] and queries[-1][0]<=i:
                heapq.heappush(q,-queries[-1][1])
                queries.pop()
            while h<nums[i]:
                if q==[]:
                    return -1
                r=-heapq.heappop(q)
                if r<i:continue
                h+=1
                diff[r+1]-=1
                res-=1
        return res
            
        ",1460878860
g129512,g129512,95,3648,python3,"from math import inf
from typing import List


class Solution:
    def maxCollectedFruits(self, ar: List[List[int]]) -> int:
        n=len(ar)
        res=0
        for i in range(n):
            res+=ar[i][i]
        dp=[[-inf]*n for _ in range(n)]
        dp[0][n-1]=ar[n-1][0]
        for j in range(1,n):
            for i in range(n):
                dp[j][i]=dp[j-1][i]
                if i<n-1:
                    dp[j][i]=max(dp[j][i],dp[j-1][i+1])
                if i>0:
                    dp[j][i]=max(dp[j][i],dp[j-1][i-1])
                if i!=j:
                    dp[j][i]+=ar[i][j]
        res+=dp[n-1][n-1]

        dp=[[-inf]*n for _ in range(n)]
        dp[0][n-1]=ar[0][n-1]
        for i in range(1,n):
            for j in range(n):
                dp[i][j]=dp[i-1][j]
                if j<n-1:
                    dp[i][j]=max(dp[i][j],dp[i-1][j+1])
                if j>0:
                    dp[i][j]=max(dp[i][j],dp[i-1][j-1])
                if i!=j:
                    dp[i][j]+=ar[i][j]
        res+=dp[n-1][n-1]
        return res",1460873469
jakao,jakao,97,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long dp[30][30];
        memset(dp, 0x3f, sizeof dp);
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < 26; j++){
                dp[i][j] = 0;
                for(int k = i; k != j; k = (k+1) % 26){
                    dp[i][j] += nextCost[k];
                }
                long long tmp = 0;
                for(int k = i; k != j; k = (k-1+26) % 26){
                    tmp += previousCost[k];
                }
                dp[i][j] = min(dp[i][j], tmp);
            }
        }
        long long ans = 0;
        for(int i = 0; i < s.size(); i++){
            ans += dp[s[i]-'a'][t[i]-'a'];
        }
        return ans;
    }
};",1460809458
jakao,jakao,97,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i = 0, j = 10; ;j--, i++){
            if(n < j){
                return i&1;
            }
            n -= j;
        }
        return 0;
    }
};",1460799163
jakao,jakao,97,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        priority_queue<int> remain;
        priority_queue<int, vector<int>, greater<int>> deadline;
        int sz = 0;
        for(int i = 0, j = 0; i < nums.size(); i++){
            while(!deadline.empty() && deadline.top() < i)
                deadline.pop();
            while(j < queries.size() && queries[j][0] <= i){
                remain.push(queries[j][1]);
                ++j;
            }
            while(deadline.size() < nums[i] && !remain.empty() && remain.top() >= i){
                deadline.push(remain.top());
                remain.pop();
                ++sz;
            }
            if(deadline.size() < nums[i])
                return -1;
            
        }
        return queries.size() - sz;
    }
};",1460824801
jakao,jakao,97,3648,cpp,"class Solution {
public:
    int n;
    bool safe(int x, int y){
        return 0 <= min(x,y) && max(x, y) < n;
    }
    int dp[1003][1003];
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ret = 0;
        n = fruits.size();
        for(int i = 0; i < n; i++){
            ret += fruits[i][i];
            fruits[i][i] = 0;
        }
        for(int i = 0; i < (n+1)/2; i++){
            for(int j = 0; j <= i; j++){
                int x = n-1-j, y = i;
                dp[n-1-j][i] = fruits[n-1-j][i];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(0, -1), pair(1, -1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        for(int i = (n+1)/2; i < n; i++){
            for(int j = 0; j <= n-1-i; j++){
                int x = n-1-j, y = i;
                dp[x][y] = fruits[x][y];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(0, -1), pair(1, -1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        // cout << dp[n-1][n-1];
        ret += dp[n-1][n-1];
        //
        memset(dp, 0, sizeof(dp));
        for(int i = 0; i < (n+1)/2; i++){
            for(int j = 0; j <= i; j++){
                int x = i, y = n-1-j;
                dp[x][y] = fruits[x][y];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(-1, 0), pair(-1, 1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        for(int i = (n+1)/2; i < n; i++){
            for(int j = 0; j <= n-1-i; j++){
                int x = i, y = n-1-j;
                dp[x][y] = fruits[x][y];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(-1, 0), pair(-1, 1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        // cout << dp[n-1][n-1];
        ret += dp[n-1][n-1];
        return ret;
    }
};",1460878939
leetgoat_dot_dev,leetgoat_dot_dev,101,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        @cache
        def getToRight(aIndex, bIndex):
            if aIndex == bIndex:
                return 0
            costA = nextCost[aIndex]
            return costA + getToRight((aIndex + 1) % 26, bIndex)
        
        @cache
        def getToLeft(aIndex, bIndex):
            if aIndex == bIndex:
                return 0
            costA = previousCost[aIndex]
            newPrev = aIndex - 1 if aIndex > 0 else 25
            return costA + getToLeft(newPrev, bIndex)
        
        res = 0
        for i in range(len(s)):
            a = s[i]
            target = t[i]
            indexA = ord(a) - ord('a')
            indexB = ord(target) - ord('a')
            right = getToRight(indexA, indexB)
            left = getToLeft(indexA, indexB)
            res += min(left, right)
        
        return res",1460811820
leetgoat_dot_dev,leetgoat_dot_dev,101,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        turn = 'A'
        subtract = 10
        remain = n
        while True:
            if subtract > remain:
                return False if turn == 'A' else True
            remain -= subtract
            turn = 'B' if turn == 'A' else 'A'
            subtract -= 1
        
        ",1460802038
leetgoat_dot_dev,leetgoat_dot_dev,101,3647,python3,"from sortedcontainers import SortedList



# TEMPLATE BY https://github.com/agrawalishaan
# You are welcome to use this template. Please keep the link in your contest code to prevent automatic detection of copied content. Templates are allowed. Thanks!

# Complexities:
# Build: O(n)
# Space: O(n)
# Query/Update: O(log N)

# baseFn: (val, i) => ...
# combineFn: (leftVal, rightVal, leftLeftIdx, leftRightIdx, rightLeftIdx, rightRightIdx) => ...
# applyLazyToValue: (lazyValue, currentValue) => newValue
# combineLazies: (oldLazy, newLazy) => combinedLazy
# tupleNametags: If baseFn returns a tuple, we can supply nametags for each value, like ('min', 'max'), used for debugging

# get max in a range, and add to a range

def baseFn(val):
    return val

def combineFn(leftVal, rightVal):
    return max(leftVal, rightVal)

def applyLazyToVal(lazy, curr):
    return lazy + curr

def combineLazies(a, b):
    return a + b

class LazyPropagationSegmentTree:
    def __init__(self, arr, baseFn, combineFn, applyLazyToValue, combineLazies, tupleNametags=None):
        self.n = len(arr)
        self.arr = arr
        self.tree = [None] * (4 * self.n)
        self.lazy = [None] * (4 * self.n)
        self._combine = combineFn
        self._baseFn = baseFn
        self._applyAggregate = applyLazyToValue
        self._compose = combineLazies
        self.tupleNametags = tupleNametags
        self._build(1, 0, self.n - 1)

    def _build(self, i, tl, tr):
        if tl == tr:
            self.tree[i] = self._baseFn(self.arr[tl])
            return
        tm = (tr + tl) // 2
        self._build(2 * i, tl, tm)
        self._build(2 * i + 1, tm + 1, tr)
        self.tree[i] = self._combine(self.tree[2 * i], self.tree[2 * i + 1])

    def _push(self, i, tl, tr):
        if self.lazy[i] is not None:
            # print(f""Pushing lazy value at node {i} [{tl},{tr}] with lazyValue {self.lazy[i]}"")
            left_child = 2 * i
            right_child = 2 * i + 1
            self.tree[i] = self._applyAggregate(self.lazy[i], self.tree[i])
            if tl != tr:
                if self.lazy[left_child] is None:
                    self.lazy[left_child] = self.lazy[i]
                else:
                    self.lazy[left_child] = self._compose(self.lazy[left_child], self.lazy[i])

                if self.lazy[right_child] is None:
                    self.lazy[right_child] = self.lazy[i]
                else:
                    self.lazy[right_child] = self._compose(self.lazy[right_child], self.lazy[i])

            self.lazy[i] = None

    def _updateRange(self, i, tl, tr, l, r, lazyValue):
        # print(f""Updating range [{l},{r}] with lazyValue {lazyValue} at node {i} [{tl},{tr}]"")
        self._push(i, tl, tr)
        if l > tr or r < tl:
            return  # No overlap
        if l <= tl and tr <= r:
            self.lazy[i] = lazyValue
            self._push(i, tl, tr)
            return
        tm = (tl + tr) // 2
        self._updateRange(2 * i, tl, tm, l, r, lazyValue)
        self._updateRange(2 * i + 1, tm + 1, tr, l, r, lazyValue)
        self.tree[i] = self._combine(self.tree[2 * i], self.tree[2 * i + 1])

    def _queryRecurse(self, i, tl, tr, l, r):
        # print(f""Querying range [{l},{r}] at node {i} [{tl},{tr}]"")
        self._push(i, tl, tr)
        if l > tr or r < tl:
            return None  # No overlap
        if l <= tl and tr <= r:
            # print(f""Fully in bounds, returning node value: {self.tree[i]}"")
            return self.tree[i]
        tm = (tl + tr) // 2
        if l > tm:
            # print(f""Left child [{tl},{tm}] would have no overlap, so only using right"")
            return self._queryRecurse(2 * i + 1, tm + 1, tr, l, r)
        elif r < tm + 1:
            # print(f""Right child [{tm+1},{tr}] would have no overlap, so only using left"")
            return self._queryRecurse(2 * i, tl, tm, l, r)

        leftResult = self._queryRecurse(2 * i, tl, tm, l, r)
        rightResult = self._queryRecurse(2 * i + 1, tm + 1, tr, l, r)
        combinedResult = self._combine(leftResult, rightResult)
        # print(f""Combining results for parent [{tl},{tr}] for query [{l},{r}]: left useful: {leftResult}, right useful: {rightResult} -> combined useful: {combinedResult}"")
        return combinedResult

    def updateRange(self, l, r, lazyValue):
        self._updateRange(1, 0, self.n - 1, l, r, lazyValue)

    def query(self, l, r):
        return self._queryRecurse(1, 0, self.n - 1, l, r)

    def getVal(self, i):
        return self.arr[i]

    def __str__(self):
        result = []
        def _printTree(i, tl, tr, indent):
            if tl == tr:
                result.append(f'{"" "" * indent}{self._getPrintFormattedVal(self.tree[i], tl, tr)}')
                return
            tm = (tl + tr) // 2
            result.append(f'{"" "" * indent}{self._getPrintFormattedVal(self.tree[i], tl, tr)}')
            _printTree(2 * i, tl, tm, indent + 4)
            _printTree(2 * i + 1, tm + 1, tr, indent + 4)
        _printTree(1, 0, self.n - 1, 0)
        return f'{self._line()} SEGMENT TREE VISUALIZATION {self._line()}\n' + ""\n"".join(result)

    def _getPrintFormattedVal(self, val, tl, tr):
        subarray = self.arr[tl:tr + 1]
        prefix = f'[{tl},{tr}] subarray: {subarray} '
        if self.tupleNametags is None:
            if isinstance(val, tuple):
                return prefix + f""({', '.join(str(v) for v in val)})""
            return prefix + str(val)
        return f'{prefix}({"", "".join(f""{tag}: {v}"" for tag, v in zip(self.tupleNametags, val))})'

    def _line(self):
        return '________________________________________'



class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        empty = [0] * len(nums)
        st = LazyPropagationSegmentTree(empty, baseFn, combineFn, applyLazyToVal, combineLazies)
        
        # queries.sort(key=lambda x: (x[0], -x[1])) # earliest first, largest second
        
        # print(f'{queries=}')
        
        res = 0
        
        startsToEnds = defaultdict(list)
        for l, r in queries:
            startsToEnds[l].append(r)
            
        # print(f'starts to ends: {startsToEnds}')
        
        endPool = SortedList() # holds the biggest endings we have from the prior starts
        
        for i in range(len(nums)):
            # print(f'on i={i}')
            # add all the ends to our pool, amortized since we add Q total queries
            for end in startsToEnds[i]:
                endPool.add(end)
            
            # print(f'end pool now: {endPool}')
            
            currVal = st.query(i, i)
            # print(f'current accrued at this index: {currVal}')
            targetVal = nums[i]
            
            incrementsNeededHere = max(0, targetVal - currVal)
            # print(f'increments needed: {incrementsNeededHere}')
            
            # clear out all the invalid endings
            while endPool and endPool[0] < i:
                endPool.pop(0)
            
            if incrementsNeededHere > len(endPool):
                return -1
            
            for _ in range(incrementsNeededHere):
                ending = endPool.pop()
                # print(f'applying range update for {i}:{ending}')
                st.updateRange(i, ending, 1)
                res += 1
            # now apply the biggest X queries, amortized since we can only apply so much
        
        return len(queries) - res
            
            
        
        
        ",1460886976
leetgoat_dot_dev,leetgoat_dot_dev,101,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        
#         ------>               |
#         |                  <  v  >
#         |  \
#         |   x
#         v
        
        
#          x
#         /
#         --->
#         \
#          \
#           \
#            x

        n = len(fruits)
        # TODO: duplicate goal counting
        
        greenScore = sum(fruits[r][r] for r in range(n))

        @cache
        def bottom(r, c):
            if c == n - 1:
                return 0 if r == n - 1 else -inf # green always takes bottom right
            
            gainable = fruits[r][c] if r != c else 0
            goUp = (gainable + bottom(r - 1, c + 1)) if r > 0 else -inf
            goRight = gainable + bottom(r, c + 1)
            goDown = gainable + bottom(r + 1, c + 1) if r < n - 1 else -inf
            return max(goUp, goRight, goDown)
        
        @cache
        def topRight(r, c):
            if r == n - 1:
                return 0 if c == n - 1 else -inf
            
            gainable = fruits[r][c] if r != c else 0
            
            goDl = (gainable + topRight(r + 1, c - 1)) if c > 0 else -inf
            goDown = gainable + topRight(r + 1, c)
            goDr = (gainable + topRight(r + 1, c + 1)) if c < n - 1 else -inf
            return max(goDl, goDown, goDr)
        
        ans = greenScore + bottom(n - 1, 0) + topRight(0, n - 1)
        bottom.cache_clear()
        topRight.cache_clear()
        return ans
            
        
            
            # \ X X X X
            # X \ X X X
            # X X \ X X
            # X X X \ X
            # X X X X \

        
        
        
        
        
        ",1460849147
czjnbb,czjnbb,103,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        res = 0
        lens = len(s)
                
        
        for i in range(lens):
            c1 = ord(s[i]) - 97
            c2 = ord(t[i]) - 97
            if c1 == c2:
                continue
            if c1 > c2:
                res += min(sum(previousCost[c2+1:c1+1]), sum(nextCost[c1:]) + sum(nextCost[:c2]))
            else:
                res += min(sum(nextCost[c1:c2]), sum(previousCost[c2+1:]) + sum(previousCost[:c1+1]))
        
        return res
            
            ",1460811114
czjnbb,czjnbb,103,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        
        for i in range(10, 0, -1):
            if n >= i:
                n -= i
            else:
                return i % 2 == 1",1460796536
czjnbb,czjnbb,103,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        
        leng = len(nums)
        queries.sort()
        len2 = len(queries)
        
        hq = []
        
        sw = defaultdict(int)
        cur = 0
        use = 0
                        
        for i,n in enumerate(nums):
            
            if i in sw:
                cur += sw[i]
                                
            while queries and queries[0][0] <= i:
                l, r = queries.pop(0)
                heapq.heappush(hq, -r)
                
            while hq and hq[0] + i > 0:
                heapq.heappop(hq)
                
            # print(hq, cur)
                
            if n <= cur:
                continue
                
            while hq and hq[0] + i <= 0:
                r = -heapq.heappop(hq)
                cur += 1
                use += 1
                    
                sw[r+1] -= 1
                if cur == n:
                    break
                    
            if cur < n:
                return -1
            
        # print(queries, sw)
            
        return len2 - use
                
                
            ",1460876537
czjnbb,czjnbb,103,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        
        leng = len(fruits)
        res = 0
        
        dir1 = [(0,1),(-1,1),(1,1)]
        dir2 = [(1,0),(1,-1),(1,1)]
        
        for i in range(leng):
            res += fruits[i][i]
            fruits[i][i] = 0
        
        #left lower
        d = {}
        d[leng-1] = fruits[leng-1][0]
            
        for i in range(1, leng):
            tmp = defaultdict(int)
            for k,v in d.items():
                for dirs in [-1,0,1]:
                    nk = k + dirs
                    if nk > leng - 1:
                        continue
                    nv = v + fruits[i][nk]
                    if nk not in tmp or tmp[nk] < nv:
                        tmp[nk] = nv
            d = tmp
            
        res += d[leng - 1]
        
        
        # right upper
        d = {}
        d[leng-1] = fruits[0][leng-1]
            
        for i in range(1, leng):
            tmp = defaultdict(int)
            for k,v in d.items():
                for dirs in [-1,0,1]:
                    nk = k + dirs
                    if nk > leng - 1:
                        continue
                    nv = v + fruits[nk][i]
                    if nk not in tmp or tmp[nk] < nv:
                        tmp[nk] = nv
            d = tmp
            
        res += d[leng - 1]
        
        return res
        
                        
            
            
        ",1460836406
IsaacHuang,IsaacHuang,104,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        int cost = 0;
        vector<vector<long long>> nextCosts(26, vector<long long>(26, 0));
        vector<vector<long long>> prevCosts(26, vector<long long>(26, 0));
        for(int dist = 0; dist < 25; dist ++){
            for(int i = 0; i < 26; i++){
                nextCosts[i][(i+dist+1)% 26] = nextCosts[i][(i+dist)%26] + nextCost[(i+dist)%26];
            }
        }
        for(int dist = 0; dist < 25; dist ++){
            for(int i = 0; i < 26; i++){
                prevCosts[i][(i-dist+25)% 26] = prevCosts[i][(i-dist+26)%26] + previousCost[(i-dist+26)%26];
            }
        }
        long long sumCost = 0;
        for(int i = 0; i < n; i++){
            sumCost += min(nextCosts[s[i]-'a'][t[i]-'a'], prevCosts[s[i]-'a'][t[i]-'a']);
        }
        return sumCost;
    }
};",1460813502
IsaacHuang,IsaacHuang,104,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n, int k = 10) {
        if(n < k) return false;
        return !canAliceWin(n - k, k - 1);
    }
};",1460797205
IsaacHuang,IsaacHuang,104,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), qSize = queries.size();
        sort(queries.begin(), queries.end(), [](const auto& q1, const auto& q2){
                if(q1[0] != q2[0]) return q1[0] < q2[0];
                return q1[1] > q2[1];
            }
        );
        int selectedCount = 0, queryIdx = 0;
        int notUsedCount = 0;
        priority_queue<int> endChooses;
        priority_queue<int, vector<int>, greater<int>> realEnds;
        int chooseNum = 0;
        for(int i = 0; i < n; i++){
            while(realEnds.size() > 0 && realEnds.top() < i) realEnds.pop();
            while(queryIdx < qSize && queries[queryIdx][0] == i){
                endChooses.push(queries[queryIdx][1]);
                queryIdx ++;
            }
            while(endChooses.size() > 0 && realEnds.size() < nums[i]){
                int endTop = endChooses.top();
                endChooses.pop();
                if(endTop < i){
                    notUsedCount++;
                    continue;
                }
                realEnds.push(endTop);
            }
            if(realEnds.size() < nums[i]) return -1;
        }
        return notUsedCount + endChooses.size();
    }
};",1460888363
IsaacHuang,IsaacHuang,104,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        if(n == 1) return fruits[0][0];
        if(n == 2){
            return fruits[0][1] + fruits[1][0] + fruits[0][0] + fruits[1][1];
        }
        int diagonalFruits = 0;
        for(int i = 0; i < n; i++) diagonalFruits += fruits[i][i];
        vector<vector<long long>> dp1(n, vector<long long>(n));
        dp1[0][n-1] = fruits[0][n-1];
        for(int i = 1; i < n; i++){
            for(int j = n-1; i + j >= n-1 && i - j < 0; j--){
                long long lastFruit = dp1[i-1][j];
                if(j != n-1) lastFruit = max(lastFruit, dp1[i-1][j+1]);
                if(j != 0) lastFruit = max(lastFruit, dp1[i-1][j-1]);
                dp1[i][j] = lastFruit + fruits[i][j];
            }
        }
        // for(int i = 0; i < n; i++){
        //     for(int j = 0; j < n; j++){
        //         printf(""%lld "", dp1[i][j]);
        //     }
        //     printf(""\n"");
        // }
        // printf(""\n"");
        vector<vector<long long>> dp2(n, vector<long long>(n));
        dp2[n-1][0] = fruits[n-1][0];
        for(int j = 1; j < n; j++){
            for(int i = n-1; i + j >= n-1 && i - j > 0; i--){
                long long lastFruit = dp2[i][j-1];
                if(i != n-1) lastFruit = max(lastFruit, dp2[i+1][j-1]);
                if(i != 0) lastFruit = max(lastFruit, dp2[i-1][j-1]);
                dp2[i][j] = lastFruit + fruits[i][j];
            }
        }
        
        // for(int i = 0; i < n; i++){
        //     for(int j = 0; j < n; j++){
        //         printf(""%lld "", dp2[i][j]);
        //     }
        //     printf(""\n"");
        // }
        // printf(""%lld"", diagonalFruits);
        return diagonalFruits + dp1[n-2][n-1] + dp2[n-1][n-2];
    }
};",1460839784
jo7p,jo7p,105,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        #define ll long long
        int n = s.size();
        ll ans = 0;
        for(int i=0; i<n; i++){
            if(s[i] == t[i]) continue;
            ll x = 0;
            char c = s[i];
            while(c != t[i]){
                x += nc[c - 'a'];
                c++;
                if(c > 'z') c = 'a';
            }
            ll xx = 0;
            c = s[i];
            while(c != t[i]){
                xx += pc[c - 'a'];
                c--;
                if(c < 'a') c = 'z';
            }
            ans += min(x, xx);
        }
        return ans;
    }
};",1460806660
jo7p,jo7p,105,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10; i>=1; i--){
            if(n >= i){
                n -= i;
                continue;
            }
            return i & 1;
        }
        return 0;
    }
};",1460797362
jo7p,jo7p,105,3647,cpp,"#define ll long long
const int N = 1e5 + 5;
const int inf = 1e9 + 5;
struct SegTree{
    struct node{
        int lz, val;
    };

    node t[N<<2];
    #define ls(x) (x<<1)
    #define rs(x) (x<<1|1)

    void pushup(int id, int l, int r){
        t[id].val = min(t[ls(id)].val, t[rs(id)].val);
    }

    void pushdown(int id, int l, int r){
        // 0,1
        if(l >= r || !t[id].lz) return;
       
        t[ls(id)].lz += t[id].lz;
        t[rs(id)].lz += t[id].lz;
        t[ls(id)].val += t[id].lz;
        t[rs(id)].val += t[id].lz;
        t[id].lz = 0;
    }

    void build(int id, int l, int r, vector<int> &a){
        t[id].lz = 0;
        if(l == r){
            t[id].val = a[l-1];
            return;
        }
        int mid = (l+r)>>1;
        build(ls(id), l, mid, a);
        build(rs(id), mid+1, r, a);
        pushup(id, l, r);
    }

    void update(int id, int l, int r, int ql, int qr, int val){
        if(ql <= l && r <= qr){
            t[id].lz += val;
            t[id].val += val;
            return;
        }
        pushdown(id, l, r);
        int mid = (l+r)>>1;
        if(mid >= ql) update(ls(id), l, mid, ql, qr, val);
        if(mid < qr) update(rs(id), mid+1, r, ql, qr, val);
        pushup(id, l, r);
    }

    int query(int id, int l, int r, int ql, int qr){
        if(ql <= l && r <= qr) return t[id].val;
        pushdown(id, l, r);
        int mid = (l+r)>>1;
        int res = inf;
        if(mid >= ql) res = query(ls(id), l, mid, ql, qr);
        if(mid < qr) res = min(res, query(rs(id), mid+1, r, ql, qr));
        return res;
    }
    
    #undef ls
    #undef rs
} sgt;

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        #define pii pair<int, int>
        #define F first
        #define S second
        int n = a.size(), m = q.size();
        int ma = *max_element(a.begin(), a.end());
        if(ma > q.size()) return -1;
        vector<int> b(n+1);
        vector<pii> t;
        for(auto it : q){
            int x = it[0], y = it[1];
            b[x]++;
            b[y+1]--;
            t.push_back({x, y});
        }
        for(int i=1; i<n; i++) b[i] += b[i-1];
        for(int i=0; i<n; i++){
            a[i] = b[i] - a[i];
            if(a[i] < 0) return -1;
        }
        // for(auto x : a) cout << x << "" "";
        // cout << endl;
        
        sort(t.begin(), t.end(), [&](auto x, auto y){
            return x.S - x.F == y.S - y.F ? x.F < y.F : x.S - x.F < y.S - y.F;
        });
        
        sgt.build(1, 1, n, a);
        
        auto Print = [&](){
            for(int i=1; i<=n; i++) cout << sgt.query(1, 1, n, i, i) << "" "";
            cout << endl;
        };
        
        // for(auto [p, q] : t) cout << p << "" "" << q << endl;
        int ans = 0;
        // Print();
        for(auto [p, q] : t){
            if(sgt.query(1, 1, n, p+1, q+1) >= 1){
                sgt.update(1, 1 ,n, p+1, q+1, -1);
                ans++;
            }
            // Print();
        }
        
        return ans;
        
    }
};",1460863791
jo7p,jo7p,105,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = a.size();
        if(n == 2){
            return a[0][0] + a[0][1] + a[1][0] + a[1][1];
        }
        vector<vector<int>> b(n, vector<int>(n));
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(i - j < 0 && i + j >= n - 1){
                    b[i][j] = 1;
                }
                if(i - j > 0 && i + j >= n - 1){
                    b[i][j] = 2;
                }
            }
        }
        auto dp = a;
        for(int i=0; i<n-1; i++){
            for(int j=0; j<n; j++){
                if(b[i][j] == 1){
                    for(int k=-1; k<=1; k++){
                        if(j + k >= 0 && j + k < n && b[i+1][j+k] == 1){
                            dp[i+1][j+k] = max(dp[i+1][j+k], dp[i][j] + a[i+1][j+k]);
                        }
                    }
                }
            }
        }
        
        for(int j=0; j<n-1; j++){
            for(int i=n-1; i>=0; i--){
                if(b[i][j] == 2){
                    for(int k=-1; k<=1; k++){
                        if(i + k >= 0 && i + k < n && b[i+k][j+1] == 2){
                            dp[i+k][j+1] = max(dp[i+k][j+1], dp[i][j] + a[i+k][j+1]);
                        }
                    }
                }
            }
        }
        
        for(int i=0; i<n-1; i++){
            dp[i+1][i+1] += dp[i][i];
        }
        
//         for(int i=0; i<n; i++){
//             for(int j=0; j<n; j++){
//                 cout << b[i][j] << "" "";
//             }
//             cout << endl;
//         }
        
//         for(int i=0; i<n; i++){
//             for(int j=0; j<n; j++){
//                 cout << dp[i][j] << "" "";
//             }
//             cout << endl;
//         }
        
        int ans = dp[n-1][n-1] + dp[n-1][n-2] + dp[n-2][n-1];
        return ans;
    }
};",1460894497
jerry5841314,jerry5841314,106,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long total = 0;
        for (int i = 0; i < n; i++){
            total += min(shiftLeft(s[i], t[i], nextCost, previousCost), shiftRight(s[i], t[i], nextCost, previousCost));
        }
        return total;
    }
    long long shiftLeft(char c1, char c2, vector<int>& nextCost, vector<int>& previousCost){
        c1 -= 'a', c2 -= 'a';
        long long total = 0;
        while (c1 != c2){
            total += previousCost[c1];
            c1--;
            if (c1 < 0)
                c1 += 26;
        }
        return total;
    }
    long long shiftRight(char c1, char c2, vector<int>& nextCost, vector<int>& previousCost){
        c1 -= 'a', c2 -= 'a';
        long long total = 0;
        while (c1 != c2){
            total += nextCost[c1];
            c1++;
            c1 %= 26;
        }
        return total;
    }
};",1460825681
jerry5841314,jerry5841314,106,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10, turn = 0;
        while (n >= cnt && n){
            n -= cnt;
            cnt--;
            turn = (turn + 1) % 2;
        }
        return (turn == 1)? true : false;
    }
};",1460811495
jerry5841314,jerry5841314,106,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        priority_queue<int> pq;
        priority_queue<int, vector<int>, greater<>> num;
        int ans = 0;
        int n = nums.size();
        int j = 0;
        for (int i = 0; i < n; i++){
            while (j < queries.size() && queries[j][0] == i){
                pq.push(queries[j][1]);
                j++;
            }
            nums[i] -= num.size();
            while (nums[i] > 0 && !pq.empty() && pq.top() >= i){
                ans++;
                num.push(pq.top());
                pq.pop();
                nums[i]--;
            } 
            if (nums[i] > 0)
                return -1;
            while (!num.empty() && num.top() == i)
                num.pop();
            
        }
        return queries.size() - ans;
        
    }
};",1460847077
jerry5841314,jerry5841314,106,3648,cpp,"class Solution {
public:
    int n;
    vector<vector<int>> fruits;
    int dp1[1001][1001], dp2[1001][1001];
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        n = fruits.size();
        this->fruits = fruits;
        int total = 0;
        for (int i = 0; i < n; i++){
            total += fruits[i][i];
            // cout << total << '\n';
            // fruits[i][i] = 0;
        }
        cout << total << '\n';
        memset(dp1, -1, sizeof(dp1));
        memset(dp2, -1, sizeof(dp2));
        total += find1(n - 1, 0);
        // cout << find1(n - 1, 0) << '\n';
        int ret = find2(0, n - 1);
        total += ret;
        // cout << ret;
        return total;
    }
    int find1(int i, int j){
        
        if (i == n - 1 && j == n - 1)
            return 0;
        if (j >= i)
            return 0;
        if (dp1[i][j] != -1)
            return dp1[i][j];
        int maxV = 0;
        int total = fruits[i][j];
        if (i - 1 >= 0)
            maxV = max(maxV, total + find1(i - 1, j + 1));
        maxV = max(maxV, total + find1(i, j + 1));
        if (i + 1 < n)
            maxV = max(maxV, total + find1(i + 1, j + 1));
        dp1[i][j] = maxV;
        return maxV;
    }
    int find2(int i, int j){
        
        if (i == n - 1 && j == n - 1)
            return 0;
        if (i >= j)
            return 0;
        if (dp2[i][j] != -1)
            return dp2[i][j];
        int maxV = 0;
        int total = fruits[i][j];
        if (j - 1 >= 0)
            maxV = max(maxV, total + find2(i + 1, j - 1));
        maxV = max(maxV, total + find2(i + 1, j));
        if (j + 1 < n)
            maxV = max(maxV, total + find2(i + 1, j + 1));
        // cout << i << "" "" << j << "" "" << maxV << '\n'; 
        dp2[i][j] = maxV;
        return maxV;
    }
};",1460888889
dirigibility,dirigibility,107,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nacc = list(accumulate(nextCost*2,initial=0))
        pacc = list(accumulate(previousCost*2))
        total = 0
        for c,d in zip(s,t):
            x,y = ord(c)-ord('a'),ord(d)-ord('a')
            if x < y:
                total += min(nacc[y]-nacc[x],pacc[x+26]-pacc[y])
            else:
                total += min(nacc[y+26]-nacc[x],pacc[x]-pacc[y])
        return total",1460857539
dirigibility,dirigibility,107,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        k = 10
        a = False
        while n >= k:
            n -= k
            k -= 1
            a = not a
        return a",1460796210
dirigibility,dirigibility,107,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        avail = []
        active = []
        used = k = 0
        for i,n in enumerate(nums):
            while k < len(queries) and queries[k][0] == i:
                heappush(avail,-queries[k][1])
                k += 1
            while active and active[0] < i:
                heappop(active)
            while len(active) < n:
                if avail and -avail[0] >= i:
                    heappush(active,-heappop(avail))
                    used += 1
                else:
                    return -1
        return len(queries)-used",1460871724
dirigibility,dirigibility,107,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        s = sum(fruits[i][i] for i in range(n))
        for j in reversed(range(n-2)):
            for i in range(j+1,n):
                fruits[i][j] += max(fruits[i+di][j+1] for di in range(-1,2) if j+1 < i+di < n)
        for i in reversed(range(n-2)):
            for j in range(i+1,n):
                fruits[i][j] += max(fruits[i+1][j+dj] for dj in range(-1,2) if i+1 < j+dj < n)
        return s+fruits[0][-1]+fruits[-1][0]",1460889308
Sai nadh,sainadhsn,109,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for(int i=0; i<n; i++){
            int j1 = s[i] - 'a';
            int j2 = t[i] - 'a';
            long long c1 = 0, c2 = 0;
            int k1 = j1, k2 = j2;
            while(k1 != k2){
                c1+=nextCost[k1];
                k1++; k1%=26;
            }
            while(j1!=j2){
                c2 += previousCost[j1];
                j1--; j1 = (j1 + 26)%26;
            }
            ans += min(c1, c2);
        }
        return ans;
    }
};",1460814092
Sai nadh,sainadhsn,109,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool f = 0;
        int cur = 10;
        while(n >= cur){
            n -= cur;
            cur--;
            f^=1;
        }
        return f;
    }
};",1460800733
Sai nadh,sainadhsn,109,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& queries) {
        int n = a.size();
        vector<long long> b(n+1, 0);
        multiset<long long> s;
        vector<vector<int>> rs(n);
        int cnt = queries.size();
        for(auto v: queries) rs[v[0]].push_back(v[1]);
        for(int i=0; i<n; i++){
            if(i) b[i] += b[i-1];
            for(auto r: rs[i]) s.insert(r);
            while(!s.empty() and *s.begin() < i) s.erase(s.begin());
            while(!s.empty() and b[i] < a[i]){
                b[i]++;
                b[(*--s.end()) + 1]--;
                s.erase(--s.end());
                cnt--;
            }
            if(b[i] < a[i]) return -1;
        }
        return cnt;
    }
};",1460837027
Sai nadh,sainadhsn,109,3648,cpp,"class Solution {
public:
    const int INF = 1e9;
    int dp[1000][1000];
    int fun1(int i, int j, vector<vector<int>> &a){
        if(i < 0 or j<0 or i>= int(a.size()) or j>= int(a.size())) return 0;
        if(i == j) return 0;
        if(i> j) return -INF;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = a[i][j] + max({-INF, fun1(i+1, j, a), fun1(i+1, j-1, a), fun1(i+1, j+1, a)});
        if(ans < 0) ans = -INF;
        return dp[i][j] = ans;
    }
    int fun2(int i, int j, vector<vector<int>> &a){
        if(i < 0 or j<0 or i>= int(a.size()) or j>= int(a.size())) return 0;
        if(i == j) return 0;
        if(i < j) return -INF;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = a[i][j] + max({-INF, fun2(i-1, j+1,a), fun2(i, j+1,a), fun2(i+1, j+1,a)});
        if(ans < 0) ans = -INF;
        return dp[i][j] = ans;
    }
    int maxCollectedFruits(vector<vector<int>>& a) {
        int ans = 0;
        int n = a.size();
        for(int i=0; i<n; i++) ans += a[i][i];
        memset(dp, -1, sizeof(dp));
        ans += fun1(0, n-1, a);
        memset(dp, -1, sizeof(dp));
        ans += fun2(n-1, 0, a);
        return ans;
    }
};",1460871873
Skyler Tsai,SkylerTsai,110,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        ldp, rdp = {}, {}
        for i in range(26):
            for j in range(26):
                temp, idx = 0, i
                while idx % 26 != j: 
                    temp += nextCost[idx % 26]
                    idx += 1
                ldp[(i, j)] = temp
                temp, idx = 0, i
                while (idx + 26) % 26 != j:
                    temp += previousCost[(idx + 26) % 26]
                    idx -= 1
                rdp[(i, j)] = temp
            
        n, ret = len(s), 0
        for i in range(n):
            x, y = ord(s[i]) - ord('a'), ord(t[i]) - ord('a')
            #print(ldp[(x, y)], rdp[(x, y)])
            ret += min(ldp[(x, y)], rdp[(x, y)])
        return ret
            
                ",1460847533
Skyler Tsai,SkylerTsai,110,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        turn, val = False, 10
        while n >= val:
            n -= val
            val -= 1
            turn = not turn
        return turn
        ",1460798380
Skyler Tsai,SkylerTsai,110,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort(key = lambda x: (x[0], -x[1]))
        n, m = len(nums), len(queries)
        qidx = 0
        rdq, hq = [], []
        ret = m
        for i in range(n):
            while qidx < m and queries[qidx][0] <= i:
                heappush(rdq, -queries[qidx][1])
                qidx += 1
                
            while hq and hq[0] < i: heappop(hq)
            while len(hq) < nums[i] and rdq:
                x = -heappop(rdq)
                if x >= i: 
                    heappush(hq, x)
                    ret -= 1
            if len(hq) < nums[i]: return -1
        return ret
            ",1460862452
Skyler Tsai,SkylerTsai,110,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n, ret = len(fruits), 0
        for i in range(n): 
            ret += fruits[i][i]
            
        dp = [[-1] * n for _ in range(n)]
        dp[0][n - 1] = fruits[0][n - 1]
        for i in range(1, n - 1):
            for j in range(i + 1, n):
                if dp[i - 1][j - 1] != -1: 
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j])
                if dp[i - 1][j] != -1:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + fruits[i][j])
                if j + 1 < n and dp[i - 1][j + 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + fruits[i][j])
        dp[n - 1][0] = fruits[n - 1][0]
        for j in range(1, n - 1):
            for i in range(j + 1, n):
                if dp[i - 1][j - 1] != -1: 
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j])
                if dp[i][j - 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + fruits[i][j])
                if i + 1 < n and dp[i + 1][j - 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + fruits[i][j])
        #print(ret, dp[n - 2][n - 1], dp[n - 1][n - 2])
        return ret + dp[n - 2][n - 1] + dp[n - 1][n - 2]",1460889838
ape_pack,ape_pack,111,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size(); 
        long long ans = 0; 

        // vector<long long> nextpref(n+1,0), prevpref(n+1,0); 
        // long long nextsum = 0, prevsum = 0; 
        // for (int i = 1; i < n; i++) {
            
        // }
        
        for (int i = 0; i < n; i++) {
            int a = s[i]-'a', b =t[i]-'a'; 
            long long forward = 0, backward = 0; 
            while (a != b) {
                forward += nextCost[a]; 
                a++; a%=26; 
            }
            a=s[i]-'a'; 
            while (a != b) {
                backward += previousCost[a]; 
                a--; 
                if (a == -1) a = 25; 
            }
            ans += min(forward,backward);
        }
        return ans; 
    }
};",1460813104
ape_pack,ape_pack,111,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0; 
        int cnt = 10; 
        while (true) {
            if (n < cnt) return (1-turn)==0; 
            n -= cnt; 
            cnt--; 
            turn = 1-turn; 
        }
    }
};",1460797432
ape_pack,ape_pack,111,3647,cpp,"class Solution {
public:
typedef pair<int,int> pii; 
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        // min queries needed 
        vector<pii> q; 
        for (auto& x:queries) {
            q.push_back(make_pair(x[0],x[1])); 
        }
        sort(q.begin(), q.end());

        int n = nums.size(); 
        multiset<int> active_end; 
        int cum = 0; 
        vector<int> diff(n+1,0); // 0 indexed 

        int q_idx = 0; 
        int ans = 0; 
        
        for (int i = 0; i < n; i++) {
            int x = abs(nums[i]);
            cum += diff[i]; 
            x -= cum; 
            
            // intervals that start at i become active 
            while (q_idx < q.size() && q[q_idx].first == i) {
                active_end.insert(q[q_idx].second); 
                q_idx++; 
            }
            while (active_end.size() && *active_end.begin() < i) {
                active_end.erase(active_end.begin());
            }

            if (x <= 0) continue; 
            if (x > active_end.size()) return -1; 

            // remove x largest values from active_end 
            for (int j = 0; j < x; j++) {
                int tmp = *active_end.rbegin(); 
                diff[tmp+1]--;
                cum ++ ; // starts somewhere earlier 
                active_end.erase(prev(active_end.end()));
                ans++; 
            }

        }

        return q.size()-ans; 
    }
};",1460895570
ape_pack,ape_pack,111,3648,cpp,"class Solution {
public:

    vector<vector<int>> dp, a; 
    int n; 
    int f(int x, int y) {
        if (y >= n) return 0; 
        if (x >= y) return 0; 
        if (dp[x][y] != -1) return dp[x][y]; 
        return dp[x][y] = max(f(x+1,y-1), max(f(x+1,y),f(x+1,y+1))) + a[x][y]; 
    }

    int g(int x, int y) {
        if (x >= n) return 0; 
        if (x <= y) return 0; 
        if (dp[x][y] != -1) return dp[x][y]; 
        return dp[x][y] = max(g(x-1,y+1), max(g(x,y+1),g(x+1,y+1))) + a[x][y]; 
    }

    int maxCollectedFruits(vector<vector<int>>& fruits) {
        // obs: top left guy must move only on diagonal 
        // cor: top right and bottom left guy cannot cross diagonal 
        n = fruits.size(); 
        a = fruits; 
        int ans = 0; 
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i]; 
        }

        dp.assign(n,vector<int>(n,-1)); 
        dp[n-1][n-1] = fruits[n-1][n-1];
        ans +=f(0,n-1);

        dp.assign(n,vector<int>(n,-1)); 
        dp[n-1][n-1] = fruits[n-1][n-1];
        ans += g(n-1,0); 

        return ans; 
    }
};",1460861944
fxfxxxfxx,fxfxxxfxx,116,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        auto R = [&](int x, int y) {
            x -= 'a'; y -= 'a';
            int64_t ret = 0;
            while (x != y) {
                ret += nextCost[x];
                x = (x + 1) % 26;
            }
            return ret;
        };
        auto L = [&](int x, int y) {
            x -= 'a'; y -= 'a';
            int64_t ret = 0;
            while (x != y) {
                ret += previousCost[x];
                x = (x - 1 + 26) % 26;
            }
            return ret;
        };
        int n = s.size();
        int64_t ans = 0;
        for (int i = 0; i < n; i++) {
            ans += min(R(s[i], t[i]), L(s[i], t[i]));
        }
        return ans;
    }
};",1460813315
fxfxxxfxx,fxfxxxfxx,116,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool isA = true;
        int k = 10;
        while (n >= k) {
            n -= k;
            k -= 1;
            isA = !isA;
        }
        return !isA;
    }
};",1460796772
fxfxxxfxx,fxfxxxfxx,116,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& Q) {
        sort(Q.begin(), Q.end());
        int n = nums.size(), m = Q.size();
        multiset<int> E, P;
        int ptr = 0, n_pick = 0;
        for (int i = 0; i < n; i++) {
            while (ptr < m && Q[ptr][0] <= i) {
                E.insert(Q[ptr][1]);
                ptr += 1;
            }
            int k = nums[i] - P.size();
            for (int j = 0; j < k; j++) {
                if (E.empty()) return -1;
                P.insert(*prev(E.end()));
                E.erase(prev(E.end()));
                n_pick += 1;
            }
            E.erase(i);
            P.erase(i);
        }
        return m - n_pick;
    }
};",1460836973
fxfxxxfxx,fxfxxxfxx,116,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& M) {
        int n = M.size();
        vector<vector<int>> F(n+1, vector<int>(n+1));
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                F[i][j] = M[i][j];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += F[i][i];
            F[i][i] = 0;
        }
        for (int i = 1; i < n-1; i++)
            F[0][i] = -1;
        for (int i = 1; i < n-1; i++)
            F[i][0] = -1;
        for (int r = 1; r < n; r++)
            for (int c = r+1; c < n; c++) {
                auto add = max({F[r-1][c-1], F[r-1][c], F[r-1][c+1]});
                if (add == -1) F[r][c] = -1;
                else F[r][c] += add;
            }
        for (int c = 1; c < n; c++)
            for (int r = c+1; r < n; r++) {
                auto add = max({F[r-1][c-1], F[r][c-1], F[r+1][c-1]});
                if (add == -1) F[r][c] = -1;
                else F[r][c] += add;
            }
        ans += F[n-2][n-1] + F[n-1][n-2];
        return ans;
    }
};",1460886492
Ryan,ryanwong0127,117,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        INF = float('inf')
        dist = [[INF] * 26 for _ in range(26)]
        for i in range(26):
            dist[i][i] = 0  
            next_i = (i + 1) % 26
            dist[i][next_i] = min(dist[i][next_i], nextCost[i])
            prev_i = (i - 1 + 26) % 26
            dist[i][prev_i] = min(dist[i][prev_i], previousCost[i])

        for k in range(26):
            for i in range(26):
                for j in range(26):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]

        res = 0
        for cs, ct in zip(s, t):
            if cs == ct:
                continue
            c1 = ord(cs) - ord('a')
            c2 = ord(ct) - ord('a')
            res += dist[c1][c2]

        return res",1460803358
Ryan,ryanwong0127,117,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        x = n
        y = 10
        curr = 'Alice'

        while True:
            if x >= y:
                x -= y
                y -= 1
                curr = 'Bob' if curr == 'Alice' else 'Alice'
            else:
                if curr == 'Alice':
                    return False
                else:
                    return True",1460797284
Ryan,ryanwong0127,117,3647,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
struct SegmentTree {
    int n;
    vector<long long> tree;
    vector<long long> lazy;

    SegmentTree(vector<long long> &data) {
        n = 1;
        while (n < data.size()) n <<= 1;
        tree.assign(2 * n, 0LL);
        lazy.assign(2 * n, 0LL);
        // 
        for(int i = 0; i < data.size(); i++) {
            tree[n + i] = data[i];
        }
        // 
        for(int i = n - 1; i >= 1; i--) {
            tree[i] = min(tree[2*i], tree[2*i+1]);
        }
    }

    // 
    void push(int node) {
        if(lazy[node] != 0) {
            tree[2*node] += lazy[node];
            tree[2*node+1] += lazy[node];
            lazy[2*node] += lazy[node];
            lazy[2*node+1] += lazy[node];
            lazy[node] = 0;
        }
    }

    // 
    void range_add(int l, int r, long long val, int node, int node_l, int node_r) {
        if(r <= node_l || node_r <= l) return;
        if(l <= node_l && node_r <= r) {
            tree[node] += val;
            lazy[node] += val;
            return;
        }
        push(node);
        int mid = (node_l + node_r) / 2;
        range_add(l, r, val, 2*node, node_l, mid);
        range_add(l, r, val, 2*node+1, mid, node_r);
        tree[node] = min(tree[2*node], tree[2*node+1]);
    }

    void add(int l, int r, long long val) {
        range_add(l, r, val, 1, 0, n);
    }

    // 
    long long range_min(int l, int r, int node, int node_l, int node_r) {
        if(r <= node_l || node_r <= l) return LLONG_MAX;
        if(l <= node_l && node_r <= r) return tree[node];
        push(node);
        int mid = (node_l + node_r) / 2;
        return min(range_min(l, r, 2*node, node_l, mid),
                   range_min(l, r, 2*node+1, mid, node_r));
    }

    long long query_min(int l, int r) {
        return range_min(l, r, 1, 0, n);
    }
};
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        const int n = nums.size(), m = queries.size();
        vi count(n+1, 0);
        for(auto &q : queries) {
            int l = q[0];
            int r = q[1];
            count[l] += 1;
            if(r + 1 < n) count[r + 1] -= 1;
        }
        for(int i = 1; i < n; i++) {
            count[i] += count[i-1];
        }

        vll d(n, 0);
        rep(i, 0, n) {
            d[i] = (ll)count[i] - (ll)nums[i];
            if(d[i] < 0) return -1;
        }

        SegmentTree st(d);

        sort(queries.begin(), queries.end(), [&](const vi &a, const vi &b) -> bool{
            if(a[1] != b[1]) return a[1] < b[1];
            return a[0] < b[0];
        });

        ll res = 0;
        for(auto &q : queries) {
            int l = q[0];
            int r = q[1];
            ll min_d = st.query_min(l, r + 1);
            if(min_d >= 1) {
                res += 1;
                st.add(l, r + 1, -1);
            }
        }

        return res;
    }
};",1460820773
Ryan,ryanwong0127,117,3648,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        const int n = fruits.size();
        ll sum1 = 0;
        for(int i=0;i<n;i++) {
            sum1 += (ll)fruits[i][i];
        }

        // Step 2: Compute sum2 (second kid's path)
        // Initialize DP arrays
        int prev_leftmost = n-1;
        vvi dp2(n, vi(n, -inf));
        dp2[0][n-1] = fruits[0][n-1];
        rep(i, 1, n) {
            int cur_leftmost = n - 1 - i;
            if (i + 1 > n / 2 ) {
                cur_leftmost = min(i+1, n -1);
            }
            printf(""for i=%d : [%d, %d]\n"",i,cur_leftmost, n-1);
            rep(j, cur_leftmost, n) {
                if (j-1 >= prev_leftmost)
                    chmax(dp2[i][j], dp2[i-1][j-1]+fruits[i][j]);
                chmax(dp2[i][j], dp2[i-1][j]+fruits[i][j]);
                if (j+1<n)
                    chmax(dp2[i][j], dp2[i-1][j+1]+fruits[i][j]);
            }
            prev_leftmost = cur_leftmost;
        }

        ll sum2 = dp2[n-1][n - 1] - fruits[n-1][n - 1];

        // Step 3: Compute sum3 (third kid's path)
        
        int prev_upmost = n-1;
        vvi dp3(n, vi(n, -inf));
        dp3[n-1][0] = fruits[n-1][0];
        rep(j, 1, n) {
            int cur_upmost = n - 1 - j;
            if (j + 1 > n / 2) {
                cur_upmost = min(j+1, n -1);
            }
            rep(i, cur_upmost, n) {
                if (i-1 >= prev_upmost)
                    chmax(dp3[i][j], dp3[i-1][j-1]+fruits[i][j]);
                chmax(dp3[i][j], dp3[i][j-1]+fruits[i][j]);
                if (i+1<n)
                    chmax(dp3[i][j], dp3[i+1][j-1]+fruits[i][j]);
            }
            prev_upmost = cur_upmost;
        }

        ll sum3 = dp3[n-1][n - 1] - fruits[n-1][n - 1];
        // cout<<sum1<<"",""<<sum2<<endl;
        // Step 4: Compute total fruits collected, adjusting for overlapping at (n-1,n-1)
        ll total = sum1 + sum2 + sum3;
        return total;
    }
private:
};",1460892862
nnv-nick,nnv-nick,118,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; ++i) {
            char c, p;
            long long res = 10000000000000;
            long long sum;
            c = s[i];
            p = t[i];
            sum = 0;
            while (c != p) {
                sum += nextCost[c - 'a'];
                c = (c == 'z' ? 'a' : c + 1);
            }
            res = min(res, sum);
            c = s[i];
            p = t[i];
            sum = 0;
            while (c != p) {
                sum += previousCost[c - 'a'];
                c = (c == 'a' ? 'z' : c - 1);
            }
            res = min(res, sum);
            ans += res;
        }
        return ans;
    }
};",1460811280
nnv-nick,nnv-nick,118,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cur = 10;
        int player = 0;
        while (true) {
            if (n < cur) {
                return (player == 1);
            }
            n -= cur;
            --cur;
            player = 1 - player;
        }
        return true;
    }
};",1460796410
nnv-nick,nnv-nick,118,3647,cpp,"#define ll int
const int inf = 1000000000;

class ExplicitSegmentTree {
public:
    ExplicitSegmentTree() {
    }

    ExplicitSegmentTree(ll sz) {
        calc_tree_size(sz);
    }

    // builds tree with n elements starting from 0 index of a
    void Build(ll *a, ll n) {
        if (tree_size < n) {
            calc_tree_size(n);
        }
        ll ind = tree_size;
        for (ll i = 0; i < n; ++i) {
            tree[tree_size + i].first = a[i];
        }
        ind >>= 1;
        while (ind > 0) {
            for (ll i = 0; i < ind; ++i) {
                tree[ind + i].first = f(tree[(ind + i) * 2].first, tree[(ind + i) * 2 + 1].first);
            }
            ind >>= 1;
        }
    }

    void Build(vector<ll>& a) {
        ll n = a.size();
        Build(a.data(), n);
    }

    // add x on the segment [lef, rig]
    void AddOnSegment(ll lef, ll rig, ll x) {
        add_on_segment(1, 0, tree_size - 1, lef, rig, x);
    }

    ll GetMax(ll lef, ll rig) {
        return get_max_on_segment(1, 0, tree_size - 1, lef, rig);
    }

    ll GetValueByIdx(ll idx) {
        return get_max_on_segment(1, 0, tree_size - 1, idx, idx);
    }

private:
    void calc_tree_size(ll sz) {
        tree_size = 1;
        while (tree_size < sz) {
            tree_size <<= 1;
        }
        tree.resize(tree_size * 2, make_pair(neutral(), 0));
    }

    ll add_on_segment(ll ind, ll lef, ll rig, ll lgr, ll rgr, ll x) {
        if (rig < lgr || lef > rgr) {
            return tree[ind].first + tree[ind].second;
        }
        if (lef >= lgr && rig <= rgr) {
            tree[ind].second += x;
            return tree[ind].first + tree[ind].second;
        }
        ll sz = (rig - lef + 1);
        ll one = add_on_segment(ind * 2, lef, lef + (sz / 2) - 1, lgr, rgr, x);
        ll two = add_on_segment(ind * 2 + 1, lef + (sz / 2), rig, lgr, rgr, x);
        tree[ind].first = f(one, two);
        return tree[ind].first + tree[ind].second;
    }

    ll get_max_on_segment(ll ind, ll lef, ll rig, ll lgr, ll rgr) {
        if (rig < lgr || lef > rgr) {
            return neutral();
        }
        if (lef >= lgr && rig <= rgr) {
            return tree[ind].first + tree[ind].second;
        }
        push(ind);
        ll sz = (rig - lef + 1);
        ll one = get_max_on_segment(ind * 2, lef, lef + (sz / 2) - 1, lgr, rgr);
        ll two = get_max_on_segment(ind * 2 + 1, lef + (sz / 2), rig, lgr, rgr);
        return f(one, two);
    }

    void push(ll idx) {
        tree[idx * 2].second += tree[idx].second;
        tree[idx * 2 + 1].second += tree[idx].second;
        tree[idx].first = f(tree[idx * 2].first + tree[idx * 2].second, tree[idx * 2 + 1].first + tree[idx * 2 + 1].second);
        tree[idx].second = 0;
    }

    ll f(ll a, ll b) {
        return min(a, b);
    }

    ll neutral() {
        return inf;
    }

    // second value in pair -- value that adds to every element on segment
    vector<pair<ll, ll>> tree;
    ll tree_size{-1};
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), ans = 0;
        vector<int> bb(n, 0);
        auto tree = ExplicitSegmentTree();
        tree.Build(bb);
        vector<int> cnt(n, 0);
        vector<vector<int>> zak(n);
        for (const auto& elem : queries) {
            ++cnt[elem[0]];
            zak[elem[1]].push_back(elem[0]);
        }
        int balance = 0;
        for (int i = 0; i < n; ++i) {
            balance += cnt[i];
            if (balance < nums[i]) {
                return -1;
            }
            tree.AddOnSegment(i, i, balance - nums[i]);
            for (const auto& elem : zak[i]) {
                --balance;
                auto tmp = tree.GetMax(elem, i);
                if (tmp == 0) {
                    continue;
                }
                ++ans;
                tree.AddOnSegment(elem, i, -1);
            }
        }
        return ans;
    }
};",1460898587
nnv-nick,nnv-nick,118,3648,cpp,"class Solution {
public:
    bool check(int in, int jn, int n) {
        return (in >= 0 && in < n && jn >= 0 && jn < n);
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        {
        vector<vector<int>> dp(n, vector<int>(n, 0));
        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 0; j < n - 1; ++j) {
            for (int i = n - 1; i > j && i >= n - 1 - j; --i) {
                if (check(i - 1, j + 1, n)) {
                    dp[i - 1][j + 1] = max(dp[i - 1][j + 1], dp[i][j] + fruits[i - 1][j + 1]);
                }
                if (check(i, j + 1, n)) {
                    dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + fruits[i][j + 1]);
                }
                if (check(i + 1, j + 1, n)) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + fruits[i + 1][j + 1]);
                }
            }
        }
        ans += dp[n - 1][n - 1];
        }
        {
        vector<vector<int>> dp(n, vector<int>(n, 0));
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 0; i < n - 1; ++i) {
            for (int j = n - 1; j > i && j >= n - 1 - i; --j) {
                if (check(i + 1, j - 1, n)) {
                    dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i][j] + fruits[i + 1][j - 1]);
                }
                if (check(i + 1, j, n)) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + fruits[i + 1][j]);
                }
                if (check(i + 1, j + 1, n)) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + fruits[i + 1][j + 1]);
                }
            }
        }
        ans += dp[n - 1][n - 1];
        }
        for (int i = 0; i < n; ++i) {
            ans += fruits[i][i];
        }
        ans -= fruits[n - 1][n - 1] * 2;
        return ans;
    }
};",1460872335
ephemeralsad,ephemeralsad,119,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = (int)s.size();

        vector<vector<long long>> costs(26, vector<long long>(26));
        
        for (char from = 'a'; from <= 'z'; ++from) {
            for (char to = 'a'; to <= 'z'; ++to) {
                long long sm = 0;
                for (char c = from; c != to;) {
                    sm += nextCost[c - 'a'];
                    c = c == 'z' ? 'a' : c + 1;
                }

                long long sm2 = 0;
                for (char c = from; c != to;) {
                    sm2 += previousCost[c - 'a'];
                    c = c == 'a' ? 'z' : c - 1;     
                }

                costs[from - 'a'][to - 'a'] = min(sm, sm2);
            }
        }
        
        long long sm = 0;
        for (int i = 0; i < n; ++i) {
            sm += costs[s[i] - 'a'][t[i] - 'a'];
        }
        return sm;
    }
};",1460828045
ephemeralsad,ephemeralsad,119,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice_turn = true;
        for (int x = 10; x >= 1; --x) {
            if (x <= n) {
                n -= x;
                alice_turn = !alice_turn;
            } else {
                break;
            }
        }
        return !alice_turn;
    }
};",1460799545
ephemeralsad,ephemeralsad,119,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        // we can fill the first element by choosing all 
        // eligible queries from max to min

        // just so
        // move to first element
        // we have info about how much is there already
        // we have a list of q-s sorted by right border what we can choose to pick
        // we must pick every elegible query in order of right border decreasing
        // we need to clear the list from elements with left border <= current pos

        vector<vector<pair<char, int>>> events((int)nums.size() + 1);
        for (int i = 0; i < (int)queries.size(); ++i) {
            events[queries[i][0]].emplace_back('s', i);
        }

        multimap<int, int> query_by_right_border;
        int already_has = 0;
        int sm = 0;
        
        int n = (int)nums.size();
        for (int i = 0; i < n; ++i) {
            for (auto e : events[i]) {
                if (e.first == 's') {
                    query_by_right_border.emplace(queries[e.second][1], e.second);
                } else if (e.first == 'f') {
                    already_has -= 1;
                }
            }

            // we need to count how much do we need
            int need = max(0, nums[i] - already_has);
            while (need && !query_by_right_border.empty()) {
                auto it = query_by_right_border.end();
                --it;
                if (queries[it->second][0] <= i && i <= queries[it->second][1]) {
                    ++sm;

                    ++already_has;
                    events[queries[it->second][1] + 1].emplace_back('f', it->second);

                    --need;
                }
                query_by_right_border.erase(it);
            }
            if (need) {
                return -1;
            }
        }

        return (int)queries.size() - sm;
    }
};",1460873460
ephemeralsad,ephemeralsad,119,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        // first child
        // 000
        // 0X1
        // 011
        // can move only in one direction LOL

        // second child
        // 000
        // 0X0
        // 111

        // third child
        // 001
        // 0X1
        // 001

        int n = (int)fruits.size();
        int sm = 0;
        for (int i = 0; i < n; ++i) {
            sm += fruits[i][i];
        }

        vector<vector<int>> dp(n, vector<int>(n, -1));
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int from_left = dp[i - 1][j - 1];
                int from_middle = dp[i - 1][j];
                int from_right = j + 1 < n ? dp[i - 1][j + 1] : -1;
                if (from_left != -1) dp[i][j] = max(dp[i][j], from_left + fruits[i][j]);
                if (from_middle != -1) dp[i][j] = max(dp[i][j], from_middle + fruits[i][j]);
                if (from_right != -1) dp[i][j] = max(dp[i][j], from_right + fruits[i][j]);
            }
        }

        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 1; j < n; ++j) {
            for (int i = j + 1; i < n; ++i) {
                int from_top = i + 1 < n ? dp[i + 1][j - 1] : -1;
                int from_middle = dp[i][j - 1];
                int from_bottom = dp[i - 1][j - 1];
                if (from_top != -1) dp[i][j] = max(dp[i][j], from_top + fruits[i][j]);
                if (from_middle != -1) dp[i][j] = max(dp[i][j], from_middle + fruits[i][j]);
                if (from_bottom != -1) dp[i][j] = max(dp[i][j], from_bottom + fruits[i][j]);
            }
        }

        return sm + dp[n - 1][n - 2] + dp[n - 2][n - 1];
    }
};",1460894136
Sam Huang,CelonyMire,122,3591,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  long long shiftDistance(string s, string t, vector<int> &c1, vector<int> &c2) {
    int n = s.size();
    long long ans = 0;
    for (int i = 0; i < n; i++) {
      long long cur = 0, cur2 = 0;
      {
        for (int j = s[i] - 'a'; j != t[i] - 'a'; j = (j + 1) % 26) {
          cur += c1[j];
        }
      }
      {
        for (int j = s[i] - 'a'; j != t[i] - 'a'; j = (j - 1 + 26) % 26) {
          cur2 += c2[j];
        }
      }
      ans += min(cur, cur2);
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::shiftDistance); // CHANGE FOR PROBLEM
}
#endif",1460821753
Sam Huang,CelonyMire,122,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool f = false;
        int p = 10;
        while (p) {
            if (n < p) {
                break;
            }
            n -= p;
            p--;
            f = !f;
        }
        return f;
    }
};",1460800216
Sam Huang,CelonyMire,122,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
template <typename T, typename U, typename A, typename P, typename C, typename C2 = C, typename F = identity>
struct segment_tree_lazy {
  vector<T> tree;
  vector<U> delay;
  U d0;
  A apply;
  P push;
  C combine;
  C2 query_combine;
  F query_fn;
  segment_tree_lazy(int n, T v, U d0, A apply, P push, C combine, C2 query_combine = {}, F query_fn = {}) : tree(2 * n, v), delay(n, d0), d0(d0), apply(apply), push(push), combine(combine), query_combine(query_combine), query_fn(query_fn) {
    for (int i = n - 1; i > 0; --i)
      tree[i] = combine(tree[i << 1], tree[i << 1 | 1]);
  }
  void apply_delay(int i, const U &v, int k) {
    int n = delay.size();
    apply(tree[i], v, k);
    if (i < n)
      push(delay[i], v, k);
  }
  void lift(int l, int r) {
    int n = delay.size();
    l += n, r += n - 1;
    for (int k = 2; l > 1; k <<= 1, l >>= 1)
      for (int i = r >>= 1; i >= l >> 1; i--) {
        tree[i] = combine(tree[i << 1], tree[i << 1 | 1]);
        if (delay[i] != d0)
          apply(tree[i], delay[i], k);
      }
  }
  void push_delay(int l, int r) {
    int n = delay.size();
    int h = __lg(n), k = 1 << __lg(n) >> 1;
    for (l += n, r += n - 1; h; h--, k >>= 1)
      for (int i = l >> h; i <= r >> h; i++)
        if (delay[i] != d0) {
          apply_delay(i << 1, delay[i], k);
          apply_delay(i << 1 | 1, delay[i], k);
          delay[i] = d0;
        }
  }
  void update(int l, int r, const U &v) { // [l, r)
    push_delay(l, l + 1);
    push_delay(r - 1, r);
    int l0 = l, r0 = r, k = 1, n = delay.size();
    for (l += n, r += n; l < r; l >>= 1, r >>= 1, k <<= 1) {
      if (l & 1)
        apply_delay(l++, v, k);
      if (r & 1)
        apply_delay(--r, v, k);
    }
    lift(l0, l0 + 1);
    lift(r0 - 1, r0);
  }
  template <typename R = T, typename... Args>
  R query(int l, int r, R ans = {}, Args &&...args) { // [l, r)
    push_delay(l, l + 1);
    push_delay(r - 1, r);
    int n = delay.size();
    auto ansl = ans, ansr = ans;
    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
      if (l & 1)
        ansl = query_combine(ansl, query_fn(tree[l++], std::forward<Args>(args)...));
      if (r & 1)
        ansr = query_combine(query_fn(tree[--r], std::forward<Args>(args)...), ansr);
    }
    return query_combine(ansl, ansr);
  }
};

class Solution {
public:
  int maxRemoval(vector<int> &a, vector<vector<int>> &q) {
    int n = a.size(), m = q.size();
    ranges::sort(q);
    vector<int> d(n + 1), extra(n);
    bool ok = true;
    for (auto &qry : q) {
      d[qry[0]]++, d[qry[1] + 1]--;
    }
    for (int i = 0, c = 0; i < n; i++) {
      c += d[i];
      ok &= c >= a[i];
      extra[i] = a[i] == 0 ? (int)1e9 : c - a[i];
    }
    if (!ok) {
      return -1;
    }
    auto apply = [](int &v, int d, int) {
      v += d;
    };
    auto comb = [](int a, int b) {
      return min(a, b);
    };
    segment_tree_lazy seg(n, 0, 0, apply, apply, comb);
    for (int i = 0; i < n; i++) {
      seg.update(i, i + 1, extra[i]);
    }
    ranges::sort(q, [&](auto &p1, auto &p2) {
      return p1[1] < p2[1];
    });
    int ans = 0;
    for (auto &qry : q) {
      dbg(qry, seg.query(qry[0], qry[1] + 1, (int)1e9));
      if (seg.query(qry[0], qry[1] + 1, (int)1e9) > 0) {
        ans++;
        seg.update(qry[0], qry[1] + 1, -1);
      }
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::maxRemoval); // CHANGE FOR PROBLEM
}
#endif",1460875427
Sam Huang,CelonyMire,122,3648,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  int maxCollectedFruits(vector<vector<int>> &g) {
    int n = g.size();
    if (n == 1) {
      return g[0][0];
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
      ans += g[i][i];
    }
    {
      int cur = 0;
      vector dp(n + 1, 0);
      for (int j = 0; j < n; j++) {
        vector ndp(n + 1, 0);
        for (int i = n - 1; i > max(j, n - j - 2); i--) {
          ndp[i] = max(dp[i], max(dp[i - 1], dp[i + 1])) + g[i][j];
          cur = max(cur, ndp[i]);
        }
        swap(dp, ndp);
      }
      ans += cur;
    }
    {
      int cur = 0;
      vector dp(n + 1, 0);
      for (int i = 0; i < n; i++) {
        vector ndp(n + 1, 0);
        for (int j = n - 1; j > max(i, n - i - 2); j--) {
          ndp[j] = max(dp[j], max(dp[j - 1], dp[j + 1])) + g[i][j];
          cur = max(cur, ndp[j]);
        }
        swap(dp, ndp);
      }
      ans += cur;
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::maxCollectedFruits); // CHANGE FOR PROBLEM
}
#endif",1460894740
SACD,SACD,124,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        
        for i in range(len(s)):
            
            c1 = c2 =0 
            t1 = s[i]
            t2 = t[i]
            
            while t1 != t2:
                c1 += nextCost[ord(t1) - ord('a')]
                t1 = chr(((ord(t1) - ord('a') + 1) % 26) + ord('a'))
            
            t1 = s[i]
            
            while t1 != t2:
                c2 += previousCost[ord(t1) - ord('a')]
                t1 = chr(((ord(t1) - ord('a') + 26 - 1 ) % 26) + ord('a'))
            
            res += min(c1, c2)
        
        return res",1460811810
SACD,SACD,124,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        p = 10
        op = 0
        while n >= 0:
            if n < p:
                return op != 0
            op ^= 1
            n -= p
            p -= 1
        return False",1460799763
SACD,SACD,124,3647,python3,"from typing import List
import heapq

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        cha = [0] * n
        
        for query in queries:
            query[1] *= -1
        queries.sort()
        for query in queries:
            query[1] *= -1
        
        p = 0
        need = 0
        pq = []
        
        for i in range(n):
            if i > 0:
                cha[i] += cha[i - 1]
            
            while p < m and queries[p][0] <= i:
                heapq.heappush(pq, -queries[p][1])
                p += 1
            
            while nums[i] + cha[i] > 0:
                while pq and -pq[0] < i:
                    return -1
                if not pq:
                    return -1
                
                l = i
                r = -heapq.heappop(pq)
                
                cha[i] -= 1
                if r + 1 < n:
                    cha[r + 1] += 1
                
                need += 1
            
            if nums[i] + cha[i] > 0:
                return -1
        
        return m - need
",1460854516
SACD,SACD,124,3648,python3,"class Solution:
    def cau(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[-1] * n for _ in range(n)]
        dp[0][n-1] = grid[0][n-1]
        ans = dp[0][n-1]
        
        for i in range(1, n-1):
            for j in range(i + 1, n):
                if dp[i-1][j-1] >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1])
                if dp[i-1][j] >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j])

                if j + 1 < n and dp[i-1][j+1] >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j+1])
                
                if dp[i][j] == -1:
                    continue
                dp[i][j] += grid[i][j]
                ans = max(ans, dp[i][j])

        return ans

    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits[0])
        ans = self.cau(fruits)

        for i in range(n):
            ans += fruits[i][i]
            for j in range(i, n):
                fruits[i][j], fruits[j][i] = fruits[j][i], fruits[i][j]

        ans += self.cau(fruits)
        return ans
",1460884566
kmjp,kmjp,1,3591,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll E[26][26]={};
        int i,x,y;
        FOR(x,26) FOR(y,26) E[x][y]=(x==y)?0:1LL<<50;
        FOR(x,26) E[x][(x+1)%26]=nextCost[x];
        FOR(x,26) E[x][(x+25)%26]=previousCost[x];
        FOR(i,26) FOR(x,26) FOR(y,26) E[x][y]=min(E[x][y],E[x][i]+E[i][y]);
        ll ret=0;
        FOR(i,s.size()) ret+=E[s[i]-'a'][t[i]-'a'];
        return ret;
    }
};
",1460801168
kmjp,kmjp,1,3625,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    bool canAliceWin(int n) {
		int i;
		FOR(i,100) {
			int del=10-i;
			if(n>=del) {
				n-=del;
			}
			else {
				return (i%2);;
			}
		}
        return 0;
    }
};
",1460796159
kmjp,kmjp,1,3647,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


int C[202020];
const int def=-1<<20;
template<class V,int NV> class SegTree_3 {
public:
	vector<V> val, ma;
	SegTree_3(){
		int i;
		val.resize(NV*2,0); ma.resize(NV*2,0);
		FOR(i,NV) val[i+NV]=ma[i+NV]=def;
		for(i=NV-1;i>=1;i--) ma[i]=max(ma[2*i],ma[2*i+1]);
	};
	
	V getval(int x,int y,int l=0,int r=NV,int k=1) {
		if(r<=x || y<=l || y<=x) return def;
		if(x<=l && r<=y) return ma[k];
		return val[k]+max(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));
	}
	
	void update(int x,int y, V v,int l=0,int r=NV,int k=1) {
		if(l>=r||y<=x) return;
		if(x<=l && r<=y) {
			val[k]+=v;
			ma[k]+=v;
		}
		else if(l < y && x < r) {
			update(x,y,v,l,(l+r)/2,k*2);
			update(x,y,v,(l+r)/2,r,k*2+1);
			ma[k]=val[k]+max(ma[k*2],ma[k*2+1]);
		}
	}
};
SegTree_3<int,1<<20> st;

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
		int i;
		int N=nums.size();
		FOR(i,N+1) C[i]=0;
		FORR(q,queries) C[q[0]]++,C[q[1]+1]--;
		FOR(i,N) {
			if(i) {
				C[i]+=C[i-1];
			}
			if(nums[i]>C[i]) return -1;
			nums[i]-=C[i];
			st.update(i,i+1,-st.getval(i,i+1)+nums[i]);
		}
		int ret=0;
		sort(ALL(queries));
		reverse(ALL(queries));
		FORR(q,queries) {
			int x=st.getval(q[0],q[1]+1);
			if(x<0) {
				ret++;
				st.update(q[0],q[1]+1,1);
			}
			
		}
		
		return ret;
        
        
    }
};
",1460829420
kmjp,kmjp,1,3648,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

ll from[1010],to[1010];

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int N=fruits.size();
        ll ret=0;
        int x,y,loop;
        FOR(x,N) ret+=fruits[x][x];
        FOR(loop,2) {
			FOR(x,N) FOR(y,N) if(x<y) swap(fruits[x][y],fruits[y][x]);
			FOR(x,N) from[x]=-1LL<<60;
			from[N-1]=fruits[0][N-1];
			for(y=1;y<N-1;y++) {
				FOR(x,N) to[x]=-1LL<<60;
				FOR(x,N) if(from[x]>=0) {
					if(x<N-1) to[x+1]=max(to[x+1],from[x]+fruits[y][x+1]);
					to[x-1]=max(to[x-1],from[x]+fruits[y][x-1]);
					to[x]=max(to[x],from[x]+fruits[y][x]);
				}
				swap(from,to);
			}
			cout<<from[N-1]<<endl;
			ret+=from[N-1];
			
		}
        return ret;
    }
};
",1460822949
AntonRaichuk,AntonRaichuk,3,3591,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll r = 0;
        REP(i,s.size()){
            ll t1 = 0, t2 = 0;
            char c = s[i];
            while(c!=t[i]){
                t1 += nextCost[c-'a'];
                if(c=='z')c='a';
                else c++;
            }
            c=s[i];
            while(c!=t[i]){
                t2 += previousCost[c-'a'];
                if(c=='a')c='z';
                else c--;
            }

            r += min(t1,t2);
        }
        return r;        
    }
};",1460801076
AntonRaichuk,AntonRaichuk,3,3625,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    bool canAliceWin(int n) {
        int t = 10;
        int c = 0;
        while(1){
            if(n<t)return c==1;
            n-=t;
            c^=1;
            t--;
        }
        
    }
};",1460796192
AntonRaichuk,AntonRaichuk,3,3647,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

struct Node{
    Node* lf;
    Node* rg;
    int l,r;
    int mx;
    int add;
    Node(){
        lf=rg=0;
        l=r=0;
        mx=add=0;
    }
};


vi a;

Node* buildTree(int l,int r){
    Node* c = new Node();
    c->l=l;
    c->r=r;
    if(l==r){
        c->mx=a[l];
    }else{
        c->lf=buildTree(l,(l+r)/2);
        c->rg=buildTree((l+r)/2+1,r);
        c->mx=max(c->lf->mx,c->rg->mx);
    }
    return c;
}

int getmax(Node* c){
    return c->mx+c->add;    
}
void add(Node* c, int l,int r, int v){
    if(r<c->l || l>c->r)return;
    if(l<=c->l && c->r<=r){
        c->add+=v;
    }else{
        add(c->lf,l,r,v);
        add(c->rg,l,r,v);
        c->mx=max(getmax(c->lf),getmax(c->rg));
    }
}

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        a=nums;
        vector<pii> t;
        Node* root=buildTree(0,a.size()-1);
        REP(i,q.size())t.pb({q[i][1], q[i][0]}),add(root,q[i][0],q[i][1],-1);
        if(getmax(root) > 0)return -1;
        SORT(t);
        int r=0;
        REP(i,t.size()){
            int from = t[i].second;
            int to = t[i].first;
            add(root,from,to,1);
            if(getmax(root)<=0)r++;
            else add(root,from,to,-1);
        }
        return r;
    }
};",1460822786
AntonRaichuk,AntonRaichuk,3,3648,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

vector<vi> a;
int n;
int d[1111];
int d2[1111];
void update(int pos,int val){
    if(d2[pos]==-1 || d2[pos]<val)d2[pos]=val;
}

int solve(){
    CL(d,-1);
    d[n-1]=a[n-1][0];
    REP(i,n-1){
        CL(d2,-1);

        REP(j,n)if(d[j]!=-1){
            if(j-1>=i+1)update(j-1,d[j]+a[i+1][j-1]);
            if(j>=i+1)update(j,d[j]+a[i+1][j]);
            if(j+1<=n-1)update(j+1,d[j]+a[i+1][j+1]);
        }
        
        memcpy(d,d2,sizeof d);
    }
    return d[n-1];
}


class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        a=f;
        n=a.size();
        int r = 0;
        REP(i,n)r+=a[i][i],a[i][i]=0;
        r += solve();
        REP(i,n)REP(j,i)swap(a[i][j],a[j][i]);
        r += solve();
        return r;
    }
};",1460835761
Ethan,ethanrao,5,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0; 
        int n = s.length();
        
        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a'; 
            int target = t[i] - 'a'; 
            
            int ff = (target - start + 26) % 26;
            int bb = (start - target + 26) % 26;
            
            long long ct1 = 0, ct2 = 0;
            for (int j = 0; j < ff; ++j) {
                ct1 += nextCost[(start + j) % 26];
            }

            for (int j = 0; j < bb; ++j) {
                ct2 += previousCost[(start - j + 26) % 26];
            }
            ans += min(ct1, ct2);
        }
        
        return ans;
    }
};",1460822153
Ethan,ethanrao,5,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int now = n, t = 10;
        int flag = 1;
        while(now>=0){
            if(now==0){
                if(flag == 1) return false;
                else return true;
            }
            if(now>=t){
                now -= t;
            }
            else{
                // cout<<flag<<endl;
                if(flag == 1) return false;
                else return true;
            }
            flag = -flag;
            t--;
        }
        return true;
    }
};
",1460821143
Ethan,ethanrao,5,3647,cpp,"class Solution {
public:
    struct node{
        int l, r;
    };
    struct cmp{
      bool operator()(node a, node b){
          return a.r < b.r;
      }  
    };
    std::priority_queue <node, std::vector <node>, cmp> q;
    int a[100005], lazy[400005], m[400005];
    inline void down(int x){
        if(lazy[x] == 0) return ;
        lazy[x * 2] += lazy[x];
        lazy[x * 2 + 1] += lazy[x];
        m[x * 2] -= lazy[x];
        m[x * 2 + 1] -= lazy[x];
        lazy[x] = 0;
        return ;
    }
    inline void up(int x){
        m[x] = std::max(m[x * 2], m[x * 2 + 1]);
        return ;
    }
    inline void upd(int x, int l, int r, int L, int R){
        if(l == L && r == R){
            lazy[x] += 1;
            m[x] -= 1;
            return ;
        }
        int mid = l + r >> 1;
        down(x);
        if(R <= mid) upd(x * 2, l, mid, L, R);
        else if(L >= mid + 1) upd(x * 2 + 1, mid + 1, r, L, R);
        else {
            upd(x * 2, l, mid, L, mid);
            upd(x * 2 + 1, mid + 1, r, mid + 1, R);
        }
        up(x);
        return ;
    }
    void build(int x, int l, int r){
        if(l == r){
            m[x] = a[l];
            lazy[x] = 0;
            return ;
        }
        int mid = l + r >> 1;
        build(x * 2, l, mid);
        build(x * 2 + 1, mid + 1, r);
        up(x);
        return ;
    }
    int ask(int x, int l, int r, int y){
        if(l == r) return m[x];
        int mid = l + r >> 1;
        down(x);
        if(y <= mid) return ask(x * 2, l, mid, y);
        else return ask(x * 2 + 1, mid + 1, r, y);
    }
    std::vector <node> vc[100005];
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), cnt = 0;
        for(int i = 1; i <= n; ++i) a[i] = nums[i - 1];
        for(int i = 0; i < queries.size(); ++i) vc[queries[i][0] + 1].push_back((node){queries[i][0] + 1, queries[i][1] + 1});
        build(1, 1, n);
        for(int i = 1; i <= n; ++i){
            for(int j = 0; j < vc[i].size(); ++j)
                q.push(vc[i][j]);
            while(ask(1, 1, n, i) >= 1){
                if(q.size() == 0) return -1;
                node u = q.top(); q.pop();
                if(u.r < i) return -1;
                upd(1, 1, n, u.l, u.r);
                cnt += 1;
            }
        }
        return queries.size() - cnt;
    }
};",1460820540
Ethan,ethanrao,5,3648,cpp,"class Solution {
public:
    int dp[1005][1005];
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ans = 0, ans1 = 0, ans2 = 0, ans3 = 0;
        int n = f.size();
        for(int i = 0; i < n; ++i) ans1 += f[i][i];
        dp[n - 1][0] = f[n - 1][0];
        for(int i = 0; i <= n - 2; ++i) dp[i][0] = -1e9;
        for(int y = 1; y <= n - 1; ++y)
            for(int x = y; x <= n - 1; ++x){
                dp[x][y] = -1e9;
                if(x - 1 >= y - 1 && dp[x - 1][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y - 1]);
                if(x >= y - 1 && dp[x][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x][y - 1]);
                if(x + 1 >= y - 1 && dp[x + 1][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x + 1][y - 1]);
                if(dp[x][y] != -1e9){
                    if(x != y) dp[x][y] += f[x][y];
                    else ;
                }
            }
        ans2 = dp[n - 1][n - 1];
        dp[0][n - 1] = f[0][n - 1];
        for(int i = 0; i <= n - 2; ++i) dp[0][i] = -1e9;
        for(int x = 1; x <= n - 1; ++x)
            for(int y = x; y <= n - 1; ++y){
                dp[x][y] = -1e9;
                if(x - 1 <= y - 1 && dp[x - 1][y - 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y - 1]);
                if(x - 1 <= y && dp[x - 1][y] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y]);
                if(x - 1 <= y + 1 && dp[x - 1][y + 1] != -1e9) dp[x][y] = std::max(dp[x][y], dp[x - 1][y + 1]);
                if(dp[x][y] != -1e9){
                    if(x != y) dp[x][y] += f[x][y];
                    else ;
                }
            }
        ans3 = dp[n - 1][n - 1];
        ans = ans1 + ans2 + ans3;
        return ans;
    }
};",1460836200
Naruto,Naruto_x,7,3591,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def shiftDistance(self, s: str, t: str, ncost: list[int], pcost: list[int]) -> int:
        sizee = 26
        INF = float('inf')
        cost = [[INF] * sizee for i in range(sizee)]
        for i in range(sizee):
            cost[i][i] = 0
        for c in range(sizee):
            nchar = (c + 1) % sizee
            prevc = (c - 1 + sizee) % sizee
            cost[c][nchar] = min(cost[c][nchar], ncost[c])
            cost[c][prevc] = min(cost[c][prevc], pcost[c])

        for k in range(sizee):
            for i in range(sizee):
                for j in range(sizee):
                    if cost[i][k] < INF and cost[k][j] < INF:
                        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])

        tot = 0
        n = len(s)
        for i in range(n):
            if s[i] == t[i]:
                continue 
            f1 = ord(s[i]) - ord('a')
            f2 = ord(t[i]) - ord('a')
            if cost[f1][f2] == INF:
                return -1  
            tot += cost[f1][f2]

        return tot",1460831814
Naruto,Naruto_x,7,3625,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def canAliceWin(self, n: int) -> bool:
        alicee = True
        s1 = 10
        while True:
            if n >= s1:
                n -= s1
                s1 -= 1
                alicee = not alicee
            else:
                if alicee:
                    return False
                else:
                    return True
            if s1 <= 0:
                if alicee:
                    return False
                else:
                    return True
",1460832436
Naruto,Naruto_x,7,3647,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
    
class SegmentTree:
    def __init__(self, size):
        self.n = size
        self.tree = [0] * (4 * size)
        self.lazy = [0] * (4 * size)

    def build(self, cap, node, l, r):
        if l == r:
            self.tree[node] = cap[l]
            return
        mid = (l + r) // 2
        self.build(cap, 2 * node, l, mid)
        self.build(cap, 2 * node + 1, mid + 1, r)
        self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])

    def down(self, node, l, r):
        if self.lazy[node] != 0:
            mid = (l + r) // 2
            self.tree[2 * node] += self.lazy[node]
            self.lazy[2 * node] += self.lazy[node]
            self.tree[2 * node + 1] += self.lazy[node]
            self.lazy[2 * node + 1] += self.lazy[node]
            # Reset lazy value
            self.lazy[node] = 0

    def update_range(self, node, l, r, ul, ur, delta):
        if ul > r or ur < l:
            return
        if ul <= l and r <= ur:
            self.tree[node] += delta
            self.lazy[node] += delta
            return
        self.down(node, l, r)
        mid = (l + r) // 2
        self.update_range(2 * node, l, mid, ul, ur, delta)
        self.update_range(2 * node + 1, mid + 1, r, ul, ur, delta)
        self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])

    def query1(self, node, l, r, ql, qr):
        if ql > r or qr < l:
            return float('inf')
        if ql <= l and r <= qr:
            return self.tree[node]
        self.down(node, l, r)
        mid = (l + r) // 2
        return min(self.query1(2 * node, l, mid, ql, qr),
                   self.query1(2 * node + 1, mid + 1, r, ql, qr))

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        q = len(queries)

        diff1 = [0] * (n + 1)
        for l, r in queries:
            diff1[l] += 1
            if r + 1 < len(diff1):
                diff1[r + 1] -= 1

        tot = [0] * n
        tot[0] = diff1[0]
        for i in range(1, n):
            tot[i] = tot[i - 1] + diff1[i]

        for i in range(n):
            if tot[i] < nums[i]:
                return -1

        cap = [tot[i] - nums[i] for i in range(n)]
        queries.sort(key=lambda x: (x[1], x[0]))

        st = SegmentTree(n)
        st.build(cap, 1, 0, n - 1)

        k = 0
        for l, r in queries:
            curr = st.query1(1, 0, n - 1, l, r)
            if curr >= 1:
                k += 1
                st.update_range(1, 0, n - 1, l, r, -1)

        return k
        
        


",1460830453
Naruto,Naruto_x,7,3648,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def maxCollectedFruits(self, fruits: list[list[int]]) -> int:
        n = len(fruits)
        def solve1(fruits, n):
            sum1 = 0
            for k in range(n):
                sum1 += fruits[k][k]
                fruits[k][k] = 0
            return sum1

        def solve2(fruits, n):
            dp2 = [[float('-inf')] * n for i in range(n)]
            dp2[0][n - 1] = fruits[0][n - 1]
        
            for k in range(1, n):
                mn1 = max(0, n - 1 - k)
                mx1 = min(n - 1, n - 1 + k)
                for c in range(mn1, mx1 + 1):
                    prev1 = float('-inf')
                    if c - 1 >= 0:
                        prev1 = max(prev1, dp2[k - 1][c - 1])
                    prev1 = max(prev1, dp2[k - 1][c])
                    if c + 1 < n:
                        prev1 = max(prev1, dp2[k - 1][c + 1])
                    if prev1 != float('-inf'):
                        dp2[k][c] = prev1 + fruits[k][c]
            return dp2[n - 1][n - 1]

        def solve3(fruits, n):
            dp3 = [[float('-inf')] * n for i in range(n)]
            dp3[0][n - 1] = fruits[n - 1][0]
        
            for k in range(1, n):
                mn2 = max(0, n - 1 - k)
                mx2 = min(n - 1, n - 1 + k)
                for r in range(mn2, mx2 + 1):
                    prev1 = float('-inf')
                    if r - 1 >= 0:
                        prev1 = max(prev1, dp3[k - 1][r - 1])
                    prev1 = max(prev1, dp3[k - 1][r])
                    if r + 1 < n:
                        prev1 = max(prev1, dp3[k - 1][r + 1])
                    if prev1 != float('-inf'):
                        dp3[k][r] = prev1 + fruits[r][k]
            return dp3[n - 1][n - 1]

        sum1 = solve1(fruits, n)
        sum2 = solve2(fruits, n)
        sum3 = solve3(fruits, n)
        ans = sum1 + sum2 + sum3
        return int(ans)


",1460839431
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        dist = {}
        for i in range(26):
            for j in range(26):
                if i == j:
                    dist[i,j] = 0
                    continue
                fcost = 0
                cur = i
                while cur != j:
                    fcost += nextCost[cur]
                    cur = (cur + 1) % 26
                pcost = 0
                cur = i
                while cur != j:
                    pcost += previousCost[cur]
                    cur = (cur - 1) % 26
                dist[i,j] = min(fcost, pcost)
        ret = 0
        for i in range(len(s)):
            a, b = ord(s[i])-97, ord(t[i])-97
            ret += dist[a,b]
        return ret
                        ",1460808432
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        turn = 0
        while 1:
            if cur > n:
                return turn == 1
            n -= cur
            turn = 1 - turn
            cur -= 1",1460796436
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        h = []
        n = len(nums)
        queries.sort()
        q = deque(queries)
        cur = 0
        end = defaultdict(int)
        take = 0
        for i in range(n):
            cur -= end[i]
            while q and q[0][0] <= i:
                heapq.heappush(h, -(1+q[0][1]))
                q.popleft()
            while cur < nums[i]:
                while 1:
                    if not h:
                        return -1
                    x = heapq.heappop(h)
                    x = -x
                    if x > i:
                        end[x] += 1
                        cur += 1
                        take += 1
                        # print(x)
                        break
                    else:
                        return -1
        return len(queries) - take",1460825221
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,9,3648,python3,"class Solution:
    def maxCollectedFruits(self, g: List[List[int]]) -> int:
        n = len(g)
        a = 0
        for i in range(n):
            a += g[i][i]
            g[i][i] = 0

        @cache
        def dp1(i, j):
            if i >= n:
                return -inf
            cur = g[i][j]
            if (i, j) == (n-1, n-1):
                return cur
            ret = -inf
            for k in range(j-1, j+2):
                if 0 <= k < n:
                    ret = max(ret, dp1(i+1, k))
            return cur + ret

        @cache
        def dp2(i, j):
            if j >= n:
                return -inf
            cur = g[i][j]
            if (i, j) == (n-1, n-1):
                return cur
            ret = -inf
            for k in range(i-1, i+2):
                if 0 <= k < n:
                    ret = max(ret, dp2(k, j+1))
            return cur + ret

        return a + dp1(0, n-1) + dp2(n-1, 0)",1460842155
Anas Maged,Anas_Maged,13,3591,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = sz(s);
        ll a[26][26], b[26][26], cost[26][26];
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < 26; j++){
                a[i][j] = b[i][j] = cost[i][j] = LLONG_MAX;
            }
        }
        for(int i = 0; i < 26; i++){
            a[i][i] = 0;
            ll last = 0;
            for(int k = 0, j = (i - 1 + 26) % 26; k < 25; k++, j = (j - 1 + 26) % 26){
                last += previousCost[(j + 1) % 26];
                a[i][j] = last;
            }
        }
        for(int i = 0; i < 26; i++){
            b[i][i] = 0;
            ll last = 0;
            for(int k = 0, j = (i + 1) % 26; k < 25; k++, j = (j + 1 + 26) % 26){
                last += nextCost[(j - 1 + 26) % 26];
                b[i][j] = last;
            }
        }

        for(int i = 0; i < 26; i++){
            for(int j = 0; j < 26; j++){
                cost[i][j] = min(a[i][j], b[i][j]);
            }
        }
        
        for(int i = 0; i < n; i++){
            int c1 = s[i] - 'a', c2 = t[i] - 'a';
            ans += cost[c1][c2];
        }
        return ans;
    }
};",1460821013
Anas Maged,Anas_Maged,13,3625,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    bool canAliceWin(int n) {
        bool turn = false;
        for(int i = 10; i >= 1; i--){
            if(n < i) break;
            n -= i;
            turn = !turn;
        }
        return turn;
    }
};",1460796394
Anas Maged,Anas_Maged,13,3647,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        int n = sz(a);
        vector<vector<int>> r(n);
        for(auto it : q){
            r[it[0]].push_back(it[1]);
        }

        int take = 0;
        priority_queue<int> have;
        int cnt = 0;
        vector<int> rem(n + 1);
        for(int i = 0; i < n; i++){
            cnt += rem[i];
            for(int x : r[i]) have.push(x);
            a[i] -= cnt;
            while(a[i] > 0){
                if(have.empty() || have.top() < i){
                    return -1;
                }
                cnt++;
                rem[have.top() + 1]--;
                a[i]--;
                have.pop();
            }
        }
        return sz(have);
    }
};",1460830206
Anas Maged,Anas_Maged,13,3648,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = a.size();
        int ans = 0;
        for(int i = 0; i < n; i++){
            ans += a[i][i];
            a[i][i] = 0;
        }

        vector<vector<int>> dp(n, vector<int>(n, -1));
        auto rec1 = [&](auto& self, int i, int j) -> int{
            if(i == n || j == n || i < 0 || j < 0 || i < j) return 0;
            int& ret = dp[i][j];
            if(~ret) return ret;
            ret = max(self(self, i + 1, j + 1), self(self, i - 1, j + 1));
            ret = max(ret, self(self, i, j + 1));
            ret += a[i][j];
            return ret;
        };
        ans += rec1(rec1, n - 1, 0);
        dp = vector<vector<int>>(n, vector<int>(n, -1));
        auto rec2 = [&](auto& self, int i, int j) -> int{
            if(i == n || j == n || i < 0 || j < 0 || j < i) return 0;
            int& ret = dp[i][j];
            if(~ret) return ret;
            ret = max(self(self, i + 1, j + 1), self(self, i + 1, j - 1));
            ret = max(ret, self(self, i + 1, j));
            ret += a[i][j];
            return ret;
        };
        ans += rec2(rec2, 0, n - 1);
        return ans;
    }
};",1460844919
brahim Hanif eker,ihceker,17,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll ans=0;
        for(int i=0;i<(int)s.size();i++){
            if(s[i]==t[i])continue;
            ll sum=0,sum2=0;
            char c=s[i];
            while(c!=t[i]){
                sum+=nextCost[c-'a'];
                c++;
                if(c>'z')c='a';
            }
            c=s[i];
            while(c!=t[i]){
                sum2+=previousCost[c-'a'];
                c--;
                if(c<'a')c='z';
            }
            ans+=min(sum,sum2);
        }
        return ans;
    }
};",1460803313
brahim Hanif eker,ihceker,17,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn=0,move=10;
        while(n-move>=0){
            n-=move;
            move--;
            turn^=1;
        }
        return turn;
    }
};",1460796215
brahim Hanif eker,ihceker,17,3647,cpp,"class Solution {
public:
    struct FenwickTree{
        vector<int>f;
        FenwickTree(int N){
            f.resize(N+5);
        }
        void update(int x,int y){
            for(int i=x;i<(int)f.size();i+=(i&-i)){
                f[i]+=y;
            }
            return;
        }
        int query(int x){
            int y=0;
            for(int i=x;i>=1;i-=(i&-i)){
                y+=f[i];
            }
            return y;
        }
    };
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n=(int)nums.size();
        int m=(int)queries.size();
        FenwickTree ft(n);
        vector<vector<int>>q(n);
        for(int i=0;i<(int)queries.size();i++){
            q[queries[i][0]].push_back(queries[i][1]);
        }
        for(int i=0;i<n;i++){
            sort(q[i].begin(),q[i].end());
            reverse(q[i].begin(),q[i].end());
        }
        priority_queue<pair<int,int>>pq;
        for(int i=0;i<n;i++){
            nums[i]-=ft.query(i+1);
            for(int j=0;j<(int)q[i].size();j++){
                pq.push({q[i][j],i});
            }
            while(nums[i]>0 && !pq.empty() && pq.top().first>=i){
                nums[i]--;
                pair<int,int>cur=pq.top();
                pq.pop();
                ft.update(cur.second+1,1);
                ft.update(cur.first+2,-1);
            }
            if(nums[i]>0)return -1;
        }
        return (int)pq.size();
    }
};",1460832139
brahim Hanif eker,ihceker,17,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& arr) {
        int n=(int)arr.size();
        vector<vector<int>>dp(n,vector<int>(n));
        dp[n-1][0]=arr[n-1][0];
        for(int j=1;j<n;j++){
            for(int i=n-1;i>=n-j-1;i--){
                dp[i][j]=max({dp[i][j-1],(i-1>=n-(j-1)-1?dp[i-1][j-1]:0),(i+1<n?dp[i+1][j-1]:0)})+(i==j?0:arr[i][j]);
            }
        }
        vector<vector<int>>dp2(n,vector<int>(n));
        dp2[0][n-1]=arr[0][n-1];
        for(int i=1;i<n;i++){
            for(int j=n-1;j>=n-i-1;j--){
                dp2[i][j]=max({dp2[i-1][j],(j-1>=n-(i-1)-1?dp2[i-1][j-1]:0),(j+1<n?dp2[i-1][j+1]:0)})+(i==j?0:arr[i][j]);
            }
        }
        int ans=0;
        for(int i=0;i<n;i++){
            ans+=arr[i][i];
        }
        return ans+dp[n-1][n-1]+dp2[n-1][n-1];
    }
};",1460851937
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const long long INF = 0X3F3F3F3F3F3F3F3FLL;
        vector<vector<long long> > d(26, vector<long long>(26, INF));
        for (int i = 0; i < 26; ++i)
            d[i][i] = 0;
        for (int i = 0, j = 0; i < 26; ++i) {
            j = (i + 1) % 26;
            d[i][j] = min(1LL * nextCost[i], d[i][j]);
            d[j][i] = min(1LL * previousCost[j], d[j][i]);
        }
        for (int z = 0; z < 26; ++z)
            for (int i = 0; i < 26; ++i)
                for (int j = 0; j < 26; ++j)
                    d[i][j] = min(d[i][z] + d[z][j], d[i][j]);
        long long result = 0;
        int n = s.size();
        for (int i = 0; i < n; ++i)
            result += d[s[i] - 'a'][t[i] - 'a'];
        return result;
    }
};",1460809270
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = true;
         int x = 10;
        while (true) {
            if (n < x) {
                if (alice)
                    return false;
                return true;
            }
            n -= x;
            --x;
            alice = !alice;
        }
        return true;
    }
};",1460798235
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3647,cpp,"template<class T>
class SegmentTree {
protected:

    const int ninf = 0xc0c0c0c0, inf = 0x3f3f3f3f;

private:

    int length;
    mutable std::vector<T> maximum, lazy;

    void down(const int i) const {
        if (lazy[i]) {
            const int l = i << 1, r = l | 1;
            lazy[l] += lazy[i];
            lazy[r] += lazy[i];
            maximum[l] += lazy[i];
            maximum[r] += lazy[i];
            lazy[i] = 0;
        }
    }

    void modify(const int q, const T value, const int i, const int l, const int r) {
        if (q < l || r < q)
            return;
        if (l == r) {
            maximum[i] = value;
            return;
        }
        down(i);
        const int m = l + r >> 1;
        modify(q, value, i << 1, l, m);
        modify(q, value, i << 1 | 1, m + 1, r);
        maximum[i] = std::max(maximum[i << 1], maximum[i << 1 | 1]);
    }

    void update(const int ql, const int qr, const T value, const int i, const int l, const int r) {
        if (qr < l || r < ql)
            return;
        if (ql <= l && r <= qr) {
            maximum[i] += value;
            lazy[i] += value;
            return;
        }
        down(i);
        const int m = l + r >> 1;
        update(ql, qr, value, i << 1, l, m);
        update(ql, qr, value, i << 1 | 1, m + 1, r);
        maximum[i] = std::max(maximum[i << 1], maximum[i << 1 | 1]);
    }

    T query(const int ql, const int qr, const int i, const int l, const int r) const {
        if (qr < l || r < ql)
            return ninf;
        if (ql <= l && r <= qr)
            return maximum[i];
        down(i);
        const int m = l + r >> 1;
        return std::max(query(ql, qr, i << 1, l, m), query(ql, qr, i << 1 | 1, m + 1, r));
    }

    void build(const int i, const int l, const int r) {
        maximum[i] = inf;
        lazy[i] = 0;
        if (l == r)
            return;
        const int m = l + r >> 1;
        build(i << 1, l, m);
        build(i << 1 | 1, m + 1, r);
    }

public:

    SegmentTree(): length(0) {};
    SegmentTree(int n): length(n) {
        n = length + 5 << 2;
        maximum.resize(n, ninf);
        lazy.resize(n);
    };

    void update(const int ql, const int qr, const int value) {
        update(ql, qr, value, 1, 1, length);
    }

    void resize(int m) {
        length = m;
        m = length + 5 << 2;
        maximum.resize(m, ninf);
        lazy.resize(m);
//        reload();
    }

    void reload() {
        std::fill(maximum.begin(), maximum.end(), inf);
        std::fill(lazy.begin(), lazy.end(), 0);
    }

    void modify(const int q, const T value) {
        modify(q, value, 1, 1, length);
    }

    T query(const int ql, const int qr) const {
        return query(ql, qr, 1, 1, length);
    }

    void build() {
        build(1, 1, length);
    }

    T top() const {
        return maximum[1];
    }

    int getLength() const {
        return this -> length;
    }

    virtual ~SegmentTree() {}

};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        SegmentTree<int> m;
        int result = 0;
        int n = nums.size(), q = queries.size();

        m.resize(n);
        
        for (int i = 0; i < n; ++i)
            m.modify(i + 1, nums[i]);
        for (int i = 0; i < q; ++i)
            m.update(queries[i].front() + 1, queries[i].back() + 1, -1);

        if (m.top() > 0)
            return -1;
        
        sort(queries.begin(), queries.end(), [&](const auto &L, const auto &R) -> bool {
            const int a = L.back() - L.front(), b = R.back() - R.front();
            if (a == b)
                return L < R;
            return a < b;
        });
        
        for (const auto &v : queries) {
            const int l = v.front() + 1, r = v.back() + 1;
            //cout << l << ' ' << r << ' ' << m.query(l, r) << '\n';
            if (m.query(l, r) >= 0)
                   continue;
             ++result;
            m.update(l, r, 1);
        }
        return result;
    }
};",1460830354
Hoang-Minh Nguyen,nguyen31hoang08minh2003,24,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int> >& f) {
        int n = f.size(), NINF = 0XC0C0C0C0;
        int res = 0;
        vector<vector<int> > u(n, vector<int>(n, -1)), l(u);

        function<int(int, int)> U = [&](int x, int y) -> int {
            if (x < 0 || x >= n || y < 0 || y >= n || x > y)
                return NINF;
            if (x == n - 1 && y == n - 1)
                return 0;
            if (u[x][y] < 0) {
                u[x][y] = max({0, U(x + 1, y), U(x + 1, y - 1), U(x + 1, y + 1)});
                if (x != y)
                    u[x][y] += f[x][y];
            }
            return u[x][y];
        };

        function<int(int, int)> L = [&](int x, int y) -> int {
            if (x < 0 || x >= n || y < 0 || y >= n || x < y)
                return NINF;
            if (x == n - 1 && y == n - 1)
                return 0;
            if (l[x][y] < 0) {
                l[x][y] = max({0, L(x, y + 1), L(x - 1, y + 1), L(x + 1, y + 1)});
                if (x != y)
                    l[x][y] += f[x][y];
            }
            return l[x][y];
        };
        
        for (int i = 0; i < n; ++i)
            res += f[i][i];

        res += U(0, n - 1) + L(n - 1, 0);
        
        return res;
    }
};",1460846323
Aibar Kuanyshbay,kaikaikaikaikai,27,3591,cpp,"class Solution {
public:
    long long cost1(char s, char t, vector<int>& nc) {
        int x = s - 'a';
        int y = t - 'a';
        long long cost = 0;
        while (x != y) {
            cost += nc[x];
            x = (x + 1) % 26;
        }
        return cost;
    }
    long long cost2(char s, char t, vector<int>& nc) {
        int x = s - 'a';
        int y = t - 'a';
        long long cost = 0;
        while (x != y) {
            cost += nc[x];
            x = (x + 25) % 26;
        }
        return cost;
    }
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i])
                continue;
            ans += min(cost1(s[i], t[i], nc), cost2(s[i], t[i], pc));
        }
        return ans;
    }
};",1460807728
Aibar Kuanyshbay,kaikaikaikaikai,27,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; i >= 1; i--) {
            n -= i;
            if (n < 0) {
                if (i % 2 == 0)
                    return 0;
                return 1;
            }
        }   
        return 0;
    }
};",1460797564
Aibar Kuanyshbay,kaikaikaikaikai,27,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& qu) {
        int n = a.size();
        int m = qu.size();
        vector<int> b(n, 0);
        vector<vector<pair<int, int>>> v(n);
        for (int i = 0; i < m; i++) {
            int l = qu[i][0], r = qu[i][1];
            v[l].push_back({i, 1});
            if (r + 1 < n)
                v[r + 1].push_back({i, 0});
        }
        int ans = 0;
        set<pair<int, int>> s;
        for (int i = 0; i < n; i++) {
            if (i > 0)
                b[i] += b[i - 1];

            for (auto j : v[i]) {
                int ind = j.first, t = j.second;
                if (t == 1)
                    s.insert({qu[ind][1], ind});
                else 
                    s.erase({qu[ind][1], ind});
            }            
            while (b[i] < a[i]) {
                if (s.size() == 0)
                    return -1;
                auto pr = *s.rbegin();
                s.erase(pr);
                ans++;
                b[i]++;
                if (pr.first + 1 < n)
                    b[pr.first + 1]--;
            }
        }
        return m - ans;
    }
};",1460840859
Aibar Kuanyshbay,kaikaikaikaikai,27,3648,cpp,"class Solution {
public:
    int calcDP(int n, vector<vector<int>>& f) {
        vector<vector<int>> dp(n, vector<int> (n, 0));
        dp[n - 1][0] = f[n - 1][0];
        for (int i = 0; i < n - 1; i++)
            dp[i][0] = -(int)1e9;
        for (int j = 1; j < n; j++)
            for (int i = 0; i < n; i++) {
                dp[i][j] = -(int)1e9;
                dp[i][j] = max(dp[i][j], dp[i][j - 1] + f[i][j]);
                if (i > 0)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + f[i][j]);
                if (i + 1 < n)
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + f[i][j]);
            }
        return dp[n - 1][n - 1];
    }
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ans = 0;
        int n = f.size();
        for (int i = 0; i < n; i++) {
            ans += f[i][i];
            f[i][i] = 0;
        }
        ans += calcDP(n, f);
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                swap(f[i][j], f[j][i]);
        ans += calcDP(n, f);
        return ans;
    }
};",1460862116
Ian Wong,ianwong1999,28,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        int n = s.size();
        
        for (int i = 0; i < n; i++) {
            int x = s[i] - 'a';
            int y = t[i] - 'a';
            
            auto f = [&] (int d, auto& vec) {
                int p = x;
                int q = y;
                long long ret = 0;
                
                while (p != q) {
                    ret += vec[p];
                    p = (p + d + 26) % 26;
                }
                
                return ret;
            };
            
            res += min(f(1, nextCost), f(-1, previousCost));
        }
        
        return res;
    }
};",1460802211
Ian Wong,ianwong1999,28,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cur = 10;
        bool state = false;
        
        while (true) {
            if (n - cur < 0) {
                return state;
            }
            
            n-= cur;
            cur--;
            state ^= true;
        }
    }
};",1460796593
Ian Wong,ianwong1999,28,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> pref(n + 1);
        
        sort(queries.begin(), queries.end(), [&](const auto& l, const auto& r) {
            return l[0] < r[0];
        });
        
        int pt = 0;
        int take = 0;
        priority_queue<int> pq;
        
        for (int i = 0; i < n; i++) {
            if (i) pref[i] += pref[i - 1];
            nums[i] -= pref[i];
            if (nums[i] <= 0) continue;
            
            while (pt < (int)queries.size() && queries[pt][0] <= i) {
                pq.push(queries[pt][1]);
                pt++;
            }
            
            while (!pq.empty() && pq.top() < i) pq.pop();

            
            while (nums[i] > 0 && !pq.empty()) {
                if (pq.top() < i) {
                    pq.pop();
                    continue;
                }
                nums[i]--;
                pref[i]++;
                pref[pq.top() + 1]--;
                take++;
                pq.pop();
            }
            
            if (nums[i] > 0) return -1;
        }
        
        return (int)queries.size() - take;
    }
};",1460834030
Ian Wong,ianwong1999,28,3648,cpp,"class Solution {
public:
    int dp[1055][1055];
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res = 0;
        int n = fruits.size();
        
        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        
        auto f = [&]() {
            memset(dp, 0, sizeof(dp));
            
            for (int j = 0; j < n; j++) {
                int lim;
                
                if (j < n / 2) lim = n - j - 1;
                else lim = n - (n - j);
                
                for (int i = lim; i < n; i++) {
                    if (j == 0) {
                        dp[i][j] = fruits[i][j];
                        continue;
                    }
                    for (int d = -1; d <= 1; d++) {
                        int k = i + d;
                        
                        if (0 <= k && k < n) {
                            dp[i][j] = max(dp[i][j], dp[k][j - 1] + fruits[i][j]);
                        }
                    }
                }
            }
            res += dp[n - 1][n - 1];
        };

        f();
        auto temp = fruits;
        
        for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) {
            fruits[j][n - i - 1] = temp[i][j];
        }
        f();
        return res;
    }
};",1460857378
ywj568-en,ywj568-en,29,3591,cpp,"using ll = long long;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        int n = s.length();
        ll ans = 0;
        for (int i = 0; i < n; i++) {
            char ch = s[i];
            ll t1 = 0;
            while (ch != t[i]) {
                t1 += nc[ch - 'a'];
                ch = (ch - 'a' + 1) % 26 + 'a';
            }
            ch = s[i];
            ll t2 = 0;
            while (ch != t[i]) {
                t2 += pc[ch - 'a'];
                ch = (ch - 'a' - 1 + 26) % 26 + 'a';
            }
            ans += min(t1, t2);
        }
        return ans;
    }
};",1460815165
ywj568-en,ywj568-en,29,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool t = false;
        int c = 10;
        while (n >= c) {
            n -= c;
            c--;
            t = !t;
        }
        return t;
    }
};",1460800460
ywj568-en,ywj568-en,29,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& qr) {
        int n = nums.size(), q = qr.size();
        vector<vector<int>> sl(n), sr(n);
        for (int i = 0; i < q; i++) {
            int l = qr[i][0], r = qr[i][1];
            sl[l].push_back(r);
            sr[r].push_back(l);
        }
        multiset<int> ms;
        vector<int> d(n + 1);
        int cur = 0, ans = 0;
        for (int i = 0; i < n; i++) {
            for (int r : sl[i]) ms.insert(r);
            while (!ms.empty() && *ms.begin() < i) ms.erase(ms.begin());
            cur += d[i];
            while (cur < nums[i]) {
                if (ms.empty()) return -1;
                auto it = prev(ms.end());
                cur++;
                ans++;
                d[(*it) + 1]--;
                ms.erase(it);
            }
        }
        return q - ans;
    }
};",1460850252
ywj568-en,ywj568-en,29,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for (int i = 0; i < n; i++) {
            for (int j = n - i - 1; j < n; j++) {
                if (i == 0) dp[i][j] = fruits[i][j];
                else {
                    int t1 = j == 0 ? 0 : dp[i - 1][j - 1];
                    int t2 = dp[i - 1][j];
                    int t3 = j == n - 1 ? 0 : dp[i - 1][j + 1];
                    dp[i][j] = max({t1, t2, t3}) + fruits[i][j];
                }
            }
        }
        ans += dp[n - 1][n - 1];
        dp.assign(n, vector<int>(n, 0));
        for (int j = 0; j < n; j++) {
            for (int i = n - j - 1; i < n; i++) {
                if (j == 0) dp[i][j] = fruits[i][j];
                else {
                    int t1 = i == 0 ? 0 : dp[i - 1][j - 1];
                    int t2 = dp[i][j - 1];
                    int t3 = i == n - 1 ? 0 : dp[i + 1][j - 1];
                    dp[i][j] = max({t1, t2, t3}) + fruits[i][j];
                }
            }
        }
        ans += dp[n - 1][n - 1];
        return ans;
    }
};",1460864796
scanhex,scanhex,31,3591,cpp,"
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const long long oo=0x3f3f3f3f3f3f3f3f;
        vector<vector<long long>> c(26, vector<long long>(26, oo));
        for (int i = 0; i < 26; ++i) {
            c[i][i] = 0;
            c[i][(i+1)%26] = nextCost[i];
            c[i][(i+25)%26] = previousCost[i];
        }
        for (int k = 0; k < 26; ++k)
            for (int i = 0; i < 26; ++i)
                for (int j = 0; j < 26; ++j)
                    c[i][j] = min(c[i][j], c[i][k] + c[k][j]);
        long long ans = 0;
        for (int i = 0; i < s.size(); ++i)
            ans += c[s[i]-'a'][t[i]-'a'];
        return ans;
    }
};
",1460827933
scanhex,scanhex,31,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i in range(11):
            if n < 10 - i:
                return i % 2 == 1
            n -= 10 - i",1460826001
scanhex,scanhex,31,3647,cpp,"class Solution {
public:
  int maxRemoval(vector<int> &nums, vector<vector<int>> &queries) {
    int n = nums.size(), q = queries.size();
    vector<vector<int>> op(n);
    for (int i = 0; i < q; ++i)
      op[queries[i][0]].push_back(queries[i][1] + 1);
    multiset<int> st;
    multiset<int> added;
    int ans = 0;
    int cntop = 0;
    for (int i = 0; i < n; ++i) {
      while (st.size() && *st.begin() <= i) {
        st.erase(st.begin());
      }
      while (added.size() && *added.begin() <= i) {
        added.erase(added.begin());
      }
      for (int r : op[i]) {
        st.insert(r);
      }
      while (added.size() < nums[i]) {
        if (st.empty())
          return -1;
        ++ans;
        added.insert(*prev(st.end()));
        st.erase(prev(st.end()));
      }
    }
    return q - ans;
  }
};
",1460846004
scanhex,scanhex,31,3648,cpp,"
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>> fruits) {
        int n = fruits.size();
        int c = 0;
        for (int i = 0; i < n; ++i) {
            c += fruits[i][i];
            fruits[i][i] = 0;
        }
        const int oo=0x3f3f3f3f;
        vector<vector<int>> dp1(n, vector<int>(n, -oo));
        dp1[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                dp1[i][j] = dp1[i - 1][j] + fruits[i][j];
                if (j - 1 > 0) 
                    dp1[i][j] = max(dp1[i][j], dp1[i - 1][j - 1] + fruits[i][j]);
                if (j + 1 < n)
                    dp1[i][j] = max(dp1[i][j], dp1[i - 1][j + 1] + fruits[i][j]);
            }
        }
        vector<vector<int>>dp2(n, vector<int>(n, -oo));
        dp2[n - 1][0] = fruits[n - 1][0];
        for(int j = 1; j < n; ++j) {
            for (int i = 0; i < n; ++i) {
                dp2[i][j] = dp2[i][j - 1] + fruits[i][j];
                if (i - 1 > 0)
                    dp2[i][j] = max(dp2[i][j], dp2[i - 1][j - 1] + fruits[i][j]);
                if (i + 1 < n)
                    dp2[i][j] = max(dp2[i][j], dp2[i + 1][j - 1] + fruits[i][j]);
            }
        }
        return c + dp1[n - 1][n - 1] + dp2[n - 1][n - 1];
    }
};

",1460812917
lilPeep,stupidRR,32,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0ll;
        for(int i=0;i<s.size();i++)
        {
            int a=s[i]-'a';
            int b=t[i]-'a';
            long long way1=0;
            long long way2=0;
            while(a!=b)
            {
                way1=(way1+nextCost[a]);
                a=(a+1)%26;
            }
            a=s[i]-'a';
            while(a!=b)
            {
                way2=(way2+previousCost[a]);
                a=(a+25)%26;
            }
            ans=ans+std::min(way1,way2);
        }
        return ans;
    }
};",1460819734
lilPeep,stupidRR,32,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn=0;
        int sub=10;
        while(sub>0 && n>=sub)
        {
            n=n-sub;
            sub--;
            turn=1-turn;
        }
        return (turn);
    }
};",1460796737
lilPeep,stupidRR,32,3647,cpp,"// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }


struct segment_change {
    // Use a sentinel value rather than a boolean to save significant memory (4-8 bytes per object).
    static const int SENTINEL = numeric_limits<int>::lowest();

    // Note that to_set goes first, and to_add goes after.
    // TODO: check if these values can overflow int.
    int to_set, to_add;

    // TODO: make sure the default constructor is the identity segment_change.
    segment_change(int _to_add = 0, int _to_set = SENTINEL) : to_set(_to_set), to_add(_to_add) {}

    bool has_set() const {
        return to_set != SENTINEL;
    }

    bool has_change() const {
        return has_set() || to_add != 0;
    }

    // Return the combined result of applying this segment_change followed by `other`.
    // TODO: make sure to check for sentinel values.
    segment_change combine(const segment_change &other) const {
        if (other.has_set())
            return other;

        return segment_change(to_add + other.to_add, to_set);
    }
};

struct segment {
    // TODO: check if these values can overflow int.
    int maximum;
    int64_t sum;
    int first, last, max_diff;

    // TODO: make sure the default constructor is the identity segment.
    segment(int _maximum = numeric_limits<int>::lowest(), int64_t _sum = 0, int _first = 0, int _last = 0,
            int _max_diff = -1) : maximum(_maximum), sum(_sum), first(_first), last(_last), max_diff(_max_diff) {}

    bool empty() const {
        return max_diff < 0;
    }

    void apply(int length, const segment_change &change) {
        if (change.has_set()) {
            maximum = change.to_set;
            sum = int64_t(length) * change.to_set;
            first = last = change.to_set;
            max_diff = 0;
        }

        maximum += change.to_add;
        sum += int64_t(length) * change.to_add;
        first += change.to_add;
        last += change.to_add;
    }

    void join(const segment &other) {
        if (empty()) {
            *this = other;
            return;
        } else if (other.empty()) {
            return;
        }

        maximum = max(maximum, other.maximum);
        sum += other.sum;
        max_diff = max({max_diff, other.max_diff, abs(last - other.first)});
        last = other.last;
    }

    // TODO: decide whether to re-implement this for better performance. Mainly relevant when segments contain arrays.
    void join(const segment &seg0, const segment &seg1) {
        *this = seg0;
        join(seg1);
    }
};

struct seg_tree {
    static int highest_bit(unsigned x) {
        return x == 0 ? -1 : 31 - __builtin_clz(x);
    }

    int tree_n = 0;
    vector<segment> tree;
    vector<segment_change> changes;

    seg_tree(int n = -1) {
        if (n >= 0)
            init(n);
    }

    void init(int n) {
        tree_n = 1;

        while (tree_n < n)
            tree_n *= 2;

        tree.assign(2 * tree_n, {});
        changes.assign(tree_n, {});
    }

    // Builds our tree from an array in O(n).
    void build(const vector<segment> &initial) {
        int n = int(initial.size());
        init(n);
        copy(initial.begin(), initial.end(), tree.begin() + tree_n);

        for (int position = tree_n - 1; position > 0; position--)
            tree[position].join(tree[2 * position], tree[2 * position + 1]);
    }

    void _apply_and_combine(int position, int length, const segment_change &change) {
        tree[position].apply(length, change);

        if (position < tree_n)
            changes[position] = changes[position].combine(change);
    }

    void _push_down(int position, int length) {
        if (changes[position].has_change()) {
            _apply_and_combine(2 * position, length / 2, changes[position]);
            _apply_and_combine(2 * position + 1, length / 2, changes[position]);
            changes[position] = segment_change();
        }
    }

    template<typename T_range_op>
    void _process_range(int position, int start, int end, int a, int b, bool needs_join, T_range_op &&range_op) {
        if (a <= start && end <= b) {
            range_op(position, end - start);
            return;
        }

        if (position >= tree_n)
            return;

        _push_down(position, end - start);
        int mid = (start + end) / 2;
        if (a < mid) _process_range(2 * position, start, mid, a, b, needs_join, range_op);
        if (b > mid) _process_range(2 * position + 1, mid, end, a, b, needs_join, range_op);
        if (needs_join) tree[position].join(tree[2 * position], tree[2 * position + 1]);
    }

    segment query(int a, int b) {
        assert(0 <= a && a <= b && b <= tree_n);
        segment answer;

        _process_range(1, 0, tree_n, a, b, false, [&](int position, int) -> void {
            answer.join(tree[position]);
        });

        return answer;
    }

    segment query_full() const {
        return tree[1];
    }

    segment query_single(int index) {
        assert(0 <= index && index < tree_n);
        int position = tree_n + index;

        for (int up = highest_bit(tree_n); up > 0; up--)
            _push_down(position >> up, 1 << up);

        return tree[position];
    }

    void update(int a, int b, const segment_change &change) {
        assert(0 <= a && a <= b && b <= tree_n);

        _process_range(1, 0, tree_n, a, b, true, [&](int position, int length) -> void {
            _apply_and_combine(position, length, change);
        });
    }

    void update_single(int index, const segment &seg) {
        assert(0 <= index && index < tree_n);
        int position = tree_n + index;

        for (int up = highest_bit(tree_n); up > 0; up--)
            _push_down(position >> up, 1 << up);

        tree[position] = seg;

        while (position > 1) {
            position /= 2;
            tree[position].join(tree[2 * position], tree[2 * position + 1]);
        }
    }

    vector<segment> to_array(int n) {
        for (int i = 1; i < tree_n; i++)
            _push_down(i, tree_n >> highest_bit(i));

        return vector<segment>(tree.begin() + tree_n, tree.begin() + tree_n + n);
    }

    // Finds the end of the last prefix of the subarray [a, b) satisfying `should_join` via binary search in O(log n).
    // Return value will be between a - 1 and b, inclusive.
    template<typename T_bool>
    int find_last_subarray(T_bool &&should_join, int a, int b) {
        assert(0 <= a && a <= b && b <= tree_n);
        segment current;

        // Check the degenerate case.
        if (!should_join(current, current))
            return a - 1;

        return y_combinator([&](auto search, int position, int start, int end) -> int {
            if (end <= a) {
                return end;
            } else if (a <= start && end <= b && should_join(current, tree[position])) {
                current.join(tree[position]);
                return end;
            } else if (end - start == 1) {
                return start;
            }

            _push_down(position, end - start);
            int mid = (start + end) / 2;
            int left = search(2 * position, start, mid);
            return left < mid ? left : search(2 * position + 1, mid, end);
        })(1, 0, tree_n);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n=nums.size();
        vector<int> pre(n+1);

        seg_tree tree(n);
        tree.build(vector<segment>(n, segment(0, 0, 0, 0, 0)));
        for(auto query : queries)
        {
            int l=query[0];
            int r=query[1];
            pre[l]++;
            pre[r+1]--;
            tree.update(l, r+1, segment_change(int(-1)));
        }
        for(int i=1;i<=n;i++)
            pre[i]+=pre[i-1];
        
        for(int i=0;i<n;i++)
        {
            if(nums[i]>pre[i])
                return -1;
            tree.update(i, i+1, segment_change(int( nums[i] )));
        }

        int ans=0;
        sort(queries.begin(),queries.end(),[&](vector<int>&a,vector<int>&b){
            return a[1]<b[1];
        });

        for(auto query : queries)
        {
            int l=query[0];
            int r=query[1];
            tree.update(l, r+1, segment_change(int(1)));
            if(tree.query(l,r+1).maximum <= 0 )
                ans++;
            else
                tree.update(l, r+1, segment_change(int(-1)));
        }

        return ans;
    
    }
};",1460866908
lilPeep,stupidRR,32,3648,cpp,"class Solution {
    int solve(vector<vector<int>>&grid,int row,int col,int type)
    {
        int n=grid.size();
        vector<vector<int>> dp(n,vector<int>(n));
        dp[row][col]=grid[row][col];
        queue< pair<int,int> > bfs;
        bfs.push({row,col});
        int moves=n-1;
        while(moves--)
        {
            set< pair<int,int> > nbfs;
            while( !bfs.empty() )
            {
                auto [row,col]=bfs.front();
                bfs.pop();
                
                if(type==0)
                {
                    for(int j=-1;j<=1;j++)
                    {
                        if( row+j>=0 && row+j<n )
                        {
                            dp[row+j][col+1]=std::max(dp[row+j][col+1],dp[row][col]+grid[row+j][col+1]);
                            nbfs.insert({row+j,col+1});
                        }
                    }
                }
                else
                {
                    for(int j=-1;j<=1;j++)
                    {
                        if( col+j>=0 && col+j<n )
                        {
                            dp[row+1][col+j]=std::max(dp[row+1][col+j],dp[row][col]+grid[row+1][col+j]);
                            nbfs.insert({row+1,col+j});
                        }
                    }
                }
            }
            
            for(auto &[a,b] : nbfs)
                bfs.push({a,b});
        }
        
        return dp[n-1][n-1];
    }
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        long long ans=0ll;
        int n=fruits.size();
        vector<vector<int>> grid(n,vector<int>(n));
        vector<vector<int>> grid2(n,vector<int>(n));
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(i==j)
                    ans=ans+fruits[i][j];
                else if(i>j)
                    grid[i][j]=fruits[i][j];
                else
                    grid2[i][j]=fruits[i][j];
            }
        }
        
        return ans+solve(grid,n-1,0,0)+solve(grid2,0,n-1,1);
    }
};",1460842123
LucasLyu,Lucas595,36,3591,python3,"from typing import List


class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
        
        for i in range(len(s)):
            start_char = s[i]
            end_char = t[i]
            
            forward_distance = (ord(end_char) - ord(start_char)) % 26
            forward_cost = sum(nextCost[(ord(start_char) - ord('a') + j) % 26] for j in range(forward_distance))
            
            backward_distance = (ord(start_char) - ord(end_char)) % 26
            backward_cost = sum(previousCost[(ord(start_char) - ord('a') - j) % 26] for j in range(backward_distance))

            total_cost += min(forward_cost, backward_cost)
        
        return total_cost",1460817689
LucasLyu,Lucas595,36,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        
        stones_to_remove = 10
        alice_turn = True
        
        while n >= 0:
            if n < stones_to_remove:
                return not alice_turn
            n -= stones_to_remove
            stones_to_remove -= 1
            alice_turn = not alice_turn
        
        return True",1460802757
LucasLyu,Lucas595,36,3647,python3,"from typing import List
import heapq

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        q = len(queries)
        
        diff = [0] * (n + 1)
        for query in queries:
            li, ri = query
            diff[li] +=1
            if ri +1 < len(diff):
                diff[ri +1] -=1
        
        coverage = [0] * n
        current = 0
        for j in range(n):
            current += diff[j]
            coverage[j] = current
        
        for j in range(n):
            if coverage[j] < nums[j]:
                return -1
        
        if sum(nums) ==0:
            return q
        
        sorted_queries = sorted(queries, key=lambda x: (x[0], -x[1]))
        
        heap = []
        kept_queries = 0
        delta = [0] * (n + 2)
        coverage_assigned = 0
        q_idx =0
        
        for j in range(n):
            coverage_assigned += delta[j]
            
            while q_idx < q and sorted_queries[q_idx][0] <=j:
                ri = sorted_queries[q_idx][1]
                heapq.heappush(heap, -ri)
                q_idx +=1
            
            while heap and -heap[0] <j:
                heapq.heappop(heap)
            
            needed = nums[j] - coverage_assigned
            if needed >0:
                if len(heap) < needed:
                    return -1 
                
                for _ in range(needed):
                    if not heap:
                        return -1
                    r_i = -heapq.heappop(heap)
                    kept_queries +=1
                    coverage_assigned +=1
                    if j <= r_i:
                        delta[j] +=1
                        delta[r_i +1] -=1
        return q - kept_queries",1460850074
LucasLyu,Lucas595,36,3648,python3,"from typing import List

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        
        sum1 = 0
        for i in range(n):
            sum1 += fruits[i][i]
        
        dp_prev = [-10**9] * n
        dp_prev[n-1] = fruits[0][n-1] if not (0 == n-1 and 0 != n-1) else fruits[0][n-1]
        for t in range(1, n):
            dp_curr = [-10**9] * n
            for j in range(n):
                if j ==t and t !=n-1:
                    fruit = 0
                else:
                    fruit = fruits[t][j]
                for delta_j in (-1,0,1):
                    prev_j = j - delta_j
                    if 0 <= prev_j <n:
                        if dp_prev[prev_j] != -10**9:
                            dp_curr[j] = max(dp_curr[j], dp_prev[prev_j] + fruit)
            dp_prev = dp_curr
        sum2 = dp_prev[n-1]
        
        dp_prev = [-10**9] * n
        dp_prev[n-1] = fruits[n-1][0] if not (n-1 ==0 and 0 !=n-1) else fruits[n-1][0]
        for t in range(1, n):
            dp_curr = [-10**9] * n
            for i in range(n):
                if i ==t and t !=n-1:
                    fruit = 0
                else:
                    fruit = fruits[i][t]
                for delta_i in (-1,0,1):
                    prev_i = i - delta_i
                    if 0 <= prev_i <n:
                        if dp_prev[prev_i] != -10**9:
                            dp_curr[i] = max(dp_curr[i], dp_prev[prev_i] + fruit)
            dp_prev = dp_curr
        sum3 = dp_prev[n-1]
        
        total = sum1 + sum2 + sum3
        total -= 2 * fruits[n-1][n-1]
        
        return total",1460841274
Andrey,A_Le_K,40,3591,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 1
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

inline int toi(char c)
{
    return c-'a';
}
const int A=26;

ll solve(const int from, const int to, vector<int>& nextCost, vector<int>& previousCost)
{
    ll cost1=0, cost2=0;
    
    for(int i=from; i!=to; i=(i+1)%A) {
        cost1+=nextCost[i];
    }
    for(int i=from; i!=to; i=(i-1+A)%A)
    {
        cost2+=previousCost[i];
    }
    
    return min(cost1, cost2);
}

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const int n=s.size();
        ll result=0;
        
        FOR(i, n) {
            const int si=toi(s[i]), ti=toi(t[i]);
            result+=solve(si, ti, nextCost,  previousCost);
        }
        
        return result;
    }
};",1460805889
Andrey,A_Le_K,40,3625,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 1
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif


class Solution {
public:
    bool canAliceWin(int n) {
        for(int d=10; d>=1; d--) {
            if(n<d) 
            {
                if(d%2==0) return false;
                return true;
            }
            else n-=d;
        }
        assert(false);
        return true;
    }
};",1460797670
Andrey,A_Le_K,40,3647,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 0
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif


class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& queries) {
        dbg(""========"");
        const int n=a.size();
        const int q=queries.size();
        vector<pii> lr;
        
        vector<vector<int>> starts_at(n+1);
        
        dbg(n, q);
        
        vector<int> delta(n+1, 0);
        for( auto qq: queries) {
            const int l=qq[0], r=qq[1];
            lr.pb({l, r}); 
            
            delta[l]++;
            delta[r+1]--;
            
            starts_at[l].pb(r);
        }
        
        dbg(delta);
        
        vector<int> S=delta;
        FOR(i, n) {
            S[i+1]+=S[i];
        }
        
        dbg(S);
        
        const int NOANS=-1;
        FOR(i, n) if(a[i]>S[i]) return NOANS;
        
        //int currently_removed=0;
        int min_intervals_to_take=0;
        
        //int balance_intervals=0;
        multiset<int> currently_open_Rs; // Rs of [L, R]
        int balance=0;
        
        vector<int> balance_deltas(n+1, 0);
        
        //for(int i=0; i<n; i)
        FOR(i, n) {
            dbg(i, balance, balance_deltas, currently_open_Rs);
            
            balance-=balance_deltas[i];
            int current_a=a[i]-balance;
            
            for(int r: starts_at[i]) currently_open_Rs.insert(r);
            
            while(current_a>0) {
                assert(!currently_open_Rs.empty());
                auto it=currently_open_Rs.end(); --it;
                int r=*it; currently_open_Rs.erase(it);
                
                balance++;
                current_a--;
                balance_deltas[r+1]++;
                min_intervals_to_take++;
            }
            
            while(!currently_open_Rs.empty())
            {
                auto it=currently_open_Rs.begin();
                if(*it<=i) {
                    currently_open_Rs.erase(it);
                } else break;
            }
        }
        
        dbg(min_intervals_to_take);
        return q-min_intervals_to_take;
        //return -42;
    }
};",1460865068
Andrey,A_Le_K,40,3648,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 0
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif


class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& g) {
        const int n=g.size();
        
        //vector<vector<int>> dp(n, vector<int>(n, 0));
        const ll INF=1e18;
        vector<vector<ll>> dp_up(n, vector<ll>(n, -INF));
        vector<vector<ll>> dp_down(n, vector<ll>(n, -INF));
        
        dbg(""up, down got"");
        
        //auto dp_up=g;
        //auto dp_down=g;
        dp_up[0][n-1]=g[0][n-1];
        dp_down[n-1][0]=g[n-1][0];
        
        FOR(i, n) {
            if(i+1>=n) continue;
            FOR(j, n) {
                const ll curr=dp_up[i][j];
                if(0<=j-1)  domax(dp_up[i+1][j-1], curr+g[i+1][j-1]);
                            domax(dp_up[i+1][j  ], curr+g[i+1][j  ]);
                if(j+1<n)   domax(dp_up[i+1][j+1], curr+g[i+1][j+1]);
            }

        }
        
        dbg(""done up"");
        
        FOR(j, n) {
            if(j+1>=n) continue;
            FOR(i, n) {
                const ll curr=dp_down[i][j];
                if(0<=i-1)  domax(dp_down[i-1][j+1], curr+g[i-1][j+1]);
                            domax(dp_down[i  ][j+1], curr+g[i  ][j+1]);
                if(i+1<n)   domax(dp_down[i+1][j+1], curr+g[i+1][j+1]);
            }            
        }
        
        dbg(""done down"");
        
        ll sum_diag=0;
        FOR(i, n) sum_diag+=g[i][i];
        const ll res1=dp_up[n-2][n-1];
        const ll res2=dp_down[n-1][n-2];
        
        const ll result=sum_diag+res1+res2;
        
        dbg(sum_diag, res1, res2, result);
        
        return result;
    }
};",1460840312
Boris Williams,boriswilliams,47,3591,python3,"def ind(c: str) -> int:
    return ord(c) - 97

class Solution:
    def shiftDistance(self, s: str, t: str, nc: List[int], pc: List[int]) -> int:
        
        cnc = [0]*(2*len(nc))
        for i in range(1, 2*len(nc)):
            cnc[i] = cnc[i-1] + nc[(i-1)%len(nc)]
        cpc = [0]*(2*len(pc))
        for i in range(1, 2*len(pc)):
            cpc[i] = cpc[i-1] + pc[(i)%len(pc)]
        
        r = 0
        for i in range(len(s)):
            j, k = ind(s[i]), ind(t[i])
            if k < j:
                k += 26
            v = cnc[k] - cnc[j]
            j, k = ind(s[i]), ind(t[i])
            if j < k:
                j += 26
            v = min(v, cpc[j] - cpc[k])
            r += v
        return r",1460823160
Boris Williams,boriswilliams,47,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        r = False
        x = 10
        while n >= x:
            n -= x
            x -= 1
            r = not r
        return r",1460796803
Boris Williams,boriswilliams,47,3647,python3,"class Solution:
    def maxRemoval(self, a: List[int], queries: List[List[int]]) -> int:
        n = len(a)
        start = len(queries)
        heapq.heapify(queries) # sorted by smallest start
        available = [] # sorted by largest end
        curr = [] # sorted by smallest end
        used = 0
        for i in range(n):
            while queries and queries[0][0] == i:
                heapq.heappush(available, -heapq.heappop(queries)[1])
            while curr and curr[0] < i:
                heapq.heappop(curr)
            #print(i)
            #print('queries', queries)
            #print('available', available)
            a[i] -= len(curr)
            while a[i] > 0 and available and -available[0] >= i:
                a[i] -= 1
                used += 1
                heapq.heappush(curr, -heapq.heappop(available))
            #print('active', curr)
            if a[i] > 0:
                #print(a, i, a[i])
                return -1
        return start - used",1460867990
Boris Williams,boriswilliams,47,3648,python3,"class Solution:
    def maxCollectedFruits(self, a: List[List[int]]) -> int:
        n = len(a)
        r = 0
        for i in range(n):
            r += a[i][i]
            a[i][i] = 0
        tr = [-1]*n
        tr[-1] = a[0][-1]
        for i in range(1, n):
            temp = [-1]*n
            for j in range(n):
                for k in range(max(j-1, 0), min(j+2, n)):
                    temp[j] = max(temp[j], tr[k])
                if temp[j] != -1:
                    temp[j] += a[i][j]
            tr = temp
        r += tr[-1]
        bl = [-1]*n
        bl[-1] = a[-1][0]
        for j in range(1, n):
            temp = [-1]*n
            for i in range(n):
                for k in range(max(i-1, 0), min(i+2, n)):
                    temp[i] = max(temp[i], bl[k])
                if temp[i] != -1:
                    temp[i] += a[i][j]
            bl = temp
        r += bl[-1]
        return r",1460845473
papapolak,papapolak,49,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        result = 0
        for i in range(1, len(nextCost)):
            nextCost[i] += nextCost[i-1]
            previousCost[i] += previousCost[i-1]
        nextCost.insert(0, 0)
        previousCost.insert(0, 0)
        # print(previousCost)
        for i, (x, y) in enumerate(zip(s, t)):
            if x == y:
                continue
            x = ord(x) - 97
            y = ord(y) - 97
            if x < y:
                res_next = nextCost[y] - nextCost[x]
            else:
                res_next = nextCost[-1] - nextCost[x] + nextCost[y]
            if x > y:
                res_prev = previousCost[x+1] - previousCost[y+1]
            else:
                res_prev = previousCost[x+1] + previousCost[-1] - previousCost[y+1]
            # print(x, y, res_next, res_prev, previousCost[y], previousCost[-1], previousCost[x+1])
            
            #     res_next = sum(nextCost[x:y])
            # else:
            #     res_next = sum(nextCost[x:]) + sum(nextCost[:y])
            # if x > y:
            #     res_prev = sum(previousCost[y+1:x+1])
            # else:
            #     res_prev = sum(previousCost[:x+1]) + sum(previousCost[y+1:])
            result += min(res_next, res_prev)
        return result",1460840275
papapolak,papapolak,49,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i in range(10, 0, -1):
            if n < i:
                return i % 2 == 1
            n -= i
        return False",1460797511
papapolak,papapolak,49,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        backlog = []
        remained = []
        j = 0
        for i in range(len(nums)):
            # print(i)
            while j != len(queries) and queries[j][0] == i:
                heappush(backlog, -queries[j][1])
                j += 1
            while remained and remained[0] < i:
                heappop(remained)
            # print(backlog, remained)
            while nums[i] > len(remained):
                if not backlog or -backlog[0] < i:
                    return -1
                heappush(remained, -heappop(backlog))
        return len(backlog)",1460855512
papapolak,papapolak,49,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        
        result = 0
        for i in range(n):
            result += fruits[i][i]
            
        lst = [fruits[n-1][0]]
        for i in range(1, n-1):
            new_list = [fruits[j][i] for j in range(n-i-1, n)]
            for j in range(len(new_list)):
                new_list[j] += max(lst[max(0, j-2):j+1])
            lst = new_list
        result += lst[-1]
            
        lst = [fruits[0][n-1]]
        for i in range(1, n-1):
            new_list = [fruits[i][j] for j in range(n-i-1, n)]
            for j in range(len(new_list)):
                new_list[j] += max(lst[max(0, j-2):j+1])
            lst = new_list
        result += lst[-1]

        return result",1460875149
sveng101,sveng101,51,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ord_a = ord(""a"")
        def char2Num(l: str) -> int:
            return ord(l) - ord_a

        nxt_arr_cumu = [0]
        prev_arr_cumu = [0]
        for i in range(26):
            nxt_arr_cumu.append(nxt_arr_cumu[-1] + nextCost[i])
            prev_arr_cumu.append(prev_arr_cumu[-1] + previousCost[i])
        #print(nxt_arr_cumu)
        #print(prev_arr_cumu)
        def minCost(l1: str, l2: str) -> int:
            if l1 == l2: return 0
            num1 = char2Num(l1)
            num2 = char2Num(l2)
            #print(l1, num1, l2, num2)
            if num2 > num1:
                nc = nxt_arr_cumu[num2] - nxt_arr_cumu[num1]
                pc = prev_arr_cumu[num1 + 1] + prev_arr_cumu[-1] - prev_arr_cumu[num2 + 1]
            else:
                nc = nxt_arr_cumu[num2] + nxt_arr_cumu[-1] - nxt_arr_cumu[num1]
                pc = prev_arr_cumu[num1 + 1] - prev_arr_cumu[num2 + 1]
            #print(nc, pc)
            return min(nc, pc)

        return sum(minCost(l1, l2) for l1, l2 in zip(s, t))",1460826891
sveng101,sveng101,51,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        diff = 10
        res = True
        while n >= 0:
            n -= diff
            res = not res
            #print(n, res)
            diff -= 1
        return res",1460803276
sveng101,sveng101,51,3647,python3,"import heapq
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        ends_incl_heap = []
        ends_excl_heap = []
        queries.sort()

        n_q = len(queries)
        q_i = 0
        curr_cover = 0
        res = 0
        for i, num in enumerate(nums):
            #print(i, num, q_i, curr_cover)
            while ends_incl_heap and ends_incl_heap[0] < i:
                heapq.heappop(ends_incl_heap)
                curr_cover -= 1
            while q_i < n_q and queries[q_i][0] <= i:
                heapq.heappush(ends_excl_heap, -queries[q_i][1])
                q_i += 1
            #print(ends_excl_heap)
            while curr_cover < num:
                if not ends_excl_heap or -ends_excl_heap[0] < i: return -1
                j = -heapq.heappop(ends_excl_heap)
                heapq.heappush(ends_incl_heap, j)
                res += 1
                curr_cover += 1
            #print(ends_excl_heap)
            #print(ends_incl_heap)
        return n_q - res
                ",1460847198
sveng101,sveng101,51,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        res = sum(fruits[i][i] for i in range(n))

        curr = [fruits[n - 2][n - 1]]
        #print(curr)
        for i1 in reversed(range(n - 2)):
            l = min(len(curr) + 1, i1 + 1)
            i2 = n
            prev = curr
            curr = []
            
            for j in range(l):
                i2 -= 1
                ans = -float(""inf"")
                if j > 0:
                    ans = max(ans, prev[j - 1])
                if j < len(prev):
                    ans = max(ans, prev[j])
                if j + 1 < len(prev):
                    ans = max(ans, prev[j + 1])
                curr.append(ans + fruits[i1][~j])
            #print(curr)
        res += curr[0]

        curr = [fruits[n - 1][n - 2]]
        #print(curr)
        for i1 in reversed(range(n - 2)):
            l = min(len(curr) + 1, i1 + 1)
            i2 = n
            prev = curr
            curr = []
            
            for j in range(l):
                i2 -= 1
                ans = -float(""inf"")
                if j > 0:
                    ans = max(ans, prev[j - 1])
                if j < len(prev):
                    ans = max(ans, prev[j])
                if j + 1 < len(prev):
                    ans = max(ans, prev[j + 1])
                curr.append(ans + fruits[~j][i1])
            #print(curr)
        res += curr[0]

        return res",1460875524
Yifeng,gaoyf1235,52,3591,cpp,"class Solution {
    using ll = long long;
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll res = 0;
        int n = s.size();
        for(int i = 0; i < n; i++){
            if(s[i] != t[i]){
                auto si = s[i] - 'a';
                auto ti = t[i] - 'a';
                ll c1 = 0;
                auto c = si;
                while(c != ti){
                    c1 += nextCost[c];
                    c = (c + 1) % 26;
                }
                ll c2 = 0;
                c = si;
                while(c != ti){
                    c2 += previousCost[c];
                    c = (c + 25) % 26;
                }
                res += min(c1, c2);
            }
        }
        return res;
    }
};",1460811794
Yifeng,gaoyf1235,52,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int t = 0;
        int x = 10;
        while(n >= x){
            t = 1 - t;
            n -= x;
            x--;
        }
        return t == 1;
    }
};",1460797003
Yifeng,gaoyf1235,52,3647,cpp,"class Solution {
    
    template<typename T>
    using MinHeap = priority_queue<T, std::vector<T>, std::greater<T>>;

    template<typename T>
    using MaxHeap = priority_queue<T>;
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        auto mx = max_element(nums.begin(), nums.end());
        vector<vector<int>> lrs(n);
        for(auto& q : queries){
            auto l = q[0];
            auto r = q[1];
            lrs[l].push_back(r);
        }
        int res = 0;
        MaxHeap<int> pq;
        multiset<int> has;
        for(int i = 0; i < n; i++){
            auto x = nums[i];
            for(auto& r : lrs[i]){
                pq.push(r);
            }
            while(has.size() < x && !pq.empty()){
                auto t = pq.top();
                pq.pop();
                if(t >= i){
                    has.insert(t);
                    res++;
                }
            }
            if(has.size() < x) {
                return -1;
            }
            has.erase(i);
        }
        return queries.size() - res;
    }
};",1460846671
Yifeng,gaoyf1235,52,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int res = 0;
        for(int i = 0; i < n; i++){
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<int> dp(n, INT_MIN);
        dp[n-1] = fruits[n-1][0];
        for(int i = 1; i < n; i++){
            vector<int> ndp(n, INT_MIN);
            for(int r = n - 1; r >= 0; r--){
                if(dp[r] == INT_MIN) break;
                for(int k = -1; k <= 1; k++){
                    if(r + k >= 0 && r + k < n){
                        ndp[r+k] = max(ndp[r+k], dp[r] + fruits[r+k][i]);
                    }
                }
            }
            dp = ndp;
        }
        res += dp[n-1];
        
        dp = vector<int>(n, INT_MIN);
        dp[n-1] = fruits[0][n-1];
        for(int i = 1; i < n; i++){
            vector<int> ndp(n, INT_MIN);
            for(int c = n - 1; c >= 0; c--){
                if(dp[c] == INT_MIN) break;
                for(int k = -1; k <= 1; k++){
                    if(c + k >= 0 && c + k < n){
                        ndp[c+k] = max(ndp[c+k], dp[c] + fruits[i][c+k]);
                    }
                }
            }
            dp = ndp;
        }
        res += dp[n-1];
        return res;
        
    }
};",1460869595
joylintp,joylintp,53,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ret = 0;
        vector<long long> preNext(27), prePrev(27);
        for (int i = 1; i <= 26; i++)
        {
            preNext[i] = preNext[i - 1] + nextCost[i - 1];
            prePrev[i] = prePrev[i - 1] + previousCost[i - 1];
        }
        for (int i = 0; i < s.size(); i++)
        {
            long long next = 0, prev = 0;
            if (s[i] < t[i])
            {
                next = preNext[t[i] - 'a'] - preNext[s[i] - 'a'];
                prev = prePrev[26] - (prePrev[t[i] - 'a' + 1] - prePrev[s[i] - 'a' + 1]);
            }
            else if (s[i] > t[i])
            {
                prev = prePrev[s[i] - 'a' + 1] - prePrev[t[i] - 'a' + 1];
                next = preNext[26] - (preNext[s[i] - 'a'] - preNext[t[i] - 'a']);
            }
            else;
            ret += min(prev, next);
        }
        return ret;
    }
};",1460834825
joylintp,joylintp,53,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; ; i--)
        {
            if (n < i)
                return i % 2;
            n -= i;
        }
    }
};",1460814468
joylintp,joylintp,53,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());

        int idx = 0, cur = 0;
        vector<int> cnt(nums.size());
        priority_queue<int> pool;
        for (int i = 0; i < nums.size(); i++)
        {
            while (idx < queries.size() && queries[idx][0] <= i)
                pool.push(queries[idx][1]), idx++;
            while (!pool.empty() && cur < nums[i])
            {
                int x = pool.top();
                pool.pop();
                if (x >= i)
                    cur++, cnt[x]++;
            }
            if (cur < nums[i])
                return -1;
            cur -= cnt[i];
        }

        int ret = queries.size();
        for (int &x : cnt)
            ret -= x;
        return ret;
    }
};",1460851337
joylintp,joylintp,53,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int N = fruits.size(), ret = 0;
        for (int i = 0; i < N; i++)
            ret += fruits[i][i];

        vector<vector<int>> dp(N, vector(N, (int)-1e9));
        dp[N - 1][0] = fruits[N - 1][0];
        for (int j = 1; j < N; j++)
            for (int i = j + 1; i < N; i++)
            {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j]);
                dp[i][j] = max(dp[i][j], dp[i][j - 1] + fruits[i][j]);
                if (i + 1 < N)
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + fruits[i][j]);
            }
        dp[0][N - 1] = fruits[0][N - 1];
        for (int i = 1; i < N; i++)
            for (int j = i + 1; j < N; j++)
            {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j]);
                dp[i][j] = max(dp[i][j], dp[i - 1][j] + fruits[i][j]);
                if (j + 1 < N)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + fruits[i][j]);
            }
        return ret + dp[N - 2][N - 1] + dp[N - 1][N - 2];
    }
};",1460869663
xymabinogi,xymabinogi,54,3591,cpp,"using i64 = long long;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& pre) {
        int n = s.length();
        i64 res = 0;
        for (int i = 0; i < n; i++){
            if (s[i] == t[i]) continue;
            //fwd
            i64 x = 0, y = 0;
            auto v = s[i];
            while(v != t[i]){
                x += nxt[v - 'a'];
                v++;
                if (v > 'z') v = 'a';
            }
            v = s[i];
            while(v != t[i]){
                y += pre[v - 'a'];
                v--;
                if (v < 'a') v = 'z';
            }
            res += min(x, y);
            
            
        }
        return res;
    }
};",1460819488
xymabinogi,xymabinogi,54,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ok = false;
        int v = 10;
        while(true){
            if (n >= v){
                ok ^= 1;
                n -= v;
                v -= 1;
            }
            else return ok;
        }
        return 0;
    }
};",1460796878
xymabinogi,xymabinogi,54,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size();
        priority_queue<int> pq;
        priority_queue<int, vector<int>, greater<int>> used;
        sort(q.begin(), q.end());
        
        int cur = 0;
        int m = q.size();
        int cnt = 0;
        for (int i = 0, j = 0; i < n; i++){
            while(j < m and q[j][0] <= i){
                pq.push(q[j][1]);
                j++;
            }
            while(!used.empty() and used.top() < i){
                cur--;
                used.pop();
            }
            while(cur < nums[i]){
                if (pq.empty() or pq.top() < i) return -1;
                int v = pq.top(); pq.pop();
                cnt++;
                cur++;
                used.push(v);
            }
            //cout << i <<"" ""<< j <<"" ""<< cnt <<"" ""<< cur << ""--\n"";
        }
       // cout << cnt << ""------\n"";
        return m - cnt;
        
    }
};",1460839547
xymabinogi,xymabinogi,54,3648,cpp,"const int INF = 1 << 25;
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& g) {
        int n = g.size();
        vector dp1(n, vector<int>(n, -INF)), dp2(n, vector<int>(n, -INF));
        dp1[n - 1][0] = g[n - 1][0];
        
        for (int j = 1; j < n; j++){
            for (int i = j; i < n; i++){
                dp1[i][j] = (i == j ? 0 : g[i][j]);
                int mx = -INF;
                if (i) mx = max(mx, dp1[i - 1][j - 1]);
                mx = max(mx, dp1[i][j - 1]);
                if (i + 1 < n) mx = max(mx, dp1[i + 1][j - 1]);
                dp1[i][j] += mx;
            }
        }
        
        dp2[0][n - 1] = g[0][n - 1];
        for (int i = 1; i < n; i++){
            for (int j = i; j < n; j++){
                dp2[i][j] = (i == j ? 0 : g[i][j]);
                int mx = -INF;
                if (j) mx = max(mx, dp2[i - 1][j - 1]);
                mx = max(mx, dp2[i - 1][j]);
                if (j + 1 < n) mx = max(mx, dp2[i - 1][j + 1]);
                dp2[i][j] += mx;
            }
        }
        int res = dp1[n - 1][n - 1] + dp2[n - 1][n - 1];
        for (int i = 0; i < n; i++){
            res += g[i][i];
        }
        
        return res;

    }
};",1460863421
washedup,rejudge_thiz,55,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n=s.size();
        using ll=long long;
        array<array<ll,26>,26> f{},b{};
        for(int i=0;i<26;i++){
            for(int j=1;j<26;j++) f[i][(i+j)%26]=f[i][(i+j-1)%26]+nextCost[(i+j-1)%26];
            for(int j=1;j<26;j++) b[i][(i-j+26)%26]=b[i][(i-j+27)%26]+previousCost[(i-j+27)%26];
        }
        ll re = 0;
        for(int i=0;i<n;i++){
            re+=min(f[s[i]-'a'][t[i]-'a'],b[s[i]-'a'][t[i]-'a']);
        }
        return re;
    }
};",1460811816
washedup,rejudge_thiz,55,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i=10,a=true;
        while(n>=i){
            n-=i;
            a=!a;
            i--;
        }
        return !a;
    }
};",1460797732
washedup,rejudge_thiz,55,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(),q=queries.size();
        vector<pair<int,int>> v(q);
        vector<int> seg(2*n);
        auto add = [&](int l,int r){
            for(l+=n,r+=n;l<r;l>>=1,r>>=1){
                if(l&1) seg[l++]++;
                if(r&1) seg[--r]++;
            }
        };
        auto query = [&](int p){
            int re =seg[p+=n];
            while(p>1){
                p>>=1;re+=seg[p];
            }
            return re;
        };
        for(int i=0;i<q;i++) v[i]={queries[i][0],queries[i][1]};
        sort(v.begin(),v.end(),[](auto a,auto b){
            return a.first==b.first ? a.second > b.second : a.first < b.first;
        });
        int id=0;
        auto comp = [](const pair<int,int>& a,const pair<int,int>& b){
            return a.second < b.second;
        };
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comp)> pq(comp);
        for(int i=0;i<n;i++){
            while(id < q && v[id].first <= i) pq.push(v[id++]);
            int k = query(i);
            while(k<nums[i] && !pq.empty()){
                auto [l,r] = pq.top();
                pq.pop();
                add(l,r+1);
                if(r>=i) k++;
            }
            if(k<nums[i]) return -1;
        }
        return pq.size();
    }
};",1460828470
washedup,rejudge_thiz,55,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int re=0,n=fruits.size();
        for(int i=0;i<n;i++) re+=fruits[i][i];
        vector<vector<int>> dp1(n,vector<int>(n,-1)),dp2(n,vector<int>(n,-1));
        dp1[0][n-1]=fruits[0][n-1];
        for(int i=0;i+1<n;i++){
            for(int j=n-1;j>i && dp1[i][j]!=-1;j--){
                if(j<n && j>i+1) dp1[i+1][j]=max(dp1[i+1][j],dp1[i][j]+fruits[i+1][j]);
                if(j-1<n && j-1>i+1) dp1[i+1][j-1]=max(dp1[i+1][j-1],dp1[i][j]+fruits[i+1][j-1]);
                if(j+1<n && j+1>i+1) dp1[i+1][j+1]=max(dp1[i+1][j+1],dp1[i][j]+fruits[i+1][j+1]);
            }
        }
        dp2[n-1][0]=fruits[n-1][0];
        for(int i=0;i+1<n;i++){
            for(int j=n-1;j>i && dp2[j][i]!=-1;j--){
                if(j<n && j>i+1) dp2[j][i+1]=max(dp2[j][i+1],dp2[j][i]+fruits[j][i+1]);
                if(j-1<n && j-1>i+1) dp2[j-1][i+1]=max(dp2[j-1][i+1],dp2[j][i]+fruits[j-1][i+1]);
                if(j+1<n && j+1>i+1) dp2[j+1][i+1]=max(dp2[j+1][i+1],dp2[j][i]+fruits[j+1][i+1]);
            }
        }
        return dp1[n-2][n-1]+dp2[n-1][n-2]+re;
    }
};",1460857169
hongyili,hongyili,56,3591,python3,"class Solution:
    def helper(self, f, t):
        key = f, t
        if key in self.mem:
            return self.mem[key]
        p = f
        c = 0
        while p != t:
            c += self.nextCost[p]
            p += 1
            p %= 26
        r = c
        p = f
        c = 0
        while p != t:
            c += self.previousCost[p]
            p -= 1
            p %= 26
        r = min(r, c)
        self.mem[key] = r
        return self.mem[key]
        
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        self.c_to_i = {c: i for i, c in enumerate('abcdefghijklmnopqrstuvwxyz')}
        assert len(self.c_to_i) == 26
        self.nextCost = nextCost
        self.previousCost = previousCost
        self.mem = {}
        rst = 0
        for c1, c2 in zip(s, t):
            rst += self.helper(self.c_to_i[c1], self.c_to_i[c2])
        return rst",1460813574
hongyili,hongyili,56,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rmv = 10
        a = True
        while rmv > 0 and n >= rmv:
            n -= rmv
            rmv -= 1
            a = not a
        return not a
        ",1460796998
hongyili,hongyili,56,3647,python3,"from sortedcontainers import SortedList
import heapq


class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries = [(stt, end) for stt, end in queries]
        queries.sort()
        q = 0
        h = []
        ends = SortedList()
        rr = 0
        for i, v in enumerate(nums):
            j = ends.bisect_left(i)
            already = len(ends) - j
            v -= already
            while q < len(queries) and queries[q][0] <= i:
                heapq.heappush(h, -queries[q][1])
                q += 1
            while v > 0:
                if len(h) == 0 or -h[0] < i:
                    return -1
                end = -heapq.heappop(h)
                v -= 1
                ends.add(end)
                rr += 1
        return len(queries) - rr
                
        ",1460848691
hongyili,hongyili,56,3648,python3,"class Solution:
    def helper(self, i, j):
        key = i, j
        if key in self.mem:
            return self.mem[key]
        if self.n - j > self.n - i:
            self.mem[key] = -float('inf')
            return self.mem[key]
        
        #assert i < self.n
        #assert j < self.n
        
        cur = 0 if i == j else self.fruits[i][j]
        add = 0
        for nj in [j-1, j, j+1]:
            if nj < 0 or nj >= self.n:
                continue
            add = max(add, self.helper(i+1, nj))
        self.mem[key] = cur + add
        return self.mem[key]
    
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        self.fruits = fruits
        self.n = len(fruits)
        self.mem = {(self.n-1, self.n-1): 0}
        rst = self.helper(0, self.n-1)
        
        for i in range(self.n):
            rst += self.fruits[i][i]
            for j in range(i+1, self.n):
                self.fruits[i][j], self.fruits[j][i] = self.fruits[j][i], self.fruits[i][j]
        self.mem = {(self.n-1, self.n-1): 0}
        rst += self.helper(0, self.n-1)
        return rst",1460877113
Dipanshu Pandey,callmepandey,57,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int i = 0;i<s.size();++i) {
            char current = s[i];
            long long forward = 0;
            while(current != t[i]) {
                
                forward += 1ll * nextCost[current - 'a'];
                
                if(current == 'z') current = 'a';
                else current++;
            }
            current = s[i];
            long long backward = 0;
            while(current != t[i]) {
                backward += 1ll * previousCost[current - 'a'];
                if(current == 'a') current = 'z';
                else current--;
            }
            ans += min(forward , backward);
        }
        return ans;
    }
};",1460805413
Dipanshu Pandey,callmepandey,57,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool win = false;
        int current = 10;
        while(n && current <= n) {
            n -= current;
            current--;
            win ^= 1;
        }
        return win;
    }
};",1460796270
Dipanshu Pandey,callmepandey,57,3647,cpp,"template <typename T>
class SegmentTree {
private:
    int n;                      // Size of the input array
    vector<T> arr;              // Input array
    vector<T> tree;             // Segment Tree
    vector<T> lazy;             // Lazy array for postponed updates
    function<T(T, T)> combine;  // Combine function for the segment tree (min)

    // Build the segment tree
    void buildTree(int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }

        int mid = (start + end) / 2;
        buildTree(2 * node, start, mid);
        buildTree(2 * node + 1, mid + 1, end);

        tree[node] = combine(tree[2 * node], tree[2 * node + 1]);
    }

    // Propagate lazy updates to children
    void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node]; // Apply lazy value to the current node

            if (start != end) { // Not a leaf node
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }

            lazy[node] = 0; // Clear lazy value for the current node
        }
    }

    // Update range [l, r] by adding `val` with lazy propagation
    void updateRange(int node, int start, int end, int l, int r, T val) {
        propagate(node, start, end); // Ensure any pending updates are applied

        if (start > end || start > r || end < l) {
            return; // No overlap
        }

        if (start >= l && end <= r) { // Complete overlap
            lazy[node] += val;
            propagate(node, start, end);
            return;
        }

        // Partial overlap
        int mid = (start + end) / 2;
        updateRange(2 * node, start, mid, l, r, val);
        updateRange(2 * node + 1, mid + 1, end, l, r, val);

        tree[node] = combine(tree[2 * node], tree[2 * node + 1]);
    }

    // Query the range [l, r] for the minimum value
    T queryRange(int node, int start, int end, int l, int r) {
        propagate(node, start, end); // Ensure any pending updates are applied

        if (start > end || start > r || end < l) {
            return numeric_limits<T>::max(); // No overlap
        }

        if (start >= l && end <= r) { // Complete overlap
            return tree[node];
        }

        // Partial overlap
        int mid = (start + end) / 2;
        T leftResult = queryRange(2 * node, start, mid, l, r);
        T rightResult = queryRange(2 * node + 1, mid + 1, end, l, r);

        return combine(leftResult, rightResult);
    }

public:
    // Constructor
    SegmentTree(const vector<T>& input, const function<T(T, T)>& combineFunc)
        : combine(combineFunc) {
        n = input.size();
        arr = input;
        tree.resize(4 * n, numeric_limits<T>::max());
        lazy.resize(4 * n, 0);
        buildTree(1, 0, n - 1);
    }

    // Update range [l, r] with value 'val'
    void update(int l, int r, T val) {
        updateRange(1, 0, n - 1, l, r, val);
    }

    // Query range [l, r] for the minimum value
    T query(int l, int r) {
        return queryRange(1, 0, n - 1, l, r);
    }
};

// Usage:
// auto combine = [](int a, int b) { return min(a, b); };
// SegmentTree<int> segmentTree(arr, combine);


class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        
        int n = nums.size();
        vector <int> prefix(n + 1 , 0);
        unordered_map < int , vector <int> > end;
        vector <int> arr(n , 0);
        for(auto &a : queries) {
            
            prefix[a[0]]++;
            prefix[a[1] + 1]--;
            
            end[a[1]].push_back(a[0]);
        }
        
        

        for(int i = 0;i<n;++i) {
            if(i)
                prefix[i] += prefix[i - 1];
            if(prefix[i] < nums[i]) return -1;
            arr[i] = prefix[i] - nums[i];
            
        }
        
        auto combine = [](int a, int b) { return min(a , b); };
        SegmentTree<int> segmentTree(arr, combine);
        
        int ans = 0;
        for(int i = 0;i<n;++i) {
            for(int j : end[i]) {
                int x = segmentTree.query(j , i);
                
                if(x > 0) {
                    ++ans;
                    segmentTree.update(j , i , -1);
                }
            }
        }
        
        return ans;
        
    }
};",1460844671
Dipanshu Pandey,callmepandey,57,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        for(int i = 0;i<n;++i) {
            ans += fruits[i][i];
        }
        vector < vector <int> > dp(n , vector <int> (n , -1));
        int zero = 0, mx = -1e6;
        function < int(int,int) > forDown = [&](int i,int j) -> int{
            
            if(i < 0 or i >= n) return mx;
            if(j < 0 or j >= n) return mx;
            if(i == n - 1 && j == n - 1) return zero;
            if(j == n - 1) return mx;
            if(i == j) return mx;
            int &ans = dp[i][j];
            if(ans != -1) return ans;
            ans = fruits[i][j];
            int xans = max({forDown(i - 1 , j + 1) , forDown(i , j + 1) , forDown(i + 1 , j + 1)});
            ans += xans;
            return ans;
        };
        int ans1 = forDown(n - 1 , 0);
        dp = vector < vector <int> >(n , vector <int> (n , -1));
        function < int(int,int) > forUp = [&](int i,int j) -> int{
            if(i < 0 or i >= n) return mx;
            if(j < 0 or j >= n) return mx;
            if(i == n - 1 && j == n - 1) return zero;
            if(i == n - 1) return mx;
            if(i == j) return mx;
            int &ans = dp[i][j];
            if(ans != -1) return ans;
            ans = fruits[i][j];
            int xans = max({forUp(i + 1 , j - 1) , forUp(i + 1 , j) , forUp(i + 1 , j + 1)});
            ans += xans;
            return ans;
        };
        int ans2 = forUp(0 , n - 1);
        cout << ans1 << ' ' << ans2 << endl;
        return ans + ans1 + ans2;       
    }
};",1460871348
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {

        long long cost = 0;

        for (int i = 0; i < (int) s.size(); i++) {
            long long up = 0;
            {
                int c = s[i] - 'a';
                int goal = t[i] - 'a';
                while (c != goal) {
                    up += nextCost[c];
                    c = (c + 1) % 26;
                }
            }
             long long down = 0;
            {
                int c = s[i] - 'a';
                int goal = t[i] - 'a';
                while (c != goal) {
                    down += previousCost[c];
                    c = (c - 1 + 26) % 26;
                }
            }
            cost += min(up, down);
        }

        return cost;
        
    }
};",1460811196
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        int remove = 10;
        int turn = 0;
        while (true) {
            if (n - remove < 0) {
                return turn;
            }
            n -= remove;
            turn ^= 1;
            --remove;
        }
        
        
    }
};",1460804626
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int best_way = 0;

        multiset<int> can_pick;

        map<int, vector<int> > start;
        map<int, int > remove;
        
        for (auto& arr : queries) {
            int l = arr[0];
            int r = arr[1];
          //  --l; --r;
            start[l].emplace_back(r);
        }
        int active = 0;
        for (int i = 0; i < (int) nums.size(); i++) {

            for (auto& R : start[i]) can_pick.insert(R);
            while (!can_pick.empty() && *can_pick.begin() < i) can_pick.erase(can_pick.begin());
            active -= remove[i];

            if (active < nums[i]) {
                int add = nums[i] - active;
                if (can_pick.size() < add) return -1;
                while (add--) {
                    ++active;
                    ++best_way;
                    auto it = --can_pick.end();
                    remove[*it + 1]++;
                    can_pick.erase(it);
                }
            }
            
        }

        
        
        return (int) queries.size() - best_way;
    }
};",1460832557
Haunted_Cpp,Xx_DarDoAzuL_xX,59,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res = 0;
        const int n = (int) fruits.size();
        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector< pair<int, int> > dir;
        vector< vector<int> > dp;

        const int INF = 1e9;
        int f = -1;
        auto calc = [&](auto&& self, int sr, int sc) {
            
            if (f == 0) {
                if (sr <= sc) return 0;
            } else {
                if (sr >= sc) return 0;
            }
            //cout << sr << ' ' << sc << '\n';
            int& res = dp[sr][sc];
            if (~res) return res;
            res = -INF;
            for (auto& [dr, dc] : dir) {
                int nr = sr + dr;
                int nc = sc + dc;
                if (nr < 0 || nr >= n) continue;
                if (nc < 0 || nc >= n) continue;
                res = max(res, self(self, nr, nc));
            }
            res += fruits[sr][sc];
            return res;
        };
        
        auto solve = [&](int sr, int sc) {
            dp = vector< vector<int> > (n, vector<int>(n, -1));
            return calc(calc, sr, sc);
        };
        dir.clear(); dir = { {-1, +1}, {+0 , +1}, {+1 , +1}};
        f = 0;
        int mx1 = solve(n - 1, 0);
        
       // cout << ""GOT IT: "" << mx1 << '\n';
        dir.clear(); dir = { {+1, -1}, {+1 , +0}, {+1 , +1}};
        f = 1;
        int mx2 = solve(0, n - 1);
     //   cout << mx2 << '\n';
        
        res += mx1;
        res += mx2;
        return res;
    }
};",1460865116
tomarin,tomarint,60,3591,rust,"impl Solution {
    pub fn shift_distance(s: String, t: String, next_cost: Vec<i32>, previous_cost: Vec<i32>) -> i64 {
        let s = s.as_bytes();
        let t = t.as_bytes();
        let n = s.len();
        let mut ans = 0;
        let next_cost = next_cost.iter().map(|&x| x as i64).collect::<Vec<i64>>();
        let previous_cost = previous_cost.iter().map(|&x| x as i64).collect::<Vec<i64>>();
        for i in 0..n {
            let mut cur = s[i];
            let mut ans1 = 0;
            while cur != t[i] {
                ans1 += next_cost[(cur - b'a') as usize];
                cur = if cur == b'z' { b'a' } else { cur + 1 };
            }
            let mut ans2 = 0;
            let mut cur = s[i];
            while cur != t[i] {
                ans2 += previous_cost[(cur - b'a') as usize];
                cur = if cur == b'a' { b'z' } else { cur - 1 };
            }
            ans += ans1.min(ans2);
        }
        ans
    }
}",1460821771
tomarin,tomarint,60,3625,rust,"impl Solution {
    pub fn can_alice_win(n: i32) -> bool {
        let mut n = n;
        let mut alice = true;
        for i in 0..10 {
            let take = 10 - i;
            if n >= take {
                n -= take;
                alice = !alice;
                continue;
            }
            break;
        }
        !alice
    }
}",1460800632
tomarin,tomarint,60,3647,rust,"#[derive(Clone)]
struct FenwickTree {
    n: usize,
    data: Vec<i64>,
}
impl FenwickTree {
    fn new(n: usize) -> FenwickTree {
        FenwickTree {
            n: n,
            data: vec![0; n + 1],
        }
    }
    // --- sum ---
    fn add(&mut self, i: usize, x: i64) {
        let mut i = i + 1;
        while i <= self.n {
            self.data[i] += x;
            i += i & i.wrapping_neg();
        }
    }
    fn sum(&self, i: usize) -> i64 {
        let mut i = i + 1;
        let mut s = 0;
        while i > 0 {
            s += self.data[i];
            i -= i & i.wrapping_neg();
        }
        s
    }
}

impl Solution {
    pub fn max_removal(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {
        let n = nums.len();
        let mut ft = FenwickTree::new(n+2);
        let mut queries = queries
            .iter()
            .map(|v| (v[0] as usize, v[1] as i64))
            .collect::<Vec<_>>();
        queries.sort();
        let mut qi = 0;
        let mut que = std::collections::BinaryHeap::new();
        let mut ans = 0;
        for i in 0..n {
            while qi < queries.len() && queries[qi].0 == i {
                que.push(queries[qi].1);
                qi += 1;
            }
            let mut val = nums[i] as i64;
            if val <= ft.sum(i) {
                continue;
            }
            while val > ft.sum(i) {
                if let Some(x) = que.pop() {
                    ft.add(i, 1);
                    ft.add(x as usize + 1, -1);
                    ans += 1;
                } else {
                    return -1;
                }
            }
        }
        queries.len() as i32 - ans
    }
}",1460853746
tomarin,tomarint,60,3648,rust,"impl Solution {
    pub fn max_collected_fruits(fruits: Vec<Vec<i32>>) -> i32 {
        // 
        let n = fruits.len();
        let fruits = fruits.into_iter().map(|v| v.into_iter().map(|v| v as i64).collect::<Vec<_>>()).collect::<Vec<_>>();
        let mut dp = vec![vec![i64::MIN; n]; n];
        dp[0][n-1] = fruits[0][n-1];
        for h in 1..n-1 {
            for w in 0..n {
                let mut max = i64::MIN;
                for i in -1..=1 {
                    let nw = w as i32 + i;
                    if nw < 0 || nw >= n as i32 { continue; }
                    max = max.max(dp[h-1][nw as usize]);
                }
                if max == i64::MIN { continue; }
                dp[h][w] = max + fruits[h][w];
            }
        }
        let ans1 = dp[n-2][n-1];
        let mut ans = ans1;

        // 
        let mut dp = vec![vec![i64::MIN; n]; n];
        dp[n-1][0] = fruits[n-1][0];
        for w in 1..n-1 {
            for h in 0..n {
                let mut max = i64::MIN;
                for i in -1..=1 {
                    let nh = h as i32 + i;
                    if nh < 0 || nh >= n as i32 { continue; }
                    max = max.max(dp[nh as usize][w-1]);
                }
                if max == i64::MIN { continue; }
                dp[h][w] = max + fruits[h][w];
            }
        }
        let ans2 = dp[n-1][n-2];
        let mut ans = ans1 + ans2;
        for i in 0..n {
            ans += fruits[i][i];
        }
        ans as i32
    }
}",1460871745
Jb1u4WvKYq,Jb1u4WvKYq,62,3591,cpp,"typedef long long ll;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        ll num = s.size(), ans=0;
        vector<ll> pren(27),prep(27);
        for(int i=1;i<=26;i++){
            pren[i] = n[i-1]+pren[i-1];
            prep[i] = p[i-1]+prep[i-1];
        }
        for(int i=0;i<num;i++){
            int a =s[i]-'a',b = t[i]-'a';
            ll temp=LLONG_MAX;
            if(a==b) continue;
            if(a<b){
                temp = min(temp,pren[b]-pren[a]);
                temp = min(temp,prep[26]-(prep[b+1]-prep[a+1]));
            }
            else{
                temp = min(temp,prep[a+1]-prep[b+1]);
                temp = min(temp,pren[26]-(pren[a]-pren[b]));
            }
            ans +=temp;
        }
        return ans;
    }
};",1460817703
Jb1u4WvKYq,Jb1u4WvKYq,62,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        return help(n,10);
    }
    bool help(int n,int take){
        if(n<take) return false;
        return !help(n-take,take-1);
    }
};",1460797277
Jb1u4WvKYq,Jb1u4WvKYq,62,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(),ans=0,cur=0,id=0,m =queries.size();
        vector<int> end(n+1);
        priority_queue<int> q;
        sort(queries.begin(),queries.end());
        for(int i=0;i<n;i++){
            cur-=end[i];
            while(id<queries.size()&&queries[id][0]==i){
                q.push(queries[id][1]);
                id++;
            }
            if(nums[i]<=cur) continue;
            else{
                int req = nums[i]-cur;
                while(req){
                    if(q.empty())return -1;
                    int temp = q.top();
                    q.pop();
                    if(temp<i){
                        continue;
                    }
                    req--;
                    end[temp+1]++;
                    ans++;
                    cur++;
                }
            }
        }
        return m-ans;
    }
};",1460850900
Jb1u4WvKYq,Jb1u4WvKYq,62,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ans=0,n = f.size();
        for(int i=0;i<n;i++){
            ans+=f[i][i];
            f[i][i]=0;
        }
        vector<vector<int>> dp(n,vector<int>(n,-1)),dp1(n,vector<int>(n,-1));
        dp[n-1][n-1] = f[n-1][n-1];
        for(int i=n-2;i>=0;i--){
            for(int j=0;j<n;j++){
                int temp=-1;
                if(j+1<n&&dp[i+1][j+1]!=-1) temp = max(temp,dp[i+1][j+1]);
                if(j<n&&dp[i+1][j]!=-1) temp = max(temp,dp[i+1][j]);
                if(j-1>=0&&dp[i+1][j-1]!=-1) temp = max(temp,dp[i+1][j-1]);
                if(temp==-1) dp[i][j]=-1;
                else dp[i][j] =temp+f[i][j];
            }
        }
        dp1[n-1][n-1] = f[n-1][n-1];
        for(int j=n-2;j>=0;j--){
            for(int i=0;i<n;i++){
                int temp=-1;
                if(i+1<n&&dp1[i+1][j+1]!=-1) temp = max(temp,dp1[i+1][j+1]);
                if(i<n&&dp1[i][j+1]!=-1) temp = max(temp,dp1[i][j+1]);
                if(i-1>=0&&dp1[i-1][j+1]!=-1) temp = max(temp,dp1[i-1][j+1]);
                if(temp==-1) dp1[i][j]=-1;
                else dp1[i][j] =temp+f[i][j];
            }
        }
        return dp1[n-1][0]+dp[0][n-1]+ans;
    }
};",1460872254
congthanh2000,congthanh2000,63,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;
            long long w1 = 0, w2 = 0;
            int c1 = s[i] - 'a';
            while (c1 != t[i] - 'a') {
                w1 += nextCost[c1];
                c1 = (c1 + 1) % 26;
            }
            int c2 = s[i] - 'a';
            while (c2 != t[i] - 'a') {
                w2 += previousCost[c2];
                c2 = (c2 + 25) % 26;
            }
            ans += min(w1, w2);
        }
        return ans;
    }
};",1460808152
congthanh2000,congthanh2000,63,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int d = 0, p = 10;
        while (n >= p) {
            n -= p;
            p--;
            d ^= 1;
        }
        return d;
    }
};",1460803183
congthanh2000,congthanh2000,63,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> add(n);
        for (int i = 0; i < queries.size(); i++) {
            int L = queries[i][0], R = queries[i][1], value = 1;
            add[L].push_back(R);
        }
        multiset<int> setR;
        int need = 0;
        vector<int> prefix_sum(n + 1, 0);
        for (int i = 0; i < n; i++) {
            if (i) prefix_sum[i] += prefix_sum[i - 1];
            for (int R : add[i]) {
                setR.insert(R);
            }
            while (setR.size() && *setR.begin() < i) {
                need++;
                setR.erase(setR.begin());
            }
            while (nums[i] > prefix_sum[i] && setR.size()) {
                auto it = setR.end(); it--;
                int R = *it;
                prefix_sum[i]++;
                prefix_sum[R + 1]--;
                setR.erase(it);
            }
            if (nums[i] > prefix_sum[i]) {
                return -1;
            }
        }
        return need + setR.size();
    }
};",1460848922
congthanh2000,congthanh2000,63,3648,cpp,"const int lim = 1e9;
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i = 0; i < n; i++) ans += fruits[i][i];
        fruits[n - 1][n - 1] = 0;
        vector<vector<int>> dp(n, vector<int>(n, -lim));
        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 0; j < n; j++) {
            for (int i = n - 1; i >= 0; i--) {
                if (dp[i][j] >= 0) {
                    for (int dx = -1; dx <= 1; dx++) {
                        int ni = i + dx;
                        int nj = j + 1;
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n && (nj < ni || (nj == n - 1 && ni == n - 1))) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + fruits[ni][nj]);
                        }
                    }
                }
            }
        }
        ans += dp[n - 1][n - 1];
        dp = vector<vector<int>>(n, vector<int>(n, -lim));
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 0; i < n; i++) {
            for (int j = n - 1; j >= 0; j--) {
                if (dp[i][j] >= 0) { 
                    for (int dy = -1; dy <= 1; dy++) {
                        int ni = i + 1;
                        int nj = j + dy;
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n && (nj > ni || (nj == n - 1 && ni == n - 1))) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + fruits[ni][nj]);
                        }
                    }
                }
            }
        }
        return ans + dp[n - 1][n - 1];
    }
};",1460865946
Kiril Minkov,xmentex,64,3591,golang,"func shiftDistance(s string, t string, nextCost []int, prevCost []int) int64 {
    res := int64(0)
    
    for i := 0; i < len(s); i++ {
        v := int(s[i] - 'a')
        u := int(t[i] - 'a')
        
        if u == v {
            continue
        }
        x := int64(0)
        for i := 0; i <= 26; i++ {
            x += int64(nextCost[ (v + i) % 26 ])
            if (v + i + 1) % 26 == u {
                break
            }
        }
        y := int64(0)
        for i := 0; i <= 26; i++ {
            y += int64(prevCost[ v ])
            v--
            if v < 0 {
                v = 25
            }
            if v == u {
                break
            }
        }
        
        res += min(x, y)        
    }
    
    return res
}",1460850289
Kiril Minkov,xmentex,64,3625,golang,"func canAliceWin(n int) bool {
    for i := 10; i >= 1; i-- {
        if n < i {
            return i % 2 == 1
        }
        n -= i
    }   
    return false
}",1460850464
Kiril Minkov,xmentex,64,3647,golang,"
import (
	""container/heap""
)

type item struct {
	item  Item
	index int
}

type heapImpl struct {
	p               *pq
	items           map[interface{}]*item
	key             func(Item) interface{}
	DisableIndexing bool
}

func (h *heapImpl) Push(i Item) {
	it := &item{i, 0}
	h.addItem(it)
	heap.Push(h.p, it)
}

func (h *heapImpl) Pop() Item {
	res := heap.Pop(h.p).(*item)
	h.removeItem(res.item)
	return res.item
}

func (h *heapImpl) Top() Item {
	if len(h.p.items) > 0 {
		return h.p.items[0].item
	}
	return nil
}

func (h *heapImpl) Len() int {
	return len(h.p.items)
}

func (h *heapImpl) Update(o Item, n Item) {
	old := h.items[h.key(o)]
	new := &item{n, old.index}
	h.removeItem(old.item)
	h.p.items[old.index] = new
	heap.Fix(h.p, old.index)
	h.addItem(new)
}

func (h *heapImpl) Remove(i Item) {
	index := h.items[h.key(i)].index
	h.removeItem(i)
	heap.Remove(h.p, index)
}

func (h *heapImpl) Get(key interface{}) Item {
	return h.items[key].item
}

func (h *heapImpl) removeItem(item Item) {
	if !h.DisableIndexing {
		delete(h.items, h.key(item))
	}
}

func (h *heapImpl) addItem(item *item) {
	if !h.DisableIndexing {
		h.items[h.key(item.item)] = item
	}
}

// A PriorityQueue implements heap.Interface and holds Items.
type pq struct {
	items []*item
}

func (pq pq) Len() int { return len(pq.items) }

func (pq pq) Less(i, j int) bool {
	// We want Pop to give us the highest, not lowest, priority so we use greater than here.
	return pq.items[i].item.Compare(pq.items[j].item)
}

func (pq pq) Swap(i, j int) {
	pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
	pq.items[i].index = i
	pq.items[j].index = j
}

func (pq *pq) Push(x interface{}) {
	n := len(pq.items)
	item := x.(*item)
	item.index = n
	pq.items = append(pq.items, item)
}

func (pq *pq) Pop() interface{} {
	old := pq.items
	n := len(old)
	item := old[n-1]
	old[n-1] = nil  // avoid memory leak
	item.index = -1 // for safety
	pq.items = old[0 : n-1]
	return item
}

func NewHeapWithKey(getKey func(Item) interface{}) Heap {
	return &heapImpl{
		&pq{
			[]*item{},
		},
		make(map[interface{}]*item),
		getKey,
		false,
	}
}

func NewHeap() Heap {
	return NewHeapWithKey(func(i Item) interface{} { return i })
}

type Item interface {
	Compare(left Item) bool
}

type Heap interface {
	Push(i Item)
	Pop() Item
	Top() Item
	Len() int
	Update(old Item, new Item)
	Remove(item Item)
	Get(key interface{}) Item
}

type MinInt int

func (i MinInt) Compare(j Item) bool {
	return i < j.(MinInt)
}

type MaxInt int

func (i MaxInt) Compare(j Item) bool {
	return i > j.(MaxInt)
}

func maxRemoval(nums []int, queries [][]int) int {
    n := len(nums)
    q := make([][]int, n)  
    e := make([]int, n)
    for _, v := range queries {
        q[v[0]] = append(q[v[0]], v[1])     
    }
    
    h := NewHeap()
    
    res := 0
    
    cur := 0
    for i := 0; i < n; i++ {
        for _, v := range q[i] {
            h.Push(MaxInt(v))
        }
        
        for cur < nums[i] {
            if h.Len() == 0 {
                return -1
            }
            v := int(h.Pop().(MaxInt))
            if v < i {
                continue
            } 
            res++
            e[v]++
            cur++
        }
        
        cur -= e[i]
    }
    
    return len(queries) - res
}",1460850079
Kiril Minkov,xmentex,64,3648,golang,"func maxCollectedFruits(arr [][]int) int {
    res := 0
    n := len(arr)
    for i := 0; i < n; i++ {
        res += arr[i][i]
    }
    
    f := make([][]int, n)
    for i := 0; i < n; i++ {
        f[i] = make([]int, n)
        for j := 0; j < n; j++ {
            f[i][j] = -1
        }
    }
    
    f[0][n-1] = arr[0][n-1]
    for i := 1; i < n; i++ {
        for j := i + 1; j < n; j++ {
            if f[i-1][j] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j] + arr[i][j]) 
            }
            if j - 1 >= 0 && f[i-1][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j-1] + arr[i][j])
            }
            if j + 1 < n && f[i-1][j+1] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j+1] + arr[i][j])   
            }
        }
    }
    res += f[n-2][n-1]
    
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            f[i][j] = -1
        }
    }
    
    f[n-1][0] = arr[n-1][0]
    
    for j := 1; j < n ; j++ {
        for i := j; i < n; i++ {
            if f[i][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i][j-1] + arr[i][j])
            } 
            if i - 1 >= 0 && f[i-1][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i-1][j-1] + arr[i][j])
            }
            if i + 1 < n && f[i+1][j-1] != -1 {
                f[i][j] = max(f[i][j], f[i+1][j-1] + arr[i][j])
            }
        } 
    }
    
    res += f[n-1][n-2]
    
    return res
}",1460878838
kasi nathan,kasinathansj,65,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        for(int i = 0 ; i < s.length() ; i++){
            int c1 = s.charAt(i)-'a';
            int c2 = t.charAt(i)-'a';
            int p1 = c1;
            long ans1 = 0;
            while(p1!=c2){
                ans1 += nextCost[p1];
                p1 = (p1+1)%26;
            }
            int p2 = c1;
            long ans2 = 0;
            while(p2!=c2){
                ans2 += previousCost[p2];
                p2 = (p2-1+26)%26;
            }
            // System.out.println(ans1+"" ""+ans2);
            ans += Math.min(ans1 , ans2);
        }
        return ans;
    }
}",1460810863
kasi nathan,kasinathansj,65,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int a = 1;
        int can = 10;
        while(n-can>=0&&can>0){
            n-=can;
            a++;
            can--;
        }
        if(a%2==0)return true;
        return false;
    }
}",1460797014
kasi nathan,kasinathansj,65,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries,(a,b)->{
            return a[0]-b[0];
        });
        int ans = 0;
        PriorityQueue<int[]> pq1 = new PriorityQueue<>((a,b)->b[1]-a[1]);
        PriorityQueue<int[]> pq2 = new PriorityQueue<>((a,b)->a[1]-b[1]);
        int p = 0;
        int ap = 0;
        // for(int a[] : queries){
        //     System.out.println(Arrays.toString(a));
        // }
        for(int i : nums){
            while(ap<queries.length&&queries[ap][0]<=p&&queries[ap][1]>=p){
                pq1.add(queries[ap++]);
            }
            while(pq2.size()!=0&&pq2.peek()[1] < p){
                pq2.remove();
            }
            i -= pq2.size();
            while(pq1.size()!=0&&i>0){
                if(pq1.peek()[1]>=p){
                    pq2.add(pq1.poll());
                    ans++;
                    i--;
                }else{
                    return -1;
                }
            }
            // System.out.println(pq1.size()+"" ""+pq2.size()+"" ""+i);
            if(i>0)return -1;
            p++;
        }
        return queries.length-ans;
    }
}",1460851010
kasi nathan,kasinathansj,65,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int ans = 0;
        for(int i = 0 ; i < fruits.length ; i++){
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        int dp1[] = new int[fruits.length];
        int dp2[] = new int[fruits.length];
        int n = fruits.length;
        dp1[fruits.length-1] = fruits[0][fruits.length-1];
        for(int i = 1 ; i < fruits.length ; i++){
            int d1 = Math.min(i,n-i);
            for(int j = 0 ; j <= d1 ; j++){
                int sum1 = 0;
                int sum2 = 0;
                int sum3 = 0;
                int ind = n-1-j;
                if(ind-1>=0)sum1 = dp1[ind-1];
                if(ind+1<n)sum2 = dp1[ind+1];
                sum3 = dp1[ind];
                dp2[ind] = Math.max(sum1 , Math.max(sum2,sum3));
                dp2[ind] += fruits[i][ind];
            }
            int pre[] = dp1;
            dp1 = dp2;
            dp2 = pre;
            Arrays.fill(dp2,0);
        }
        ans += dp1[n-1];
        Arrays.fill(dp1,0);
        dp1[n-1] = fruits[n-1][0];
        for(int i = 1 ; i < fruits.length ; i++){
            int d1 = Math.min(i,n-i);
            for(int j = 0 ; j <= d1 ; j++){
                int sum1 = 0;
                int sum2 = 0;
                int sum3 = 0;
                int ind = n-1-j;
                if(ind-1>=0)sum1 = dp1[ind-1];
                if(ind+1<n)sum2 = dp1[ind+1];
                sum3 = dp1[ind];
                dp2[ind] = Math.max(sum1 , Math.max(sum2,sum3));
                dp2[ind] += fruits[ind][i];
            }
            int pre[] = dp1;
            dp1 = dp2;
            dp2 = pre;
            Arrays.fill(dp2,0);
            // System.out.println(Arrays.toString(dp1));
        }
        ans += dp1[n-1];
        return ans;
    }
}",1460878854
Mac,cowmane,67,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = (int)s.size();
        long long ans = 0;
        for (int i=0; i<n; i++) {
            long long up_cost = 0;
            for (int j=s[i]-'a'; j!=t[i]-'a'; j = (j+1)%26) {
                up_cost += nextCost[j];
            }
            long long down_cost = 0;
            for (int j=s[i]-'a'; j!=t[i]-'a'; j = (j-1+26)%26) {
                down_cost += previousCost[j];
            }
            ans += min(up_cost, down_cost);
        }
        return ans;
    }
};",1460811885
Mac,cowmane,67,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i=10; i>=1; i--) {
            if (n<i) {
                return i%2==1;
            }
            n -= i;
        }
        return false;
    }
};",1460804734
Mac,cowmane,67,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> query_ends(n);
        for (auto query : queries) {
            query_ends[query[0]].push_back(query[1]);
        }
        vector<int> diff(n+1);
        int cur_diff = 0;
        
        
        multiset<int> ms;
        int used = 0;
        for (int i=0; i<n; i++) {
            cur_diff += diff[i]; // update difference array
            nums[i] += cur_diff; // use active queries
            for (int e : query_ends[i]) {
                ms.insert(e);
            }
            while (nums[i]>0) {
                while (!ms.empty() && *ms.begin() < i) {
                    ms.erase(ms.begin());
                }
                if (ms.empty()) {
                    return -1; // cant use anything
                }
                int mx = *ms.rbegin();
                cur_diff--;
                nums[i]--;
                diff[mx+1]++;
                ms.erase(ms.find(mx));
                used++;
            }
        }
        return queries.size() - used;
    }
};",1460826361
Mac,cowmane,67,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int score = 0; // forced moves diagonal
        for (int i=0; i<n; i++) {
            score += fruits[i][i];
            fruits[i][i] = 0;
        }
        // Solve horizontal guy
        vector<int> dp(n,-1e9);
        dp[n-1] = fruits[n-1][0];
        for (int c=1; c<n; c++) {
            vector<int> ndp(n,-1e9);
            for (int r=0; r<n; r++) {
                ndp[r] = dp[r]+fruits[r][c];
                if (r>0) {
                    ndp[r] = max(ndp[r], dp[r-1]+fruits[r][c]);
                }
                if (r<n-1) {
                    ndp[r] = max(ndp[r], dp[r+1]+fruits[r][c]);
                }
            }
            swap(dp,ndp);
        }
        score += dp[n-1];
        
        // Solve vertical guy
        dp = vector<int>(n,-1e9);
        dp[n-1] = fruits[0][n-1];
        for (int r=1; r<n; r++) {
            vector<int> ndp(n,-1e9);
            for (int c=0; c<n; c++) {
                ndp[c] = dp[c]+fruits[r][c];
                if (c>0) {
                    ndp[c] = max(ndp[c], dp[c-1]+fruits[r][c]);
                }
                if (c<n-1) {
                    ndp[c] = max(ndp[c], dp[c+1]+fruits[r][c]);
                }
            }
            swap(dp,ndp);
        }
        score += dp[n-1];
        
        return score;
    }
};",1460860390
Xiaomeng Yang,yangxm,69,3591,cpp,"using i64 = long long;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
      int n = s.length();
      i64 ret = 0;
      for (int i = 0; i < n; ++i) {
        int u = s[i] - 'a', v = t[i] - 'a';
        i64 x = 0, y = 0;
        for (int j = u; j != v; j = (j + 1) % 26) {
          x += (i64)nextCost[j];
        }
        for (int j = u; j != v; j = (j + 25) % 26) {
          y += (i64)previousCost[j];
        }
        ret += min(x, y);
      }
      return ret;
    }
};",1460805505
Xiaomeng Yang,yangxm,69,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
      int ret = 0, cur = 10;
      while (n >= cur) {
        n -= cur;
        ret ^= 1;
        --cur;
      }
      return ret;
    }
};",1460797491
Xiaomeng Yang,yangxm,69,3647,cpp,"#define X first
#define Y second

using Pii = pair<int, int>;

constexpr int MAX = 200010;

struct SegmentTree {
  int c[MAX << 1], cap;

  void Reset(int n) {
    for (cap = 1; cap < n; cap <<= 1);
    fill(c, c + cap * 2, 0);
  }

  void Update(int k, int v) {
    k += cap;
    for (c[k] += v; k > 1; k >>= 1) {
      c[k >> 1] = c[k] + c[k ^ 1];
    }
  }

  int Query(int l, int r) const {
    int ret = 0;
    l += cap;
    r += cap;
    while (l < r) {
      if (l & 1) {
        ret += c[l++];
      }
      if (r & 1) {
        ret += c[--r];
      }
      l >>= 1;
      r >>= 1;
    }
    return ret;
  }
} st;

int a[MAX];
Pii q[MAX];
map<Pii, int> mp;

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
      int n = nums.size(), m = 0, k = queries.size(), ret = 0;
      for (int i = 0; i < n; ++i) {
        a[i] = nums[i];
        m = max(m, a[i]);
      }
      for (int i = 0; i < k; ++i) {
        q[i] = make_pair(queries[i][0], queries[i][1] + 1);
      }
      sort(q, q + k);
      st.Reset(n + 1);
      mp.clear();
      int p = 0;
      for (int i = 0; i < n; ++i) {
        int cur = st.Query(0, i + 1);
        for (; p < k && q[p].X <= i; ++p) {
          ++mp[make_pair(q[p].Y, q[p].X)];
        }
        int d = max(a[i] - cur, 0);
        for (int j = 0; j < d; ++j) {
          auto it = mp.end();
          if (it == mp.begin()) {
            return -1;
          }
          --it;
          auto [rr, ll] = it->X;
          if (rr <= i) {
            return -1;
          }
          st.Update(ll, 1);
          st.Update(rr, -1);
          if (!(--it->Y)) {
            mp.erase(it);
          }
        }
        ret += d;
      }
      return k - ret;
    }
};",1460848501
Xiaomeng Yang,yangxm,69,3648,cpp,"constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;

int mat[MAX][MAX], dp[2][MAX];

int Calc1(int n) {
  int x = 0;
  fill(dp[0], dp[0] + n, -INF);
  dp[0][n - 1] = mat[0][n - 1];
  for (int i = 1; i < n; ++i) {
    x ^= 1;
    fill(dp[x], dp[x] + n, -INF);
    for (int j = i; j < n; ++j) {
      int cur = max(dp[x ^ 1][j - 1], dp[x ^ 1][j]);
      if (j < n - 1) {
        cur = max(cur, dp[x ^ 1][j + 1]);
      }
      dp[x][j] = cur + mat[i][j];
    }
  }
  return dp[x][n - 1];
}

int Calc2(int n) {
  int x = 0;
  fill(dp[0], dp[0] + n, -INF);
  dp[0][n - 1] = mat[n - 1][0];
  for (int i = 1; i < n; ++i) {
    x ^= 1;
    fill(dp[x], dp[x] + n, -INF);
    for (int j = i; j < n; ++j) {
      int cur = max(dp[x ^ 1][j - 1], dp[x ^ 1][j]);
      if (j < n - 1) {
        cur = max(cur, dp[x ^ 1][j + 1]);
      }
      dp[x][j] = cur + mat[j][i];
    }
  }
  return dp[x][n - 1];
}

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
      int n = fruits.size(), ret = 0;
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
          mat[i][j] = fruits[i][j];
        }
        ret += mat[i][i];
        mat[i][i] = 0;
      }
      int x = Calc1(n);
      ret += x;
      int y = Calc2(n);
      ret += y;
      return ret;
    }
};",1460868486
Agnibha Chakraborty,zanj0,70,3591,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	lli GetNextCost(lli from, lli to, vector<int>& cost) {
		lli ret = 0;
		while (from != to) {
			ret += cost[from];
			from += 1;
			from %= (lli)cost.size();
		}
		return ret;
	}

	lli GetPrevCost(lli from, lli to, vector<int>& cost) {
		lli ret = 0;
		while (from != to) {
			ret += cost[from];
			from -= 1;
			from += (lli)cost.size();
			from %= (lli)cost.size();
		}
		return ret;
	}
	long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
		lli ret = 0;
		for (int i = 0; i < s.size(); i++) {
			lli from = s[i] - 'a';
			lli to = t[i] - 'a';
			ret += min(GetNextCost(from, to, nextCost), GetPrevCost(from, to, previousCost));
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460806012
Agnibha Chakraborty,zanj0,70,3625,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	bool canAliceWin(int n) {
		bool alice = true;
		int curr = 10;
		while (1) {
			if (curr > n) {
				return !alice;
			}
			n -= curr;
			curr--;
			alice = !alice;
		}
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460796374
Agnibha Chakraborty,zanj0,70,3647,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

class SegmentTree {
public:
	lli* tree;
	lli* lazy;
	SegmentTree(lli n) {
		tree = new lli[4 * n + 5]();
		lazy = new lli[4 * n + 5]();
        
	}
	lli left(lli x) {
		return 2 * x + 1;
	}
	lli right(lli x) {
		return 2 * x + 2;
	}
	lli operate(lli a, lli b) {
		return max(a, b);
	}
	void pull(lli node) {
		tree[node] = operate(tree[left(node)], tree[right(node)]);
	}
	void push(lli low, lli high, lli node) {
		if (lazy[node]!=0 ) {
            // cout << node << "" ->"" << lazy[node]<< endl;
			tree[node] += lazy[node];
		}
		if (low != high) {
			lazy[left(node)] += lazy[node];
			lazy[right(node)] += lazy[node];
		}
		lazy[node] = 0;
	}
	void buildTree(lli low, lli high, lli node, vector <int>& arr) {
		if (low == high) {
            // cout << low << "" "" << arr[low] << endl;
			tree[node] = arr[low];
			return;
		}
		lli mid = low + (high - low) / 2;
		buildTree(low, mid, left(node), arr);
		buildTree(mid + 1, high, right(node), arr);
		pull(node);
	}
	lli query(lli low, lli high, lli node, lli qlow, lli qhigh) {
		push(low, high, node);
		if (qlow > high || qhigh < low) return INT_MIN;
		if (qlow <= low && qhigh >= high) {
			return tree[node];
		}
		lli mid = low + (high - low) / 2;
		lli l = query(low, mid, left(node), qlow, qhigh);
		lli r = query(mid + 1, high, right(node), qlow, qhigh);
		return operate(l, r);
	}
	void update(lli low, lli high, lli node, lli ulow, lli uhigh, lli val) {
		push(low, high, node);
		if (ulow > high || uhigh < low) return;
		if (ulow <= low && uhigh >= high) {
			lazy[node] += val;
			push(low, high, node);
			return;
		}
		lli mid = low + (high - low) / 2;
		update(low, mid, left(node), ulow, uhigh, val);
		update(mid + 1, high, right(node), ulow, uhigh, val);
		pull(node);

	}

};
struct Data {
	int first_pt, second_pt, open;

};
class Solution {
public:
	int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
		int ret = 0;
		int n = nums.size();
		vector<Data> v;
		vector<vector<int>> open(n), close(n);
		for (auto& it : queries) {
			open[it[0]].pb(it[1]);
			close[it[1]].pb(it[0]);
		}
		for (int i = 0; i < n; i++)sort(close[i].begin(), close[i].end());
		SegmentTree segment_tree = SegmentTree(n);
		segment_tree.buildTree(0, n - 1, 0, nums);
        // cout << ""YES""
		for (int i = 0; i < n; i++) {
			for (auto& it : open[i]) {
                // cout <<  segment_tree.query(0, n - 1, 0, i, it) << endl;
                
				segment_tree.update(0, n - 1, 0, i, it, -1);
                // cout << ""Update: ""  << i << ""  "" << it << endl;
                // cout <<  segment_tree.query(0, n - 1, 0, i, it) << endl;
			}
			for (auto& it : close[i]) {
                lli q = segment_tree.query(0, n - 1, 0, it, i);
                // cout << it << "" "" << i << "" "" << q << endl;
				if (q < 0) {
					segment_tree.update(0, n - 1, 0, it, i, 1);
					ret++;
				}
			}
		}
		return segment_tree.query(0, n - 1, 0, 0, n - 1) > 0 ?-1:ret;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460853782
Agnibha Chakraborty,zanj0,70,3648,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e4

typedef long long int lli;

class Solution {
public:
	lli n;
	lli Dfs1(lli i, lli j, vector<vector<int>>& grid, vector<vector<lli>>& dp) {
		if (i == n - 1) {
			return j == n - 1 ? grid[i][j] : -inf;
		}
		if (i < 0 || i >= n || j < 0 || j >= n)return -inf;
		if (dp[i][j] != -1) return dp[i][j];
		lli ret = 0;
		ret = grid[i][j] + Dfs1(i + 1, j - 1, grid, dp);
		ret = max(ret, grid[i][j] + Dfs1(i + 1, j , grid, dp));
		ret = max(ret, grid[i][j] + Dfs1(i + 1, j + 1 , grid, dp));
		return dp[i][j] = ret;
	}

	lli Dfs2(lli i, lli j, vector<vector<int>>& grid, vector<vector<lli>>& dp) {
		if (j == n - 1) {
			return i == n - 1 ? grid[i][j] : -inf;
		}
		if (i < 0 || i >= n || j < 0 || j >= n)return -inf;
		if (dp[i][j] != -1) return dp[i][j];
		lli ret = 0;
		ret = grid[i][j] + Dfs2(i - 1, j + 1, grid, dp);
		ret = max(ret, grid[i][j] + Dfs2(i, j + 1 , grid, dp));
		ret = max(ret, grid[i][j] + Dfs2(i + 1, j + 1 , grid, dp));
		return dp[i][j] = ret;
	}
	int maxCollectedFruits(vector<vector<int>>& fruits) {
		lli ret = 0;
		n = fruits.size();
		for (int i = 0; i < n; i++)ret += fruits[i][i];

		vector<vector<int>> grid1 = fruits;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (j <= i) grid1[i][j] = -inf;
			}
		}
		grid1[n - 1][n - 1] = 0;

		vector<vector<int>> grid2 = fruits;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (j >= i) grid2[i][j] = -inf;
			}
		}
		grid2[n - 1][n - 1] = 0;
		vector<vector<lli>> dp1(n, vector<lli>(n, -1));
		vector<vector<lli>> dp2(n, vector<lli>(n, -1));

		lli value1 = Dfs1(0, n - 1, grid1, dp1);
		lli value2 = Dfs2(n - 1, 0, grid2, dp2);
		// cout << ret << "" "" << value1 << "" "" << value2 << endl;
		return ret + value1 + value2;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1460882775
Javier,JavOliva,71,3591,cpp,"typedef long long ll;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        ll best_cost = 0;
        for (int i = 0; i < n; i ++){
            char a1 = s[i];
            char a2 = s[i];
            ll c1 = 0, c2 = 0;
            while(a1 != t[i]){
                c1 += nextCost[a1 - 'a'];
                a1 ++;
                if (a1 == 'z' + 1)
                    a1 = 'a';
            }
            while(a2 != t[i]){
                c2 += previousCost[a2 - 'a'];
                a2 --;
                if (a2 + 1 == 'a')
                    a2 = 'z';
            }
            best_cost += min(c1, c2);
        }
        return best_cost;
    }
};",1460811061
Javier,JavOliva,71,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10;
        while(n >= remove and remove > 0){
            n -= remove;
            remove --;
        }
        return remove % 2 != 0;
    }
};",1460799708
Javier,JavOliva,71,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();
        priority_queue<int> pq;
        vector<vector<int> > weas(n + 1);
        for (int i = 0; i < q; i ++){
            int l = queries[i][0];
            int r = queries[i][1];
            weas[l].push_back(r);
        }
        vector<int> sumas(n + 1);
        int j = 0;
        int eliminados = 0;
        for (int i = 0; i < n; i ++){
            if (i > 0)
                sumas[i] += sumas[i - 1];
            for (int r : weas[i])
                pq.push(r);
            while (nums[i] - sumas[i] > 0){
                if (pq.empty()){
                    return -1;
                }
                int r = pq.top();
                pq.pop();
                if (r < i){
                    continue;
                }
                sumas[i] ++;
                sumas[r + 1] --;
            }
        }
        return pq.size();
    }
};",1460832462
Javier,JavOliva,71,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int sum = 0;
        int n = fruits.size();
        for (int i = 0; i < n; i ++){
            sum += fruits[i][i];
            fruits[i][i] = 0;
        }
        auto solve = [&](){
            vector<vector<int> > dp(n, vector<int>(n));
            vector<vector<bool> > usable(n, vector<bool>(n));
            int lim = 0;
            for (int i = n - 1; i >= 0; i --){
                for (int j = lim; j < n - lim; j ++){
                    usable[j][i] = 1;
                }
                lim ++;
            }
            // for (int i = 0; i < n; i ++){
            //     for (int j = 0; j < n; j ++){
            //         if (usable[i][j]){
            //             cout << ""1 "";
            //         }
            //         else{
            //             cout << ""0 "";
            //         }
            //     }
            //     cout << endl;
            // }
            for (int i = n - 1; i >= 0; i --){
                for (int j = 0; j < n; j ++){
                    if (usable[i][j]){
                        dp[i][j] += fruits[i][j];
                        if (i == n - 1)
                            continue;
                        for (int k = -1; k <= 1; k ++){
                            if (j + k >= 0 and j + k < n and usable[i + 1][j + k])
                                dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i + 1][j + k]);
                        }
                        
                    }
                }
            }
            // for (int i = 0; i < n; i ++){
            //     for (int j = 0; j < n; j ++){
            //         cout << dp[i][j] << "" "";
            //     }
            //     cout << endl;
            // }
            return dp[0][n - 1];
        };
        sum += solve();
        vector<vector<int> > fruits2(n, vector<int>(n));
        for (int i = 0; i < n; i ++){
            for (int j = 0; j < n; j ++){
                fruits2[i][j] = fruits[j][i];
            }
        }
        swap(fruits, fruits2);
        sum += solve();
        return sum;
    }
};",1460883016
Rejas Raj,celestialcoder,72,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> a(26, vector<long long>(26));
        for (int i = 0; i < 26; i++) {
            long long curr = 0;
            for (int j = 0; j < 26; j++) {
                int k = (i + j) % 26;
                a[i][k] = curr;
                curr += nextCost[k];
            }
            curr = 0;
            for (int j = 0; j < 26; j++) {
                int k = (i - j + 26) % 26;
                a[i][k] = min(a[i][k], curr);
                curr += previousCost[k];
            }
        }
        long long ans = 0;
        for (int i = 0; i < s.length(); i++) {
            ans += a[s[i] - 'a'][t[i] - 'a'];
        }
        return ans;
    }
};",1460812735
Rejas Raj,celestialcoder,72,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int k = 10;
        bool ans = false;
        while (n > 0) {
            if (n < k) {
                return ans;
            }
            n -= k, k--, ans = !ans;
        }
        return ans;
    }
};",1460796364
Rejas Raj,celestialcoder,72,3647,cpp,"class Solution {
public:
    void build(vector<int>& st, vector<int>& a, int ss, int se, int si) {
        if (ss > se) {
            return;
        }
        if (ss == se) {
            st[si] = a[ss];
            return;
        }
        int m = (ss + se) / 2;
        build(st, a, ss, m, si * 2 + 1), build(st, a, m + 1, se, si * 2 + 2);
        st[si] = min(st[si * 2 + 1], st[si * 2 + 2]);
    }
    int query(vector<int>& st, vector<int>& l, int ss, int se, int qs, int qe, int si) {
        if (l[si]) {
            st[si] += l[si];
            if (ss != se) {
                l[si * 2 + 1] += l[si];
                l[si * 2 + 2] += l[si];
            }
            l[si] = 0;
        }
        if (ss > se || ss > qe || qs > se) {
            return 1e9;
        }
        if (qs <= ss && se <= qe) {
            return st[si];
        }
        int m = (ss + se) / 2;
        return min(query(st, l, ss, m, qs, qe, si * 2 + 1), query(st, l, m + 1, se, qs, qe, si * 2 + 2));
    }
    void update(vector<int>& st, vector<int>& l, int ss, int se, int qs, int qe, int si, int k) {
        if (ss > se) {
            return;
        }
        if (l[si]) {
            st[si] += l[si];
            if (ss != se) {
                l[si * 2 + 1] += l[si];
                l[si * 2 + 2] += l[si];
            }
            l[si] = 0;
        }
        if (ss > se || ss > qe || qs > se) {
            return;
        }
        if (qs <= ss && se <= qe) {
            st[si] += k;
            if (ss != se) {
                l[si * 2 + 1] += k;
                l[si * 2 + 2] += k;
            }
            return;
        }
        int m = (ss + se) / 2;
        update(st, l, ss, m, qs, qe, si * 2 + 1, k), update(st, l, m + 1, se, qs, qe, si * 2 + 2, k);
        st[si] = min(st[si * 2 + 1], st[si * 2 + 2]);
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> a(n + 1);
        for (auto& query : queries) {
            a[query[0]]++, a[query[1] + 1]--;
        }
        vector<int> p(n + 1);
        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] + a[i];
        }
        for (int i = 0; i < n; i++) {
            nums[i] = p[i + 1] - nums[i];
            if (nums[i] < 0) {
                return -1;
            }
        }
        vector<vector<int>> g(n);
        vector<int> st(4 * n), l(4 * n);
        build(st, nums, 0, n - 1, 0);
        int ans = 0;
        for (auto& query : queries) {
            g[query[1]].push_back(query[0]);
        }
        for (int i = 0; i < n; i++) {
            sort(g[i].begin(), g[i].end());
            for (int j : g[i]) {
                if (query(st, l, 0, n - 1, j, i, 0) > 0) {
                    update(st, l, 0, n - 1, j, i, 0, -1), ans++;
                }
            }
        }
        return ans;
    }
};",1460883056
Rejas Raj,celestialcoder,72,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size(), ans = 0;
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
        }
        vector<vector<int>> dp(n, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = n - 1 - i; j < n; j++) {
                dp[i][j] = fruits[i][j];
                if (!i) {
                    continue;
                }
                dp[i][j] = fruits[i][j] + dp[i - 1][j];
                if (j) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i - 1][j - 1]);
                }
                if (j < n - 1) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i - 1][j + 1]);
                }
            }
        }
        ans += dp[n - 2][n - 1];
        for (int i = 0; i < n; i++) {
            dp[i].clear();
        }
        for (int j = 0; j < n; j++) {
            for (int i = n - 1 - j; i < n; i++) {
                dp[i][j] = fruits[i][j];
                if (!j) {
                    continue;
                }
                dp[i][j] = fruits[i][j] + dp[i][j - 1];
                if (i) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i - 1][j - 1]);
                }
                if (i < n - 1) {
                    dp[i][j] = max(dp[i][j], fruits[i][j] + dp[i + 1][j - 1]);
                }
            }
        }
        ans += dp[n - 1][n - 2];
        return ans;
    }
};",1460849554
__keep_it_simple__,__keep_it_simple__,73,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        for (int i = 0; i < s.size(); i++) {
            int a = s[i] - 'a', b = t[i] - 'a';
            long long x = 0, y = 0;
            int na = a;
            while (na != b) {
                x += nextCost[na];
                na = (na + 1) % 26;
            }
            na = a;
            while (na != b) {
                y += previousCost[na];
                na = (na - 1 + 26) % 26;
            }
            res += min(x, y);
        }
        return res;
    }
};",1460820579
__keep_it_simple__,__keep_it_simple__,73,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; i >= 1; i--) {
            n -= i;
            if (n < 0) {
                if (i % 2 == 0) return false;
                else return true;
            }
        }
        return false;
    }
};",1460797994
__keep_it_simple__,__keep_it_simple__,73,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int N = nums.size();
        vector<vector<int>> pos(N);
        priority_queue<int> pq;
        for (auto &arr: queries) {
            int l = arr[0], r = arr[1];
            if (l < N) pos[l].emplace_back(min(r, N - 1));
        }
        int acc = 0;
        vector<int> pref(N);
        int res = 0;
        for (int i = 0; i < N; i++) {
            for (auto x: pos[i]) pq.emplace(x);
            acc += pref[i];
            int sub = min(nums[i], acc);
            nums[i] -= sub;
            pref[i] = 0;
            while (nums[i] > 0 && !pq.empty() && pq.top() >= i) {
                int x = pq.top(); pq.pop();
                acc++;
                nums[i]--;
                if (x + 1 < N) pref[x + 1]--;
            }
            if (nums[i] > 0) return -1;
            acc += pref[i];
        }
        return pq.size();
    }
};",1460857009
__keep_it_simple__,__keep_it_simple__,73,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& grid) {
        int N = grid.size(), res = 0;
        const int INF = 1e9;
        for (int i = 0; i < N; i++) {
            res += grid[i][i];
            grid[i][i] = 0;
        }
        int x = 0, y = 0;
        vector<vector<int>> dp(N, vector<int>(N, -INF));
        dp[0][N - 1] = grid[0][N - 1];
        for (int i = 1; i < N; i++) for (int j = 0; j < N; j++) {
            int max_prev = dp[i-1][j];
            if (j > 0) max_prev = max(max_prev, dp[i-1][j-1]);
            if (j + 1 < N) max_prev = max(max_prev, dp[i-1][j+1]);
            if (max_prev >= 0) dp[i][j] = grid[i][j] + max_prev;
        }
        x = dp[N-1][N-1];
        dp.assign(N, vector<int>(N, -INF));
        dp[N - 1][0] = grid[N - 1][0];
        for (int j = 1; j < N; j++) for (int i = 0; i < N; i++) {
            int max_prev = dp[i][j - 1];
            if (i > 0) max_prev = max(max_prev, dp[i - 1][j - 1]);
            if (i + 1 < N) max_prev = max(max_prev, dp[i + 1][j - 1]);
            if (max_prev >= 0) dp[i][j] = grid[i][j] + max_prev;
        }
        y = dp[N-1][N-1];

        return res + x + y;
    }
};",1460877227
Pavlo Soroka,Chasey,78,3591,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<ll> pref1(27, 0); REP(i, 26) pref1[i+1] = pref1[i] + nextCost[i];
        vector<ll> pref2(27, 0); REP(i, 26) pref2[i+1] = pref2[i] + previousCost[i];
        vector<vector<ll>> dp(26, vector<ll>(26, 0));
        REP(i, 26) {
            REP(j, 26) {
                if (i == j) continue;
                if (i > j) {
                    ll sub1 = pref2[i+1] - pref2[j+1];
                    ll sub2 = pref1[26]-pref1[i] + pref1[j];
                    dp[i][j] = min(sub1, sub2);
                } else {
                    ll sub1 = pref1[j] - pref1[i];
                    ll sub2 = pref2[i+1] + pref2[26] - pref2[j+1];
                    dp[i][j] = min(sub1, sub2);                    
                }
            }
        }
        ll res = 0;
        ll n = s.size();
        REP(i, n) res += dp[s[i]-'a'][t[i]-'a'];
        return res;
    }
};",1460819862
Pavlo Soroka,Chasey,78,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int start = 10;
        bool res = false;
        while (n >= start) {
            n -= start;
            start--;
            res = !res;
        }
        return res;
    }
};",1460796329
Pavlo Soroka,Chasey,78,3647,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        SORT(queries); ll m = queries.size(); ll j = 0;
        priority_queue<ll> pq; // dropped
        map<ll, ll> picked;
        ll curr = 0;
        ll totalPicked = 0;
        ll n = nums.size();
        REP(i, n) {
            while (j < m && queries[j][0] <= i) { pq.push(queries[j][1]); j++; }
            curr += picked[i];
            while (curr < nums[i]) {
                if (pq.size() == 0) return -1;
                auto p = pq.top(); pq.pop();
                if (p < i) return -1;
                curr++;
                picked[p+1]--;
                totalPicked++;
            }
        }
        return m - totalPicked;
    }
};",1460858310
Pavlo Soroka,Chasey,78,3648,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        ll n = fruits.size();
        ll res = 0;
        REP(i, n) { res += fruits[i][i]; fruits[i][i] = 0; }
        REP(i, n) REP(j, n) if (i+j < n-1) fruits[i][j] = 0;

        vector<vector<ll>> dp1(n, vector<ll>(n, 0));
        dp1[0][n-1] = fruits[0][n-1];
        FOR(i, 1, n) {
            REP(j, n) {
                ll sub = dp1[i-1][j];
                if (j > 0) sub = max(sub, dp1[i-1][j-1]);
                if (j+1 < n) sub = max(sub, dp1[i-1][j+1]);
                dp1[i][j] = fruits[i][j]+sub;
            }
        }

        vector<vector<ll>> dp2(n, vector<ll>(n, 0));
        dp2[n-1][0] = fruits[n-1][0];
        FOR(j, 1, n) {
            REP(i, n) {
                ll sub = dp2[i][j-1];
                if (i > 0) sub = max(sub, dp2[i-1][j-1]);
                if (i+1 < n) sub = max(sub, dp2[i+1][j-1]);
                dp2[i][j] = fruits[i][j]+sub;
            }
        }
        
        return res + dp1[n-1][n-1] + dp2[n-1][n-1];
    }
};",1460879164
PyIsTheBestLang,PyIsTheBestLang,79,3591,python3,"
def min(a, b):
    return a if a < b else b


class Solution:
    def shiftDistance(self, ss: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        n = len(ss)
        ans = 0
        for i in range(n):
            pre = ord(ss[i])-ord('a')
            post = ord(t[i]) - ord('a')
            cur = math.inf
            s = pre
            cost = 0
            while s != post:
                cost += nextCost[s]
                s = (s+1)%26
            cur = cost
            
            s = pre
            cost2 = 0
            while s != post:
                cost2 += previousCost[s]
                s = (s-1)%26
            ans += min(cur, cost2)
        return ans",1460867987
PyIsTheBestLang,PyIsTheBestLang,79,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        
        pre = 10
        x = n
        for i in range(n+1):
            if pre > x or pre == 0:
                return i%2 == 1
            x -= pre
            pre -= 1
        ",1460867861
PyIsTheBestLang,PyIsTheBestLang,79,3647,python3,"
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        dct = [[] for _ in range(n)]
        for i, j in queries:
            dct[i].append(j)
        ans = 0
        diff = [0]*n
        pre = []
        for i in range(n):
            diff[i] += diff[i-1] if i else 0
            nums[i] += diff[i]
            for x in dct[i]:
                heappush(pre, -x)
            if nums[i] > 0:
                if nums[i] > len(pre):
                    return -1

                for _ in range(nums[i]):
                    x = -heappop(pre)
                    if x < i:
                        return -1
                    diff[i] -= 1
                    if x+1<n:
                        diff[x+1] += 1
        return len(pre)",1460869759
PyIsTheBestLang,PyIsTheBestLang,79,3648,python3,"def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b



class Solution:

    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:

        n = len(fruits)
        ans = 0
        for i in range(n):
            #print(i, fruits[i][i])
            ans += fruits[i][i]
            fruits[i][i] = 0

        @lru_cache(None)
        def dfs1(i1, j1):
            #print(i1, j1)
            if i1 == j1:
                return 0
            cur = fruits[i1][j1]
            nex = -math.inf
            for a, b in [[-1, 1], [0, 1], [1, 1]]:
                if 0<=i1+a<n and 0<=j1+b<n:
                    nex = max(nex, dfs1(i1+a, j1+b))
            #print(i1, j1, i2, j2, cur+nex)
            return cur + nex

        @lru_cache(None)
        def dfs2(i2, j2):
            if i2 == j2:
                return 0
            cur = fruits[i2][j2]
            nex = -math.inf
            for a2, b2 in [[1, -1], [1, 0], [1, 1]]:
                if 0<=i2+a2<n and 0<=j2+b2<n:
                    nex = max(nex, dfs2(i2+a2, j2+b2))
            return cur + nex
        ans += dfs1(n-1, 0)
        ans += dfs2(0, n-1)
        #print(ans)
        dfs1.cache_clear()
        dfs2.cache_clear()
        return ans

    def maxCollectedFruits2(self, fruits: List[List[int]]) -> int:

        n = len(fruits)
        ans = 0
        for i in range(n):
            #print(i, fruits[i][i])
            ans += fruits[i][i]
            fruits[i][i] = 0

        @lru_cache(None)
        def dfs(i1, j1, i2, j2):
            if i1 == j1 or i2 == j2:
                return 0
            cur = fruits[i1][j1] + fruits[i2][j2]

            if (i1, j1) == (i2, j2):
                cur -= fruits[i1][j1]
            nex = -math.inf
            for a, b in [[-1, 1], [0, 1], [1, 1]]:
                if abs(n-1-i1-a)+abs(n-1-j1-b) + abs(n-1-i1)+abs(j1) <= n-1 and 0<=i1+a<n and 0<=j1+b<n:
                    for a2, b2 in [[1, -1], [1, 0], [1, 1]]:
                        if abs(n - 1 - i2 - a2) + abs(n - 1 - j2 - b2) + abs(i2) + abs(n-1-j2) <= n-1 and 0<=i2+a2<n and 0<=j2+b2<n:
                            nex = max(nex, dfs(i1+a, j1+b, i2+a2, j2+b2))
            #print(i1, j1, i2, j2, cur+nex)
            return cur + nex

        #print(ans)
        ans += dfs(n-1, 0, 0, n-1)
        #print(ans)
        dfs.cache_clear()
        return ans
",1460873223
Kinon,Kinon,80,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long dpnxt[32], dpprv[32];
        dpnxt[0] = 0; dpprv[0] = 0;
        for(int i=0; i<26; i++){
            dpnxt[i+1] = dpnxt[i] + nextCost[i];
            dpprv[i+1] = dpprv[i] + previousCost[i];
        }
        long long ans = 0;
        for(int i=0; i<s.length(); i++){
            long long nxt = 0, prv = 0;
            for(int j=s[i]-'a'; j!=t[i]-'a'; j=(j+1)%26){
                nxt = nxt + nextCost[j];
            }
            for(int j=s[i]-'a'; j!=t[i]-'a'; j=(j+25)%26){
                prv = prv + previousCost[j];
            }
            ans += min(nxt, prv);
        }
        return ans;
    }
};",1460821186
Kinon,Kinon,80,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10; i>=0; i--){
            if(n < i){
                return (i%2 == 1);
            }
            n -= i;
        }
        return true;
    }
};",1460801083
Kinon,Kinon,80,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        multiset<int> pos, neg;
        vector<pair<int, int>> pq;
        for(int i=0; i<queries.size(); i++) pq.push_back({queries[i][0], queries[i][1]});
        sort(pq.begin(), pq.end());
        int ans = 0, pqidx = 0, cur = 0;
        for(int i=0; i<nums.size(); i++){
            while(pqidx < pq.size() && pq[pqidx].first == i){
                neg.insert(-pq[pqidx].second);
                pqidx++;
            }
            while(cur < nums[i] && neg.size() > 0 && -*(neg.begin()) >= i){
                int temp = -*(neg.begin());
                cur++; ans++;
                neg.erase(neg.begin());
                pos.insert(temp);
            }
            if(cur < nums[i]) return -1;
            while(pos.size() > 0 && *(pos.begin()) == i){
                cur--; 
                pos.erase(pos.begin());
            }
        }
        return queries.size() - ans;
    }
};",1460852257
Kinon,Kinon,80,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        //vector<vector<int>> temp;
        //vector<int> row;
        //for(int i=0; i<n*2; i++) row.push_back(0);
        //for(int i=0; i<n*2; i++) temp.push_back(row);
        
        for(int i=1; i<n; i++){
            fruits[i][i] += fruits[i-1][i-1];
            fruits[i-1][i-1] = 0;
            for(int j=0; j+i-1 < n-1; j++){
                fruits[i-1][j] = 0;
            }
        }
        for(int i=1; i<n-1; i++){
            for(int j=i+1; j<n; j++){
                int a = max(fruits[i-1][j-1], fruits[i-1][j]);
                int b = max(fruits[j-1][i-1], fruits[j][i-1]);
                if(j<n-1){
                    a = max(fruits[i-1][j+1], a);
                    b = max(fruits[j+1][i-1], b);
                }
                fruits[i][j] += a;
                fruits[j][i] += b;
            }
        }
        return fruits[n-2][n-1] + fruits[n-1][n-1] + fruits[n-1][n-2];
    }
};",1460879521
Teemu Ryyti,delivery,87,3591,cpp,"using ll = long long;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        int n = s.size();
        ll ans = 0;
        vector<vector<ll>> d(26, vector<ll> (26, INT64_MAX));
        for (int i = 0; i < 26; ++i) {
            d[i][i] = 0;
            d[i][(i +1) % 26] = nc[i];
            d[i][(i + 25) % 26] = pc[i];
        }
        for (int k = 0; k < 26; ++k) {
            for (int i = 0; i < 26; ++i) {
                for (int j = 0; j < 26; ++j) {
                    if (d[i][k] != INT64_MAX && d[k][j] != INT64_MAX)
                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
                }
            }
        }
        
        for (int i = 0; i < n; ++i) {
            ans += d[s[i]-'a'][t[i]-'a'];
        }
        
        return ans;
    }
};",1460817385
Teemu Ryyti,delivery,87,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int c = 10;
        for (int i = 0; i < 100; ++i) {
            if (n < c) {
                return i % 2 == 1;
            }
            n -= c;
            --c;
        }
        return true;
    }
};",1460799975
Teemu Ryyti,delivery,87,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& qq) {
        sort(qq.begin(), qq.end());
        int ans = qq.size();
        multiset<int> have, open;
        int j = -1;
        for (int i = 0; i < nums.size(); ++i) {
            while (!open.empty() && *open.begin() < i) {
                open.erase(open.find(*open.begin()));
            }
            while (!have.empty() && *have.begin() < i) {
                have.erase(have.find(*have.begin()));
            }
            while (j + 1 < qq.size() && qq[j + 1][0] == i) {
                ++j;
                open.insert(qq[j][1]);
            }
                        //cout << i << "" "" << open.size() << "" "" << have.size() << ""\n"";
            if (have.size() < nums[i]) {
                if (open.size() + have.size() < nums[i]) {
                    return -1;
                }
                while (have.size() < nums[i]) {
                    int r = *open.rbegin();
                    have.insert(r);
                    open.erase(open.find(r));
                    --ans;
                }
            }
        }
        return ans;
    }
};",1460840683
Teemu Ryyti,delivery,87,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int n = f.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += f[i][i];
        }
        
        {
            vector<vector<int>> d(n, vector<int> (n));
            d[0][n-1] = f[0][n-1];
            for (int i = 1; i < n - 1; ++i) {
                for (int j = max(i + 1, n - 1 - i); j < n; ++j) {
                    d[i][j] = max(d[i-1][j], d[i-1][j-1]);
                    if (j + 1 < n) {
                        d[i][j] = max(d[i][j], d[i-1][j+1]);
                    }
                    d[i][j] += f[i][j];
                }
            }
            ans += d[n-2][n-1];
        }
        {
            vector<vector<int>> d(n, vector<int> (n));
            d[0][n-1] = f[n-1][0];
            for (int i = 1; i < n - 1; ++i) {
                for (int j =  max(i + 1, n - 1 - i); j < n; ++j) {
                    d[i][j] = max(d[i-1][j], d[i-1][j-1]);
                    if (j + 1 < n) {
                        d[i][j] = max(d[i][j], d[i-1][j+1]);
                    }
                    d[i][j] += f[j][i];
                }
            }
            ans += d[n-2][n-1];

        }
        return ans;
    }
};",1460864009
Peter Lin,inversionpeter,89,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long counts = 0, cost1, cost2;
        for (int i = 0; i != s.size(); ++i) {
            cost1 = cost2 = 0;
            char c = s[i];
            while (c != t[i]) {
                cost1 += nextCost[c - 'a'];
                c = (c - 'a' + 1) % 26 + 'a';
            }
            c = s[i];
            while (c != t[i]) {
                cost2 += previousCost[c - 'a'];
                c = (c - 'a' + 25) % 26 + 'a';
            }
            counts += min(cost1, cost2);
        }
        return counts;
    }
};",1460806150
Peter Lin,inversionpeter,89,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int nowAlice = true, nowStone = 10;
        while (n) {
            if (n >= nowStone) {
                n -= nowStone;
            }
            else {
                break;
            }
            nowAlice = !nowAlice;
            --nowStone;
        }
        return nowAlice ? false : true;
    }
};",1460796589
Peter Lin,inversionpeter,89,3647,cpp,"vector <vector <int>> events;
bool picked[100000];

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int nowAt = 0, nowEvent = 0, totalDecrements = 0, pick = 0;
        set <pair <int, int>> rightEnds;
        events.clear();
        memset(picked, false, sizeof(picked));
        for (int i = 0; i != queries.size(); ++i) {
            events.push_back({ queries[i][0], 0, i });
            events.push_back({ queries[i][1] + 1, 1, i });
        }
        sort(events.begin(), events.end());
        while (nowAt != nums.size()) {
            while (nowEvent != events.size() && events[nowEvent][0] == nowAt) {
                int index = events[nowEvent][2];
                if (events[nowEvent][1]) {
                    if (picked[index]) {
                        --totalDecrements;
                    }
                    rightEnds.erase({ queries[index][1], index });
                }
                else {
                    rightEnds.insert({ queries[index][1], index });
                }
                ++nowEvent;
            }
            for (int i = totalDecrements; i < nums[nowAt]; ++i) {
                if (rightEnds.empty()) {
                    return -1;
                }
                ++pick;
                ++totalDecrements;
                picked[(*prev(rightEnds.end())).second] = true;
                rightEnds.erase(prev(rightEnds.end()));
            }
            ++nowAt;
        }
        return queries.size() - pick;
    }
};",1460882727
Peter Lin,inversionpeter,89,3648,cpp,"int DP[1000][1000];

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        memset(DP, 0, sizeof(DP));
        int counts = 0, length = fruits.size(), half = (length >> 1) - 1;
        for (int i = 0; i < length; ++i) {
            counts += fruits[i][i];
        }
        DP[0][length - 1] = fruits[0][length - 1];
        for (int i = 1; i <= half; ++i) {
            for (int j = 0; j <= i; ++j) {
                DP[i][length - j - 1] = max(DP[i][length - j - 1], DP[i - 1][length - j - 1]);
                if (j) {
                    DP[i][length - j - 1] = max(DP[i][length - j - 1], DP[i - 1][length - j]);
                }
                DP[i][length - j - 1] = max(DP[i][length - j - 1], DP[i - 1][length - j - 2]);
                DP[i][length - j - 1] += fruits[i][length - j - 1];
            }
        }
        for (int i = half - !(length & 1), _i = half + 1; i >= 0; --i, ++_i) {
            for (int j = 0; j <= i; ++j) {
                DP[_i][length - j - 1] = max(DP[_i][length - j - 1], DP[_i - 1][length - j - 1]);
                if (j) {
                    DP[_i][length - j - 1] = max(DP[_i][length - j - 1], DP[_i - 1][length - j]);
                }
                DP[_i][length - j - 1] = max(DP[_i][length - j - 1], DP[_i - 1][length - j - 2]);
                DP[_i][length - j - 1] += fruits[_i][length - j - 1];
            }
        }
        DP[length - 1][0] = fruits[length - 1][0];
        for (int i = 1; i <= half; ++i) {
            for (int j = 0; j <= i; ++j) {
                DP[length - j - 1][i] = max(DP[length - j - 1][i], DP[length - j - 1][i - 1]);
                if (j) {
                    DP[length - j - 1][i] = max(DP[length - j - 1][i], DP[length - j][i - 1]);
                }
                DP[length - j - 1][i] = max(DP[length - j - 1][i], DP[length - j - 2][i - 1]);
                DP[length - j - 1][i] += fruits[length - j - 1][i];
            }
        }
        for (int i = half - !(length & 1), _i = half + 1; i >= 0; --i, ++_i) {
            for (int j = 0; j <= i; ++j) {
                DP[length - j - 1][_i] = max(DP[length - j - 1][_i], DP[length - j - 1][_i - 1]);
                if (j) {
                    DP[length - j - 1][_i] = max(DP[length - j - 1][_i], DP[length - j][_i - 1]);
                }
                DP[length - j - 1][_i] = max(DP[length - j - 1][_i], DP[length - j - 2][_i - 1]);
                DP[length - j - 1][_i] += fruits[length - j - 1][_i];
            }
        }
        return counts + DP[length - 2][length - 1] + DP[length - 1][length - 2];
    }
};",1460858757
luciaa,luciaa,91,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        for c1, c2 in zip(s, t):
            i1, i2 = ord(c1) - ord('a'), ord(c2) - ord('a') 
            l, r = (i1 - i2) % 26, (i2 - i1) % 26
            res += min(
                sum(previousCost[(i1 - j) % 26] for j in range(l)), 
                sum(nextCost[(i1 + j) % 26] for j in range(r)))
        return res",1460824111
luciaa,luciaa,91,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for q in range(10, 0, -1):
            if n >= q:
                n -= q
            else:
                return q % 2 != 0
        return False
        ",1460799633
luciaa,luciaa,91,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        can, have = [], []
        used = 0
        qi = 0
        for i, e in enumerate(nums):
            while have and have[0] < i:
                heapq.heappop(have)
            while qi < len(queries) and queries[qi][0] <= i:
                heapq.heappush(can, -queries[qi][1])
                qi += 1
            while len(have) < e and can and i <= -can[0]:
                heapq.heappush(have, -heapq.heappop(can))
                used += 1
            if len(have) < e:
                return -1
        return len(queries) - used
        ",1460859452
luciaa,luciaa,91,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        @cache
        def topright(r, c):
            if r == n - 1 and c == n - 1:
                return 0
            if r < 0 or r > n - 1 or c < 0 or c > n - 1:
                return -inf
            cur = fruits[r][c] if r != c else 0
            return cur + max(
                topright(r + 1, c - 1),
                topright(r + 1, c),
                topright(r + 1, c + 1))

        @cache
        def bottomleft(r, c):
            if r == n - 1 and c == n - 1:
                return 0
            if r < 0 or r > n - 1 or c < 0 or c > n - 1:
                return -inf
            cur = fruits[r][c] if r != c else 0
            return cur + max(
                bottomleft(r - 1, c + 1),
                bottomleft(r, c + 1),
                bottomleft(r + 1, c + 1))

        res = sum(fruits[r][r] for r in range(n))
        res += topright(0, n - 1)
        res += bottomleft(n - 1, 0)
        print(res)
        return res
        ",1460889163
zsq007,zsq007,92,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nextCost = list(accumulate(nextCost, initial = 0))
        previousCost = list(accumulate(previousCost, initial = 0))
        dist = [[0]*26 for _ in range(26)]
        for i in range(26):
            for j in range(i):
                dist[i][j] = min(nextCost[26] - nextCost[i] + nextCost[j], previousCost[i+1] - previousCost[j+1])
                dist[j][i] = min(previousCost[26] - previousCost[i+1] + previousCost[j+1], nextCost[i] - nextCost[j])
        # print(nextCost)
        # print(previousCost)

        # for d in dist:
        #     print(d)

        return sum(dist[ord(a)-97][ord(b)-97] for a,b in zip(s,t))",1460825884
zsq007,zsq007,92,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        p = 10
        res = False
        while n >= p:
            n -= p
            p -= 1
            res = not res
        return res",1460797709
zsq007,zsq007,92,3647,python3,"from sortedcontainers import SortedList
        
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        queries.sort()
        avail = SortedList()
        used = []
        j, m = 0, len(queries)
        acc, res = 0, 0

        for i in range(n):
            while used and used[0] == i:
                heappop(used)
                acc -= 1
            while avail and avail[0] == i:
                avail.remove(i)
                res += 1
            while j < m and queries[j][0] == i:
                # heappush(avail, -queries[j][1]-1)
                avail.add(queries[j][1]+1)
                j += 1
            while acc < nums[i] and avail:
                # heappush(used, heappop(avail))
                heappush(used, avail.pop(-1))
                acc += 1
            if acc < nums[i]:
                return -1

        return res + len(avail)",1460883420
zsq007,zsq007,92,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        for j in range(1, n-1):
            fruits[0][j] = -inf
        fruits[0].append(-inf)

        for i in range(1, n-1):
            fruits[i][0] = -inf
        fruits.append([-inf]*n)

        for i in range(1, n-1):
            for j in range(i+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i-1][j], fruits[i-1][j+1])
            fruits[i].append(-inf)

        for j in range(1, n-1):
            for i in range(j+1, n):
                fruits[i][j] += max(fruits[i-1][j-1], fruits[i][j-1], fruits[i+1][j-1])

        return fruits[n-2][n-1] + fruits[n-1][n-2] + sum(fruits[i][i] for i in range(n))",1460870340
Sreesh Maheshwar,sreeshmaheshwar,93,3591,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prv) {
        vt<ll> pn(26 + 1);
        forn(26) pn[i + 1] = pn[i] + nxt[i];
        
        vt<ll> pp(26 + 1);
        forn(26) pp[i + 1] = pp[i] + prv[i];

        vt<vt<ll>>dp(26,vt<ll>(26, (ll) 1e18));
        forn(i, 26) forn(j, 26) {
            if (i == j) dp[i][j] = 0;
            if (i < j) {
                ll x = pn[j] - pn[i];
                dp[i][j] = x;
                // umin(dp[i][j], pn.back() - x);
    
                ll y = pp[j + 1] - pp[i + 1];
                // umin(dp[i][j], y);
                umin(dp[i][j], pp.back() - y);
            } else {
                ll x = pn[i] - pn[j];
                // dp[i][j] = x;
                umin(dp[i][j], pn.back() - x);
    
                ll y = pp[i + 1] - pp[j + 1];
                umin(dp[i][j], y);
                // umin(dp[i][j], pp.back() - y);
            }
        }
        int n = sz(s);
        ll ans = 0;
        forn(n) {
            // if(s[i]>t[i])swap(s[i], t[i]);
            ans += dp[s[i] - 'a'][t[i] - 'a'];
        }
        return ans;
    }
};",1460868921
Sreesh Maheshwar,sreeshmaheshwar,93,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0;
        int now = 10;
        while (true) {
            if (n - now < 0) return turn;
            n -= now;
            now--;
            turn ^= 1;
        } 
        return 0;
    }
};",1460872315
Sreesh Maheshwar,sreeshmaheshwar,93,3647,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

namespace atcoder {

/** 
 * Atcoder Library Code (Lazy Segment Tree), credited to AtCoder. Taken from
 * https://github.com/atcoder/ac-library/blob/master/atcoder/lazysegtree.hpp
 */

inline int ceil_pow2(int n) {
    int x = 0;
    while ((1U << x) < (unsigned int)(n)) x++;
    return x;
}

template <class S,
          S (*op)(S, S),
          S (*e)(),
          class F,
          S (*mapping)(F, S),
          F (*composition)(F, F),
          F (*id)()>
struct lazy_segtree {
  public:
    lazy_segtree() : lazy_segtree(0) {}

    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}

    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {
        log = ceil_pow2(_n);
        size = 1 << log;
        d = std::vector<S>(2 * size, e());
        lz = std::vector<F>(size, id());
        for (int i = 0; i < _n; i++) d[size + i] = v[i];
        for (int i = size - 1; i >= 1; i--) {
            update(i);
        }
    }

    void set(int p, S x) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        d[p] = x;
        for (int i = 1; i <= log; i++) update(p >> i);
    }

    S get(int p) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        return d[p];
    }

    S prod(int l, int r) {
        assert(0 <= l && l <= r && r <= _n);
        if (l == r) return e();
        l += size;
        r += size;
        for (int i = log; i >= 1; i--) {
            if (((l >> i) << i) != l) push(l >> i);
            if (((r >> i) << i) != r) push((r - 1) >> i);
        }
        S sml = e(), smr = e();
        while (l < r) {
            if (l & 1) sml = op(sml, d[l++]);
            if (r & 1) smr = op(d[--r], smr);
            l >>= 1;
            r >>= 1;
        }
        return op(sml, smr);
    }

    S all_prod() { return d[1]; }

    void apply(int p, F f) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        d[p] = mapping(f, d[p]);
        for (int i = 1; i <= log; i++) update(p >> i);
    }

    void apply(int l, int r, F f) {
        assert(0 <= l && l <= r && r <= _n);
        if (l == r) return;
        l += size;
        r += size;
        for (int i = log; i >= 1; i--) {
            if (((l >> i) << i) != l) push(l >> i);
            if (((r >> i) << i) != r) push((r - 1) >> i);
        }
        {
            int l2 = l, r2 = r;
            while (l < r) {
                if (l & 1) all_apply(l++, f);
                if (r & 1) all_apply(--r, f);
                l >>= 1;
                r >>= 1;
            }
            l = l2;
            r = r2;
        }
        for (int i = 1; i <= log; i++) {
            if (((l >> i) << i) != l) update(l >> i);
            if (((r >> i) << i) != r) update((r - 1) >> i);
        }
    }

    template <bool (*g)(S)> int max_right(int l) {
        return max_right(l, [](S x) { return g(x); });
    }

    template <class G> int max_right(int l, G g) {
        assert(0 <= l && l <= _n);
        assert(g(e()));
        if (l == _n) return _n;
        l += size;
        for (int i = log; i >= 1; i--) push(l >> i);
        S sm = e();
        do {
            while (l % 2 == 0) l >>= 1;
            if (!g(op(sm, d[l]))) {
                while (l < size) {
                    push(l);
                    l = (2 * l);
                    if (g(op(sm, d[l]))) {
                        sm = op(sm, d[l]);
                        l++;
                    }
                }
                return l - size;
            }
            sm = op(sm, d[l]);
            l++;
        } while ((l & -l) != l);
        return _n;
    }

    template <bool (*g)(S)> int min_left(int r) {
        return min_left(r, [](S x) { return g(x); });
    }

    template <class G> int min_left(int r, G g) {
        assert(0 <= r && r <= _n);
        assert(g(e()));
        if (r == 0) return 0;
        r += size;
        for (int i = log; i >= 1; i--) push((r - 1) >> i);
        S sm = e();
        do {
            r--;
            while (r > 1 && (r % 2)) r >>= 1;
            if (!g(op(d[r], sm))) {
                while (r < size) {
                    push(r);
                    r = (2 * r + 1);
                    if (g(op(d[r], sm))) {
                        sm = op(d[r], sm);
                        r--;
                    }
                }
                return r + 1 - size;
            }
            sm = op(d[r], sm);
        } while ((r & -r) != r);
        return 0;
    }

  private:
    int _n, size, log;
    std::vector<S> d;
    std::vector<F> lz;

    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }

    void all_apply(int k, F f) {
        d[k] = mapping(f, d[k]);
        if (k < size) lz[k] = composition(f, lz[k]);
    }

    void push(int k) {
        all_apply(2 * k, lz[k]);
        all_apply(2 * k + 1, lz[k]);
        lz[k] = id();
    }
};

}  // namespace atcoder

struct segment_change {
    // TODO: overflow - must hold composition also!
    int64_t to_add = 0;

    segment_change() {}
    segment_change(int64_t _to_add) : to_add(_to_add) {}
};

// change represented by g's application followed by f's application
segment_change compose(segment_change f, segment_change g) {
    return segment_change(f.to_add + g.to_add);
}

const ll INF = 1e18;

struct segment {
    // TODO: overflow - must hold application and combination also!
    int64_t minimum = -INF;

    segment() {}
    segment(int64_t _minimum) : minimum(_minimum) {}
};

segment apply(segment_change change, segment a) {
    if (a.minimum == -INF) return segment(-INF);
    return segment(a.minimum + change.to_add);
}

segment combine(segment a, segment b) {
    return segment(max(a.minimum, b.minimum));
}

segment segment_e() { return segment(); }
segment_change segment_change_id() { return segment_change(); }
using lazy_segtree = atcoder::lazy_segtree<segment, combine, segment_e, 
    segment_change, apply, compose, segment_change_id>;

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& qs) {
        int n = sz(a);
        int q = sz(qs);

        vt<segment> segs;
        forn(n) segs.pb(segment(a[i]));
        lazy_segtree st(segs);

        sort(all(qs), [&](vt<int>& lhs, vt<int>& rhs) -> bool {
            return lhs[1] < rhs[1];
        });

        for (auto v : qs) {
            int l = v[0], r = v[1];
            st.apply(l, r + 1, -1);
        }
        int c = 0;
        for (auto v : qs) {
            int l = v[0], r = v[1]; r++;
            if (st.prod(l, r).minimum < 0) {
                st.apply(l, r, 1);
                c += 1;
            }
        }

        if (st.prod(0, n).minimum > 0) return -1;
        return c;
    }
};",1460849208
Sreesh Maheshwar,sreeshmaheshwar,93,3648,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = sz(a);
        // dp[i][j] is max to get to i, j, can never go above diagonal
        int x = 0;
        {
            const vector<pair<int, int>> DIRECTIONS = {{-1, +1}, {0, +1}, {+1, +1}};
            vt<vt<int>> dp(n, vt<int>(n, -1));
            dp[n - 1][0] = a[n - 1][0];
            for (int j = 0; j < n; ++j) {
                for (int i = 0; i < n; ++i) {
                    if (dp[i][j] < 0) continue;
                    for (auto [di, dj] : DIRECTIONS) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (0 <= min(ni, nj) && max(ni, nj) < n && i > j) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + a[ni][nj]);
                        }
                    } 
                }
            }
            x = dp[n - 1][n - 1] - a[n - 1][n - 1];
        }
        int y = 0;
        {
            const vector<pair<int, int>> DIRECTIONS = {{+1, -1}, {+1, 0}, {+1, +1}};
            vt<vt<int>> dp(n, vt<int>(n, -1));
            dp[0][n - 1] = a[0][n - 1];
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (dp[i][j] < 0) continue;
                    for (auto [di, dj] : DIRECTIONS) {
                        int ni = i + di;
                        int nj = j + dj;
                        if (0 <= min(ni, nj) && max(ni, nj) < n && i < j) {
                            dp[ni][nj] = max(dp[ni][nj], dp[i][j] + a[ni][nj]);
                        }
                    } 
                }
            }
            y = dp[n - 1][n - 1] - a[n - 1][n - 1];
        }
        int z = 0;
        for (int i = 0; i < n; ++i) {
            z += a[i][i];
        }
        return z + x + y;
    }
};",1460821538
kesshb,kesshb,94,3591,java,"class Solution {
  public static void main(String... args) {
    Solution solution = new Solution();

  }

  int n;

  public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
    int n = s.length();
    long result = 0L;
    for (int i = 0; i < n; i++) {
      result += cost(s, t, nextCost, previousCost, i);
    }
    return result;
  }

  private long cost(String s, String t, int[] nextCost, int[] previousCost, int i) {
    long forward = 0L, back = 0L;
    char sc = s.charAt(i), tc = t.charAt(i);
    if (sc == tc) {
      return 0L;
    }
    while (sc != tc) {
      forward += nextCost[sc - 'a'];
      sc = (char) ((sc - 'a' + 1) % 26 + 'a');
    }
    sc = s.charAt(i);
    while (sc != tc) {
      back += previousCost[sc - 'a'];
      sc = (char) ((sc - 'a' - 1 + 26) % 26 + 'a');
    }
    return Math.min(forward, back);
  }
}",1460810217
kesshb,kesshb,94,3625,java,"class Solution {
  public boolean canAliceWin(int n) {
    boolean win = false;
    int curr = 10;
    while (curr <= n) {
      n -= curr--;
      win = !win;
    }
    return win;
  }
}",1460796406
kesshb,kesshb,94,3647,java,"class Solution {

  public static void main(String... args) {
    Solution solution = new Solution();
    int[] nums = {2, 0, 2};
    int[][] queries = {{0, 2}, {0, 2}, {1, 1}};
    System.out.println(solution.maxRemoval(nums, queries));
  }

  public int maxRemoval(int[] nums, int[][] queries) {
    int n = nums.length;
    int q = queries.length;
    int[] sweep = new int[n + 1];
    for (int[] query : queries) {
      sweep[query[0]]++;
      sweep[query[1] + 1]--;
    }
    if (!zero(nums, sweep)) {
      return -1;
    }
    Queue<int[]> quer = new PriorityQueue<>((a, b) -> {
      if (a[0] == b[0]) {
        return b[1] - a[1];
      }
      return a[0] - b[0];
    });
    for (int[] query : queries) {
      quer.add(query);
    }
    Queue<Integer> gone = new PriorityQueue<>((a, b) -> a - b);
    Queue<Integer> reserve = new PriorityQueue<>((a, b) -> b - a);
    int curr = 0;
    int size = 0;
    for (int i = 0; i < n; i++) {
      while (!gone.isEmpty() && gone.peek() <= i) {
        curr--;
        gone.poll();
      }
      int end = nums[i] - curr;
      for (int j = 0; j < end; j++) {
        if ((quer.isEmpty() || quer.peek()[0] > i) && reserve.isEmpty()) {
          break;
        }
        int fromRes = -1, fromQuer = -1;
        if (!reserve.isEmpty()) {
          fromRes = reserve.peek();
        }
        if (!quer.isEmpty() && quer.peek()[0] <= i) {
          fromQuer = quer.peek()[1];
        }
        if (fromRes >= fromQuer) {
          gone.add(reserve.poll() + 1);
          curr++;
          size++;
        } else {
          int[] query = quer.poll();
          gone.add(query[1] + 1);
          curr++;
          size++;
        }
      }
      while (!quer.isEmpty() && quer.peek()[0] <= i) {
        reserve.add(quer.poll()[1]);
      }
    }
    return q - size;
  }

  private boolean zero(int[] nums, int[] sweep) {
    int curr = 0;
    for (int i = 0; i < nums.length; i++) {
      curr += sweep[i];
      if (nums[i] > curr) {
        return false;
      }
    }
    return true;
  }
}",1460864063
kesshb,kesshb,94,3648,java,"class Solution {
 
  public static void main(String... args) {
    Solution solution = new Solution();
    int[][] fruits = new int[][] {{1,2,3,4},{5,6,8,7},{9,10,11,12},{13,14,15,16}};
    System.out.println(solution.maxCollectedFruits(fruits));
  }

  private int[][] dirsBot = new int[][] {{1, 1}, {0, 1}, {-1, 1}};
  private int[][] dirsTop = new int[][] {{1, -1}, {1, 0}, {1, 1}};

  int n;

  public int maxCollectedFruits(int[][] fruits) {
    int res = 0;
    n = fruits.length;
    for (int i = 0; i < n; i++) {
      res += fruits[i][i];
      fruits[i][i] = 0;
    }
    int[][] dp = new int[n][n];
    for (int i = 0; i < n; i++) {
      Arrays.fill(dp[i], -1);
    }
    res += dpBot(dp, fruits, n - 1, 0);
    dp = new int[n][n];
    for (int i = 0; i < n; i++) {
      Arrays.fill(dp[i], -1);
    }
    res += dpTop(dp, fruits, 0, n - 1);
    return res;
  }

  private int dpTop(int[][] dp, int[][] fruits, int i, int j) {
    if (i > j) {
      return -10000000;
    }
    if (i == n - 1) {
      return j == n - 1 ? 0 : -10000000;
    }
    if (dp[i][j] != -1) {
      return dp[i][j];
    }
    int res = fruits[i][j];
    for (int[] dir : dirsTop) {
      int x = i + dir[0];
      int y = j + dir[1];
      if (isValid(x, y)) {
        res = Math.max(res, fruits[i][j] + dpTop(dp, fruits, x, y));
      }
    }
    return dp[i][j] = res;
  }

  private int dpBot(int[][] dp, int[][] fruits, int i, int j) {
    if (i < j) {
      return -10000000;
    }
    if (j == n - 1) {
      return i == n - 1 ? 0 : -10000000;
    }
    if (dp[i][j] != -1) {
      return dp[i][j];
    }
    int res = fruits[i][j];
    for (int[] dir : dirsBot) {
      int x = i + dir[0];
      int y = j + dir[1];
      if (isValid(x, y)) {
        res = Math.max(res, fruits[i][j] + dpBot(dp, fruits, x, y));
      }
    }
    return dp[i][j] = res;
  }

  private boolean isValid(int x, int y) {
    return x >= 0 && x < n && y >= 0 && y < n;
  }
}",1460890567
g129512,g129512,95,3591,python3,"from typing import List


class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n=len(s)
        res=0

        def c1(x,y):
            res=0
            while x!=y:
                res+=nextCost[x]
                x+=1
                x%=26
            return res
        def c2(x,y):
            res=0
            while x!=y:
                res+=previousCost[x]
                x-=1
                x%=26
            return res

        for i in range(n):
            res+=min(c1(ord(s[i])-ord('a'), ord(t[i])-ord('a')),
                     c2(ord(s[i])-ord('a'), ord(t[i])-ord('a')))
        return res
        ",1460873871
g129512,g129512,95,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        x=10
        for i in range(100):
            if n<x:
                return i%2==1
            n-=x
            x-=1
        ",1460876619
g129512,g129512,95,3647,python3,"import heapq
from typing import List


class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n=len(nums)
        q=[]
        res=len(queries)
        queries.sort(key=lambda x:-x[0])
        h=0
        diff=[0]*(n+1)
        for i in range(n):
            h+=diff[i]
            while queries!=[] and queries[-1][0]<=i:
                heapq.heappush(q,-queries[-1][1])
                queries.pop()
            while h<nums[i]:
                if q==[]:
                    return -1
                r=-heapq.heappop(q)
                if r<i:continue
                h+=1
                diff[r+1]-=1
                res-=1
        return res
            
        ",1460878860
g129512,g129512,95,3648,python3,"from math import inf
from typing import List


class Solution:
    def maxCollectedFruits(self, ar: List[List[int]]) -> int:
        n=len(ar)
        res=0
        for i in range(n):
            res+=ar[i][i]
        dp=[[-inf]*n for _ in range(n)]
        dp[0][n-1]=ar[n-1][0]
        for j in range(1,n):
            for i in range(n):
                dp[j][i]=dp[j-1][i]
                if i<n-1:
                    dp[j][i]=max(dp[j][i],dp[j-1][i+1])
                if i>0:
                    dp[j][i]=max(dp[j][i],dp[j-1][i-1])
                if i!=j:
                    dp[j][i]+=ar[i][j]
        res+=dp[n-1][n-1]

        dp=[[-inf]*n for _ in range(n)]
        dp[0][n-1]=ar[0][n-1]
        for i in range(1,n):
            for j in range(n):
                dp[i][j]=dp[i-1][j]
                if j<n-1:
                    dp[i][j]=max(dp[i][j],dp[i-1][j+1])
                if j>0:
                    dp[i][j]=max(dp[i][j],dp[i-1][j-1])
                if i!=j:
                    dp[i][j]+=ar[i][j]
        res+=dp[n-1][n-1]
        return res",1460873469
jakao,jakao,97,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long dp[30][30];
        memset(dp, 0x3f, sizeof dp);
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < 26; j++){
                dp[i][j] = 0;
                for(int k = i; k != j; k = (k+1) % 26){
                    dp[i][j] += nextCost[k];
                }
                long long tmp = 0;
                for(int k = i; k != j; k = (k-1+26) % 26){
                    tmp += previousCost[k];
                }
                dp[i][j] = min(dp[i][j], tmp);
            }
        }
        long long ans = 0;
        for(int i = 0; i < s.size(); i++){
            ans += dp[s[i]-'a'][t[i]-'a'];
        }
        return ans;
    }
};",1460809458
jakao,jakao,97,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i = 0, j = 10; ;j--, i++){
            if(n < j){
                return i&1;
            }
            n -= j;
        }
        return 0;
    }
};",1460799163
jakao,jakao,97,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        priority_queue<int> remain;
        priority_queue<int, vector<int>, greater<int>> deadline;
        int sz = 0;
        for(int i = 0, j = 0; i < nums.size(); i++){
            while(!deadline.empty() && deadline.top() < i)
                deadline.pop();
            while(j < queries.size() && queries[j][0] <= i){
                remain.push(queries[j][1]);
                ++j;
            }
            while(deadline.size() < nums[i] && !remain.empty() && remain.top() >= i){
                deadline.push(remain.top());
                remain.pop();
                ++sz;
            }
            if(deadline.size() < nums[i])
                return -1;
            
        }
        return queries.size() - sz;
    }
};",1460824801
jakao,jakao,97,3648,cpp,"class Solution {
public:
    int n;
    bool safe(int x, int y){
        return 0 <= min(x,y) && max(x, y) < n;
    }
    int dp[1003][1003];
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ret = 0;
        n = fruits.size();
        for(int i = 0; i < n; i++){
            ret += fruits[i][i];
            fruits[i][i] = 0;
        }
        for(int i = 0; i < (n+1)/2; i++){
            for(int j = 0; j <= i; j++){
                int x = n-1-j, y = i;
                dp[n-1-j][i] = fruits[n-1-j][i];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(0, -1), pair(1, -1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        for(int i = (n+1)/2; i < n; i++){
            for(int j = 0; j <= n-1-i; j++){
                int x = n-1-j, y = i;
                dp[x][y] = fruits[x][y];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(0, -1), pair(1, -1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        // cout << dp[n-1][n-1];
        ret += dp[n-1][n-1];
        //
        memset(dp, 0, sizeof(dp));
        for(int i = 0; i < (n+1)/2; i++){
            for(int j = 0; j <= i; j++){
                int x = i, y = n-1-j;
                dp[x][y] = fruits[x][y];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(-1, 0), pair(-1, 1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        for(int i = (n+1)/2; i < n; i++){
            for(int j = 0; j <= n-1-i; j++){
                int x = i, y = n-1-j;
                dp[x][y] = fruits[x][y];
                int mx = 0;
                for(auto from : {pair(-1, -1), pair(-1, 0), pair(-1, 1)}){
                    int dx = from.first, dy = from.second;
                    if(safe(x+dx,y+dy)){
                        mx = max(mx, dp[x+dx][y+dy]);
                    }
                }
                dp[x][y] += mx;
            }
        }
        // cout << dp[n-1][n-1];
        ret += dp[n-1][n-1];
        return ret;
    }
};",1460878939
leetgoat_dot_dev,leetgoat_dot_dev,101,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        @cache
        def getToRight(aIndex, bIndex):
            if aIndex == bIndex:
                return 0
            costA = nextCost[aIndex]
            return costA + getToRight((aIndex + 1) % 26, bIndex)
        
        @cache
        def getToLeft(aIndex, bIndex):
            if aIndex == bIndex:
                return 0
            costA = previousCost[aIndex]
            newPrev = aIndex - 1 if aIndex > 0 else 25
            return costA + getToLeft(newPrev, bIndex)
        
        res = 0
        for i in range(len(s)):
            a = s[i]
            target = t[i]
            indexA = ord(a) - ord('a')
            indexB = ord(target) - ord('a')
            right = getToRight(indexA, indexB)
            left = getToLeft(indexA, indexB)
            res += min(left, right)
        
        return res",1460811820
leetgoat_dot_dev,leetgoat_dot_dev,101,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        turn = 'A'
        subtract = 10
        remain = n
        while True:
            if subtract > remain:
                return False if turn == 'A' else True
            remain -= subtract
            turn = 'B' if turn == 'A' else 'A'
            subtract -= 1
        
        ",1460802038
leetgoat_dot_dev,leetgoat_dot_dev,101,3647,python3,"from sortedcontainers import SortedList



# TEMPLATE BY https://github.com/agrawalishaan
# You are welcome to use this template. Please keep the link in your contest code to prevent automatic detection of copied content. Templates are allowed. Thanks!

# Complexities:
# Build: O(n)
# Space: O(n)
# Query/Update: O(log N)

# baseFn: (val, i) => ...
# combineFn: (leftVal, rightVal, leftLeftIdx, leftRightIdx, rightLeftIdx, rightRightIdx) => ...
# applyLazyToValue: (lazyValue, currentValue) => newValue
# combineLazies: (oldLazy, newLazy) => combinedLazy
# tupleNametags: If baseFn returns a tuple, we can supply nametags for each value, like ('min', 'max'), used for debugging

# get max in a range, and add to a range

def baseFn(val):
    return val

def combineFn(leftVal, rightVal):
    return max(leftVal, rightVal)

def applyLazyToVal(lazy, curr):
    return lazy + curr

def combineLazies(a, b):
    return a + b

class LazyPropagationSegmentTree:
    def __init__(self, arr, baseFn, combineFn, applyLazyToValue, combineLazies, tupleNametags=None):
        self.n = len(arr)
        self.arr = arr
        self.tree = [None] * (4 * self.n)
        self.lazy = [None] * (4 * self.n)
        self._combine = combineFn
        self._baseFn = baseFn
        self._applyAggregate = applyLazyToValue
        self._compose = combineLazies
        self.tupleNametags = tupleNametags
        self._build(1, 0, self.n - 1)

    def _build(self, i, tl, tr):
        if tl == tr:
            self.tree[i] = self._baseFn(self.arr[tl])
            return
        tm = (tr + tl) // 2
        self._build(2 * i, tl, tm)
        self._build(2 * i + 1, tm + 1, tr)
        self.tree[i] = self._combine(self.tree[2 * i], self.tree[2 * i + 1])

    def _push(self, i, tl, tr):
        if self.lazy[i] is not None:
            # print(f""Pushing lazy value at node {i} [{tl},{tr}] with lazyValue {self.lazy[i]}"")
            left_child = 2 * i
            right_child = 2 * i + 1
            self.tree[i] = self._applyAggregate(self.lazy[i], self.tree[i])
            if tl != tr:
                if self.lazy[left_child] is None:
                    self.lazy[left_child] = self.lazy[i]
                else:
                    self.lazy[left_child] = self._compose(self.lazy[left_child], self.lazy[i])

                if self.lazy[right_child] is None:
                    self.lazy[right_child] = self.lazy[i]
                else:
                    self.lazy[right_child] = self._compose(self.lazy[right_child], self.lazy[i])

            self.lazy[i] = None

    def _updateRange(self, i, tl, tr, l, r, lazyValue):
        # print(f""Updating range [{l},{r}] with lazyValue {lazyValue} at node {i} [{tl},{tr}]"")
        self._push(i, tl, tr)
        if l > tr or r < tl:
            return  # No overlap
        if l <= tl and tr <= r:
            self.lazy[i] = lazyValue
            self._push(i, tl, tr)
            return
        tm = (tl + tr) // 2
        self._updateRange(2 * i, tl, tm, l, r, lazyValue)
        self._updateRange(2 * i + 1, tm + 1, tr, l, r, lazyValue)
        self.tree[i] = self._combine(self.tree[2 * i], self.tree[2 * i + 1])

    def _queryRecurse(self, i, tl, tr, l, r):
        # print(f""Querying range [{l},{r}] at node {i} [{tl},{tr}]"")
        self._push(i, tl, tr)
        if l > tr or r < tl:
            return None  # No overlap
        if l <= tl and tr <= r:
            # print(f""Fully in bounds, returning node value: {self.tree[i]}"")
            return self.tree[i]
        tm = (tl + tr) // 2
        if l > tm:
            # print(f""Left child [{tl},{tm}] would have no overlap, so only using right"")
            return self._queryRecurse(2 * i + 1, tm + 1, tr, l, r)
        elif r < tm + 1:
            # print(f""Right child [{tm+1},{tr}] would have no overlap, so only using left"")
            return self._queryRecurse(2 * i, tl, tm, l, r)

        leftResult = self._queryRecurse(2 * i, tl, tm, l, r)
        rightResult = self._queryRecurse(2 * i + 1, tm + 1, tr, l, r)
        combinedResult = self._combine(leftResult, rightResult)
        # print(f""Combining results for parent [{tl},{tr}] for query [{l},{r}]: left useful: {leftResult}, right useful: {rightResult} -> combined useful: {combinedResult}"")
        return combinedResult

    def updateRange(self, l, r, lazyValue):
        self._updateRange(1, 0, self.n - 1, l, r, lazyValue)

    def query(self, l, r):
        return self._queryRecurse(1, 0, self.n - 1, l, r)

    def getVal(self, i):
        return self.arr[i]

    def __str__(self):
        result = []
        def _printTree(i, tl, tr, indent):
            if tl == tr:
                result.append(f'{"" "" * indent}{self._getPrintFormattedVal(self.tree[i], tl, tr)}')
                return
            tm = (tl + tr) // 2
            result.append(f'{"" "" * indent}{self._getPrintFormattedVal(self.tree[i], tl, tr)}')
            _printTree(2 * i, tl, tm, indent + 4)
            _printTree(2 * i + 1, tm + 1, tr, indent + 4)
        _printTree(1, 0, self.n - 1, 0)
        return f'{self._line()} SEGMENT TREE VISUALIZATION {self._line()}\n' + ""\n"".join(result)

    def _getPrintFormattedVal(self, val, tl, tr):
        subarray = self.arr[tl:tr + 1]
        prefix = f'[{tl},{tr}] subarray: {subarray} '
        if self.tupleNametags is None:
            if isinstance(val, tuple):
                return prefix + f""({', '.join(str(v) for v in val)})""
            return prefix + str(val)
        return f'{prefix}({"", "".join(f""{tag}: {v}"" for tag, v in zip(self.tupleNametags, val))})'

    def _line(self):
        return '________________________________________'



class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        empty = [0] * len(nums)
        st = LazyPropagationSegmentTree(empty, baseFn, combineFn, applyLazyToVal, combineLazies)
        
        # queries.sort(key=lambda x: (x[0], -x[1])) # earliest first, largest second
        
        # print(f'{queries=}')
        
        res = 0
        
        startsToEnds = defaultdict(list)
        for l, r in queries:
            startsToEnds[l].append(r)
            
        # print(f'starts to ends: {startsToEnds}')
        
        endPool = SortedList() # holds the biggest endings we have from the prior starts
        
        for i in range(len(nums)):
            # print(f'on i={i}')
            # add all the ends to our pool, amortized since we add Q total queries
            for end in startsToEnds[i]:
                endPool.add(end)
            
            # print(f'end pool now: {endPool}')
            
            currVal = st.query(i, i)
            # print(f'current accrued at this index: {currVal}')
            targetVal = nums[i]
            
            incrementsNeededHere = max(0, targetVal - currVal)
            # print(f'increments needed: {incrementsNeededHere}')
            
            # clear out all the invalid endings
            while endPool and endPool[0] < i:
                endPool.pop(0)
            
            if incrementsNeededHere > len(endPool):
                return -1
            
            for _ in range(incrementsNeededHere):
                ending = endPool.pop()
                # print(f'applying range update for {i}:{ending}')
                st.updateRange(i, ending, 1)
                res += 1
            # now apply the biggest X queries, amortized since we can only apply so much
        
        return len(queries) - res
            
            
        
        
        ",1460886976
leetgoat_dot_dev,leetgoat_dot_dev,101,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        
#         ------>               |
#         |                  <  v  >
#         |  \
#         |   x
#         v
        
        
#          x
#         /
#         --->
#         \
#          \
#           \
#            x

        n = len(fruits)
        # TODO: duplicate goal counting
        
        greenScore = sum(fruits[r][r] for r in range(n))

        @cache
        def bottom(r, c):
            if c == n - 1:
                return 0 if r == n - 1 else -inf # green always takes bottom right
            
            gainable = fruits[r][c] if r != c else 0
            goUp = (gainable + bottom(r - 1, c + 1)) if r > 0 else -inf
            goRight = gainable + bottom(r, c + 1)
            goDown = gainable + bottom(r + 1, c + 1) if r < n - 1 else -inf
            return max(goUp, goRight, goDown)
        
        @cache
        def topRight(r, c):
            if r == n - 1:
                return 0 if c == n - 1 else -inf
            
            gainable = fruits[r][c] if r != c else 0
            
            goDl = (gainable + topRight(r + 1, c - 1)) if c > 0 else -inf
            goDown = gainable + topRight(r + 1, c)
            goDr = (gainable + topRight(r + 1, c + 1)) if c < n - 1 else -inf
            return max(goDl, goDown, goDr)
        
        ans = greenScore + bottom(n - 1, 0) + topRight(0, n - 1)
        bottom.cache_clear()
        topRight.cache_clear()
        return ans
            
        
            
            # \ X X X X
            # X \ X X X
            # X X \ X X
            # X X X \ X
            # X X X X \

        
        
        
        
        
        ",1460849147
czjnbb,czjnbb,103,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        res = 0
        lens = len(s)
                
        
        for i in range(lens):
            c1 = ord(s[i]) - 97
            c2 = ord(t[i]) - 97
            if c1 == c2:
                continue
            if c1 > c2:
                res += min(sum(previousCost[c2+1:c1+1]), sum(nextCost[c1:]) + sum(nextCost[:c2]))
            else:
                res += min(sum(nextCost[c1:c2]), sum(previousCost[c2+1:]) + sum(previousCost[:c1+1]))
        
        return res
            
            ",1460811114
czjnbb,czjnbb,103,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        
        for i in range(10, 0, -1):
            if n >= i:
                n -= i
            else:
                return i % 2 == 1",1460796536
czjnbb,czjnbb,103,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        
        leng = len(nums)
        queries.sort()
        len2 = len(queries)
        
        hq = []
        
        sw = defaultdict(int)
        cur = 0
        use = 0
                        
        for i,n in enumerate(nums):
            
            if i in sw:
                cur += sw[i]
                                
            while queries and queries[0][0] <= i:
                l, r = queries.pop(0)
                heapq.heappush(hq, -r)
                
            while hq and hq[0] + i > 0:
                heapq.heappop(hq)
                
            # print(hq, cur)
                
            if n <= cur:
                continue
                
            while hq and hq[0] + i <= 0:
                r = -heapq.heappop(hq)
                cur += 1
                use += 1
                    
                sw[r+1] -= 1
                if cur == n:
                    break
                    
            if cur < n:
                return -1
            
        # print(queries, sw)
            
        return len2 - use
                
                
            ",1460876537
czjnbb,czjnbb,103,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        
        leng = len(fruits)
        res = 0
        
        dir1 = [(0,1),(-1,1),(1,1)]
        dir2 = [(1,0),(1,-1),(1,1)]
        
        for i in range(leng):
            res += fruits[i][i]
            fruits[i][i] = 0
        
        #left lower
        d = {}
        d[leng-1] = fruits[leng-1][0]
            
        for i in range(1, leng):
            tmp = defaultdict(int)
            for k,v in d.items():
                for dirs in [-1,0,1]:
                    nk = k + dirs
                    if nk > leng - 1:
                        continue
                    nv = v + fruits[i][nk]
                    if nk not in tmp or tmp[nk] < nv:
                        tmp[nk] = nv
            d = tmp
            
        res += d[leng - 1]
        
        
        # right upper
        d = {}
        d[leng-1] = fruits[0][leng-1]
            
        for i in range(1, leng):
            tmp = defaultdict(int)
            for k,v in d.items():
                for dirs in [-1,0,1]:
                    nk = k + dirs
                    if nk > leng - 1:
                        continue
                    nv = v + fruits[nk][i]
                    if nk not in tmp or tmp[nk] < nv:
                        tmp[nk] = nv
            d = tmp
            
        res += d[leng - 1]
        
        return res
        
                        
            
            
        ",1460836406
IsaacHuang,IsaacHuang,104,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        int cost = 0;
        vector<vector<long long>> nextCosts(26, vector<long long>(26, 0));
        vector<vector<long long>> prevCosts(26, vector<long long>(26, 0));
        for(int dist = 0; dist < 25; dist ++){
            for(int i = 0; i < 26; i++){
                nextCosts[i][(i+dist+1)% 26] = nextCosts[i][(i+dist)%26] + nextCost[(i+dist)%26];
            }
        }
        for(int dist = 0; dist < 25; dist ++){
            for(int i = 0; i < 26; i++){
                prevCosts[i][(i-dist+25)% 26] = prevCosts[i][(i-dist+26)%26] + previousCost[(i-dist+26)%26];
            }
        }
        long long sumCost = 0;
        for(int i = 0; i < n; i++){
            sumCost += min(nextCosts[s[i]-'a'][t[i]-'a'], prevCosts[s[i]-'a'][t[i]-'a']);
        }
        return sumCost;
    }
};",1460813502
IsaacHuang,IsaacHuang,104,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n, int k = 10) {
        if(n < k) return false;
        return !canAliceWin(n - k, k - 1);
    }
};",1460797205
IsaacHuang,IsaacHuang,104,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), qSize = queries.size();
        sort(queries.begin(), queries.end(), [](const auto& q1, const auto& q2){
                if(q1[0] != q2[0]) return q1[0] < q2[0];
                return q1[1] > q2[1];
            }
        );
        int selectedCount = 0, queryIdx = 0;
        int notUsedCount = 0;
        priority_queue<int> endChooses;
        priority_queue<int, vector<int>, greater<int>> realEnds;
        int chooseNum = 0;
        for(int i = 0; i < n; i++){
            while(realEnds.size() > 0 && realEnds.top() < i) realEnds.pop();
            while(queryIdx < qSize && queries[queryIdx][0] == i){
                endChooses.push(queries[queryIdx][1]);
                queryIdx ++;
            }
            while(endChooses.size() > 0 && realEnds.size() < nums[i]){
                int endTop = endChooses.top();
                endChooses.pop();
                if(endTop < i){
                    notUsedCount++;
                    continue;
                }
                realEnds.push(endTop);
            }
            if(realEnds.size() < nums[i]) return -1;
        }
        return notUsedCount + endChooses.size();
    }
};",1460888363
IsaacHuang,IsaacHuang,104,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        if(n == 1) return fruits[0][0];
        if(n == 2){
            return fruits[0][1] + fruits[1][0] + fruits[0][0] + fruits[1][1];
        }
        int diagonalFruits = 0;
        for(int i = 0; i < n; i++) diagonalFruits += fruits[i][i];
        vector<vector<long long>> dp1(n, vector<long long>(n));
        dp1[0][n-1] = fruits[0][n-1];
        for(int i = 1; i < n; i++){
            for(int j = n-1; i + j >= n-1 && i - j < 0; j--){
                long long lastFruit = dp1[i-1][j];
                if(j != n-1) lastFruit = max(lastFruit, dp1[i-1][j+1]);
                if(j != 0) lastFruit = max(lastFruit, dp1[i-1][j-1]);
                dp1[i][j] = lastFruit + fruits[i][j];
            }
        }
        // for(int i = 0; i < n; i++){
        //     for(int j = 0; j < n; j++){
        //         printf(""%lld "", dp1[i][j]);
        //     }
        //     printf(""\n"");
        // }
        // printf(""\n"");
        vector<vector<long long>> dp2(n, vector<long long>(n));
        dp2[n-1][0] = fruits[n-1][0];
        for(int j = 1; j < n; j++){
            for(int i = n-1; i + j >= n-1 && i - j > 0; i--){
                long long lastFruit = dp2[i][j-1];
                if(i != n-1) lastFruit = max(lastFruit, dp2[i+1][j-1]);
                if(i != 0) lastFruit = max(lastFruit, dp2[i-1][j-1]);
                dp2[i][j] = lastFruit + fruits[i][j];
            }
        }
        
        // for(int i = 0; i < n; i++){
        //     for(int j = 0; j < n; j++){
        //         printf(""%lld "", dp2[i][j]);
        //     }
        //     printf(""\n"");
        // }
        // printf(""%lld"", diagonalFruits);
        return diagonalFruits + dp1[n-2][n-1] + dp2[n-1][n-2];
    }
};",1460839784
jo7p,jo7p,105,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        #define ll long long
        int n = s.size();
        ll ans = 0;
        for(int i=0; i<n; i++){
            if(s[i] == t[i]) continue;
            ll x = 0;
            char c = s[i];
            while(c != t[i]){
                x += nc[c - 'a'];
                c++;
                if(c > 'z') c = 'a';
            }
            ll xx = 0;
            c = s[i];
            while(c != t[i]){
                xx += pc[c - 'a'];
                c--;
                if(c < 'a') c = 'z';
            }
            ans += min(x, xx);
        }
        return ans;
    }
};",1460806660
jo7p,jo7p,105,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10; i>=1; i--){
            if(n >= i){
                n -= i;
                continue;
            }
            return i & 1;
        }
        return 0;
    }
};",1460797362
jo7p,jo7p,105,3647,cpp,"#define ll long long
const int N = 1e5 + 5;
const int inf = 1e9 + 5;
struct SegTree{
    struct node{
        int lz, val;
    };

    node t[N<<2];
    #define ls(x) (x<<1)
    #define rs(x) (x<<1|1)

    void pushup(int id, int l, int r){
        t[id].val = min(t[ls(id)].val, t[rs(id)].val);
    }

    void pushdown(int id, int l, int r){
        // 0,1
        if(l >= r || !t[id].lz) return;
       
        t[ls(id)].lz += t[id].lz;
        t[rs(id)].lz += t[id].lz;
        t[ls(id)].val += t[id].lz;
        t[rs(id)].val += t[id].lz;
        t[id].lz = 0;
    }

    void build(int id, int l, int r, vector<int> &a){
        t[id].lz = 0;
        if(l == r){
            t[id].val = a[l-1];
            return;
        }
        int mid = (l+r)>>1;
        build(ls(id), l, mid, a);
        build(rs(id), mid+1, r, a);
        pushup(id, l, r);
    }

    void update(int id, int l, int r, int ql, int qr, int val){
        if(ql <= l && r <= qr){
            t[id].lz += val;
            t[id].val += val;
            return;
        }
        pushdown(id, l, r);
        int mid = (l+r)>>1;
        if(mid >= ql) update(ls(id), l, mid, ql, qr, val);
        if(mid < qr) update(rs(id), mid+1, r, ql, qr, val);
        pushup(id, l, r);
    }

    int query(int id, int l, int r, int ql, int qr){
        if(ql <= l && r <= qr) return t[id].val;
        pushdown(id, l, r);
        int mid = (l+r)>>1;
        int res = inf;
        if(mid >= ql) res = query(ls(id), l, mid, ql, qr);
        if(mid < qr) res = min(res, query(rs(id), mid+1, r, ql, qr));
        return res;
    }
    
    #undef ls
    #undef rs
} sgt;

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        #define pii pair<int, int>
        #define F first
        #define S second
        int n = a.size(), m = q.size();
        int ma = *max_element(a.begin(), a.end());
        if(ma > q.size()) return -1;
        vector<int> b(n+1);
        vector<pii> t;
        for(auto it : q){
            int x = it[0], y = it[1];
            b[x]++;
            b[y+1]--;
            t.push_back({x, y});
        }
        for(int i=1; i<n; i++) b[i] += b[i-1];
        for(int i=0; i<n; i++){
            a[i] = b[i] - a[i];
            if(a[i] < 0) return -1;
        }
        // for(auto x : a) cout << x << "" "";
        // cout << endl;
        
        sort(t.begin(), t.end(), [&](auto x, auto y){
            return x.S - x.F == y.S - y.F ? x.F < y.F : x.S - x.F < y.S - y.F;
        });
        
        sgt.build(1, 1, n, a);
        
        auto Print = [&](){
            for(int i=1; i<=n; i++) cout << sgt.query(1, 1, n, i, i) << "" "";
            cout << endl;
        };
        
        // for(auto [p, q] : t) cout << p << "" "" << q << endl;
        int ans = 0;
        // Print();
        for(auto [p, q] : t){
            if(sgt.query(1, 1, n, p+1, q+1) >= 1){
                sgt.update(1, 1 ,n, p+1, q+1, -1);
                ans++;
            }
            // Print();
        }
        
        return ans;
        
    }
};",1460863791
jo7p,jo7p,105,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = a.size();
        if(n == 2){
            return a[0][0] + a[0][1] + a[1][0] + a[1][1];
        }
        vector<vector<int>> b(n, vector<int>(n));
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(i - j < 0 && i + j >= n - 1){
                    b[i][j] = 1;
                }
                if(i - j > 0 && i + j >= n - 1){
                    b[i][j] = 2;
                }
            }
        }
        auto dp = a;
        for(int i=0; i<n-1; i++){
            for(int j=0; j<n; j++){
                if(b[i][j] == 1){
                    for(int k=-1; k<=1; k++){
                        if(j + k >= 0 && j + k < n && b[i+1][j+k] == 1){
                            dp[i+1][j+k] = max(dp[i+1][j+k], dp[i][j] + a[i+1][j+k]);
                        }
                    }
                }
            }
        }
        
        for(int j=0; j<n-1; j++){
            for(int i=n-1; i>=0; i--){
                if(b[i][j] == 2){
                    for(int k=-1; k<=1; k++){
                        if(i + k >= 0 && i + k < n && b[i+k][j+1] == 2){
                            dp[i+k][j+1] = max(dp[i+k][j+1], dp[i][j] + a[i+k][j+1]);
                        }
                    }
                }
            }
        }
        
        for(int i=0; i<n-1; i++){
            dp[i+1][i+1] += dp[i][i];
        }
        
//         for(int i=0; i<n; i++){
//             for(int j=0; j<n; j++){
//                 cout << b[i][j] << "" "";
//             }
//             cout << endl;
//         }
        
//         for(int i=0; i<n; i++){
//             for(int j=0; j<n; j++){
//                 cout << dp[i][j] << "" "";
//             }
//             cout << endl;
//         }
        
        int ans = dp[n-1][n-1] + dp[n-1][n-2] + dp[n-2][n-1];
        return ans;
    }
};",1460894497
jerry5841314,jerry5841314,106,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long total = 0;
        for (int i = 0; i < n; i++){
            total += min(shiftLeft(s[i], t[i], nextCost, previousCost), shiftRight(s[i], t[i], nextCost, previousCost));
        }
        return total;
    }
    long long shiftLeft(char c1, char c2, vector<int>& nextCost, vector<int>& previousCost){
        c1 -= 'a', c2 -= 'a';
        long long total = 0;
        while (c1 != c2){
            total += previousCost[c1];
            c1--;
            if (c1 < 0)
                c1 += 26;
        }
        return total;
    }
    long long shiftRight(char c1, char c2, vector<int>& nextCost, vector<int>& previousCost){
        c1 -= 'a', c2 -= 'a';
        long long total = 0;
        while (c1 != c2){
            total += nextCost[c1];
            c1++;
            c1 %= 26;
        }
        return total;
    }
};",1460825681
jerry5841314,jerry5841314,106,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10, turn = 0;
        while (n >= cnt && n){
            n -= cnt;
            cnt--;
            turn = (turn + 1) % 2;
        }
        return (turn == 1)? true : false;
    }
};",1460811495
jerry5841314,jerry5841314,106,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        priority_queue<int> pq;
        priority_queue<int, vector<int>, greater<>> num;
        int ans = 0;
        int n = nums.size();
        int j = 0;
        for (int i = 0; i < n; i++){
            while (j < queries.size() && queries[j][0] == i){
                pq.push(queries[j][1]);
                j++;
            }
            nums[i] -= num.size();
            while (nums[i] > 0 && !pq.empty() && pq.top() >= i){
                ans++;
                num.push(pq.top());
                pq.pop();
                nums[i]--;
            } 
            if (nums[i] > 0)
                return -1;
            while (!num.empty() && num.top() == i)
                num.pop();
            
        }
        return queries.size() - ans;
        
    }
};",1460847077
jerry5841314,jerry5841314,106,3648,cpp,"class Solution {
public:
    int n;
    vector<vector<int>> fruits;
    int dp1[1001][1001], dp2[1001][1001];
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        n = fruits.size();
        this->fruits = fruits;
        int total = 0;
        for (int i = 0; i < n; i++){
            total += fruits[i][i];
            // cout << total << '\n';
            // fruits[i][i] = 0;
        }
        cout << total << '\n';
        memset(dp1, -1, sizeof(dp1));
        memset(dp2, -1, sizeof(dp2));
        total += find1(n - 1, 0);
        // cout << find1(n - 1, 0) << '\n';
        int ret = find2(0, n - 1);
        total += ret;
        // cout << ret;
        return total;
    }
    int find1(int i, int j){
        
        if (i == n - 1 && j == n - 1)
            return 0;
        if (j >= i)
            return 0;
        if (dp1[i][j] != -1)
            return dp1[i][j];
        int maxV = 0;
        int total = fruits[i][j];
        if (i - 1 >= 0)
            maxV = max(maxV, total + find1(i - 1, j + 1));
        maxV = max(maxV, total + find1(i, j + 1));
        if (i + 1 < n)
            maxV = max(maxV, total + find1(i + 1, j + 1));
        dp1[i][j] = maxV;
        return maxV;
    }
    int find2(int i, int j){
        
        if (i == n - 1 && j == n - 1)
            return 0;
        if (i >= j)
            return 0;
        if (dp2[i][j] != -1)
            return dp2[i][j];
        int maxV = 0;
        int total = fruits[i][j];
        if (j - 1 >= 0)
            maxV = max(maxV, total + find2(i + 1, j - 1));
        maxV = max(maxV, total + find2(i + 1, j));
        if (j + 1 < n)
            maxV = max(maxV, total + find2(i + 1, j + 1));
        // cout << i << "" "" << j << "" "" << maxV << '\n'; 
        dp2[i][j] = maxV;
        return maxV;
    }
};",1460888889
dirigibility,dirigibility,107,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nacc = list(accumulate(nextCost*2,initial=0))
        pacc = list(accumulate(previousCost*2))
        total = 0
        for c,d in zip(s,t):
            x,y = ord(c)-ord('a'),ord(d)-ord('a')
            if x < y:
                total += min(nacc[y]-nacc[x],pacc[x+26]-pacc[y])
            else:
                total += min(nacc[y+26]-nacc[x],pacc[x]-pacc[y])
        return total",1460857539
dirigibility,dirigibility,107,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        k = 10
        a = False
        while n >= k:
            n -= k
            k -= 1
            a = not a
        return a",1460796210
dirigibility,dirigibility,107,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        avail = []
        active = []
        used = k = 0
        for i,n in enumerate(nums):
            while k < len(queries) and queries[k][0] == i:
                heappush(avail,-queries[k][1])
                k += 1
            while active and active[0] < i:
                heappop(active)
            while len(active) < n:
                if avail and -avail[0] >= i:
                    heappush(active,-heappop(avail))
                    used += 1
                else:
                    return -1
        return len(queries)-used",1460871724
dirigibility,dirigibility,107,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        s = sum(fruits[i][i] for i in range(n))
        for j in reversed(range(n-2)):
            for i in range(j+1,n):
                fruits[i][j] += max(fruits[i+di][j+1] for di in range(-1,2) if j+1 < i+di < n)
        for i in reversed(range(n-2)):
            for j in range(i+1,n):
                fruits[i][j] += max(fruits[i+1][j+dj] for dj in range(-1,2) if i+1 < j+dj < n)
        return s+fruits[0][-1]+fruits[-1][0]",1460889308
Sai nadh,sainadhsn,109,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for(int i=0; i<n; i++){
            int j1 = s[i] - 'a';
            int j2 = t[i] - 'a';
            long long c1 = 0, c2 = 0;
            int k1 = j1, k2 = j2;
            while(k1 != k2){
                c1+=nextCost[k1];
                k1++; k1%=26;
            }
            while(j1!=j2){
                c2 += previousCost[j1];
                j1--; j1 = (j1 + 26)%26;
            }
            ans += min(c1, c2);
        }
        return ans;
    }
};",1460814092
Sai nadh,sainadhsn,109,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool f = 0;
        int cur = 10;
        while(n >= cur){
            n -= cur;
            cur--;
            f^=1;
        }
        return f;
    }
};",1460800733
Sai nadh,sainadhsn,109,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& queries) {
        int n = a.size();
        vector<long long> b(n+1, 0);
        multiset<long long> s;
        vector<vector<int>> rs(n);
        int cnt = queries.size();
        for(auto v: queries) rs[v[0]].push_back(v[1]);
        for(int i=0; i<n; i++){
            if(i) b[i] += b[i-1];
            for(auto r: rs[i]) s.insert(r);
            while(!s.empty() and *s.begin() < i) s.erase(s.begin());
            while(!s.empty() and b[i] < a[i]){
                b[i]++;
                b[(*--s.end()) + 1]--;
                s.erase(--s.end());
                cnt--;
            }
            if(b[i] < a[i]) return -1;
        }
        return cnt;
    }
};",1460837027
Sai nadh,sainadhsn,109,3648,cpp,"class Solution {
public:
    const int INF = 1e9;
    int dp[1000][1000];
    int fun1(int i, int j, vector<vector<int>> &a){
        if(i < 0 or j<0 or i>= int(a.size()) or j>= int(a.size())) return 0;
        if(i == j) return 0;
        if(i> j) return -INF;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = a[i][j] + max({-INF, fun1(i+1, j, a), fun1(i+1, j-1, a), fun1(i+1, j+1, a)});
        if(ans < 0) ans = -INF;
        return dp[i][j] = ans;
    }
    int fun2(int i, int j, vector<vector<int>> &a){
        if(i < 0 or j<0 or i>= int(a.size()) or j>= int(a.size())) return 0;
        if(i == j) return 0;
        if(i < j) return -INF;
        if(dp[i][j] != -1) return dp[i][j];
        int ans = a[i][j] + max({-INF, fun2(i-1, j+1,a), fun2(i, j+1,a), fun2(i+1, j+1,a)});
        if(ans < 0) ans = -INF;
        return dp[i][j] = ans;
    }
    int maxCollectedFruits(vector<vector<int>>& a) {
        int ans = 0;
        int n = a.size();
        for(int i=0; i<n; i++) ans += a[i][i];
        memset(dp, -1, sizeof(dp));
        ans += fun1(0, n-1, a);
        memset(dp, -1, sizeof(dp));
        ans += fun2(n-1, 0, a);
        return ans;
    }
};",1460871873
Skyler Tsai,SkylerTsai,110,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        ldp, rdp = {}, {}
        for i in range(26):
            for j in range(26):
                temp, idx = 0, i
                while idx % 26 != j: 
                    temp += nextCost[idx % 26]
                    idx += 1
                ldp[(i, j)] = temp
                temp, idx = 0, i
                while (idx + 26) % 26 != j:
                    temp += previousCost[(idx + 26) % 26]
                    idx -= 1
                rdp[(i, j)] = temp
            
        n, ret = len(s), 0
        for i in range(n):
            x, y = ord(s[i]) - ord('a'), ord(t[i]) - ord('a')
            #print(ldp[(x, y)], rdp[(x, y)])
            ret += min(ldp[(x, y)], rdp[(x, y)])
        return ret
            
                ",1460847533
Skyler Tsai,SkylerTsai,110,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        turn, val = False, 10
        while n >= val:
            n -= val
            val -= 1
            turn = not turn
        return turn
        ",1460798380
Skyler Tsai,SkylerTsai,110,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort(key = lambda x: (x[0], -x[1]))
        n, m = len(nums), len(queries)
        qidx = 0
        rdq, hq = [], []
        ret = m
        for i in range(n):
            while qidx < m and queries[qidx][0] <= i:
                heappush(rdq, -queries[qidx][1])
                qidx += 1
                
            while hq and hq[0] < i: heappop(hq)
            while len(hq) < nums[i] and rdq:
                x = -heappop(rdq)
                if x >= i: 
                    heappush(hq, x)
                    ret -= 1
            if len(hq) < nums[i]: return -1
        return ret
            ",1460862452
Skyler Tsai,SkylerTsai,110,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n, ret = len(fruits), 0
        for i in range(n): 
            ret += fruits[i][i]
            
        dp = [[-1] * n for _ in range(n)]
        dp[0][n - 1] = fruits[0][n - 1]
        for i in range(1, n - 1):
            for j in range(i + 1, n):
                if dp[i - 1][j - 1] != -1: 
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j])
                if dp[i - 1][j] != -1:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + fruits[i][j])
                if j + 1 < n and dp[i - 1][j + 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + fruits[i][j])
        dp[n - 1][0] = fruits[n - 1][0]
        for j in range(1, n - 1):
            for i in range(j + 1, n):
                if dp[i - 1][j - 1] != -1: 
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + fruits[i][j])
                if dp[i][j - 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + fruits[i][j])
                if i + 1 < n and dp[i + 1][j - 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + fruits[i][j])
        #print(ret, dp[n - 2][n - 1], dp[n - 1][n - 2])
        return ret + dp[n - 2][n - 1] + dp[n - 1][n - 2]",1460889838
ape_pack,ape_pack,111,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size(); 
        long long ans = 0; 

        // vector<long long> nextpref(n+1,0), prevpref(n+1,0); 
        // long long nextsum = 0, prevsum = 0; 
        // for (int i = 1; i < n; i++) {
            
        // }
        
        for (int i = 0; i < n; i++) {
            int a = s[i]-'a', b =t[i]-'a'; 
            long long forward = 0, backward = 0; 
            while (a != b) {
                forward += nextCost[a]; 
                a++; a%=26; 
            }
            a=s[i]-'a'; 
            while (a != b) {
                backward += previousCost[a]; 
                a--; 
                if (a == -1) a = 25; 
            }
            ans += min(forward,backward);
        }
        return ans; 
    }
};",1460813104
ape_pack,ape_pack,111,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0; 
        int cnt = 10; 
        while (true) {
            if (n < cnt) return (1-turn)==0; 
            n -= cnt; 
            cnt--; 
            turn = 1-turn; 
        }
    }
};",1460797432
ape_pack,ape_pack,111,3647,cpp,"class Solution {
public:
typedef pair<int,int> pii; 
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        // min queries needed 
        vector<pii> q; 
        for (auto& x:queries) {
            q.push_back(make_pair(x[0],x[1])); 
        }
        sort(q.begin(), q.end());

        int n = nums.size(); 
        multiset<int> active_end; 
        int cum = 0; 
        vector<int> diff(n+1,0); // 0 indexed 

        int q_idx = 0; 
        int ans = 0; 
        
        for (int i = 0; i < n; i++) {
            int x = abs(nums[i]);
            cum += diff[i]; 
            x -= cum; 
            
            // intervals that start at i become active 
            while (q_idx < q.size() && q[q_idx].first == i) {
                active_end.insert(q[q_idx].second); 
                q_idx++; 
            }
            while (active_end.size() && *active_end.begin() < i) {
                active_end.erase(active_end.begin());
            }

            if (x <= 0) continue; 
            if (x > active_end.size()) return -1; 

            // remove x largest values from active_end 
            for (int j = 0; j < x; j++) {
                int tmp = *active_end.rbegin(); 
                diff[tmp+1]--;
                cum ++ ; // starts somewhere earlier 
                active_end.erase(prev(active_end.end()));
                ans++; 
            }

        }

        return q.size()-ans; 
    }
};",1460895570
ape_pack,ape_pack,111,3648,cpp,"class Solution {
public:

    vector<vector<int>> dp, a; 
    int n; 
    int f(int x, int y) {
        if (y >= n) return 0; 
        if (x >= y) return 0; 
        if (dp[x][y] != -1) return dp[x][y]; 
        return dp[x][y] = max(f(x+1,y-1), max(f(x+1,y),f(x+1,y+1))) + a[x][y]; 
    }

    int g(int x, int y) {
        if (x >= n) return 0; 
        if (x <= y) return 0; 
        if (dp[x][y] != -1) return dp[x][y]; 
        return dp[x][y] = max(g(x-1,y+1), max(g(x,y+1),g(x+1,y+1))) + a[x][y]; 
    }

    int maxCollectedFruits(vector<vector<int>>& fruits) {
        // obs: top left guy must move only on diagonal 
        // cor: top right and bottom left guy cannot cross diagonal 
        n = fruits.size(); 
        a = fruits; 
        int ans = 0; 
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i]; 
        }

        dp.assign(n,vector<int>(n,-1)); 
        dp[n-1][n-1] = fruits[n-1][n-1];
        ans +=f(0,n-1);

        dp.assign(n,vector<int>(n,-1)); 
        dp[n-1][n-1] = fruits[n-1][n-1];
        ans += g(n-1,0); 

        return ans; 
    }
};",1460861944
fxfxxxfxx,fxfxxxfxx,116,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        auto R = [&](int x, int y) {
            x -= 'a'; y -= 'a';
            int64_t ret = 0;
            while (x != y) {
                ret += nextCost[x];
                x = (x + 1) % 26;
            }
            return ret;
        };
        auto L = [&](int x, int y) {
            x -= 'a'; y -= 'a';
            int64_t ret = 0;
            while (x != y) {
                ret += previousCost[x];
                x = (x - 1 + 26) % 26;
            }
            return ret;
        };
        int n = s.size();
        int64_t ans = 0;
        for (int i = 0; i < n; i++) {
            ans += min(R(s[i], t[i]), L(s[i], t[i]));
        }
        return ans;
    }
};",1460813315
fxfxxxfxx,fxfxxxfxx,116,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool isA = true;
        int k = 10;
        while (n >= k) {
            n -= k;
            k -= 1;
            isA = !isA;
        }
        return !isA;
    }
};",1460796772
fxfxxxfxx,fxfxxxfxx,116,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& Q) {
        sort(Q.begin(), Q.end());
        int n = nums.size(), m = Q.size();
        multiset<int> E, P;
        int ptr = 0, n_pick = 0;
        for (int i = 0; i < n; i++) {
            while (ptr < m && Q[ptr][0] <= i) {
                E.insert(Q[ptr][1]);
                ptr += 1;
            }
            int k = nums[i] - P.size();
            for (int j = 0; j < k; j++) {
                if (E.empty()) return -1;
                P.insert(*prev(E.end()));
                E.erase(prev(E.end()));
                n_pick += 1;
            }
            E.erase(i);
            P.erase(i);
        }
        return m - n_pick;
    }
};",1460836973
fxfxxxfxx,fxfxxxfxx,116,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& M) {
        int n = M.size();
        vector<vector<int>> F(n+1, vector<int>(n+1));
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                F[i][j] = M[i][j];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += F[i][i];
            F[i][i] = 0;
        }
        for (int i = 1; i < n-1; i++)
            F[0][i] = -1;
        for (int i = 1; i < n-1; i++)
            F[i][0] = -1;
        for (int r = 1; r < n; r++)
            for (int c = r+1; c < n; c++) {
                auto add = max({F[r-1][c-1], F[r-1][c], F[r-1][c+1]});
                if (add == -1) F[r][c] = -1;
                else F[r][c] += add;
            }
        for (int c = 1; c < n; c++)
            for (int r = c+1; r < n; r++) {
                auto add = max({F[r-1][c-1], F[r][c-1], F[r+1][c-1]});
                if (add == -1) F[r][c] = -1;
                else F[r][c] += add;
            }
        ans += F[n-2][n-1] + F[n-1][n-2];
        return ans;
    }
};",1460886492
Ryan,ryanwong0127,117,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        INF = float('inf')
        dist = [[INF] * 26 for _ in range(26)]
        for i in range(26):
            dist[i][i] = 0  
            next_i = (i + 1) % 26
            dist[i][next_i] = min(dist[i][next_i], nextCost[i])
            prev_i = (i - 1 + 26) % 26
            dist[i][prev_i] = min(dist[i][prev_i], previousCost[i])

        for k in range(26):
            for i in range(26):
                for j in range(26):
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]

        res = 0
        for cs, ct in zip(s, t):
            if cs == ct:
                continue
            c1 = ord(cs) - ord('a')
            c2 = ord(ct) - ord('a')
            res += dist[c1][c2]

        return res",1460803358
Ryan,ryanwong0127,117,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        x = n
        y = 10
        curr = 'Alice'

        while True:
            if x >= y:
                x -= y
                y -= 1
                curr = 'Bob' if curr == 'Alice' else 'Alice'
            else:
                if curr == 'Alice':
                    return False
                else:
                    return True",1460797284
Ryan,ryanwong0127,117,3647,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
struct SegmentTree {
    int n;
    vector<long long> tree;
    vector<long long> lazy;

    SegmentTree(vector<long long> &data) {
        n = 1;
        while (n < data.size()) n <<= 1;
        tree.assign(2 * n, 0LL);
        lazy.assign(2 * n, 0LL);
        // 
        for(int i = 0; i < data.size(); i++) {
            tree[n + i] = data[i];
        }
        // 
        for(int i = n - 1; i >= 1; i--) {
            tree[i] = min(tree[2*i], tree[2*i+1]);
        }
    }

    // 
    void push(int node) {
        if(lazy[node] != 0) {
            tree[2*node] += lazy[node];
            tree[2*node+1] += lazy[node];
            lazy[2*node] += lazy[node];
            lazy[2*node+1] += lazy[node];
            lazy[node] = 0;
        }
    }

    // 
    void range_add(int l, int r, long long val, int node, int node_l, int node_r) {
        if(r <= node_l || node_r <= l) return;
        if(l <= node_l && node_r <= r) {
            tree[node] += val;
            lazy[node] += val;
            return;
        }
        push(node);
        int mid = (node_l + node_r) / 2;
        range_add(l, r, val, 2*node, node_l, mid);
        range_add(l, r, val, 2*node+1, mid, node_r);
        tree[node] = min(tree[2*node], tree[2*node+1]);
    }

    void add(int l, int r, long long val) {
        range_add(l, r, val, 1, 0, n);
    }

    // 
    long long range_min(int l, int r, int node, int node_l, int node_r) {
        if(r <= node_l || node_r <= l) return LLONG_MAX;
        if(l <= node_l && node_r <= r) return tree[node];
        push(node);
        int mid = (node_l + node_r) / 2;
        return min(range_min(l, r, 2*node, node_l, mid),
                   range_min(l, r, 2*node+1, mid, node_r));
    }

    long long query_min(int l, int r) {
        return range_min(l, r, 1, 0, n);
    }
};
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        const int n = nums.size(), m = queries.size();
        vi count(n+1, 0);
        for(auto &q : queries) {
            int l = q[0];
            int r = q[1];
            count[l] += 1;
            if(r + 1 < n) count[r + 1] -= 1;
        }
        for(int i = 1; i < n; i++) {
            count[i] += count[i-1];
        }

        vll d(n, 0);
        rep(i, 0, n) {
            d[i] = (ll)count[i] - (ll)nums[i];
            if(d[i] < 0) return -1;
        }

        SegmentTree st(d);

        sort(queries.begin(), queries.end(), [&](const vi &a, const vi &b) -> bool{
            if(a[1] != b[1]) return a[1] < b[1];
            return a[0] < b[0];
        });

        ll res = 0;
        for(auto &q : queries) {
            int l = q[0];
            int r = q[1];
            ll min_d = st.query_min(l, r + 1);
            if(min_d >= 1) {
                res += 1;
                st.add(l, r + 1, -1);
            }
        }

        return res;
    }
};",1460820773
Ryan,ryanwong0127,117,3648,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        const int n = fruits.size();
        ll sum1 = 0;
        for(int i=0;i<n;i++) {
            sum1 += (ll)fruits[i][i];
        }

        // Step 2: Compute sum2 (second kid's path)
        // Initialize DP arrays
        int prev_leftmost = n-1;
        vvi dp2(n, vi(n, -inf));
        dp2[0][n-1] = fruits[0][n-1];
        rep(i, 1, n) {
            int cur_leftmost = n - 1 - i;
            if (i + 1 > n / 2 ) {
                cur_leftmost = min(i+1, n -1);
            }
            printf(""for i=%d : [%d, %d]\n"",i,cur_leftmost, n-1);
            rep(j, cur_leftmost, n) {
                if (j-1 >= prev_leftmost)
                    chmax(dp2[i][j], dp2[i-1][j-1]+fruits[i][j]);
                chmax(dp2[i][j], dp2[i-1][j]+fruits[i][j]);
                if (j+1<n)
                    chmax(dp2[i][j], dp2[i-1][j+1]+fruits[i][j]);
            }
            prev_leftmost = cur_leftmost;
        }

        ll sum2 = dp2[n-1][n - 1] - fruits[n-1][n - 1];

        // Step 3: Compute sum3 (third kid's path)
        
        int prev_upmost = n-1;
        vvi dp3(n, vi(n, -inf));
        dp3[n-1][0] = fruits[n-1][0];
        rep(j, 1, n) {
            int cur_upmost = n - 1 - j;
            if (j + 1 > n / 2) {
                cur_upmost = min(j+1, n -1);
            }
            rep(i, cur_upmost, n) {
                if (i-1 >= prev_upmost)
                    chmax(dp3[i][j], dp3[i-1][j-1]+fruits[i][j]);
                chmax(dp3[i][j], dp3[i][j-1]+fruits[i][j]);
                if (i+1<n)
                    chmax(dp3[i][j], dp3[i+1][j-1]+fruits[i][j]);
            }
            prev_upmost = cur_upmost;
        }

        ll sum3 = dp3[n-1][n - 1] - fruits[n-1][n - 1];
        // cout<<sum1<<"",""<<sum2<<endl;
        // Step 4: Compute total fruits collected, adjusting for overlapping at (n-1,n-1)
        ll total = sum1 + sum2 + sum3;
        return total;
    }
private:
};",1460892862
nnv-nick,nnv-nick,118,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; ++i) {
            char c, p;
            long long res = 10000000000000;
            long long sum;
            c = s[i];
            p = t[i];
            sum = 0;
            while (c != p) {
                sum += nextCost[c - 'a'];
                c = (c == 'z' ? 'a' : c + 1);
            }
            res = min(res, sum);
            c = s[i];
            p = t[i];
            sum = 0;
            while (c != p) {
                sum += previousCost[c - 'a'];
                c = (c == 'a' ? 'z' : c - 1);
            }
            res = min(res, sum);
            ans += res;
        }
        return ans;
    }
};",1460811280
nnv-nick,nnv-nick,118,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cur = 10;
        int player = 0;
        while (true) {
            if (n < cur) {
                return (player == 1);
            }
            n -= cur;
            --cur;
            player = 1 - player;
        }
        return true;
    }
};",1460796410
nnv-nick,nnv-nick,118,3647,cpp,"#define ll int
const int inf = 1000000000;

class ExplicitSegmentTree {
public:
    ExplicitSegmentTree() {
    }

    ExplicitSegmentTree(ll sz) {
        calc_tree_size(sz);
    }

    // builds tree with n elements starting from 0 index of a
    void Build(ll *a, ll n) {
        if (tree_size < n) {
            calc_tree_size(n);
        }
        ll ind = tree_size;
        for (ll i = 0; i < n; ++i) {
            tree[tree_size + i].first = a[i];
        }
        ind >>= 1;
        while (ind > 0) {
            for (ll i = 0; i < ind; ++i) {
                tree[ind + i].first = f(tree[(ind + i) * 2].first, tree[(ind + i) * 2 + 1].first);
            }
            ind >>= 1;
        }
    }

    void Build(vector<ll>& a) {
        ll n = a.size();
        Build(a.data(), n);
    }

    // add x on the segment [lef, rig]
    void AddOnSegment(ll lef, ll rig, ll x) {
        add_on_segment(1, 0, tree_size - 1, lef, rig, x);
    }

    ll GetMax(ll lef, ll rig) {
        return get_max_on_segment(1, 0, tree_size - 1, lef, rig);
    }

    ll GetValueByIdx(ll idx) {
        return get_max_on_segment(1, 0, tree_size - 1, idx, idx);
    }

private:
    void calc_tree_size(ll sz) {
        tree_size = 1;
        while (tree_size < sz) {
            tree_size <<= 1;
        }
        tree.resize(tree_size * 2, make_pair(neutral(), 0));
    }

    ll add_on_segment(ll ind, ll lef, ll rig, ll lgr, ll rgr, ll x) {
        if (rig < lgr || lef > rgr) {
            return tree[ind].first + tree[ind].second;
        }
        if (lef >= lgr && rig <= rgr) {
            tree[ind].second += x;
            return tree[ind].first + tree[ind].second;
        }
        ll sz = (rig - lef + 1);
        ll one = add_on_segment(ind * 2, lef, lef + (sz / 2) - 1, lgr, rgr, x);
        ll two = add_on_segment(ind * 2 + 1, lef + (sz / 2), rig, lgr, rgr, x);
        tree[ind].first = f(one, two);
        return tree[ind].first + tree[ind].second;
    }

    ll get_max_on_segment(ll ind, ll lef, ll rig, ll lgr, ll rgr) {
        if (rig < lgr || lef > rgr) {
            return neutral();
        }
        if (lef >= lgr && rig <= rgr) {
            return tree[ind].first + tree[ind].second;
        }
        push(ind);
        ll sz = (rig - lef + 1);
        ll one = get_max_on_segment(ind * 2, lef, lef + (sz / 2) - 1, lgr, rgr);
        ll two = get_max_on_segment(ind * 2 + 1, lef + (sz / 2), rig, lgr, rgr);
        return f(one, two);
    }

    void push(ll idx) {
        tree[idx * 2].second += tree[idx].second;
        tree[idx * 2 + 1].second += tree[idx].second;
        tree[idx].first = f(tree[idx * 2].first + tree[idx * 2].second, tree[idx * 2 + 1].first + tree[idx * 2 + 1].second);
        tree[idx].second = 0;
    }

    ll f(ll a, ll b) {
        return min(a, b);
    }

    ll neutral() {
        return inf;
    }

    // second value in pair -- value that adds to every element on segment
    vector<pair<ll, ll>> tree;
    ll tree_size{-1};
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), ans = 0;
        vector<int> bb(n, 0);
        auto tree = ExplicitSegmentTree();
        tree.Build(bb);
        vector<int> cnt(n, 0);
        vector<vector<int>> zak(n);
        for (const auto& elem : queries) {
            ++cnt[elem[0]];
            zak[elem[1]].push_back(elem[0]);
        }
        int balance = 0;
        for (int i = 0; i < n; ++i) {
            balance += cnt[i];
            if (balance < nums[i]) {
                return -1;
            }
            tree.AddOnSegment(i, i, balance - nums[i]);
            for (const auto& elem : zak[i]) {
                --balance;
                auto tmp = tree.GetMax(elem, i);
                if (tmp == 0) {
                    continue;
                }
                ++ans;
                tree.AddOnSegment(elem, i, -1);
            }
        }
        return ans;
    }
};",1460898587
nnv-nick,nnv-nick,118,3648,cpp,"class Solution {
public:
    bool check(int in, int jn, int n) {
        return (in >= 0 && in < n && jn >= 0 && jn < n);
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        {
        vector<vector<int>> dp(n, vector<int>(n, 0));
        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 0; j < n - 1; ++j) {
            for (int i = n - 1; i > j && i >= n - 1 - j; --i) {
                if (check(i - 1, j + 1, n)) {
                    dp[i - 1][j + 1] = max(dp[i - 1][j + 1], dp[i][j] + fruits[i - 1][j + 1]);
                }
                if (check(i, j + 1, n)) {
                    dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + fruits[i][j + 1]);
                }
                if (check(i + 1, j + 1, n)) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + fruits[i + 1][j + 1]);
                }
            }
        }
        ans += dp[n - 1][n - 1];
        }
        {
        vector<vector<int>> dp(n, vector<int>(n, 0));
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 0; i < n - 1; ++i) {
            for (int j = n - 1; j > i && j >= n - 1 - i; --j) {
                if (check(i + 1, j - 1, n)) {
                    dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i][j] + fruits[i + 1][j - 1]);
                }
                if (check(i + 1, j, n)) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + fruits[i + 1][j]);
                }
                if (check(i + 1, j + 1, n)) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + fruits[i + 1][j + 1]);
                }
            }
        }
        ans += dp[n - 1][n - 1];
        }
        for (int i = 0; i < n; ++i) {
            ans += fruits[i][i];
        }
        ans -= fruits[n - 1][n - 1] * 2;
        return ans;
    }
};",1460872335
ephemeralsad,ephemeralsad,119,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = (int)s.size();

        vector<vector<long long>> costs(26, vector<long long>(26));
        
        for (char from = 'a'; from <= 'z'; ++from) {
            for (char to = 'a'; to <= 'z'; ++to) {
                long long sm = 0;
                for (char c = from; c != to;) {
                    sm += nextCost[c - 'a'];
                    c = c == 'z' ? 'a' : c + 1;
                }

                long long sm2 = 0;
                for (char c = from; c != to;) {
                    sm2 += previousCost[c - 'a'];
                    c = c == 'a' ? 'z' : c - 1;     
                }

                costs[from - 'a'][to - 'a'] = min(sm, sm2);
            }
        }
        
        long long sm = 0;
        for (int i = 0; i < n; ++i) {
            sm += costs[s[i] - 'a'][t[i] - 'a'];
        }
        return sm;
    }
};",1460828045
ephemeralsad,ephemeralsad,119,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice_turn = true;
        for (int x = 10; x >= 1; --x) {
            if (x <= n) {
                n -= x;
                alice_turn = !alice_turn;
            } else {
                break;
            }
        }
        return !alice_turn;
    }
};",1460799545
ephemeralsad,ephemeralsad,119,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        // we can fill the first element by choosing all 
        // eligible queries from max to min

        // just so
        // move to first element
        // we have info about how much is there already
        // we have a list of q-s sorted by right border what we can choose to pick
        // we must pick every elegible query in order of right border decreasing
        // we need to clear the list from elements with left border <= current pos

        vector<vector<pair<char, int>>> events((int)nums.size() + 1);
        for (int i = 0; i < (int)queries.size(); ++i) {
            events[queries[i][0]].emplace_back('s', i);
        }

        multimap<int, int> query_by_right_border;
        int already_has = 0;
        int sm = 0;
        
        int n = (int)nums.size();
        for (int i = 0; i < n; ++i) {
            for (auto e : events[i]) {
                if (e.first == 's') {
                    query_by_right_border.emplace(queries[e.second][1], e.second);
                } else if (e.first == 'f') {
                    already_has -= 1;
                }
            }

            // we need to count how much do we need
            int need = max(0, nums[i] - already_has);
            while (need && !query_by_right_border.empty()) {
                auto it = query_by_right_border.end();
                --it;
                if (queries[it->second][0] <= i && i <= queries[it->second][1]) {
                    ++sm;

                    ++already_has;
                    events[queries[it->second][1] + 1].emplace_back('f', it->second);

                    --need;
                }
                query_by_right_border.erase(it);
            }
            if (need) {
                return -1;
            }
        }

        return (int)queries.size() - sm;
    }
};",1460873460
ephemeralsad,ephemeralsad,119,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        // first child
        // 000
        // 0X1
        // 011
        // can move only in one direction LOL

        // second child
        // 000
        // 0X0
        // 111

        // third child
        // 001
        // 0X1
        // 001

        int n = (int)fruits.size();
        int sm = 0;
        for (int i = 0; i < n; ++i) {
            sm += fruits[i][i];
        }

        vector<vector<int>> dp(n, vector<int>(n, -1));
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int from_left = dp[i - 1][j - 1];
                int from_middle = dp[i - 1][j];
                int from_right = j + 1 < n ? dp[i - 1][j + 1] : -1;
                if (from_left != -1) dp[i][j] = max(dp[i][j], from_left + fruits[i][j]);
                if (from_middle != -1) dp[i][j] = max(dp[i][j], from_middle + fruits[i][j]);
                if (from_right != -1) dp[i][j] = max(dp[i][j], from_right + fruits[i][j]);
            }
        }

        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 1; j < n; ++j) {
            for (int i = j + 1; i < n; ++i) {
                int from_top = i + 1 < n ? dp[i + 1][j - 1] : -1;
                int from_middle = dp[i][j - 1];
                int from_bottom = dp[i - 1][j - 1];
                if (from_top != -1) dp[i][j] = max(dp[i][j], from_top + fruits[i][j]);
                if (from_middle != -1) dp[i][j] = max(dp[i][j], from_middle + fruits[i][j]);
                if (from_bottom != -1) dp[i][j] = max(dp[i][j], from_bottom + fruits[i][j]);
            }
        }

        return sm + dp[n - 1][n - 2] + dp[n - 2][n - 1];
    }
};",1460894136
Sam Huang,CelonyMire,122,3591,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  long long shiftDistance(string s, string t, vector<int> &c1, vector<int> &c2) {
    int n = s.size();
    long long ans = 0;
    for (int i = 0; i < n; i++) {
      long long cur = 0, cur2 = 0;
      {
        for (int j = s[i] - 'a'; j != t[i] - 'a'; j = (j + 1) % 26) {
          cur += c1[j];
        }
      }
      {
        for (int j = s[i] - 'a'; j != t[i] - 'a'; j = (j - 1 + 26) % 26) {
          cur2 += c2[j];
        }
      }
      ans += min(cur, cur2);
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::shiftDistance); // CHANGE FOR PROBLEM
}
#endif",1460821753
Sam Huang,CelonyMire,122,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool f = false;
        int p = 10;
        while (p) {
            if (n < p) {
                break;
            }
            n -= p;
            p--;
            f = !f;
        }
        return f;
    }
};",1460800216
Sam Huang,CelonyMire,122,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
template <typename T, typename U, typename A, typename P, typename C, typename C2 = C, typename F = identity>
struct segment_tree_lazy {
  vector<T> tree;
  vector<U> delay;
  U d0;
  A apply;
  P push;
  C combine;
  C2 query_combine;
  F query_fn;
  segment_tree_lazy(int n, T v, U d0, A apply, P push, C combine, C2 query_combine = {}, F query_fn = {}) : tree(2 * n, v), delay(n, d0), d0(d0), apply(apply), push(push), combine(combine), query_combine(query_combine), query_fn(query_fn) {
    for (int i = n - 1; i > 0; --i)
      tree[i] = combine(tree[i << 1], tree[i << 1 | 1]);
  }
  void apply_delay(int i, const U &v, int k) {
    int n = delay.size();
    apply(tree[i], v, k);
    if (i < n)
      push(delay[i], v, k);
  }
  void lift(int l, int r) {
    int n = delay.size();
    l += n, r += n - 1;
    for (int k = 2; l > 1; k <<= 1, l >>= 1)
      for (int i = r >>= 1; i >= l >> 1; i--) {
        tree[i] = combine(tree[i << 1], tree[i << 1 | 1]);
        if (delay[i] != d0)
          apply(tree[i], delay[i], k);
      }
  }
  void push_delay(int l, int r) {
    int n = delay.size();
    int h = __lg(n), k = 1 << __lg(n) >> 1;
    for (l += n, r += n - 1; h; h--, k >>= 1)
      for (int i = l >> h; i <= r >> h; i++)
        if (delay[i] != d0) {
          apply_delay(i << 1, delay[i], k);
          apply_delay(i << 1 | 1, delay[i], k);
          delay[i] = d0;
        }
  }
  void update(int l, int r, const U &v) { // [l, r)
    push_delay(l, l + 1);
    push_delay(r - 1, r);
    int l0 = l, r0 = r, k = 1, n = delay.size();
    for (l += n, r += n; l < r; l >>= 1, r >>= 1, k <<= 1) {
      if (l & 1)
        apply_delay(l++, v, k);
      if (r & 1)
        apply_delay(--r, v, k);
    }
    lift(l0, l0 + 1);
    lift(r0 - 1, r0);
  }
  template <typename R = T, typename... Args>
  R query(int l, int r, R ans = {}, Args &&...args) { // [l, r)
    push_delay(l, l + 1);
    push_delay(r - 1, r);
    int n = delay.size();
    auto ansl = ans, ansr = ans;
    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
      if (l & 1)
        ansl = query_combine(ansl, query_fn(tree[l++], std::forward<Args>(args)...));
      if (r & 1)
        ansr = query_combine(query_fn(tree[--r], std::forward<Args>(args)...), ansr);
    }
    return query_combine(ansl, ansr);
  }
};

class Solution {
public:
  int maxRemoval(vector<int> &a, vector<vector<int>> &q) {
    int n = a.size(), m = q.size();
    ranges::sort(q);
    vector<int> d(n + 1), extra(n);
    bool ok = true;
    for (auto &qry : q) {
      d[qry[0]]++, d[qry[1] + 1]--;
    }
    for (int i = 0, c = 0; i < n; i++) {
      c += d[i];
      ok &= c >= a[i];
      extra[i] = a[i] == 0 ? (int)1e9 : c - a[i];
    }
    if (!ok) {
      return -1;
    }
    auto apply = [](int &v, int d, int) {
      v += d;
    };
    auto comb = [](int a, int b) {
      return min(a, b);
    };
    segment_tree_lazy seg(n, 0, 0, apply, apply, comb);
    for (int i = 0; i < n; i++) {
      seg.update(i, i + 1, extra[i]);
    }
    ranges::sort(q, [&](auto &p1, auto &p2) {
      return p1[1] < p2[1];
    });
    int ans = 0;
    for (auto &qry : q) {
      dbg(qry, seg.query(qry[0], qry[1] + 1, (int)1e9));
      if (seg.query(qry[0], qry[1] + 1, (int)1e9) > 0) {
        ans++;
        seg.update(qry[0], qry[1] + 1, -1);
      }
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::maxRemoval); // CHANGE FOR PROBLEM
}
#endif",1460875427
Sam Huang,CelonyMire,122,3648,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  int maxCollectedFruits(vector<vector<int>> &g) {
    int n = g.size();
    if (n == 1) {
      return g[0][0];
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
      ans += g[i][i];
    }
    {
      int cur = 0;
      vector dp(n + 1, 0);
      for (int j = 0; j < n; j++) {
        vector ndp(n + 1, 0);
        for (int i = n - 1; i > max(j, n - j - 2); i--) {
          ndp[i] = max(dp[i], max(dp[i - 1], dp[i + 1])) + g[i][j];
          cur = max(cur, ndp[i]);
        }
        swap(dp, ndp);
      }
      ans += cur;
    }
    {
      int cur = 0;
      vector dp(n + 1, 0);
      for (int i = 0; i < n; i++) {
        vector ndp(n + 1, 0);
        for (int j = n - 1; j > max(i, n - i - 2); j--) {
          ndp[j] = max(dp[j], max(dp[j - 1], dp[j + 1])) + g[i][j];
          cur = max(cur, ndp[j]);
        }
        swap(dp, ndp);
      }
      ans += cur;
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::maxCollectedFruits); // CHANGE FOR PROBLEM
}
#endif",1460894740
SACD,SACD,124,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        
        for i in range(len(s)):
            
            c1 = c2 =0 
            t1 = s[i]
            t2 = t[i]
            
            while t1 != t2:
                c1 += nextCost[ord(t1) - ord('a')]
                t1 = chr(((ord(t1) - ord('a') + 1) % 26) + ord('a'))
            
            t1 = s[i]
            
            while t1 != t2:
                c2 += previousCost[ord(t1) - ord('a')]
                t1 = chr(((ord(t1) - ord('a') + 26 - 1 ) % 26) + ord('a'))
            
            res += min(c1, c2)
        
        return res",1460811810
SACD,SACD,124,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        p = 10
        op = 0
        while n >= 0:
            if n < p:
                return op != 0
            op ^= 1
            n -= p
            p -= 1
        return False",1460799763
SACD,SACD,124,3647,python3,"from typing import List
import heapq

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        cha = [0] * n
        
        for query in queries:
            query[1] *= -1
        queries.sort()
        for query in queries:
            query[1] *= -1
        
        p = 0
        need = 0
        pq = []
        
        for i in range(n):
            if i > 0:
                cha[i] += cha[i - 1]
            
            while p < m and queries[p][0] <= i:
                heapq.heappush(pq, -queries[p][1])
                p += 1
            
            while nums[i] + cha[i] > 0:
                while pq and -pq[0] < i:
                    return -1
                if not pq:
                    return -1
                
                l = i
                r = -heapq.heappop(pq)
                
                cha[i] -= 1
                if r + 1 < n:
                    cha[r + 1] += 1
                
                need += 1
            
            if nums[i] + cha[i] > 0:
                return -1
        
        return m - need
",1460854516
SACD,SACD,124,3648,python3,"class Solution:
    def cau(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[-1] * n for _ in range(n)]
        dp[0][n-1] = grid[0][n-1]
        ans = dp[0][n-1]
        
        for i in range(1, n-1):
            for j in range(i + 1, n):
                if dp[i-1][j-1] >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1])
                if dp[i-1][j] >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j])

                if j + 1 < n and dp[i-1][j+1] >= 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j+1])
                
                if dp[i][j] == -1:
                    continue
                dp[i][j] += grid[i][j]
                ans = max(ans, dp[i][j])

        return ans

    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits[0])
        ans = self.cau(fruits)

        for i in range(n):
            ans += fruits[i][i]
            for j in range(i, n):
                fruits[i][j], fruits[j][i] = fruits[j][i], fruits[i][j]

        ans += self.cau(fruits)
        return ans
",1460884566
Tudor Buzu,Tudor67,126,3591,cpp,"class Solution {
private:
    const int A = 26;
    
    long long f(int src, int dest, vector<int>& cost, int dir){
        long long res = 0;
        while(src != dest){
            res += cost[src];
            src = (src + dir + A) % A;
        }
        return res;
    }
    
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const int N = s.length();
        
        long long res = 0;
        for(int i = 0; i < N; ++i){
            long long cost = 0;
            if(s[i] != t[i]){
                cost = min(f(s[i] - 'a', t[i] - 'a', nextCost, 1),
                           f(s[i] - 'a', t[i] - 'a', previousCost, -1));
            }
            res += cost;
        }
        
        
        return res;
    }
};",1460815548
Tudor Buzu,Tudor67,126,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int step = 0;

        for(int val = 10; val >= 1; --val){
            if(n >= val){
                n -= val;
                step += 1;
            }else{
                break;
            }
        }
        
        return (step % 2 == 1);
    }
};",1460799539
Tudor Buzu,Tudor67,126,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        const int N = nums.size();
        const int Q = queries.size();
        
        vector<pair<int, int>> v(Q);
        for(int i = 0; i < Q; ++i){
            v[i] = {queries[i][0], queries[i][1]};
        }
        
        sort(v.begin(), v.end());
        reverse(v.begin(), v.end());
        
        int taken = 0;
        vector<int> delta(N + 5);
        using PII = pair<int, int>;
        priority_queue<PII, vector<PII>, less<PII>> maxHeap;
        
        for(int i = 0; i < N; ++i){
            if(i > 0){
                delta[i] += delta[i - 1];
            }
            
            int have = delta[i];
            int need = nums[i];
            if(have >= need){
                continue;
            }
            
            while(!v.empty() && v.back().first <= i){
                int l = v.back().first;
                int r = v.back().second;
                v.pop_back();
                maxHeap.push({r, -l});
            }
            
            while(have < need && !maxHeap.empty() && i <= maxHeap.top().first){
                int r = maxHeap.top().first;
                maxHeap.pop();
                
                delta[i] += 1;
                delta[r + 1] -= 1;
                have += 1;
                taken += 1;
            }
            
            if(have < need){
                return -1;
            }
        }
        
        return Q - taken;
    }
};",1460902107
Tudor Buzu,Tudor67,126,3648,cpp,"class Solution {
private:
    const int INF = 1e9 + 12345;
    
    int getVal(vector<vector<int>>& mat, int row, int col){
        const int ROWS = mat.size();
        const int COLS = mat[0].size();
        if(0 <= row && row < ROWS && 0 <= col && col < COLS){
            return mat[row][col];
        }
        return -INF;
    }
    
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        const int ROWS = fruits.size();
        const int COLS = fruits[0].size();
        
        // (0, 0)
        long long res = 0;
        for(int row = 0; row < ROWS; ++row){
            res += fruits[row][row];
        }
        
        // (n - 1, 0)
        vector<vector<int>> a = fruits;
        for(int row = 0; row < ROWS; ++row){
            for(int col = row; col < COLS; ++col){
                a[row][col] = 0;
            }
        }
        
        vector<vector<int>> dp(ROWS, vector<int>(COLS, -INF));
        dp[ROWS - 1][0] = a[ROWS - 1][0];
        for(int col = 1; col < COLS; ++col){
            for(int row = ROWS - 1; row >= 0; --row){
                dp[row][col] = a[row][col] + max({getVal(dp, row + 1, col - 1),
                                                  getVal(dp, row, col - 1),
                                                  getVal(dp, row - 1, col - 1)});
            }
        }
        
        res += max(0, dp[ROWS - 1][COLS - 1]);
        
        // (0, n - 1)
        a = fruits;
        for(int row = 0; row < ROWS; ++row){
            for(int col = 0; col <= row; ++col){
                a[row][col] = 0;
            }
        }
        
        for(int row = 0; row < ROWS; ++row){
            for(int col = 0; col < COLS; ++col){
                dp[row][col] = -INF;
            }
        }
        
        dp[0][COLS - 1] = a[0][COLS - 1];
        for(int row = 1; row < ROWS; ++row){
            for(int col = COLS - 1; col >= 0; --col){
                dp[row][col] = a[row][col] + max({getVal(dp, row - 1, col - 1),
                                                  getVal(dp, row - 1, col),
                                                  getVal(dp, row - 1, col + 1)});
            }
        }
        
        res += max(0, dp[ROWS - 1][COLS - 1]);
        
        return res;
    }
};",1460881720
MakarenkoStepan,MakarenkoStepan,127,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        # prepare shift costs 26 x 26
        shift_table = [[0 for _ in range(26)] for _ in range(26)]

        for i in range(26):
            for j in range(i + 1, i + 26):
                shift_table[i][j % 26] = shift_table[i][(j - 1) % 26] + nextCost[(j - 1) % 26]

        for i in range(26):
            for j in range(i + 25, i, -1):
                shift_table[i][j % 26] = min(shift_table[i][j % 26],
                                             shift_table[i][(j + 1) % 26] + previousCost[(j + 1) % 26])

        ans = 0
        for s_ch, t_ch in zip(s, t):
            ans += shift_table[ord(s_ch) - ord('a')][ord(t_ch) - ord('a')]


        return ans",1460817562
MakarenkoStepan,MakarenkoStepan,127,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        alice_win = False
        curr = 10
        while n >= curr:
            n -= curr
            curr -= 1
            alice_win = not alice_win

        return alice_win
        
        ",1460798579
MakarenkoStepan,MakarenkoStepan,127,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        min_queries = 0
        best_q = []
        running_q = []
        for l, r in queries:
            heapq.heappush(best_q, (l, -r))

        for i, n in enumerate(nums):
            # remove expired from running
            while running_q and running_q[0] < i:
                heapq.heappop(running_q)
            
            while len(running_q) < n and best_q and best_q[0][0] <= i:
                #cut queries
                while best_q and best_q[0][0] < i:
                    l, r = heapq.heappop(best_q)
                    r = -r 
                    if r >= i:
                        heapq.heappush(best_q, (i, -r))
                
                #take query and add to running
                if not best_q:
                    return -1
                l, r = heapq.heappop(best_q)
                r = -r
                heapq.heappush(running_q, r)
                min_queries += 1

            if len(running_q) < n:
                return -1

        
        return len(queries) - min_queries
                

        ",1460868684
MakarenkoStepan,MakarenkoStepan,127,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        # 0 children always diagonal? and other dont overlap?
        ans = 0 
        n = len(fruits)

        # 0 children
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0 

        # greedy other childrens, dont cross diagonal cose other one take it
        curr_lvl = {(0, n-1): fruits[0][n-1]}

        for _ in range(n-1):
            new_lvl = dict()
            for (x, y) in curr_lvl:
                for dx, dy in ((1, -1), (1, 0), (1, 1)):
                    if -1 < x + dx < n and -1 < y + dy < n and y + dy >= x + dx:
                        new_lvl[(x+dx, y+dy)] = max(new_lvl.get((x+dx, y+dy), 0),
                                                    curr_lvl[(x, y)] + fruits[x+dx][y+dy])
            curr_lvl = new_lvl
        ans += curr_lvl[(n-1, n-1)]


        # greedy other childrens, dont cross diagonal cose other one take it
        curr_lvl = {(n-1, 0): fruits[n-1][0]}

        for _ in range(n-1):
            new_lvl = dict()
            for (x, y) in curr_lvl:
                for dx, dy in ((-1, 1), (0, 1), (1, 1)):
                    if -1 < x + dx < n and -1 < y +dy < n and y + dy <= x + dx:
                        new_lvl[(x+dx, y+dy)] = max(new_lvl.get((x+dx, y+dy), 0),
                                                    curr_lvl[(x, y)] + fruits[x+dx][y+dy])
            curr_lvl = new_lvl

        ans += curr_lvl[(n-1, n-1)]

        return ans
                
        
        
        

        

        
        
        ",1460896661
Mridul Pandey,mridul_cr7,128,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<long long> pfn(30,0),pft(30,0);
        for(int i=1;i<=26;i++)
        {
            pfn[i]+=pfn[i-1]+nextCost[i-1];
            pft[i]+=pft[i-1]+previousCost[i-1];
        }
        long long ans=0;
        int n=s.size();
        for(int i=0;i<n;i++)
        {
            long long sum=1e18;
            int l=s[i]-96;
            int r=t[i]-96;
            if(r>l)
            {
                sum=min(sum,pfn[r-1]-pfn[l-1]);
                sum=min(sum,pft[l]+(pft[26]-pft[r]));
            }
            else if(l>r)
            {
                sum=min(sum,pft[l]-pft[r]);
                sum=min(sum,pfn[r-1]+(pfn[26]-pfn[l-1]));
            }
            else
            {
                sum=0;
            }
           // cout<<sum<<"" "";
            ans=ans+sum;
                
        }
        return ans;
    }
};",1460827055
Mridul Pandey,mridul_cr7,128,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool tell=false;
        int rem=n;
        int sub=10;
        while(true)
        {
            if(rem<sub)
                return tell;
            rem=rem-sub;
            tell=!tell;
            sub--;
        }
        return tell;
    }
};",1460797951
Mridul Pandey,mridul_cr7,128,3647,cpp,"struct comp1
{
    bool operator()(int &a, int &b)
    {
        return a > b;
        
    }
};



class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n=nums.size();
     
        vector<vector<int>> st(n+1);
        for(auto x:queries)
        {
            st[x[0]].push_back(x[1]);
        }
        priority_queue<int, vector<int>, comp1> pq1;
        priority_queue<int, vector<int>> pq2;
        int ans=0;
        int m=queries.size();
        for(int i=0;i<n;i++)
        {
            for(auto x:st[i])
            {
                pq2.push(x);
            }
            while(!pq1.empty() && pq1.top()<i)
            {
                pq1.pop();
            }
            while(!pq2.empty() && pq2.top()<i)
            {
                pq2.pop();
            }
            int sz=pq1.size();
            //cout<<i<<"" ""<<sz<<"" ""<<pq2.size()<<""\n"";
        
            while(sz<nums[i] && !pq2.empty())
            {
                int y=pq2.top();
                //cout<<i<<"" ""<<y<<""\n"";
                if(y<i)
                {
                    while(!pq2.empty() && pq2.top()<i)
                    {
                        pq2.pop();
                    }
                    break;
                }
                pq1.push(y);
                pq2.pop();
                sz++;
                ans++;
            }
            //cout<<i<<"" ""<<sz<<""\n"";
            if(sz<nums[i])
            {
                return -1;
            }
        }
        return m-ans;
    }
};",1460858810
Mridul Pandey,mridul_cr7,128,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n=fruits.size();
        vector<vector<int>> dp1(n+2,vector<int> (n+2,-1e5));
        dp1[0][n-1]=fruits[0][n-1];
        for(int i=1;i<n;i++)
        {
            int sz=n-(i+1);
            for(int j=n-1;j>=max(i+1,sz);j--)
            {
                int x1=i-1,y1=j;
                int x2=i-1,y2=j+1;
                int x3=i-1,y3=j-1;
                dp1[i][j]=fruits[i][j]+max(dp1[x1][y1],max(dp1[x2][y2],dp1[x3][y3]));
            }
        }
        // for(int i=0;i<n;i++)
        // {
        //     for(int j=0;j<n;j++)
        //     {
        //         cout<<dp1[i][j]<<"" "";
        //     }
        //     cout<<""\n"";
        // }
        // cout<<dp1[n-1][n-1]<<"" "";
        vector<vector<int>> dp2(n+2,vector<int> (n+2,-1e5));
        dp2[n-1][0]=fruits[n-1][0];
        for(int i=1;i<n;i++)
        {
            int sz=n-(i+1);
            for(int j=n-1;j>=max(i+1,sz);j--)
            {
                int x1=i-1,y1=j;
                int x2=i-1,y2=j+1;
                int x3=i-1,y3=j-1;
                dp2[j][i]=fruits[j][i]+max(dp2[y1][x1],max(dp2[y2][x2],dp2[y3][x3]));
            }
        }
        int ans=0;
        for(int i=0;i<n;i++)
        {
            ans=ans+fruits[i][i];
        }
        ans=ans+dp1[n-2][n-1]+dp2[n-1][n-2];
        return ans;
    }
};",1460885667
Akram,mdakram28,130,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        nextCost = list(accumulate(nextCost))
        previousCost = list(accumulate(previousCost))

        nextCost.append(0)
        previousCost.append(0)
        
        def cost(a, b, nc, pc):
            if b == a: return 0
            if b > a:
                f = nc[b-1] - nc[a-1]
                b = pc[a] + pc[25] - pc[b]
            else:
                f = nc[25] - nc[a-1] + nc[b-1]
                b = pc[a] - pc[b]
            return min(f, b)

        # print(
        #     [cost(ord(a)-ord('a'), ord(b)-ord('a'), nextCost, previousCost)
        #     for a, b in zip(s, t)]
        # )
        return sum(
            cost(ord(a)-ord('a'), ord(b)-ord('a'), nextCost, previousCost)
            for a, b in zip(s, t)
        )",1460823658
Akram,mdakram28,130,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        alice = True
        c = 10
        while n >= c:
            n -= c
            alice = not alice
            c -= 1

        return not alice
            ",1460796753
Akram,mdakram28,130,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        curr = 0
        n = len(nums)

        pend = []
        red = defaultdict(int)

        queries.sort()

        qi = 0
        count = 0

        for i in range(n):
            # print(""---"", i, curr)
            curr -= red[i]

            nums[i] -= curr

            while qi < len(queries) and queries[qi][0] <= i:
                heappush(pend, -queries[qi][1])
                qi += 1

            while nums[i] > 0:
                # print(i, nums[i], pend)
                if not pend or -pend[0] < i:
                    return -1
                end = -heappop(pend)
                curr += 1
                red[end+1] += 1
                nums[i] -= 1

        return len(pend)",1460848124
Akram,mdakram28,130,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        sumDiag = sum(fruits[r][r] for r in range(n))

        @cache
        def maxSumLeft(r,c):
            if r < 0 or r >= n or c < 0 or c >= n:
                return -inf
            if r <= c:
                return -inf
            if c == 0:
                return -inf if r != n-1 else fruits[r][c]
            return max(
                maxSumLeft(r-1, c-1),
                maxSumLeft(r, c-1),
                maxSumLeft(r+1, c-1),
            ) + fruits[r][c]

        @cache
        def maxSumTop(r,c):
            if r < 0 or r >= n or c < 0 or c >= n:
                return -inf
            if r >= c:
                return -inf
            if r == 0:
                return -inf if c != n-1 else fruits[r][c]
            return max(
                maxSumTop(r-1, c-1),
                maxSumTop(r-1, c),
                maxSumTop(r-1, c+1),
            ) + fruits[r][c]

        ans = 0
        for i in range(ceil(n/2)):
            r = c = n-i-1
            left = max(maxSumLeft(r,c-1), maxSumLeft(r+1,c-1))
            top = max(maxSumTop(r-1,c), maxSumLeft(r-1,c+1))
            total = sumDiag + left + top

            # print(i, total, left, top)
            ans = max(ans, total)

        return ans",1460891740
Mehul Singh Teya,mehulsinghteya,131,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        long long ans=0;
        for(int i=0;i<n;i++){
            long long fd = 0;
            long long rd = 0;
            
            for(int j=1;j<26;j++){
                if((s[i]-'a'+j-1)%26==t[i]-'a'){
                    break;
                }
                fd+=nextCost[(s[i]-'a'+j-1)%26];
            }
            for(int j=1;j<26;j++){
                if((s[i]-'a'-j+1+26)%26==t[i]-'a'){
                    break;
                }
                rd+=previousCost[(s[i]-'a'-j+1+26)%26];
            }
            ans+=min(rd, fd);
        }
        return ans;
    }
};",1460819465
Mehul Singh Teya,mehulsinghteya,131,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10){
            return false;
        }
        int cur=10;
        bool ans=false;
        while(n>0&&cur>0){
            if(n<cur){
                return ans;
            }
            n-=cur;
            ans=!ans;
            cur--;
        }
        return ans;
    }
};",1460799155
Mehul Singh Teya,mehulsinghteya,131,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        vector<vector<int>> edges(nums.size()+2);
        for(vector<int>& q:queries){
            edges[q[0]].push_back(q[1]);
        }
        
        int waste=0, cur=0;
        priority_queue<int> pq;
        priority_queue<int, vector<int>, greater<int>> mpq;
        int ans=0;
        for(int i=0;i<nums.size();i++){
            while(!mpq.empty()&&mpq.top()<i){
                mpq.pop();
                cur--;
            }
            for(int val:edges[i]){
                pq.push(val);
            }
            while(cur<nums[i]&&!pq.empty()&&pq.top()>=i){
                int tp = pq.top();
                mpq.push(tp);
                pq.pop();
                cur++;
                ans++;
            }
            if(cur<nums[i]){
                return -1;
            }
        }
        return queries.size()-ans;
    }
};",1460886482
Mehul Singh Teya,mehulsinghteya,131,3648,cpp,"class Solution {
    int topRight(vector<vector<int>>& f, int x, int y, int n, vector<vector<int>>& dp){
        if(x>=n||y>=n){
            return 0;
        }
        if(y<=x){
            return 0;
        }
        if(dp[x][y] != -1){
            return dp[x][y];
        }
        return dp[x][y] = (x!=y? f[x][y]:0)+ max({topRight(f, x+1, y-1, n, dp), topRight(f, x+1, y, n, dp), topRight(f, x+1, y+1, n, dp)});
    }
    int bottomLeft(vector<vector<int>>& f, int x, int y, int n, vector<vector<int>>& dp){
        if(x>=n||y>=n){
            return 0;
        }
        if(y>=x){
            return 0;
        }
        if(dp[x][y] != -1){
            return dp[x][y];
        }
        return dp[x][y] = (x!=y? f[x][y]:0)+ max({bottomLeft(f, x-1, y+1, n, dp), bottomLeft(f, x, y+1, n, dp), bottomLeft(f, x+1, y+1, n, dp)});
    }
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans=0;
        int n = fruits.size();
        for(int i=0;i<n;i++){
            ans+=fruits[i][i];
        }
        vector<vector<int>> dp1(n, vector<int>(n, -1)), dp2(n, vector<int>(n, -1));
        return ans+topRight(fruits, 0, n-1, n, dp1)+bottomLeft(fruits, n-1, 0, n, dp2);
    }
};",1460865894
openai_is_closed,openai_is_closed,134,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for (int i = 0; i < s.size(); i++) {
            char ch = s[i];
            long long c1 = 0, c2 = 0;

            while (ch != t[i]) {
                c1 += nextCost[ch - 'a'];
                ch++;
                if (ch > 'z') {
                    ch = 'a';
                }
            }

            ch = s[i];
            while (ch != t[i]) {
                c2 += previousCost[ch - 'a'];
                ch--;
                if (ch < 'a') {
                    ch = 'z';
                }
            }

            // cout << c1 << ' ' << c2 << endl;
            ans += min(c1, c2);
        }

        return ans;
    }
};",1460811202
openai_is_closed,openai_is_closed,134,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool win = false;
        int st = 10;
        while (n >= st) {
            n -= st;
            st--;
            win = !win;
        }

        return win;
    }
};",1460797853
openai_is_closed,openai_is_closed,134,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end(), [&](vector<int> &a, vector<int> &b) {
            return a[0] < b[0]; 
        });

        // printf(""queries = "");
        // for (auto it : queries) {
        //     printf(""[%d, %d] "", it[0], it[1]);
        // }
        // printf(""\n"");

        int n = nums.size();
        multiset<int> s;
        int p = 0;
        vector<int> smen(n, 0);
        int counter = 0;
        int used = 0;
        int ok = 1;
        
        for (int i = 0; i < n && ok; i++) {
            counter += smen[i];
            while (p < queries.size() && queries[p][0] <= i) {
                s.insert(queries[p][1]);
                p++;
            }

            while (counter < nums[i] && s.size() > 0) {
                auto it = prev(s.end());
                int val = *it;
                s.erase(it);

                if (val < i) {
                    continue;
                }

                used++;
                counter++;
                if (val + 1 < n) {
                    smen[val + 1]--;
                }
            }

            if (counter < nums[i]) {
                ok = 0;
            }
        }

        if (!ok) {
            return -1;
        }
            
        return queries.size() - used;
    }
};",1460869925
openai_is_closed,openai_is_closed,134,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
        }
        // printf(""ans1 = %d\n"", ans);

        vector<vector<int>> dp(2, vector<int>(n, -666666));
        dp[0][n - 1] = fruits[0][n - 1];
        int f = 1;
        for (int i = 1; i + 1 < n; i++) {
            dp[f] = vector<int>(n, -666666);
            
            for (int j = i + 1; j < n; j++) {
                for (int k = -1; k <= 1; k++) {
                    if (j + k >= 0 && j + k < n) {
                        dp[f][j] = max(dp[f][j], fruits[i][j] + dp[!f][j + k]);
                    }
                }
            }
            f = !f;
        }
        ans += dp[!f][n - 1];
        // printf(""ans2 = %d\n"", ans);

        dp = vector<vector<int>>(2, vector<int>(n, -666666));
        dp[0][n - 1] = fruits[n - 1][0];
        f = 1;
        for (int j = 1; j + 1 < n; j++) {
            dp[f] = vector<int>(n, -666666);

            for (int i = j + 1; i < n; i++) {
                for (int k = -1; k <= 1; k++) {
                    if (i + k >= 0 && i + k < n) {
                        dp[f][i] = max(dp[f][i], fruits[i][j] + dp[!f][i + k]);
                    }
                }
            }

            f = !f;
        }
        ans += dp[!f][n - 1];
        // printf(""ans3 = %d\n"", ans);
        
        return ans;
    }
};",1460892327
antiefficient,antiefficient,135,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res=0
        for i in range(len(s)):
            c=s[i]
            ci=ord(c)-ord('a')
            cost1=0
            t1=ci
            while t1!=ord(t[i])-ord('a'):
                cost1+=nextCost[t1]
                t1+=1
                t1%=26
            cost2=0
            t2=ci
            while t2!=ord(t[i])-ord('a'):
                cost2+=previousCost[t2]
                t2-=1
                t2%=26
            # cost1=nextCost[ci]*((ord(t[i])-ord(s[i]))%26)
            # cost2=previousCost[ci]*((-ord(t[i])+ord(s[i]))%26)
            res+=min(cost1,cost2)
        return res
        ",1460817866
antiefficient,antiefficient,135,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rm=10
        res=False
        while True:
            if rm>n:
                return res
            n-=rm
            rm-=1
            res = not res
        ",1460797528
antiefficient,antiefficient,135,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        qm=defaultdict(list)
        for a,b in queries:
            qm[a].append(b)
            
        av=[]
        ends=defaultdict(int)
        rt=0
        
        for i,val in enumerate(nums):
            for b in qm[i]:
                heapq.heappush(av,-b)
            while val>rt:
                if not av:
                    return -1
                b=-heapq.heappop(av)
                if b<i:
                    continue
                rt+=1
                ends[b]+=1
            rt-=ends[i]
        return len(av)
            
        ",1460850290
antiefficient,antiefficient,135,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n=len(fruits)
        r1,r2,r3=0,0,0
        for i in range(n):
            r1+=fruits[i][i]
            fruits[i][i]=-10**9
            
        for i in range(n//2):
            for j in range(i+1,n-1-i):
                fruits[i][j]=-10**9
        for i in range(1,n//2):
            for j in range(n-1-i,n-1):
                fruits[i][j]+=max(fruits[i-1][j-1],fruits[i-1][j],fruits[i-1][j+1])
            fruits[i][n-1]+=max(fruits[i-1][n-2],fruits[i-1][n-1])
        for i in range(n//2,n-1):
            for j in range(i+1,n-1):
                fruits[i][j]+=max(fruits[i-1][j-1],fruits[i-1][j],fruits[i-1][j+1])
            fruits[i][n-1]+=max(fruits[i-1][n-2],fruits[i-1][n-1])
        r2=fruits[n-2][n-1]
        
        # print(fruits)
        # print(r1,r2)
        
        
        fruits2=[[0 for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(n):
                fruits2[j][i]=fruits[i][j]
        fruits=fruits2
            
        for i in range(n//2):
            for j in range(i+1,n-1-i):
                fruits[i][j]=-10**9
        for i in range(1,n//2):
            for j in range(n-1-i,n-1):
                fruits[i][j]+=max(fruits[i-1][j-1],fruits[i-1][j],fruits[i-1][j+1])
            fruits[i][n-1]+=max(fruits[i-1][n-2],fruits[i-1][n-1])
        for i in range(n//2,n-1):
            for j in range(i+1,n-1):
                fruits[i][j]+=max(fruits[i-1][j-1],fruits[i-1][j],fruits[i-1][j+1])
            fruits[i][n-1]+=max(fruits[i-1][n-2],fruits[i-1][n-1])
        r3=fruits[n-2][n-1]
        
        return r1+r2+r3",1460898100
Leofu,Leofu,136,3591,cpp,"class Solution {
public:
    typedef long long ll;
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost) {
        int n = s.size();
        ll ans = 0;
        for (int i = 0 ; i < n ; ++i) {
            s[i] -= 'a';
            t[i] -= 'a';

            int x = s[i];
            ll cost1 = 0;
            while (x != t[i]) {
                cost1 += (ll)nextCost[x];
                x = (x + 1) % 26;
            }
            x = s[i];
            ll cost2 = 0;
            while (x != t[i]) {
                cost2 += (ll)prevCost[x];
                x = (x + 25) % 26;
            }
            ans += min(cost1, cost2);
            
        }


        return ans;
    }
};",1460807417
Leofu,Leofu,136,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i = 10;
        while (1) {
            if (i > n) {
                return i % 2 == 1;
            }
            n -= i;
            --i;
        }
        return false;
    }
};",1460798685
Leofu,Leofu,136,3647,cpp,"class Solution {
public:
    class SegmentTree {
        vector<int> tree, lazy;
        int n;
    
        void applyLazy(int node, int start, int end) {
            if (lazy[node] != 0) {
                tree[node] -= lazy[node];
    
                if (start != end) { // Not a leaf
                    lazy[2 * node + 1] += lazy[node];
                    lazy[2 * node + 2] += lazy[node];
                }
    
                lazy[node] = 0;
            }
        }
    
        void updateRange(int node, int start, int end, int l, int r, int value) {
            applyLazy(node, start, end);
    
            if (start > r || end < l) return;
    
            if (start >= l && end <= r) {
                lazy[node] += value;
                applyLazy(node, start, end);
                return;
            }
    
            // Partial overlap
            int mid = (start + end) / 2;
            updateRange(2 * node + 1, start, mid, l, r, value);
            updateRange(2 * node + 2, mid + 1, end, l, r, value);
    
            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
        }
    
        int queryRange(int node, int start, int end, int l, int r) {
            applyLazy(node, start, end);
    
            if (start > r || end < l) return INT_MAX;
    
            if (start >= l && end <= r) return tree[node];
    
            int mid = (start + end) / 2;
            return min(queryRange(2 * node + 1, start, mid, l, r),
                       queryRange(2 * node + 2, mid + 1, end, l, r));
        }
    
    public:
        SegmentTree(vector<int>& arr) {
            n = arr.size();
            tree.resize(4 * n, 0);
            lazy.resize(4 * n, 0);
            buildTree(arr, 0, 0, n - 1);
        }
    
        void buildTree(vector<int>& arr, int node, int start, int end) {
            if (start == end) {
                tree[node] = arr[start];
                return;
            }
            int mid = (start + end) / 2;
            buildTree(arr, 2 * node + 1, start, mid);
            buildTree(arr, 2 * node + 2, mid + 1, end);
            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
        }
    
        void update(int l, int r, int value) {
            updateRange(0, 0, n - 1, l, r, value);
        }
    
        int query(int l, int r) {
            return queryRange(0, 0, n - 1, l, r);
        }
    };

    static const int BIT_SIZE = 1e5  + 10;
    int BIT[BIT_SIZE] = {0};
    void inc(int x, int val) {
        for (int i = x ; i > 0 ; i -= i&-i) {
            BIT[i] += val;
        }
    }
    int ask(int x) {
        int sum = 0;
        for (int i = x ; i < BIT_SIZE ; i += i&-i ) {
            sum += BIT[i];
        }
        return sum;
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        for (auto & q : queries) {
            inc(q[1] + 1, 1);
            inc(q[0], -1);
        }
        vector<int> diff(n);
        for (int i = 0 ; i < n ; ++i) {
            diff[i] = ask(i + 1) - nums[i];
            if (diff[i] < 0) return -1;
        }

        // how many segments we can remove from diff?

        /*
        dp[i] meaning that we the last deduction is until i ?
        
        */
        sort(queries.begin(), queries.end(), [](auto const & a, auto const & b) {
            return a[1] == b[1] ? a[0] > b[0] : a[1] < b[1];
        });

        SegmentTree seg(diff);

        int ans = 0;

        for (auto & q : queries) {
            if (seg.query(q[0], q[1]) > 0) {
                ++ans;
                seg.update(q[0], q[1], 1);
            }
        }
        
        return ans;
    }
};

/*
1. make the difference array
2. sort segments
3. use dp<p>
maintain until index i, we have how many segments, and the previous 0 

problem: how to maintain previous values? set or pq?
put all (value, index): value from small to big, index from big to small or use neg
maintain cur?
maintain rightmost 0, rightmost 1, ..?

*/",1460879055
Leofu,Leofu,136,3648,cpp,"class Solution {
public:
    // int dp[1001][1001] = {0}; // the x position of (n-1,0) and y position of (0,n-1)

// when it's j step: (.., j), (j, ..)
// .. between n - 1 - j and n - 1 + j
    int maxCollectedFruits(vector<vector<int>>& grid) {
        int ans = 0, n = grid.size();
        for (int i = 0 ; i < n ; ++i) {
            ans += grid[i][i];
            grid[i][i] = 0;
        }
        
        /*
        consider the special case ( meet in the middle, then go right down)
        others are independent cases
        */
        vector<int> dp1(n, -1), dp2(n, -1);
        dp1[n - 1] = grid[n - 1][0];
        for (int j = 1 ; j < n ; ++j){ // at grid[x][j]
            auto prev = dp1;
            dp1 =vector<int>(n, -1);
            for (int x = n / 2 + n % 2 ; x < n ; ++x) {
                int dir[3][2] = {{x - 1, j}, {x, j}, {x + 1, j}};
                for (int a = 0 ; a < 3 ; ++a) {
                    if (dir[a][0] < 0 || dir[a][0] >= n || dir[a][1] < 0 || dir[a][1] >= n) continue ;
                    int xx = dir[a][0], yy = dir[a][1];
                    if (prev[xx] < 0) continue ;
                    dp1[x] = max(dp1[x], prev[xx] + grid[x][j]);
                }
            }
        }
        dp2[n - 1] = grid[0][n - 1];
        for (int i = 1 ;i < n ; ++i) {
            auto prev = dp2;
            dp2 = vector<int>(n, -1);
            for (int y = n / 2 + n % 2 ; y < n ; ++y) {
                int dir[3][2] = {{i, y - 1}, {i, y}, {i, y + 1}};
                for (int a  = 0 ; a < 3 ; ++a) {
                    int xx = dir[a][0], yy = dir[a][1];
                    if (xx < 0 || xx >= n || yy < 0 || yy >= n) continue ;
                    if (prev[yy] < 0) continue ;
                    dp2[y] = max(dp2[y], prev[yy] + grid[i][y]);
                }
            }
        }

        return ans + dp1.back() + dp2.back();
    }
};",1460903909
Fasdr,Fasdr,139,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        int m = 'z' - 'a' + 1;
        long total = 0;
        for (int i = 0; i < n; i++){
            int oldIdx = s.charAt(i) - 'a';
            int newIdx = t.charAt(i) - 'a';
            int curIdx = oldIdx;
            long prev = 0;
            while (curIdx != newIdx) {
                prev += previousCost[curIdx];
                curIdx = (curIdx - 1 + m) % m;
            }
            curIdx = oldIdx;
            long next = 0;
            while (curIdx != newIdx) {
                next += nextCost[curIdx];
                curIdx = (curIdx + 1) % m;
            }
            total += Math.min(prev, next);
        }
        return total;
    }
}",1460821194
Fasdr,Fasdr,139,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int start = 10;
        boolean winner = false;
        while (n >= 0) {
            if (n < start) {
                return winner;
            }
            winner = winner ^ true;
            n -= start--;
        }
        return false;
    }
}",1460798553
Fasdr,Fasdr,139,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length, m = queries.length;
        Arrays.sort(queries, (q1, q2) -> q1[0] - q2[0]);
        Queue<Integer> frontier = new PriorityQueue<>(Collections.reverseOrder());
        int j = 0;
        int[] change = new int[n + 1];
        for (int i = 0; i < n; i++) {
            if (i != 0) {
                change[i] += change[i - 1];
            }
            // place possible options in PQ
            while (j < m && queries[j][0] == i) {
                frontier.add(queries[j++][1]);
            }
            while (!frontier.isEmpty() && change[i] < nums[i]) {
                int right = frontier.remove();
                if (right < i) {
                    return -1;
                }
                change[i]++;
                change[right + 1]--;
            }
            if (change[i] < nums[i]) {
                return -1;
            }
        }
        
        
        return frontier.size();
    }
}",1460841038
Fasdr,Fasdr,139,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        int diag = 0;
        for (int i = 0; i < n; i++) {
            diag += fruits[i][i];
            fruits[i][i] = 0;
        }
        int[][] right = new int[n][n];
        for (int[] row : right) {
            Arrays.fill(row, -100_000_000);
        }
        right[n - 1][0] = fruits[n - 1][0];
        for (int j = 0; j < n - 1; j++) {
            for (int i = 0; i < n; i++) {
                right[i][j + 1] = Math.max(right[i][j + 1], right[i][j] + fruits[i][j + 1]);
            }
            for (int i = 1; i < n; i++) {
                right[i - 1][j + 1] = Math.max(right[i - 1][j + 1], right[i][j] + fruits[i - 1][j + 1]);
            }
            for (int i = 0; i < n - 1; i++) {
                right[i + 1][j + 1] = Math.max(right[i + 1][j + 1], right[i][j] + fruits[i + 1][j + 1]);
            }
        }
        int[][] left = new int[n][n];
        for (int[] row : left) {
            Arrays.fill(row, -100_000_000);
        }
        left[0][n - 1] = fruits[0][n - 1];
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n; j++) {
                left[i + 1][j] = Math.max(left[i + 1][j], left[i][j] + fruits[i + 1][j]);
            }
            for (int j = 1; j < n; j++) {
                left[i + 1][j - 1] = Math.max(left[i + 1][j - 1], left[i][j] + fruits[i + 1][j - 1]);
            }
            for (int j = 0; j < n - 1; j++) {
                left[i + 1][j + 1] = Math.max(left[i + 1][j + 1], left[i][j] + fruits[i + 1][j + 1]);
            }
        }
        return diag + right[n - 1][n - 1] + left[n - 1][n - 1];
    }
}",1460884146
TheRaven,TheRaven,140,3591,java,"class Solution {
    long [] nextC;
    long [] prevC;
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        char [] S = s.toCharArray();
        char [] T = t.toCharArray();
        nextC = new long [26];
        prevC = new long [26];
        nextC[0] = nextCost[0];
        for (int i = 1; i<nextCost.length; ++i) nextC[i] = nextC[i-1] + nextCost[i];
        prevC[25] = previousCost[25];
        for (int i = 24; i>=0; --i) prevC[i] = prevC[i+1] + previousCost[i];
        
        long min = 0;
        for (int i = 0; i<S.length; ++i) {
            int v = S[i]-'a';
            int x = T[i]-'a';
            long nextC0 = nextC[(x+25)%26] - nextC[(v+25)%26];
            if ((x+25)%26 < (v+25)%26) nextC0 += nextC[25];
            long prevC0 = prevC[(x+1)%26] - prevC[(v+1)%26];
            if ((x+1)%26 > (v+1)%26) prevC0 += prevC[0];
            min += Math.min(nextC0, prevC0);
        }
        return min;
    }
}",1460844859
TheRaven,TheRaven,140,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean alice = true;
        int num = 10;
        while (n > 0 && num > 0) {
            if (n < num) return !alice;
            alice ^= true;
            n -= num;
            num--;
        }
        return !alice;
    }
}",1460807624
TheRaven,TheRaven,140,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int [] adj = new int [nums.length];
        AL[] s = new AL[nums.length];
        for (int i = 0; i<queries.length; ++i) {
            int a = queries[i][0];
            int b = queries[i][1];
            if (s[a] == null) s[a] = new AL();
            s[a].add(b);
        }
        int v = 0;
        int ans = 0;
        PriorityQueue<Integer> PQ = new PriorityQueue<>((a,b) -> b-a);
        for (int i = 0; i<nums.length; ++i) {
            if (s[i] != null) PQ.addAll(s[i]);
            while (v < nums[i] && !PQ.isEmpty()) {
                int j = PQ.poll();
                if (j < i) return -1;
                adj[j]--;
                v++;
                ans++;
            }
            if (v < nums[i]) return -1;
            v += adj[i];
        }
        return queries.length - ans;
    }
    static class AL extends ArrayList<Integer>{}
}",1460880331
TheRaven,TheRaven,140,3648,java,"class Solution {
    int [][] dp;
    int [][] F;
    int N;
    public int maxCollectedFruits(int[][] fruits) {
       F = fruits;
       N = F.length;
       int ans = 0;
       dp = new int [fruits.length][fruits[0].length];
       for (int i = 0; i<fruits.length;++i) Arrays.fill(dp[i], -1);
       int v1 = recurse(N-1, N-2);
       int v2 = recurse(N-2, N-1);
       for (int i = 0; i<fruits.length; ++i) 
           ans+= fruits[i][i];
       return ans + v1 + v2;
    }
    public int recurse(int i, int j) {
        if (i < 0 || j < 0 || i >= N || j >= N) return -1;
        if (i == j || i+j < F.length-1) return -1;
        if (dp[i][j] == -1) {
            //...
            int best = 0;
            if (i > j) {
                best = Math.max(best, recurse(i, j-1));
                best = Math.max(best, recurse(i-1, j-1));
                best = Math.max(best, recurse(i+1, j-1));
            } else {
                best = Math.max(best, recurse(i-1, j));
                best = Math.max(best, recurse(i-1, j+1));
                best = Math.max(best, recurse(i-1, j-1));
            }
            dp[i][j] = best + F[i][j];
        }
        //System.out.println(""At row "" + i + "" col "" + j + "" ans is "" + dp[i][j]);
        return dp[i][j];
    }
}",1460901945
Ajit,Ajit123,141,3591,cpp,"class Solution {
public:
    long long calc(int i, int j, vector<int>& costNext, vector<int>& costPrev) {
        if (i > j) {
            long long val1 = accumulate(costPrev.begin() + j + 1, costPrev.begin() + i + 1, 0ll);
            long long val2 = accumulate(costNext.begin() + i, costNext.end(), 0ll) + accumulate(costNext.begin(), costNext.begin()+j, 0ll);
            return min(val1, val2);
        }

        long long val1 = accumulate(costNext.begin() + i, costNext.begin() + j, 0ll);
        long long val2 = accumulate(costPrev.begin() + j + 1, costPrev.end(), 0ll) + accumulate(costPrev.begin(), costPrev.begin()+i+1, 0ll);
        return min(val1, val2);
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int i=0; i<s.size(); i++) {
            ans += calc(s[i]-'a', t[i]-'a', nextCost, previousCost);
        }

        return ans;
    }
};",1460860738
Ajit,Ajit123,141,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) {
            return false;
        }

        int cur = 10;
        int turn = 0;
        while (cur && n >= cur) {
            n -= cur--;
            turn ^= 1;
        }

        return turn;
    }
};",1460863954
Ajit,Ajit123,141,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        sort(queries.begin(), queries.end(), [&](const vector<int>& val1, const vector<int>& val2) -> bool {
            if (val1[0] != val2[0]) {
                return val1[0] < val2[0];
            }

            return val1[1] > val2[1];
        });

        int ptr = 0, cur = 0;
        vector<int> cnt(n+1);
        multiset<int, greater<int>> cand;
        int ans = queries.size();
        for(int i=0; i<n; i++) {
            cur += cnt[i];
        
            while (ptr < queries.size()) {
                if (queries[ptr][1] < i) {
                    ptr++;
                    continue;
                }

                if (queries[ptr][0] > i) {
                    break;
                }

                cand.insert(queries[ptr][1]);
                ptr++;
            }

            while (!cand.empty() && nums[i] + cur > 0) {
                int r = *cand.begin();
                if (r < i) {
                    return -1;
                }

                
                cur--;
                cnt[i]--;
                cnt[r + 1]++;
                ans--;
                cand.erase(cand.begin());
            }

            if (nums[i] + cur > 0) {
                return -1;
            }
        }

        return ans;
    }
};",1460843750
Ajit,Ajit123,141,3648,cpp,"const int INF = 1e9 + 205;
class Solution {
    vector<pair<int, int>> dirs1 = {{-1, 1}, {0, 1}, {1, 1}};
    vector<pair<int, int>> dirs2 = {{1, -1}, {1, 0}, {1, 1}};
public:
    bool valid(int i, int j, int n) {
        return i >= 0 && i < n && j >= 0 && j < n; 
    }

    int solve(int i, int j, vector<vector<int>>& a, vector<vector<int>>& dp) {
        int n = a.size();
        if (j == n-1) {
            return i == n-1 ? 0 : -INF; 
        }

        if (i < j) {
            return -INF;
        }

        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int& ans = dp[i][j];
        ans = 0;
        for (auto& [di, dj]: dirs1) {
            int i1 = i + di;
            int j1 = j + dj;
            if (valid(i1, j1, n)) {
                ans = max(ans, a[i][j] + solve(i1, j1, a, dp));
            }
        }

        return ans;
    }

    int solve1(int i, int j, vector<vector<int>>& a, vector<vector<int>>& dp) {
        int n = a.size();
        if (i == n-1) {
            return j == n-1 ? 0 : -INF; 
        }

        if (i > j) {
            return -INF;
        }

        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int& ans = dp[i][j];
        ans = 0;
        for (auto& [di, dj]: dirs2) {
            int i1 = i + di;
            int j1 = j + dj;
            if (valid(i1, j1, n)) {
                ans = max(ans, a[i][j] + solve1(i1, j1, a, dp));
            }
        }

        return ans;
    }

    int maxCollectedFruits(vector<vector<int>>& a) {
        int ans = 0;
        for(int i=0; i<a.size(); i++) {
            ans += a[i][i];
            a[i][i] = 0;
        }

        int n = a.size();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        vector<vector<int>> dp1(n, vector<int>(n, -1));
        return ans + solve1(0, n-1, a, dp1) + solve(n-1, 0, a, dp);
    }
};",1460896546
Sandeep P,Sandeep_P,144,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans=0
        @cache
        def cost(x,y):
            xx=x
            r=0
            while x%26!=y:
                r+=nextCost[x%26]
                x+=1
            x=xx+26
            l=0
            while x%26!=y:
                l+=previousCost[x%26]
                x-=1
            return min(l,r)
        for x,y in zip(s,t):
            x=ord(x)%32-1
            y=ord(y)%32-1
            ans+=cost(x,y)
        return ans
            ",1460822674
Sandeep P,Sandeep_P,144,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        take=10
        alice=True
        while n>=take and take!=0:
            n-=take
            alice=not alice
            take-=1
        return not alice
            ",1460797981
Sandeep P,Sandeep_P,144,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n=len(nums)
        queries.sort()
        pos=0
        h=[]
        cur=0
        c=[0]*(n+1)
        ans=len(queries)
        for i,x in enumerate(nums):
            cur+=c[i]
            while pos<len(queries) and queries[pos][0]<=i:
                heappush(h,-queries[pos][-1])
                pos+=1
            while cur<x and h:
                r=-heappop(h)
                if r<i:
                    return -1
                ans-=1
                cur+=1
                c[r+1]-=1
            if cur<x:
                return -1
        return ans
                ",1460846741
Sandeep P,Sandeep_P,144,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n=len(fruits)
        ans=0
        for i in range(n):
            ans+=fruits[i][i]
            fruits[i][i]=0
        @cache
        def dfs1(x,y):
            if x==n-1:
                if y==n-1:
                    return 0
                return -inf
            ans=fruits[x][y]
            next=-inf
            for ny in range(y-1,y+2):
                if 0<=ny<n:
                    next=max(next,dfs1(x+1,ny))
            ans+=next
            return ans

        @cache
        def dfs2(x,y):
            if y==n-1:
                if x==n-1:
                    return 0
                return -inf
            ans=fruits[x][y]
            next=-inf
            for nx in range(x-1,x+2):
                if 0<=nx<n:
                    next=max(next,dfs2(nx,y+1))
            ans+=next
            return ans

        ans+=dfs1(0,n-1)
        dfs1.cache_clear()
        ans+=dfs2(n-1,0)
        dfs2.cache_clear()
        return ans",1460885876
Kar Deepak Kumar,kardeepakkumar,145,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        result = 0
        for idx in range(len(s)):
            byNext = 0
            byPrev = 0
            nextIdx = ord(s[idx]) - ord('a')
            while nextIdx != ord(t[idx]) - ord('a'):
                byNext += nextCost[nextIdx]
                nextIdx = (nextIdx + 1)%26
            prevIdx = ord(s[idx]) - ord('a')
            while prevIdx != ord(t[idx]) - ord('a'):
                byPrev += previousCost[prevIdx]
                prevIdx = (prevIdx - 1)%26
            current = min(byPrev, byNext)
            result += current
        return result",1460815122
Kar Deepak Kumar,kardeepakkumar,145,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        moves = 0
        moveCount = 10
        while n >= moveCount:
            n -= moveCount
            moveCount -= 1
            moves += 1
        return (moves%2 == 1)",1460802069
Kar Deepak Kumar,kardeepakkumar,145,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        fixedCount = 0
        queries.sort()
        qIdx = 0
        curFixed = []
        curOptions = []
        for i, num in enumerate(nums):
            while qIdx < len(queries) and queries[qIdx][0] <= i:
                heapq.heappush(curOptions, -1*queries[qIdx][1])
                qIdx += 1
            while curFixed and curFixed[0] < i:
                heapq.heappop(curFixed)
            while len(curFixed) < num:
                if not curOptions or -1*curOptions[0] < i:
                    return -1
                val = -1*heapq.heappop(curOptions)
                heapq.heappush(curFixed, val)
                fixedCount += 1
        return len(queries) - fixedCount",1460878242
Kar Deepak Kumar,kardeepakkumar,145,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        child1 = 0
        for i in range(n):
            child1 += fruits[i][i]

        INF = 10**9 + 1

        @cache
        def scoreChild2(curRow, curCol):
            if curRow < 0 or curRow >= n or curCol < 0 or curCol >= n or curCol < curRow:
                return -1*INF
            if curRow == curCol:
                return 0
            curScore = fruits[curRow][curCol]
            nextScore = max(scoreChild2(curRow + 1, curCol + 1), scoreChild2(curRow + 1, curCol - 1), scoreChild2(curRow + 1, curCol))
            return curScore  + nextScore

        @cache
        def scoreChild3(curRow, curCol):
            if curRow < 0 or curRow >= n or curCol < 0 or curCol >= n or curCol > curRow:
                return -1*INF
            if curRow == curCol:
                return 0
            curScore = fruits[curRow][curCol]
            nextScore = max(scoreChild3(curRow - 1, curCol + 1), scoreChild3(curRow, curCol + 1), scoreChild3(curRow + 1, curCol + 1))
            return curScore  + nextScore

        return child1 + scoreChild2(0, n-1) + scoreChild3(n-1, 0)

",1460893086
Sai Krishna,saikrishna17394,146,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;

        int len = s.length();

        for (int i = 0; i < len; i++) {
            int diff = t[i] - s[i];

            if (diff < 0) { diff += 26; }

            int idx1 = s[i] - 'a';
            int idx2 = t[i] - 'a';
            long long cur1 = 0;
            
            while (idx1 != idx2) {
                cur1 += (long long)nextCost[idx1];
                idx1++;
                idx1 %= 26;
            }

            idx1 = s[i] - 'a';
            long long cur2 = 0;

            while (idx1 != idx2) {
                cur2 += (long long)previousCost[idx1];
                idx1 += 25;
                idx1 %= 26;
            }
            ans += min(cur1, cur2);
        }

        return ans;
    }
};",1460810856
Sai Krishna,saikrishna17394,146,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        int cur = 0;
        int rem = 10;

        while (n >= rem) {
            n -= rem;
            rem--;
            cur ^= 1;
        }

        if (cur == 0) { return false; }

        return true;
    }
};",1460797272
Sai Krishna,saikrishna17394,146,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int len = nums.size();

        multiset<int> s;
        vector<vector<int>> v(len);
        
        for (const auto& q : queries) {
            v[q[0]].push_back(q[1]);    
        }

        for (int i = len - 1; i > 0; i--) {
            nums[i] -= nums[i - 1];
        }
        nums.push_back(0); // for cumulative sums
        
        int cur = 0;
        int ans = 0;

        for (int i = 0; i < len; i++) {
            cur += nums[i];

            int cnt = s.size();
            cnt += v[i].size();

            if (cnt < cur) {
                return -1;
            }

            for (const auto& r : v[i]) {
                s.insert(r);
            }
            
            while (cur > 0) {
                auto it = s.rbegin();
                nums[*it + 1]++;
                s.erase(s.find(*it));
                cur--;
            }

            while (s.size() > 0) {
                if (*s.begin() == i) {
                    ans++;
                    s.erase(s.begin());
                }
                else {
                    break;
                }
            }
        }

        return ans;
    }
};",1460889068
Sai Krishna,saikrishna17394,146,3648,cpp,"class Solution {
    vector<vector<int>> dp;
    int n;
    int inf = 1e8;

    int solve(int i, int j, vector<vector<int>>& fruits) {
        if (dp[i][j] != -1) {
            return dp[i][j];
        }


        if (j == 0) {
            dp[i][j] = inf;
            return inf;
        }

        int val = solve(i, j - 1, fruits);
        int ret = -1;
        
        if (val != inf) {
            ret = max(ret, val);    
        }

        if (i > 0) {
            val = solve(i - 1, j - 1, fruits);
            
            if (val != inf) {
                ret = max(ret, val);    
            }
        }

        if (i < (n - 1)) {
            val = solve(i + 1, j - 1, fruits);
            
            if (val != inf) {
                ret = max(ret, val);    
            }
        }

        if (ret == -1) {
            dp[i][j] = inf;
            return inf;
        }

        dp[i][j] = ret + fruits[i][j];
        return dp[i][j];
    }

    int solve_ot(int i, int j, vector<vector<int>>& fruits) {
        if (dp[i][j] != -1) {
            return dp[i][j];
        }


        if (i == 0) {
            dp[i][j] = inf;
            return inf;
        }

        int val = solve_ot(i - 1, j, fruits);
        int ret = -1;
        
        if (val != inf) {
            ret = max(ret, val);    
        }

        if (j > 0) {
            val = solve_ot(i - 1, j - 1, fruits);
            
            if (val != inf) {
                ret = max(ret, val);
            }
        }

        if (j < (n - 1)) {
            val = solve_ot(i - 1, j + 1, fruits);
            
            if (val != inf) {
                ret = max(ret, val);    
            }
        }

        if (ret == -1) {
            dp[i][j] = inf;
            return inf;
        }

        dp[i][j] = ret + fruits[i][j];
        return dp[i][j];
    }

public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        n = fruits.size();

        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }

        dp = vector<vector<int>>(n, vector<int>(n, -1));
        dp[n - 1][0] = fruits[n - 1][0];
        ans += solve(n - 1, n - 1, fruits);

        dp = vector<vector<int>>(n, vector<int>(n, -1));
        dp[0][n - 1] = fruits[0][n - 1];
        ans += solve_ot(n - 1, n - 1, fruits);
        return ans;
    }
};",1460909727
Lee Chun Kit,plastical,149,3591,cpp,"#define ll long long

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& pv) {
        ll ans=0, n=s.length();
        for (ll i=0; i<n; i++){
            ll id = s[i]-'a', nid = t[i]-'a';
            // ll p=nxt[id], q=pv[id];
            // ll dist = nid-id;
            // dist = (dist%26+26)%26;
            // ll neg = 26-dist;
            // neg = (neg%26+26)%26;
            // ans+=min(dist*p, neg*q);
            // cout << dist << ' ' << neg << ' ' << ans << '\n';
            ll op1=0;
            while (id!=nid){
                op1+=nxt[id];
                id++;
                if (id==26) id=0;
            }
            ll op2=0;
            id=s[i]-'a';
            while (id!=nid){
                op2+=pv[id];
                id--;
                if (id==-1) id=25;
            }
            ans+=min(op1, op2);
        }
        return ans;
    }
};",1460829232
Lee Chun Kit,plastical,149,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int ptr = 10;
        while (1){
            if (n<ptr) break;
            n-=ptr;
            ptr--;
        }
        return (ptr%2);
    }
};",1460803533
Lee Chun Kit,plastical,149,3647,cpp,"#define ll long long
class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        ll n = a.size(), si = q.size(), used = 0, ptr=0;
        sort(q.begin(), q.end());
        multiset<ll> active, ready;
        for (ll i=0; i<n; i++){
            while (ptr<si && q[ptr][0]<=i){
                ready.insert(q[ptr][1]);
                ptr++;
            }
            while (!ready.empty()){
                if (*(ready.begin())<i)
                    ready.erase(ready.begin());
                else break;
            }
            while (!active.empty()){
                if (*(active.begin())<i)
                    active.erase(active.begin());
                else break;
            }
            while (active.size() < a[i] && !ready.empty()){
                used++;
                active.insert(*prev(ready.end()));
                ready.erase(prev(ready.end()));
            }
            // cout << i << active.size() << '\n';
            if (active.size() < a[i]) return -1;
        }
        return si-used;
    }
};",1460866544
Lee Chun Kit,plastical,149,3648,cpp,"#define ll long long

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        ll ans=0, n=a.size(), bad=-1e7;
        for (ll i=0; i<n; i++){
            ans+=a[i][i];
            a[i][i]=0;
        }
        vector<vector<ll>> tmp(n, vector<ll>(n));
        for (ll j=0; j<n; j++)
            tmp[0][j]=tmp[j][0]=bad;
        tmp[0][n-1]=a[0][n-1];
        
        tmp[n-1][0]=a[n-1][0];
        for (ll i=1; i<n; i++){
            for (ll j=i+1; j<n; j++){
                ll best = tmp[i-1][j];
                if (j-1>=0) best=max(best, tmp[i-1][j-1]);
                if (j+1<n) best=max(best, tmp[i-1][j+1]);
                tmp[i][j]=a[i][j]+best;
            }
        }
        for (ll j=1; j<n; j++){
            for (ll i=j+1; i<n; i++){
                ll best = tmp[i][j-1];
                if (i-1>=0) best=max(best, tmp[i-1][j-1]);
                if (i+1<n) best=max(best, tmp[i+1][j-1]);
                tmp[i][j]=a[i][j]+best;
            }
        }
        // cout << ans << ' ' << tmp[n-1][n-2] << ' ' << tmp[n-1][n-2] << '\n';
        ans+=tmp[n-1][n-2]+tmp[n-2][n-1];
        return ans;
    }
};",1460905398
Cyril Huang,hccyril,150,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        INF = 10 ** 11
        a = [[INF] * 26 for _ in range(26)]
        for i in range(26):
            a[i][i] = 0
            a[i][(i + 1) % 26] = min(a[i][(i + 1) % 26], nextCost[i])
            a[i][(i - 1) % 26] = min(a[i][(i - 1) % 26], previousCost[i])
        for k in range(26):
            for i in range(26):
                for j in range(26):
                    if a[i][k] + a[k][j] < a[i][j]:
                        a[i][j] = a[i][k] + a[k][j]
        return sum(a[ord(x) - 97][ord(y) - 97] for x, y in zip(s, t))
        ",1460824939
Cyril Huang,hccyril,150,3625,python3,"def win(n, c):
    if n < c or c == 0:
        return False
    return not win(n - c, c - 1)
class Solution:
    def canAliceWin(self, n: int) -> bool:
        return win(n, 10)
        ",1460799357
Cyril Huang,hccyril,150,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        qs = [(l, -r) for l, r in queries]
        qs.sort()
        n = len(nums)
        a = [0] * (n + 1)
        cur = 0
        j = 0
        hp = []
        need = 0
        for i, x in enumerate(nums):
            cur += a[i]
            while j < len(qs) and qs[j][0] <= i:
                l, rt = qs[j]
                j += 1
                heappush(hp, (rt, l))
            while cur < x:
                if not hp:
                    return -1
                rt, l = heappop(hp)
                r = -rt
                if r >= i:
                    a[r + 1] -= 1
                    cur += 1
                    need += 1
        return len(qs) - need",1460910961
Cyril Huang,hccyril,150,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        if n == 2:
            return sum(sum(r) for r in fruits)
        elif n == 3:
            return sum(sum(r) for r in fruits) - fruits[0][1] - fruits[1][0]
        a = fruits
        def calc():
            nonlocal a, n
            dp = [0] * n
            dp[n - 1] = a[-2][-1]
            for i in range(n - 3, -1, -1):
                c = min(n - 1 - i, i + 1)
                dp[n - c:] = (a[i][j] + max(dp[k] for k in range(j - 1, j + 2) if 0 <= k < n) for j in range(n - c, n))
            return dp[-1]
        ans = sum(a[i][i] for i in range(n))
        ans += calc()
        a = [list(c) for c in zip(*a)]
        ans += calc()
        return ans",1460869535
henrychienhy,henrychienhy,154,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long distance[26][26] = {0};
        for(int i = 0; i < 26; i++) {
            for(int j = 0; j < 26; j++) {
                if (i != j) {
                    long long x1 = 0, x2 = 0;
                    for(int k = i; k != j; k = (k+1) % 26) {
                        x1 += nextCost[k];
                    }
                    for(int k = i; k != j; k = (k+25) % 26) {
                        x2 += previousCost[k];
                    }
                    distance[i][j] = min(x1, x2);
                }
            }
        }
        long long res = 0;
        for(int i = 0; i < s.length(); i++) {
            res += distance[s[i]-'a'][t[i]-'a'];
        }
        return res;
    }
};",1460847247
henrychienhy,henrychienhy,154,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 10;
        int y = 0;
        while(n >= x) {
            n -= x;
            x--;
            y = 1 - y;
        }
        return y == 1;
    }
};",1460836907
henrychienhy,henrychienhy,154,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        vector<int> end_counts(nums.size(), 0);
        sort(queries.begin(), queries.end());
        priority_queue<int> ends;
        int j = 0;
        int intersects_count = 0;
        int res = queries.size();
        for(int i = 0; i < nums.size(); i++) {
            while(j < queries.size() && queries[j][0] <= i) {
                ends.push(queries[j++][1]);
            }
            while(intersects_count < nums[i] && !ends.empty()) {
                int end = ends.top();
                ends.pop();
                if (end >= i) {
                    // cout << end << endl;
                    end_counts[end]++;
                    intersects_count++;
                    res--;
                }
            }
            if (intersects_count < nums[i])
                return -1;
            intersects_count -= end_counts[i];
        }
        return res;
    }
};",1460872726
henrychienhy,henrychienhy,154,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int res = 0;
        for(int i = 0; i < n; i++) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> memo1(n, vector<int>(n, -1));
        vector<vector<int>> memo2(n, vector<int>(n, -1));
        int di1[] = {1, 1, 1};
        int dj1[] = {-1, 0, 1};
        int di2[] = {1, 0, -1};
        int dj2[] = {1, 1, 1};
        return res + search(fruits, 0, n-1, di1, dj1, 0, memo1) + search(fruits, n-1, 0, di2, dj2, 0, memo2);    
    }
    int search(vector<vector<int>>& fruits, int i, int j, int di[3], int dj[3], int move_cnt, vector<vector<int>>& memo) {
        int n = fruits.size();
        if (i >= n || j >= n || i < 0 || j < 0 || (n - move_cnt < max(n - i, n - j)))
            return INT_MIN/2;
        if (i == n-1 && j == n-1) {
            return fruits[n-1][n-1];
        }
        if (memo[i][j] >= 0)
            return memo[i][j];
        int res = INT_MIN/2;
        for(int d = 0; d < 3; d++) {
            res = max(res, search(fruits, i + di[d], j + dj[d], di, dj, move_cnt+1, memo));
        }
        return memo[i][j] = res + fruits[i][j];
    }
};",1460900105
Skhirtladze,jskhirtladze,157,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {

        vector <vector <long long>> a(26, vector <long long> (26, 1000L*1000LL*1000LL*1000LL));

        for (int j=0;j<26;j++) {
            int prev=(j+25)%26;
            int next=(j+1)%26;
            a[j][prev]=previousCost[j];
            a[j][j]=0;
            a[j][next]=nextCost[j];
        }

        for (int k=0;k<26;k++)
            for (int i=0;i<26;i++)
                for (int j=0;j<26;j++)
                    a[i][j]=min(a[i][j],a[i][k]+a[k][j]);

        long long ans=0;
        for (int k=0;k<s.size();k++) {
            int x = s[k]-'a';
            int y = t[k]-'a';
            ans+=a[x][y];
        }
        return ans;
    }
};",1460872818
Skhirtladze,jskhirtladze,157,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n,int x=10) {
        if (n<x) return false;
        if (x==0) return false;
        return !canAliceWin(n-x,x-1);
    }
};",1460875377
Skhirtladze,jskhirtladze,157,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int maxn=100000+10;
        vector <vector <int>> s(maxn+1);


        vector <int> deactive(maxn+1,0);
        
        for (int j=0;j<q.size();j++)
            s[q[j][0]].push_back(q[j][1]);


        priority_queue <int> h;

        int active=0;
        int taken=0;
        
        for (int i=0;i<nums.size();i++) {

            active-=deactive[i];
            
            for (int j=0;j<s[i].size();j++)
                h.push(s[i][j]);
     

            while (!h.empty() && active<nums[i]) {
                
                int fin=h.top();
                
                if (fin<i) return -1;
                
                active++;
                deactive[fin+1]++;
                h.pop();
                taken++;
            }
            if (active<nums[i]) return -1;

        }
        return q.size()-taken;
    }
};",1460906225
Skhirtladze,jskhirtladze,157,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int n=f.size();

        int ans=0;
        for (int k=0;k<n;k++) {
            ans+=f[k][k];
            f[k][k]=0;
        }
        
        vector <vector<int>> x(n, vector <int> (n,-1000*1000*1000));
        x[n-1][0]=f[n-1][0];
        for (int k=1;k<n;k++)
            for (int i=0;i<n;i++) {
                if (i>0)     x[i][k]=max(x[i][k],x[i-1][k-1]+f[i][k]);
                             x[i][k]=max(x[i][k],x[i][k-1]+f[i][k]);
                if (i<(n-1)) x[i][k]=max(x[i][k],x[i+1][k-1]+f[i][k]);
            }
    
        vector <vector<int>> z(n, vector <int> (n,-1000*1000*1000));
        z[0][n-1]=f[0][n-1];
        for (int k=1;k<n;k++)
            for (int i=0;i<n;i++) {
                if (i>0)     z[k][i]=max(z[k][i],z[k-1][i-1]+f[k][i]);
                             z[k][i]=max(z[k][i],z[k-1][i]+f[k][i]);
                if (i<(n-1)) z[k][i]=max(z[k][i],z[k-1][i+1]+f[k][i]);
            }

        
        ans+=z[n-1][n-1];
        ans+=x[n-1][n-1];
        return ans;
    }
};",1460822160
ZZ10,zz_10,158,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const int n = 26;
        const long long INF = 1e18;
        vector<vector<long long>> cost(n, vector<long long>(n, INF));
        for(int i=0;i<n;i++) cost[i][i]=0;
        for(int i=0;i<n;i++){
            int nxt = (i+1)%n;
            int prv = (i-1+n)%n;
            cost[i][nxt] = min(cost[i][nxt], (long long)nextCost[i]);
            cost[i][prv] = min(cost[i][prv], (long long)previousCost[i]);
        }
        for(int k=0;k<n;k++) {
            for(int i=0;i<n;i++) {
                for(int j=0;j<n;j++) {
                    if(cost[i][k] + cost[k][j] < cost[i][j]){
                        cost[i][j] = cost[i][k] + cost[k][j];
                    }
                }
            }
        }
        long long total =0;
        for(int i=0;i<s.size();i++) {
            int a = s[i]-'a', b = t[i]-'a';
            total += (a == b) ? 0 : cost[a][b];
        }
        return total;
    }
};
",1460856603
ZZ10,zz_10,158,3625,cpp,"class Solution {
public:
    bool winner(int n){
        int move=10;
        bool alice=true;
        while(true){
            if(n>=move){
                n-=move;
            }
            else{
                return !alice;
            }
            move--;
            if(move<=0){
                return !alice;
            }
            alice=!alice;
        }
    }
    bool canAliceWin(int n){
        return winner(n);
    }
};
",1460857860
ZZ10,zz_10,158,3647,cpp,"class SegmentTree {
public:
    int n;
    vector<int> tr;
    vector<int> lz;

    SegmentTree(int sz) {
        n = 1;
        while(n < sz) n <<=1;
        tr.assign(2*n, 0);
        lz.assign(2*n, 0);
    }

    void build(vector<int> &d) {
        for(int i=0;i<d.size();i++) {
            tr[n+i] = d[i];
        }
        for(int i=n-1;i>=1;i--) {
            tr[i] = min(tr[2*i], tr[2*i+1]);
        }
    }

    void push(int nd, int l, int r) {
        if(lz[nd] !=0) {
            tr[nd] += lz[nd];
            if(nd < n) {
                lz[2*nd] += lz[nd];
                lz[2*nd+1] += lz[nd];
            }
            lz[nd]=0;
        }
    }

    int rmq(int nd, int l, int r, int ql, int qr) {
        push(nd, l, r);
        if(ql > r || qr < l) return INT32_MAX;
        if(ql <= l && r <= qr) return tr[nd];
        int m = (l + r) /2;
        return min(rmq(2*nd, l, m, ql, qr), rmq(2*nd+1, m+1, r, ql, qr));
    }

    void ra(int nd, int l, int r, int ql, int qr, int v) {
        push(nd, l, r);
        if(ql > r || qr < l) return;
        if(ql <= l && r <= qr) {
            lz[nd] += v;
            push(nd, l, r);
            return;
        }
        int m = (l + r)/2;
        ra(2*nd, l, m, ql, qr, v);
        ra(2*nd+1, m+1, r, ql, qr, v);
        tr[nd] = min(tr[2*nd], tr[2*nd+1]);
    }

    void decr(int ql, int qr) {
        ra(1, 0, n-1, ql, qr, -1);
    }

    int gmin(int ql, int qr) {
        return rmq(1, 0, n-1, ql, qr);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& qs) {
        int n = nums.size();
        vector<int> diff(n+1, 0);
        for(auto &q: qs){
            diff[q[0]] +=1;
            if(q[1]+1 < n) diff[q[1]+1] -=1;
        }
        vector<int> tc(n, 0);
        tc[0] = diff[0];
        for(int i=1;i<n;i++) {
            tc[i] = tc[i-1] + diff[i];
        }
        vector<int> allowed(n, 0);
        for(int i=0;i<n;i++) {
            allowed[i] = tc[i] - nums[i];
            if(allowed[i] <0) return -1;
        }
        
        sort(qs.begin(), qs.end(), [&](const vector<int> &a, const vector<int> &b) {
            if(a[1] != b[1]) return a[1] < b[1];
            return a[0] < b[0];
        });
        SegmentTree st(n);
        st.build(allowed);
        int removed =0;
        for(auto &q: qs){
            if(st.gmin(q[0], q[1]) >=1){
                removed +=1;
                st.decr(q[0], q[1]);
            }
        }
        return removed;
    }
};
",1460852854
ZZ10,zz_10,158,3648,cpp,"class Solution {
public:
  long long sum1 = 0, sum2 ,sum3;

 vector<vector<bool>> bl;
vector<vector<long long>> DP2;
vector<vector<long long>> DP3;

int n;

void ans1(vector<vector<int>>& fruits)
{
    for(int k=0; k<n; ++k)
    {
            sum1 += fruits[k][k];
            if(k != n-1)
            bl[k][k] = true;
            
    }
}

void ans2(vector<vector<int>>& fruits)
{
    for(int k=1; k<n; ++k){
            for(int j=0; j<n; ++j){
                if(bl[k][j] && j !=n-1){
                    continue;
                }
                long long max_prev = LLONG_MIN;
                
                if(j >0 && DP2[k-1][j-1] != LLONG_MIN){
                    max_prev = max(max_prev, DP2[k-1][j-1]);
                }
                if(DP2[k-1][j] != LLONG_MIN){
                    max_prev = max(max_prev, DP2[k-1][j]);
                }
                if(j <n-1 && DP2[k-1][j+1] != LLONG_MIN){
                    max_prev = max(max_prev, DP2[k-1][j+1]);
                }
                if(max_prev != LLONG_MIN){
                    DP2[k][j] = fruits[k][j] + max_prev;
                }
            }
        }
}

void ans3(vector<vector<int>>& fruits)
{
 for(int k=1; k<n; ++k){
            for(int i=0; i<n; ++i){
                if(bl[i][k] && i !=n-1){
                    continue;
                }
                long long max_prev = LLONG_MIN;
                
                if(i >0 && DP3[k-1][i-1] != LLONG_MIN){
                    max_prev = max(max_prev, DP3[k-1][i-1]);
                }
                if(DP3[k-1][i] != LLONG_MIN){
                    max_prev = max(max_prev, DP3[k-1][i]);
                }
                if(i <n-1 && DP3[k-1][i+1] != LLONG_MIN){
                    max_prev = max(max_prev, DP3[k-1][i+1]);
                }
                if(max_prev != LLONG_MIN){
                    DP3[k][i] = fruits[i][k] + max_prev;
                }
            }
        }   
}

    int maxCollectedFruits(vector<vector<int>>& fruits) {
        n = fruits.size();

        bl.resize(n, vector<bool>(n, false));

        ans1(fruits);

        

        DP2.resize(n, vector<long long>(n, LLONG_MIN));
        DP2[0][n-1] = fruits[0][n-1];

        ans2(fruits);
        
       
        
        sum2 = DP2[n-1][n-1];
        if(sum2 == LLONG_MIN){
            sum2 = 0;
        }

        

        
        DP3.resize(n, vector<long long>(n, LLONG_MIN));
        DP3[0][n-1] = fruits[n-1][0];

        ans3(fruits);
        
        
        sum3 = DP3[n-1][n-1];
        if(sum3 == LLONG_MIN){
            sum3 = 0;
        }

        
        long long total = sum1 + sum2 + sum3;
        
        total -= 2LL * fruits[n-1][n-1];
        return (int)total;
    }
};
",1460901083
himanshu dhingra,himanshudhingra,164,3591,cpp,"class Solution {
    public:

    long long forwardCost (vector<int>& nextCost, int a, int b) {
        long long ans = 0;

        if (a < b) {
            for (int i = a; i < b; i++) {
                ans += nextCost[i];
            }
        } else {
            for (int i = a; i < 26; i++) {
                ans += nextCost[i];
            }
            
            for (int i = 0; i < b; i++) {
                ans += nextCost[i];
            }
        }

        return ans;
    }


    long long backwardCost (vector<int>& nextCost, int a, int b) {
        long long ans = 0;

        if (a > b) {
            for (int i = a; i > b; i--) {
                ans += nextCost[i];
            }
        } else {
            for (int i = a; i >=0 ; i--) {
                ans += nextCost[i];
            }
            
            for (int i = 25; i > b; i--) {
                ans += nextCost[i];
            }
        }

        return ans;
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = (int) s.size();

        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;

            
            int indx = s[i]-'a';
            int indx2 = t[i] - 'a';

            long long cost = forwardCost(nextCost, indx, indx2);
            long long cost2 = backwardCost(previousCost, indx, indx2);

            ans += min(cost, cost2);
        }


        return ans;
    }
};",1460814362
himanshu dhingra,himanshudhingra,164,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0;
        int toRemove = 10;
        
        while (true){
            if (n < toRemove) {
                if (turn == 0) {
                    return false;
                }
                return true;
            }
            n -= toRemove;
            toRemove--;
            turn ^= 1;
        }
        return false;
    }
};",1460797300
himanshu dhingra,himanshudhingra,164,3647,cpp,"class Solution {
public:
    struct Compare {
        bool operator()(const pair<int, int>& a, const pair<int, int>& b) {
            if (a.second != b.second) {
                return a.second < b.second; 
            }
    
            return a.first > b.first; 
        }
    };
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {

        int n = (int) nums.size();
        int q = (int) queries.size();
        
        int ans = 0;

        sort(queries.begin(), queries.end());
        
        int j = 0;
        int pow = 0;
        // priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;
        priority_queue<int> pq;
        priority_queue<int, vector<int>, greater<int>> pq2;
        for (int i = 0; i < n; i++) {

            
            while(pq.size() && pq.top() <= i) {
                pq.pop();
            }
            
            while(pq2.size() && pq2.top() <= i) {
                pq2.pop();
                pow--;
            }

            
            while(j < q && queries[j][0] <= i) {
                pq.push(queries[j][1] + 1);
                j++;
            }

            

            while (pow < nums[i] && pq.size()) {
                int ending = pq.top(); 
                if (ending <= i) break;
                pq.pop();
                pq2.push(ending);
                pow++;
                ans++;
            }
            
            if (pow < nums[i]) {
                // cout << ""UF"" << endl;
                return -1;
            }
            
        }
        
        return q - ans;
    }
};",1460856907
himanshu dhingra,himanshudhingra,164,3648,cpp,"typedef long long ll;
class Solution {
public:
    ll dp[1001][1001];
    ll dp2[1001][1001];

    vector<pair<int,int>> moves1 = {{1, -1}, {1, 0}, {1, 1}};
    vector<pair<int,int>> moves2 = {{-1, 1}, {0, 1}, {1, 1}};

    bool isValid (int x, int y ,int n) {
        if (x < 0 || y < 0 || x>=n || y>=n) return false;
        return true;
    }

     ll helper (int row ,int col, int n, vector<vector<int>>& fruits) {
        if (row == n-1) {
            if (col == n-1) {
                return 0;
            } 
            return -1e9;
        }
        if (dp[row][col] != -1) return dp[row][col];

        dp[row][col] = -1e9;

        for (auto & it: moves1) {
            int x = row + it.first;
            int y = col + it.second;
            if (!isValid(x, y, n)) continue;
            dp[row][col] = max(dp[row][col], fruits[row][col] + helper(x, y, n, fruits));
        }


        return dp[row][col];
    }


    ll helper2 (int row ,int col, int n, vector<vector<int>>& fruits) {
        if (col == n-1) {
            if (row == n-1) {
                return 0;
            } 
            return -1e9;
        }
        if (dp2[row][col] != -1) return dp2[row][col];

        dp2[row][col] = -1e9;

        for (auto & it: moves2) {
            int x = row + it.first;
            int y = col + it.second;
            if (!isValid(x, y, n)) continue;
            dp2[row][col] = max(dp2[row][col], fruits[row][col] + helper2(x, y, n, fruits));
        }


        return dp2[row][col];
    }


    int maxCollectedFruits(vector<vector<int>>& fruits) {
        memset(dp, -1, sizeof dp);
        memset(dp2, -1, sizeof dp2);
        ll ans = 0;
        int n = (int) fruits.size();

        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }

        ans += helper(0, n-1, n, fruits);
        ans += helper2(n-1, 0, n, fruits);
        return (int)ans;
    }
};",1460901720
bothemrun,bothemrun,167,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const int alphabet = 26;
        vector<vector<long long>> forward_cost(alphabet, vector<long long>(alphabet));
        vector<vector<long long>> backward_cost(alphabet, vector<long long>(alphabet));
        for(int a=0;a<alphabet;a++){
            for(int b=0;b<alphabet;b++){
                long long cost = 0;
                int cur = a;
                while(cur != b){
                    cost += nextCost[cur];
                    cur = (cur+1)%alphabet;//forward
                }
                forward_cost[a][b] = cost;
            }
        }
        
        for(int a=0;a<alphabet;a++){
            for(int b=0;b<alphabet;b++){
                long long cost = 0;
                int cur = a;
                while(cur != b){
                    cost += previousCost[cur];
                    cur = ( (cur-1)%alphabet + alphabet )%alphabet;
                }
                backward_cost[a][b] = cost;
            }
        }
        
        long long ans = 0;
        int n = s.size();
        for(int i=0;i<n;i++){
            ans += min( forward_cost[ s[i]-'a' ][ t[i]-'a' ], backward_cost[ s[i]-'a' ][ t[i]-'a' ] );
        }
        return ans;
    }
};",1460828135
bothemrun,bothemrun,167,3625,cpp,"class Solution {
public:
    bool play(int n, int last){
        if(n<=0) return false;
        
        last--;
        if(n - last < 0){
            return false;
        }
        
        if( play(n - last, last) == false){
            return true;//opponent loses
        }else{
            return false;//opponent wins
        }
    }
    bool canAliceWin(int n) {
        return play(n, 11);
    }
};",1460807091
bothemrun,bothemrun,167,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        auto cmp_sort = [](const vector<int>& a, const vector<int>& b){
            return a[0] < b[0];
            //don't care about r_i here
        };
        sort(queries.begin(), queries.end(), cmp_sort);
        
        int min_used = 0;
        vector<int> diff(n+3, 0);
        int sweep = 0;
        auto cmp_pq = [](const int& a, const int& b){
            //max heap for right
            return a<b;//max heap, sink down
        };
        priority_queue<int, vector<int>, decltype(cmp_pq)> maxheap(cmp_pq);
        int qi = (-1);
        int qn = queries.size();
        for(int pos=0;pos<n;pos++){
            while(qi+1 < qn && queries[qi+1][0] <= pos){
                qi++;
                maxheap.push( queries[qi][1] );
            }
            
            //ok for nums[pos] + old_sweep < 0!!
            sweep += diff[pos];
            int old_sweep = sweep;
            for(int k=0;k < nums[pos] + old_sweep;k++){
                //needs nums[pos] decrements!!
                if(maxheap.size() == 0){
                    return (-1);
                }
                min_used++;
                
                int right = maxheap.top();
                maxheap.pop();
                
                if(right < pos){
                    return (-1);
                }
                
                sweep--;
                assert( right+1 < (int)diff.size() );
                diff[ right+1 ]++;
            }
        }
        return qn - min_used;
    }
};",1460882058
bothemrun,bothemrun,167,3648,cpp,"#define inf_add(a, b) ( (a==impossible || b==impossible)? impossible:(a+b) )
class Solution {
public:
    int n;
    const int notyet = (-1);
    const int impossible = INT_MIN;
    vector<vector<int>> memo;
    int no_cross(const vector<vector<int>>& fruits, int i, int j){
        if(!( 0<=i && i<n && 0<=j && j<n )){
            return impossible;
        }
        if(i==j){
            return impossible;
        }
        if(i==0){
            if(j==n-1){
                return fruits[i][j];
            }else{
                return impossible;
            }
        }
        if(j==0){
            if(i==n-1){
                return fruits[i][j];
            }else{
                return impossible;
            }
        }
        if(memo[i][j] != notyet) return memo[i][j];
        
        int last;
        if(i<j){
            //upper right
            last = max({
                no_cross(fruits, i-1, j-1),
                no_cross(fruits, i-1, j),
                no_cross(fruits, i-1, j+1),
            });
        }else{
            last = max({
                no_cross(fruits, i-1, j-1),
                no_cross(fruits, i, j-1),
                no_cross(fruits, i+1, j-1),
            });
        }
        return memo[i][j] = inf_add( fruits[i][j], last );
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        this->n = fruits.size();
        memo.resize(n, vector<int>(n, notyet));
        
        int ans = no_cross(fruits, n-1, n-2);
        ans += no_cross(fruits, n-2, n-1);
        
        for(int i=0;i<n;i++){
            ans += fruits[i][i];
        }
        return ans;
    }
};",1460908123
metaphysicalist,metaphysicalist,168,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        @cache
        def next_cost(a, b):
            if a == b:
                return 0
            return nextCost[a] + next_cost((a + 1) % 26, b)
        @cache
        def prev_cost(a, b):
            if a == b:
                return 0
            return previousCost[a] + prev_cost((a - 1) % 26, b)
        ans = 0
        for a, b in zip(s, t):
            ans += min(next_cost(ord(a)-ord('a'), ord(b)-ord('a')), prev_cost(ord(a)-ord('a'), ord(b)-ord('a')))
        return ans

        
        ",1460814979
metaphysicalist,metaphysicalist,168,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        m = 10
        for turn in range(n+1):
            if n < m:
                return turn % 2 != 0
            n -= m
            m -= 1
            ",1460801673
metaphysicalist,metaphysicalist,168,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        q = deque(sorted(queries))
        ready = []
        selected = []
        ans = 0
        for i in range(len(nums)):
            while q and q[0][0] <= i:
                heappush(ready, -q.popleft()[1])
            while selected and selected[0] < i:
                heappop(selected)
            while nums[i] > len(selected):
                if ready and -ready[0] >= i:
                    heappush(selected, -heappop(ready))
                    ans += 1
                else:
                    return -1
        return len(queries) - ans",1460854210
metaphysicalist,metaphysicalist,168,3648,python3,"class Solution:
    def maxCollectedFruits(self, grid: List[List[int]]) -> int:
        n, m = len(grid), len(grid[0])
        dp = []
        for i in range(n):
            dp.append([-inf] * m)
        dp[0][m-1] = grid[0][m-1]
        dp[n-1][0] = grid[n-1][0]
        ans = 0
        for i in range(n):
            for j in range(m):
                if i == j:
                    ans += grid[i][j]
                elif i > j and j > 0:
                    continue
                elif i < j and i > 0:
                    dp[i][j] = dp[i-1][j] + grid[i][j]
                    if j + 1 < m:
                        dp[i][j] = max(dp[i][j], dp[i-1][j+1] + grid[i][j])
                    if j - 1 >= 0:
                        dp[i][j] = max(dp[i][j], dp[i-1][j-1] + grid[i][j])

        for j in range(m):
            for i in range(n):
                if i > j and j > 0:
                    dp[i][j] = dp[i][j-1] + grid[i][j]
                    if i + 1 < n:
                        dp[i][j] = max(dp[i][j], dp[i+1][j-1] + grid[i][j])
                        # print(i, j, 1, dp[i+1][j-1], dp[i][j])
                    if i - 1 >= 0:
                        dp[i][j] = max(dp[i][j], dp[i-1][j-1] + grid[i][j])
                        # print(i, j, 2, dp[i-1][j-1], dp[i-1][j-1]+grid[i][j], grid[i][j], dp[i][j])

        return ans + dp[n-1][m-2] + dp[n-2][m-1]
                
        ",1460897039
agakishy,agakishy,174,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        conn = defaultdict(dict)
        ans = 0
        def shift(a, b):
            nonlocal conn
            if b not in conn[a]:
                a = ord(a) - ord('a')
                b = ord(b) - ord('a')
                left = right = 0
                i = a
                while i != b:
                    right += nextCost[i]
                    i = (i+1) % 26
                i = a
                while i != b:
                    left += previousCost[i]
                    i = (i+25) % 26
                conn[a][b] = min(left, right)
            return conn[a][b]

        for i in range(len(s)):
            ans += shift(s[i], t[i])
        return ans",1460816730
agakishy,agakishy,174,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones = [10-i for i in range(10)]
        curr = n
        alice_wins = [False, True]
        for i in stones:
            curr -= i
            if curr < 0:
                return alice_wins[i%2]
        return ""wft""
        ",1460801364
agakishy,agakishy,174,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        ans = [0] * (n+1)
        conn = defaultdict(list)
        for l, r in queries:
            conn[l].append(r)

        update = [0] * (n+1)
        h = []
        balance = 0
        for i in range(n):
            if i in conn:
                for r in conn[i]:
                    heapq.heappush(h, -r)
                    
            balance += update[i]
            while balance < nums[i]:
                if (not h) or (-h[0] < i):
                    return -1
                r = -heapq.heappop(h)
                balance += 1
                update[r+1] -= 1

        return len(h)",1460887057
agakishy,agakishy,174,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0
        for i in range(n):
            for j in range(n-1-i):
                fruits[i][j] = 0

        f = copy.deepcopy(fruits)
        for i in range(1, n):
            for j in range(n-1, -1, -1):
                mx = 0
                for nxt in [j-1, j, j+1]:
                    if 0 <= nxt < n:
                        mx = max(mx, fruits[i-1][nxt])
                fruits[i][j] += mx
        ans += fruits[n-1][n-1]
     
        for j in range(1, n):
            for i in range(n):
                mx = 0
                for nxt in [i-1, i, i+1]:
                    if 0 <= nxt < n:
                        mx = max(mx, f[nxt][j-1])
                f[i][j] += mx
        ans += f[n-1][n-1]
        return ans
        
            
            ",1460914807
gtushar,gtushar,175,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long i, j, n = s.size(), cost = 0, ans = 0;
        for(i = 0; i < n; ++i) {
            long long x = 0;
            char ch = s[i];
            while(ch != t[i]) {
                x += nextCost[ch - 'a'];
                // cout << ""i = "" << i << "" ch = "" << ch << "" t[i] = "" << t[i] << endl;
                if (ch == 'z') ch = 'a'; else ch = (char)(ch + 1);
            }
            long long y = 0;
            ch = s[i];
            while(ch != t[i]) {
                y += previousCost[ch - 'a'];
                // cout << ""   i = "" << i << "" ch = "" << ch << "" t[i] = "" << t[i] << endl;
                if (ch == 'a') ch = 'z'; else ch = (char)(ch - 1);
            }
            ans += min(x, y);
        }
        return ans;
    }
};",1460814465
gtushar,gtushar,175,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool f = false;
        int i = 10;
        while(n >= 0) {
            if (n >= i)
                n -= i, f = !f;
            else return f;
            --i;
        }
        return f;
    }
};",1460800658
gtushar,gtushar,175,3647,cpp,"class Solution {
public:
    class FenwickTree {
    private:
        vector<long long> BIT1, BIT2, bit;
        int n;
    public:
        FenwickTree(int size) {
            n = size;
            BIT1.resize(n + 1, 0);
            BIT2.resize(n + 1, 0);
            bit.resize(n + 1, 0);
        }
        void add(int idx, int val) {
            for (++idx; idx < n; idx += idx & -idx)
                bit[idx] += val;
        }

        void add(int l, int r, int val) {
            add(l, val);
            add(r + 1, -val);
        }

        int find(int idx) {
            int ret = 0;
            for (++idx; idx > 0; idx -= idx & -idx)
                ret += bit[idx];
            return ret;
        }
    };
    class SegmentTree {
    private:
        vector<long long> tree, lazy;
        int n;

        void propagate(int node, int start, int end) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node] * (end - start + 1);
                if (start != end) {
                    lazy[2 * node] += lazy[node];
                    lazy[2 * node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        void rangeAdd(int node, int start, int end, int l, int r, long long val) {
            propagate(node, start, end);
            if (start > r || end < l) return;
            if (start >= l && end <= r) {
                lazy[node] += val;
                propagate(node, start, end);
                return;
            }
            int mid = (start + end) / 2;
            rangeAdd(2 * node, start, mid, l, r, val);
            rangeAdd(2 * node + 1, mid + 1, end, l, r, val);
            tree[node] = tree[2 * node] + tree[2 * node + 1];
        }

        long long pointQuery(int node, int start, int end, int idx) {
            propagate(node, start, end);
            if (start == end) return tree[node];
            int mid = (start + end) / 2;
            if (idx <= mid) return pointQuery(2 * node, start, mid, idx);
            else return pointQuery(2 * node + 1, mid + 1, end, idx);
        }

    public:
        SegmentTree(int size) {
            n = size;
            tree.resize(4 * n, 0);
            lazy.resize(4 * n, 0);
        }

        void add(int l, int r, long long val) {
            rangeAdd(1, 0, n - 1, l, r, val);
        }

        long long find(int idx) {
            return pointQuery(1, 0, n - 1, idx);
        }
    };
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        sort(q.begin(), q.end());
        // cout << ""\nq = ""; for(auto v : q) cout << ""[ "" << v[0] << "", "" << v[1] << "" ]"" << endl;
        int i, j = 0, ans = 0, n = a.size(), m = q.size(), it = 0;
        // FenwickTree tree(n);
        SegmentTree tree(n);
        for(i =0 ; i < n; ++i) tree.add(i, i, a[i]);
        // cout << ""tree = ""; for(i =0 ; i < n; ++i) cout << tree.find(i) << ' '; cout << endl;
        
        auto cmp = [](const vector<int>& a, const vector<int>&b) { return a[1] < b[1]; };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);     // sorted in dec order of q[it][1]
        int used = 0;
        for(i = 0; i < n; ++i) {
            // i = elem in tree / array
            // r, it = elem in queries
            // int r = it;
            // int cur = tree.find(i);
            // cout << ""i = "" << i << "" cur = "" << cur << endl;
            // if (cur <= 0) continue;
            // while(r < m && q[r][1] < i) 
            //     ++r, ++it, ++ans;
            // while(r < m && q[r][0] <= i && q[r][1] >= i) 
            //     ++r;
            // cout << ""r = "" << r << "" it = "" << it << endl;
            // // ignore q[j]
            // for(j = it; (r - j) > cur; ++j) 
            //     ++ans;
            // cout << ""ans = "" << ans << endl;
            // // decrement range denoted by q[j]
            // for(; j < r; ++j) 
            //     tree.add(q[j][0], q[j][1], -1);
            // it = r;
            
            int cur = tree.find(i);
            // cout << ""i = "" << i << "" cur = "" << cur << endl;
            if (cur <= 0) continue;
            while(it < m && q[it][0] <= i) {
                pq.push(vector<int>{q[it][0], q[it][1], it});
                ++it;
            }
            // cout << ""s = "" ; for(auto v:s) cout << ""( "" << v[0] << "", "" << v[1] << ""), ""; cout << endl;
            while(cur--) {
                if (pq.empty()) return -1;
                auto v = pq.top();
                pq.pop();
                // cout << ""v = "" << v[0] << ' ' << v[1] << endl;
                if (i >= v[0] && i <= v[1]) {
                    tree.add(v[0], v[1], -1);
                    ++used;
                }
            }
        }
        // if (it < m) ans += m - it;
        for(i =0 ; i < n; ++i) if (tree.find(i) > 0) return -1;
        // return ans;
        return m - used;
    }
};",1460898708
gtushar,gtushar,175,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int i, j, n = a.size();
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
        int ans = 0;
        for(i = 0; i < n; ++i) ans += a[i][i];
        
        dp[0][n - 1] = a[0][n - 1];
        for(i = 1; i < n; ++i) {
            for(j = max(n - 1 - i, i); j < n; ++j) {
                dp[i][j] = (i == j ? 0 : a[i][j]) + max({ dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1] });
            }
        }
        int x = 0;
        for(i = 0; i < n; ++i) for(j = 0; j < n; ++j) x = max(x, dp[i][j]);
        ans += x;
                                                        
        dp = vector<vector<int>>(n + 1, vector<int>(n + 1, 0));
        dp[n - 1][0] = a[n - 1][0];
        for(j = 1; j < n; ++j) {
            for(i = max(n - 1 - j, j); i < n; ++i) {
                dp[i][j] = (i == j ? 0 : a[i][j]) + max({ dp[i - 1][j - 1], dp[i][j - 1], dp[i + 1][j - 1] });
            }
        }

        x = 0;
        for(i = 0; i < n; ++i) for(j = 0; j < n; ++j) x = max(x, dp[i][j]);
        ans += x;
                                                        
        return ans;
    }
};",1460909522
6cdh,6cdh,176,3591,racket,"(define (shift-distance s t nextCost previousCost)
  (vec! nextCost previousCost)

  (define/cache (min-shift-distance sc tc direction)
    (cond
      [(= sc tc) 0]
      [(= 1 direction)
       (+ (aref nextCost sc)
          (min-shift-distance (modulo (add1 sc) 26) tc direction))]
      [(= -1 direction)
       (+ (aref previousCost sc)
          (min-shift-distance (modulo (sub1 sc) 26) tc direction))]))

  (for/sum ([sc s]
            [tc t])
    (define si (lower-char->integer sc))
    (define ti (lower-char->integer tc))
    (min (min-shift-distance si ti 1)
         (min-shift-distance si ti -1))))


(require syntax/parse/define)

(define-syntax aref
  (syntax-rules ()
    [(_ arr) arr]
    [(_ arr i dims ...)
     (aref (vector-ref arr i) dims ...)]))

(define (lower-char->integer c)
  (- (char->integer c) (char->integer #\a)))

(define-syntax-parser define/cache
  [(_ (fname:id args:id ...)
      body ...)
   #'(define fname
       (letrec ([cache (make-hash)]
                [fn
                 ( (args ...)
                   body ...)]
                [fname
                 ( (args ...)
                   (define key (list args ...))
                   (cond [(hash-has-key? cache key)
                          (hash-ref cache key)]
                         [else
                          (define val (fn args ...))
                          (hash-set! cache key val)
                          val]))])
         fname))])

(define-syntax-parse-rule (vec! var:id ...)
  (let ()
    (vec1! var) ...))

(define-syntax-parse-rule (vec1! var:id)
  (set! var
        (cond [(string? var) (list->vector (string->list var))]
              [(list? var) (list->vector var)]
              [else var])))

",1460822515
6cdh,6cdh,176,3625,racket,"(define (can-alice-win n)
  (define (play alice? k n)
    (if (< n k)
        (not alice?)
        (play (not alice?) (sub1 k) (- n k))))

  (play #t 10 n))

",1460806999
6cdh,6cdh,176,3647,racket,"(require data/heap)

(define (max-removal nums queries)
  (define n (length nums))
  (define queries-vec (make-vector n '()))

  (for ([q queries])
    (match-define (list l r) q)
    (aupd! queries-vec l ( (old) (cons q old))))

  (define (maxr a b)
    (>= (cadr a) (cadr b)))

  (define (greedy-add! i v)
    (cond
      [(>= cur v) (void)]
      [(heap-empty? h)
       (set! ok? #f)]
      [else
       (define query (heap-max h))
       (heap-remove-max! h)
       (match-define (list l r) query)
       (cond [(< r i)
              (set! ok? #f)]
             [else
              (aupd! delta l add1)
              (set! has (add1 has))
              (set! cur (add1 cur))
              (aupd! delta (add1 r) sub1)
              (greedy-add! i v)])]))

  (define h (make-heap maxr))
  (define delta (make-vector (add1 n) 0))
  (define cur 0)
  (define has 0)
  (define ok? #t)
  (for ([v nums]
        [d delta]
        [qs queries-vec]
        [i (in-naturals 0)])
    (set! cur (+ cur d))
    (for ([q qs])
      (heap-add! h q))
    (greedy-add! i v))
  (if ok? (- (length queries) has) -1))


(require data/heap)

(define-syntax aref
  (syntax-rules ()
    [(_ arr) arr]
    [(_ arr i dims ...)
     (aref (vector-ref arr i) dims ...)]))

(define-syntax aset!
  (syntax-rules ()
    [(_ arr dim new-val)
     (vector-set! arr dim new-val)]
    [(_ arr dim1 dims ... new-val)
     (aset! (vector-ref arr dim1) dims ... new-val)]))

(define-syntax-rule (aupd! arr dims ... updater)
  (aset! arr dims ... (updater (aref arr dims ...))))

(define heap-max heap-min)

(define heap-remove-max! heap-remove-min!)

(define (heap-empty? h)
  (= 0 (heap-count h)))

",1460864998
6cdh,6cdh,176,3648,racket,"(define (max-collected-fruits fruits)
  (set! fruits (list2d->vector2d fruits))
  (define n (vector-length fruits))
  (define topleft 0)
  (for ([i n])
    (set! topleft (+ topleft (aref fruits i i)))
    (aset! fruits i i 0))

  (define -inf #e-1e19)

  (define/cache (max-bottom-left i j)
    (cond [(and (= i (sub1 n)) (= j (sub1 n))) 0]
          [(not (and (< -1 i n) (< -1 j n))) -inf]
          [(< i j) -inf]
          [else
           (+ (aref fruits i j)
              (max (max-bottom-left (sub1 i) (add1 j))
                   (max-bottom-left i (add1 j))
                   (max-bottom-left (add1 i) (add1 j))))]))

  (define/cache (max-top-right i j)
    (cond [(and (= i (sub1 n)) (= j (sub1 n))) 0]
          [(not (and (< -1 i n) (< -1 j n))) -inf]
          [(> i j) -inf]
          [else
           (+ (aref fruits i j)
              (max (max-top-right (add1 i) (sub1 j))
                   (max-top-right (add1 i) j)
                   (max-top-right (add1 i) (add1 j))))]))

  (+ topleft (max-bottom-left (sub1 n) 0) (max-top-right 0 (sub1 n))))


(require syntax/parse/define)

(define-syntax aref
  (syntax-rules ()
    [(_ arr) arr]
    [(_ arr i dims ...)
     (aref (vector-ref arr i) dims ...)]))

(define-syntax aset!
  (syntax-rules ()
    [(_ arr dim new-val)
     (vector-set! arr dim new-val)]
    [(_ arr dim1 dims ... new-val)
     (aset! (vector-ref arr dim1) dims ... new-val)]))

(define (list2d->vector2d lst)
  (list->vector (map list->vector lst)))

(define-syntax-parser define/cache
  [(_ (fname:id args:id ...)
      body ...)
   #'(define fname
       (letrec ([cache (make-hash)]
                [fn
                 ( (args ...)
                   body ...)]
                [fname
                 ( (args ...)
                   (define key (list args ...))
                   (cond [(hash-has-key? cache key)
                          (hash-ref cache key)]
                         [else
                          (define val (fn args ...))
                          (hash-set! cache key val)
                          val]))])
         fname))])

",1460910117
Smit Mandavia,l_returns,177,3591,cpp,"class Solution {

    
    long long distance(int i, int j, vector<int>& nc, vector<int>& pc) {
        long long ans = 0;
        if(i<j) {
            for(int k=i;k<j;k++) {
                ans+=nc[k];
            }        
        } else {
            for(int k=i;k>j;k--) {
                ans+=pc[k];
            }
        }
        return ans;
    }
    

public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long ans = 0;
        for(int i=0;i<26;i++) {
            nextCost.push_back(nextCost[i]);
            previousCost.push_back(previousCost[i]);
        }
        for(int i=0;i<n;i++) {
            int x = s[i]-'a';
            int y = t[i]-'a';
            if(x<y) {
                ans+=min(distance(x,y,nextCost,previousCost),distance(x+26,y,nextCost,previousCost));
            } else {
                ans+=min(distance(x,y,nextCost,previousCost),distance(x,y+26,nextCost,previousCost)); 
            }
        }
        return ans;
    }
};",1460815463
Smit Mandavia,l_returns,177,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int start=10;
        int turn = 0;
        while(n>=start) {
            n-=start;
            turn++;
            start--;
        }
        if(turn%2==0) {
            return false;            
        }
        return true;
    }
};",1460796658
Smit Mandavia,l_returns,177,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& qr) {
        sort(qr.begin(),qr.end());
        int ans = qr.size();
        int j = 0;
        int n = nums.size();
        priority_queue<int> pq;
        int curr=0;
        int dec[n+1];
        fill(dec,dec+n+1,0);
        for(int i=0;i<n;i++) {
            while(j<qr.size() && qr[j][0]==i) {
                pq.push(qr[j][1]);
                j++;
            }
            curr-=dec[i];
            while(pq.size()>0 && nums[i]>curr) {
                if(pq.top()<i) {
                    pq.pop();
                    continue;
                } 
                dec[pq.top()+1]++;
                curr++;
                pq.pop();
                ans--;
            }
            if(nums[i]>curr)
                return -1;
        }
        return ans;
    }
};",1460843833
Smit Mandavia,l_returns,177,3648,cpp,"class Solution {
    int n;

    int solve1(vector<vector<int>>&cp_fr) {
        int dp[n][n];
        for(int i=0;i<n;i++) {
            fill(dp[i],dp[i]+n,0);
            for(int j=n-1;j>=n-1-i;j--) {
                dp[i][j]=cp_fr[i][j];
                if(i==0)
                    continue;
                int maxi = 0;
                for(int del=-1;del<=1;del++) {
                    if(j+del>=0 && j+del<n) {
                        maxi=max(dp[i-1][j+del],maxi);
                    }
                }
                dp[i][j]+=maxi;
            }
        }
        int ans = dp[n-1][n-1];
        int x=n-1, y=n-1;
        while(x>0) {
            dp[x][y]-=cp_fr[x][y];
            cp_fr[x][y]=0;
            int final = dp[x][y];
            int del;
            for(del=1;del>=-1;del--) {
                if(y+del>=0 && y+del<n && dp[x-1][y+del]==dp[x][y]) {
                    y=y+del;
                    x--;
                    break;
                }
            }
            assert(del<=1);
        }
        cp_fr[x][y]=0;
        return ans;
    }

    int solve2(vector<vector<int>>&cp_fr) {
        int dp[n][n];
        for(int i=0;i<n;i++) 
            fill(dp[i],dp[i]+n,0);
        
        for(int j=0;j<n;j++) {    
            for(int i=n-1;i>=n-1-j;i--) {
                dp[i][j]=cp_fr[i][j];
                if(j==0)
                    continue;
                int maxi = 0;
                for(int del=-1;del<=1;del++) {
                    if(i+del>=0 && i+del<n) {
                        maxi=max(dp[i+del][j-1],maxi);
                    }
                }
                dp[i][j]+=maxi;
            }
        }
        int ans = dp[n-1][n-1];
        int x=n-1, y=n-1;
        while(y>0) {
            dp[x][y]-=cp_fr[x][y];
            cp_fr[x][y]=0;
            int final = dp[x][y];
            int del;
            for(del=1;del>=-1;del--) {
                if(x+del>=0 && x+del<n && dp[x+del][y-1]==dp[x][y]) {
                    x=x+del;
                    y--;
                    break;
                }
            }
            assert(del<=1);
        }
        cp_fr[x][y]=0;
        return ans;
    }


public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        n=fruits.size();
        int ans = 0;
        for(int i=0;i<n;i++) {
            ans+=fruits[i][i];
            fruits[i][i]=0;
        }
        vector<vector<int>> cp = fruits;

        int ans2 = solve1(fruits) + solve2(fruits);
        fruits = cp;
        int ans3 = solve2(fruits) + solve1(fruits);
        return ans+max(ans2,ans3);
    }
};",1460894207
Ayush Saluja,ayuchitsaluja8,178,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long cost = 0 ;
        for(int i=0;i<s.size();++i)if(s[i]!=t[i]){
            long long c1 = 0 , c2 = 0 ;
            for(int x=s[i]-'a',y=t[i]-'a';(x%26)!=y;++x)c1+=nextCost[x%26];
            for(int x=s[i]-'a',y=t[i]-'a';((x+26)%26)!=y;--x)c2+=previousCost[(x+26)%26];
            cost += min(c1,c2);
        }
        return cost;
    }
};",1460861479
Ayush Saluja,ayuchitsaluja8,178,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i=10,x=0;
        for(;i<=n;--i)n-=i,x^=1;
        return x == 1;
    }
};",1460854134
Ayush Saluja,ayuchitsaluja8,178,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(begin(queries), end(queries));
        priority_queue<int> mp;
        const int n = nums.size(), m = queries.size();
        int ans = 0 ;
        vector<int> torem(n+1,0);
        for(int i=0,j=0,tt=0;i<n;++i){
            for(;j<m && queries[j][0]==i;++j)mp.push(queries[j][1]);
            tt -= torem[i];
            for(;tt<nums[i] && !mp.empty() && mp.top()>=i;mp.pop()){
                ++ans;
                ++tt;
                torem[mp.top()+1]++;
            }
            if(tt<nums[i])return -1;
        }
        return m-ans;
    }
};",1460884332
Ayush Saluja,ayuchitsaluja8,178,3648,cpp,"class Solution {
public:
    int solve(vector<vector<int>>&mat){
        int ans = 0,n=mat.size();
        vector<vector<int>> dp(n,vector<int>(n,0));

        dp[0][n-1] = mat[0][n-1];
        for(int row=1;row<n;++row){
            for(int col=n-1;col>=n-row-1;--col){
                int mxn = 0;
                for(int c: {col-1,col,col+1})if(c>=0 && c<n){
                    mxn = max(mxn, dp[row-1][c]);
                }
                dp[row][col] = mat[row][col] + mxn;
            }
        }
        
        return dp[n-1][n-1];
    }
    int maxCollectedFruits(vector<vector<int>>& mat) {
        int n = mat.size(),ans=0;
        for(int i=0;i<n;++i){
            ans += mat[i][i];
            mat[i][i] = 0;
        }
        ans += solve(mat);

        for(int i=0;i<n;++i){
            for(int j=0;j<n;++j){
                if(i>j){
                    swap(mat[i][j], mat[j][i]);
                }
            }
        }
        ans += solve(mat);
        return ans;
    }
};",1460911116
hanbro0112,hanbro0112,181,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        prev = list(accumulate(previousCost, initial=0))
        nxt = list(accumulate(nextCost, initial=0))
        ans = 0
        for c1, c2 in zip(s, t):
            a, b = ord(c1) - 97, ord(c2) - 97
            if a < b:
                ans += min(nxt[b] - nxt[a], prev[a + 1] + prev[-1] - prev[b + 1])
            elif a > b:
                ans += min(prev[a + 1] - prev[b + 1], nxt[-1] - nxt[a] + nxt[b])
        return ans",1460827229
hanbro0112,hanbro0112,181,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        ans = 0
        d = 10
        while n >= d:
            n -= d
            d -= 1
            ans ^= 1
        return bool(ans)",1460801767
hanbro0112,hanbro0112,181,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort(key=lambda x: (x[0], -x[1]))
        n = len(nums)
        prefix = [0] * (n + 1)
        j = s = 0
        q = []
        for i, x in enumerate(nums):
            s += prefix[i]
            while j < len(queries) and queries[j][0] == i:
                heappush(q, -queries[j][1])
                j += 1
            while q and s < x:
                while q and -q[0] < i:
                    heappop(q)
                if q:
                    r = -heappop(q)
                    prefix[r + 1] -= 1
                    s += 1
                
            if s < x:
                return -1
            
        return len(queries) - j + len(q)",1460907056
hanbro0112,hanbro0112,181,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        if n == 2:
            return sum(sum(i) for i in fruits)
        if n == 3:
            return sum(sum(i) for i in fruits) - fruits[0][1] - fruits[1][0]
        
        ans = 0
        # (0, 0)
        for i in range(n):
            ans += fruits[i][i]
        # (n - 1, 0)
        prev = [0] * n
        for j in range(n - 1):
            #   * 
            # * * * 
            nxt = [0] * n
            for i in range(min(n - (j + 1) , j + 1)):
                idx = n - 1 - i
                nxt[idx] = fruits[idx][j] + max(prev[idx - 1: min(n, idx + 2)])
            prev = nxt
        ans += prev[-1]
        # (0, n - 1)
        prev = [0] * n
        for i in range(n - 1):
            #     *
            #   * *
            #     *
            nxt = [0] * n
            for j in range(min(n - (i + 1) , i + 1)):
                idx = n - 1 - j
                nxt[idx] = fruits[i][idx] + max(prev[idx - 1: min(n, idx + 2)])
            prev = nxt
        ans += prev[-1]
        return ans
                ",1460894353
Ivan Vasilenko,8symbols,182,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        @cache
        def dp_left(src, dest):
            if src == dest:
                return 0
            return previousCost[src] + dp_left((src - 1) % len(string.ascii_lowercase), dest)

        @cache
        def dp_right(src, dest):
            if src == dest:
                return 0
            return nextCost[src] + dp_right((src + 1) % len(string.ascii_lowercase), dest)

        @cache
        def dp(src, dest):
            if src == dest:
                return 0
            src, dest = ord(src) - ord('a'), ord(dest) - ord('a')
            return min(dp_left(src, dest), dp_right(src, dest))

        return sum(dp(a, b) for a, b in zip(s, t))",1460812529
Ivan Vasilenko,8symbols,182,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        is_alice_move = True
        stones = 10

        while n != 0 and stones <= n:
            n -= stones
            stones -= 1
            is_alice_move = not is_alice_move

        return not is_alice_move
",1460800393
Ivan Vasilenko,8symbols,182,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries = sorted(queries, key=lambda x: (x[0], -x[1]))

        ends = [0] * (len(nums) + 1)
        current_removes = 0
        used_queries = 0
        next_query_index = 0
        heap = []

        for i in range(len(nums)):
            current_removes -= ends[i]

            while next_query_index != len(queries) and queries[next_query_index][0] <= i:
                heapq.heappush(heap, -queries[next_query_index][1])
                next_query_index += 1

            while nums[i] > current_removes:
                if not heap or -heap[0] < i:
                    return -1
                end = -heapq.heappop(heap)
                current_removes += 1
                ends[end + 1] += 1
                used_queries += 1

        return len(queries) - used_queries",1460907474
Ivan Vasilenko,8symbols,182,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        first = sum(fruits[i][i] for i in range(n))

        @cache
        def bottom_dp(i, j, moves):
            if i == j == n - 1:
                return 0

            if not (i < j < n and 0 <= i < n) or n - 1 - j > moves:
                return -inf

            return fruits[i][j] + max(
                bottom_dp(i + 1, j - 1, moves - 1),
                bottom_dp(i + 1, j, moves - 1),
                bottom_dp(i + 1, j + 1, moves - 1),
            )

        second = bottom_dp(0, n - 1, n - 1)
        bottom_dp.cache_clear()

        @cache
        def right_dp(i, j, moves):
            if i == j == n - 1:
                return 0

            if not (j < i < n and 0 <= j < n) or n - 1 - i > moves:
                return -inf

            return fruits[i][j] + max(
                right_dp(i - 1, j + 1, moves - 1),
                right_dp(i, j + 1, moves - 1),
                right_dp(i + 1, j + 1, moves - 1),
            )

        third = right_dp(n - 1, 0, n - 1)
        return first + second + third",1460860720
Oleksandr,Oleks_V,186,3591,csharp,"public class Solution {
    public long ShiftDistance(string s, string t, int[] nextCost, int[] previousCost) {
        var ret = 0L;
        for (var i = 0; i < s.Length; i++) {
            var forward = ShiftForward(s[i] - 'a', t[i] - 'a', nextCost);
            var backward = ShiftBackward(s[i] - 'a', t[i] - 'a', previousCost);
            ret += Math.Min(forward, backward);
        }
        return ret;
    }

    private Dictionary<(int, int), long> fcache = new Dictionary<(int, int), long>();
    private long ShiftForward(int from, int to, int[] cost) {
        if (from == to) return 0;
        if (fcache.ContainsKey((from, to))) return fcache[(from, to)];
        var ret = cost[from] + ShiftForward((from + 1) % 26, to, cost);
        fcache.Add((from, to), ret);
        return ret;
    }

    private Dictionary<(int, int), long> bcache = new Dictionary<(int, int), long>();
    private long ShiftBackward(int from, int to, int[] cost) {
        if (from == to) return 0;
        if (bcache.ContainsKey((from, to))) return bcache[(from, to)];
        var ret = cost[from] + ShiftBackward((from + 25) % 26, to, cost);
        bcache.Add((from, to), ret);
        return ret;
    }
}",1460819135
Oleksandr,Oleks_V,186,3625,csharp,"public class Solution {
    public bool CanAliceWin(int n) {
        var ret = false;
        var rem = 10;
        while (n >= rem) {
            n -= rem;
            rem--;
            ret = !ret;
        }
        return ret;
    }
}",1460797166
Oleksandr,Oleks_V,186,3647,csharp,"public class Solution {
    public int MaxRemoval(int[] nums, int[][] queries) {
        queries = queries.OrderBy(q => q[0]).ThenByDescending(q => q[1]).ToArray();
        var arr = new int[nums.Length + 1];
        var heap = new List<int[]>();
        var qp = 0;
        var cur = 0;
        //var ret = 0;
        for (var i = 0; i < nums.Length; i++) {
            /*while (heap.Any() && heap[0][1] < i) {
                Pop(heap);
                ret++;
            }*/
            cur += arr[i];
            while (cur < nums[i] && (heap.Any() && heap[0][1] >= i || qp < queries.Length && queries[qp][0] == i)) {
                cur++;
                var canTakeHeap = heap.Any() && heap[0][1] >= i;
                var canTakeQuery = qp < queries.Length && queries[qp][0] == i;
                if (!canTakeHeap) {
                    arr[queries[qp++][1] + 1]--;
                }
                else if (!canTakeQuery) {
                    arr[Pop(heap)[1] + 1]--;
                }
                else {
                    if (heap[0][1] > queries[qp][1]) {
                        arr[Pop(heap)[1] + 1]--;
                    }
                    else {
                        arr[queries[qp++][1] + 1]--;
                    }
                }
                /*if (!heap.Any() && queries[qp][0] == i) {
                    arr[queries[qp++][1] + 1]--;
                }
                else if (heap[0][1] >= i && qp == queries.Length) {
                    arr[Pop(heap)[1] + 1]--;
                }
                else {
                    if (heap[0][1] > queries[qp][1]) {
                        arr[Pop(heap)[1] + 1]--;
                    }
                    else {
                        arr[queries[qp++][1] + 1]--;
                    }
                }*/
            }
            //Console.WriteLine($""i: {i}; cur: {cur}; arr: {string.Join("","", arr)}"");
            if (cur < nums[i]) return -1;
            while (qp < queries.Length && queries[qp][0] == i) {
                Push(heap, queries[qp++]);
            }
        }
        //ret += heap.Count();
        //return ret;
        return heap.Count();
    }

    private void Push(List<int[]> heap, int[] v) {
        heap.Add(v);
        var cur = heap.Count() - 1;
        var parent = (cur - 1) / 2;
        while (cur != parent && heap[cur][1] > heap[parent][1]) {
            var t = heap[cur];
            heap[cur] = heap[parent];
            heap[parent] = t;
            cur = parent;
            parent = (cur - 1) / 2;
        }
    }

    private int[] Pop(List<int[]> heap) {
        var ret = heap[0];
        heap[0] = heap.Last();
        heap.RemoveAt(heap.Count() - 1);
        var cur = 0;
        var left = 1;
        while (left < heap.Count()) {
            var swap = cur;
            if (heap[left][1] > heap[swap][1]) swap = left;
            if (left + 1 < heap.Count() && heap[left + 1][1] > heap[swap][1]) swap = left + 1;
            if (swap == cur) break;
            var t = heap[swap];
            heap[swap] = heap[cur];
            heap[cur] = t;
            cur = swap;
            left = cur * 2 + 1;
        }
        return ret;
    }
}",1460907939
Oleksandr,Oleks_V,186,3648,csharp,"public class Solution {
    public int MaxCollectedFruits(int[][] fruits) {
        var ret = 0;
        var n = fruits.Length;
        for (var i = 0; i < n; i++) {
            ret += fruits[i][i];
            fruits[i][i] = 0;
        }

        var cur = new int[n];
        cur[n - 1] = fruits[n - 1][0];
        for(var col = 0; col < n - 1; col++) {
            var next = new int[n];
            var width = Math.Min(col, n - 2 - col);
            for (var row = n - 1; row >= n - 1 - width; row--) {
                next[row] = Math.Max(next[row], cur[row] + fruits[row][col + 1]);
                next[row - 1] = Math.Max(next[row - 1], cur[row] + fruits[row - 1][col + 1]);
                if (row < n - 1) next[row + 1] = Math.Max(next[row + 1], cur[row] + fruits[row + 1][col + 1]);
            }
            cur = next;
        }
        ret += cur.Last();

        cur = new int[n];
        cur[n - 1] = fruits[0][n - 1];
        for(var row = 0; row < n - 1; row++) {
            var next = new int[n];
            var width = Math.Min(row, n - 2 - row);
            for (var col = n - 1; col >= n - 1 - width; col--) {
                next[col] = Math.Max(next[col], cur[col] + fruits[row + 1][col]);
                next[col - 1] = Math.Max(next[col - 1], cur[col] + fruits[row + 1][col - 1]);
                if (col < n - 1) next[col + 1] = Math.Max(next[col + 1], cur[col] + fruits[row + 1][col + 1]);
            }
            cur = next;
        }
        ret += cur.Last();
        return ret;
    }
}",1460856403
wellway,wellway,187,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long>> mp(26,vector<long>(26,100000000000));
        
        nextCost.insert(nextCost.end(),nextCost.begin(),nextCost.end());
        previousCost.insert(previousCost.end(),previousCost.begin(),
            previousCost.end());
        
        for(int i = 0;i<26;i++){
            long sum = 0;
            mp[i][i] = 0; 
            for(int j = i+1;j<i+26;j++){
                sum += nextCost[(j-1)%26];
                // cout<<i<<' '<<j<<endl;
                mp[i][j%26] = min(mp[i][j%26], sum);
            }
        }
        for(int i = 26;i<52;i++){
            long sum = 0;
            for(int j = i-1;j>i-26;j--){
                sum += previousCost[(j+1)%26];
                mp[i%26][j%26] = min(mp[i%26][j%26],sum);
            }
        }
        //     for(int )
            
        //     for(int j= i+1;j!=i;j++,j%=26){
        //         j%=26;
        //         sum += nextCost[j];
        //         mp[i][j] = sum;
        //         cout<<i<<' '<<j<<' '<<mp[i][j]<<endl;
        //     }
        //     sum = 0;
        //     for(int j = i-1;j!=i;j--,j = (j+26)%26){
        //         j = (j+26)%26;
        //         sum += previousCost[j];
        //         mp[i][j] = min(mp[i][j], sum);
        //         cout<<i<<' '<<j<<' '<<mp[i][j]<<endl;
        //     }
        // }
        long long ans = 0;
        for(int i=0;i<s.size();i++){
            if(s[i]!=t[i]){
                ans += 1ll*mp[s[i]-'a'][t[i]-'a'];
            }
        }
        return ans;
    }
};",1460854840
wellway,wellway,187,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cur = 0;
        int tor = 10;
        while(n){
            if(n >= tor){
                n-=tor;
                cur^=1;
            }
            else{
                return cur;
            }
            tor--;
        }
        return cur;
    }
};",1460797021
wellway,wellway,187,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(),queries.end(),[](vector<int> &a, vector<int> &b){
            if(a[0]==b[0]){
                return a[1]<b[1];
            }
            return a[0]<b[0];
        });
        multiset<int> av, used;
        int q = 0;
        int ans = 0;
        for(int i = 0;i<nums.size();i++){
            while(av.size() && *(av.begin())<i){
                av.erase(av.find(*av.begin()));
                ans++;
            }
            while(used.size() && *(used.begin())<i){
                used.erase(used.find(*used.begin()));
            }
            while(q<queries.size() && queries[q][0]<=i){
                av.insert(queries[q][1]);
                q++;
            }
            while(nums[i]>used.size()){
                if(av.size()==0){
                    return -1;
                }
                used.insert(*av.rbegin());
                av.erase(av.find(*av.rbegin()));
            }
        }
        return ans+av.size();
    }
};",1460873926
wellway,wellway,187,3648,cpp,"class Solution {
public:
    bool check(int i, int j, int n){
        if(i < n && j < n){
            return 1;
        }
        return 0;
    }
    int cal(vector<vector<int>> &fruits){
        vector<vector<int>> nex = {{1,-1},{1,0},{1,1}};
        vector<vector<int>> pans(fruits);
        int n = fruits.size();
        vector<vector<int>> vis(n,vector<int>(n));
        vis[0][n-1] = 1;
        int ans = 0;
        for(int i = 0;i<n;i++){
            for(int j = 0;j<n;j++){
                if(j>i && vis[i][j]==1){
                    ans = max(ans, pans[i][j]);
                    for(int k = 0;k<3;k++){
                        int nx = nex[k][0]+i;
                        int ny = nex[k][1]+j;
                        if(check(nx, ny, n)){
                            vis[nx][ny] = 1;
                            pans[nx][ny] = max(pans[nx][ny], 
                                pans[i][j]+fruits[nx][ny]);
                        }
                    }
                }
            }
        }
        return ans;
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int a = cal(fruits);
        vector<vector<int>> nf(fruits);
        for(int i = 0;i<fruits.size();i++){
            for(int j = 0;j<fruits.size();j++){
                nf[i][j]=fruits[j][i];
            }
        }
        int b = cal(nf);
        int c = 0;
        for(int i=0;i<fruits.size();i++){
            c+=fruits[i][i];
        }
        return a+b+c;
    }
};",1460908087
u50UoHd3Oy,u50UoHd3Oy,190,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();

        for (int i = 0; i < n; i++) {
            int diff = abs(t[i] - s[i] + 26) % 26;
            int prevDiff = 26 - diff;

            long nCost = 0;
            long pCost = 0;

            int j = s[i] - 'a';
            for (int k = 1; k <= diff; k++) {
                nCost += nextCost[j];
                j = (j + 1 + 26) % 26;
            }

            j = s[i] - 'a';
            for (int k = 1; k <= prevDiff; k++) {
                pCost += previousCost[j];
                j = (j - 1 + 26) % 26;
            }

            ans += min(nCost, pCost);
        }

        return ans;
    }
};",1460818760
u50UoHd3Oy,u50UoHd3Oy,190,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; i >= 1; i--) {
            if (n >= i) {
                n -= i;
            } else {
                if (i % 2) return true;
                else return false;
            }
        }

        return true;
    }
};",1460797914
u50UoHd3Oy,u50UoHd3Oy,190,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> eps(n);
        for (int i = 0; i < queries.size(); i++) {
            int l = queries[i][0];
            int r = queries[i][1];

            eps[l].push_back(r);
        }

        multiset<int> notUsed;
        int cur = 0;
        vector<int> ends(n + 1, 0);
        for (int i = 0; i < n; i++) {
            cur -= ends[i];
            
            while (eps[i].size()) {
                notUsed.insert(eps[i].back());
                eps[i].pop_back();
            }

            while (cur < nums[i] && notUsed.size()) {
                int last = *notUsed.rbegin();

                if (last < i) break;
                cur++;
                ends[last + 1]++;
                notUsed.erase(notUsed.find(last));
            }

            if (cur < nums[i]) {
                return -1;
            }
        }

        return (int)notUsed.size();
    }
};",1460851621
u50UoHd3Oy,u50UoHd3Oy,190,3648,cpp,"class Solution {
public:
    bool ok(int x, int y, int sx, int sy, int n) {
        if (x < 0 || x >= n) return false;
        if (y < 0 || y >= n) return false;

        int sd = max(abs(x - sx), abs(y - sy)) + max(abs(x - (n - 1)), abs(y - (n - 1)));
        return sd == (n - 1);
    }

    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }

        vector<vector<int>> dp1(n, vector<int>(n, 0));
        dp1[n - 1][0] = fruits[n - 1][0];
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < n; i++) {
                if (ok(i, j, n - 1, 0, n)) {
                    if (ok(i, j - 1, n - 1, 0, n)) {
                        dp1[i][j] = max(dp1[i][j], dp1[i][j - 1] + fruits[i][j]);
                    }

                    if (ok(i - 1, j - 1, n - 1, 0, n)) {
                        dp1[i][j] = max(dp1[i][j], dp1[i - 1][j - 1] + fruits[i][j]);
                    }

                    if (ok(i + 1, j - 1, n - 1, 0, n)) {
                        dp1[i][j] = max(dp1[i][j], dp1[i + 1][j - 1] + fruits[i][j]);
                    }
                }
            }
        }

        vector<vector<int>> dp2(n, vector<int>(n, 0));
        dp2[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (ok(i, j, 0, n - 1, n)) {
                    if (ok(i - 1, j - 1, 0, n - 1, n)) {
                        dp2[i][j] = max(dp2[i][j], dp2[i - 1][j - 1] + fruits[i][j]);
                    }

                    if (ok(i - 1, j, 0, n - 1, n)) {
                        dp2[i][j] = max(dp2[i][j], dp2[i - 1][j] + fruits[i][j]);
                    }

                    if (ok(i - 1, j + 1, 0, n - 1, n)) {
                        dp2[i][j] = max(dp2[i][j], dp2[i - 1][j + 1] + fruits[i][j]);
                    }
                }
            }
        }

        ans += (dp1[n - 1][n - 1] + dp2[n - 1][n - 1]);

        return ans;
    }
};",1460909005
Dhiraj Patil,dhirajpatil2346,191,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost) 
    {
        vector<vector<long long>> vpf(26, vector<long long> (26)), vpb;
        vpb = vpf;
        for(int i = 0 ; i < 26 ; i++)
            for(int j = 0 ; j < 26 ; j++)
            {
                int k = i;
                while(true)
                {
                    if(k==j)
                        break;
                    long long z = nextCost[k];
                    vpf[i][j] += z;
                    k++;
                    k%=26;
                }
            }
        for(int i = 0 ; i < 26 ; i++)
            for(int j = 0 ; j < 26 ; j++)
            {
                int k = i ;
                while(true)
                {
                    if(k==j)
                        break;
                    long long z = prevCost[k];
                    vpb[i][j]+= z;
                    k--;
                    if(k==-1)
                        k = 25;
                }
            }
        long long ans = 0;
        for(int i = 0 ; i < s.size() ; i++)
        {
            int a = s[i]  -'a';
            int b = t[i] - 'a';
            ans += min(vpf[a][b], vpb[a][b]);
        }
        return ans;
    }
};",1460818357
Dhiraj Patil,dhirajpatil2346,191,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = true;
        int curr = 10;
        while(n>0)
        {
            if(n<curr)
                return !alice;
            n-=curr;
            curr--;
            alice = !alice;
        }
        return !alice;
    }
};",1460798146
Dhiraj Patil,dhirajpatil2346,191,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) 
    {
        int used = 0;
        vector<int> v(nums.size());
        map<int, multiset<int>> m;
        for(auto &val:queries)
                m[val[0]].insert(val[1]);
        multiset<int> rem;
        for(int i = 0 ; i < nums.size() ; i++)
        {
            while(m.size())
            {
                auto f = *m.begin();
                if(f.first>i)
                    break;
                m.erase(m.begin());
                
                for(auto &val:f.second)
                    rem.insert(val);
            }
            if(i>0)
                v[i]+=v[i-1];
            // cout<<i<<"" v[i] : ""<<v[i]<<endl;
            int req = nums[i] + v[i];
            // cout<<""nums[i] : ""<<nums[i]<<"" v[i] ""<<v[i]<< "" req ""<<req<<endl;
            // cout<<i <<"" req : ""<<req <<"" rem : "";
            // for(auto &val:rem)
            //         cout<<val<<"" "";
            // cout<<endl;
            
            while(rem.size() && (req>0))
            {
                
                int bc = *prev(rem.end());
                rem.erase(prev(rem.end()));
                if(bc<i)
                {
                    rem.clear();
                    break;
                }
                used++;
                v[i]--;
                req--;
                if((bc+1)<v.size())
                    v[bc+1]++;
                
            }
            // if(req>0)
            // cout<<""fault : ""<<i<<"" ""<<req<<endl;
            if(req>0)
                return -1;
            
        }
        // cout<<""final : ""<<used<<"" ""<<queries.size()-used<<endl;
        return queries.size() - used;
        
    }
};",1460867336
Dhiraj Patil,dhirajpatil2346,191,3648,cpp,"class Solution {
public:
    int second(int sr, int sc, vector<vector<int>> &v, vector<vector<int>> &dp, vector<pair<int,int>> &vp)
    {
        if(sr<=sc || sr<0 ||sc<0 || sr>=dp.size() || sc>=dp.size())
            return 0;
        if(dp[sr][sc] != -1)
                return dp[sr][sc];
        int ret = v[sr][sc];
        int maxi = 0;
        for(auto &val:vp)
            maxi = max(maxi, second(sr+val.first, sc+val.second, v, dp, vp));
        return dp[sr][sc] = ret + maxi;
    }
    int third(int sr, int sc, vector<vector<int>> &v, vector<vector<int>> &dp, vector<pair<int,int>> &vp)
    {
        if(sr>=sc || sr<0 ||sc<0 || sr>=dp.size() || sc>=dp.size())
            return 0;
        if(dp[sr][sc] != -1)
                return dp[sr][sc];
        int ret = v[sr][sc];
        int maxi = 0;
        for(auto &val:vp)
            maxi =max(maxi, third(sr+val.first, sc+val.second, v, dp, vp));
        return dp[sr][sc] = ret + maxi;
    }
    int maxCollectedFruits(vector<vector<int>>& v) {
        int n = v.size(), sum = 0;
        // first playr
        for(int i = 0 ; i < n ; i++)
                sum+=v[i][i];
        // second player
        vector<vector<int>> dp(n, vector<int> (n, -1));
        vector<pair<int,int>> vp = {
            {0, 1}, 
            {-1, 1},
            {1,1}
        };
        sum += second(n-1, 0, v, dp, vp);
        for(auto &val:dp)
                for(auto &valu:val)
                        valu = -1;
        vp ={
            {1, 0},
            {1, -1},
            {1, 1}
        };
        sum+=third(0, n-1, v, dp, vp);
        return sum;
        
    }
};",1460898104
raararaara,raararaara,194,3591,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
//#include <atcoder/all>
//using mint = atcoder::modint998244353;
using namespace std;
using namespace __gnu_pbds;
template<class key, class cmp = std::less<key>>
using ordered_set = tree<key, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;
template<class key, class value, class cmp = std::less<key>>
using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;

using lint = long long;
using ii = pair<int, int>;
using il = pair<int, lint>;
using li = pair<lint, int>;
using ll = pair<lint, lint>;

const int mxn = 1000100, mxp = 1000001;
const int MOD = 1e9 + 7, inf = -1e9 - 7, INF = 1e9 + 1;
const lint lnf = -4e18, LNF = 5e18;
const double eps = 1e-10;
const int sqrtN = 200;

#define sz(x) int(size(x))
#define all(x) (x).begin(),(x).end()
#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define lb(x, v) (lower_bound(all(x), v) - (x).begin())
#define ub(x, v) (upper_bound(all(x), v) - (x).begin())
#define eb emplace_back
#define pb push_back
#define getName(var)  #var
vector<lint> xl, yl;

#define Yes ""Yes\n""
#define No ""No\n""

const int dr[] = {-1, 0, 1, 0};
const int dc[] = {0, -1, 0, 1};

inline int inRange(int r, int c, int R, int C) {
    return 0 <= r && r < R && 0 <= c && c < C;
}

int N, M, Q, R, H, K, T;

void init() {

}

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        N = sz(s);
        vector<lint> pfn(26), pfp(26);
        lint tn = accumulate(all(nextCost), 0ll);
        lint tp = accumulate(all(previousCost), 0ll);
        pfn[0] = nextCost[0];
        pfp[0] = previousCost[0];
        for(int i = 1; i < 26; i++) {
            pfn[i] = nextCost[i] + pfn[i-1];
            pfp[i] = previousCost[i] + pfp[i-1];
        }


        auto sum = [](int l, int r, vector<lint> &v) {
            lint ret = v[r];
            if(l-1 >= 0) ret -= v[l-1];
            return ret;
        };

        lint ret = 0;
        for(int i = 0; i < N; i++) {
            if(s[i] == t[i]) continue;
            if(s[i] < t[i]) {
                lint cand = sum(s[i]-'a', t[i]-1-'a', pfn);
                lint cand2 = tp - sum(s[i]+1-'a', t[i]-'a', pfp);
                ret += min(cand, cand2);
            } else {
                lint cand = sum(t[i]+1-'a', s[i]-'a', pfp);
                lint cand2 = tn - sum(t[i]-'a', s[i]-'a'-1, pfn);
                ret += min(cand, cand2);
            }
        }
        return ret;
    }
};
",1460876665
raararaara,raararaara,194,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 10, t = 0;
        while(n >= 0) {
            if(n-x < 0) {
                return (t == 1);
            }
            n -= x;
            x--;
            t^=1;
        }
        return t==1;
    }
};",1460880274
raararaara,raararaara,194,3647,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
//#include <atcoder/all>
//using mint = atcoder::modint998244353;
using namespace std;
using namespace __gnu_pbds;
template<class key, class cmp = std::less<key>>
using ordered_set = tree<key, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;
template<class key, class value, class cmp = std::less<key>>
using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;

using lint = long long;
using ii = pair<int, int>;
using il = pair<int, lint>;
using li = pair<lint, int>;
using ll = pair<lint, lint>;

const int mxn = 1000100, mxp = 1000001;
const int MOD = 1e9 + 7, inf = -1e9 - 7, INF = 1e9 + 1;
const lint lnf = -4e18, LNF = 5e18;
const double eps = 1e-10;
const int sqrtN = 200;

#define sz(x) int(size(x))
#define all(x) (x).begin(),(x).end()
#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define lb(x, v) (lower_bound(all(x), v) - (x).begin())
#define ub(x, v) (upper_bound(all(x), v) - (x).begin())
#define eb emplace_back
#define pb push_back
#define getName(var)  #var
vector<lint> xl, yl;

#define Yes ""Yes\n""
#define No ""No\n""

const int dr[] = {-1, 0, 1, 0};
const int dc[] = {0, -1, 0, 1};

inline int inRange(int r, int c, int R, int C) {
    return 0 <= r && r < R && 0 <= c && c < C;
}

int N, M, Q, R, H, K, T;

void init() {

}

struct P {
    lint v, _sz;
    P() { v = _sz = 0; }
    P(lint v, lint t): v(v), _sz(t) {}
    P operator + (const P&rhs) const {
        P ret;
        ret.v += v + rhs.v;
        ret._sz += _sz + rhs._sz;

        return ret;
    }
    bool operator == (const P&rhs) const {
        return v == rhs.v && _sz == rhs._sz;
    }
};

template<typename T_Node,
        typename T_Lazy,
        typename F_Merge,
        typename F_Update,
        typename F_Prop>
struct LazySegTree {
    int N{}, base{};
    vector<T_Node> tree;
    vector<T_Lazy> lz;

    const F_Merge m;
    const F_Update u;
    const F_Prop p;
    const T_Node I;
    const T_Lazy lzI;

    LazySegTree() = default;

    LazySegTree(int n,
                F_Merge _m, F_Update _u, F_Prop _p,
                const T_Node &I, const T_Lazy &lzI)
            : N(n), m(_m), u(_u), p(_p), I(I), lzI(lzI) {
        for (base = 1; base < N; base <<= 1);
        tree.resize(base * 2 + 1, I);
        lz.resize(base * 2 + 1, lzI);
    }

    void lazy(int n) {
        if(lz[n] == lzI) return;
        tree[n] = u(tree[n], lz[n]);
        if (n < base) {
            lz[n<<1] = p(lz[n<<1], lz[n]);
            lz[n<<1|1] = p(lz[n<<1|1], lz[n]);
        }
        lz[n] = lzI;
    }

    void build() {
        for (int i = base - 1; i; i--) {
            tree[i] = m(tree[i << 1], tree[i << 1 | 1]);
        }
    }

    T_Node get(int i) { return tree[i + base]; }

    void set(int i, T_Node v) { tree[i + base] = v; }

    void upd(int l, int r, T_Lazy v) {
        upd(l, r, 1, 0, base - 1, v);
    }
    void upd(int l, int r, int n, int nl, int nr, T_Lazy v) {
        lazy(n);
        if (r < nl || nr < l) return;
        if (l <= nl && nr <= r) {
            lz[n] = p(lz[n], v);
            lazy(n);
            return;
        }
        int mid = (nl + nr) >> 1;
        upd(l, r, n<<1, nl, mid, v);
        upd(l, r, n<<1|1, mid+1, nr, v);

        tree[n] = m(tree[n<<1], tree[n<<1|1]);
    }

    T_Node qry(int l, int r) {
        return qry(l, r, 1, 0, base - 1);
    }
    T_Node qry(int l, int r, int n, int nl, int nr) {
        lazy(n);
        if (r < nl || nr < l) return I;
        if (l <= nl && nr <= r) return tree[n];
        int mid = (nl + nr) >> 1;
        return m(qry(l, r, n<<1, nl, mid), qry(l, r, n<<1|1, mid+1, nr));
    }
};
template<typename T_Node>
auto m = [](T_Node a, T_Node b) { return a + b; };
template<typename T_Node, typename T_Lazy>
auto u = [](T_Node a, T_Lazy b) { return P(a.v + b.v * a._sz, a._sz); };
template<typename T_Lazy>
auto p = [](T_Lazy a, T_Lazy b) { return a + b; };

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& qList) {
        N = sz(a), Q = sz(qList);
        vector<priority_queue<int>> qIdx(N);
        vector<ii> qs;
        for(auto &vec: qList) {
            qs.eb(vec[0], vec[1]);
            qIdx[vec[0]].emplace(vec[1]);
        }
        vector<int> b(N);
        b.eb(0);
        for(auto [l,r]: qs) {
            b[l]--; b[r+1]++;
        }
        auto c = a;
        for(int i = 0, sm = 0; i < N; i++) {
            sm += b[i];
            c[i] += sm;
        }
        for(auto &x: c) if(x > 0) return -1;


        LazySegTree<P, P, decltype(m<P>), decltype(u<P,P>), decltype(p<P>)> seg(N, m<P>, u<P,P>, p<P>, P(0,0), P(0,0));
        for(int i = 0; i < N; i++) {
            seg.set(i, P(a[i], 1));
        }
        seg.build();
        int ret = 0;
        for(int i = 0; i < N; i++) {
            int it = seg.qry(i,i).v;
            if(it < 0) {
                if(i+1 < N) {
                    if(sz(qIdx[i]) < sz(qIdx[i+1])) {
                        while(!qIdx[i].empty()) {
                            qIdx[i+1].emplace(qIdx[i].top());
                            qIdx[i].pop();
                        }
                    } else {
                        while(!qIdx[i+1].empty()) {
                            qIdx[i].emplace(qIdx[i+1].top());
                            qIdx[i+1].pop();
                        }
                        swap(qIdx[i], qIdx[i+1]);
                    }
                }
                continue;
            }

            while(it--) {
                assert(!qIdx[i].empty());
                int tp = qIdx[i].top();
                seg.upd(i, tp, P(-1,0));
                qIdx[i].pop();
                ret++;
            }

            if(i+1 < N) {
                if(sz(qIdx[i]) < sz(qIdx[i+1])) {
                    while(!qIdx[i].empty()) {
                        qIdx[i+1].emplace(qIdx[i].top());
                        qIdx[i].pop();
                    }
                } else {
                    while(!qIdx[i+1].empty()) {
                        qIdx[i].emplace(qIdx[i+1].top());
                        qIdx[i+1].pop();
                    }
                    swap(qIdx[i], qIdx[i+1]);
                }
            }
        }

        return Q - ret;
    }
};
",1460904384
raararaara,raararaara,194,3648,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
//#include <atcoder/all>
//using mint = atcoder::modint998244353;
using namespace std;
using namespace __gnu_pbds;
template<class key, class cmp = std::less<key>>
using ordered_set = tree<key, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;
template<class key, class value, class cmp = std::less<key>>
using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;

using lint = long long;
using ii = pair<int, int>;
using il = pair<int, lint>;
using li = pair<lint, int>;
using ll = pair<lint, lint>;

const int mxn = 1000100, mxp = 1000001;
const int MOD = 1e9 + 7, inf = -1e9 - 7, INF = 1e9 + 1;
const lint lnf = -4e18, LNF = 5e18;
const double eps = 1e-10;
const int sqrtN = 200;

#define sz(x) int(size(x))
#define all(x) (x).begin(),(x).end()
#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define lb(x, v) (lower_bound(all(x), v) - (x).begin())
#define ub(x, v) (upper_bound(all(x), v) - (x).begin())
#define eb emplace_back
#define pb push_back
#define getName(var)  #var
vector<lint> xl, yl;

#define Yes ""Yes\n""
#define No ""No\n""

const int dr[] = {-1, 0, 1, 0};
const int dc[] = {0, -1, 0, 1};

inline int inRange(int r, int c, int R, int C) {
    return 0 <= r && r < R && 0 <= c && c < C;
}

lint N, M, Q, R, H, K, T;

void init() {

}

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = sz(a);

        int ret = 0;
        for(int i = 0; i < n; i++) {
            ret += a[i][i];
            a[i][i] = 0;
        }
        if(n==1) return ret;
        // left
        vector<int> d(1, a[n-1][0]);
        for(int j = 1; j < n; j++) {
            vector<int> nd(j+1);
            for(int i = 0; i < sz(d); i++) {
                int x = d[i];
                int r = n-1-i;
                for(int dir = -1; dir <= 1; dir++) {
                    int nr = r + dir;
                    if(!inRange(n-1-nr, j, sz(nd), n)) continue;
                    nd[n-1-nr] = max(nd[n-1-nr], x + a[nr][j]);
                }
            }
            d = nd;
        }

        // up
        vector<int> d2(1, a[0][n-1]);
        for(int i = 1; i < n; i++) {
            vector<int> nd(i+1);
            for(int j = 0; j < sz(d2); j++) {
                int x = d2[j];
                int c = n-1-j;
                for(int dir = -1; dir <= 1; dir++) {
                    int nc = c + dir;
                    if(!inRange(i, n-1-nc, n, sz(nd))) continue;
                    nd[n-1-nc] = max(nd[n-1-nc], x + a[i][nc]);
                }
            }
            d2 = nd;
        }
        return ret + d[0] + d2[0];
    }
};
",1460830061
minamotoorin,minamotoorin,195,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        long long dn[26][26]={}, dp[26][26]={};
        for (int i  = 0; i < 26; i ++)
        {
            for (int j = 0; j < 26; j++)
            {
                int tmp = i;
                while(tmp != j)
                {
                    dn[i][j] += nextCost[tmp];
                    tmp++;
                    if(tmp == 26) tmp = 0;
                }
                tmp = i;
                while(tmp != j)
                {
                    dp[i][j] += previousCost[tmp];
                    tmp--;
                    if(tmp == -1) tmp = 25;
                }
            }
        }

        for(int i = 0 ; i < s.size(); i++)
        {
            ans += min(dp[s[i]-'a'][t[i]-'a'], dn[s[i]-'a'][t[i]-'a']);
        }

        return ans;
    }
};",1460816924
minamotoorin,minamotoorin,195,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i = 10; i>0; i--)
            {
                if (i > n) return i&1;
                n-=i;
            }
        return 1;
    }
};",1460797182
minamotoorin,minamotoorin,195,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size(), m = q.size();

        sort(q.begin(), q.end(), 
            [](const vector<int> &a, const vector<int> &b){
            return a[0] != b[0] ? a[0] < b[0] : a[1] < b[1];
        });

        vector<int> pre(n+1);
        for(auto &it : q){
            pre[it[0]] --;
            pre[it[1]+1] ++;
        }
        
        int cnt = 0;
        for(int i = 0; i < n; i ++){
            cnt += pre[i];
            if(nums[i] + cnt > 0) return -1;
        }
        
        priority_queue<int, vector<int>, less<int>> pq;
        fill(pre.begin(), pre.end(), 0);
        cnt = 0;
        int ans = m, ind = 0;
        
        for(int i = 0; i < n; i ++){
            cnt += pre[i];
            while(ind < m && q[ind][0] <= i && q[ind][1] >= i){
                pq.push(q[ind][1]);
                ind++;
            }
            while(nums[i] + cnt > 0){
                auto tmp = pq.top();
                pq.pop();
                
                pre[tmp+1] ++ ;
                cnt--;
                ans--;
            }
        }
        
        return ans;
    }
};",1460904551
minamotoorin,minamotoorin,195,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ans = 0;
        int n = f.size();
        for(int i = 0 ; i < n ; i ++)
        {
            ans += f[i][i];
            f[i][i] = 0;
        }
        int dp1[1001][1001] = {0};
        for(int i = n - 2; i >=0; i--)
        {
            for(int j = (i >= n/2 ? i: n - 1 - i); j < n; j++)
            {
                dp1[i][j] = max(max(dp1[i+1][j], dp1[i+1][j-1]), dp1[i+1][j+1]);
                dp1[i][j]+=f[i][j];
            }
        }
        int dp2[1001][1001] = {0};
        for(int j = n - 2; j >=0; j--)
        {
            for(int i = (j >= n/2 ? j: n - 1 - j); i < n; i++)
            {
                dp2[i][j] = max(max(dp2[i][j+1], dp2[i-1][j+1]), dp2[i+1][j+1]);
                dp2[i][j]+=f[i][j];
            }
        }

        ans += dp1[0][n-1] + dp2[n-1][0];

        return ans;
    }
};",1460852315
Amarnath Ganguli,amarnathsama,198,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost,
                            vector<int>& previousCost) {
        int n = s.size();
        long long ans = 0;
        for (int x = 0; x < n; x++) {
            auto ic = [&](char c1, char c2, bool inc) -> long long {
                long long c = 0;
                while (c1 != c2) {
                    if (inc) {
                        c += nextCost[c1 - 'a'];
                        c1++;
                        if (c1 > 'z')
                            c1 = 'a';
                    } else {
                        c += previousCost[c1 - 'a'];
                        c1--;
                        if (c1 < 'a')
                            c1 = 'z';
                    }
                }
                return c;
            };
            ans += min(ic(s[x], t[x], 0), ic(s[x], t[x], 1));
            // cout<<ans<<endl;
        }
        return ans;
    }
};",1460832747
Amarnath Ganguli,amarnathsama,198,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool aliceWin = false;
        int turn = 10;
        while (true) {
            if (n < turn)
                return aliceWin;
            n -= turn;
            turn--;
            aliceWin = !aliceWin;
        }
    }
};",1460802946
Amarnath Ganguli,amarnathsama,198,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        sort(q.begin(), q.end());
        int qi = 0;
        priority_queue<pair<int, int>> pq;
        int n = nums.size();
        vector<int> dec(n);
        int curr = 0;
        for (int x = 0; x < n; x++) {
            while (qi < q.size() && q[qi][0] <= x) {
                pq.push({q[qi][1], q[qi][0]});
                qi++;
            }

            while (curr < nums[x] && pq.size()) {
                auto [ei, si] = pq.top();
                pq.pop();
                if (ei < x)
                    return -1;
                curr++;
                dec[ei]++;
            }
            if (curr < nums[x])
                return -1;
            curr -= dec[x];
        }
        return pq.size();
    }
};
",1460868430
Amarnath Ganguli,amarnathsama,198,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int n = f.size(), m = f[0].size();
        vector<vector<int>> dpup(n, vector<int>(m,-1));
        // auto visup = dpup;
        dpup[0][m - 1] = f[0][m - 1];
        // visup[0][m-1] = 1;
        for (int x = 1; x < n - 1; x++) {
            for (int y = m - 1; y > x; y--) {
                int v1 = y + 1 < m ? dpup[x - 1][y + 1] : -1;
                int v2 = y - 1 >= 0 ? dpup[x - 1][y - 1] : -1;
                int res = max({v1, v2, dpup[x - 1][y]});
                if (res == -1)
                    continue;
                dpup[x][y] = f[x][y] + res;
            }
        }
        // return 0;
        vector<vector<int>> dpd(n, vector<int>(m,-1));
        dpd[n - 1][0] = f[n - 1][0];
        for (int y = 1; y < m - 1; y++) {
            for (int x = n - 1; x > y; x--) {
                int v1 = x + 1 < n ? dpd[x + 1][y - 1] : -1;
                int v2 = x - 1 >= 0 ? dpd[x - 1][y - 1] : -1;
                int res = max({v1, v2, dpd[x][y - 1]});
                if (res == -1)
                    continue;
                dpd[x][y] = f[x][y] + res;
            }
        }
        int sum = 0;
        for (int x = 0; x < n; x++)
            sum += f[x][x];
        return sum + dpd[n - 1][m - 2] + dpup[n - 2][m - 1];
    }
};

// c1 x
// x  x

//     c2
// x    x    x

//     x
// c3  x
//     x",1460916139
ysahu,ysahu,199,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[][] cost = new long[26][26];
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                int k = i;
                long next = 0;
                while (k != j) {
                    next += nextCost[k];
                    if (++k == 26) k = 0;
                }

                long prev = 0;
                k = i;
                while (k != j) {
                    prev += previousCost[k];
                    if (--k == -1) k = 25;
                }

                cost[i][j] = Math.min(next, prev);
            }
        }
        
        int n = s.length();
        long c = 0;
        for (int i = 0; i < n; i++) {
            char sc = s.charAt(i);
            char tc = t.charAt(i);
            c += cost[sc - 'a'][tc - 'a'];
        }

        return c;
    }
}",1460813132
ysahu,ysahu,199,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int v = 10;
        boolean out = false;
        while (v > 0) {
            if (n >= v) n -= v;
            else return out;
            v--;
            out = !out;
        }
        return out;
    }
}",1460797283
ysahu,ysahu,199,3647,java,"class Solution {

    private static class IntArray extends ArrayList<Integer> {}
    
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        IntArray[] starts = new IntArray[n + 1];
        for (int i = 0; i < n + 1; i++) starts[i] = new IntArray();

        for (int i = 0; i < queries.length; i++) {
            starts[queries[i][0]].add(i);
        }

        int mod = 0, out = queries.length;
        int[] endCount = new int[n + 1];
        PriorityQueue<Integer> endings = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            mod -= endCount[i];
            for (int index : starts[i]) {
                endings.add(-queries[index][1]);
            }
            while (mod < nums[i]) {
                if (endings.size() == 0) return -1;
                int end = -endings.poll();
                if (end < i) return -1;
                endCount[end + 1]++;
                mod++;
                out--;
            }
        }

        return out;
    }
}",1460910740
ysahu,ysahu,199,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        if (n == 2) {
            return fruits[0][0] + fruits[0][1] + fruits[1][0] + fruits[1][1];
        }

        int[] c1 = new int[n], c2 = new int[n];
        c1[n - 1] = fruits[n - 2][n - 1];
        c2[n - 1] = fruits[n - 1][n - 2];
        
        for (int i = n - 3; i >= 0; i--) {
            int[] nc1 = new int[n], nc2 = new int[n];
            for (int j = i + 1; j < n; j++) {
                nc1[j] = Math.max(c1[j - 1], c1[j]);
                nc2[j] = Math.max(c2[j - 1], c2[j]);
                if (j + 1 < n) {
                    nc1[j] = Math.max(nc1[j], c1[j + 1]);
                    nc2[j] = Math.max(nc2[j], c2[j + 1]);
                }
                nc1[j] += fruits[i][j];
                nc2[j] += fruits[j][i];
            }
            c1 = nc1;
            c2 = nc2;
        }

        int total = c1[n - 1] + c2[n - 1];
        for (int i = 0; i < n; i++) total += fruits[i][i];
        return total;
    }
}",1460888957
stupid_panda,stupid_panda,201,3591,rust,"impl Solution {
    pub fn shift_distance(
        s: String,
        t: String,
        next_cost: Vec<i32>,
        previous_cost: Vec<i32>,
    ) -> i64 {
        let mut ans = 0;
        let s = s.as_bytes();
        let t = t.as_bytes();
        for i in 0..s.len() {
            let s_ch = (s[i] - b'a') as usize;
            let t_ch = (t[i] - b'a') as usize;
            let mut cur_prev_cost = 0_i64;
            let mut cur_next_cost = 0_i64;
            if s_ch < t_ch {
                next_cost[s_ch..t_ch]
                    .iter()
                    .for_each(|&v| cur_next_cost += v as i64);
                previous_cost[0..=s_ch]
                    .iter()
                    .chain(previous_cost[(t_ch + 1)..].iter())
                    .for_each(|&v| cur_prev_cost += v as i64);
            } else if t_ch < s_ch {
                previous_cost[(t_ch + 1)..=s_ch]
                    .iter()
                    .for_each(|&v| cur_prev_cost += v as i64);
                next_cost[s_ch..]
                    .iter()
                    .chain(next_cost[0..t_ch].iter())
                    .for_each(|&v| cur_next_cost += v as i64);
            }
            ans += cur_prev_cost.min(cur_next_cost);
        }
        ans
    }
}
",1460846978
stupid_panda,stupid_panda,201,3625,rust,"impl Solution {
    pub fn can_alice_win(mut n: i32) -> bool {
        let mut alice_turn = true;
        let mut move_stone = 10;
        while n >= move_stone && move_stone > 0 {
            n -= move_stone;
            move_stone -= 1;
            alice_turn = !alice_turn;
        }
        !alice_turn
    }
}
",1460812071
stupid_panda,stupid_panda,201,3647,rust,"impl Solution {
    pub fn max_removal(nums: Vec<i32>, mut queries: Vec<Vec<i32>>) -> i32 {
        use std::collections::BinaryHeap;
        queries.sort_unstable();
        let mut ans = 0;
        let mut next_end = BinaryHeap::<i32>::new();
        let mut offset = vec![0_i32; nums.len() + 1];
        let mut cur_h = 0;
        let mut q_i = 0;
        for i in 0..nums.len() {
            cur_h += offset[i];
            while q_i < queries.len() && queries[q_i][0] == i as i32 {
                next_end.push(queries[q_i][1]);
                q_i += 1;
            }
            while cur_h < nums[i] {
                let end = next_end.pop().unwrap_or(-1);
                if end < i as i32 {
                    return -1;
                }
                offset[(end + 1) as usize] -= 1;
                cur_h += 1;
                ans += 1;
            }
        }
        (queries.len() - ans) as _
    }
}",1460917368
stupid_panda,stupid_panda,201,3648,rust,"impl Solution {
    pub fn max_collected_fruits(mut fruits: Vec<Vec<i32>>) -> i32 {
        let n = fruits.len();
        let mut ans = 0;
        // first child
        for i in 0..n {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        // second child
        let mut dp = vec![-1; n];
        let mut dp_next = vec![-1; n];
        dp[n - 1] = fruits[0][n - 1];
        for i in 1..(n - 1) {
            dp_next.fill(-1);
            for j in (i + 1)..n {
                if dp[j - 1] >= 0 || dp[j] >= 0 {
                    dp_next[j] = fruits[i][j] + dp[j - 1].max(dp[j]);
                }
                if j < n - 1 && dp[j + 1] >= 0 {
                    dp_next[j] = dp_next[j].max(fruits[i][j] + dp[j + 1]);
                }
            }
            std::mem::swap(&mut dp, &mut dp_next);
        }
        ans += dp[n - 1];
        // third child
        dp.fill(-1);
        dp[n - 1] = fruits[n - 1][0];
        for j in 1..(n - 1) {
            dp_next.fill(-1);
            for i in (j + 1)..n {
                if dp[i - 1] >= 0 || dp[i] >= 0 {
                    dp_next[i] = fruits[i][j] + dp[i - 1].max(dp[i]);
                }
                if i < n - 1 && dp[i + 1] >= 0 {
                    dp_next[i] = dp_next[i].max(fruits[i][j] + dp[i + 1]);
                }
            }
            std::mem::swap(&mut dp, &mut dp_next);
        }
        ans += dp[n - 1];
        ans
    }
}
",1460889533
Meng-Hsuan Wu,meng-hsuan,202,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        next_cumsum = [0]
        for i in range(2):
            for j in nextCost:
                next_cumsum.append(next_cumsum[-1] + j)
        
        prev_cumsum = [0]
        for i in range(2):
            for j in previousCost[0::-1] + previousCost[:0:-1]:
                prev_cumsum.append(prev_cumsum[-1] + j)
        prev_cumsum.reverse()
        
        n = len(s)
        ans = 0
        for i in range(n):
            sc = ord(s[i]) - 97
            tc = ord(t[i]) - 97
            ans += min(next_cumsum[tc + (0 if tc >= sc else 26)] - next_cumsum[sc], prev_cumsum[tc] - prev_cumsum[sc + (0 if sc >= tc else 26)])
        
        return ans
    ",1460824978
Meng-Hsuan Wu,meng-hsuan,202,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        avail = n
        to_take = 10
        player = 0
        
        while avail >= to_take:
            avail -= to_take
            to_take -= 1
            player ^= 1
        
        return player == 1",1460799432
Meng-Hsuan Wu,meng-hsuan,202,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        nq = len(queries)
        delta = [0] * (n + 1)
        for l, r in queries:
            delta[l] += 1
            delta[r + 1] -= 1
        for i in range(1, n + 1):
            delta[i] += delta[i - 1]
        
        if any(delta[i] < nums[i] for i in range(n)):
            return -1
        
        queries.sort(reverse = True)
        avail_pq = []
        taken_pq = []
        ct = 0
        for curr in range(n):
            while len(queries) and queries[-1][0] <= curr:
                heappush(avail_pq, -queries.pop()[1])
            
            while len(taken_pq) > 0 and taken_pq[0] < curr:
                heappop(taken_pq)
            
            while len(taken_pq) < nums[curr]:
                heappush(taken_pq, -heappop(avail_pq))
                ct += 1
            #print(curr, nums[curr], avail_pq, taken_pq)
        
        return nq - ct
    ",1460912146
Meng-Hsuan Wu,meng-hsuan,202,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0
        
        for i in range(n - 1):
            fruits[i][0] = -1
        
        for c in range(1, n):
            for r in range(c, n):
                prev_best = max(fruits[i][c - 1] for i in range(r - 1, min(r + 2, n)))
                if prev_best == -1:
                    fruits[r][c] = -1
                else:
                    fruits[r][c] += prev_best    
        #for row in fruits:
        #    print(row)
        
        ans += fruits[n - 1][n - 1]
        
        for i in range(n):
            fruits[i][i] = 0
        
        for i in range(n - 1):
            fruits[0][i] = -1
        
        for r in range(1, n):
            for c in range(r, n):
                prev_best = max(fruits[r - 1][i] for i in range(c - 1, min(c + 2, n)))
                if prev_best == -1:
                    fruits[r][c] = -1
                else:
                    fruits[r][c] += prev_best
        #for row in fruits:
        #    print(row)
        
        ans += fruits[n - 1][n - 1]
        
        return ans
    ",1460887768
yzkkai,yzkkai,203,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = size(s);
        long long ans = 0;
        for (int i = 0; i < n; ++i) {
            char tmp = s[i];
            long long cur1 = 0, cur2 = 0;
            int a = s[i] - 'a', b = t[i] - 'a';
            while (a != b) {
                cur1 += nextCost[a];
                a = (a + 1) % 26;
            }

            a = s[i] - 'a';
            while (a != b) {
                cur2 += previousCost[a];
                a = (a + 25) % 26;
            }
            
            ans += min(cur1, cur2);
        }

        return ans;
    }
};",1460806095
yzkkai,yzkkai,203,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 0; ; ++i) {
            int j = 10 - i;
            if (n < j) 
                return i & 1;
            else
                n -= j;
        }
            
    }
};",1460797352
yzkkai,yzkkai,203,3647,cpp,"#define lowbit(x) ((x) & -(x))
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = size(nums), m = size(queries);
        vector<int> bit(n + 5);
        auto add = [&](int idx, int val) {
            for (; idx <= n; idx += lowbit(idx))
                bit[idx] += val;
        };
        auto query = [&](int idx) {
            int ret = 0;
            for (; idx; idx -= lowbit(idx))
                ret += bit[idx];
            return ret;
        };

        for (int i = 1; i <= n; ++i) {
            add(i, nums[i - 1]);
            add(i + 1, -nums[i - 1]);
        }
        for (auto& v : queries)
            ++v[0], ++v[1];
        
        sort(queries.begin(), queries.end(), [&](const auto& x, const auto& y) {
            if (x[0] != y[0]) return x[0] < y[0];
            return x[1] > y[1];
        });
        
        priority_queue<int> pq;
        int j = 0;
        int used = 0;
        for (int i = 1; i <= n; ++i) {
            int cur = query(i);
            while (j < m && queries[j][0] < i)
                pq.emplace(queries[j++][1]);
            while (cur > 0) {
                --cur;
                if (j < m && queries[j][0] == i && (pq.empty() || queries[j][1] >= pq.top())) {
                    add(1, -1);
                    add(queries[j][1] + 1, 1);
                    ++j;
                    ++used;
                    continue;
                }
                if (pq.empty() || pq.top() < i)
                    return -1;
                add(1, -1);
                add(pq.top() + 1, 1);
                pq.pop();
                ++used;
            }
        }

        
        return m - used;
    }
};",1460873897
yzkkai,yzkkai,203,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& grid) {
        int n = size(grid), ans = 0;
        for (int i = 0; i < n; ++i)
            ans += grid[i][i];

        vector<int> dp(n, -1e9);
        dp[n - 1] = grid[n - 1][0];
        for (int i = 0; i < n - 1; ++i) {
            vector<int> tmp(n, -1e9);
            for (int j = n - 1; j > i; --j)
                for (int k = -1; k <= 1; ++k) {
                    if (j + k < 0 || j + k >= n || dp[j] == -1)
                        continue;
                    if (j + k == i + 1)
                        tmp[j + k] = max(tmp[j + k], dp[j]);
                    else
                        tmp[j + k] = max(tmp[j + k], dp[j] + grid[j + k][i + 1]);
                }
            dp = tmp;
        }
        ans += dp[n - 1];

        fill(dp.begin(), dp.end(), -1e9);
        dp[n - 1] = grid[0][n - 1];
        for (int i = 0; i < n - 1; ++i) {
            vector<int> tmp(n, -1e9);
            for (int j = n - 1; j > i; --j)
                for (int k = -1; k <= 1; ++k) {
                    if (j + k < 0 || j + k >= n || dp[j] == -1)
                        continue;
                    if (j + k == i + 1)
                        tmp[j + k] = max(tmp[j + k], dp[j]);
                    else
                        tmp[j + k] = max(tmp[j + k], dp[j] + grid[i + 1][j + k]);
                }
            dp = tmp;
        }
        ans += dp[n - 1];

        return ans;
    }
};",1460901665
sguaaa,sguaaa,205,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        mx = [[0] * 26 for _ in range(26)]
        for i in range(26):
            v = 0
            for d in range(1, 26):
                v += nextCost[(i + d - 1) % 26]
                mx[i][(i + d) % 26] = v
                
            w = 0
            for d in range(1, 26):
                w += previousCost[(i - d + 1) % 26]
                mx[i][(i - d) % 26] = min(mx[i][(i - d) % 26], w)
                
        # print(mx)
        cost = 0
        for x, y in zip(s, t):
            cost += mx[ord(x) - ord('a')][ord(y) - ord('a')]
            
        return cost",1460842225
sguaaa,sguaaa,205,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        r = 0
        x = 10
        while n > 0:
            n -= x
            x -= 1
            if n >= 0:
                r += 1
        return bool(r % 2)
        ",1460809379
sguaaa,sguaaa,205,3647,python3,"from heapq import heapify, heappush, heappop

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        ind = 0
        queries.sort(key=lambda q: q[0])
        res = 0
        candidates = []
        used = []
        level = 0
        for i, x in enumerate(nums):
            while ind < len(queries) and queries[ind][0] <= i:
                heappush(candidates, -queries[ind][1])
                ind += 1
                
            while candidates and level < x:
                v = -heappop(candidates)
                if v >= i:
                    level += 1
                    heappush(used, v)
                    res += 1
                
            if level < x:
                return -1
            
            while used and used[0] <= i:
                heappop(used)
                level -= 1
            
        return len(queries) - res
        
            
#         # events = [event for ind, q in enumerate(queries) for event in [(q[0], 1, ind), (q[1], -1, ind)]]
#         # heapify(events)
        
#         ind = 0
#         start_events = []
#         end_events = []
#         level = 0
#         for i, x in enumerate(nums):
#             while start_events and start_events[0] <= i:
#                 level += 1
#                 heappop(start_events)
                
#             while x > level and ind < len(queries):
#                 q = queries[ind]
#                 ind += 1
#                 if q[1] >= i:
#                     heappush(end_events, q[1])
#                     if q[0] <= i:
#                         level += 1
#                     else:
#                         heappush(start_events, q[0])
            
#             if x > level:
#                 return -1
            
#             while end_events and end_events[0] <= i:
#                 level -= 1
#                 heappop(end_events)
#         return len(queries) - ind
                ",1460884460
sguaaa,sguaaa,205,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        size = len(fruits)
        dp = [[0] * (size + 1) for _ in range(size + 1)]
        
        res = sum([fruits[i][i] for i in range(size)])
        
        dp[0][size - 1] = fruits[0][size - 1]
        
        for i in range(1, size - 1):
            for j in range(size - i - 1, size):
                if j > i:
                    dp[i][j] = fruits[i][j] + max(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1])
                    
                    
        dp[size - 1][0] = fruits[size - 1][0]
        for j in range(1, size - 1):
            for i in range(size - j - 1, size):
                if i > j:
                    dp[i][j] = fruits[i][j] + max(dp[i - 1][j - 1], dp[i][j - 1], dp[i + 1][j - 1])
                    
        
        
        if size >= 2:
            res += dp[size - 1][size - 2]
            res += dp[size - 2][size - 1]
        return res
        
        ",1460902156
Shenglong Chen,chenshenglong1990,206,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long cost[26][26] ;
        for (int i = 0; i < 26; ++ i) {
            for (int j = 0; j < 26; ++ j) {
                if (i == j) cost[i][j] = 0;
                else {
                    if (i < j) {
                        long long tmp =0;
                        for (int k = i; k < j; ++ k) {
                            tmp += nextCost[k];
                        }
                        cost[i][j] = tmp;
                        tmp = 0;
                        for (int k = i; k >=0; -- k) {
                            tmp += previousCost[k];
                            
                        }
                        for (int k = 25; k > j; -- k) {
                            tmp += previousCost[k];
                        }
                        cost[i][j] = std::min(tmp, cost[i][j]);
                        
                    } else {
                        
                        long long tmp =0;
                        for (int k = i; k > j; -- k) {
                            tmp += previousCost[k];
                        }
                        cost[i][j] = tmp;
                        tmp = 0;
                        for (int k = i; k < 26; ++ k) {
                            tmp += nextCost[k];
                            
                        }
                        for (int k = 0; k < j; ++ k) {
                            tmp += nextCost[k];
                        }
                        cost[i][j] = std::min(tmp, cost[i][j]);
                        
                        
                        
                    }
                }
            }
            
            
        }
        long long res = 0;
        for (int i = 0; i < s.size(); ++ i) {
            res += cost[s[i] - 'a'][t[i] - 'a'];
        }
        return res;
        
        
    }
};",1460825237
Shenglong Chen,chenshenglong1990,206,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10;
        bool win = 1;
        while (n >= cnt) {
            n -= cnt;
            cnt --;
            win = !win;
            
        }
        return !win;
        
    }
};",1460799512
Shenglong Chen,chenshenglong1990,206,3647,cpp,"class Solution {
public:
    struct Node {
        int l, r;
        friend bool operator<(const Node& a, const Node& b) {
            return a.r < b.r;
        }
    };
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end(), [&](const vector<int>& a, const vector<int>& b){
            if (a[0] == b[0]) return a[1] > b[1];
            else return a[0] < b[0];
        });
        vector<int> diff(nums.size() + 1, 0);
        int cur = 0;
        int k = 0;
        int res = 0;
        priority_queue<Node> pq;
        for (int i = 0; i < nums.size(); ++ i) {
            int need = nums[i];
            cur += diff[i];
            if (cur >= need) continue;
            while (k < queries.size()) {
                auto& q = queries[k];
                if (q[0] <= i && q[1] >= i) {
                    //printf (""i: %d, push [%d, %d]\n"", i, q[0], q[1]);
                    pq.push(Node(q[0], q[1]));
                } 
                if (q[0] > i) break;
                k ++;
            }
            if (pq.size() < need - cur) {
                return -1;
            } else {
                need -= cur;
                while (pq.size() && need ) {
                    auto x = pq.top();
                    pq.pop();
                    if (x.r  < i) continue;
                    //printf (""i: %d, pop[%d, %d]\n"", i, x.l, x.r);
                    cur ++;
                    res ++;
                    diff[x.r + 1] -= 1;
                    need --;
                }
                if (need) return -1;
            }
        }
        return queries.size() - res;
        
    }
};",1460879230
Shenglong Chen,chenshenglong1990,206,3648,cpp,"#define printf(...) void()
class Solution {
public:
    int dir1[3][2] = {{-1, 1}, {0, 1}, {1, 1}};
    int dir2[3][2] = {{1, -1}, {1, 0}, {1, 1}};
    /*
    struct Node {
        int x, y;
        frid
    };
    */
       int n ;
    int dp[1001][1001];
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res = 0;
        n = fruits.size();
        for (int i = 0; i< n; ++ i) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        memset(dp, -1, sizeof(dp));
        printf (""res: %d\n"", res);
        res += dfs1(n - 1, 0, fruits);
        res += dfs2(0, n - 1, fruits);
        
        
        return res;
        
    }
    int dfs1(int x, int y, vector<vector<int>>& fruits) {
        printf (""%d, %d\n"", x, y);
        if (x == n - 1 && y == n - 1) return 0;
        if (dp[x][y] != -1) return dp[x][y];
        int tmp = 0;
        for (int i = 0; i < 3; ++ i) {
            int nx = x + dir1[i][0];
            int ny = y + dir1[i][1];
            if (nx >= n || nx == ny || nx < ny) continue;
            tmp = std::max(tmp, dfs1(nx, ny, fruits))  ;
        }
        dp[x][y] = tmp + fruits[x][y];;
        printf (""dfs1 [%d][%d]: %d\n"", x, y, dp[x][y]);
        return dp[x][y];
    }
    int dfs2(int x, int y, vector<vector<int>>& fruits) {
        if (x == n - 1 && y == n - 1) return 0;
        if (dp[x][y] != -1) return dp[x][y];
        int tmp = 0;
        for (int i = 0; i < 3; ++ i) {
            int nx = x + dir2[i][0];
            int ny = y + dir2[i][1];
            if (ny >= n || nx == ny || nx > ny) continue;
            tmp = std::max(tmp, dfs2(nx, ny, fruits));
        }
        dp[x][y] = tmp + fruits[x][y];;
        return dp[x][y];
    }
};",1460907679
jlallas384,jlallas384,208,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans = 0
        for i in range(len(s)):
            frm = ord(s[i]) - 97
            t1 = 0
            while frm != ord(t[i]) - 97:
                t1 += nextCost[frm]
                frm = (frm + 1) % 26
            frm = ord(s[i]) - 97
            t2 = 0
            while frm != ord(t[i]) - 97:
                t2 += previousCost[frm]
                frm = (frm - 1) % 26
            ans += min(t1, t2)
        return ans",1460805894
jlallas384,jlallas384,208,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        turn = False
        at = 10
        while n > 0 and at > 0 and n - at >= 0:
            n -= at
            at -= 1
            turn = not turn
        return turn",1460800415
jlallas384,jlallas384,208,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> segs(n);
        vector<int> kill(n + 1);
        for (auto q: queries) {
            segs[q[0]].push_back(q[1]);
        }
        int ans = 0;
        int active = 0;
        multiset<int> st;
        for (int i = 0; i < n; i++) {
            active -= kill[i];
            for (int x: segs[i]) {
                st.insert(x);
            }
            while (active < nums[i] && st.size()) {
                auto it = st.rbegin();
                int r = *it;
                st.erase(st.find(*it));
                if (r < i) continue;
                active++;
                kill[r + 1]++;
                ans++;
            }
            if (active < nums[i]) {
                return -1;
            }
        }
        return queries.size() - ans;
    }
};",1460848464
jlallas384,jlallas384,208,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = sum(fruits[i][i] for i in range(n)) + fruits[-1][0] + fruits[0][-1]
        for i in range(n):
            fruits[i][i] = 0

        dp = [[-1e9] * n for i in range(n)]
        dp[-1][0] = 0
        for i in range(n - 1):
            for j in range(n):
                for to in range(-1, 2):
                    nj = to + j
                    if nj >= 0 and nj < n:
                        dp[nj][i + 1] = max(dp[nj][i + 1], dp[j][i] + fruits[nj][i + 1])
        ans += dp[-1][-1]
        dp = [[-1e9] * n for i in range(n)]
        dp[0][-1] = 0
        for i in range(n - 1):
            for j in range(n):
                for to in range(-1, 2):
                    nj = to + j
                    if nj >= 0 and nj < n:
                        dp[i + 1][nj] = max(dp[i + 1][nj], dp[i][j] + fruits[i + 1][nj])
        ans += dp[-1][-1]
        return ans - 2 * fruits[-1][-1]",1460902355
jason7708,jason7708,212,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long ans = 0;

        auto check = [&] (char c1, char c2) {
            long long c = 0;
            while(c1 != c2) {
                int j = c1 - 'a';
                c += nextCost[j];
                c1 = c1 == 'z' ? 'a' : c1+1;
            }
            return c;
        };

        auto check2 = [&] (char c1, char c2) {
            long long c = 0;
            while(c1 != c2) {
                int j = c1 - 'a';
                c += previousCost[j];
                c1 = c1 == 'a' ? 'z' : c1 - 1;
            }
            return c;
        };
        
        for(int i=0; i<n; i++) {
            if(s[i] == t[i]) continue;
            ans += min(check(s[i], t[i]), check2(s[i], t[i]));
        }
        return ans;
    }
};",1460837222
jason7708,jason7708,212,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10; i>=0; i--) {
            if(i > n) {
                return i % 2;
            }
            n -= i;
        }
        return true;
    }
};",1460797169
jason7708,jason7708,212,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), m = queries.size();

        ranges::sort(queries);

        priority_queue<int> pq;
        vector<int> diff(n+1, 0);
        int cur = 0, j = 0;
        int pick = 0;
        for(int i=0; i<n; i++) {
            cur += diff[i];
            int x = nums[i] + cur;
            while(j < m && queries[j][0] <= i) {
                if(queries[j][1] >= i) {
                    pq.push(queries[j][1]);
                }
                j++;
            }
            // cout << i << ' ' << j << ' ' << x << ' ' << cur << '\n';
            for(int k=0; k<x; k++) {
                if(pq.empty())
                    return -1;
                int r = pq.top();
                pq.pop();
                // cout << ""r:"" << r << '\n';
                if(r < i) {
                    k--;
                    continue;
                }
                pick++;
                cur--;
                diff[r+1]++;
            }
        }
        return m - pick;
    }
};",1460909694
jason7708,jason7708,212,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for(int i=0; i<n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }

        vector<vector<int>> dp(n, vector<int>(n, -1));
        auto dfs = [&] (auto&& dfs, int i, int j) {
            if(j == n-1) {
                if(i == n-1)
                    return 0;
                return INT_MIN;
            }
            if(dp[i][j] != -1) {
                return dp[i][j];
            }
            int res = dfs(dfs, i, j+1);
            if(i < n-1)
                res = max(res, dfs(dfs, i+1, j+1));
            if(i > (n+1) / 2)
                res = max(res, dfs(dfs, i-1, j+1));
            res += fruits[i][j];
            dp[i][j] = res;
            return res;
        };

        vector<vector<int>> dp2(n, vector<int>(n, -1));
        auto dfs2 = [&] (auto&& dfs2, int i, int j) {
            if(i == n-1) {
                if(j == n-1)
                    return 0;
                return INT_MIN;
            }
            if(dp2[i][j] != -1) {
                return dp2[i][j];
            }
            int res = dfs2(dfs2, i+1, j);
            if(j < n-1)
                res = max(res, dfs2(dfs2, i+1, j+1));
            if(j > (n+1) / 2)
                res = max(res, dfs2(dfs2, i+1, j-1));
            res += fruits[i][j];
            dp2[i][j] = res;
            return res;
        };

        return ans + dfs(dfs, n-1, 0) + dfs2(dfs2, 0, n-1);
    }
};",1460880576
Md Abedin,MdAbedin,214,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans = 0

        for c1,c2 in zip(s,t):
            c = c1
            x1 = 0

            while c != c2:
                ci = ord(c)-ord(""a"")
                x1 += nextCost[ci]
                c = ascii_lowercase[(ci+1)%26]

            c = c1
            x2 = 0

            while c != c2:
                ci = ord(c)-ord(""a"")
                x2 += previousCost[ci]
                c = ascii_lowercase[(ci-1)%26]

            ans += min(x1,x2)

        return ans",1460806131
Md Abedin,MdAbedin,214,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        x = 10
        t = 0
        
        while True:
            if n < x: return bool(t%2)
            n -= x
            x -= 1
            t += 1",1460798294
Md Abedin,MdAbedin,214,3647,cpp,"int t[400000];
int lazy[400000];

void build(vector<int>& a, int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v*2, tl, tm);
        build(a, v*2+1, tm+1, tr);
        t[v] = max(t[v*2], t[v*2 + 1]);
    }
}

void push(int v) {
    t[v*2] += lazy[v];
    lazy[v*2] += lazy[v];
    t[v*2+1] += lazy[v];
    lazy[v*2+1] += lazy[v];
    lazy[v] = 0;
}

void update(int v, int tl, int tr, int l, int r, int addend) {
    if (l > r) 
        return;
    if (l == tl && tr == r) {
        t[v] += addend;
        lazy[v] += addend;
    } else {
        push(v);
        int tm = (tl + tr) / 2;
        update(v*2, tl, tm, l, min(r, tm), addend);
        update(v*2+1, tm+1, tr, max(l, tm+1), r, addend);
        t[v] = max(t[v*2], t[v*2+1]);
    }
}

int query(int v, int tl, int tr, int l, int r) {
    if (l > r)
        return -100001;
    if (l == tl && tr == r)
        return t[v];
    push(v);
    int tm = (tl + tr) / 2;
    return max(query(v*2, tl, tm, l, min(r, tm)), 
               query(v*2+1, tm+1, tr, max(l, tm+1), r));
}

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        fill(begin(t),end(t),0);
        fill(begin(lazy),end(lazy),0);
        int ans = 0;
        build(nums,1,0,nums.size()-1);

        for(auto& p : queries) update(1,0,nums.size()-1,p[0],p[1],-1);
        if(query(1,0,nums.size()-1,0,nums.size()-1) > 0) return -1;

        sort(queries.begin(),queries.end(),[](const vector<int>& lhs,const vector<int>& rhs){return lhs[1] < rhs[1] || (lhs[1] == rhs[1] && lhs[1]-lhs[0] < rhs[1]-rhs[0]);});

        for(auto& p : queries){
            if(query(1,0,nums.size()-1,p[0],p[1]) == 0) continue;
            update(1,0,nums.size()-1,p[0],p[1],1);
            ans++;
        }

        return ans;
    }
};

















",1460896438
Md Abedin,MdAbedin,214,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = sum(fruits[i][i] for i in range(n))
        for i in range(n): fruits[i][i] = 0

        dp = [[0]*n for i in range(n)]
        dp[-1][0] = fruits[-1][0]

        for c in range(1,n):
            for r in range(n-1,-1,-1):
                if r < n-1-c or r < n//2: break
                dp[r][c] = fruits[r][c] + max(dp[r2][c-1] if r2 in range(n) else 0 for r2 in [r-1,r,r+1])

        dp2 = [[0]*n for i in range(n)]
        dp2[0][-1] = fruits[0][-1]

        for r in range(1,n):
            for c in range(n-1,-1,-1):
                if c < n-1-r or c < n//2: break
                dp2[r][c] = fruits[r][c] + max(dp2[r-1][c2] if c2 in range(n) else 0 for c2 in [c-1,c,c+1])

        return ans + dp[-1][-1] + dp2[-1][-1]",1460915395
yumiysong,yumiysong,215,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long answer = 0;
        long[][] cache = new long[26][26];
        for (int i = 0; i < 26; ++i) {
            for (int j = 0; j < i; ++j) {
                cache[i][j] = -1;
            }
            for (int j = i + 1; j < 26; ++j) {
                cache[i][j] = -1;
            }
        } // fill with -1 except for when i = j
        for (int i = 0; i < s.length(); ++i) {
            int a = s.charAt(i) - 'a';
            int b = t.charAt(i) - 'a';
            if (cache[a][b] >= 0) {
                answer += cache[a][b];
                continue;
            }
            int p = a;
            cache[a][b] = 0;
            while (p != b) {
                cache[a][b] += nextCost[p];
                p = (p+1)%26;
            }
            long temp = 0;
            p = a;
            while (p != b) {
                temp += previousCost[p];
                p = (p+25)%26;
            }
            if (temp < cache[a][b]) {
                cache[a][b] = temp;
            }
            answer += cache[a][b];
        }
        return answer;
    }
}",1460836368
yumiysong,yumiysong,215,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int remove = 10;
        while (n >= remove) {
            n -= remove;
            --remove;
        }
        return remove%2 == 1;
    }
}",1460808095
yumiysong,yumiysong,215,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (a,b) -> {
            if (a[0] == b[0]) {
                return a[1]-b[1];
            }
            return a[0]-b[0];
        });
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        TreeMap<Integer,Integer> removes = new TreeMap<>();
        int size = 0;
        int pos = 0;
        int max = 0;
        for (int i = 0; i < nums.length; ++i) {
            int start = pos;
            while (pos < queries.length && queries[pos][0] == i) {
                pq.add(queries[pos][1]);
                ++pos;
            }
            while (pq.peek() != null && pq.peek() < i) {
                pq.poll();
            }
            if (pq.size() < nums[i]) {
                return -1;
            }
            while (pq.size()-size > nums[i]) {
                if (pos-start == 0) {
                    break;
                }
                removes.put(queries[start][1], removes.getOrDefault(queries[start][1],0) + 1);
                ++size;
                ++start;
            }
            while (size > 0 && pos - start > 0 && removes.lastKey() > queries[start][1]) {
                removes.put(queries[start][1], removes.getOrDefault(queries[start][1],0) + 1);
                if (removes.lastEntry().getValue() > 1) {
                    removes.put(removes.lastKey(), removes.lastEntry().getValue() - 1);
                } else {
                    removes.pollLastEntry();                    
                }
                ++start;
            }
            while (pq.size()-size < nums[i]) {
                if (removes.lastEntry().getValue() > 1) {
                    removes.put(removes.lastKey(), removes.lastEntry().getValue() - 1);
                } else {
                    removes.pollLastEntry();                    
                }
                --size;
            }
            if (size != 0 && removes.firstKey() == i) {
                max += removes.firstEntry().getValue();
                size -= removes.firstEntry().getValue();
                removes.pollFirstEntry();
            }
        }
        return max;
    }
}",1460897820
yumiysong,yumiysong,215,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        for (int i = 0; i < n-1; ++i) {
            fruits[n-1][n-1] += fruits[i][i];
            fruits[i][i] = -1;
        }
        for (int i = 0; i < n/2; ++i) {
            for (int j = i + 1; j < n-i-1; ++j) {
                fruits[i][j] = 0;
                fruits[j][i] = 0;
            }
        }
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j <= i; ++j) {
                if (fruits[i][n-j-1] == -1) {
                    break;
                }
                int max = Math.max(fruits[i-1][n-j-1],fruits[i-1][n-j-2]);
                if (j > 0) {
                    max = Math.max(max, fruits[i-1][n-j]);
                }
                fruits[i][n-j-1] += max;
                max = Math.max(fruits[n-j-1][i-1],fruits[n-j-2][i-1]);
                if (j > 0) {
                    max = Math.max(max, fruits[n-j][i-1]);
                }
                fruits[n-j-1][i] += max;
                if (i == n-1) {
                    break;
                }
            }
        }
        return fruits[n-1][n-1];
    }
}",1460915628
w0w0,w0w0,217,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans = 0
        for x, y in zip(s, t):
            i = ord(x) - 97
            j = ord(y) - 97
            cost1 = 0
            k = i
            while k != j:
                cost1 += nextCost[k]
                k = (k + 1) % 26
            cost2 = 0
            k = i
            while k != j:
                cost2 += previousCost[k]
                k = (k - 1) % 26
            ans += min(cost1, cost2)

        return ans",1460827626
w0w0,w0w0,217,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        if n == 10:
            return True

        cur = 10
        ans = True
        while True:
            ans = not ans
            if n >= cur:
                n -= cur
                cur -= 1
            else:
                break

        return ans",1460804342
w0w0,w0w0,217,3647,python3,"class SegmentTree:
    def __init__(self, l, r):
        self.l = l
        self.r = r

        self.info = None
        self.assign = None
        self.add = 0

        self.left = None
        self.right = None

    @staticmethod
    def build(nums, l=None, r=None):
        if l is None:
            l = 0
        if r is None:
            r = len(nums) - 1

        node = SegmentTree(l, r)
        if l < r:
            m = (l + r) // 2
            node.left = SegmentTree.build(nums, l, m)
            node.right = SegmentTree.build(nums, m + 1, r)
            node.info = max(node.left.info, node.right.info)
        else:
            node.info = nums[l]
        return node

    def update(self):
        if self.add:
            self.info += self.add
            if self.left:
                self.left.add += self.add
            if self.right:
                self.right.add += self.add
            self.add = 0

    def rangeAdd(self, l, r, val):
        self.update()

        if self.l == l and self.r == r:
            self.info += val
            if self.left:
                self.left.update()
                self.left.add += val
            if self.right:
                self.right.update()
                self.right.add += val
        else:
            m = (self.l + self.r) // 2
            if l > m:
                self.left.update()
                self.right.rangeAdd(l, r, val)
            elif r <= m:
                self.left.rangeAdd(l, r, val)
                self.right.update()
            else:
                self.left.rangeAdd(l, m, val)
                self.right.rangeAdd(m + 1, r, val)
            self.info = max(self.left.info, self.right.info)

    def query(self, l, r):
        self.update()

        if self.l == l and self.r == r:
            return self.info
        m = (self.l + self.r) // 2
        if l > m:
            return self.right.query(l, r)
        if r <= m:
            return self.left.query(l, r)
        return max(self.left.query(l, m), self.right.query(m + 1, r))

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        n = len(nums)
        q = len(queries)

        root = SegmentTree.build(nums)
        pq = []

        ans = q
        j = 0
        for i in range(n):
            while j < q and queries[j][0] <= i:
                heappush(pq, [-queries[j][1], queries[j][0]])
                j += 1

            while root.query(i, i) > 0:
                if pq == []:
                    return -1
                r, l = heappop(pq)
                root.rangeAdd(l, -r, -1)
                ans -= 1

        return ans",1460872432
w0w0,w0w0,217,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        ans = 0
        for i in range(n):
            ans += fruits[i][i]

        dp = [[-inf] * n for _ in range(n)]
        dp[0][n - 1] = fruits[0][n - 1]
        for i in range(1, n):
            for j in range(i + 1, n):
                dp[i][j] = fruits[i][j] + max([dp[i - 1][k] if k < n else 0 for k in [j - 1, j, j + 1]])

        dp[n - 1][0] = fruits[n - 1][0]
        for j in range(1, n):
            for i in range(j + 1, n):
                dp[i][j] = fruits[i][j] + max([dp[k][j - 1] if k < n else 0 for k in [i - 1, i, i + 1]])

        return ans + dp[n - 2][n - 1] + dp[n - 1][n - 2]",1460894469
Ash Ketchum,user8787Y,218,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], prevCost: List[int]) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            sn = ord(s[i]) - ord('a')
            tn = ord(t[i]) - ord('a')
            x, y = 0, 0
            i, j = sn, tn
            if i < j:
                ti, tj = i, j
                while ti != tj:
                    x += nextCost[ti%26]
                    ti += 1
                while j-26 != i:
                    y += prevCost[i%26]
                    i -= 1
            else:
                ti, tj = i, j
                while ti-26 != tj:
                    x += nextCost[ti%26]
                    ti += 1
                while i != j:
                    y += prevCost[i%26]
                    i -= 1
            ans += min(x, y)
        return ans",1460821306
Ash Ketchum,user8787Y,218,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        c = 0
        k = 10
        while True:
            if n < k:
                return c%2!=0
            n -= k
            k -= 1
            c += 1
        ",1460799167
Ash Ketchum,user8787Y,218,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        m = len(queries)
        n = len(nums)
        str = [0]*(n+1)
        c = 0
        ans = 0
        l = 0
        q = []
        for i in range(n):
            c += str[i]
            k = nums[i] - c
            if k <= 0:
                continue
            j = 0
            while j < len(q) and q[j][1] < i:
                j += 1
            q = q[j:]
            while q and q[-1][1] < i:
                q.pop()
            while l < m and queries[l][1] < i:
                l += 1
            while l < m and queries[l][0] <= i:
                if queries[l][0] <= i <= queries[l][1]:
                    q.append(queries[l])
                l += 1
            if len(q) < k:
                return -1
            q.sort(key=lambda x: x[1])
            for i in range(k):
                a, b = q.pop()
                str[b+1] -= 1
            ans += k
            c += k
        return m-ans",1460916701
Ash Ketchum,user8787Y,218,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0
        for i in range(n):
            for j in range(n-1-i):
                fruits[i][j] = 0
        for i in range(1, n):
            for j in range(n-1, max(n-2-i, i), -1):
                x = 0
                if j == n-1:
                    x = max(fruits[i-1][j], fruits[i-1][j-1])
                else:
                    x = max(fruits[i-1][j], fruits[i-1][j-1], fruits[i-1][j+1])
                fruits[i][j] += x
        for j in range(1, n):
            for i in range(n-1, max(n-2-j, j), -1):
                x = 0
                if i == n-1:
                    x = max(fruits[i][j-1], fruits[i-1][j-1])
                else:
                    x = max(fruits[i][j-1], fruits[i-1][j-1], fruits[i+1][j-1])
                fruits[i][j] += x
        return ans+fruits[n-2][n-1]+fruits[n-1][n-2]",1460860355
Wei Liu,nevergiveup,220,3591,java,"class Solution {

    private long getNextCost(char source, char target, int[] nextCost) {
        int sourceIdx = source - 'a';
        int targetIdx = target - 'a';
        long ans = 0;
        for (int i = sourceIdx;i != targetIdx;i = (i + 1) % 26) {
            ans += nextCost[i];
        }
        return ans;
    }

    private long getPrevCost(char source, char target, int[] previousCost) {
        int sourceIdx = source - 'a';
        int targetIdx = target - 'a';
        long ans = 0;
        for (int i = sourceIdx;i != targetIdx;i = (i - 1 + 26) % 26) {
            ans += previousCost[i];
        }
        return ans;
    }

    private long getCost(char source, char target, int[] nextCost, int[] previousCost) {
        return Math.min(getNextCost(source, target, nextCost), getPrevCost(source, target, previousCost));
    }

    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        for (int i = 0;i < s.length();i ++) {
            ans += getCost(s.charAt(i), t.charAt(i), nextCost, previousCost);
        }
        return ans;
    }

}",1460810958
Wei Liu,nevergiveup,220,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean aliceTurn = true;
        for (int i = 10;i >= 1;i --) {
            if (n >= i) {
                n -= i;
            } else {
                if (aliceTurn) {
                    return false;
                } else {
                    return true;
                }
            }
            aliceTurn = !aliceTurn;
        }
        return true;
    }   
}",1460797268
Wei Liu,nevergiveup,220,3647,java,"class Solution {

    private static List<Integer>[] ends = new ArrayList[100010];

    static {
        for (int i = 0;i < ends.length;i ++) {
            ends[i] = new ArrayList<>();
        }
    }

    private int[] update;

    public int maxRemoval(int[] nums, int[][] queries) {
        update = new int[nums.length + 1];
        for (int i = 0;i < nums.length;i ++) {
            ends[i].clear();
        }
        for (int[] query : queries) {
            ends[query[0]].add(query[1]);
        }
        TreeMap<Integer, Integer> map = new TreeMap<>();
        int need = 0, cur = 0;
        for (int i = 0;i < nums.length;i ++) {
            while (!map.isEmpty() && map.firstKey() < i) {
                int key = map.firstKey();
                map.remove(key);
            }
            for (int end : ends[i]) {
                map.put(end, map.getOrDefault(end, 0) + 1);
            }
            cur += update[i];
            while (cur < nums[i] && !map.isEmpty()) {
                Map.Entry<Integer, Integer> entry = map.lastEntry();
                int key = entry.getKey();
                int count = entry.getValue();
                cur ++;
                update[key + 1] --;
                if (count - 1 > 0) {
                    map.put(key, count - 1);
                } else {
                    map.remove(key);
                }
                need ++;
            }
            if (cur < nums[i]) {
                return - 1;
            }
        }
        return queries.length - need;
    }
}",1460879259
Wei Liu,nevergiveup,220,3648,java,"class Solution {



    private static int[][] dp = new int[1010][1010];

    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        int ans = 0;
        for (int i = 0;i < n;i ++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        // dp col
        for (int i = 0;i < n;i ++) {
            for (int j = 0;j < n;j ++) {
                dp[i][j] = - 1;
            }
        }
        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 1;j < n;j ++) {
            for (int i = 0;i < n;i ++) {
                for (int offset = - 1;offset <= 1;offset ++) {
                    int prev = i + offset;
                    if (prev >= 0 && prev < n && dp[prev][j - 1] >= 0) {
                        dp[i][j] = Math.max(dp[i][j], dp[prev][j - 1] + fruits[i][j]);
                    }
                }
            }
        }
        ans += dp[n - 1][n - 1];
        // dp row
        for (int i = 0;i < n;i ++) {
            for (int j = 0;j < n;j ++) {
                dp[i][j] = - 1;
            }
        }
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 1;i < n;i ++) {
            for (int j = 0;j < n;j ++) {
                for (int offset = - 1;offset <= 1;offset ++) {
                    int prev = j + offset;
                    if (prev >= 0 && prev < n && dp[i - 1][prev] >= 0) {
                        dp[i][j] = Math.max(dp[i][j], dp[i - 1][prev] + fruits[i][j]);
                    }
                }
            }
        }
        ans += dp[n - 1][n - 1];
        return ans;
    }
    
    
}",1460911508
Tamminaina Yugandhar,heisenberg_003,221,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n=(int)s.size();
        vector<long long> a,b;
        for(int i=0;i<26;i++){
            a.push_back(nextCost[i]);
            b.push_back(previousCost[i]);
        }
        for(int i=1;i<26;i++){
            a[i]+=a[i-1];
            b[i]+=b[i-1];
        }
        long long ans=0;
        for(int i=0;i<n;i++){
            if(s[i]!=t[i]){
                int ind1=s[i]-'a',ind2=t[i]-'a';
                long long val1=0,val2=0;
                if(ind2>ind1){
                    val1=a[ind2-1];
                    if(ind1-1>=0) val1-=a[ind1-1];
                }
                else{
                    val1=a[25];
                    if(ind1-1>=0) val1-=a[ind1-1];
                    if(ind2-1>=0) val1+=a[ind2-1];
                }
                if(ind1>ind2){
                    val2=b[ind1]-b[ind2];
                }
                else{
                    val2=b[ind1];
                    val2+=b[25]-b[ind2];
                }
                ans+=min(val1,val2);
            }
        }
        return ans;
    }
};",1460815506
Tamminaina Yugandhar,heisenberg_003,221,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x=0;
        int req=10;
        while(n>=req){
            n-=req;
            x++;
            req--;
        }
        if(x%2==0) return false;
        return true;
    }
};",1460797478
Tamminaina Yugandhar,heisenberg_003,221,3647,cpp,"class Solution {
public:
    
    vector<int> tree,lazy;
    
    void push(int v){
        tree[2*v+1]+=lazy[v];
        tree[2*v+2]+=lazy[v];
        lazy[2*v+1]+=lazy[v];
        lazy[2*v+2]+=lazy[v];
        lazy[v]=0;
    }
    
    void update(int v, int tl, int tr, int l, int r, int x){
        if(l>r) return;
        if(l==tl && r==tr){
            tree[v]+=x;
            lazy[v]+=x;
        }
        else{
            push(v);
            int m=(tl+tr)/2;
            update(2*v+1,tl,m,l,min(r,m),x);
            update(2*v+2,m+1,tr,max(l,m+1),r,x);
            tree[v]=max(tree[2*v+1],tree[2*v+2]);
        }
    }
    
    int get(int v, int tl, int tr, int l, int r, int x){
        if(tl>r || tr<l) return -1;
        if(tree[v]<=x) return -1;
        if(tl==tr) return tl;
        push(v);
        int m=(tl+tr)/2;
        int left=get(2*v+1,tl,m,l,r,x);
        if(left!=-1) return left;
        return get(2*v+2,m+1,tr,l,r,x);
    }
    
    int maxRemoval(vector<int>& a, vector<vector<int>>& v) {
        int n=(int)a.size();
        int q=(int)v.size();
        vector<int> v1(n,0);
        for(int i=0;i<q;i++){
            int l=v[i][0],r=v[i][1];
            v1[l]++;
            if(r+1<n) v1[r+1]--;
        }
        for(int i=1;i<n;i++) v1[i]+=v1[i-1];
        tree.clear();
        tree.resize(4*n);
        lazy.clear();
        lazy.resize(4*n);
        for(int i=0;i<n;i++){
            if(a[i]>v1[i]) return -1;
            int val=-(v1[i]-a[i]);
            update(0,0,n-1,i,i,val);
        }
        vector<vector<int>> v3;
        vector<vector<int>> v4(n);
        for(int i=0;i<q;i++){
            int l=v[i][0],r=v[i][1];
            v4[r].push_back(l);
        }
        for(int i=0;i<n;i++){
            sort(v4[i].begin(),v4[i].end());
        }
        for(int i=0;i<n;i++){
            while((int)v4[i].size()>0){
                int l=v4[i].back();
                v3.push_back({l,i});
                v4[i].pop_back();
            }
        }
        int ans=0;
        for(int i=0;i<q;i++){
            int l=v3[i][0],r=v3[i][1];
            int ind=get(0,0,n-1,l,r,-1);
            if(ind==-1){
                ans++;
                update(0,0,n-1,l,r,1);
            }
        }
        return ans;
    }
};",1460876435
Tamminaina Yugandhar,heisenberg_003,221,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& v) {
        int n=(int)v.size();
        int ans=0;
        for(int i=0;i<n;i++) ans+=v[i][i];
        int h=(n/2);
        int sz=1,prevsz=1;
        for(int i=1;i<n-1;i++){
            if(i<h) sz++;
            else if(i>h) sz--;
            else if(i==h && n%2==0) sz--;
            for(int j=n-1;j>=(n-sz);j--){
                int val=v[i][j];
                if(j+1<n) val=max(val,v[i][j]+v[i-1][j+1]);
                if(j>=(n-prevsz)) val=max(val,v[i][j]+v[i-1][j]);
                if(j-1>=(n-prevsz)) val=max(val,v[i][j]+v[i-1][j-1]);
                v[i][j]=val;
            }
            prevsz=sz;
        }
        sz=1;
        prevsz=1;
        for(int i=1;i<n-1;i++){
            if(i<h) sz++;
            else if(i>h) sz--;
            else if(i==h && n%2==0) sz--;
            for(int j=n-1;j>=(n-sz);j--){
                int val=v[j][i];
                if(j+1<n) val=max(val,v[j][i]+v[j+1][i-1]);
                if(j>=(n-prevsz)) val=max(val,v[j][i]+v[j][i-1]);
                if(j-1>=(n-prevsz)) val=max(val,v[j][i]+v[j-1][i-1]);
                v[j][i]=val;
            }
            prevsz=sz;
        }
        ans+=v[n-1][n-2]+v[n-2][n-1];
        return ans;
    }
};",1460912518
yu46656,yu46656,224,3591,cpp,"class Solution {
public:
    long long shiftDistance(const std::string& s, const std::string& t,
                            const std::vector<int>& nxt_costs,
                            const std::vector<int>& prv_costs) {
        long long nxt_table[26][26]{ 0 };
        long long prv_table[26][26]{ 0 };

        for (int diff{ 1 }; diff < 26; ++diff) {
            for (int i{ 0 }; i < 26; ++i) {
                nxt_table[i][(i + diff) % 26] =
                    nxt_table[i][(i + diff - 1) % 26] +
                    nxt_costs[(i + diff - 1) % 26];
            }
        }

        for (int diff{ 1 }; diff < 26; ++diff) {
            for (int i{ 0 }; i < 26; ++i) {
                prv_table[i][(i - diff + 26) % 26] =
                    prv_table[i][(i - diff + 1 + 26) % 26] +
                    prv_costs[(i - diff + 1 + 26) % 26];
            }
        }

        int n{ static_cast<int>(s.size()) };

        long long ret{ 0 };

        for (int i{ 0 }; i < n; ++i) {
            int a{ (s[i] - 'a') };
            int b{ (t[i] - 'a') };
            ret += std::min(nxt_table[a][b], prv_table[a][b]);
        }

        return ret;
    }
};
",1460826703
yu46656,yu46656,224,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ret{ false };

        for (int i{ 10 }; 0 < i; --i) {
            if (n < i) { return ret; }
            n -= i;
            ret = !ret;
        }

        return ret;
    }
};
",1460803221
yu46656,yu46656,224,3647,cpp,"class Solution {
public:
    struct ACompare {
        bool operator()(const std::vector<int>& b,
                        const std::vector<int>& a) const {
            return b[1] < a[1];
        }
    };

    struct BCompare {
        bool operator()(const std::vector<int>& b,
                        const std::vector<int>& a) const {
            return a[0] < b[0];
        }
    };

    int maxRemoval(const std::vector<int>& nums,
                   std::vector<std::vector<int>>& queries) {
        int n{ static_cast<int>(nums.size()) };
        int q{ static_cast<int>(queries.size()) };

        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>,
                            ACompare>
            aq;

        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>,
                            BCompare>
            bq{ queries.begin(), queries.end() };

        int ret{ 0 };

        int acc{ 0 };

        std::vector<int> dels;
        dels.resize(n + 1, 0);

        for (int i{ 0 }; i < n;) {
            while (!bq.empty()) {
                const std::vector<int>& b{ bq.top() };
                if (i < b[0]) { break; }
                aq.push(b);
                bq.pop();
            }

            for (;;) {
                if (nums[i] <= acc) {
                    acc += dels[++i];
                    break;
                }

                if (aq.empty()) { return -1; }

                const std::vector<int>& a{ aq.top() };
                if (a[1] < i) { return -1; }

                ++ret;

                ++acc;
                ++dels[a[0]];
                --dels[a[1] + 1];

                aq.pop();
            }
        }

        return q - ret;
    }
};
",1460913576
yu46656,yu46656,224,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(std::vector<std::vector<int>>& fruits) {
        int n{ static_cast<int>(fruits.size()) };

        int ret{ 0 };

        for (int i{ 0 }; i < n; ++i) { ret += fruits[i][i]; }

        std::vector<std::vector<int>> dp;
        dp.resize(n);

        for (int i{ 0 }; i < n; ++i) { dp[i].resize(n, 0); }

        for (int i{ n - 2 }; 0 <= i; --i) {
            for (int j{ n - 1 }; i < j; --j) {
                int ans{ 0 };

                int nxt_i{ i + 1 };

                for (int nxt_j{ j - 1 }; nxt_j <= j + 1; ++nxt_j) {
                    if (nxt_i < nxt_j && nxt_j < n) {
                        ans = std::max(ans, dp[nxt_i][nxt_j]);
                    }
                }

                dp[i][j] = fruits[i][j] + ans;
            }
        }

        for (int j{ n - 2 }; 0 <= j; --j) {
            for (int i{ n - 1 }; j < i; --i) {
                int ans{ 0 };

                int nxt_j{ j + 1 };

                for (int nxt_i{ i - 1 }; nxt_i <= i + 1; ++nxt_i) {
                    if (nxt_j < nxt_i && nxt_i < n) {
                        ans = std::max(ans, dp[nxt_i][nxt_j]);
                    }
                }

                dp[i][j] = fruits[i][j] + ans;
            }
        }

        return dp[0][n - 1] + dp[n - 1][0] + ret;
    }
};
",1460871975
Pavel,Pavel_For_Sure,225,3591,csharp,"public class Solution 
{
    public long ShiftDistance(string s, string t, int[] nextCost, int[] previousCost) 
    {
        long res = 0;
        long[] preSumNext = new long[26], preSumPrev = new long[26];
        for (int i = 1; i < 26; i++)
        {
            preSumNext[i] = preSumNext[i - 1] + nextCost[i-1];
            preSumPrev[^(i + 1)] = preSumPrev[^i] + previousCost[^i];
        }
        
        for (int i = 0; i < s.Length; i++)
        {
            int l = s[i] - 'a', r = t[i] - 'a';
            if (l == r)
                continue;
            long next, prev = 0;
            //next
            if (l > r)
                next = preSumNext[^1] - preSumNext[l] + nextCost[^1] + preSumNext[r];
            else
            {
                next = preSumNext[r] - preSumNext[l];
            }
        
            //prev
        
            if (l < r)
                prev = preSumPrev[0] + previousCost[0] + preSumPrev[r] - preSumPrev[l];
            else
            {
                prev = preSumPrev[r] - preSumPrev[l];
            }
        
            res += Math.Min(prev, next);
        }
        
        return res;
    }
}",1460842454
Pavel,Pavel_For_Sure,225,3625,csharp,"public class Solution 
{
    public bool CanAliceWin(int n) 
    {
        int add = 11;
        bool isAlice = false;
        for(int i=0;i<=n;i+= add)
        {
            isAlice = !isAlice;
            add--;
        }

        return !isAlice;
    }
}",1460800064
Pavel,Pavel_For_Sure,225,3647,csharp,"public class Solution 
{
    static Comparer<int> comparer = Comparer<int>.Create((x, y) => y.CompareTo(x));
    public int MaxRemoval(int[] nums, int[][] queries) 
    {
        PriorityQueue<int, int> candidates = new(comparer), taken = new();
        Dictionary<int, List<int>> ranges = new Dictionary<int, List<int>>();
        foreach (var q in queries)
        {
            int start = q[0];
            if (!ranges.ContainsKey(start))
                ranges[start] = new();
        
            ranges[start].Add(q[1]);
        }
        
        int counter = 0, toTake = 0;
        for (int i = 0; i < nums.Length; i++)
        {
            if (ranges.TryGetValue(i, out var list))
            {
                foreach (var end in list)
                    candidates.Enqueue(counter++, end);
            }
        
            Clear(i, taken);
        
            while (candidates.Count > 0 && taken.Count < nums[i])
            {
                candidates.TryDequeue(out var _, out var priority);
                if (priority < i)
                {
                    candidates = new();
                    break;
                }
                taken.Enqueue(counter++, priority);
                toTake++;
            }
        
            if (taken.Count < nums[i])
                return -1;
        
            continue;
        }
        
        return queries.Length - toTake;
        
        void Clear(int i, PriorityQueue<int, int> q)
        {
            while (q.TryPeek(out var _, out var priority))
            {
                if (priority >= i)
                    break;
                q.Dequeue();
            }
        }
    }
}",1460880836
Pavel,Pavel_For_Sure,225,3648,csharp,"public class Solution 
{
    static int[] dir = [0, 1, -1];  
    public int MaxCollectedFruits(int[][] fruits) 
    {
        int n = fruits.Length;
        int[,] left = new int[n, n],rigth = new int[n, n];
        
        left[n - 1, n - 2] = fruits[^1][^2];
        int col = n-2,max = n-2;
        while (col > 0)
        {
            for (int i = n-1; i > max; i--)
            {
                foreach (var d in dir)
                {
                    int next = i + d;
                    if (next >= n)
                        continue;
                    left[next, col - 1] = Math.Max(left[next, col-1], left[i, col] + fruits[next][col-1]);
                }
            }
            col--;
            max--;
        }
        
        rigth[n - 2, n-1] = fruits[^2][^1];
        max = n-2;
        int row = n - 2;
        while (row > 0)
        {
            for (int i = n-1; i > max; i--)
            {
                foreach (var d in dir)
                {
                    int next = i + d;
                    if (next >= n)
                        continue;
                    rigth[row - 1, next] = Math.Max(rigth[row - 1, next], rigth[row,i] + fruits[row - 1][next]);
                }
            }
            row--;
            max--;
        }
        
        int sum = 0;
        for (int i = 0; i < n; i++)
            sum += fruits[i][i];
        
        return sum + left[n - 1, 0] + rigth[0,n-1];
    }
}",1460913847
littlemiss,littlemiss,227,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long n = s.size(), res = 0;
        for (int i = 0; i < n; i++) {
            long x = s[i] - 'a', y = t[i] - 'a';
            long f = (y - x + 26) % 26, b = (x - y + 26) % 26; 
            long fc = 0, bc = 0;
            for (int j = 0; j < f; j++) {
                fc += nextCost[(x + j) % 26];
            }
            for (int j = 0; j < b; j++) {
                bc += previousCost[(x - j + 26) % 26];
            }
            res += min(fc, bc);
        }
        return res;
    }
};",1460803251
littlemiss,littlemiss,227,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ok = false;
        for (int i = 10; i >= 1; i--) {
            n -= i;
            if (n < 0) {
                return ok;
            }
            ok = !ok;
        }
        return true;
    }
};",1460796259
littlemiss,littlemiss,227,3647,cpp,"template<class Fun> class y_combinator_result {
  Fun fun_;
public:
  template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
  template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << "", "" << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << '}'; }
void debug_out() { cout << endl; }
template<typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << ' ' << H; debug_out(T...); }
#define debug(...) cout << ""[Line "" <<  __LINE__ << ""] ("" << #__VA_ARGS__ << ""):"", debug_out(__VA_ARGS__)

template <class T>
struct BIT { //1-indexed
  int n; vector<T> t;
  BIT() {}
  BIT(int _n) {
    n = _n; t.assign(n + 1, 0);
  }
  T query(int i) {
    T ans = 0;
    for (; i >= 1; i -= (i & -i)) ans += t[i];
    return ans;
  }
  void upd(int i, T val) {
    if (i <= 0) return;
    for (; i <= n; i += (i & -i)) t[i] += val;
  }
  void upd(int l, int r, T val) {
    upd(l, val);
    upd(r + 1, -val);
  }
  T query(int l, int r) {
    return query(r) - query(l - 1);
  }
};

/*
[1,2]
[[1,1],[0,0],[1,1],[1,1],[0,1],[0,0]]

res should be 4
{{0, 1}, {0, 0}, {0, 0}, {1, 1}, {1, 1}, {1, 1}}

[0,1,2]
[[1,2],[1,2],[0,0],[1,1],[1,1],[0,1],[2,2],[2,2]]
Expected: 6

use queries start start with i and are longest, if not available, used one that are available before

use query that contains i and has highest r
{-r, l}
*/
class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& queries) {
        int n = a.size(), m = queries.size();
        for (auto& q : queries) {
            q[0]++, q[1]++;
        }
        sort(queries.begin(), queries.end(), [](const auto& q1, const auto& q2) {
            if (q1[0] != q2[0]) {
                return q1[0] < q2[0];
            } else {
                return q1[1] - q1[0] < q2[1] - q2[0];
            }
        });
        // debug(queries);
        
        a.insert(a.begin(), 0);
        BIT<int> bit(n + 5);
        int used = 0;
        multiset<pair<int, int>> candq;
        for (int i = 1, j = 0; i <= n; ) {
            int curr = bit.query(i);
            // debug(i, curr, a[i]);
            // debug(""Before cleanup: "", candq);
            while (!candq.empty()) {
                auto [negR, l] = *candq.begin();
                if (!(l <= i && i <= -negR)) {
                    candq.erase(candq.begin());
                } else {
                    break;
                }
            }
            // debug(""After cleanup: "", candq);
            while (j < m) {
                int l = queries[j][0], r = queries[j][1];
                if (l <= i && i <= r) {
                    candq.insert({-r, l});
                    j++;
                } else {
                    break;
                }
            }
            // debug(""After insertions: "", candq);
            if (curr < a[i]) {
                if (candq.empty()) {
                    return -1;
                }
                auto [negR, l] = *candq.begin();
                used++;
                bit.upd(l, -negR, 1);
                candq.erase(candq.begin());
            } else {
                i++;
            }
        }
        return m - used;
    }
};",1460868618
littlemiss,littlemiss,227,3648,cpp,"template<class Fun> class y_combinator_result {
  Fun fun_;
public:
  template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
  template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << "", "" << p.second << ')'; }
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << '}'; }
void debug_out() { cout << endl; }
template<typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << ' ' << H; debug_out(T...); }
#define debug(...) cout << ""[Line "" <<  __LINE__ << ""] ("" << #__VA_ARGS__ << ""):"", debug_out(__VA_ARGS__)

/*
[[11,17,13,0,18],
 [13,12,10,12,19],
 [4,8,10,14,16],
 [2,13,12,7,16],
 [4,9,7,4,3]]

 Expected: 145
*/
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = a.size(), res = 0;
        for (int i = 0; i < n; i++) {
            res += a[i][i];
            a[i][i] = 0;
        }

        const int INF = 1e5 + 5;
        vector<vector<int>> dp;
        
        dp = vector<vector<int>> (n, vector<int> (n, -1));
        function<int(int, int)> rec2 = [&](int x, int y) {
            if (x == n - 1) {
                return y == n - 1 ? 0 : -INF;
            }

            int& mem = dp[x][y];
            if (mem != -1) {
                return mem;
            }
    
            int best = -INF;
            if (y - 1 >= 0) {
                best = max(best, rec2(x + 1, y - 1));
            }
            best = max(best, rec2(x + 1, y));
            if (y + 1 < n) {
                best = max(best, rec2(x + 1, y + 1));
            }
            return mem = a[x][y] + best;
        };
        res += rec2(0, n - 1);
        
        dp = vector<vector<int>> (n, vector<int> (n, -1));
        function<int(int, int)> rec3 = [&](int x, int y) {
            if (y == n - 1) {
                return x == n - 1 ? 0 : -INF;
            }

            int& mem = dp[x][y];
            if (mem != -1) {
                return mem;
            }
    
            int best = -INF;
            if (x - 1 >= 0) {
                best = max(best, rec3(x - 1, y + 1));
            }
            best = max(best, rec3(x, y + 1));
            if (x + 1 < n) {
                best = max(best, rec3(x + 1, y + 1));
            }
            return mem = a[x][y] + best;
        };
        res += rec3(n - 1, 0);

        return res;
    }
};",1460911013
Zamfirescu George-Iulian,SkinnySnakeLimb,228,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n = len(s)
        for i in range(1, 26):
            nextCost[i] += nextCost[i - 1]
            previousCost[i] += previousCost[i - 1]
        nextCost.append(0)
        previousCost.append(0)
            
        def getMinCost(c1, c2):
            i1 = ord(c1) - ord('a')
            i2 = ord(c2) - ord('a')

            if i1 == i2:
                return 0

            if i1 < i2:
                ret = nextCost[i2 - 1] - nextCost[i1 - 1]
                ret = min(ret, previousCost[i1] + previousCost[-2] - previousCost[i2])
            else:
                ret = previousCost[i1] - previousCost[i2]
                ret = min(ret, nextCost[-2] - nextCost[i1 - 1] + nextCost[i2 - 1])

            return ret

        ret = 0
        for i, (c1, c2) in enumerate(zip(s, t)):
            ret += getMinCost(c1, c2)

        return ret",1460826909
Zamfirescu George-Iulian,SkinnySnakeLimb,228,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        pl = 1
        am = 10

        while am <= n:
            n -= am
            am -= 1
            pl = 1 - pl

        return True if pl == 0 else False",1460796824
Zamfirescu George-Iulian,SkinnySnakeLimb,228,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        queries.sort()
        pq = []

        ret = 0
        idq = 0
        am = 0
        decs = []
        for i in range(n):
            while idq < m and i == queries[idq][0]:
                q = queries[idq]
                heappush(pq, -q[1])
                idq += 1

            while len(decs) > 0 and decs[0] == i:
                am -= 1
                heappop(decs)

            while am < nums[i]:
                if len(pq) == 0:
                    return -1
                val = heappop(pq)
                val = -val

                if val < i:
                    return -1
                am += 1
                heappush(decs, val + 1)
                ret += 1

        return m - ret
            
                    
        ",1460883914
Zamfirescu George-Iulian,SkinnySnakeLimb,228,3648,python3,"class Solution:
    def maxCollectedFruits(self, mat: List[List[int]]) -> int:
        n = len(mat)
        ret = -2 * mat[-1][-1]

        for i in range(n):
            ret += mat[i][i]

        dp = [[-1000000000000] * n for _ in range(n)]
        dp[0][-1] = mat[0][-1]
        
        for i in range(1, n):
            for j in range(n // 2, n):
                if i == j and i != n - 1:
                    continue
                dp[i][j] = mat[i][j] + max(dp[i - 1][j], dp[i - 1][j - 1], (dp[i - 1][j + 1] if j + 1 < n else 0))
        ret += dp[-1][-1]

        dp = [[-10000000000000] * n for _ in range(n)]
        dp[-1][0] = mat[-1][0]

        for j in range(1, n):
            for i in range(n // 2, n):
                if i == j and i != n - 1:
                    continue
                dp[i][j] = mat[i][j] + max(dp[i - 1][j - 1], dp[i][j - 1], (dp[i + 1][j - 1] if i + 1 < n else 0))
        ret += dp[-1][-1]

        return ret

        ",1460912865
James Jialun Zhao,frixxxer,231,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        cost = 0
        forward = [[0] * 26 for _ in range(26)]
        backward = [[0] * 26 for _ in range(26)]
        for i in range(26):
            for j in range(1, 26):
                forward[i][(i + j) % 26] = forward[i][(i + j - 1) % 26] + nextCost[(i+j-1) % 26]
        for i in range(26):
            for j in range(1, 26):
                backward[i][(i -j) % 26] = backward[i][(i -j + 1) % 26] + previousCost[(i-j + 1) % 26]
        
        for a, b in zip(s, t):
            a, b = ord(a) - ord('a'), ord(b) - ord('a')
            cost += min(forward[a][b], backward[a][b])
        return cost",1460809107
James Jialun Zhao,frixxxer,231,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        whose_turn = 0
        r = 10
        while n > 0 and r > 0 and r <= n:
            n -= r
            r -= 1
            whose_turn = 1 - whose_turn
        return whose_turn == 1",1460797438
James Jialun Zhao,frixxxer,231,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        sorted_queries = [(l, r) for l, r in queries]
        sorted_queries.sort(key = lambda x: (x[0], -x[1]))
        backup = []
        n, q = len(nums), len(queries)
        taken = 0
        j = 0
        cur = 0
        insert = [0] * (n + 1)

        # print(sorted_queries)
        for i in range(n):
            # print(f""{i=} {backup=} {j=}"")
            cur += insert[i]
            while backup and -backup[0] < i:
                # print(""pop"")
                heapq.heappop(backup)
            while cur < nums[i] and ((backup and -backup[0] >= i) or (j < q and sorted_queries[j][0] <= i)):
                if backup and -backup[0] >= i and (j == q or sorted_queries[j][0] > i or sorted_queries[j][1] <= -backup[0]):
                    r = -heapq.heappop(backup)
                    # print(f""{i=} backup {r=} {(None if j == q else sorted_queries[j])=}"")
                else:
                    r = sorted_queries[j][1]
                    # print(f""{i=} queries {r=} {(None if not backup else backup[0])= } {(None if j == 1 else sorted_queries[j])=}"")
                    j += 1
                cur += 1
                insert[r + 1] -= 1
                taken += 1
            if cur < nums[i]:
                return -1
            while j < q and sorted_queries[j][0] <= i:
                heapq.heappush(backup, -sorted_queries[j][1])
                j += 1
        return len(queries) - taken",1460875900
James Jialun Zhao,frixxxer,231,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        diag = sum([fruits[i][i] for i in range(n)])
        dp = [[0]*n for _ in range(n)]
        dp[0][-1] = fruits[0][-1]
        dp[-1][0] = fruits[-1][0]
        width = n // 2
        p = False
        for i in range(n - 1):
            p_limit = min((i-1) + 1, n -1 - (i-1))
            limit = min(i + 1, n -1 - i)
            if p:
                print(f""{i=} {limit=}"")
            for j in range(limit):
                dp[i][-1-j] = fruits[i][-1-j]
                dp[-1-j][i] = fruits[-1-j][i]
                if p:
                    print(f""{j=}"", end="""")
                # away
                if i > 0 and j + 1 < p_limit:
                    if p:
                        print(""away"", end="", "")
                    dp[i][-1-j] = max(dp[i][-1-j], fruits[i][-1-j] + dp[i-1][-1-j-1])
                    dp[-1-j][i] = max(dp[-1-j][i], fruits[-1-j][i] + dp[-1-j-1][i-1])
                # up
                if i > 0 and j < p_limit:
                    if p:
                        print(""up"", end="", "")
                    dp[i][-1-j] = max(dp[i][-1-j], fruits[i][-1-j] + dp[i-1][-1-j])
                    dp[-1-j][i] = max(dp[-1-j][i], fruits[-1-j][i] + dp[-1-j][i-1])
                # towards edge
                if i > 0 and j > 0:
                    if p:
                        print(""towards"", end="", "")
                    dp[i][-1-j] = max(dp[i][-1-j], fruits[i][-1-j] + dp[i-1][-1-j+1])
                    dp[-1-j][i] = max(dp[-1-j][i], fruits[-1-j][i] + dp[-1-j+1][i-1])
                if p:
                    print()
        if p:
            print(""\n"".join(map(str, dp)))
        return diag + dp[-2][-1] + dp[-1][-2]",1460905376
gitgud8055,gitgud8055,234,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        vector<vector<long long>> c(26, vector<long long> (26, (long long) 1e18));
        for (int i = 0; i < 26; i++) {
            c[i][(i + 1) % 26] = nextCost[i];
            c[i][(i + 25) % 26] = previousCost[i];
            c[i][i] = 0;
        }
        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                for (int j = 0; j < 26; j++) {
                    c[i][j] = min(c[i][j], c[i][k] + c[k][j]);
                }
            }
        }
        for (int i = 0; i < (int)s.size(); i++) {
            ans += c[s[i] - 'a'][t[i] - 'a'];
        }   
        return ans;
    }
};",1460818314
gitgud8055,gitgud8055,234,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int res = 0;
        for (int i = 10; i; i--) {
            if (n >= i) {
                n -= i;
                res ^= 1;
            }
            else {
                return res;
            }
        }
        return 0;
    }
};",1460798166
gitgud8055,gitgud8055,234,3647,cpp,"const int MAXN = 1e5 + 3;
struct Node {
    int lazy; // gi tr T trong phn tch trn
    int val; // gi tr ln nht.
} nodes[MAXN * 4];

void down(int id) {
    int t = nodes[id].lazy;
    nodes[id*2].lazy += t;
    nodes[id*2].val += t;

    nodes[id*2+1].lazy += t;
    nodes[id*2+1].val += t;

    nodes[id].lazy = 0;
}

void update(int id, int l, int r, int u, int v, int val) {
    if (v < l || r < u) {
        return ;
    }
    if (u <= l && r <= v) {
        // Khi ci t, ta LUN M BO gi tr ca nt c cp nht NG THI vi
        // gi tr lazy propagation. Nh vy s trnh sai st.
        nodes[id].val += val;
        nodes[id].lazy += val;
        return ;
    }
    int mid = (l + r) / 2;

    down(id); // y gi tr lazy propagation xung cc con

    update(id*2, l, mid, u, v, val);
    update(id*2+1, mid+1, r, u, v, val);

    nodes[id].val = min(nodes[id*2].val, nodes[id*2+1].val);
}

int get(int id, int l, int r, int u, int v) {
    if (v < l || r < u) {
        return (int) 1e9;
    }
    if (u <= l && r <= v) {
        return nodes[id].val;
    }
    int mid = (l + r) / 2;
    down(id); // y gi tr lazy propagation xung cc con

    return min(get(id*2, l, mid, u, v),
        get(id*2+1, mid+1, r, u, v));
    // Trong cc bi ton tng qut, gi tr  nt id c th b thay i (do ta y lazy propagation
    // xung cc con). Khi , ta cn cp nht li thng tin ca nt id da trn thng tin ca cc con.
}

class Solution {
public:
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = (int) nums.size();
        for (int i = 0; i <= 4 * n; i++) nodes[i].val = 0, nodes[i].lazy = 0;
        sort(queries.begin(), queries.end(), [&](vector<int>& x, vector<int>& y) {
           return x[1] != y[1] ? x[1] < y[1] : x[0] > y[0]; 
        });
           for (int i = 0; i < (int) queries.size(); i++) {
               update(1, 0, n-1, queries[i][0], queries[i][1], 1);
           }
        for (int i = 0; i < n; i++) {
            int cur = get(1, 0, n - 1, i, i);
            if (cur < nums[i]) return -1;
            update(1, 0, n - 1, i, i, -nums[i]);
        }
        int ans = 0;
        for (int i = 0; i < (int) queries.size(); i++) {
            if (get(1, 0, n-1, queries[i][0], queries[i][1]) > 0){
               update(1, 0, n-1, queries[i][0], queries[i][1], -1);
            ++ans;}
           }
        return ans;
        
    }
};",1460865729
gitgud8055,gitgud8055,234,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        const int inf = (int) -1e9;
        {
            vector<int> dp(n, inf);
            dp[n-1] = fruits[0][n-1];
            for (int i = 1; i < n; i++) {
                vector<int> ndp(n, inf);
                swap(dp, ndp);
                for (int j = 0; j < n; j++) {
                    if (ndp[j] == inf) continue;
                    for (int k = max(0, j-1); k <= min(n-1, j+1); k++) {
                        dp[k] = max(dp[k], ndp[j] + fruits[i][k]);
                    }
                }
            }
            ans += dp.back();
        }
        {
            vector<int> dp(n, inf);
            dp[n-1] = fruits[n-1][0];
            for (int i = 1; i < n; i++) {
                vector<int> ndp(n, inf);
                swap(dp, ndp);
                for (int j = 0; j < n; j++) {
                    if (ndp[j] == inf) continue;
                    for (int k = max(0, j-1); k <= min(n-1, j+1); k++) {
                        dp[k] = max(dp[k], ndp[j] + fruits[k][i]);
                    }
                }
            }
            ans += dp.back();
        }
        return ans;
    }
};",1460891184
Abhishek Choudhary,theabbie,236,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        for i in range(len(s)):
            a = ord(s[i]) - ord('a')
            b = ord(t[i]) - ord('a')
            f = 0
            while a != b:
                f += nextCost[a]
                a += 1
                a %= 26
            a = ord(s[i]) - ord('a')
            b = ord(t[i]) - ord('a')
            l = 0
            while a != b:
                l += previousCost[a]
                a -= 1
                a %= 26
            res += min(f, l)
        return res",1460835726
Abhishek Choudhary,theabbie,236,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        s = 0
        prev = 10
        res = True
        while s <= n:
            s += prev
            prev -= 1
            res = not res
        return res",1460846222
Abhishek Choudhary,theabbie,236,3647,python3,"import heapq

class FenwickTree:
    def __init__(self, x):
        self.bit = x
        for i in range(len(x)):
            j = i | (i + 1)
            if j < len(x):
                x[j] += x[i]

    def update(self, idx, x):
        while idx < len(self.bit):
            self.bit[idx] += x
            idx |= idx + 1

    def query(self, end):
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        queries.sort()
        dec = FenwickTree([0] * n)
        i = 0
        heap = []
        res = len(queries)
        for j in range(n):
            while i < len(queries) and queries[i][0] <= j:
                heapq.heappush(heap, (-queries[i][1], queries[i][0]))
                i += 1
            while nums[j] - dec.query(j + 1) > 0 and heap:
                res -= 1
                x = heapq.heappop(heap)
                l, r = x[1], -x[0]
                dec.update(l, 1)
                dec.update(r + 1, -1)
            if nums[j] - dec.query(j + 1) > 0:
                return -1
        return res",1460822551
Abhishek Choudhary,theabbie,236,3648,python3,"from collections import *
import heapq

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        diag = 0
        for i in range(n):
            diag += fruits[i][i]
        def topright():
            dist = [[0] * n for _ in range(n)]
            for i in range(n - 1, -1, -1):
                for j in range(n):
                    dist[i][j] = fruits[i][j]
                    for di, dj in [(1, -1), (1, 0), (1, 1)]:
                        x = i + di
                        y = j + dj
                        if not 0 <= x < n or not 0 <= y < n:
                            continue
                        if x == y and (x, y) != (n - 1, n - 1):
                            continue
                        if (i < j) != (x < y) and (x, y) != (n - 1, n - 1):
                            continue
                        dist[i][j] = max(dist[i][j], fruits[i][j] + dist[x][y])
            return dist[0][n - 1]
        def bottomleft():
            dist = [[0] * n for _ in range(n)]
            for j in range(n - 1, -1, -1):
                for i in range(n):
                    dist[i][j] = fruits[i][j]
                    for di, dj in [(-1, 1), (0, 1), (1, 1)]:
                        x = i + di
                        y = j + dj
                        if not 0 <= x < n or not 0 <= y < n:
                            continue
                        if x == y and (x, y) != (n - 1, n - 1):
                            continue
                        if (i < j) != (x < y) and (x, y) != (n - 1, n - 1):
                            continue
                        dist[i][j] = max(dist[i][j], fruits[i][j] + dist[x][y])
            return dist[n - 1][0]
        return diag + topright() + bottomleft() - 2 * fruits[n - 1][n - 1]",1460892896
Meet Brahmbhatt,MeetBrahmbhatt,237,3591,cpp,"const int N = 26;
const long long inf = 1e16;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prv) {
        int n = (int) s.size();
        
        vector<vector<long long>> dp(N, vector<long long>(N, inf));
        for (int i = 0; i < N; i++) {
            dp[i][i] = 0;
            priority_queue<pair<long long, int>> pq;
            pq.push({0, i});
            
            while (!pq.empty()) {
                auto [cost, cur] = pq.top();
                pq.pop();
                if (dp[i][cur] < cost) {
                    continue;
                }
                
                int next = (cur + 1) % N;
                if (dp[i][next] > cost + nxt[cur]) {
                    dp[i][next] = cost + nxt[cur];
                    pq.push({dp[i][next], next});
                }
                
                int prev = (cur + N - 1) % N;
                if (dp[i][prev] > cost + prv[cur]) {
                    dp[i][prev] = cost + prv[cur];
                    pq.push({dp[i][prev], prev});
                }
            }
        }
        
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            ans += dp[s[i] - 'a'][t[i] - 'a'];
        }
        return ans;
    }
};",1460885626
Meet Brahmbhatt,MeetBrahmbhatt,237,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10;
        int turn = 0;
        while (1) {
            if (!remove || n < remove) {
                break;
            }
            n -= remove--;
            turn ^= 1;
        }
        return turn;
    }
};",1460885835
Meet Brahmbhatt,MeetBrahmbhatt,237,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& v, vector<vector<int>>& q) {
        int n = (int) v.size();
        int m = (int) q.size();

        sort(begin(q), end(q));
        int ptr = 0;
        
        int ans = m;
        multiset<int> st;
        vector<int> dp(n + 1);

        for (int i = 0; i < n; i++) {
            if (i) {
                dp[i] += dp[i - 1];
            }
            while (!st.empty() && *st.begin() < i) {
                st.erase(st.begin());
            }
            while (ptr < m and q[ptr][0] == i) {
                st.insert(q[ptr][1]);
                ptr++;
            }
            while (v[i] + dp[i] > 0 && !st.empty()) {
                int r = *st.rbegin();
                dp[r + 1]++;
                dp[i]--;
                ans--;
                st.erase(--st.end());
            }
            if (v[i] + dp[i] > 0) {
                return -1;
            }
        }

        return ans;
    }
};",1460890913
Meet Brahmbhatt,MeetBrahmbhatt,237,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& v) {
        int n = (int) v.size();
        
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += v[i][i];
            v[i][i] = 0;
        }
        
        vector<vector<int>> dp(n, vector<int>(n, -1));
        dp[n - 1][0] = v[n - 1][0];
        
        for (int j = 1; j < n; j++) {
            for (int i = n - 1; i >= 0; i--) {
                for (int dx = -1; dx <= 1; dx++) {
                    int pi = i + dx;
                    if (pi < n and i >= j and dp[pi][j - 1] != -1) {
                        dp[i][j] = max(dp[i][j], dp[pi][j - 1] + v[i][j]);
                    }
                }
            }
        }
        
        ans += dp[n - 1][n - 1];
        dp = vector<vector<int>>(n, vector<int>(n, -1));
        dp[0][n - 1] = v[0][n - 1];
        
        for (int i = 1; i < n; i++) {
            for (int j = n - 1; j >= 0; j--) {
                for (int dy = -1; dy <= 1; dy++) {
                    int pj = j + dy;
                    if (pj < n and i <= j and dp[i - 1][pj] != -1) {
                        dp[i][j] = max(dp[i][j], dp[i - 1][pj] + v[i][j]);
                    }
                }
            }
        }
        
        ans += dp[n - 1][n - 1];
        return ans;
    }
};",1460916127
Yousef,mythh,238,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        long long ans = 0;
        for(int i = 0; i < n; i++) {
            long long fw = 0, bw = 0;
            for(char c = s[i]; c != t[i]; (c == 'z' ? c = 'a' : c = c + 1)) fw += nextCost[c - 'a'];
            for(char c = s[i]; c != t[i]; (c == 'a' ? c = 'z' : c = c - 1)) bw += previousCost[c - 'a'];
            ans += min(fw, bw);
        }

        return ans;
    }
};",1460816509
Yousef,mythh,238,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = 0;
        int cnt = 10;
        while(n - cnt >= 0) {
            n -= cnt;
            cnt--;
            alice ^= 1;
        }

        return alice;
    }
};",1460797319
Yousef,mythh,238,3647,cpp,"struct SegmentTree {
#define L 2 * node + 1
#define R 2 * node + 2
#define mid (l + r >> 1)

    private:
        long long sz, skip = 0;
        vector<long long> seg, lazy;

        long long merge(long long a, long long b) {
            return a + b;
        }

        void build(long long l, long long r, long long node, vector<int>& a) {
            if(l == r) {
                if(l < a.size()) seg[node] = a[l];
                return;
            }

            build(l, mid, L, a);
            build(mid + 1, r, R, a);
            seg[node] = merge(seg[L], seg[R]);
        }

        void propagate(long long l, long long r, long long node) {
            if(!lazy[node]) return;
            
            if(l != r) {
                lazy[L] += lazy[node];
                lazy[R] += lazy[node];
            }
            
            seg[node] += lazy[node];
            lazy[node] = 0;
        }

        void update(long long l, long long r, long long node, long long lq, long long rq, long long val) {
            propagate(l, r, node);
            if(r < lq || l > rq) return;
            if(l >= lq && r <= rq) {
                lazy[node] += val;
                propagate(l, r, node);
                return;
            }

            update(l, mid, L, lq, rq, val);
            update(mid + 1, r, R, lq, rq, val);
            seg[node] = merge(seg[L], seg[R]);
        }

        long long query(long long l, long long r, long long node, long long lq, long long rq) {
            propagate(l, r, node);
            if(r < lq || l > rq) return skip;
            else if(l >= lq && r <= rq) return seg[node];

            long long lft = query(l, mid, L, lq, rq);
            long long rght = query(mid + 1, r, R, lq, rq);
            return merge(lft, rght);
        }
        
    public:
        SegmentTree(vector<int>& a) {
            sz = 1;
            long long n = a.size();
            while(sz < n) sz *= 2;
            seg = vector<long long> (sz * 2, skip);
            lazy = vector<long long> (sz * 2);
            build(0, sz - 1, 0, a);
        }

        void update(long long l, long long r, long long val) {
            update(0, sz - 1, 0, l, r, val);
        }

        long long query(long long l, long long r) {
            return query(0, sz - 1, 0, l, r);
        }

#undef L
#undef R
#undef mid
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        priority_queue<pair<long long, long long>> pq;
        sort(queries.begin(), queries.end());
        long long n = nums.size();
        long long j = 0;
        SegmentTree seg(nums);
        long long ans = 0;
        for(long long i = 0; i < n; i++) {
            while(j < queries.size() && queries[j][0] == i) {
                pq.push({queries[j][1], queries[j][0]});
                j++;
            }

            long long x = seg.query(i, i);
            while(!pq.empty() && pq.top().first >= i && x > 0) {
                auto [r, l] = pq.top();
                pq.pop();
                x--;
                seg.update(l, r, -1);
                ans++;
            }

            if(x > 0) return -1;
        }

        return queries.size() - ans;
    }
};",1460854145
Yousef,mythh,238,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        if(n == 1) return fruits[0][0];
        if(n == 2) return fruits[0][n - 1] + fruits[n - 1][0] + fruits[n - 1][n - 1] + fruits[0][0];
        
        for(int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }

        vector<vector<int>> dp(n, vector<int> (n, -1));
        dp[0][n - 1] = fruits[0][n - 1];
        for(int i = 1; i < n; i++) {
            for(int j = n - 1; j >= n - 1 - i; j--) {
                if(j != n - 1 - i) dp[i][j] = max(dp[i][j], dp[i - 1][j]);
                if(j != n - 1) dp[i][j] = max(dp[i][j], dp[i - 1][j + 1]);
                if(j > n - i) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                dp[i][j] += fruits[i][j];
            }
        }


        ans += dp[n - 1][n - 1];
        cout << ans << endl;
        dp = vector<vector<int>> (n, vector<int> (n, -1));
        dp[n - 1][0] = fruits[n - 1][0];
        for(int j = 1; j < n; j++) {
            for(int i = n - 1; i >= n - 1 - j; i--) {
                if(i != n - 1 - j) dp[i][j] = max(dp[i][j], dp[i][j - 1]);
                if(i != n - 1) dp[i][j] = max(dp[i][j], dp[i + 1][j - 1]);
                if(i > n - j) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                dp[i][j] += fruits[i][j];
            }
        }

        ans += dp[n - 1][n - 1];
        return ans;
    }
};",1460916645
Fishron,Fishron,239,3591,python3,"f=lambda x:ord(x)-ord(""a"")
class Solution:
    def shiftDistance(self, s: str, t: str, nc: List[int], pc: List[int]) -> int:
        s=[f(e)for e in s]
        t=[f(e)for e in t]
        n=len(s)
        ps1=[0]+list(accumulate(pc))
        ps2=[0]+list(accumulate(nc))

        o=0
        for i in range(n):
            if t[i]==s[i]:continue
            if t[i]>s[i]:
                c1=ps2[t[i]]-ps2[s[i]]
                c2=ps1[s[i]+1] + ps1[-1]-ps1[t[i]+1]

            else:
                c1=ps1[s[i]+1]-ps1[t[i]+1]
                c2=ps2[t[i]] + ps2[-1]-ps2[s[i]]

            o+=min(c1,c2)
        return o",1460815488
Fishron,Fishron,239,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        t=0
        cur=10
        while n>=cur:
            n-=cur
            cur-=1
            t^=1
        return True if t else False",1460796594
Fishron,Fishron,239,3647,python3,"class LazySegmentTree:
    def __init__(self, data, default=-inf, func=max):
        """"""initialize the lazy segment tree with data""""""
        self._default = default
        self._func = func

        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
        self._lazy = [0] * (2 * _size)

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i<<1], self.data[i<<1|1])

    def __len__(self):
        return self._len

    def _push(self, idx):
        """"""push query on idx to its children""""""
        # Let the children know of the queries
        q, self._lazy[idx] = self._lazy[idx], 0

        self._lazy[idx<<1] += q
        self._lazy[idx<<1|1] += q
        self.data[idx<<1] += q
        self.data[idx<<1|1] += q

    def _update(self, idx):
        """"""updates the node idx to know of all queries applied to it via its ancestors""""""
        for i in reversed(range(1, idx.bit_length())):
            self._push(idx >> i)

    def _build(self, idx):
        """"""make the changes to idx be known to its ancestors""""""
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[idx<<1], self.data[idx<<1|1]) + self._lazy[idx]
            idx >>= 1

    def add(self, start, stop, value):
        """"""lazily add value to [start, stop)""""""
        start = start + self._size
        stop = stop + self._size
        cr=cl=False
        while start < stop:
            if cl:
                sp=start-1
                self.data[sp]=self._func(self.data[sp<<1],self.data[sp<<1|1])+self._lazy[sp]
            if cr:
                self.data[stop]=self._func(self.data[stop<<1],self.data[stop<<1|1])+self._lazy[stop]
            if start & 1:
                self._lazy[start] += value
                self.data[start] += value
                start += 1
                cl=True
            if stop & 1:
                stop -= 1
                self._lazy[stop] += value
                self.data[stop] += value
                cr=True
            start >>= 1
            stop >>= 1

        # Tell all nodes above of the updated area of the updates
        start-=1
        while stop>0:
            if cl:
                self.data[start]=self._func(self.data[start<<1],self.data[start<<1|1])+self._lazy[start]
            if cr and (not cl or start!=stop):
                self.data[stop]=self._func(self.data[stop<<1],self.data[stop<<1|1])+self._lazy[stop]

            start>>=1
            stop>>=1
    def query(self, start, stop, default=-inf):
        """"""func of data[start, stop)""""""
        start += self._size
        stop += self._size

        # Apply all the lazily stored queries
        self._update(start)
        self._update(stop - 1)

        res = default
        while start < stop:
            if start & 1:
                res = self._func(res, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res = self._func(res, self.data[stop])
            start >>= 1
            stop >>= 1
        return res

    def __repr__(self):
        return ""LazySegmentTree({0})"".format(self.data)
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n=len(nums)
        a=[0]*(n+5)
        for l,r in queries:
            a[l]+=1
            a[r+1]-=1
        for i in range(1,n+5):
            a[i]+=a[i-1]
        d=[nums[i]-a[i]for i in range(n)]

        st=LazySegmentTree(data=d)
        if st.data[1]>0:return -1

        X=sorted(queries,key=lambda t:(t[1]-t[0],t[0]))
        o=0
        #print(X)
        #print(d)
        for l,r in X:
            if st.query(l,r+1)<0:
                st.add(l,r+1,1)
                o+=1
        return o",1460853982
Fishron,Fishron,239,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        for e in fruits:
            print(*e)
        n=len(fruits)
        d=defaultdict(lambda:-inf)
        d[n-1,0]=fruits[n-1][0]
        for j in range(n):
            for i in range(n-1,j,-1):
                if i+j>=n-1 and (i,j)!=(n-1,0):
                    d[i,j]=fruits[i][j]+max((d[i+1,j-1],d[i,j-1],d[i-1,j-1]))

        #print(d)
        o=max(d.values())

        d=defaultdict(lambda:-inf)
        d[0,n-1]=fruits[0][n-1]
        for i in range(n):
            for j in range(n-1,i,-1):
                if i+j>=n-1 and (i,j)!=(0,n-1):
                    d[i,j]=fruits[i][j]+max((d[i-1,j+1],d[i-1,j],d[i-1,j-1]))

        o+=max(d.values())

        return sum(fruits[i][i]for i in range(n))+o",1460912087
Ravi,xyzabcdef,240,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prv) {
        using ll = long long;
        int n = s.size();
        ll cost = 0;
        for(int i = 0; i < n; i++){
            ll a = 0, b = 0;
            if(s[i] == t[i]){
                continue;
            } 
            char x = s[i];
            while(x != t[i]){
                a += (ll)nxt[x - 'a'];
                x = ((x - 'a' + 1) % 26) + 'a'; 
            }
            x = s[i];
            while(x != t[i]){
                b += (ll)prv[x - 'a'];
                x = ((x - 'a' - 1 + 26) % 26) + 'a'; 
            }
            cost += min<ll>(a, b);
        }
        return cost;
    }
};",1460820624
Ravi,xyzabcdef,240,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n < 10)return false;
        int cur = 10, alice = 0;
        while(n >= cur){
            n -= cur;
            alice ^= 1;
            cur--;
        }
        return alice;
    }
};",1460824376
Ravi,xyzabcdef,240,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size();
        sort(q.begin(), q.end());
        priority_queue<int>pq;
        vector<int>sum(n+1, 0);
        int cost = 0;
        for(int i = 0, j = 0; i < n; i++){
            if(i > 0)sum[i] += sum[i-1];
            while(j < q.size() && q[j][0] == i){
                pq.push(q[j][1]);
                j++;
            }
            while((nums[i] > sum[i]) && pq.size()){
                if(pq.top() < i){
                    pq.pop(); continue;
                }
                sum[i] += 1;
                sum[pq.top() + 1] -= 1;
                pq.pop();
                cost++;
            }
            if(nums[i] > sum[i])return -1;
        }
        return q.size() - cost;
    }
};",1460840886
Ravi,xyzabcdef,240,3648,cpp,"vector<vector<int>> dp(1002, vector<int>(1002, -1e9));

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int n = f.size();
        int cost = 0;

        for (int i = 0; i < n; i++) {
            cost += f[i][i];
            f[i][i] = 0;
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = -1e9;
            }
        }

        for (int i = 0; i < n; i++) {
            dp[i][n - 1] = (i == n - 1) ? 0 : -1e9;
        }

        for (int j = n - 2; j >= 0; j--) {
            for (int i = 0; i < n; i++) {
                dp[i][j] = -1e9;
                for (int p = -1; p <= 1; p++) {
                    if ((i + p) >= 0 && (i + p) < n) {
                        dp[i][j] = max(dp[i][j], dp[i + p][j + 1] + f[i][j]);
                    }
                }
            }
        }

        cost += dp[n - 1][0];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = -1e9;
            }
        }

        for (int j = 0; j < n; j++) {
            dp[n - 1][j] = (j == n - 1) ? 0 : -1e9;
        }

        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = -1e9;
                for (int p = -1; p <= 1; p++) {
                    if ((j + p) >= 0 && (j + p) < n) {
                        dp[i][j] = max(dp[i][j], dp[i + 1][j + p] + f[i][j]);
                    }
                }
            }
        }

        cost += dp[0][n - 1];
        return cost;
    }
};
",1460915398
Yucheng Dai,Rainingcity,246,3591,cpp,"typedef long long ll;
class Solution {
private:
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<ll>> nexts(26, vector<ll>(26));
        for(int i = 0; i < 26; i++) {
            nexts[i][i] = 0;
            nexts[i][(i + 1) % 26] = nextCost[i];
            for(int j = 2; j < 26; j++) {
                nexts[i][(i + j) % 26] = nexts[i][(i + j - 1) % 26] + nextCost[(i + j - 1) % 26];
            }
        }
        vector<vector<ll>> prevs(26, vector<ll>(26));
        for(int i = 0; i < 26; i++) {
            prevs[i][i] = 0;
            prevs[i][(i + 25) % 26] = previousCost[i];
            for(int j = 24; j > 0; j--) {
                prevs[i][(i + j) % 26] = prevs[i][(i + j + 1) % 26] + previousCost[(i + j + 1) % 26];
            }
        }
        ll ans = 0;
        for(int i = 0; i < s.length(); i++) {
            ans += min(nexts[s[i] - 'a'][t[i] - 'a'], prevs[s[i] - 'a'][t[i] - 'a']);
        }
        return ans;
    }
};",1460812664
Yucheng Dai,Rainingcity,246,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int m = 10;
        while(m > 0 && n >= m) {
            n -= m;
            m--;
        }
        return m % 2 != 0;
    }
};",1460797035
Yucheng Dai,Rainingcity,246,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        vector<vector<int>> dp(n, vector<int>(n, -1000000));
        dp[0][n - 1] = fruits[0][n - 1];
        for(int i = 1; i < n - 1; i++) {
            for(int j = i + 1; j < n; j++) {
                dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]);
                if (j + 1 < n) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1]);
                }
                dp[i][j] += fruits[i][j];
            }
        }
        dp[n - 1][0] = fruits[n - 1][0];
        for(int j = 1; j < n - 1; j++) {
            for(int i = j + 1; i < n; i++) {
                dp[i][j] = max(dp[i - 1][j - 1], dp[i][j - 1]);
                if (i + 1 < n) {
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1]);
                }
                dp[i][j] += fruits[i][j];
            }
        }
        // for(int i = 0; i < n; i++) {
        //     for(int j = 0; j < n; j++) {
        //         cout << dp[i][j] << "" "";
        //     }
        //     cout<<endl;
        // }
        // cout<<endl;
        int ans = dp[n - 2][n - 1] + dp[n - 1][n - 2];
        for(int i = 0; i < n; i++) ans += fruits[i][i];
        return ans;
    }
};",1460849414
realstar,realstar,247,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long result = 0;
        long[][] forward = new long[26][26];
        long[][] backward = new long[26][26];
        for (int i = 0; i < 26; i++) {
        	forward[i][1] = nextCost[i];
        	backward[i][1] = previousCost[i];
        	for (int j = 2; j < 26; j++) {
        		forward[i][j] = forward[i][j - 1] + nextCost[(i + j - 1) % 26];
        		backward[i][j] = backward[i][j - 1] + previousCost[(i - j + 27) % 26];
        	}
        }
        for (int i = 0; i < s.length(); i++) {
        	char sc = s.charAt(i);
        	char tc = t.charAt(i);
        	long ahead = forward[sc - 'a'][(tc - sc + 26) % 26];
        	long back = backward[sc - 'a'][(sc - tc + 26) % 26];
        	result += Math.min(ahead, back);
        }
        return result;
    }
}",1460823152
realstar,realstar,247,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int need = 10;
        boolean win = false;
        while (n >= need) {
        	n -= need;
        	win = !win;
            need--;
        }
        return win;
    }
}",1460797782
realstar,realstar,247,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        int result = 0;
        for (int i = 0; i < n; i++) {
        	result += fruits[i][i];
        	fruits[i][i] = 0;
        }
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++)
        	Arrays.fill(dp[i], -1);
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n; i++) {
        	for (int j = 0; j < n; j++) {
        		int prev = dp[i - 1][j];
        		if (j > 0)
        			prev = Math.max(dp[i - 1][j - 1], prev);
        		if (j < n - 1)
        			prev = Math.max(dp[i - 1][j + 1], prev);
        		if (prev >= 0)
        			dp[i][j] = prev + fruits[i][j];
        	}
        }
        result += dp[n - 1][n - 1];
        dp = new int[n][n];
        for (int i = 0; i < n; i++)
        	Arrays.fill(dp[i], -1);
        dp[n - 1][0] = fruits[n - 1][0];
    	for (int j = 1; j < n; j++) {
    		for (int i = 0; i < n; i++) {
        		int prev = dp[i][j - 1];
        		if (i > 0)
        			prev = Math.max(dp[i - 1][j - 1], prev);
        		if (i < n - 1)
        			prev = Math.max(dp[i + 1][j - 1], prev);
        		if (prev >= 0)
        			dp[i][j] = prev + fruits[i][j];
        	}
        }
        result += dp[n - 1][n - 1];
        return result;
    }
}",1460852949
Amit Kumar,amit_kumar112,248,3591,cpp,"class Solution {
public:
    long long find_next(char a,char b,vector<int>& next)
    {
        long long ans=0;
        int x=a-'a';
        int y=b-'a';
        while(x!=y)
            {
                ans+=next[x];
                x=(x+1)%26;
            }
        return ans;
    }

    long long find_prev(char a,char b,vector<int>& prev)
    {
        long long ans=0;
        int x=a-'a';
        int y=b-'a';
        while(x!=y)
            {
                ans+=prev[x];
                x=(x-1)%26;
                x+=26;
                x%=26;
            }
        return ans;
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.size();i++)
            {
                long long cost1=0,cost2=0;
                ans+=min(find_next(s[i],t[i],nextCost),find_prev(s[i],t[i],previousCost));
            }
        return ans;
    }
};",1460814636
Amit Kumar,amit_kumar112,248,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr=10;
        int x=0;
        while(1)
            {
                if(n>=curr)
                {
                    n-=curr;
                    curr--;
                    x=1-x;
                }
                else
                {
                    if(x==0)
                        return false;
                    else
                        return true;
                }
            }
        return true;
    }
};",1460800422
Amit Kumar,amit_kumar112,248,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& v) {
        int n=v.size();
        int ans=0;
        for(int i=0;i<n;i++)
            {
                ans+=v[i][i];
                v[i][i]=0;
            }

        cout<<ans<<"" "";
        vector<vector<int>>dp(n,vector<int>(n,0));
        for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                    dp[i][j]=-1;
            }
        dp[n-1][0]=v[n-1][0];
        for(int j=1;j<n;j++)
            {
                for(int i=j+1;i<n;i++)
                    {
                        if(dp[i][j-1]!=-1)
                        dp[i][j]=max(dp[i][j],v[i][j]+dp[i][j-1]);
                        if(i+1<n and dp[i+1][j-1]!=-1)
                        dp[i][j]=max(dp[i][j],v[i][j]+dp[i+1][j-1]);
                        if(dp[i-1][j-1]!=-1)
                        dp[i][j]=max(dp[i][j],v[i][j]+dp[i-1][j-1]);

                
                    }
            }
        ans+=dp[n-1][n-2];

cout<<ans<<"" "";
         for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                    dp[i][j]=-1;
            }
        dp[0][n-1]=v[0][n-1];
        for(int i=1;i<n;i++)
            {
                for(int j=i+1;j<n;j++)
                    {
                        if(dp[i-1][j]!=-1)
                        dp[i][j]=max(dp[i][j],v[i][j]+dp[i-1][j]);
                        if(j+1<n and dp[i-1][j+1]!=-1)
                        dp[i][j]=max(dp[i][j],v[i][j]+dp[i-1][j+1]);
                        if(dp[i-1][j-1]!=-1)
                        dp[i][j]=max(dp[i][j],v[i][j]+dp[i-1][j-1]);

                
                    }
            }
        ans+=dp[n-2][n-1];

cout<<ans<<"" "";
        return ans;

    }
};",1460860136
daisek,daisek,249,3591,kotlin,"class Solution {
    fun shiftDistance(s: String, t: String, nextCost: IntArray, previousCost: IntArray): Long {
        return (0 until s.length)
            .sumOf { i ->
                var a = s[i] - 'a'
                var b = t[i] - 'a'
                val a1 = a
                val b1 = if (b < a) b + 26 else b
                val b2 = b
                val a2 = if (a < b) a + 26 else a
                min( (a1 until b1).sumOf {nextCost[it%26].toLong()}, ((b2+1)..a2).sumOf{previousCost[it%26].toLong()} )
            }
    }
}",1460843144
daisek,daisek,249,3625,kotlin,"class Solution {
    fun canAliceWin(n: Int): Boolean {
        var m = n
        for (i in (1..10).reversed()) {
            m -= i
            if (m < 0) {
                return i % 2 == 1
            }
        }
        return true
    }
}",1460802151
daisek,daisek,249,3648,kotlin,"class Solution {
    fun maxCollectedFruits(fruits: Array<IntArray>): Int {
        val n = fruits.size
        val res = Array<IntArray>(n) { IntArray(n) {0}}
        for (i in (0 until (n-1)).reversed()) {
            for (j in ((i+1) until n)) {
                val ind = listOf(j-1, j, j+1).filter {it > i+1 && it < n}
                res[i][j] = fruits[i][j] + (ind.maxOfOrNull{res[i+1][it]} ?: 0)
                res[j][i] = fruits[j][i] + (ind.maxOfOrNull{res[it][i+1]} ?: 0)
            }
        }
        return (0 until n).sumOf {fruits[it][it]} + res[0][n-1] + res[n-1][0]
    }
}",1460864784
Burger Monstah,WRWRW,250,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int: 
        s = [ord(c) - ord('a') for c in s]
        t = [ord(c) - ord('a') for c in t]
        n = len(s)
        diff = {}
        diff2 = {}
        for i in range(26):
            diff[i] = {i: 0}
            diff2[i] = {i: 0}
            for j in range(1, 26):
                diff[i][(i + j) % 26] = diff[i][(i + j - 1) % 26] + nextCost[(i + j - 1) % 26]
            # print(diff)
            for j in range(1, 26):
                diff2[i][(i - j) % 26] = diff2[i][(i - j + 1) % 26] + previousCost[(i - j + 1) % 26]
            # print(diff2)
        res = 0
        for a, b in zip(s, t):
            res += min(diff[a][b], diff2[a][b])
        return res
    ",1460842687
Burger Monstah,WRWRW,250,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        res = False
        diff = 10
        while n >= diff:
            n -= diff
            res = not res
            diff -= 1
        return res
        ",1460796804
Burger Monstah,WRWRW,250,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        res = sum(fruits[i][i] for i in range(n))

        line = {n - 1: fruits[0][n - 1]}
        for r in range(1, n):
            newline = Counter()
            for c, val in line.items():
                if c - 1 == r:
                    newline[c - 1] = max(newline[c - 1], line[c])
                elif c - 1 > r:
                    newline[c - 1] = max(newline[c - 1], line[c] + fruits[r][c - 1]) 
                if c == r:
                    newline[c] = max(newline[c], line[c])
                elif c > r:
                    newline[c] = max(newline[c], line[c] + fruits[r][c]) 
                if c + 1 < n:
                    if c + 1 == r:
                        newline[c + 1] = max(newline[c + 1], line[c])
                    elif c + 1 > r:
                        newline[c + 1] = max(newline[c + 1], line[c] + fruits[r][c + 1])
            line = newline
        res += line[n - 1]

        line = {n - 1: fruits[n - 1][0]}
        for c in range(1, n):
            newline = Counter()
            for r, val in line.items():
                if r - 1 == c:
                    newline[r - 1] = max(newline[r - 1], line[r])
                elif r - 1 > c:
                    newline[r - 1] = max(newline[r - 1], line[r] + fruits[r - 1][c])
                if r == c:
                    newline[r] = max(newline[r], line[r])
                elif r > c:
                    newline[r] = max(newline[r], line[r] + fruits[r][c]) 
                if r + 1 < n:
                    if r + 1 == c:
                        newline[r + 1] = max(newline[r + 1], line[r])
                    elif r + 1 > c:
                        newline[r + 1] = max(newline[r + 1], line[r] + fruits[r + 1][c])
            line = newline

        return res + line[n - 1]",1460870684
eulusoy,eulusoy,251,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        int n = s.size();
        for(int i=0; i<n; ++i){
            // cout << i << "" "";
            long long curCostN = 0;
            long long  curCostP = 0;
            // cout << static_cast<int>(s[i]+1-'a') << "" "";
            // cout << static_cast<int>(t[i]+1-'a') << endl;
            for(int j=(s[i]-'a'); (j%26)!=(t[i]-'a'); ++j){
                // cout << j%26 << "" "";
                curCostN += nextCost[j%26];
            }
            // cout << endl;
            for(int j=(s[i]-'a'+26); (j%26)!=(t[i]-'a'); --j){
                // cout << j%26 << "" "";
                curCostP += previousCost[j%26];
            }
            // cout << endl;
            ans += min(curCostN, curCostP);
        }
        return ans;
    }
};",1460823473
eulusoy,eulusoy,251,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn=0;
        int count = 10;
        while(n>=0){
            n -= count;
            --count;
            turn = 1-turn;
        }
        return turn == 0;
    }
};",1460796637
eulusoy,eulusoy,251,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        vector<vector<int>> dPHelper(n, vector<int>(n,0));
        int ans = 0;
        for(int i=0; i<n; ++i){
            ans += fruits[i][i];
        }
        // cout << ans << "" "";
        dPHelper[n-1][0] = fruits[n-1][0];
        dPHelper[0][n-1] = fruits[0][n-1];
        for(int i=1; i<(n-1); ++i){
            for(int j=max(n-1-i, i+1); j<n; ++j){
                int f=0;
                for(int k=max(j-1, i); k<min(n,j+2); ++k){
                    f = max(f,dPHelper[i-1][k]);
                }
                dPHelper[i][j] = f+fruits[i][j];
            }
            for(int j=max(n-1-i, i+1); j<n; ++j){
                int f=0;
                for(int k=max(j-1, i); k<min(n,j+2); ++k){
                    f = max(f,dPHelper[k][i-1]);
                }
                dPHelper[j][i] = f+fruits[j][i];
            }
        }
        // for(int i=0; i<n; ++i){
        //     for(int j=0; j<n; ++j){
        //         cout << dPHelper[i][j] << "" "";
        //     }
        //     cout << endl;
        // }
        int fr=0;
        for(int i=1; i<n; ++i){
            fr = max(fr,dPHelper[i][i-1]);
        }
        ans += fr;
        // cout << fr << "" "";
        fr=0;
        for(int i=1; i<n; ++i){
            fr = max(fr,dPHelper[i-1][i]);
        }
        ans += fr;
        // cout << fr << "" "";
        return ans;
    }
};",1460864612
Devansh,devansh151005,253,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0; 
    int n = s.length();      

    for (int i = 0; i < n; i++) {
        char charS = s[i];
        char charT = t[i];
        int indexS = charS - 'a';
        int indexT = charT - 'a';
        int forwardDistance = (indexT - indexS + 26) % 26;
        int backwardDistance = (indexS - indexT + 26) % 26;
        long long forwardCost = 0, backwardCost = 0;

        for (int j = 0; j < forwardDistance; j++) {
            forwardCost += nextCost[(indexS + j) % 26];
        }
        for (int j = 0; j < backwardDistance; j++) {
            backwardCost += previousCost[(indexS - j + 26) % 26];
        }

        ans += min(forwardCost, backwardCost);
    }

    return ans;

    }
};",1460816263
Devansh,devansh151005,253,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n < 10) return false;

        if(n >= 10 && n <= 18){
            return true;
        }
        if(n >= 19 && n <= 26) return false;
        if(n >= 27 && n <= 33) return true;
        if(n >= 34 && n <= 39) return false;
        if(n >= 40 && n <= 44) return true;
        if(n >= 45 && n <= 48) return false;
        if(n >= 49 && n <= 51) return true;
        return true;
    }
};",1460806622
Devansh,devansh151005,253,3648,cpp,"class Solution {
public:
    int solveBotLeft(vector<vector<int>> &fruits, int i, int j, int count, vector<vector<int>>&dp){
        int n = fruits.size();
        if(count == n-1 && i== n-1 && j== n-1){
            return fruits[i][j];
        }
        if(i == n || j == n){
            return -1e5;
        }
        if(count == n-1){
            if(!(i == n-1 && j == n-1)) return -1e5;
        }
        if(dp[i][j] != -1) return dp[i][j];
        // 3 ways to move
        int ans1 = 0, ans2 = 0, ans3 = 0;

        ans1 = solveBotLeft(fruits, i-1, j+1, count+1, dp) + fruits[i][j];
        ans2 = solveBotLeft(fruits, i, j+1, count+1, dp) + fruits[i][j];
        ans3 = solveBotLeft(fruits, i+1, j+1, count+1, dp) + fruits[i][j];
        
        return dp[i][j]=max({ans1, ans2, ans3});
    }

int solveTopRight(vector<vector<int>> &fruits, int i, int j, int count,vector<vector<int>>&dp){
        int n = fruits.size();
        if(count == n-1 && i== n-1 && j== n-1){
            return fruits[i][j];
        }
        if(i >= n || j >= n){
            return -1e5;
        }
        if(count >= n-1){
            if(!(i == n-1 && j == n-1)) return -1e5;
        }
        if(dp[i][j] != -1) return dp[i][j];
        // 3 ways to move
        int ans1 = 0, ans2 = 0, ans3 = 0;

        ans1 = solveTopRight(fruits, i+1, j-1, count+1, dp) + fruits[i][j];
        ans2 = solveTopRight(fruits, i+1, j+1, count+1, dp) + fruits[i][j];
        ans3 = solveTopRight(fruits, i+1, j, count+1, dp) + fruits[i][j];
        
        return dp[i][j] = max({ans1, ans2, ans3});
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for(int i = 0;i < n;i++){
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> dp1(n, vector<int>(n, -1));
        vector<vector<int>> dp2(n, vector<int>(n, -1));

        int val1 = solveBotLeft(fruits, n-1, 0, 0, dp1);
        int val2 = solveTopRight(fruits, 0, n-1, 0, dp2);
        ans += val1 + val2;
        return ans;
    }
};",1460866220
Brian Ahaneku,Ruvxei,254,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        cost = 0
        n = len(s)
        
        for i in range(n):
            c1 = s[i]
            c2 = t[i]
            right = 0
            while c1 != c2:
                right += nextCost[ord(c1) - 97]
                c1 = chr((ord(c1) - 97 + 1) % 26 + 97)
                
            left = 0
            c1 = s[i]
            while c1 != c2:
                left += previousCost[ord(c1) - 97]
                c1 = chr((ord(c1) - 97 - 1) % 26 + 97)
                
            cost += min(right, left)
        return cost",1460809014
Brian Ahaneku,Ruvxei,254,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        s = 10
        turn = True
        while n >= s:
            n -= s
            s -= 1
            turn = not turn
        return turn == False",1460796087
Brian Ahaneku,Ruvxei,254,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        ans = 0
        n = len(fruits)
        for i in range(n):
            ans += fruits[i][i]

        dp = {}
        def solve(i, j):
            if (i, j) in dp:
                return dp[(i, j)]
            total = fruits[i][j]
            ret = total
            for dr, dc in [(-1, 1), (0, 1), (1, 1)]:
                r, c = i + dr, j + dc
                if 0 <= r < n and 0 <= c < n:
                    if r > c:
                        ret = max(ret, total + solve(r, c))
            dp[(i, j)] = ret
            return ret

        dp2 = {}
        def solve2(i, j):
            if (i, j) in dp2:
                return dp2[(i, j)]
            total = fruits[i][j]
            ret = total
            for dr, dc in [(1, -1), (1, 0), (1, 1)]:
                r, c = i + dr, j + dc
                if 0 <= r < n and 0 <= c < n:
                    if r < c:
                        ret = max(ret, total + solve2(r, c))
            dp2[(i, j)] = ret
            return ret
        print(solve(0, n - 1))
        return ans + solve(n - 1, 0) + solve2(0, n - 1)
            
            ",1460873404
tt-2,tt-2,255,3591,java,"class Solution {
    long evalF(char b, char f, int[] c) {
        long a = 0;
        while (b != f) {
            a += c[b - 'a'];
            b++;
            if (b > 'z') b = 'a';
        }
        //System.out.print(b +"", "" + f + "": "" + a + "" "");
        return a;
    }
    long evalB(char b, char f, int[] c) {
        long a = 0;
        while (b != f) {
            a += c[b - 'a'];
            b--;
            if (b < 'a') b = 'z';
        }
        //System.out.println(a);
        return a;
    }
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long a = 0;
        for (int i = 0; i < s.length(); i++) {
            a += Math.min(
                evalF(s.charAt(i), t.charAt(i), nextCost),
                evalB(s.charAt(i), t.charAt(i), previousCost));
        }
        return a;
    }
}",1460826575
tt-2,tt-2,255,3625,java,"class Solution {
    boolean canWin(int n, int m) {
        if (n < m) return false;
        if (m == n) return true;
        return !canWin(n - m, m -1);
    }
    public boolean canAliceWin(int n) {
        return canWin(n, 10);
    }
}",1460802506
tt-2,tt-2,255,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] f) {
        int n = f.length;
        // the first child should move only diagonally.
        // the other two should move in their halves (always moving to the right or down respectively)
        int fc = 0;
        for (int i = 0; i < n; i++) fc += f[i][i];

        int[][] dp = new int[n][n];

        dp[0][n-1] = f[0][n-1];
        for (int i = 0; i < n-1; i++) dp[0][i] = -1_000_000_000;
        for (int j = 1; j < n; j++) {
            for (int i = j + 1; i < n - 1; i++) {
                dp[j][i] = f[j][i] + Math.max(dp[j-1][i-1], Math.max(dp[j-1][i], dp[j-1][i+1]));
            }
            dp[j][n-1] = f[j][n-1] + Math.max(dp[j-1][n-2], dp[j-1][n-1]);
        }

        dp[n-1][0] = f[n-1][0];
        for (int i = 0; i < n-1; i++) dp[i][0] = -1_000_000_000;
        for (int j = 1; j < n; j++) {
            for (int i = j + 1; i < n - 1; i++) {
                dp[i][j] = f[i][j] + Math.max(dp[i-1][j-1], Math.max(dp[i][j-1], dp[i+1][j-1]));
            }
            dp[n-1][j] = f[n-1][j] + Math.max(dp[n-2][j-1], dp[n-1][j-1]);
        }        

        //System.out.println(fc + "" "" + dp[n-2][n-1] + "" "" + dp[n-1][n-2]);

        return fc + dp[n-2][n-1] + dp[n-1][n-2]; 
    }
}",1460867125
Bibu54123,Bibu54123,256,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long inf = 1000LL*1000*1000*1000;
        vector<vector<long long>> d(26, vector<long long>(26, inf));
        for (int a = 0; a < 26; a++) {
            d[a][a] = 0;
            for (int da = 1; da < 26; da++) {
                int b = (a + da)%26, bm1 = (a + da - 1)%26;
                d[a][b] = min(d[a][b], d[a][bm1] + nextCost[bm1]);
                int c = (a + 26 - da)%26, cp1 = (a + 26 + 1 - da)%26;
                d[a][c] = min(d[a][c], d[a][cp1] + previousCost[cp1]);
            }
        }
        long long ans = 0;
        for (int i = 0; i < s.size(); i++)
            ans += d[s[i] - 'a'][t[i] - 'a'];
        return ans;
    }
};
",1460836941
Bibu54123,Bibu54123,256,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool aliceWin = false;
        int k = 10;
        while (k <= n) {
            aliceWin = !aliceWin;
            n -= k;
            k--;
        }
        return aliceWin;
    }
};
",1460805542
Bibu54123,Bibu54123,256,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // any kid collecting the fruits in the last cell
        dp[n - 1][n - 1] = fruits[n - 1][n - 1];
        
        // top-left kid taking fruits in the diagonal
        dp[0][0] = fruits[0][0];
        for (int i = 1; i < n - 1; i++)
            dp[i][i] = dp[i - 1][i - 1] + fruits[i][i];
        dp[n - 1][n - 1] += dp[n - 2][n - 2];
        
        // bot-left kit taking fruits in the bot-left part
        dp[n - 1][0] = fruits[n - 1][0];
        for (int j = 1; j < n - 1; j++)
            for (int i = n - 1; n - 1 <= i + j && j < i; i--) {
                dp[i][j] = max(dp[i][j - 1] + fruits[i][j],
                               dp[i - 1][j - 1] + fruits[i][j]);
                if (i + 1 < n)
                    dp[i][j] = max(dp[i][j],
                                   dp[i + 1][j - 1] + fruits[i][j]);
            }
        dp[n - 1][n - 1] += dp[n - 1][n - 2];

        // top-right kid
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n - 1; i++)
            for (int j = n - 1; n - 1 <= j + i && i < j; j--) {
                dp[i][j] = max(dp[i - 1][j] + fruits[i][j],
                               dp[i - 1][j - 1] + fruits[i][j]);
                if (j + 1 < n)
                    dp[i][j] = max(dp[i][j],
                                   dp[i - 1][j + 1] + fruits[i][j]);
            }
        dp[n - 1][n - 1] += dp[n - 2][n - 1];
        return dp[n - 1][n - 1];
    }
};
",1460874138
Yi Chen,1bicJpwX1d,257,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        

        // a -> z?

        vector<vector<long long>> mapCost(26, vector<long long>(26, LLONG_MAX));

        // a, b, c, d, e, f, ..., z

        // cost[a][b] = nextCost[a]
        // cost[b][c] = nextCost[b]

        // cost[a][c] = cost[a][b] + nextCost[b];
        for (int i = 0 ; i < 26 ; i++)
            mapCost[i][i] = 0;

        for (int len = 1 ; len <= 25 ; len++)
        {
            for (int i = 0 ; i < 26 ; i++)
            {
                mapCost[i][(i+len)%26] = min(
                    mapCost[i][(i+len)%26],
                    mapCost[i][(i+len-1)%26] + nextCost[(i+len-1)%26]);
            }
        }

        for (int len = 1 ; len <= 25 ; len++)
        {
            for (int i = 0 ; i < 26 ; i++)
            {
                mapCost[i][(i+26-len)%26] = min(
                    mapCost[i][(i+26-len)%26],
                    mapCost[i][(i+26-len+1)%26] + previousCost[(i+26-len+1)%26]);
            }
        }

        long long result = 0;
        for (int i = 0 ; i < s.size() ; i++)
        {
            result += mapCost[s[i]-'a'][t[i]-'a'];
        }

        return result;
    }
};",1460825534
Yi Chen,1bicJpwX1d,257,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool winner = false;
        for (int i = 10 ; i >= 0 ; i--)
        {
            if (i > n)
                break;
            n = n - i;
            winner = !winner;
        }

        return winner;
    }
};",1460797260
Yi Chen,1bicJpwX1d,257,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();

        /* [
            [11,15,18, 7]
            [ 8,15, 5,19]
            [15,20, 4,10]
            [15, 3,10, 5]]

            35 + 45 + 36
        */

        
        // (0, n-1) -> (n-2, n-1)
        vector<vector<int>> dp1(n, vector<int>(n, 0));
        dp1[0][n-1] = fruits[0][n-1];
        for (int i = 1 ; i < n-1 ; i++)
        {
            for (int j = n-1 ; j >= n-1-i ; j--)
            {
                if (j < n-1)
                    dp1[i][j] = max(dp1[i][j], dp1[i-1][j+1]+fruits[i][j]);
                dp1[i][j] = max(dp1[i][j], dp1[i-1][j]+fruits[i][j]);
                dp1[i][j] = max(dp1[i][j], dp1[i-1][j-1]+fruits[i][j]);
            }
        }
        // cout << dp1[n-2][n-1] << endl;
        
        // (n-1, 0) -> (n-1, n-2)
        vector<vector<int>> dp2(n, vector<int>(n, 0));
        dp2[n-1][0] = fruits[n-1][0];
        for (int j = 1 ; j < n-1 ; j++)
        {
            for (int i = n-1 ; i >= n-1-j ; i--)
            {
                if (i < n-1)
                    dp2[i][j] = max(dp2[i][j], dp2[i+1][j-1]+fruits[i][j]);
                dp2[i][j] = max(dp2[i][j], dp2[i][j-1]+fruits[i][j]);
                dp2[i][j] = max(dp2[i][j], dp2[i-1][j-1]+fruits[i][j]);
            }
        }
        // cout << dp2[n-1][n-2] << endl;
        
        int result = dp1[n-2][n-1] + dp2[n-1][n-2];
        for (int i = 0 ; i < n ; i++)
            result += fruits[i][i];

        return result;
    }
};",1460867906
Prakhar,B_Rabbit007,258,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long dp[26][26]{};
        const long long INF = 1e18;
        for (int i = 0; i < 26; ++i) {
            for (int j = 0; j < 26; ++j) {
                dp[i][j] = INF;
            }
        }
        for (int i = 0; i < 26; ++i) {
            dp[i][i] = 0;
            dp[i][(i + 1) % 26] = nextCost[i];
            dp[i][(i + 25) % 26] = previousCost[i];
        }
        
        for (int j = 0; j < 26; ++j) {
            for (int i = 0; i < 26; ++i) {
                for (int k = 0; k < 26; ++k) {
                    dp[i][k] = min(dp[i][k], dp[i][j] + dp[j][k]);
                }
            }
        }
        
        long long ans = 0;
        for (int i = 0; i < s.size(); ++i) {
            ans += dp[s[i] - 'a'][t[i] - 'a'];
        }
        
        return ans;
    }
};",1460817214
Prakhar,B_Rabbit007,258,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int f = 0, remove = 10;
        while (n >= 0) {
            if (n < remove) return f == 1;
            n -= remove--;
            f ^= 1;
        }
        return true;
    }
};",1460801077
Prakhar,B_Rabbit007,258,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        
        const int inf = 1e9;
        
        vector<vector<int> > dp(n, vector<int> (n, -inf));
        dp[n - 1][0] = fruits[n - 1][0];
        
        for (int j = 1; j < n; ++j) {
            for (int i = 0; i < n; ++i) {
                if (i - 1 >= 0 && dp[i - 1][j - 1] >= 0) {
                    dp[i][j] = fruits[i][j] + dp[i - 1][j - 1];
                }
                if (dp[i][j - 1] >= 0) dp[i][j] = max(dp[i][j], dp[i][j - 1] + fruits[i][j]);
                if (i + 1 < n && dp[i + 1][j - 1] >= 0) {
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + fruits[i][j]);
                }
            }
        }
        
        ans += dp[n - 1][n - 1];
        for (auto &d : dp) fill(d.begin(), d.end(), -inf);
        
        dp[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (j - 1 >= 0 && dp[i - 1][j - 1] >= 0) {
                    dp[i][j] = dp[i - 1][j - 1] + fruits[i][j];
                }
                if (dp[i - 1][j] >= 0) dp[i][j] = max(dp[i][j], dp[i - 1][j] + fruits[i][j]);
                if (j + 1 < n) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + fruits[i][j]);
                }
            }
        }
        
        return ans + dp[n - 1][n - 1];
    }
};",1460856196
Boshiang,Boshiang,259,3591,cpp,"class Solution {
public:
    long long solve(char s, char& t, vector<int>& cost, int dir){
        if (s == t) return 0;
        long long cc = 0;
        int index = s-'a';
        while (s != t){
            cc += cost[index];
            index = (index+1*dir+26) % 26;
            s = 'a' + index;
        }
        return cc;
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for (int i=0;i<s.size();++i){
            ans += min(solve(s[i], t[i], nextCost, 1), solve(s[i], t[i], previousCost, -1));
        }
        return ans;
    }
};",1460836024
Boshiang,Boshiang,259,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool state = false;
        int cnt = 10;
        while (n >= cnt){
            n -= cnt;
            cnt--;
            state = !state;
        }
        return state;
    }
};",1460816960
Boshiang,Boshiang,259,3648,cpp,"class Solution {
public:
    int solve1(vector<vector<int>>& fruits, vector<vector<int>>& dp, int x, int y){
        if (x == 0){
            if (y == fruits.size()-1) return fruits[0][fruits.size()-1];
            else return -1000009;
        }
        if (y < 0 || y >= fruits.size()) return 0;
        if (dp[x][y] != -1) return dp[x][y];
        return dp[x][y] = fruits[x][y] + max(solve1(fruits, dp, x-1, y-1), max(solve1(fruits, dp, x-1, y), solve1(fruits, dp, x-1, y+1)));
    }
    int solve2(vector<vector<int>>& fruits, vector<vector<int>>& dp, int x, int y){
        if (y == 0) {
            if (x == fruits.size()-1) return fruits[fruits.size()-1][0];
            else return -1000009;
        }
        if (x < 0 || x >= fruits.size()) return 0;
        if (dp[x][y] != -1) return dp[x][y];
        return dp[x][y] = fruits[x][y] + max(solve2(fruits, dp, x+1, y-1), max(solve2(fruits, dp, x, y-1), solve2(fruits, dp, x-1, y-1)));
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i=0;i<n;++i){
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> dp(n, vector<int>(n, -1));
        int k = solve1(fruits, dp, n-1, n-1);
        vector<vector<int>> dp2(n, vector<int>(n, -1));
        int l = solve2(fruits, dp2, n-1, n-1);
        return ans + dp[n-1][n-1] + dp2[n-1][n-1];
    }
};",1460869356
nedmv,nedmv,261,3591,cpp,"class Solution {
    long long roll(char start, char end, const vector<int>& cost, bool forward) {
        int pos = start-'a';
        int end_pos = end-'a';

        long long total = 0;
        while(pos != end_pos) {
            total += cost[pos];
            if (forward) {
                pos = (pos + 1) % 26;
            } else {
                pos = (pos + 25) % 26;
            }
        }
        return total;
    }
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        size_t n = s.size();
        long long total = 0;
        for (int i = 0; i < n; ++i) {
            total += min(roll(s[i], t[i], nextCost, true), roll(s[i], t[i], previousCost, false));
        }
        return total;
    }
};",1460864355
nedmv,nedmv,261,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; i > 0; --i) {
            n -= i;
            if (n < 0) {
                return i % 2 != 0;
            }
        }
        return false;
    }
};",1460798917
nedmv,nedmv,261,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();

        
        int ans = 0;

        // the only route is diagonal
        for (int i = 0; i < n; ++i) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }

        // can't pick this and reach end in n-1 turns
        for (int row = 0; row < n; ++row) {
            for (int col = 0; col < n-1-row; ++col) {
                fruits[row][col] = 0;
            }
        }

        vector<int> prev(n+1);
        vector<int> cur(n+1);
        
        for (int row = 0; row < n; ++row) {
            for (int col = row+1; col < n; ++col) {
                cur[col] = max(max(prev[col-1], prev[col]), prev[col+1]) + fruits[row][col];
            }
            prev = cur;
        }
        ans += cur[n-1];

        for (int i = 0; i < n; ++i) {
            prev[i] = 0;
        }

        for (int col = 0; col < n; ++col) {
            for (int row = col+1; row < n; ++row) {
                cur[row] = max(max(prev[row-1], prev[row]), prev[row+1]) + fruits[row][col];
            }
            prev = cur;
        }
        ans += cur[n-1];
        return ans;
    }
};",1460852776
Andimeo,Andimeo,265,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        r = 0
        for i in range(len(s)):
            a, b = ord(s[i]) - ord('a'), ord(t[i]) - ord('a')
            p, q = 0, 0
            c, d = a, b
            while c != d:
                p += nextCost[c]
                c = (c + 1) % 26
            c, d = a, b
            while c != d:
                q += previousCost[c]
                c = (c - 1 + 26) % 26
            r += min(p, q)
        return r",1460814792
Andimeo,Andimeo,265,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        a = 10
        i = 0
        while True:
            if n >= a:
                n -= a
            else:
                return i % 2 == 1
            i += 1
            a -= 1
        return False",1460798774
Andimeo,Andimeo,265,3648,python3,"class Solution:
    def maxCollectedFruits(self, f: List[List[int]]) -> int:
        n = len(f)
        a = 0
        for i in range(n):
            a += f[i][i]

        dpb = [[-1] * n for _ in range(n)]
        dpb[0][n-1] = f[n-1][0]
        for i in range(n-1):
            for j in range(n):
                if dpb[i][j] != -1:
                    if j + 1 < n and j + 1 != i + 1:
                        dpb[i+1][j+1] = max(dpb[i+1][j+1], dpb[i][j] + f[j+1][i+1])
                    if j != i:
                        dpb[i+1][j] = max(dpb[i+1][j], dpb[i][j] + f[j][i+1])
                    if j - 1 >= 0 and j - 1 != i + 1:
                        dpb[i+1][j-1] = max(dpb[i+1][j-1], dpb[i][j] + f[j-1][i+1])
        b = max(dpb[n-2][n-1], dpb[n-2][n-2] - f[n-2][n-2])

        dpc = [[-1] * n for _ in range(n)]
        dpc[0][n-1] = f[0][n-1]
        for i in range(n-1):
            for j in range(n):
                if dpc[i][j] != -1:
                    if j + 1 < n and j + 1 != i + 1:
                        dpc[i+1][j+1] = max(dpc[i+1][j+1], dpc[i][j] + f[i+1][j+1])
                    if i + 1 != j:
                        dpc[i+1][j] = max(dpc[i+1][j], dpc[i][j] + f[i+1][j])
                    if j - 1 >= 0 and j - 1 != i + 1:
                        dpc[i+1][j-1] = max(dpc[i+1][j-1], dpc[i][j] + f[i+1][j-1])

        c = max(dpc[n-2][n-1], dpc[n-2][n-2] - f[n-2][n-2])
        print(a, b, c)
        return a + b + c
        ",1460867136
Bohus,leetCoinCollector,266,3591,kotlin,"class Solution {
    fun shiftDistance(s: String, t: String, nextCost: IntArray, previousCost: IntArray): Long {
        var ans = 0L
        val n = s.length
        
        for(i in 0 until n) {
            var f = 0L
            var b = 0L
            var c = s[i]
            var id = s[i] - 'a'
            while(c != t[i]){
                c++
                if(c > 'z'){
                    c = 'a'
                }
                f += nextCost[id]
                id++
                if(id == 26) {
                    id = 0
                }
            }
            c = s[i]
            id = s[i] - 'a'
            while(c != t[i]){
                c--
                if(c < 'a'){
                    c = 'z'
                }
                b += previousCost[id]
                id--
                if(id < 0) {
                    id = 25
                }
            }
            ans += b.coerceAtMost(f)
        }
        return ans
    }
}",1460852196
Bohus,leetCoinCollector,266,3625,kotlin,"class Solution {
    fun canAliceWin(n: Int): Boolean {
        var m = 10
        var p = n
        var ans = true
        while(p >= 0){
            p -= m
            ans = !ans
            m--
        }
        return ans
        
    }
}",1460808126
Bohus,leetCoinCollector,266,3648,kotlin,"class Solution {
    fun maxCollectedFruits(fruits: Array<IntArray>): Int {
        var ans = 0
        val n = fruits.size
        for(i in 0 until n) {
            ans += fruits[i][i]
        }

        val d1 = Array(n){IntArray(n){-1000000000}}
        d1[0][n - 1] = fruits[0][n - 1]
        for(i in 1 until n) {
            for(j in i + 1 until n) {
                d1[i][j] = d1[i][j].coerceAtLeast(d1[i - 1][j - 1] + fruits[i][j])
                d1[i][j] = d1[i][j].coerceAtLeast(d1[i - 1][j] + fruits[i][j])
                if(j + 1 < n)d1[i][j] = d1[i][j].coerceAtLeast(d1[i - 1][j + 1] + fruits[i][j])
            }
        }

        val d2 = Array(n){IntArray(n){-1000000000}}
        d2[n - 1][0] = fruits[n - 1][0]
        for(j in 1 until n) {
            for(i in j + 1 until n) {
                d2[i][j] = d2[i][j].coerceAtLeast(d2[i - 1][j - 1] + fruits[i][j])
                d2[i][j] = d2[i][j].coerceAtLeast(d2[i][j - 1] + fruits[i][j])
                if(i + 1 < n)d2[i][j] = d2[i][j].coerceAtLeast(d2[i + 1][j - 1] + fruits[i][j])
            }
        }
        ans += d1[n - 2][n - 1]
        ans += d2[n - 1][n - 2]
        return ans
    }
}",1460880000
tmimotw,tmimotw,267,3591,java,"class Solution {
 public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        var costByNext = new long[26][26];
        for (int from = 0; from < 26; from++) {
            for (int to = from + 1; to < 26; to++) {
                costByNext[from][to] = costByNext[from][to - 1] + nextCost[to - 1];
            }
            costByNext[from][0] = costByNext[from][25] + nextCost[25];
            for (int to = 1; to < from; to++) {
                costByNext[from][to] = costByNext[from][to - 1] + nextCost[to - 1];
            }
        }
        var costByPrev = new long[26][26];
        for (int from = 0; from < 26; from++) {
            for (int to = from - 1; to >= 0; to--) {
                costByPrev[from][to] = costByPrev[from][to + 1] + previousCost[to + 1];
            }
            costByPrev[from][25] = costByPrev[from][0] + previousCost[0];
            for (int to = 24; to > from; to--) {
                costByPrev[from][to] = costByPrev[from][to + 1] + previousCost[to + 1];
            }
        }
        long result = 0;
        for (int i = 0; i < s.length(); i++) {
            var from = s.charAt(i) - 'a';
            var to = t.charAt(i) - 'a';
            result += Math.min(costByNext[from][to], costByPrev[from][to]);
        }
        return result;
    }
}",1460826286
tmimotw,tmimotw,267,3625,java,"class Solution {
public boolean canAliceWin(int n) {
        var currentPlayer = 0;
        var currentStep = 10;
        while (n >= 0) {
            n -= currentStep;
            currentPlayer = 1 - currentPlayer;
            currentStep--;
        }
        if (currentPlayer == 0)
            return true;
        return false;
    }
}",1460801471
tmimotw,tmimotw,267,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        var n = fruits.length;
        var result = 0;
        for (int i = 0; i < n; i++) {
            result += fruits[i][i];
            fruits[i][i] = 0;
        }
        var dp = new int[n][n];
        var mid = (n + 1) / 2;
        var MIN_INF = -1000001;
        Arrays.fill(dp[0], MIN_INF);
        dp[0][n - 1] = fruits[0][n - 1];
        for (int row = 1; row < n; row++) {
            Arrays.fill(dp[row], MIN_INF);
            for (int col = n - 1; col >= mid; col--) {
                dp[row][col] = dp[row - 1][col];
                if (col + 1 <= n - 1)
                    dp[row][col] = Math.max(dp[row][col], dp[row - 1][col + 1]);
                if (col - 1 >= mid)
                    dp[row][col] = Math.max(dp[row][col], dp[row - 1][col - 1]);
                dp[row][col] += fruits[row][col];
            }
        }
        result += dp[n - 1][n - 1];
        dp = new int[n][n];
        Arrays.fill(dp[0], MIN_INF);
        dp[0][n - 1] = fruits[n - 1][0];
        for (int col = 1; col < n; col++) {
            Arrays.fill(dp[col], MIN_INF);
            for (int row = n - 1; row >= mid; row--) {
                dp[col][row] = dp[col - 1][row];
                if (row + 1 <= n - 1)
                    dp[col][row] = Math.max(dp[col][row], dp[col - 1][row + 1]);
                if (row - 1 >= mid)
                    dp[col][row] = Math.max(dp[col][row], dp[col - 1][row - 1]);
                dp[col][row] += fruits[row][col];
            }
        }
        result += dp[n - 1][n - 1];
        return result;
    }
}",1460875123
Allen Tigga,AllenTigga02,270,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();

        for (int i = 0; i < n; i++) {
            int start = s[i] - 'a';
            int target = t[i] - 'a';

            // Forward traversal cost
            long long forwardCost = 0;
            for (int j = start; j != target; j = (j + 1) % 26) {
                forwardCost += nextCost[j];
            }

            // Backward traversal cost
            long long backwardCost = 0;
            for (int j = start; j != target; j = (j - 1 + 26) % 26) {
                backwardCost += previousCost[j];
            }

            // Add the minimum cost to the total answer
            ans += min(forwardCost, backwardCost);
        }

        return ans;
    }
};
",1460828723
Allen Tigga,AllenTigga02,270,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10;i>0;i--){
            n-=i;
            if(n<0){
                return (i%2!=0)? true:false;
            }
        }
        return true;
    }
};",1460800105
Allen Tigga,AllenTigga02,270,3648,cpp,"class Solution {
public:
    vector<vector<int>> dp;

    // Helper function to move left-to-right
    int helper_left_to_right(int i, int j, int x, int y, int n, vector<vector<int>> &fruits) {
    if (i < 0 || i >= n || j < 0 || j >= fruits[0].size()) return INT_MIN;  // Correct bounds check
    if (i == x && j == y) return fruits[x][y];
    if (dp[i][j] != -1) return dp[i][j];

    int A = helper_left_to_right(i - 1, j + 1, x, y, n, fruits);
    int B = helper_left_to_right(i, j + 1, x, y, n, fruits);
    int C = helper_left_to_right(i + 1, j + 1, x, y, n, fruits);

    return dp[i][j] = fruits[i][j] + max({A, B, C});
}

int helper_top_to_down(int i, int j, int x, int y, int n, vector<vector<int>> &fruits) {
    if (i < 0 || i >= n || j < 0 || j >= fruits[0].size()) return INT_MIN;  // Correct bounds check
    if (i == x && j == y) return fruits[x][y];
    if (dp[i][j] != -1) return dp[i][j];

    int A = helper_top_to_down(i + 1, j - 1, x, y, n, fruits);
    int B = helper_top_to_down(i + 1, j, x, y, n, fruits);
    int C = helper_top_to_down(i + 1, j + 1, x, y, n, fruits);

    return dp[i][j] = fruits[i][j] + max({A, B, C});
}

    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();

        // Collect fruits from the main diagonal (child_1st)
        int child_1st = 0;
        for (int i = 0; i < n; i++) {
            child_1st += fruits[i][i];
            fruits[i][i] = 0; // Mark collected fruits
        }

        // Left-to-right collection (child_2nd)
        dp.assign(n, vector<int>(n, -1));
        int child_2nd = helper_left_to_right(n - 1, 0, n - 1, n - 2, n, fruits);

        // Top-to-down collection (child_3rd)
        dp.assign(n, vector<int>(n, -1));
        int child_3rd = helper_top_to_down(0, n - 1, n - 2, n - 1, n, fruits);

        // cout << child_1st << "" "" << child_2nd << "" "" << child_3rd << endl;

        return child_1st + child_2nd + child_3rd;
    }
};
",1460875916
Sonu_710,Sonu_710,274,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] n, int[] p) {
        long ans=0;
        for(int i=0;i<s.length();i++)
            {
                int curr=s.charAt(i)-'a';
                int req=t.charAt(i)-'a';
                long frd=0;
                long bkd=0;
                while(curr!=req)
                    {
                        frd+=(long)n[curr];
                        curr=(curr+1)%26;
                    }
                curr=s.charAt(i)-'a';
                req=t.charAt(i)-'a';
                while(curr!=req)
                    {
                        bkd+=(long)p[curr];
                        curr=(curr-1);
                        if(curr<0)
                            curr+=26;
                        curr=curr%26;
                    }
                ans=ans+Math.min(frd,bkd);
            }
        return ans;
    }
}",1460813573
Sonu_710,Sonu_710,274,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int start=10;
        int turn=1;
        while(n>=0)
            {
                n-=start;
                start--;
                if(n<0)
                {
                    if(turn==1)
                        return false;
                    return true;
                }
                turn*=(-1);
            }
        return false;
    }
}",1460801102
Sonu_710,Sonu_710,274,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] nums) {
        int ans=0;
        int n=nums.length;
        
        for(int i=0;i<nums.length;i++)
            {
                for(int j=0;j<n;j++)
                    {
                        if(i==j)
                        {
                            ans+=nums[i][j];
                            nums[i][j]=0;
                        }
                    }
            }
        int[][] dp=new int[n][n];
        for(int[] row:dp)
            Arrays.fill(row,-1);
        // System.out.println(ans);
        // System.out.println(getMaxTop(0,n-1,n-1,nums,dp));
        
        // System.out.println(getMaxDown(n-1,0,n-1,nums,dp));
        ans+=getMaxTop(0,n-1,n-1,nums,dp);
        for(int[] row:dp)
            Arrays.fill(row,-1);
        ans+=getMaxDown(n-1,0,n-1,nums,dp);
        return ans;
    }
    static int getMaxTop(int row,int col,int n,int[][] nums,int[][] dp)
    {
        // System.out.println(row+"" ""+col+"" ""+n);
        if(n<0)
            return -(int)1e5;
        if(row==nums.length-1 && col==nums.length-1)
            return 0;
        // System.out.println(dp[col][n]);
        if(dp[col][n]==-1)
        {
            int op1=getMaxTop(row+1,col-1,n-1,nums,dp);
            int op2=getMaxTop(row+1,col,n-1,nums,dp);
            int op3=0;
            if(col+1<nums[0].length)
                op3=getMaxTop(row+1,col+1,n-1,nums,dp);

            dp[col][n]=nums[row][col]+Math.max(op1,Math.max(op2,op3));
        }
        return dp[col][n];
    }
    static int getMaxDown(int row,int col,int n,int[][] nums,int[][] dp)
    {
        if(n<0)
            return -(int)1e5;
        if(row==nums.length-1 && col==nums.length-1)
            return 0;
        if(dp[row][n]==-1)
        {
            int op1=getMaxDown(row-1,col+1,n-1,nums,dp);
            int op2=getMaxDown(row,col+1,n-1,nums,dp);
            int op3=0;
            if(row+1<nums.length)
                op3=getMaxDown(row+1,col+1,n-1,nums,dp);
            dp[row][n]=nums[row][col]+Math.max(op1,Math.max(op2,op3));
        }
        return dp[row][n];
    }
}",1460876394
srujan2_3,srujan2_3,277,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& a, vector<int>& b) {
        long long ans=0;
        int n=s.size();
        for(int i=0;i<n;i++)
            {
                long long val=0;
                char x=s[i];
                while(x!=t[i])
                {
                    val+=a[x-'a'];
                    if(x=='z')
                    {
                        x='a';
                    }
                    else
                    {
                        x++;
                    }
                }
                long long res=0;
                x=s[i];
                while(x!=t[i])
                {
                    // cout<<x-'0'<<endl;
                    res+=b[x-'a'];
                    if(x=='a')
                    {
                        x='z';
                    }
                    else
                    {
                        x--;
                    }
                }
                ans+=min(val,res);
            }
        return ans;
    }
};",1460825493
srujan2_3,srujan2_3,277,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt=0;
        int x=10;
        while(n>=x)
            {
                n-=x;
                cnt++;
                x--;
            }
        return cnt%2;
    }
};",1460801923
srujan2_3,srujan2_3,277,3648,cpp,"class Solution {
public:
int f(vector<vector<int>>& mat, int i, int j,vector<vector<int>> &dp)
{
    if(i==mat.size()-2)
    {
        if(j==mat.size()-1)
        {
            return mat[i][j];
        }
        else
        {
            return INT_MIN;
        }
    }
    if(dp[i][j]!=-1)
    {
        return dp[i][j];
    }
    int ans=0;
    if(i+1<j-1)
    {
        // cout<<i<<j;
        ans=max(ans,mat[i][j]+f(mat,i+1,j-1,dp));
    }
    if(i+1<j)
    {
        ans=max(ans,mat[i][j]+f(mat,i+1,j,dp));
    }
    if(i+1<j+1 && j+1<mat.size())
    {
        ans=max(ans,mat[i][j]+f(mat,i+1,j+1,dp));
    }
    dp[i][j]=ans;
    return ans;
}
int l(vector<vector<int>>& mat, int i, int j,vector<vector<int>> &da)
{
    if(j==mat.size()-2)
    {
        // cout<<i<<j<<endl;
        if(i==mat.size()-1)
        {
            
            return mat[i][j];
        }
        else
        {
            return INT_MIN;
        }
    }
    if(da[i][j]!=-1)
    {
        return da[i][j];
    }
    int ans=0;
    // cout<<i<<"" ""<<j<<endl;
    if(j+1<i-1)
    {
        // cout<<i<<"" ""<<j<<endl;
        // cout<<i<<j;
        ans=max(ans,mat[i][j]+l(mat,i-1,j+1,da));
    }
    if(j+1<i)
    {
        // cout<<i<<"" ""<<j<<endl;
        ans=max(ans,mat[i][j]+l(mat,i,j+1,da));
    }
    if(j+1<i+1 && i+1<mat.size())
    {
        ans=max(ans,mat[i][j]+l(mat,i+1,j+1,da));
    }
    // cout<<ans<<endl;
    da[i][j]=ans;
    return ans;
}
    int maxCollectedFruits(vector<vector<int>>& mat) {
        int n=mat.size();
        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));
        int ans=f(mat,0,n-1,dp);
        // cout<<ans;
        vector<vector<int>>da(n+1,vector<int>(n+1,-1));
        ans+=l(mat,n-1,0,da);
         // cout<<ans;
        for(int i=0;i<n;i++)
            {
                ans+=mat[i][i];
            }
        return ans;
    }
};",1460883049
jashr_123,jashr_123,281,3591,cpp,"class Solution {
public:
    long long helper(int idx, vector<long long>&v)
    {
        if(idx<0) return 0;
        return v[idx];
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<long long>prefixSum1(26,0), prefixSum2(26,0);

        prefixSum1[0] = nextCost[0];
        prefixSum2[0] = previousCost[0];
        for(int i=1;i<26;i++) 
        {
            prefixSum1[i] += (nextCost[i] + prefixSum1[i-1]); 
            prefixSum2[i] += (previousCost[i] + prefixSum2[i-1]); 
        }

        long long ans = 0;
        
        for(int i=0;i<s.size();i++)
        {
            int start = s[i]-'a';
            int end = t[i]-'a';

            if(start < end)
            {
                ans = ans + min(helper(end-1, prefixSum1)-helper(start-1, prefixSum1), helper(start,prefixSum2) + (helper(25,prefixSum2) - helper(end,prefixSum2)));
            }
            else if(start > end)
            {
                ans = ans + min(helper(start,prefixSum2) - helper(end,prefixSum2) ,  helper(end-1,prefixSum1) + (helper(25,prefixSum1) -  helper(start-1,prefixSum1)));
            }
        }

        return ans;
    }
};",1460837812
jashr_123,jashr_123,281,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0; int cnt = 10;
        while(n>0)
        {
            if(n < cnt) break;
            if(cnt<0) break;
            n -= cnt;
            cnt--; 
            turn = 1 - turn;
        }

        if(turn==1) {
            return true;
        }
        return false;
    }
};",1460799765
jashr_123,jashr_123,281,3648,cpp,"class Solution {
public:

    void helper(vector<vector<int>>&dp, int n)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                dp[i][j] = -1;
            }
        }
    }
    bool isValid(int x,int y,int &n)
    {
        if((x<0) || (y<0) || (x>=n) || (y>=n)) {
            return false;
        }
        if(x<y)
        {
            // we are above diagonal
            return false;
        }
        return true;
    }

    void doTranspose(vector<vector<int>>& fruits, int n)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<i;j++)
            {
                swap(fruits[i][j], fruits[j][i]);
            }
        }
    }

    int rec(int x,int y, vector<vector<int>>& fruits, int &n, vector<vector<int>>&dp)
    {
        if(x==(n-1) && y==(n-1))
        {
            return 0;
        }

        if(dp[x][y] != -1) return dp[x][y];
        
        int ans = 0, ans1 = 0, ans2 = 0,ans3 = 0;
        if(x!=y) {
            ans = fruits[x][y];
        }
        
        if(isValid(x,y+1,n))
        {
            ans1 = rec(x,y+1,fruits,n,dp);  
        }
        if(isValid(x+1,y+1,n))
        {
            ans2 = rec(x+1,y+1,fruits,n,dp);  
        }
        if(isValid(x-1,y+1,n))
        {
            ans3 = rec(x-1,y+1,fruits,n,dp);  
        }

        ans = ans + max(ans1,max(ans2,ans3));

        return dp[x][y] = ans;
    }

    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0, n = fruits.size();
        
        // contribution by child-1
        for(int i=0;i<n;i++)
        {
            ans += fruits[i][i];
        }

        // contribution by child-3
        vector<vector<int>>dp1(n,vector<int>(n,-1));
        ans += rec(n-1,0,fruits,n,dp1);

        

        // contribution by child-2
        doTranspose(fruits,n);
        helper(dp1,n);
        ans += rec(n-1,0,fruits,n,dp1);

        return ans;
    }
};",1460885083
got_u,got_u,282,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.length();i++){
            int ind1=s[i]-'a';
            int ind2=s[i]-'a';
            int ind3=t[i]-'a';
            long long s1=0;
            long long s2=0;
            while(ind1!=ind3){
                s1+=(long long)nextCost[ind1];
                ind1=(ind1+1)%26;
            }
            while(ind2!=ind3){
                s2+=(long long)previousCost[ind2];
                ind2=(26+ind2-1)%26;
            }
            ans+=min(s1,s2);
        }

        return ans;
    }
};",1460814743
got_u,got_u,282,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice=true;
        int start=10;
        int turn=0;
        while(true){
            if(n>=start){
                n-=start;
            }else{
                return !alice;
            }
            alice=!alice;
            start--;
        }

        return false;
    }
};",1460801145
got_u,got_u,282,3648,cpp,"int dp1[1001][1001];
int dp2[1001][1001];
class Solution {
public:
    bool isreachable1(int x, int y, int n){
        if(x<0||x>=n||y<0||y>=n){
            return false;
        }
        int currsteps=x;
        int stepsrem=n-1-currsteps;
        if(n-1-y<=stepsrem){
            return true;
        }
        return false;
    }
    int recurse1(int x, int y, int n, vector<vector<int>>& fruits){
        if(x==n-1&&y==n-1){
            return 0;
        }
        if(isreachable1(x, y ,n)==false){
            return 0;
        }
        if(dp1[x][y]!=-1){
            return dp1[x][y];
        }
        int ans=0;
        int curr=fruits[x][y];
        if(x==y){
            curr=0;
        }
        ans=max(ans, recurse1(x+1, y, n, fruits)+curr);
        ans=max(ans, recurse1(x+1, y-1, n, fruits)+curr);
        ans=max(ans, recurse1(x+1, y+1, n, fruits)+curr);

        return dp1[x][y]=ans;
    }
    bool isreachable2(int x, int y, int n){
        if(x<0||x>=n||y<0||y>=n){
            return false;
        }
        int currsteps=y;
        int stepsrem=n-1-currsteps;
        if(n-1-x<=stepsrem){
            return true;
        }
        return false;
    }
    int recurse2(int x, int y, int n, vector<vector<int>>& fruits){
        if(x==n-1&&y==n-1){
            return 0;
        }
        if(isreachable2(x, y ,n)==false){
            return 0;
        }
        if(dp2[x][y]!=-1){
            return dp2[x][y];
        }
        int ans=0;
        int curr=fruits[x][y];
        if(x==y){
            curr=0;
        }
        ans=max(ans, recurse2(x-1, y+1, n, fruits)+curr);
        ans=max(ans, recurse2(x, y+1, n, fruits)+curr);
        ans=max(ans, recurse2(x+1, y+1, n, fruits)+curr);

        return dp2[x][y]=ans;
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        memset(dp1, -1, sizeof(dp1));
        memset(dp2, -1, sizeof(dp2));
        int n=fruits.size();
        int ans=recurse1(0, n-1, n, fruits)+recurse2(n-1, 0, n, fruits);
        for(int i=0;i<n;i++){
            ans+=fruits[i][i];
        }

        return ans;
    }
};",1460879247
BurtTheAlert,BurtTheAlert,283,3591,typescript,"function shiftDistance(s: string, t: string, nextCost: number[], previousCost: number[]): number {
    let sum = 0;
    for (let i=0; i<s.length; ++i)
        sum += transform(s[i], t[i], nextCost, previousCost);
    return sum;
}

function toIndex(c: string): number {
    return c.charCodeAt(0) - 97;
}

function transform(a: string, b: string, nextCost: number[], previousCost: number[]): number {
    if (a === b) return 0;

    const target = toIndex(b);
    let j = toIndex(a);

    let forwardCost = 0;
    while (j !== target) {
        forwardCost += nextCost[j];
        j = (j + 1) % 26;
    }

    j = toIndex(a);
    let backCost = 0;
    while (j !== target) {
        backCost += previousCost[j];
        j = (26 + j - 1) % 26;
    }

    return Math.min(forwardCost, backCost);
}",1460826913
BurtTheAlert,BurtTheAlert,283,3625,typescript,"function canAliceWin(n: number): boolean {
    let x = 10;
    let alice = true;
    while (x <= n) {
        n -= x;
        --x;
        alice = !alice;
    }
    return !alice;
}",1460798273
BurtTheAlert,BurtTheAlert,283,3648,typescript,"function maxCollectedFruits(fruits: number[][]): number {
    const n = fruits.length;

    // Diagonal child has only one choice (trick question):
    let diag = 0;
    for (let i=0; i<n; ++i) {
        diag += fruits[i][i];
        fruits[i][i] = 0;
    }

    console.log(diag, subRight(fruits), subDown(fruits));

    return diag + subRight(fruits) + subDown(fruits);
}

function subRight(fruits: number[][]): number {
    const n = fruits.length;

    let prev = Array(~~(n/2)).fill(0);
    let curr = Array(~~(n/2)).fill(0);
    prev[0] = fruits[n - 1][0];

    for (let i=1; i<n; ++i) { // TODO: n - 1?
        for (let j=0; j<=i; ++j) {
            curr[j] = Math.max(
                (prev[j - 1] || 0),
                (prev[j    ] || 0),
                (prev[j + 1] || 0)
            ) + fruits[n - 1 - j][i];
        }
        [prev, curr] = [curr, prev];
    }

    return prev[0];
}

function subDown(fruits: number[][]): number {
    const n = fruits.length;

    let prev = Array(~~(n/2)).fill(0);
    let curr = Array(~~(n/2)).fill(0);
    prev[0] = fruits[0][n - 1];

    for (let i=1; i<n; ++i) { // TODO: n - 1?
        for (let j=0; j<=i; ++j) {
            curr[j] = Math.max(
                (prev[j - 1] || 0),
                (prev[j    ] || 0),
                (prev[j + 1] || 0)
            ) + fruits[i][n - 1 - j];
        }
        [prev, curr] = [curr, prev];
    }

    return prev[0];
}",1460879417
wshldwps,wshldwps,284,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        self.nextCost = nextCost
        self.previousCost = previousCost
        self.costDic = self.buildDic()
        out = 0
        for i in range(len(s)):
            out += self.costDic[(ord(s[i])- ord('a'), ord(t[i])- ord('a'))]
        return out

    def buildDic(self):
        costDic = {}
        for i in range(26):
            for j in range(26):
                #if i == 0 and j == 1:
                #    print(self.getNextCost(i,j), self.getPrevCost(i,j))
                cost = min(self.getNextCost(i,j), self.getPrevCost(i,j))
                costDic[(i,j)] = cost
        return costDic

    def getNextCost(self, i, j):
        if i == j:
            return 0
        if i < j:
            out = 0
            for k in range(i,j):
                out += self.nextCost[k]
            return out
        out = 0
        for k in range(i, 26):
            out += self.nextCost[k]
        for k in range(j):
            out += self.nextCost[k]
        return out

    def getPrevCost(self, i, j):
        if i == j:
            return 0
        if i > j:
            out = 0
            for k in range(i,j, -1):
                out += self.previousCost[k]
            return out
        out = 0
        for k in range(i, -1, -1):
            out += self.previousCost[k]
        for k in range(25, j, -1):
            out += self.previousCost[k]
        return out",1460828805
wshldwps,wshldwps,284,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        out = False
        a = 10
        while n >= a:
            n -= a
            a -= 1
            out = not out
        return out",1460796954
wshldwps,wshldwps,284,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        self.n = len(fruits)
        self.fruits = fruits
        self.maxDic = {}
        out = self.getMid() + self.getMax(self.n-1,0, True) + self.getMax(0, self.n-1, False)
        return out

    def getMax(self, i , j, largerI):
        if i < 0 or i >= self.n or j < 0 or j >= self.n:
            return 0
        if largerI and j >= i:
            return 0
        if (not largerI) and i >= j:
            return 0
        if (i,j) in self.maxDic:
            return self.maxDic[(i,j)]
        if i > j:
            thisMax = self.fruits[i][j] + max(self.getMax(i, j+1, True), self.getMax(i + 1, j+1, True), self.getMax(i - 1, j+1, True))
            self.maxDic[(i,j)] = thisMax
            return thisMax
        thisMax = self.fruits[i][j] + max(self.getMax(i + 1, j, False), self.getMax(i + 1, j+1, False), self.getMax(i + 1, j - 1, False))
        self.maxDic[(i,j)] = thisMax
        return thisMax

    def getMid(self):
        out = 0
        for i in range(self.n):
            out += self.fruits[i][i]
        return out",1460879423
Catchet,Catchet,287,3591,cpp,"using ll = long long;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        const int num_char = 'z' - 'a' + 1;
        vector<vector<long long>> conv_rate(num_char, vector<long long> (num_char, -1));
        for (int i = 0; i < num_char; ++i) {
            for (int j = 0; j < num_char; ++j) {
                int x = i;
                ll right_cost = 0;
                while (x != j) {
                    right_cost += nextCost[x];
                    ++x;
                    if (x >= num_char)
                        x = 0;
                }
                x = i;
                ll left_cost = 0;
                while (x != j) {
                    left_cost += previousCost[x];
                    --x;
                    if (x < 0)
                        x = num_char - 1;
                }
                conv_rate[i][j] = min(left_cost, right_cost);
            }
        }
        ll ans = 0;
        for (int i = 0; i < n; ++i) {
            int c1 = s[i] - 'a';
            int c2 = t[i] - 'a';
            ans += conv_rate[c1][c2];        
        }
        return ans;
    }
};",1460816984
Catchet,Catchet,287,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int k = 10;
        bool alice = true;
        while (n >= 0) {
            n -= k;
            --k;
            alice = !alice;
        }
        return alice;
    }
};",1460796967
Catchet,Catchet,287,3648,cpp,"#define INF (1e8 + 7)
class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int child_diag = 0, child_bottom = 0, child_side = 0;
        int x, y;
        for (int i = 0; i < n; ++i) {
            x = y = i;
            child_diag += fruits[x][y];
            fruits[x][y] = 0;
        }
        vector<vector<int>> side_opt(n, vector<int>(n));
        side_opt[0][n - 1] = fruits[0][n - 1];
        for (int i = 0; i < n - 1; ++i) {
            side_opt[0][i] = -INF;
            fruits[0][i] = -INF;
        }
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                int a = 0, b = 0, c = 0;
                if (j > 0)
                    a = side_opt[i - 1][j - 1];
                b = side_opt[i - 1][j];
                if (j < n - 1)
                    c = side_opt[i - 1][j + 1];
                side_opt[i][j] += max({a, b, c});
                //if (side_opt[i][j] > 0)
                    side_opt[i][j] += fruits[i][j];
            }
        }
        child_side = side_opt[n - 1][n - 1];

        vector<vector<int>> bottom_opt(n, vector<int>(n));
        bottom_opt[n - 1][0] = fruits[n - 1][0];
        for (int i = 0; i < n - 1; ++i) {
            bottom_opt[i][0] = -INF;
            fruits[i][0] = -INF;
        }
        for (int j = 1; j < n; ++j) {
            for (int i = 0; i < n; ++i) {
                int a = 0, b = 0, c = 0;
                if (i > 0)
                    a = bottom_opt[i - 1][j - 1];
                b = bottom_opt[i][j - 1];
                if (i < n - 1)
                    c = bottom_opt[i + 1][j - 1];
                bottom_opt[i][j] += max({a, b, c});
                //if (bottom_opt[i][j] > 0)
                    bottom_opt[i][j] += fruits[i][j];
            }
        }
        child_bottom = bottom_opt[n - 1][n - 1];
        
        return child_diag + child_bottom + child_side;
    }
};",1460874210
Ashutosh Krishna,ashu_2202,288,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        long long ans = 0;
        map<pair<char,char>, long long> mnc, mpc;
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                long long sm = 0;
                int k=i;
                while(k!= j){
                    sm += nc[k];
                    k++;
                    k%=26;
                }
                // cout<<'a'+i<<"" ""<<'a'+j<<"" ""<<sm<<endl;
                mnc[{'a'+i,'a'+j}] = sm;
            }
        }
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                long long sm = 0;
                int k=i;
                while(k!= j){
                    sm += pc[k];
                    k--;
                    k += 26;
                    k%=26;
                }
                mpc[{'a'+i,'a'+j}] = sm;
            }
        }
        for(int i=0;i<s.size();i++){
            // long long v1 = t[i]-s[i];
            // if(v1 < 0) v1 += 26;
            // long long v2 = 26 - v1;
            // cout<<s[i]<<"" ""<<t[i]<<"" ""<<mnc[{s[i], t[i]}]<<endl;
            // cout<<s[i]<<"" ""<<t[i]<<"" ""<<mpc[{s[i], t[i]}]<<endl;
            ans += min(mnc[{s[i], t[i]}], mpc[{s[i],t[i]}]);
        }
        return ans;
    }
};",1460825155
Ashutosh Krishna,ashu_2202,288,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 10;
        int k = 0;
        while(n >= x){
            n -= x;
            x--;
            k ^= 1;
        }
        return k;
    }
};",1460796956
Ashutosh Krishna,ashu_2202,288,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int n = f.size(), m = f[0].size();
        int ans = 0;
        for(int i=0;i<n;i++)
            ans += f[i][i];
        vector<vector<int>> dp(n, vector<int>(m,0));
        dp[n-1][0] = f[n-1][0];
        for(int j=1;j<m;j++){
            for(int i=0;i<n;i++){
                if(i+j >= n-1){
                    int mx = dp[i][j-1];
                    if(i-1 >= 0) mx = max(mx, dp[i-1][j-1]);
                    if(i+1 < n) mx = max(mx, dp[i+1][j-1]);
                    dp[i][j] = mx + f[i][j];
                }
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         cout<<dp[i][j]<<"" "";
        //     }
        //     cout<<endl;
        // }
        vector<vector<int>> dpp(n, vector<int>(m,0));
        dpp[0][n-1] = f[0][n-1];
        for(int i=1;i<n;i++){
            for(int j=0;j<m;j++){
                if(j+i >= n-1){
                    int mx = dpp[i-1][j];
                    if(j-1 >= 0) mx = max(mx, dpp[i-1][j-1]);
                    if(j+1 < m) mx = max(mx, dpp[i-1][j+1]);
                    dpp[i][j] = mx + f[i][j];
                }
            }
        }
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         cout<<dpp[i][j]<<"" "";
        //     }
        //     cout<<endl;
        // }
        
        return ans + dp[n-1][n-2] + dpp[n-2][n-1];
    }
};",1460880345
serparamon,serparamon,290,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[][] d = new long[26][26];
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                if (i <= j) {
                    long f = 0;
                    for (int k = i; k < j; k++) {
                        f += nextCost[k];
                    }
                    long b = 0;
                    for (int k = i+26; k > j; k--) {
                        b += previousCost[k%26];
                    }
                    d[i][j] = Math.min(f, b);
                } else {
                    long f = 0;
                    for (int k = i; k < j+26; k++) {
                        f += nextCost[k%26];
                    }
                    long b = 0;
                    for (int k = i; k > j; k--) {
                        b += previousCost[k];
                    }
                    d[i][j] = Math.min(f, b);
                }
            }
        }
        long ans = 0;
        for (int i = 0; i < s.length(); i++) {
            ans += d[s.charAt(i)-'a'][t.charAt(i)-'a'];
        }
        return ans;
    }
}",1460817597
serparamon,serparamon,290,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean ans = false;
        for (int i = 10; i >= 1; i--) {
            if (n < i) {
                return ans;
            }
            n -= i;
            ans = !ans;
        }
        return ans;
    }
}",1460799055
serparamon,serparamon,290,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        int a1 = 0;
        for (int i = 0; i < n; i++) {
            a1 += fruits[i][i];
        }

        int[][] d = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(d[i], -1500000);
        }
        d[0][n-1] = fruits[0][n-1];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                d[i][j] = d[i-1][j];
                if (j > 0 && d[i-1][j-1] > d[i][j]) {
                    d[i][j] = d[i-1][j-1];
                }
                if (j+1 < n && d[i-1][j+1] > d[i][j]) {
                    d[i][j] = d[i-1][j+1];
                }
                if (i != j) {
                    d[i][j] += fruits[i][j];
                }
            }
        }
        int a2 = d[n-1][n-1];

        d = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(d[i], -1500000);
        }
        d[0][n-1] = fruits[n-1][0];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                d[i][j] = d[i-1][j];
                if (j > 0 && d[i-1][j-1] > d[i][j]) {
                    d[i][j] = d[i-1][j-1];
                }
                if (j+1 < n && d[i-1][j+1] > d[i][j]) {
                    d[i][j] = d[i-1][j+1];
                }
                if (i != j) {
                    d[i][j] += fruits[j][i];
                }
            }
        }
        int a3 = d[n-1][n-1];

        return a1 + a2 + a3;
    }
}",1460880834
Chuan-Chih Chou,chuan-chih,291,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nextCost[:] = accumulate(nextCost)
        previousCost[:] = accumulate(previousCost)
        nextCost.append(0)
        previousCost.append(0)
        ans = 0
        for x, y in zip(s, t):
            x = ord(x) - ord('a')
            y = ord(y) - ord('a')
            if x != y:
                if y > x:
                    forward = nextCost[y - 1] - nextCost[x - 1]
                else:
                    forward = nextCost[-2] - nextCost[x - 1] + nextCost[y - 1]
                if x > y:
                    backward = previousCost[x] - previousCost[y]
                else:
                    backward = previousCost[x] + previousCost[-2] - previousCost[y]
                ans += min(forward, backward)
        return ans",1460831967
Chuan-Chih Chou,chuan-chih,291,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        remove = 10
        for i in range(n):
            if n < remove:
                return bool(i % 2)
            n -= remove
            remove -= 1
            ",1460798323
Chuan-Chih Chou,chuan-chih,291,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        middle = n // 2
        diag = sum(fruits[i][i] for i in range(n))

        @cache
        def vertical(i, j):
            if i == n - 1:
                return 0 if j == n - 1 else -inf
            if j >= n:
                return -inf
            pick = fruits[i][j]
            if i >= middle and i == j:
                pick = 0
            return pick + max(vertical(i + 1, y) for y in range(j - 1, j + 2))
        
        @cache
        def horizontal(i, j):
            if j == n - 1:
                return 0 if i == n - 1 else -inf
            if i >= n:
                return -inf
            pick = fruits[i][j]
            if j >= middle and i == j:
                pick = 0
            return pick + max(horizontal(x, j + 1) for x in range(i - 1, i + 2))

        return diag + vertical(0, n - 1) + horizontal(n - 1, 0)
        ",1460886837
Lego Haryanto,turuthok,292,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        for i, (a, b) in enumerate(zip(s, t)):
            aa = ord(a)-ord('a')
            bb = ord(b)-ord('a')
            i = aa
            c = 0
            while i != bb:
                c += nextCost[i]
                i += 1
                if i == 26: i = 0
            d = 0
            i = aa
            while i != bb:
                d += previousCost[i]
                i -= 1
                if i < 0: i = 25
            res += min(c, d)
        return res",1460819487
Lego Haryanto,turuthok,292,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i in range(10, -1, -1):
            if n < i: return i % 2 != 0
            n -= i
        return True",1460800241
Lego Haryanto,turuthok,292,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        res = 0
        for i in range(n):
            res += fruits[i][i]
            fruits[i][i] = 0

        cache = {}
        def go(i, j, d, out):
            if i == n-1 and j == n-1: return 0
            if (i, j) in cache: return cache[(i, j)]

            res = 0
            for dy, dx in d:
                ii = i + dy; jj = j + dx
                if out(ii, jj): continue
                if ii < 0 or ii >= n or jj < 0 or jj >= n: continue
                res = max(res, go(ii, jj, d, out))
            res += fruits[i][j]
            cache[(i, j)] = res
            return res
            
        res += go(n-1, 0, [(-1, 1), (0, 1), (1, 1)], lambda i, j: i < j)
        res += go(0, n-1, [(1, -1), (1, 0), (1, 1)], lambda i, j: j < i)
        return res",1460881012
Harshit Agarwal,is_Harshit,293,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans=0
        self.t1=[0]
        c=0
        for i in nextCost:
            c+=i
            self.t1.append(c)
        self.s1=[]
        c=0
        for i in previousCost:
            c+=i
            self.s1.append(c)
        # print(self.t1)
        # print(self.s1)
        def f(a,b):
            if a==b:
                return 0
            c1=0
            c2=0
            
            a1=ord(a)-97
            b1=ord(b)-97
            a2=ord(a)-97
            b2=ord(b)-97

            if a1<b1:
                c1=self.t1[b1]-self.t1[a1]
            else:
                c1=self.t1[-1]-self.t1[a1]
                c1+=self.t1[b1]

            # print(a2,b2)
            if a2>b2:
                c2=self.s1[a2]-self.s1[b2]
            else:
                c2=self.s1[a2]
                c2+=self.s1[-1]-self.s1[b2]
            # print(a,b,""=="",c1,c2)
            return min(c1,c2)
                
        for i in range(len(s)):
            ans+=f(s[i],t[i])
        return ans",1460841595
Harshit Agarwal,is_Harshit,293,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur=10
        stat=False
        while n>=cur:
            n-=cur
            cur-=1
            stat=not stat
        return stat",1460796823
Harshit Agarwal,is_Harshit,293,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        p1=0
        for i in range(len(fruits)):
            p1+=fruits[i][i]

        self.mem={}

        def pp2(i,j):
            if i>=0 and i<len(fruits) and j<len(fruits) and j>=0 and j>i:
                if i==len(fruits) and i==j:
                    return 0
                if (i,j) in self.mem:
                    return self.mem[(i,j)]
                self.mem[(i,j)]=fruits[i][j]+max(pp2(i+1,j),pp2(i+1,j-1),pp2(i+1,j+1))
                return self.mem[(i,j)]
            else:
                return 0

        self.mem1={}

        def pp3(i,j):
            if i>=0 and i<len(fruits) and j<len(fruits) and j>=0 and i>j:
                if i==len(fruits)-1 and i==j:
                    return 0
                if (i,j) in self.mem1:
                    return self.mem1[(i,j)]
                self.mem1[(i,j)]=fruits[i][j]+max(pp3(i-1,j+1),pp3(i,j+1),pp3(i+1,j+1))
                return self.mem1[(i,j)]
            else:
                return 0
                
        p2=pp2(0,len(fruits)-1)
        p3=pp3(len(fruits)-1,0)
        # print(self.mem)
        # print(self.mem1)
        # print(p1)
        # print(p2)
        # print(p3)
        return p1+p2+p3",1460881223
Aashrith,ash_0003,295,3591,cpp,"class Solution {
public:
    #define ll long long
    ll getMin(char s, char t, vector<int>& n, vector<int>& p) {
        ll a=0;
        char ss=s, tt=t;
        while(ss != tt){
            a += n[ss-'a'];
            if(ss == 'z'){
                ss = 'a';
            }
            else{
                ss++;
            }
        }
        
        ll b=0;
        while(s != t){
            b += p[s-'a'];
            if(s == 'a'){
                s = 'z';
            }
            else{
                s--;
            }
        }
        return min(a, b);
    }
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        ll res=0;
        for(int i=0; i<s.size(); i++){
            res += getMin(s[i], t[i], n, p);
        }
        return res;
        
    }
};",1460887342
Aashrith,ash_0003,295,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int val=10, turn=0;
        while(n>=0){
            if(n<val){
                return turn;
            }
            turn = 1-turn;
            n-=val--;
        }
        return turn;
    }
};",1460887505
Aashrith,ash_0003,295,3648,cpp,"class Solution {
public:
    int getTopRight(vector<vector<int>>& g, int i, int j, vector<vector<int>> &dp){
        if(i > j || i == g.size() || j == g[0].size() || i<0 || j<0){
            return 0;
        }
        
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        
        int a = getTopRight(g, i+1, j-1, dp);
        int b = getTopRight(g, i+1, j, dp);
        int c = getTopRight(g, i+1, j+1, dp);
        
        return dp[i][j] = g[i][j] + max({a, b, c});
    }
    
    int getBottomLeft(vector<vector<int>>& g, int i, int j, vector<vector<int>> &dp){
        if(i < j || i == g.size() || j == g[0].size() || i<0 || j<0){
            return 0;
        }
        
        if(dp[i][j] != -1){
            return dp[i][j];
        }
        
        int a = getBottomLeft(g, i-1, j+1, dp);
        int b = getBottomLeft(g, i, j+1, dp);
        int c = getBottomLeft(g, i+1, j+1, dp);
        
        return dp[i][j] = g[i][j] + max({a, b, c});
    }
    
    int maxCollectedFruits(vector<vector<int>>& g) {
        int m = g.size(), n = g[0].size();
        vector<vector<int>> dp(m, vector<int>(n, -1));
        int res=0;
        for(int i=0; i<n; i++){
            res += g[i][i];
            g[i][i] = 0;
        }
        
        res += getTopRight(g, 0, n-1, dp);
        
        vector<vector<int>> dp1(m, vector<int>(n, -1));
        res += getBottomLeft(g, n-1, 0, dp1);
        
        return res;
    }
};",1460887054
kdarvadia,kdarvadia,298,3591,cpp,"class Solution {
public:
    long long cost [26] [26];

    void update_cost(vector<int>& nextCost, vector<int>& prevCost){
        for(int i=0; i<26; i++) for(int j=0; j<26; j++){
            int k=i;
            long long ans = 0;
            while(k != j){
                ans += nextCost[k];
                k = (k+1)%26;
            }

            cost[i][j] = ans;

            k=i;
            ans = 0;
            while(k != j){
                ans += prevCost[k];
                k = (k-1+26)%26;
            }

            cost[i][j] = min(cost[i][j], ans);
        }
    }

    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        update_cost(nextCost, previousCost);

        long long ans = 0;
        for(int i=0; i<s.size(); i++){
            ans = ans + cost[s[i]-'a'][t[i]-'a'];
        }
        return ans;
    }
};",1460827225
kdarvadia,kdarvadia,298,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        int x = 10;
        while(true){
            n = n-x;
            if(n < 0) return x%2;
            x--;
        }
        
    }
};",1460810627
kdarvadia,kdarvadia,298,3648,cpp,"class Solution {
public:

    int n;

    bool isval(int i, int j){
        if(i >= n) return false;
        if(j >= n) return false;
        if(i < 0) return false;
        if(j < 0) return false;
        return true;
    }

    int get_max(vector<vector<int>>& fruits){
        int xin = 0;
        int yin = n-1;

        vector<int> v1(n, -1);
        vector<vector<int>> dp(n, v1);
        
        dp[xin][yin] = fruits[xin][yin];

        for(int i=1; i<n; i++){
            for(int j=0; j<n; j++){
                if(i == j) continue;
                for(int k=j-1; k<=j+1; k++){
                    if(isval(i-1, k)) if(dp[i-1][k] != -1){
                        dp[i][j] = max(dp[i][j], dp[i-1][k]+fruits[i][j]);
                        //cout << i << "" "" << j << "" "" << k << "" "" << dp[i][j] << "" "" << dp[i-1][k] << endl;
                    }
                }
            }
        }

        return dp[n-2][n-1];
    }

    int get_max2(vector<vector<int>>& fruits){
        int xin = n-1;
        int yin = 0;

        vector<int> v1(n, -1);
        vector<vector<int>> dp(n, v1);
        
        dp[xin][yin] = fruits[xin][yin];

        for(int i=1; i<n; i++){
            for(int j=0; j<n; j++){
                if(i == j) continue;
                for(int k=j-1; k<=j+1; k++){
                    if(isval(i-1, k)) if(dp[k][i-1] != -1){
                        dp[j][i] = max(dp[j][i], dp[k][i-1]+fruits[j][i]);
                        //cout << i << "" "" << j << "" "" << k << "" "" << dp[i][j] << "" "" << dp[i-1][k] << endl;
                    }
                }
            }
        }

        return dp[n-1][n-2];
    }


    int maxCollectedFruits(vector<vector<int>>& fruits) {
        this->n = fruits.size();
        
        int ans = 0;
        ans = ans + get_max(fruits);
        //cout << ans << endl;

        //ans = 0;
        ans = ans + get_max2(fruits);
        //cout << ans << endl;
        
        //ans = 0;
        for(int i=0; i<n; i++) ans = ans + fruits[i][i];
        //cout << ans << endl;

        return ans;   
    }
};",1460882167
BusioStrusio,TFNESYtvxZ,299,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        // Calculate distance for each letter in s and t
        // Calculate whether it is better to go back or to go forward - choose lesser cost.
        // return cost;

        var cost = 0L;
        for (int i = 0; i < s.length(); i++) {
            var sChar = s.charAt(i) - 'a';
            var tChar = t.charAt(i) - 'a';
            if (sChar == tChar) {
                continue;
            } else if (sChar < tChar) {
                long next = 0;
                for (int j = sChar; j < tChar; j++) {
                    next += nextCost[j];
                }
                long previous = 0;
                for (int j = sChar + 26; j > tChar; j--) {
                    previous += previousCost[j % 26];
                }
                cost += Math.min(next, previous);
            } else {
                long next = 0;
                for (int j = sChar; j < tChar + 26; j++) {
                    next += nextCost[j % 26];
                }
                long previous = 0;
                for (int j = sChar; j > tChar; j--) {
                    previous += previousCost[j];
                }
                cost += Math.min(next, previous);
            }
        }
        return cost;
    }
}",1460822761
BusioStrusio,TFNESYtvxZ,299,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        for (int i = 10; i > 0; i--) {
            if (n - i > -1) {
                n -= i;
            } else {
                if (i % 2 == 0) {
                    return false;
                } else {
                    return true;
                }
            }
        }
        
        return true;
    }
}",1460800234
BusioStrusio,TFNESYtvxZ,299,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        // (0, 0) child goes on diagonal
        // (n - 1, 0) and (0, n - 1) use dp1

        var n = fruits.length;
        var max = 0;

        if (n == 1) {
            return fruits[0][0];
        } else if (n == 2) {
            return fruits[0][0] + fruits[1][0] + fruits[0][1] + fruits[1][1];
        }

        // First Child
        for (int i = 0; i < n; i++) {
            max += fruits[i][i];
        }
        // System.out.println(max);

        var dp1 = new int[n][n + 1];
        dp1[0][n - 1] = fruits[0][n - 1];
        for (int i = 1; i < n / 2; i++) {
            for (int j = 0; j <= i; j++) {
                dp1[i][n - j - 1] = Math.max(dp1[i - 1][n - j - 1], dp1[i - 1][n - j]);
                dp1[i][n - j - 1] = Math.max(dp1[i][n - j - 1], dp1[i - 1][n - j - 2]);
                dp1[i][n - j - 1] += fruits[i][n - j - 1];
                // System.out.printf(""%s, %s - %s%n"", i, n - j - 1, dp1[i][n - j - 1]);
            }
        }
        // System.out.println(""---------"");
        for (int i = (n - 1) / 2; i > -1; i--) {
            for (int j = 0; j <= i; j++) {
                if (j == i) {
                    continue;
                }
                dp1[n - i - 1][n - j - 1] = Math.max(dp1[n - i - 2][n - j - 1], dp1[n - i - 2][n - j]);
                dp1[n - i - 1][n - j - 1] = Math.max(dp1[n - i - 1][n - j - 1], dp1[n - i - 2][n - j - 2]);
                dp1[n - i - 1][n - j - 1] += fruits[n - i - 1][n - j - 1];
                // System.out.printf(""%s, %s - %s%n"", n - i - 1, n - j - 1, dp1[n - i - 1][n - j - 1]);
            }
        }
        max += dp1[n - 2][n - 1];
        // System.out.println(max);


        var dp2 = new int[n + 1][n];
        dp2[n - 1][0] = fruits[n - 1][0];
        for (int i = 1; i < n / 2; i++) {
            for (int j = 0; j <= i; j++) {
                dp2[n - j - 1][i] = Math.max(dp2[n - j - 1][i - 1], dp2[n - j][i - 1]);
                dp2[n - j - 1][i] = Math.max(dp2[n - j - 1][i], dp2[n - j - 2][i - 1]);
                dp2[n - j - 1][i] += fruits[n - j - 1][i];
            }
        }
        for (int i = n / 2; i > -1; i--) {
            for (int j = 0; j <= i; j++) {
                if (j == i) {
                    continue;
                }
                dp2[n - j - 1][n - i - 1] = Math.max(dp2[n - j - 1][n - i - 2], dp2[n - j][n - i - 2]);
                dp2[n - j - 1][n - i - 1] = Math.max(dp2[n - j - 1][n - i - 1], dp2[n - j - 2][n - i - 2]);
                dp2[n - j - 1][n - i - 1] += fruits[n - j - 1][n - i - 1];
            }
        }
        max += dp2[n - 1][n - 2];

        return max;
    }
}",1460888106
Yuriy Kaminskiy,yumkam,300,3591,cpp,"template <typename Weight = unsigned, typename Size = unsigned, Weight inf = std::numeric_limits<Weight>::max()/2>
void floyd_warshall(std::vector<std::vector<Weight>> &dist) {
    const auto n = dist.size();
    for (Size k = 0; k < n; ++k) {
        auto &dist_k = dist[k];
        // assert(dist_k.size() == n);
        for (Size i = 0; i < n; ++i) {
            auto &dist_i = dist[i];
            auto dist_ik = dist_i[k];
            if (dist_ik == inf) continue;
            for (Size j = 0; j < n; ++j) {
                auto dist_kj = dist_k[j];
                if (dist_kj == inf) continue;
                dist_i[j] = std::min(dist_i[j], dist_ik + dist_kj);
            }
        }
    }
}
class Solution {
public:
    long long shiftDistance(string_view s, string_view t, vector<int>& nextCost, vector<int>& previousCost) {
        typedef long long ll;
        constexpr auto inf = LONG_LONG_MAX/2;
        vector<vector<ll>> cost(26, vector<ll>(26, inf));
        for (unsigned i = 0, prev = 25, next = 1; i < 26; ++i) {
            cost[i][i] = 0;
            cost[i][next] = nextCost[i];
            cost[i][prev] = previousCost[i];
            if (++next == 26) next = 0;
            if (++prev == 26) prev = 0;
        }
        floyd_warshall<ll>(cost);
        ll ret = 0;
        const unsigned n = s.size();
        for (unsigned i = 0; i < n; ++i)
            ret += cost[s[i] - 'a'][t[i] - 'a'];
        return ret;
    }
};",1460836609
Yuriy Kaminskiy,yumkam,300,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = true;
        int k = 10;
        for (;; alice = !alice, --k) {
            if (k < 0)
                return !alice;
            if (n >= k)
                n -= k;
            else
                return !alice;
        }
    }
};",1460802872
Yuriy Kaminskiy,yumkam,300,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        // first child [0][0] can only reach destination if he walk by +1, +1;
        // second child [0][n - 1] can only reach destination if he walks equal number of times diagonal left/right and some down
        // and remain in upper/right triangle;
        // third child [n-1][0] can only reach destination if he walks equal number of times diagonal up/down and some right
        // and remains in bottom/left triangle;
        // so, assume first takes diagonal, and independently solve 2nd and 3rd with 2d dp
        int ret = 0;
        const unsigned n = fruits.size();
        for (unsigned i = 0; i < n; ++i) {
            ret += exchange(fruits[i][i], 0);
        }
        constexpr auto inf = INT_MIN;
        {
            vector<int> dp(n + 1, inf);
            dp[n - 1] = fruits[0][n - 1];
            for (unsigned i = 1; i < n; ++i) {
                auto dpjzz = dp[i];
                auto dpjm1 = dp[i - 1];
                for (unsigned j = i; j < n; ++j) {
                    auto dpjp1 = dp[j + 1];
                    auto f = fruits[i][j];
                    auto dpj = max(dpjzz, max(dpjm1, dpjp1));
                    if (dpj != inf)
                        dpj += f;
                    dp[j] = dpj;
                    dpjm1 = dpjzz;
                    dpjzz = dpjp1;
                }
            }
            ret += dp[n - 1];
        }
        {
            vector<int> dp(n + 1, inf);
            dp[n - 1] = fruits[n - 1][0];
            for (unsigned i = 1; i < n; ++i) {
                auto dpjzz = dp[i];
                auto dpjm1 = dp[i - 1];
                for (unsigned j = n - i - 1; j < n; ++j) {
                    auto dpjp1 = dp[j + 1];
                    auto f = fruits[j][i];
                    auto dpj = max(dpjzz, max(dpjm1, dpjp1));
                    if (dpj != inf)
                        dpj += f;
                    dp[j] = dpj;
                    dpjm1 = dpjzz;
                    dpjzz = dpjp1;
                }
            }
            ret += dp[n - 1];
        }
        return ret;
    }
};",1460888143
resotto,resotto,302,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        var ans = 0L;
        for (int i = 0; i < n; i++) {
            int cur = s.charAt(i)-'a', tar = t.charAt(i)-'a';
            if (cur == tar) {
                continue;
            }
            long forward = 0L, backward = 0L;
            int f = cur, b = cur;
            while (f != tar) {
                forward += nextCost[f];
                f = (f + 1) % 26;
            }
            while (b != tar) {
                backward += previousCost[b];
                b = (b - 1 + 26) % 26;
            }
            ans += Math.min(forward, backward);
        }
        return ans;
    }
}",1460809508
resotto,resotto,302,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int j = 0;
        for (int i = 10; 0 < n; i--, j++) {
        // for (int i = 10, j = 0; 0 < n; i--, j++) {
            if (n - i < 0) {
                break;
            }
            n -= i;
        }
        return j % 2 == 0 ? false : true;
    }
}",1460800543
resotto,resotto,302,3648,java,"class Solution {
    private Integer[][] down, right;
    private int n;
    public int maxCollectedFruits(int[][] fruits) {
        int ans = 0;
        n = fruits.length;
        for (int i = 0, j = 0; i < n; i++, j++) {
            ans += fruits[i][j];
        }
        down = new Integer[n][n];
        right = new Integer[n][n];
        return ans + moveDown(0, n-1, fruits) + moveRight(n-1, 0, fruits);
    }
    private int moveDown(int r, int c, int[][] f) {
        if (r == n-1) {
            return c == n-1 ? 0 : -1 * (int) (1e9);
        } else if (down[r][c] == null) {
            int ans = 0, add = r == c ? 0 : f[r][c];
            ans = add + moveDown(r+1, c, f);
            if (0 <= c-1) {
                ans = Math.max(ans, add + moveDown(r+1, c-1, f));
            }
            if (c+1 < n) {
                ans = Math.max(ans, add + moveDown(r+1, c+1, f));
            }
            down[r][c] = ans;
        }
        return down[r][c];
    }
    private int moveRight(int r, int c, int[][] f) {
        if (c == n-1) {
            return r == n-1 ? 0 : -1 * (int) (1e9);
        } else if (right[r][c] == null) {
            int ans = 0, add = r == c ? 0 : f[r][c];
            ans = add + moveRight(r, c+1, f);
            if (0 <= r-1) {
                ans = Math.max(ans, add + moveRight(r-1, c+1, f));
            }
            if (r+1 < n) {
                ans = Math.max(ans, add + moveRight(r+1, c+1, f));
            }
            right[r][c] = ans;
        }
        return right[r][c];
    }

}",1460882531
Jatin Sood,jsood99,303,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {

        long long res = 0;
        int n = s.size();

        for(int i = 0; i < n; ++i) {
            int c = s[i];
            //forward
            long long int f = 0;
            while(c != t[i]) {
                f += nextCost[c - 'a'];
                if(c == 'z') c = 'a';
                else c = c+1;
            }

            //backward
            c = s[i];
            long long int b = 0;
            while(c != t[i]) {
                b += previousCost[c - 'a'];
                if(c == 'a') c = 'z';
                else c = c-1;
            }

            res += min(f, b);
        }

        return res;
        
    }
};",1460824899
Jatin Sood,jsood99,303,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        int t = 10;
        bool f = false;
        while(n >= t) {
            n -= t;
            t--;
            f  = !f;
        }
        return f;
        
    }
};",1460799412
Jatin Sood,jsood99,303,3648,cpp,"class Solution {
public:

    int solve1(vector<vector<int>>& fruits, int i, int j, vector<vector<int>>& dp1) {
        int n = fruits.size();
        if(i < j || i >= n || j >= n) return INT_MIN;
        if(i == n-1 && j == n-1) return 0;
        if(dp1[i][j] == INT_MIN) {
            dp1[i][j] = fruits[i][j] + max(solve1(fruits, i-1, j+1, dp1), max(solve1(fruits, i, j+1, dp1), solve1(fruits, i+1, j+1, dp1)));
        }
        return dp1[i][j];
    }

    int solve2(vector<vector<int>>& fruits, int i, int j, vector<vector<int>>& dp2) {
        int n = fruits.size();
        if(i > j || i >= n || j >= n) return INT_MIN;
        if(i == n-1 && j == n-1) return 0;
        if(dp2[i][j] == INT_MIN) {
            dp2[i][j] = fruits[i][j] + max(solve2(fruits, i+1, j-1, dp2), max(solve2(fruits, i+1, j, dp2), solve2(fruits, i+1, j+1, dp2)));
        }
        return dp2[i][j];
    }

    int maxCollectedFruits(vector<vector<int>>& fruits) {

        int n = fruits.size();
        int res = 0;

        for(int i = 0; i < n; ++i) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }

        vector<vector<int>> dp1(n, vector<int>(n, INT_MIN));
        vector<vector<int>> dp2(n, vector<int>(n, INT_MIN));
        return res + solve1(fruits, n-1, 0, dp1) + solve2(fruits, 0, n-1, dp2);
        
    }
};",1460882638
Anh Ti Trn,anh_tai,305,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> cost1(26, vector<long long>(26));
        vector<vector<long long>> cost2(26, vector<long long>(26));
        for (int c1 = 0; c1 < 26; c1++){
            cost1[c1][c1] = 0; 
            for (int i = 1; i < 26; i++){
                cost1[c1][(c1 + i) % 26] = cost1[c1][(c1 + i - 1) % 26] + nextCost[(c1 + i - 1) % 26];
            }
        }

        for (int c1 = 0; c1 < 26; c1++){
            cost2[c1][c1] = 0; 
            for (int i = 1; i < 26; i++){
                cost2[c1][(c1 - i + 26) % 26] = cost2[c1][(c1 - i + 27) % 26] + previousCost[(c1 - i + 27) % 26];
            }
        }

        long long ans = 0;
        for (int i = 0; i < (int)s.size(); i++){
            ans += std::min(cost1[s[i] - 'a'][t[i] - 'a'], cost2[s[i] - 'a'][t[i] - 'a']);
        }

        return ans; 
    }
};",1460884105
Anh Ti Trn,anh_tai,305,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 10;
        while (n >= turn){
            n -= turn; turn--; 
        }
        return turn % 2 == 1;
    }
};",1460876675
Anh Ti Trn,anh_tai,305,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int r = 0; r < n; r++){
            ans += fruits[r][r];
            fruits[r][r] = 0;
        }

        const int oo = 1e9; 

        auto ok = [&](int r, int c) -> bool {
          return r >= 0 && c >= 0 && r < n && c < n;   
        };

        vector<vector<int>> f0(n, vector<int>(n, -oo)); // (n - 1, 0) -> (n - 1, n - 1)
        f0[n - 1][0] = fruits[n - 1][0];
        for (int c = 1; c <= n - 1; c++){
            for (int r = 0; r < n; r++){
                for (int d = -1; d <= 1; d++){
                    if (ok(r + d, c - 1)){
                        f0[r][c] = std::max(f0[r][c], f0[r + d][c - 1] + fruits[r][c]);
                    }
                }
            }
        }
        
        vector<vector<int>> f1(n, vector<int>(n, -oo)); // (0, n - 1) -> (n - 1, n - 1)
        f1[0][n - 1] = fruits[0][n - 1];
        for (int r = 1; r <= n - 1; r++){
            for (int c = 0; c < n; c++){
                for (int d = -1; d <= 1; d++){
                    if (ok(r - 1, c + d)){
                        f1[r][c] = std::max(f1[r][c], f1[r - 1][c + d] + fruits[r][c]);
                    }
                }
            }
        }
        
        return ans + f0[n - 1][n - 1] + f1[n - 1][n - 1]; 
    }
};",1460874518
meonceagain,meonceagain,306,3591,cpp,"class Solution {
public:
    long long shiftDistance(const string& s, const string& t, const vector<int>& nextCost, const vector<int>& previousCost) {
        long long ans = 0;
        unordered_map<int, long long> cache;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] != t[i]) {
                const int sidx = s[i] - 'a';
                const int tidx = t[i] - 'a';
                const int idx = (sidx << 8) | tidx;
                auto it = cache.find(idx);
                if (cache.end() == it) {
                    long long dist1 = 0;
                    int a = sidx;
                    while (a != tidx) {
                        dist1 += nextCost[a];
                        if (25 == a) a = 0; else ++a;
                    }
                    long long dist2 = 0;
                    a = sidx;
                    while (a != tidx) {
                        dist2 += previousCost[a];
                        if (0 == a) a = 25; else --a;
                    }
                    long long dist = min(dist1, dist2);
                    ans += dist;
                    cache[idx] = dist;
                    //cout << s[i] << "" "" << t[i] << "" "" << dist1 << "" "" << dist2 << "" "" << dist << endl;
                } else
                    ans += it->second;
            }
        }

        return ans;
    }
};",1460836086
meonceagain,meonceagain,306,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int a = 10;
        bool AliceWins = false;
        while (n >= a) {
            n -= a;
            --a;
            AliceWins = !AliceWins;
        }
        return AliceWins;
    }
};",1460808563
meonceagain,meonceagain,306,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        const int n = fruits.size();
        for (int i = 0; i < fruits.size(); ++i) { ans += fruits[i][i]; fruits[i][i] = 0; }
        const int offset = (n-1) / 2;

        for (int c = n-3; c >= 0; --c) {
            for (int r = c+1; r < n; ++r) {
                int cc = c + 1;
                int m = 0;
                for (int ro = -1; ro < 2; ++ro) {
                    int rr = r + ro;
                    if (rr <= cc || rr >= n) continue;
                    //cout << rr << "" "" << cc << endl;
                    m = max(m, fruits[rr][cc]);
                }
                fruits[r][c] += m;
            }
        }

        for (int r = n-3; r >= 0; --r) {
            for (int c = r+1; c < n; ++c) {
                int rr = r + 1;
                int m = 0;
                for (int co = -1; co < 2; ++co) {
                    int cc = c + co;
                    if (cc <= rr || cc >= n) continue;
                    //cout << rr << "" "" << cc << endl;
                    m = max(m, fruits[rr][cc]);
                }
                fruits[r][c] += m;
            }
        }

        /*for (int r = 0; r < n; ++r) {
            for (int c = 0; c < n; ++c) {
                cout << fruits[r][c] << "" "";
            }
            cout << endl;
        }*/

        ans += fruits[n-1][0] + fruits[0][n-1];

        return ans;
    }
};",1460884194
Akshit Khare,Akshit25,308,3591,cpp,"#define ll long long

ll minDist(char a, char b, vector<int>& nextCost, vector<int>& previousCost){
    char c=a;
    ll ans1=0;
    while(c!=b){
        int idx = c-'a';
        ans1+=nextCost[idx];
        c = (c=='z')?'a':(c+1);
    }

    c=a;
    ll ans2=0;
    while(c!=b){
        int idx = c-'a';
        ans2+=previousCost[idx];
        c = (c=='a')?'z':(c-1);
    }

    return min(ans1, ans2);
}

class Solution {
    
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll ans=0;
        int n=s.length();
        for(int i=0;i<n;i++){
            ans+=minDist(s[i], t[i], nextCost, previousCost);
        }
        return ans;
    }
};",1460817561
Akshit Khare,Akshit25,308,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ans = false;
        int x = 10;
        while(true){
            if(n<x){
                return ans;
            }
            n-=x;
            x--;
            ans = !(ans);
        }
        return true;
    }
};",1460798554
Akshit Khare,Akshit25,308,3648,cpp,"#define ll long long

class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n=fruits.size();
        ll ans=0;
        for(int i=0;i<n;i++){
            ans+=fruits[i][i];
            fruits[i][i]=0;
        }

        vector<vector<ll>> dp(n, vector<ll> (n, -1));
        dp[n-1][n-1]=0;
        for(int j=n-1;j>=0;j--){
            for(int i=0;i<n;i++){
                if(i>0 && j<n-1 && dp[i-1][j+1]!=-1){
                    dp[i][j]=fruits[i][j]+dp[i-1][j+1];
                }
                if(i<n-1 && j<n-1 && dp[i+1][j+1]!=-1){
                    dp[i][j]=max(dp[i][j], fruits[i][j]+dp[i+1][j+1]);
                }
                if(j<n-1 && dp[i][j+1]!=-1){
                    dp[i][j]=max(dp[i][j], fruits[i][j]+dp[i][j+1]);
                }
            }
        }

        ans+=dp[n-1][0];
        int i=n-1, j=0;
        while(j!=n-1){
            fruits[i][j]=0;
            int mxi=i;
            if(i>0 && dp[i-1][j+1]>dp[mxi][j+1]){
                mxi=i-1;
            }
            if(i<n-1 && dp[i+1][j+1]>dp[mxi][j+1]){
                mxi=i+1;
            }
            j++;
        }

        for (auto& row : dp) {
            for (auto& val : row) {
                val = -1;
            }
        }
        dp[n-1][n-1]=0;
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<n;j++){
                if(i<n-1 && j>0 && dp[i+1][j-1]!=-1){
                    dp[i][j]=fruits[i][j]+dp[i+1][j-1];
                }
                if(i<n-1 && j<n-1 && dp[i+1][j+1]!=-1){
                    dp[i][j]=max(dp[i][j], fruits[i][j]+dp[i+1][j+1]);
                }
                if(i<n-1 && dp[i+1][j]!=-1){
                    dp[i][j]=max(dp[i][j], fruits[i][j]+dp[i+1][j]);
                }
            }
        }
        ans+=dp[0][n-1];
        return ans;
        
        
    }
};",1460890103
soilingrogue,soilingrogue,309,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nextCost2 = nextCost + nextCost
        cumNextCost = [0] * 52
        for i in range(1, len(nextCost2)):
            cumNextCost[i] = nextCost2[i - 1] + cumNextCost[i - 1]

        prevCost2 = previousCost + previousCost
        cumPrevCost = [0] * 52
        for i in range(1, len(prevCost2)):
            cumPrevCost[52 - i - 1] = prevCost2[52 - i] + cumPrevCost[52 - i]

        cost = 0
        for curr, target in zip(s, t):
            if curr == target:
                continue
            if curr > target:
                forwardCost = cumNextCost[ord(target) - ord('a') + 26] - cumNextCost[ord(curr) - ord('a')]
                backwardCost = cumPrevCost[ord(target) - ord('a') + 26] - cumPrevCost[ord(curr) - ord('a') + 26]
            else:
                forwardCost = cumNextCost[ord(target) - ord('a')] - cumNextCost[ord(curr) - ord('a')]
                backwardCost = cumPrevCost[ord(target) - ord('a')] - cumPrevCost[ord(curr) - ord('a') + 26]
            # print(forwardCost, backwardCost)
            cost += min(forwardCost, backwardCost)

        return cost",1460835504
soilingrogue,soilingrogue,309,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False

        def helper(stones, to_remove):
            if stones < to_remove:
                return False

            return not helper(stones - to_remove, to_remove - 1)

        return helper(n, 10)",1460797977
soilingrogue,soilingrogue,309,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        maxFruits = 0
        n = len(fruits)
        for i in range(n):
            maxFruits += fruits[i][i]

        @functools.cache
        def top_right(i, j):
            if i == n or j == n or (i == j and i != n - 1) or i > j:
                return float(""-inf"")

            if i == j:
                return 0

            return fruits[i][j] + max(top_right(i + 1, j - 1), top_right(i + 1, j), top_right(i + 1, j + 1))

        @functools.cache
        def bottom_left(i, j):
            if i == n or j == n or (i == j and i != n - 1) or j > i:
                return float(""-inf"")

            if i == j:
                return 0

            return fruits[i][j] + max(bottom_left(i - 1, j + 1), bottom_left(i, j + 1), bottom_left(i + 1, j + 1))
        
        return maxFruits + top_right(0, n - 1) + bottom_left(n - 1, 0)",1460884368
nipunjain099,nipunjain099,310,3591,cpp,"class Solution {

long long cal_cost( vector<int>& nextCost, vector<int>& previousCost, int start, int end){
    if(start == end) return 0;
    long long cost1 = 0;
    int st = start;
    while(st != end){
        cost1+= (long long)nextCost[st];
        st++;
        if(st==26) st=0;
    }

    long long cost2 = 0;
    st = start;
    while(st != end){
        cost2+= (long long)previousCost[st];
        st--;
        if(st==-1) st=25;
    }
    // cout<< start<<"" ""<<end<<"" ""<< cost1<<"" ""<<cost2<<endl;
        if(cost1<cost2) return cost1;
    return cost2;
}

public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int len = s.size();
        // cout<<len;
        long long cost=0;
        for(int it=0;it<len;it++){
            cost+= cal_cost(nextCost, previousCost, s[it]-'a', t[it]-'a');
        }
        return cost;
    }
};",1460822544
nipunjain099,nipunjain099,310,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int ans=0;
        int ct=10;
        while(n>=0){
            n-=ct;
            ct--;
            ans++;
        }
        return (ans%2==0);
    }
};",1460799438
nipunjain099,nipunjain099,310,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        vector<vector<int>> dp(n, vector<int>(n,0));
        dp[n-1][0] = fruits[n-1][0];
        dp[0][n-1] = fruits[0][n-1];
        int ans=0;
        for(int it=1;it<n-1;it++){
            for(int it2=n-1;it2>= max(it+1, n-1-it); it2--){
                dp[it2][it] =  max(dp[it2][it-1],dp[it2-1][it-1]);
                if(it2!=(n-1)){
                    dp[it2][it] = max(dp[it2][it],dp[it2+1][it-1]);
                }
                dp[it2][it]+= fruits[it2][it];
            }
        }
        for(int it=1;it<n-1;it++){
            for(int it2=n-1;it2>= max(it+1, n-1-it); it2--){
                dp[it][it2] =max(dp[it-1][it2],dp[it-1][it2-1]);
                if(it2!=(n-1)){
                    dp[it][it2] = max(dp[it][it2],dp[it-1][it2+1]);
                }
                
                dp[it][it2]+= fruits[it][it2];
                // cout<<it<<"" ""<<it2<<"" ""<<dp[it][it2]<<endl;
            }
        }
        for(int it=0;it<n;it++){
            ans+= fruits[it][it];
        }
        // cout<<ans<<"" ""<<dp[n-1][n-2] <<"" ""<<dp[n-2][n-1]<<endl;
        return ans+dp[n-1][n-2] + dp[n-2][n-1];
    }
};",1460884912
dapu81000,dapu81000,311,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long sum[2][27] = {};
        for(int i=0;i<26;i++){
            sum[0][i+1] = sum[0][i] + nextCost[i];
            sum[1][i+1] = sum[1][i] + previousCost[i];
        }
        long long ans = 0;
        for(int i=0;i<s.size();i++){
            int id1 = s[i]-'a', id2 = t[i]-'a';
            if(id1==id2) continue;
            long long cost1 , cost2;
            if(id1<id2){
                cost1 = sum[0][id2] - sum[0][id1];
                cost2 = sum[1][26] - sum[1][id2+1] + sum[1][id1+1];
            }else{
                cost2 = sum[1][id1+1] - sum[1][id2+1];
                cost1 = sum[0][26] - sum[0][id1] + sum[0][id2];
            }
            ans += min(cost1, cost2);
        }
        return ans;
    }
};",1460833690
dapu81000,dapu81000,311,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ok = false;
        int cur = 10;
        while(n>=cur){
            n-=cur;
            ok = !ok;
            cur--;
        }
        return ok;
    }
};",1460796492
dapu81000,dapu81000,311,3648,cpp,"class Solution {
public:
    int dp[1001][1001] = {};
    int dfs1(int x,int y, int n, vector<vector<int>>& fruits){
        if(x<0 || x>=n || y<0 || y>=n) return -1e9;
        if(x==y || x<y) return -1e9;
        if(dp[x][y]!=-1) return dp[x][y];
        int res = fruits[x][y];
        int r1 = dfs1(x-1,y-1,n,fruits), r2 = dfs1(x,y-1,n,fruits), r3 = dfs1(x+1,y-1,n,fruits);
        res += max({r1,r2,r3});
        return dp[x][y] = res;
    }
    int dfs2(int x,int y, int n, vector<vector<int>>& fruits){
        if(x<0 || x>=n || y<0 || y>=n) return -1e9;
        if(x==y || x>y) return -1e9;
        if(dp[x][y]!=-1) return dp[x][y];
        int res = fruits[x][y];
        int r1 = dfs2(x-1,y-1,n,fruits), r2 = dfs2(x-1,y,n,fruits), r3 = dfs2(x-1,y+1,n,fruits);
        res += max({r1,r2,r3});
        return dp[x][y] = res;
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0, n = fruits.size();
        memset(dp, -1,sizeof dp);
        for(int i=0;i<n;i++) ans += fruits[i][i];

        dp[n-1][0] = fruits[n-1][0];
        dp[0][n-1] = fruits[0][n-1];

        int r1 = dfs1(n-1, n-2, n, fruits);
        int r2 = dfs2(n-2, n-1, n, fruits);
        ans += r1;
        ans += r2;

        return ans;
        
    }
};",1460890724
unstablebrainiac,unstablebrainiac,316,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[][] charDistance = new long[26][26];
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                long option1 = 0, option2 = 0;
                for (int k = i; k != j; k = (k + 1) % 26) {
                    option1 += nextCost[k];
                }
                for (int k = i; k != j; k = (k + 25) % 26) {
                    option2 += previousCost[k];
                }
                charDistance[i][j] = Math.min(option1, option2);
            }
        }

        long ans = 0;
        for (int i = 0; i < s.length(); i++) {
            ans += charDistance[s.charAt(i) - 'a'][t.charAt(i) - 'a'];
        }

        return ans;
    }
}",1460829319
unstablebrainiac,unstablebrainiac,316,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        return canAliceWin(n, 10);
    }

    private boolean canAliceWin(int n, int next) {
        if (n < next) {
            return false;
        }
        return !canAliceWin(n - next, next - 1);
    }
}",1460799152
unstablebrainiac,unstablebrainiac,316,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int ans = 0;
        Integer[][] dp = new Integer[fruits.length][fruits.length];
        for (int i = 0; i < fruits.length; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
            dp[i][i] = 0;
        }
        ans += maxCollectedFruitsByTwo(fruits, 0, fruits.length - 1, dp);
        ans += maxCollectedFruitsByThree(fruits, fruits.length - 1, 0, dp);
        return ans;
    }

    private int maxCollectedFruitsByTwo(int[][] fruits, int x, int y, Integer[][] dp) {
        if (x < 0 || x >= fruits.length || y < 0 || y >= fruits.length || x - y >= 0) {
            return 0;
        }
        if (dp[x][y] != null) {
            return dp[x][y];
        }

        int option1 = maxCollectedFruitsByTwo(fruits, x + 1, y - 1, dp);
        int option2 = maxCollectedFruitsByTwo(fruits, x + 1, y, dp);
        int option3 = maxCollectedFruitsByTwo(fruits, x + 1, y + 1, dp);

        int ans = fruits[x][y] + Math.max(Math.max(option1, option2), option3);
        dp[x][y] = ans;

        return ans;
    }

    private int maxCollectedFruitsByThree(int[][] fruits, int x, int y, Integer[][] dp) {
        if (x < 0 || x >= fruits.length || y < 0 || y >= fruits.length || y - x >= 0) {
            return 0;
        }
        if (dp[x][y] != null) {
            return dp[x][y];
        }

        int option1 = maxCollectedFruitsByThree(fruits, x - 1, y + 1, dp);
        int option2 = maxCollectedFruitsByThree(fruits, x, y + 1, dp);
        int option3 = maxCollectedFruitsByThree(fruits, x + 1, y + 1, dp);

        int ans = fruits[x][y] + Math.max(Math.max(option1, option2), option3);
        dp[x][y] = ans;

        return ans;
    }
}",1460885907
Kartheek,kartheekvajrala,319,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        vector<long long> nt(27,0),pt(27,0);
        for(int i=0;i<26;i++)nt[i+1] = nt[i]+n[i];
        for(int i=0;i<26;i++)pt[i+1] = pt[i]+p[i];
        // for(int x:nt)cout << x << "" "";cout << endl;
        // for(int x:pt)cout << x << "" "";cout << endl;
        long long ans = 0;
        for(int i=0;i<s.size();i++){
            if(s[i]<t[i]){
                ans += min(nt[t[i]-'a']-nt[s[i]-'a'], pt.back()-pt[t[i]-'a'+1]+pt[s[i]-'a'+1]);
            } else if(s[i]>t[i]){
                ans += min(pt[s[i]-'a'+1]-pt[t[i]-'a'+1], nt.back()-nt[s[i]-'a']+nt[t[i]-'a']);
            }
            // cout << ans << endl;
        }
        return ans;
    }
};",1460835852
Kartheek,kartheekvajrala,319,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10;i>0;i--){
            if(n>=i){
                n -= i;
            }else{
                return i%2;
            }
        }
        return false;
    }
};",1460800690
Kartheek,kartheekvajrala,319,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& arr) {
        int n = arr.size();
        int ans = 0;
        vector<vector<int>> dp1(n+3,vector<int>(n+3,-1000));
        vector<vector<int>> dp2(n+3,vector<int>(n+3,-1000));
        for(int i=0;i<n;i++){ans += arr[i][i];arr[i][i]=0;}
        dp2[n][1] = arr[n-1][0];
        dp1[1][n] = arr[0][n-1];
        for(int i=1;i<n;i++){
            // cout << i <<  "" "" << endl;
            for(int j=0;j<=i;j++){
                dp1[i+1][n-j] = max(dp1[i][n-j],max(dp1[i][n-j+1],dp1[i][n-j-1])) + arr[i][n-1-j];
                dp2[n-j][i+1] = max(dp2[n-j][i],max(dp2[n-j+1][i],dp2[n-j-1][i])) + arr[n-1-j][i];
            }
        }
        return ans + dp1[n][n] + dp2[n][n];
    }
};",1460886712
karush1fa,karush1fa,320,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        prefixNextCost = [0] * 27
        prefixPrevCost = [0] * 27
        for i in range(1, 27):
            prefixNextCost[i] = prefixNextCost[i-1] + nextCost[i-1]
            prefixPrevCost[i] = prefixPrevCost[i-1] + previousCost[i-1]
        # print(prefixNextCost)
        # print(prefixPrevCost)
    
        ans = 0
        for i in range(len(s)):
            if s[i] == t[i]:
                continue
    
            ps = ord(s[i]) - ord('a') + 1
            pt = ord(t[i]) - ord('a') + 1
    
            if ps > pt:
                cost1 = prefixPrevCost[ps] - prefixPrevCost[pt] # from ps, keep doing previous opt
                cost2 = prefixNextCost[-1] - prefixNextCost[ps-1] + prefixNextCost[pt-1]
            else:
                # ps < pt
                cost1 = prefixNextCost[pt-1] - prefixNextCost[ps-1]
                cost2 = prefixPrevCost[ps] + prefixPrevCost[-1] - prefixPrevCost[pt]
            ans += min(cost1 ,cost2)
        return ans",1460848190
karush1fa,karush1fa,320,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        k = 10
        while n >= k:
            n -= k
            k -= 1

        # n < k
        return True if k % 2 == 1 else False",1460802626
karush1fa,karush1fa,320,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0
    
        dp = [[0] * n for _ in range(n)]
        dp[n-1][0] = fruits[n-1][0]
        for i in range(n-1):
            dp[i][0] = float('-inf')
    
        for j in range(1, n):
            dp[n-1][j] = fruits[n-1][j] + max(dp[n-1][j-1],  dp[n-2][j-1])
            for i in range(j, n-1):
                dp[i][j] = fruits[i][j] + max([dp[i-1][j-1], dp[i+1][j-1], dp[i][j-1]])
        ans += dp[-1][-1]
    
        # for child 3
        dp = [[0] * n for _ in range(n)]
        dp[0][n-1] = fruits[0][n-1]
        for j in range(n-1):
            dp[0][j] = float('-inf')
        
        for i in range(1, n):
            dp[i][n-1] = max(dp[i-1][n-1], dp[i-1][n-2]) + fruits[i][n-1]
            for j in range(i, n-1):
                dp[i][j] = fruits[i][j] + max([dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]])
        ans += dp[-1][-1]
        return ans

        ",1460892475
aminjonshermatov,aminjonshermatov,322,3591,cpp,"class Solution {
public:
  long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prv) {
    const auto n = int(s.size());
    long long ret = 0;
    for (int i = 0; i < n; ++i) {
      long long x = 0, y = 0;
      for (auto c = s[i]; c != t[i]; c = (c - 'a' + 26 + 1) % 26 + 'a') {
        x += nxt[c - 'a'];
      }
      for (auto c = s[i]; c != t[i]; c = (c - 'a' + 26 - 1) % 26 + 'a') {
        y += prv[c - 'a'];
      }
      ret += min(x, y);
    }
    return ret;
  }
};",1460876582
aminjonshermatov,aminjonshermatov,322,3625,cpp,"class Solution {
public:
  bool canAliceWin(int n) {
    for (int b = 0, x = 10; ; b ^= 1, --x) {
      if ((n -= x) < 0) {
        return b;
      }
    }
    return {};
  }
};",1460881664
aminjonshermatov,aminjonshermatov,322,3648,cpp,"class Solution {
public:
  int maxCollectedFruits(vector<vector<int>>& g) {
    const auto n = int(g.size());
    auto imax = [](int& a, const int b) -> bool {
      return a < b && (a = b, true);
    };
    auto ok = [n](int i, int j) {
      return std::clamp(i, 0, n - 1) == i && std::clamp(j, 0, n - 1) == j;
    };

    int ret = 0;
    for (int i = 0; i < n; ++i) {
      ret += g[i][i];
      g[i][i] = 0;
    }
    constexpr int kInf = std::numeric_limits<int>::max() / 3;
    {
      std::vector dp(n, std::vector(n, -kInf));
      dp[0][n - 1] = g[0][n - 1];
      for (int i = 1; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
          for (auto [di, dj] : {std::pair{-1, +1}, {-1, +0}, {-1, -1}}) {
            const auto ni = i + di;
            const auto nj = j + dj;
            if (ok(ni, nj) && imax(dp[i][j], dp[ni][nj] + g[i][j])) { }
          }
        }
      }
      ret += dp[n - 1][n - 1];
      g[0][n - 1] = 0;
      for (int i = n - 1, j = n - 1; i > 0 && j >= 0;) {
        if (std::clamp(j, 1, n - 2) == j) {
          const auto best = std::max({dp[i - 1][j - 1], dp[i - 1][j + 0], dp[i - 1][j + 1]});
          if (best == dp[i - 1][j - 1]) {
            g[i--][j--] = 0;
          } else if (best == dp[i - 1][j + 0]) {
            g[i--][j] = 0;
          } else {
            g[i--][j++] = 0;
          }
        } else if (j > 0) {
          const auto best = std::max(dp[i - 1][j - 1], dp[i - 1][j + 0]);
          if (best == dp[i - 1][j - 1]) {
            g[i--][j--] = 0;
          } else {
            g[i--][j] = 0;
          }
        } else if (j + 1 < n) {
          const auto best = std::max(dp[i - 1][j + 1], dp[i - 1][j + 0]);
          if (best == dp[i - 1][j + 1]) {
            g[i--][j++] = 0;
          } else {
            g[i--][j] = 0;
          }
        } else {
          g[i--][j] = 0;
        }
      }
    }
    {
      std::vector dp(n, std::vector(n, -kInf));
      dp[n - 1][0] = g[n - 1][0];
      for (int j = 1; j < n; ++j) {
        for (int i = 0; i < n; ++i) {
          for (auto [di, dj] : {std::pair{+1, -1}, {+0, -1}, {-1, -1}}) {
            const auto ni = i + di;
            const auto nj = j + dj;
            if (ok(ni, nj) && imax(dp[i][j], dp[ni][nj] + g[i][j])) { }
          }
        }
      }
      ret += dp[n - 1][n - 1];
      g[n - 1][0] = 0;
      for (int i = n - 1, j = n - 1; i >= 0 && j > 0;) {
        if (std::clamp(i, 1, n - 2) == i) {
          const auto best = std::max({dp[i + 1][j - 1], dp[i + 0][j - 1], dp[i - 1][j - 1]});
          if (best == dp[i + 1][j - 1]) {
            g[i++][j--] = 0;
          } else if (best == dp[i + 0][j - 1]) {
            g[i][j--] = 0;
          } else {
            g[i--][j--] = 0;
          }
        } else if (i > 0) {
          const auto best = std::max(dp[i - 1][j - 1], dp[i - 0][j - 1]);
          if (best == dp[i - 1][j - 1]) {
            g[i--][j--] = 0;
          } else {
            g[i][j--] = 0;
          }
        } else if (i + 1 < n) {
          const auto best = std::max(dp[i + 1][j - 1], dp[i - 0][j - 1]);
          if (best == dp[i + 1][j - 1]) {
            g[i++][j--] = 0;
          } else {
            g[i][j--] = 0;
          }
        } else {
          g[i][j--] = 0;
        }
      }
    }
    return ret;
  }
};",1460871637
jianstanleya,jianstanleya,323,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long result = 0;
        for(int i = 0; i < s.size(); i++) {
            long long diffi = 0;
            long long diffd = 0;
            char c = s[i];
            while(c != t[i]) {
                diffi += nextCost[c - 'a'];
                c++;
                if(c > 'z') c = 'a';
            }
            c = s[i];
            while(c != t[i]) {
                diffd += previousCost[c - 'a'];
                c--;
                if(c < 'a') c = 'z';
            }
            result += min(diffi, diffd);
        }
        return result;
    }
};",1460816355
jianstanleya,jianstanleya,323,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i = 0;
        int c = 10;
        while(c && n >= c) {
            n -= c;
            i++;
            c--;
        }
        return i % 2;
    }
};",1460798735
jianstanleya,jianstanleya,323,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int result = 0;
        for(int i = 0; i < n; i++) {
            result += fruits[i][i];
            fruits[i][i] = 0;
        }
        int ceil = n / 2 + n % 2;
        vector<vector<int>> dp(ceil, vector<int>(n, -1));
        dp[ceil - 1][0] = fruits[n - 1][0];
        for(int i = 1; i < n; i++) {
            int top = i;
            if(top >= ceil) top = n - i - 1;
            for(int j = 0; j <= top; j++) {
                int cand = dp[ceil - j - 1][i - 1];
                if(j > 0) cand = max(cand, dp[ceil - j][i - 1]);
                if(j < ceil - 1) cand = max(cand, dp[ceil - j - 2][i - 1]);
                dp[ceil - j - 1][i] = cand + fruits[n - j - 1][i];
            }
        }
        result += dp[ceil - 1][n - 1];
        dp = vector<vector<int>>(n, vector<int>(ceil, -1));
        dp[0][ceil - 1] = fruits[0][n - 1];
        for(int i = 1; i < n; i++) {
            int top = i;
            if(top >= ceil) top = n - i - 1;
            for(int j = 0; j <= top; j++) {
                int cand = dp[i - 1][ceil - j - 1];
                if(j > 0) cand = max(cand, dp[i - 1][ceil - j]);
                if(j < ceil - 1) cand = max(cand, dp[i - 1][ceil - j - 2]);
                dp[i][ceil - j - 1] = cand + fruits[i][n - j - 1];
            }
        }
        result += dp[n - 1][ceil - 1];
        return result;
    }
};",1460875903
gjp4_,gjp4_,324,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long> > dp(26, vector<long long>(26, 1e15));
        for(int i=0;i<26;i++) {
            dp[i][i] = 0;
            dp[i][(i+1)%26] = nextCost[i];
            dp[i][(i+25)%26] = previousCost[i];
        }
        for(int k=0;k<26;k++) {
            for(int i = 0;i<26;i++) {
                if(dp[i][k] == 1e15)continue;
                for(int j=0;j<26;j++) {
                    if(dp[k][j] == 1e15)continue;
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
                }
            }
        }
        long long ans = 0;
        for(int i=0; i< s.size(); i++) {
            ans += dp[s[i]-'a'][t[i] -'a'];
        }
        return ans;
    }
};",1460806974
gjp4_,gjp4_,324,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10;i>=1;i--) {
            if(i > n)return i&1;
            n-= i;
        }
        return true;
    }
};",1460797183
gjp4_,gjp4_,324,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        // 0, n-1   
        // n-1, 0   
        int n=  fruits.size();
        int ans =0;
        for(int i=0;i<n;i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        auto Valid = [&](int x, int y) {
            return x >=0 && x < n && y >=0 && y < n;
        };
        vector<vector<long long> > dp(n, vector<long long>(n, -1)), dp1(n, vector<long long>(n, -1));
        auto dfs = [&](auto &&dfs, int x, int y) -> long long{
            if(!Valid(x, y))return -1e15;
            if(x > y)return -1e15;
            if( x == n-1 && y == n-1) return 0;
            long long &ret = dp[x][y];
            if(ret != -1)return ret;
            ret = 0;
            ret = max(ret, fruits[x][y] + dfs(dfs, x+1, y-1));
            ret = max(ret, fruits[x][y] + dfs(dfs, x+1, y));
            ret = max(ret, fruits[x][y] + dfs(dfs, x+1, y+1));
            return ret;
        };
        auto dfs1 = [&](auto &&dfs1, int x, int y) -> long long{
            if(!Valid(x, y))return -1e15;
            if(y > x)return -1e15;
            if( x == n-1 && y == n-1) return 0;
            long long &ret = dp1[x][y];
            if(ret != -1)return ret;
            ret = 0;
            ret = max(ret, fruits[x][y] + dfs1(dfs1, x+1, y+1));
            ret = max(ret, fruits[x][y] + dfs1(dfs1, x, y+1));
            ret = max(ret, fruits[x][y] + dfs1(dfs1, x-1, y+1));
            // cout<<x<<"" ""<<y<<"" ""<<dp[x][y]<<endl;
            return ret;
        };
        // cout<<""0, n-1: ""<<dfs(dfs, 0, n-1)<<endl;
        // cout<<""n-1, 0: ""<<dfs1(dfs1, n-1, 0)<<endl;
        return ans + dfs(dfs, 0, n-1) + dfs1(dfs1, n-1, 0);
        
    }
};",1460876005
mad7max,mad7max,327,3591,cpp,"#define ll long long int
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        ll size=s.length(), i, j, ans=0ll, c1=0ll, c2=0ll, index1, index2;
        vector<ll> v1(52,0ll), v2(52,0ll);
        v1[0]=n[0]*1ll;
        v2[0]=p[0]*1ll;
        for (i=1;i<52;i++) {
            v1[i]=p[i%26]+v1[i-1];
            v2[i]=n[i%26]+v2[i-1];
        }
        for (i=0;i<size;i++) {
            index1=s[i]-'a';
            index2=t[i]-'a';
            if (index1==index2) {
                continue;
            }
            if (index1<index2) {
                c2=v2[index2+25]-v2[index1+25];
                c1=v1[index1+26]-v1[index2];
            } else {
                c2=v2[index2+25]-v2[index1-1];
                c1=v1[index1+26]-v1[index2+26];
            }
            // cout<<index1<<"" ""<<index2<<"" ""<<c1<<"" ""<<c2<<endl;
            ans+=min(c1,c2);
        }
        return ans;
    }
};",1460845603
mad7max,mad7max,327,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x=10, c=0;
        while(n>=x) {
            n-=x;
            x--;
            c=(c+1)%2;
        }
        return c==1;
    }
};",1460799685
mad7max,mad7max,327,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n=fruits.size(), i, j;
        vector<vector<int>> v(n, vector<int>(n, 0));
        v[0][0]=fruits[0][0];
        v[0][n-1]=fruits[0][n-1];
        v[n-1][0]=fruits[n-1][0];
        for (i=1;i<n-1;i++) {
            for (j=max(i+1, n-i-1);j<n;j++) {
                // cout<<i<<"" ""<<j<<endl;
                v[i][j]+=fruits[i][j] + max(max(v[i-1][j], v[i-1][j-1]), max(0, j+1<n?v[i-1][j+1]:0));
            }
        }
        for (j=1;j<n-1;j++) {
            for (i=max(j+1, n-j-1);i<n;i++) {
                // cout<<i<<"" ""<<j<<endl;
                v[i][j]+=fruits[i][j] + max(max(v[i][j-1], v[i-1][j-1]), max(i+1<n?v[i+1][j-1]:0 , 0));
            }
        }
        for (i=1;i<n;i++) {
            v[i][i]+=v[i-1][i-1] + fruits[i][i];
        }
        return v[n-1][n-1]+v[n-1][n-2]+v[n-2][n-1];
    }
};",1460893703
Chakradhar G,ChakradharG,328,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nextCost += nextCost
        previousCost += previousCost
        n = [0 for _ in range(52)]
        p = [0 for _ in range(52)]
        cur = 0
        for i in range(52):
            n[i] = cur
            cur += nextCost[i]
        cur = 0
        for i in reversed(range(52)):
            p[i] = cur
            cur += previousCost[i]

        ans = 0
        for sc, tc in zip(s, t):
            i = ord(sc) - 97
            j = ord(tc) - 97
            if i < j:
                ans += min(n[j] - n[i], p[j] - p[i + 26])
            elif i > j:
                ans += min(n[j + 26] - n[i], p[j] - p[i])

        return ans
",1460888034
Chakradhar G,ChakradharG,328,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        a, c = False, 10
        while n >= c:
            n -= c
            c -= 1
            a = not a

        return a
",1460808652
Chakradhar G,ChakradharG,328,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0

        memo1 = {}
        def dfs1(i, j):
            if j == n-1:
                if i == n-1:
                    return 0
                else:
                    return -math.inf
            key = (i, j)
            if key not in memo1:
                memo1[key] = dfs1(i, j+1)
                if i < n-1:
                    memo1[key] = max(memo1[key], dfs1(i+1, j+1))
                if i > 0:
                    memo1[key] = max(memo1[key], dfs1(i-1, j+1))
                memo1[key] += fruits[i][j]
            return memo1[key]

        memo2 = {}
        def dfs2(i, j):
            if i == n-1:
                if j == n-1:
                    return 0
                else:
                    return -math.inf
            key = (i, j)
            if key not in memo2:
                memo2[key] = dfs2(i+1, j)
                if j < n-1:
                    memo2[key] = max(memo2[key], dfs2(i+1, j+1))
                if j > 0:
                    memo2[key] = max(memo2[key], dfs2(i+1, j-1))
                memo2[key] += fruits[i][j]
            return memo2[key]

        ans += dfs1(n-1, 0) + dfs2(0, n-1)
        return ans",1460862083
Ajay Singh Deopa,singh_deopa,329,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = (int) s.size();
        long long res = 0;

        for (int i = 0; i < n; i++) {
            int ch1 = (int) s[i] - 'a';
            int ch2 = (int) t[i] - 'a';

            if (ch1 == ch2) {
                continue;
            }

            int j = ch1;
            long long c1 = 0, c2 = 0;
            
            while (j != ch2) {
                c1 += 1LL * nextCost[j];
                j = (j + 1) % 26;
            }

            j = ch1;

            while (j != ch2) {
                c2 += 1LL * previousCost[j];
                j = (j - 1 + 26) % 26;
            }

            res += min(c1, c2);
        }

        return res;
    }
};",1460807980
Ajay Singh Deopa,singh_deopa,329,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 0, curr = 10;

        while (n >= curr && curr > 0) {
            n -= curr;
            curr--;
            cnt++;
        }

        return (cnt & 1) == 1;
    }
};",1460797436
Ajay Singh Deopa,singh_deopa,329,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = (int) fruits.size();
        int res = fruits[0][n - 1] + fruits[n - 1][0];

        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }

        if (n == 2) {
            return res;
        }

        vector<vector<int>> dp1(n, vector<int>(n, 0)), dp2(n, vector<int>(n, 0));
        queue<int> q;
        q.push(n - 1);

        for (int i = 1; i < n - 1; i++) {
            int sz = (int) q.size();
            vector<int> vis(n);

            while (sz--) {
                int x = q.front();
                q.pop();

                for (int dx: {-1, 0, 1}) {
                    int nx = x + dx;

                    if (nx < 0 || nx >= n || (n - 1 - nx) > i) {
                        continue;
                    }

                    dp1[nx][i] = max(dp1[nx][i], dp1[x][i - 1] + fruits[nx][i]);

                    if (vis[nx]) {
                        continue;
                    }

                    vis[nx] = true;
                    q.push(nx);
                }
            }
        }

        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         cout << dp1[i][j] << "" "";
        //     }
        //     cout << endl;
        // }

        res += max(dp1[n - 2][n - 2], dp1[n - 1][n - 2]);

        while(!q.empty()) {
            q.pop();
        }

        q.push(n - 1);

        for (int i = 1; i < n - 1; i++) {
            int sz = (int) q.size();
            vector<int> vis(n);

            while (sz--) {
                int y = q.front();
                q.pop();

                for (int dy: {-1, 0, 1}) {
                    int ny = y + dy;

                    if (ny < 0 || ny >= n) {
                        continue;
                    }

                    dp2[i][ny] = max(dp2[i][ny], dp2[i - 1][y] + fruits[i][ny]);

                    if (vis[ny]) {
                        continue;
                    }

                    vis[ny] = true;
                    q.push(ny);
                }
            }
        }

        res += max(dp2[n - 2][n - 1], dp2[n - 1][n - 2]);
        
        return res;
    }
};",1460876290
LittleboyBK99,LittleboyBK99,330,3591,typescript,"function shiftDistance(s: string, t: string, next: number[], prev: number[]): number {
  const nk = 26;
  const d_next: number[][] = new Array(nk).fill(0).map(() => new Array(nk).fill(0));
  const d_prev: number[][] = new Array(nk).fill(0).map(() => new Array(nk).fill(0));

  for (var i = 0; i < nk; i++) {
    for (var j = i + 1; j < i + nk; j++) {
      var vj = j % nk;
      d_next[i][vj] = d_next[i][(vj + 25) % nk] + next[(vj + 25) % nk];
    }
  }

  for (var i = 0; i < nk; i++) {
    for (var j = i - 1; j > i - nk; j--) {
      var vj = (j + nk) % nk;
      d_prev[i][vj] = d_prev[i][(vj + 1) % nk] + prev[(vj + 1) % nk];
    }
  }

  var res = 0;
  const n = s.length;
  for (var i = 0; i < n; i++) {
    var u = s.charCodeAt(i) - 97;
    var v = t.charCodeAt(i) - 97;
    res += Math.min(d_next[u][v], d_prev[u][v]);
  }
  return res;
}",1460831105
LittleboyBK99,LittleboyBK99,330,3625,typescript,"function canAliceWin(n: number): boolean {
  var alice = true;
  var count = 10;
  while (n >= count) {
    n -= count;
    alice = !alice;
      count--
  }
  return !alice;
}",1460798981
LittleboyBK99,LittleboyBK99,330,3648,typescript,"function maxCollectedFruits(a: number[][]): number {
  const n = a.length;
  var res = a[0][0] + a[0][n - 1] + a[n - 1][0];
  for (var i = 1; i < n; i++) {
    res += a[i][i];
  }
  //
  if (n < 3) {
    return res;
  }

  res += a[n - 2][n - 1] + a[n - 1][n - 2];
  if (n === 3) {
    return res;
  }
  var dp: number[][] = new Array(n).fill(0).map(() => new Array(n).fill(-1000000000));

  //
  // console.log(""res: "", res);
  dp[n - 1][0] = 0;
  for (var col = 1; col <= n - 3; col++) {
    for (var row = 0; row < n; row++) {
      if (row > 0) {
        dp[row][col] = Math.max(dp[row][col], dp[row - 1][col - 1] + a[row][col]);
      }
      dp[row][col] = Math.max(dp[row][col], dp[row][col - 1] + a[row][col]);
      if (row < n - 1) {
        dp[row][col] = Math.max(dp[row][col], dp[row + 1][col - 1] + a[row][col]);
      }
    }
  }
  res += Math.max(dp[n - 1][n - 3], dp[n - 2][n - 3]);

  //console.log(dp[4][1], dp[3][2], dp[4][3], dp[n - 1][n - 3], dp[n - 2][n - 3]);
  var dp2 = new Array(n).fill(0).map(() => new Array(n).fill(-1000000000));
  //
  dp2[0][n - 1] = 0;
  for (var row = 1; row <= n - 3; row++) {
    for (var col = 0; col < n; col++) {
      if (col > 0) {
        dp2[row][col] = Math.max(dp2[row][col], dp2[row - 1][col - 1] + a[row][col]);
      }
      dp2[row][col] = Math.max(dp2[row][col], dp2[row - 1][col] + a[row][col]);
      if (col < n - 1) {
        dp2[row][col] = Math.max(dp2[row][col], dp2[row - 1][col + 1] + a[row][col]);
      }
    }
  }
  res += Math.max(dp2[n - 3][n - 2], dp2[n - 3][n - 1]);
  return res;
}",1460882324
After,A009,338,3591,cpp,"class Solution {
public:
    #define ll long long
    
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        
        ll ans = 0;
        
        vector<ll> a(26 , 0);
        vector<ll> b(26 , 0);
        
        for(int i = 1 ; i < 26 ; i++)
        {
            a[i] = a[i - 1] + n[i - 1];    
        }
        
        
        for(int i = 24 ; i >= 0 ; i--)
        {
            b[i] = b[i + 1] + p[i + 1];
        }
        
        for(int i = 0 ; i < s.size() ; i++)
        {
            if(s[i] == t[i])
                continue ;
            
            if(s[i] < t[i])
            {
                ll temp = (a[t[i] - 'a'] - a[s[i] - 'a']);
                
                ll tempp = (b[0] - b[s[i] - 'a'] + p[0]) + (b[t[i] - 'a'] - b[25]);
                
                ans += min(tempp , temp);
            }
            
            else
            {
                ll temp = (b[t[i] - 'a'] - b[s[i] - 'a']);
                
                ll tempp = (ll)(a[25] - a[s[i] - 'a'] + (ll)n[25]) + (a[t[i] - 'a'] - a[0]);
                
                ans += min(tempp , temp);
            }
        }
        
        return ans;
        
    }
};",1460853111
After,A009,338,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
  
        int flag = 0;
        int a = 10;
        
        while(n)
        {
            if(n < a)
                return flag;
            
            n = n - a;
            a--;
            flag = !flag;
        }
        
        return flag;
    }
};",1460797212
After,A009,338,3648,cpp,"class Solution {
public:

    int f(vector<vector<int>>& v, int i , int j , int flag , vector<vector<vector<int>>>& dp)
    {
        int n = v.size();
        
        if(i < 0 || j < 0 || i >= n || j >= n || (i != n - 1 && i == j))
            return -1;
        
        if(i == j)
            return 0;
        
        if(dp[i][j][flag] != -2)
            return dp[i][j][flag];
        
        if(flag == 0)
        {
            int count = max((i - 0) , (n - 1 - j));
            
            if(count == n - 1)
                return -1;
            
            int ans = -1;
            
            int a = f(v , i + 1 , j - 1 , flag , dp);
            int b = f(v , i + 1 , j , flag , dp);
            int c = f(v , i + 1 , j + 1 , flag , dp);
            
            if(a != -1)
                ans = max(ans , a);
            
            if(c != -1)
                ans = max(ans , c);
            
            if(b != -1)
                ans = max(ans , b);
            
            if(ans != -1)
                ans += v[i][j];
            
            return dp[i][j][flag] = ans;
        }
        
        int count = max((n - 1 - i) , (j - 0));

        if(count == n - 1)
            return dp[i][j][flag] = -1;

        int ans = -1;

        int a = f(v , i - 1 , j + 1 , flag , dp);
        int b = f(v , i , j + 1 , flag , dp);
        int c = f(v , i + 1 , j + 1 , flag , dp);

        if(a != -1)
            ans = max(ans , a);

        if(c != -1)
            ans = max(ans , c);

        if(b != -1)
            ans = max(ans , b);

        if(ans != -1)
            ans += v[i][j];
        
        return dp[i][j][flag] = ans;
    }
    
    int maxCollectedFruits(vector<vector<int>>& v) {
        
        int n = v.size();
        int ans = 0;
        
        for(int i = 0 ; i < n ; i++)
        {
            ans += v[i][i];
            v[i][i] = 0;
        }
        
        vector<vector<vector<int>>> dp(n , vector<vector<int>>(n , vector<int>(2 , -2)));
        
        int a = f(v , 0 , n - 1 , 0 , dp);
        int b = f(v , n - 1 , 0 , 1 , dp);
        
        if(a != -1)
            ans += a;
        
        if(b != -1)
            ans += b;
        
        return ans;
    }
};",1460896319
Nisarg Patel,Nisarg_Pat,339,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        // Find left and right cost for each character.
        for(int i=0;i<s.length();i++) {
            int curr = s.charAt(i)-'a';
            int req = t.charAt(i)-'a';

            ans += Math.min(leftCost(curr, req, previousCost), rightCost(curr, req, nextCost));
        }
        return ans;
    }

    private long leftCost(int curr, int req, int[] prevCost) {
        long cost = 0;
        while(curr != req) {
            cost += prevCost[curr];
            curr = (curr+26-1)%26;
        }
        //System.out.println(cost);
        return cost;
    }

    private long rightCost(int curr, int req, int[] nextCost) {
        long cost = 0;
        while(curr != req) {
            cost += nextCost[curr];
            curr = (curr+1)%26;
        }
        //System.out.println(cost);
        return cost;
    }
}",1460827108
Nisarg Patel,Nisarg_Pat,339,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int curr = 10;
        int turns = 0;
        while(n-curr >= 0) {
            turns++;
            n = n-curr;
            curr--;
        }
        return turns%2 == 1;
    }
}",1460808145
Nisarg Patel,Nisarg_Pat,339,3648,java,"class Solution {
    int n;
    
    public int maxCollectedFruits(int[][] fruits) {
        n = fruits.length;
        // Child 1 will always move on diagonal
        // Child 2 cannot go below diagonal
        // Child 3 cannot go above diagonal
        return childOne(fruits) + childTwo(fruits) + childThree(fruits);
    }

    private int childOne(int[][] fruits) {
        int count = 0;
        for(int i=0;i<n;i++) {
            count += fruits[i][i];
        }
        // System.out.println(count);
        return count;
    }

    private int childTwo(int[][] fruits) {
        long[][] memo = new long[n][n];
        for(int i=0;i<n;i++) {
            for(int j=0;j<n;j++) {
                memo[i][j] = -1;
            }
        }
        return (int)dpTwo(memo, 0, n-1, fruits);
    }

    private long dpTwo(long[][] memo, int i, int j, int[][] fruits) {
        // System.out.println(i+"" ""+j);
        if(i<0 || i>=n || j<0 || j>=n) {
            return -10000000;
        }
        if(i == j) {
            return 0;
        }
        if(i>j) {
            return -10000000;
        } 
        if(memo[i][j] != -1) {
            return memo[i][j];
        }
        memo[i][j] = fruits[i][j];
        memo[i][j] += Math.max(dpTwo(memo, i+1, j-1, fruits), Math.max(dpTwo(memo, i+1, j, fruits), dpTwo(memo, i+1, j+1, fruits)));
        // System.out.println(i+"" ""+j+"" ""+memo[i][j]);
        return memo[i][j];
    }

    private int childThree(int[][] fruits) {
        long[][] memo = new long[n][n];
        for(int i=0;i<n;i++) {
            for(int j=0;j<n;j++) {
                memo[i][j] = -1;
            }
        }
        return (int)dpThree(memo, n-1, 0, fruits);
    }

    private long dpThree(long[][] memo, int i, int j, int[][] fruits) {
        if(i<0 || i>=n || j<0 || j>=n) {
            return -10000000;
        }
        if(i==j) {
            return 0;
        }
        if(i<j) {
            return -10000000;
        } if(memo[i][j] != -1) {
            return memo[i][j];
        }
        memo[i][j] = fruits[i][j];
        memo[i][j] += Math.max(dpThree(memo, i-1, j+1, fruits), Math.max(dpThree(memo, i, j+1, fruits),dpThree(memo, i+1, j+1, fruits)));
        return memo[i][j];
    }
}",1460896628
Haixin Shi,HaixinShi,341,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        def prev(src, tgt):
            acc = 0
            while src != tgt:
                acc += previousCost[src]
                if src == 0:
                    src = 25
                else:
                    src -= 1
            return acc
        def next(src, tgt):
            acc = 0
            while src != tgt:
                acc += nextCost[src]
                if src == 25:
                    src = 0
                else:
                    src += 1
            return acc
        ans = 0
        for i in range(len(s)):
            src = ord(s[i]) - ord('a')
            tgt = ord(t[i]) - ord('a')
            prev_cost = prev(src, tgt)
            next_cost = next(src, tgt)
            if prev_cost > next_cost:
                ans += next_cost
            else:
                ans += prev_cost
        return ans
        ",1460826884
Haixin Shi,HaixinShi,341,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        n -= 10
        k = 9
        i = 0
        while n > 0 and k > 0:
            if n >= k:
                n -= k
                k -= 1
                i += 1
            else:
                if i % 2 == 0:
                    return True
                else:
                    return False
        if i % 2 == 0:
            return True
        else:
            return False
                    ",1460806940
Haixin Shi,HaixinShi,341,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        ans = 0
        n = len(fruits)
        # 1. find top left children
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0
        # 2. find left two children, and they are independent
        memo = {}
        def dfs(i, j, budget, dirs, n, seen):
            if (i, j) in memo:
                return memo[(i, j)]
            if budget == 0:
                if i == n - 1 and j == n - 1:
                    return 0
                else:
                    return -1
            else:
                res = -1
                for di, dj in dirs:
                    new_i, new_j = i + di, j + dj
                    if 0 <= new_i < n and 0 <= new_j < n \
                        and (new_i, new_j) not in seen:
                        seen.add((new_i, new_j))
                        ret = dfs(new_i, new_j, budget - 1, dirs, n, seen)
                        res = max(res, ret)
                        seen.remove((new_i, new_j))
                memo[(i, j)] = res + fruits[i][j] if res != -1 else -1
                return memo[(i, j)]
        memo = {}
        ans += dfs(0, n - 1, n - 1, [(1, -1), (1, 0), (1, 1)], n, set())
        memo = {}
        ans += dfs(n - 1, 0, n - 1, [(-1, 1), (0, 1), (1, 1)], n, set())
        return ans
                            
                ",1460891201
wanderlust312,wanderlust312,343,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans=0
        prevCostS = sum(previousCost)
        nextCostS = sum(nextCost)
        for (i,j) in zip(s,t):
            iind = ord(i)-97
            jind = ord(j)-97
            if iind < jind:
                # print(i,j,sum(nextCost[iind:jind]), sum(previousCost[0:iind+1])+sum(previousCost[jind+1:]))
                ans += min(sum(nextCost[iind:jind]), sum(previousCost[0:iind+1])+sum(previousCost[jind+1:]))
            elif iind > jind:
                # print(i,j,sum(previousCost[jind+1:iind+1]), sum(nextCost[0:jind])+sum(nextCost[iind:]))
                ans += min(sum(previousCost[jind+1:iind+1]), sum(nextCost[0:jind])+sum(nextCost[iind:]))
        return ans
                ",1460839909
wanderlust312,wanderlust312,343,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        curr=10
        while n>0:
            if n-curr>=0:
                n = n-curr
                curr-=1
            else:
                if curr%2==0:
                    return False
                return True
        return curr%2==1
            ",1460799308
wanderlust312,wanderlust312,343,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        def helper1(i,j,dp):
            if i==n-1 and j==n-1:
                return 0
            else:
                if dp[i][j] == -1:
                    possibilities = [[i-1,j+1],[i,j+1],[i+1,j+1]]
                    # print(i,j)
                    ans = fruits[i][j]
                    for (a,b) in possibilities:
                        if a>=0 and a<n and b>=0 and b<n and a>b:
                            ans = max(ans,fruits[i][j]+helper1(a,b,dp))
                    dp[i][j] = ans
                return dp[i][j]
                    
        def helper2(i,j,dp):
            if i==n-1 and j==n-1:
                return 0
            else:
                if dp[i][j]==-1:
                    possibilities = [[i+1,j-1],[i+1,j],[i+1,j+1]]
                    # print(i,j)
                    ans = fruits[i][j]
                    for (a,b) in possibilities:
                        if a>=0 and a<n and b>=0 and b<n and a<b:
                            ans = max(ans,fruits[i][j]+helper2(a,b,dp))
                    dp[i][j] = ans
                return dp[i][j]
                        
                
            
        ans=0
        n = len(fruits)
        for i in range(n):
            ans += fruits[i][i]

        dp1 = [[-1 for j in range(n)] for i in range(n)]
        dp2 = [[-1 for j in range(n)] for i in range(n)]
        
        return ans+helper1(n-1,0,dp1)+helper2(0,n-1,dp2)
                    
            ",1460891612
lazyleeds1,lazyleeds1,345,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        ans = 0
        
        for i in range(len(s)):
            curr, goal = ord(s[i]) - ord('a'), ord(t[i]) - ord('a')
            gonext, goprev = 0, 0

            if goal > curr:
                gonext = sum(nextCost[curr:goal])
                goprev = sum(previousCost[0:curr+1]) + sum(previousCost[goal+1:])
            elif goal < curr:
                gonext = sum(nextCost[curr:]) + sum(nextCost[0:goal])
                goprev = sum(previousCost[goal+1:curr+1])

            # print(curr, goal, gonext, goprev)
            ans += min(gonext, goprev)

        return ans",1460836147
lazyleeds1,lazyleeds1,345,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        r = 10
        turn = True

        while True:
            if n < r:
                return not turn
                
            n -= r
            r -= 1
            turn = not turn",1460796425
lazyleeds1,lazyleeds1,345,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0

        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0


        red_dp = [[0 for _ in range(n)] for _ in range(n)]
        
        for i in range(n):
            for j in range(max(n-1-i, i), n):
                top = red_dp[i-1][j]
                topleft = red_dp[i-1][j-1]
                topright = red_dp[i-1][j+1] if j+1 < n else 0
                
                red_dp[i][j] = fruits[i][j] + max(top, topleft, topright)

        # for row in red_dp:
        #     print(row)
        ans += red_dp[n-1][n-1]

        blue_dp = [[0 for _ in range(n)] for _ in range(n)]

        for j in range(n):
            for i in range(max(n-1-j, j), n):
                left = blue_dp[i][j-1]
                topleft = blue_dp[i-1][j-1]
                bottomleft = blue_dp[i+1][j-1] if i+1 < n else 0

                blue_dp[i][j] = fruits[i][j] + max(left, topleft, bottomleft)

        ans += blue_dp[n-1][n-1]
            
        return ans",1460886107
Rajesh Darapureddy,darapureddy,346,3591,java,"
class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long res = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) != t.charAt(i)) {
                res += cost(s.charAt(i) - 'a', t.charAt(i) - 'a', nextCost, previousCost);
            }
        }
        return res;
    }

    private long cost(int from, int to, int[] nextCost, int[] previousCost) {
        long r1 = 0, r2 = 0;
        int f1 = from, f2 = from;
        while (f1 != to) {
            r1 += nextCost[f1];
            f1 = (f1 + 1) % 26;
        }
        while (f2 != to) {
            r2 += previousCost[f2];
            f2 = (f2 - 1 + 26) % 26;
        }
        return Math.min(r1, r2);
    }

}",1460829892
Rajesh Darapureddy,darapureddy,346,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int moves=0;
        for(int i=10;i>=1;i--){
            if(n>=i){
                n-=i;
                moves++;
            }else break;
        }
        return moves%2==1;
    }
}",1460821993
Rajesh Darapureddy,darapureddy,346,3648,java,"class Solution {

    public int maxCollectedFruits(int[][] fruits) {
        final int n = fruits.length;
        if (n == 2) {
            return fruits[0][0] + fruits[0][1] + fruits[1][0] + fruits[1][1];
        }
        // print(fruits);
        int res = 0;
        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
        }
        boolean[][] isValid = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i + j >= (n - 1)) {
                    isValid[i][j] = true;
                }
                if (i == j) {
                    isValid[i][j] = false;
                }
            }
        }

        for (int i = 1; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isValid[i][j]) {
                    int add = 0;
                    if (isValid[i - 1][j]) {
                        add = Math.max(add, fruits[i - 1][j]);
                    }
                    if (j!= n-1 && isValid[i - 1][j + 1]) {
                        add = Math.max(add, fruits[i - 1][j + 1]);
                    }
                    if (isValid[i - 1][j - 1]) {
                        add = Math.max(add, fruits[i - 1][j - 1]);
                    }
                    fruits[i][j] += add;
                }
            }
        }
        rotate(fruits);
        for (int i = 1; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isValid[i][j]) {
                    int add = 0;
                    if (isValid[i - 1][j]) {
                        add = Math.max(add, fruits[i - 1][j]);
                    }
                    if (j!= n-1 && isValid[i - 1][j + 1]) {
                        add = Math.max(add, fruits[i - 1][j + 1]);
                    }
                    if (isValid[i - 1][j - 1]) {
                        add = Math.max(add, fruits[i - 1][j - 1]);
                    }
                    fruits[i][j] += add;
                }
            }
        }
        // rotate(fruits);
        // print(fruits);
        return res + fruits[n - 1][n - 2] + fruits[n - 2][n - 1];
    }

    private void rotate(int[][] grid) {
        int n = grid.length;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = grid[i][j];
                grid[i][j] = grid[j][i];
                grid[j][i] = temp;
            }
        }
    }

    private void print(int[][] grid) {
        for (int[] row : grid) {
            System.out.println(Arrays.toString(row));
        }
        System.out.println();
    }
}",1460892310
ganesh patra,92ganesh,348,3591,java,"class Solution {
public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {

        long cost = 0;
        for(int i=0;i<s.length();i++){
            long pre = preShift(s.charAt(i), t.charAt(i), previousCost);
            long next = nextShift(s.charAt(i), t.charAt(i), nextCost);
            cost += Math.min(pre, next);
        }

        return cost;
    }

    long preShift(char s, char t, int[] previousCost){
        int start = gi(s);
        int end = gi(t);

        long cost = 0;
        for(int i = start; i!=end; ){
            cost += previousCost[i];

            i--;
            if(i<0) i=25;
        }

        return cost;
    }

    long nextShift(char s, char t, int[] nextCost){
        int start = gi(s);
        int end = gi(t);

        long cost = 0;
        for(int i = start; i!=end; ){
            cost += nextCost[i];

            i++;
            if(i==26) i=0;
        }

        return cost;
    }

    int gi(char c){
        return c-'a';
    }
}",1460830447
ganesh patra,92ganesh,348,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
            boolean alice=false;
        
        int re=10;
        while(true){
            if(n-re>=0){
                n-=re;
                alice = !alice;
                re--;
            }else{
                break;
            }
        }
        
        return alice;
    }
}",1460798302
ganesh patra,92ganesh,348,3648,java,"class Solution {
 int[][] fruits;
    int n;
    public int maxCollectedFruits(int[][] fruits) {
        this.fruits = fruits;
        n = fruits.length;
        dp2 = new Integer[n][n];
        dp3 = new Integer[n][n];

        int re = 0;
        int kid2 = recur2(0, n-1);
        int kid3 = recur3(n-1, 0);

        int kid1 = 0;
        for(int i=0;i<n;i++){
            kid1 += fruits[i][i];
        }

//        System.out.printf(""kid1 %s %n"",kid1);
//        System.out.printf(""kid2 %s %n"",kid2);
//        System.out.printf(""kid3 %s %n"",kid3);

        return kid1+kid2+kid3;
    }


    Integer[][] dp2;
    Integer[][] dp3;
    int recur2(int x, int y){
//        System.out.printf(""-- %s %s \n"", x,y);
        if(x<0 || y<0 || x>=n || y>=n){
            return 0;
        }

        if(x==y || y<x){
            return 0;
        }

        if(dp2[x][y]!=null) return dp2[x][y];

//        System.out.printf(""%s %s \n"", x,y);
        int left = recur2(x+1, y-1);
        int down = recur2(x+1, y);
        int right = recur2(x+1, y+1);

        dp2[x][y] = fruits[x][y] + Math.max(left, Math.max(right, down));
        return dp2[x][y];
    }


    int recur3(int x, int y){

        if(x<0 || y<0 || x>=n || y>=n){
            return 0;
        }

        if(x==y || y>x){
            return 0;
        }

        if(dp3[x][y]!=null) return dp3[x][y];

//        System.out.printf(""%s %s \n"", x,y);
        int top = recur3(x-1, y+1);
        int right = recur3(x, y+1);
        int down = recur3(x+1, y+1);

        dp3[x][y] = fruits[x][y] + Math.max(top, Math.max(right, down));
        return dp3[x][y];
    }
}",1460898117
Ark_e,Ark_e,349,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long res = 0;
        for (int i = 0; i < s.length(); ++i) {
            int p = s.charAt(i) - 'a';
            int f = t.charAt(i) - 'a';
            long score = 0;
            while (p != f) {
                score += nextCost[p];
                p++;
                if (p == 26) {
                    p = 0;
                }
            }

            long scoreb = 0;
            p = s.charAt(i) - 'a';
            while (p != f) {
                scoreb += previousCost[p];
                p--;
                if (p == -1) {
                    p = 25;
                }                
            }
            res += Math.min(score, scoreb);
        }

        return res;
    }
}",1460809474
Ark_e,Ark_e,349,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int t = 10;
        boolean res = false;
        while (n >= t) {
            n -= t;
            t--;
            res = !res;
        }
        return res;
    }
}",1460796480
Ark_e,Ark_e,349,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int res = 0;
        for (int i = 0; i < fruits.length; ++i) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
       // System.out.println(res);

        int[][] dp = new int[fruits.length][fruits.length];
        for (int i = 0; i < fruits.length; ++i) {
            Arrays.fill(dp[i], -1);
        }
        dp[fruits.length - 1][0] = fruits[fruits.length - 1][0];

        
        for (int j = 1; j < fruits.length; ++j) {
            for (int i = 0; i < fruits.length; ++i) {
                int max = -1;
                if (dp[i][j - 1] >= 0) {
                    max = dp[i][j - 1];
                }
                if (i > 0 && dp[i - 1][j - 1] >= 0 ) {
                    max = Math.max(max, dp[i - 1][j - 1]);                    
                }
                if (i < fruits.length - 1 && dp[i + 1][j - 1] >= 0) {
                    max = Math.max(max, dp[i + 1][j - 1]);
                }
                if (max >= 0) {
                    dp[i][j] = max + fruits[i][j];
                }
            }
        }

        res += dp[fruits.length - 1][fruits.length - 1];
        //System.out.println(dp[fruits.length - 1][fruits.length - 1]);

        
        dp = new int[fruits.length][fruits.length];
        for (int i = 0; i < fruits.length; ++i) {
            Arrays.fill(dp[i], -1);
        }
        dp[0][fruits.length - 1] = fruits[0][fruits.length - 1];
        

        for (int i = 1; i < fruits.length; ++i) {
            for (int j = 0; j < fruits.length; ++j) {
                int max = -1;
                if (dp[i - 1][j] >= 0) {
                    max = dp[i - 1][j];
                }
                if (j > 0 && dp[i - 1][j - 1] >= 0) {
                    max = Math.max(max, dp[i - 1][j - 1]);                    
                }
                if (j < fruits.length - 1 && dp[i - 1][j + 1] >= 0) {
                    max = Math.max(max, dp[i - 1][j + 1]);
                }
                if (max >= 0) {
                    dp[i][j] = max + fruits[i][j];
                }
            }
        }
        res += dp[fruits.length - 1][fruits.length - 1];

        //System.out.println(dp[fruits.length - 1][fruits.length - 1]);

        return res;

    }

}",1460886981
Isa,isa773,350,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, up: List[int], down: List[int]) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            x, y = ord(s[i])-ord('a'), ord(t[i]) - ord('a')
            s1, s2 = 0, 0
            if x == y: continue
            if x < y:
                s1 = sum(up[x:y])
                s2 = sum(down[:x+1]) + sum(down[y+1:])
            if x > y:
                s1 = sum(up[x:]) + sum(up[:y])
                s2 = sum(down[y+1:x+1])
            #print(i, x, y, s1, s2)
            ans += min(s1, s2)
        return ans",1460838433
Isa,isa773,350,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        c = 10
        while True:
            if n < c and c % 2 == 0:
                return False
            if n < c and c % 2 == 1:
                return True
            n -= c
            c -= 1
        return True",1460798514
Isa,isa773,350,3648,python3,"class Solution:
    def maxCollectedFruits(self, nums: List[List[int]]) -> int:
        n = len(nums)
        s1 = 0
        for i in range(n): s1 += nums[i][i]
            
        dp1 = [[0] * n for i in range(n)]
        dp1[0][n-1] = nums[0][n-1]
        for i in range(1,n):
            for j in range(n-1-i,n):
                if n-1-i >= n-1-j:
                    dp1[i][j] = max(dp1[i-1][j-1], dp1[i-1][j])
                    if j < n-1: dp1[i][j] = max(dp1[i][j], dp1[i-1][j+1])
                    if i != j: dp1[i][j] += nums[i][j]
        s2 = dp1[n-1][n-1]
        #print(dp1)
        
        dp1 = [[0] * n for i in range(n)]
        dp1[n-1][0] = nums[n-1][0]
        for j in range(1,n):
            for i in range(n-1-j,n):
                if n-1-j >= n-1-i:
                    dp1[i][j] = max(dp1[i-1][j-1], dp1[i][j-1])
                    if i < n-1: dp1[i][j] = max(dp1[i][j], dp1[i+1][j-1])
                    if i != j: dp1[i][j] += nums[i][j]
        s3 = dp1[n-1][n-1]
        #print(dp1)

        #print(s1, s2, s3)
        
        return s1 + s2 + s3
        
                    
                ",1460881344
Ying Liu,pein531,351,3591,cpp,"typedef long long LL;
const int N = 100010;
LL dp[N];

class Solution {
public:
    int n;
    string s, t;
    vector<int> nextCost, previousCost;
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        n = s.size();
        this->s = s;
        this->t = t;
        this->previousCost = previousCost;
        this->nextCost = nextCost;
        memset(dp, -1, sizeof(dp));
        return dfs(0);
    }

    LL dfs(int i) {
        if(i == n) return 0LL;
        LL &v = dp[i];
        if(v != -1) return v;
        int j = s[i] - 'a';
        if(s[i] < t[i]) {
            LL cost1 = 0;
            for(int k = j; k < t[i] - 'a'; k++) {
                cost1 += nextCost[k];
            }
            cost1 += dfs(i + 1);
            LL cost2 = 0;
            for(int k = j; k >= 0; k--) {
                cost2 += previousCost[k];
            }
            for(int k = 25; k > t[i] - 'a'; k--) {
                cost2 += previousCost[k];
            }
            cost2 += dfs(i + 1);
            return v = min(cost1, cost2);
        }else if(s[i] > t[i]) {
            LL cost1 = 0;
            for(int k = j; k <= 25; k++) {
                cost1 += nextCost[k];
            }
            for(int k = 0; k < t[i] - 'a'; k++) {
                cost1 += nextCost[k];
            }
            cost1 += dfs(i + 1);
            LL cost2 = 0;
            for(int k = j; k > t[i] - 'a'; k--) {
                cost2 += previousCost[k];
            }
            cost2 += dfs(i + 1);
            return v = min(cost1, cost2);
        }else {
            return v = dfs(i + 1);
        }
    }
};",1460884963
Ying Liu,pein531,351,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 10, a = 1;
        while(n >= x) {
            n -= x;
            a = 1 - a;
            x--;
        }
        return a == 0;
    }
};",1460887261
Ying Liu,pein531,351,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0, n = fruits.size();
        for(int i = 0; i < n; i++) {
            ans += fruits[i][i];
        }
        vector<int> dp1;
        for(int j = 0; j < n; j++) {
            vector<int> temp(j + 1);
            for(int i = 0; i < j + 1; i++) {
                int tmp = 0;
                if(i < j && i < dp1.size()) {
                    tmp = dp1[i];
                }
                if(i < j - 1 && i + 1 < dp1.size()) {
                    tmp = max(tmp, dp1[i + 1]);
                }
                if(i > 0 && i - 1 < dp1.size()) {
                    tmp = max(tmp, dp1[i - 1]);
                }
                temp[i] = tmp;
                if(n - i - 1 != j) {
                    temp[i] += fruits[n - i - 1][j];
                }
            }
            dp1.swap(temp);
        }
        vector<int> dp2;
        for(int i = 0; i < n; i++) {
            vector<int> temp(i + 1);
            for(int j = 0; j < i + 1; j++) {
                int tmp = 0;
                if(j < i && j < dp2.size()) {
                    tmp = dp2[j];
                }
                if(j < i - 1 && j + 1 < dp2.size()) {
                    tmp = max(tmp, dp2[j + 1]);
                }
                if(j > 0 && j - 1 < dp2.size()) {
                    tmp = max(tmp, dp2[j - 1]);
                }
                temp[j] = tmp;
                if(n - j - 1 != i) {
                    temp[j] += fruits[i][n - j - 1];
                }
            }
            dp2.swap(temp);
        }
        return ans + dp1[0] + dp2[0];
    }
};",1460886217
Dilworth,dilworth,352,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for (int i = 0; i < s.size(); ++i) {
            long long cst = 0;
            char from = s[i];
            while (from != t[i]) {
                cst += nextCost[from - 'a'];
                if (from == 'z') from = 'a';
                else ++from;
            }
            from = s[i];
            long long cst2 = 0;
            while (from != t[i]) {
                cst2 += previousCost[from - 'a'];
                if (from == 'a') from = 'z';
                else --from;
            }
            ans += min(cst, cst2);
        }
        return ans;
    }
};",1460817381
Dilworth,dilworth,352,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int st = 10;
        int who = 1;
        while (n) {
            if (n < st) return 1 - who;
            n -= st;
            --st;
            who = 1 - who;
        }
        return 1 - who;
    }
};",1460799961
Dilworth,dilworth,352,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        if (n <= 3) {
            int ans = 0;
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (i == j || i == n - 1 || j == n - 1) ans += fruits[i][j];
                }
            }
            return ans;
        }
        vector<vector<int>> dp(n, vector<int>(n, -1));
        vector<vector<int>> a_arr;
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += fruits[i][i];
        }
        // cout << ans << '\n';
        for (int i = 0; i < n; ++i) {
            vector<int> cur;
            for (int j = 0; j < n; ++j) {
                if (i == j) cur.push_back(0);
                else cur.push_back(fruits[i][j]);
            }
            a_arr.push_back(cur);
        }
        // cout << ""first pass: \n"";
        // for (auto x: a_arr) {
        //     for (auto y: x) {
        //         cout << y << ' ';
        //     }
        //     cout << '\n';
        // }
        ans += rec(n - 1, 0, n, dp, a_arr);
        // cout << ans << '\n';
        a_arr = vector<vector<int>>();
        dp = vector<vector<int>>(n, vector<int>(n, -1));
        for (int j = 0; j < n; ++j) {
            vector<int> cur;
            for (int i  = 0; i < n; ++i) {
                if (i == j) cur.push_back(0);
                else cur.push_back(fruits[i][j]);
            }
            a_arr.push_back(cur);
        }
        // cout << ""second pass: \n"";
        // for (auto x: a_arr) {
        //     for (auto y: x) {
        //         cout << y << ' ';
        //     }
        //     cout << '\n';
        // }
        ans += rec(n - 1, 0, n, dp, a_arr);
        return ans;
    }

    int rec(int row, int moves, int n, vector<vector<int>> &dp, vector<vector<int>> &arr) {
        if (row < 0 || row > n - 1) return INT_MIN;
        if (moves == n - 1) return (row != n - 1) ? INT_MIN : 0;
        if (dp[row][moves] != -1) return dp[row][moves];
        return (dp[row][moves] = arr[row][moves] + max(max(rec(row, moves + 1, n, dp, arr),
                                                           rec(row - 1, moves + 1, n, dp, arr)), 
                                                        rec(row + 1, moves + 1, n, dp, arr)));
    }
};",1460887335
Sanjay Venkatesh,sanjay-venkatesh,353,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        for (int i=0; i < s.length(); i++) {
            long minCost = Math.min(
                calculateForward(nextCost, s.charAt(i)-'a', t.charAt(i)-'a'),
                calculateBackward(previousCost, s.charAt(i)-'a', t.charAt(i)-'a')
            );
            totalCost += minCost;
        }
        return totalCost;
    }

    long calculateForward(int[] nextCost, int start, int end) {
        int i=start;
        long cost = 0;
        while (i != end) {
            cost += nextCost[i];
            i = (i+1)%26;
        }
        return cost;
    }

    long calculateBackward(int[] previousCost, int start, int end) {
        int i=start;
        long cost = 0;
        while (i != end) {
            cost += previousCost[i];
            i = ((i-1)+26)%26;
        }
        return cost;
    }
}",1460839156
Sanjay Venkatesh,sanjay-venkatesh,353,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean isAliceTurn = true;
        int seq = 10;
        while (n !=0 && n >= seq) {
            n -= seq;
            seq--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
}",1460802061
Sanjay Venkatesh,sanjay-venkatesh,353,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;
        int cost = 0;
        for (int i=0; i < n; i++) {
            cost += fruits[i][i];
            fruits[i][i] = -1;
        }
        
        int[][] bottomLeftDir = {{1,-1}, {1,0}, {1, 1}};
        int[][] topRightDir = {{-1,1}, {0,1}, {1, 1}};

        int[][] memo = new int[n][n];
        for (int i=0; i <n; i++) {
            Arrays.fill(memo[i], -1);
        }
        
        cost += backtrack(fruits, n, bottomLeftDir, 0, n-1, n-1, memo);

        for (int i=0; i <n; i++) {
            Arrays.fill(memo[i], -1);
        }
        
        cost += backtrack(fruits, n, topRightDir, n-1, 0, n-1, memo);

        return cost;
    }

    int backtrack(int[][] fruits, int n, int[][] directions, int i, int j, int moves, int[][] memo) {
        if (i < 0 || i  >= n || j < 0 || j >= n) {
            return -60000;
        }
        
        if (i == n-1 && j == n-1) {
            return 0;
        }

        if (fruits[i][j] == -1) {
            return -60000;
        }

        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        int cost = Integer.MIN_VALUE;
        for (int[] dir : directions) {
            cost = Math.max(cost, 
                   backtrack(fruits, n, directions, i+dir[0], j+dir[1], moves-1, memo)
                  );
        }
        
        memo[i][j] = cost + fruits[i][j];
        return memo[i][j];
    }
}",1460898699
he zhong miao,ko1you22,354,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        a = ord('a')
        n = len(s)
        ans = 0

        def helper(sc, st, f) :
            ans = 0
            if f == 1 :
                while sc != st :
                    ans += nextCost[sc]
                    sc += 1
                    sc %= 26
            else :
                while sc != st :
                    ans += previousCost[sc]
                    sc += -1
                    sc = (sc+26) % 26
            return ans
                
                    
        
        for i in range(n) :
            sc = ord(s[i]) - a
            tc = ord(t[i]) - a
            cnt1 = cnt2 = 0
            if sc == tc :
                continue
                
            ans += min(helper(sc, tc, 1), helper(sc, tc, -1))
        return ans",1460877628
he zhong miao,ko1you22,354,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cnt = 10
        ans = False
        while n >= cnt:
            n -= cnt
            ans = not ans
            cnt -= 1

        return ans",1460877406
he zhong miao,ko1you22,354,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        ans = 0
        for i in range(n) :
            ans += fruits[i][i]

        @cache
        def dfs1(i, j) :
            if i == n-1 :
                if j != n-1 : return -inf
                return 0
            if i >= n or j >= n or i == j : return -inf
                
            r = -inf
            for dj in [-1, 0, 1] :
                r = max(r, dfs1(i+1, j+dj) + fruits[i][j])
            return r

        @cache
        def dfs2(i, j) :
            if j == n-1 :
                if i != n-1 : return -inf
                return 0
            if i >= n or j >= n or i == j : return -inf

            r = -inf
            for di in [-1, 0, 1] :
                r = max(r, dfs2(i+di, j+1) + fruits[i][j])
            return r

        
        r1 = dfs1(0, n-1)
        r2 = dfs2(n-1, 0)

        # print(ans, r1, r2)

        dfs1.cache_clear()
        dfs2.cache_clear()
            
            
        return ans + r1 + r2",1460893165
Jason,Jason0704,357,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long res = 0;
        for (int i = 0; i < n; i++) {
            int j = s[i] - 'a';
            long long c1 = 0, c2 = 0;
            while (j != t[i] - 'a') {
                c1 += nextCost[j];
                j = (j + 1) % 26;
            }
            j = s[i] - 'a';
            while (j != t[i] - 'a') {
                c2 += previousCost[j];
                j = (j - 1 + 26) % 26;
            }
            res += min(c1, c2);
        }
        return res;
    }
};",1460815998
Jason,Jason0704,357,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool res = false;
        int cnt = 10;
        while (n >= cnt) {
            n -= cnt;
            cnt--;
            res = !res;
        }
        return res;
    }
};",1460800749
Jason,Jason0704,357,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res = 0;
        int n = fruits.size();
        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         cout<<setw(3)<<fruits[i][j]<<"" "";
        //     }cout<<endl;
        // }cout<<endl;
        
        // A (0, 0)
        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
        }
        
        // B (n - 1, 0)
        vector<vector<int> > b(n, vector<int> (n, 0));
        b[n - 1][0] = fruits[n - 1][0];
        for (int j = 1, start = n - 2; j < n; j++) {
            for (int i = max(start, j + 1); i < n; i++) {
                if (i - 1 >= 0) b[i][j] = max(b[i][j], b[i - 1][j - 1]);
                b[i][j] = max(b[i][j], b[i][j - 1]);
                if (i + 1 < n) b[i][j] = max(b[i][j], b[i + 1][j - 1]);
                b[i][j] += fruits[i][j];
            }
            start = max(start - 1, (n + 1) / 2);
        }
        res += b[n - 1][n - 2];
        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         cout<<setw(3)<<b[i][j]<<"" "";
        //     }cout<<endl;
        // }cout<<endl;
        
        // C (0, n - 1)
        vector<vector<int> > c(n, vector<int> (n, 0));
        c[0][n - 1] = fruits[0][n - 1];
        for (int i = 1, start = n - 2; i < n; i++) {
            for (int j = max(start, i + 1); j < n; j++) {
                if (j - 1 >= 0) c[i][j] = max(c[i][j], c[i - 1][j - 1]);
                c[i][j] = max(c[i][j], c[i - 1][j]);
                if (j + 1 < n) c[i][j] = max(c[i][j], c[i - 1][j + 1]);
                c[i][j] += fruits[i][j];
            }
            start = max(start - 1, (n + 1) / 2);
        }
        res += c[n - 2][n - 1];
        // for (int i = 0; i < n; i++) {
        //     for (int j = 0; j < n; j++) {
        //         cout<<setw(3)<<c[i][j]<<"" "";
        //     }cout<<endl;
        // }
        return res;
    }
};",1460893771
soonsu,soonsu,358,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        shift_cost = [[0] * 26 for _ in range(26)]
        def get_shift_cost(i, j):
            if i == j:
                return 0
            # d -> a
            # 3 -> 0
            elif i > j:
                # previous
                previous = sum(previousCost[j+1:i+1])
                # d -> c -> b -> a
                # next
                # d -> e -> ... -> z -> a
                next = sum(nextCost[i:]) + sum(nextCost[:j])
            else:
                # b -> d baz
                previous = sum(previousCost[:i+1]) + sum(previousCost[j+1:])
                next = sum(nextCost[i:j])
            return min(previous, next)
        for i in range(26):
            for j in range(26):
                shift_cost[i][j] = get_shift_cost(i, j)
        results = 0
        for i in range(len(s)):
            x = ord(s[i]) - ord('a')
            y = ord(t[i]) - ord('a')
            results += shift_cost[x][y]
            # print(i, shift_cost[x][y])
        return results",1460838241
soonsu,soonsu,358,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        i = 10
        result = True
        while n >= 0:
            n -= i
            if result:
                result = False
            else:
                result = True
            i -= 1
        return result",1460801473
soonsu,soonsu,358,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        first_child = sum([fruits[i][i] for i in range(n)])
        second_dp = [[0] * n for _ in range(n)]
        third_dp = [[0] * n for _ in range(n)]
        @cache
        def second_get_dp(x, y):
            if second_dp[x][y] != 0:
                return second_dp[x][y]
            if x + y < n-1:
                second_dp[x][y] = -10**8
                return -10**8
            if x == 0:
                if y < n-1:
                    second_dp[x][y] = -10**8
                    return -10**8
                else:
                    second_dp[x][y] = fruits[x][y]
                    return fruits[x][y]
            if second_dp[x-1][y] != 0:
                v1 = second_dp[x-1][y]
            else:
                v1 = second_get_dp(x-1, y)
            if second_dp[x-1][y-1] != 0:
                v2 = second_dp[x-1][y-1]
            else:
                v2 = second_get_dp(x-1, y-1)
            if y < n-1:
                if second_dp[x-1][y+1] != 0:
                    v3 = second_dp[x-1][y+1]
                else:
                    v3 = second_get_dp(x-1, y+1)
            else:
                v3 = 0
            second_dp[x][y] = max(v1, v2, v3) + fruits[x][y]
            return second_dp[x][y]
        @cache
        def third_get_dp(x, y):
            if third_dp[x][y] != 0:
                return third_dp[x][y]
            if x + y < n-1:
                third_dp[x][y] = -10**8
                return -10**8
            if y == 0:
                if x < n-1:
                    third_dp[x][y] = -10**8
                    return -10**8
                else:
                    third_dp[x][y] = fruits[x][y]
                    return fruits[x][y]
            if third_dp[x][y-1] != 0:
                v1 = third_dp[x][y-1]
            else:
                v1 = third_get_dp(x, y-1)
            if third_dp[x-1][y-1] != 0:
                v2 = third_dp[x-1][y-1]
            else:
                v2 = third_get_dp(x-1, y-1)
            if x < n-1:
                if third_dp[x+1][y-1] != 0:
                    v3 = third_dp[x+1][y-1]
                else:
                    v3 = third_get_dp(x+1, y-1)
            else:
                v3 = 0
            third_dp[x][y] = max(v1, v2, v3) + fruits[x][y]
            return third_dp[x][y]
        value1 = second_get_dp(n-2, n-1)
        value2 = third_get_dp(n-1, n-2)
        # print(first_child, value1, value2)
        return first_child + value1 + value2",1460870836
ProblemSolver,theesoteric,359,3591,javascript,"/**
 * @param {string} s
 * @param {string} t
 * @param {number[]} nextCost
 * @param {number[]} previousCost
 * @return {number}
 */
var shiftDistance = function(s, t, nextCost, previousCost) {
    let distArr = [], memo = new Map();
    for(let i=0; i<26; i++){
        distArr[i] = Array(26).fill(Number.MAX_SAFE_INTEGER);
        let next = i+1, prev = i-1;
        if(next === 26){
            next = 0;
        }
        if(prev === -1){
            prev = 25;
        }
        distArr[i][next] = nextCost[i];
        distArr[i][prev] = previousCost[i];
    }
    for(let k=0; k<26; k++){
        for(let i=0; i<26; i++){
            for(let j=0; j<26; j++){
                distArr[i][j] = Math.min(distArr[i][j],distArr[i][k]+distArr[k][j]);
            }
        }
    }
    //console.log(distArr);
    let ans = dfs(0,0);
    //console.log(""ans"",ans);
    return ans;
    
    function dfs(i,j){
        let key = i+""_""+j;
        if(memo.has(key)){
            return memo.get(key);
        }
        if(i === s.length){
            return 0;
        }
        let res;
        if(s[i] === t[j]){
            res =  dfs(i+1,j+1);
        }else{
            let iIndex = s.charCodeAt(i)-""a"".charCodeAt(0);
            let jIndex = t.charCodeAt(j)-""a"".charCodeAt(0);
            res =  dfs(i+1,j+1)+distArr[iIndex][jIndex];
        }
        memo.set(key,res);
        return res;
    }
};",1460832031
ProblemSolver,theesoteric,359,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int limit = 10, player = 1;
        while(n>=limit){
            n -= limit;
            limit--;
            player++;
        }
        if(player%2 == 0){
            return true;
        }
        return false;
    }
}",1460798814
ProblemSolver,theesoteric,359,3648,javascript,"/**
 * @param {number[][]} fruits
 * @return {number}
 */
var maxCollectedFruits = function(fruits) {
    let n = fruits.length;
    let dx1 = [[1,-1],[1,0],[1,1]];
    let dx2 = [[-1,1],[0,1],[1,1]];
    let max1 = 0, max2 = 0;
    let count1=0, count2=0, count=0;
    let memo = new Map();
    count1 = dfs1(0,n-1,0);
    memo = [];
    memo = new Map();
    count2 = dfs2(n-1,0,0);
    for(let i=0; i<n; i++){
        //console.log(""i,i,fruits[i][i]"",i,i,fruits[i][i])
        count += fruits[i][i];
    }
    //console.log(""count,count1,count2"",count,count1,count2)
    return count+count1+count2-2*fruits[n-1][n-1];
    function dfs1(i,j,steps){
        let key = i+""_""+j+""_""+steps;
        if(memo.has(key)){
            return memo.get(key);
        }
        //console.log(""i,j,steps"",i,j,steps)
        let max = -1;
        if(steps === n-1 && (i === n-1 && j === n-1)){
            max = fruits[i][j];
            return max;
            //max = Math.max(max,sum);
        }else if(steps === n-1 || (i === n-1 && j === n-1)){
            return max;
        }else{
            for(let d=0; d<dx1.length; d++){
            let row = i+dx1[d][0];
            let col = j+dx1[d][1];
            if(row>=0 && row<n && col>=0 && col<n && (col>row || (col===n-1 && row === n-1))){
                let res = dfs1(row,col,steps+1);
                if(res !== -1){
                    max = Math.max(max,fruits[i][j]+res);
                }
            }
        }
        }
        memo.set(key,max);
        return max;
    }

    function dfs2(i,j,steps){
        let key = i+""_""+j+""_""+steps;
        if(memo.has(key)){
            return memo.get(key);
        }
        let max = -1;
        if(steps === n-1 && (i === n-1 && j === n-1)){
            max = fruits[i][j];
            return max;
            //max = Math.max(max,sum);
        }
        if(steps === n-1 || (i === n-1 && j === n-1)){
            return max;
        }
        for(let d=0; d<dx2.length; d++){
            let row = i+dx2[d][0];
            let col = j+dx2[d][1];
            if(row>=0 && row<n && col>=0 && col<n && (row>col || (col===n-1 && row === n-1))){
                let res = dfs2(row,col,steps+1);
                if(res !== -1){
                    max = Math.max(max,fruits[i][j]+res);
                }
            }
        }
        memo.set(key,max);
        return max;
    }
};",1460900319
kid_de,kid_de,360,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
      long long ans = 0;
      int n = s.size();
      long long temp1 , temp2;
      for(int i=0;i<n;i++){
        if(s[i] == t[i]) continue;

        int val_s = s[i] - 'a';
        int val_t = t[i] - 'a';
        int diff = abs(val_s - val_t);

        temp1 = 0;
        temp2 =0;
        while(val_s != val_t){
          temp1 += nextCost[val_s];
          val_s++;
          if(val_s == 26) val_s = 0;
        }

        val_s = s[i] - 'a';
        while(val_s != val_t){
          temp2 += previousCost[val_s];
          val_s--;
          if(val_s < 0) val_s = 25;
        }
 
        ans += min(temp1 , temp2);
      }
      return ans;
    }
};",1460826880
kid_de,kid_de,360,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
      int alice = 1;
      int val = 10;
      while(1){
        if(n < val){
          if(alice == 1) return false;
          else return true;
        }    
        n -= val;
        val--;
        if(alice == 1) alice = 0;
        else alice = 1;
      }  

      return true;
    }
};",1460797597
kid_de,kid_de,360,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
      int r = fruits.size();
      int c = fruits[0].size();
      int ans = 0;
      for(int i=0;i<r;i++){    // start at [0][0]
        ans += fruits[i][i];
        fruits[i][i] = 0;  
      }
     
      int arr2[r][c];          // start at [0][c-1]
      for(int i=r-1;i>=0;i--){
        for(int j=c-1;j>=0;j--){
          if(i==r-1) arr2[i][j] = fruits[i][j];
          else{
            //int rest_step = (r-i-1) + (c-j-1);
               
            int v1 = fruits[i][j],v2 = fruits[i][j],v3 = fruits[i][j];
            if(j+1<r )   v1 += arr2[i+1][j+1];
            if(j > i+1 ) v2 += arr2[i+1][j];
            if(j-1>=0 && j-1>i+1) v3 += arr2[i+1][j-1];
            arr2[i][j] = max(v1,v2);
            arr2[i][j] = max(arr2[i][j] , v3);
          }
        }
      }
        /*
      printf(""arr2[][] : \n"");
      for(int i=0;i<r;i++){
        for(int j=0;j<c;j++){
          printf(""%d "",arr2[i][j]);
        }
        printf(""\n"");
      }
      */
        
      int arr3[r][c];     // start at [n-1][0]
      for(int j=c-1;j>=0;j--){
        for(int i=r-1;i>=0;i--){
          if(j==c-1) arr3[i][j] = fruits[i][j];
          else{
            int v1 = fruits[i][j],v2 = fruits[i][j],v3 = fruits[i][j];
            if(i+1<r && i+1>j+1) v1 += arr3[i+1][j+1];
            if(i > j+1)  v2 += arr3[i][j+1];
            if(i-1>=0 && i-1>j+1) v3 += arr3[i-1][j+1];
              
            arr3[i][j] = max(v1,v2);
            arr3[i][j] = max(arr3[i][j] , v3);
          }
        }
      }
        /*
      printf(""arr3[][] : \n"");
      for(int i=0;i<r;i++){
        for(int j=0;j<c;j++){
          printf(""%d "",arr3[i][j]);
        }
        printf(""\n"");
      }
        */
        
      ans += arr2[0][c-1];
      ans += arr3[r-1][0];

      return ans;
    }
};",1460895033
am_607,am_607,361,3591,cpp,"class Solution {
public:
    typedef long long ll;
    long long shiftDistance(string s, string t, vector<int>& nn, vector<int>& pp) {
        int n=s.size();
        ll sum=0;
        for(int i=0;i<n;i++){
            int ff= s[i]-'a';
            int ss=t[i]-'a';
            
            if(ff==ss)continue;
            if(ff<ss){
                int fi=ff;
                int si=ss;
                
                
                ll nex=0,pre=0;
                
                while(fi!=si){
                    nex+=nn[fi];
                    fi++;
                }
                
                 fi=ff;
                 si=ss;
                
                while(fi>=0){
                    pre+=pp[fi];
                    fi--;
                }
                fi=25;
                while(fi!=si){
                    pre+=pp[fi];
                    fi--;
                }
                
                sum+=min(nex,pre);
            }
            else{
                
                int fi=ff;
                int si=ss;
                
                
                ll nex=0,pre=0;
                
                while(fi!=si){
                    pre+=pp[fi];
                    fi--;
                }
                fi=ff;
                 si=ss;
                while(fi<=25){
                    nex+=nn[fi];
                    fi++;
                }
                fi=0;
                while(fi!=si){
                     nex+=nn[fi];
                    fi++;
                }
                    
 
                sum+=min(nex,pre);
            }
        }
        return sum;
    }
};",1460828938
am_607,am_607,361,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int a=1;
        for(int i=10;i>=1;i--){
            if(n<i){
                if(a==1)return false;
                else return true;
            }
            n-=i;
            a=!a;
        }
        return true;
    }
};",1460796467
am_607,am_607,361,3648,cpp,"class Solution {
public:
    int dp[1001][1001];
    
    int f(int i, int j, vector<vector<int>>& a){
        int n=a.size();
        if(i==n-1 and j==n-1)return a[n-1][n-1];
        
        int ld=a[i][j],d=a[i][j],rd=a[i][j];
        if(dp[i][j]!=-1)return dp[i][j];
        if(i+1<n and j-1>=0 and j-1>i+1)
            ld+=f(i+1, j-1,a);
        if(i+1<n and j<n and i+1<j)
            d+=f(i+1, j,a);
        
        if(i+1<n and j+1<n and i+1<j+1)
            rd+=f(i+1, j+1,a);
        
        return dp[i][j]=max(ld, max(d,rd));
        
        
    }
    
     int ff(int i, int j, vector<vector<int>>& a){
        int n=a.size();
        if(i==n-1 and j==n-1)return a[n-1][n-1];
        
        int u=a[i][j],r=a[i][j],d=a[i][j];
        if(dp[i][j]!=-1)return dp[i][j];
        if(j+1<n and i-1>=0 and i-1>j+1)u+=ff(i-1, j+1,a);
         
        if(j+1<n and i<n and i>j+1)d+=ff(i, j+1,a);
        
        if(i+1<n and j+1<n and i+1>j+1)r+=ff(i+1, j+1,a);
        
        return dp[i][j]=max(u, max(d,r));
        
        
    }
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n=a.size(), m=a[0].size();

        memset(dp,-1,sizeof(dp));
        
        int sum1= f(0,n-1,a);
        
        memset(dp,-1,sizeof(dp));
        int sum2= ff(n-1,0,a);
        
        

        
        
        int sum=sum1+sum2;
        int sum3=0;
        for(int i=0;i<n;i++){
            sum3+=a[i][i];
        }
        // cout<<sum1<<"" ""<<sum2<<"" ""<<sum3<<endl;
        sum+=sum3;
        // sum-=2*a[n-1][n-1];
        return sum;
        
    }
};",1460895185
holer,holer,362,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<ll> pref(27);
        for (int i = 0; i < 26; ++i) {
            pref[i + 1] = pref[i] + nextCost[i];
        }
        vector<ll> suff(27);
        for (int i = 26; i > 0; --i) {
            suff[i - 1] = suff[i] + previousCost[i - 1];
        }
        int n = s.length();
        ll res = 0;
        for (int i = 0; i < n; ++i) {
            int tt = t[i] - 'a';
            int ss = s[i] - 'a';
            if (tt == ss) continue;
            ll cost_l = tt < ss ? suff[tt + 1] - suff[ss + 1] : suff[0] - suff[ss + 1] + suff[tt + 1]; 
            ll cost_r = tt > ss ? pref[tt] - pref[ss] : pref[26] - pref[ss] + pref[tt];
            
            res += min(cost_l, cost_r);
        }
        return res;
    }
};",1460871287
holer,holer,362,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i = 0;
        for (int cur = 10; n >= 0; ++i, cur--) {
             n -= cur;
        }
        return i % 2 == 0;
    }
};",1460871476
holer,holer,362,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size(), res = fruits[0][n - 1] + fruits[n - 1][0];
        for (int i = 0; i < n; ++i) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        fruits[0][n - 1] = 0;
        fruits[n - 1][0] = 0;

        int dp[n][n];
        auto dfs = [&](auto&& dfs, int i, int j) -> int {
            if (i == n - 1 && j == n - 1) return 0;
            if (max(i, n - 1 - j) + max(n - 1 - i, n - 1 - j) > n - 1) return dp[i][j] = -1e9;
            if (dp[i][j] != -1) return dp[i][j];
            int l = fruits[i + 1][j - 1] + dfs(dfs, i + 1, j - 1);
            int d = fruits[i + 1][j] + dfs(dfs, i + 1, j);
            int r = j + 1 < n ? fruits[i + 1][j + 1] + dfs(dfs, i + 1, j + 1) : 0;
            return dp[i][j] = max(l, max(d, r));
        };

        auto dfs2 = [&](auto&& dfs2, int i, int j) {
            if (i == n - 1 && j == n - 1) return 0;
            if (max(n - 1 - i, j) + max(n - 1 - i, n - 1 - j) > n - 1) return dp[i][j] = -1e9;
            if (dp[i][j] != -1) return dp[i][j];
            int t = fruits[i - 1][j + 1] + dfs2(dfs2, i - 1, j + 1);
            int m = fruits[i][j + 1] + dfs2(dfs2, i, j + 1);
            int d = i + 1 < n ? fruits[i + 1][j + 1] + dfs2(dfs2, i + 1, j + 1) : 0;
            return dp[i][j] = max(t, max(m, d));
        };

        memset(dp, -1, sizeof(dp));
        // cout << res << ' ';
        res += dfs(dfs, 0, n - 1);
        // cout << res << ' ';
        memset(dp, -1, sizeof(dp));
        res += dfs2(dfs2, n - 1, 0);
        // cout << res << ' ';
        
        return res;
    }
};",1460895377
Daksh Sahani,DakshSahani,363,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nextC = [[0] * 26 for _ in range(26)] 
        prevC = [[0] * 26 for _ in range(26)] 

        for i in range(26):
            nextC[i][i] = 0
            j = (i+1) % 26
            while j!=i:
                nextC[i][j] = nextC[i][(j-1) % 26] + nextCost[(j-1) % 26]
                j = (j+1)%26
                
        for i in range(26):
            prevC[i][i] = 0
            j = (i-1) % 26
            while j!=i:
                prevC[i][j] = prevC[i][(j+1)%26] + previousCost[(j+1)%26]
                j = (j-1)%26

        # print(prevC)

        ans = 0
        for i in range(len(s)):
            i1 = ord(s[i]) - ord('a')
            i2 = ord(t[i]) - ord('a')
            # print(i1-i2, nextC[i1][i2], prevC[i1][i2])
            ans += min(nextC[i1][i2], prevC[i1][i2])
        
        return ans",1460836637
Daksh Sahani,DakshSahani,363,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        ans = False
        while n:
            if n < cur:
                return ans
            n -= cur
            cur -= 1
            ans = not ans
        return ans",1460800407
Daksh Sahani,DakshSahani,363,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        dp = [[-1]*n for _ in range(n)]
        M = 10**9 + 7
        def solve(i, j):
            if i==n-1 and j==n-1:
                # print(i, j, sep=',', end=' ')
                return 0
            if i<0 or i>=n or j<0 or j>=n:
                return -M
            if not(i<j and i+j>=n-1):
                return -M
            # print(i, j, sep=',', end=' ')
            if dp[i][j] != -1:
                return dp[i][j]

            dp[i][j] = fruits[i][j] + max(
                solve(i+1, j+1),
                solve(i+1, j-1),
                solve(i+1, j)
            )
            return dp[i][j]
        
        def solve2(i, j):
            # print(i, j, sep=',', end=' ')
            if i==n-1 and j==n-1:
                return 0
            if i<0 or i>=n or j<0 or j>=n:
                return -M
            if not(i>j and i+j>=n-1):
                return -M
            if dp[i][j] != -1:
                return dp[i][j]

            dp[i][j] = fruits[i][j] + max(
                solve2(i-1, j+1),
                solve2(i, j+1),
                solve2(i+1, j+1)
            )
            return dp[i][j]
         

        x1 = solve(0, n-1)
        # print(dp)
        dp = [[-1]*n for _ in range(n)]
        x2 = solve2(n-1, 0)
        # print(dp)
        x3 = 0
        for i in range(n):
            x3 += fruits[i][i]
        print(x1, x2, x3)
        return x1 + x2 + x3

        ",1460900994
stevenhgs,stevenhgs,364,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        min_costs = [[inf for _ in range(26)] for _ in range(26)]
        for i in range(26):
            min_costs[i][i] = 0

        for origin in range(26):
            for distance in range(1, 26):
                ahead_index = (origin + distance) % 26
                prev_ahead_index = (ahead_index - 1) % 26
                min_costs[origin][ahead_index] = min(min_costs[origin][ahead_index], min_costs[origin][prev_ahead_index] + nextCost[prev_ahead_index])
                prev_index = (origin - distance) % 26
                prev_prev_index = (prev_index + 1) % 26
                min_costs[origin][prev_index] = min(min_costs[origin][prev_index], min_costs[origin][prev_prev_index] + previousCost[prev_prev_index])

        n = len(s)
        ord_a = ord('a')
        cost = 0
        for i in range(n):
            s_char = s[i]
            t_char = t[i]
            s_i = ord(s_char) - ord_a
            t_i = ord(t_char) - ord_a
            cost += min_costs[s_i][t_i]

        return cost
        
            ",1460821294
stevenhgs,stevenhgs,364,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        to_take = 10
        alice = True
        while to_take <= n:
            n -= to_take
            alice = not alice
            to_take -= 1
        return not alice
        ",1460798391
stevenhgs,stevenhgs,364,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        
        first_score = 0
        for i in range(n):
            first_score += fruits[i][i]
            fruits[i][i] = 0

        dp = [[0 for _ in range(n)] for _ in range(n)]
        dp[n - 1][0] = fruits[n - 1][0]
        for i in range(1, n):
            max_height = min(i, n - i - 1)
            for h in range(max_height + 1):
                for dh in range(3):
                    real_dh = dh - 1
                    if 0 <= n - h - 1 + real_dh < n:
                        dp[n - h - 1][i] = max(dp[n - h - 1][i], dp[n - h - 1 + real_dh][i-1])
                dp[n - h - 1][i] += fruits[n - h - 1][i]
        second_score = dp[n-1][n - 1]

        dp = [[0 for _ in range(n)] for _ in range(n)]
        dp[0][n - 1] = fruits[0][n - 1]
        for i in range(1, n):
            max_height = min(i, n - i - 1)
            for h in range(max_height + 1):
                for dh in range(3):
                    real_dh = dh - 1
                    if 0 <= n - h - 1 + real_dh < n:
                        dp[i][n - h - 1] = max(dp[i][n - h - 1], dp[i-1][n - h - 1 + real_dh])
                dp[i][n - h - 1] += fruits[i][n - h - 1]
        third_score = dp[n-1][n - 1]
        
        return first_score + second_score + third_score",1460901005
Safal Kumar,_safalkumar_,365,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<long long> next(26);
        vector<long long> prev(26);
        long long a=0,b=0;
        for(int i=0;i<26;i++){
            a+=(long long)nextCost[i];
            b+=(long long)previousCost[i];
            next[i]=a;
            prev[i]=b;
        }
        
        int n=s.size();
        long long ans=0;
        
        for(int i=0;i<n;i++){
            int p=s[i]-'a';
            int q=t[i]-'a';
            if(p==q) continue;
            else if(p<q){
                long long s1=next[q-1] - (p>0 ? next[p-1]:0);
                long long s2=(prev[25]-prev[q]) + prev[p];
                ans+=min(s1,s2);
            }
            else if(p>q){
                long long s1=prev[p]-prev[q];
                long long s2=(next[25]-next[p-1])+ (q>0 ? next[q-1]:0);
                ans+=min(s1,s2);
            }
        }
        return ans;
    }
};",1460860645
Safal Kumar,_safalkumar_,365,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10) return false;
        if(n<19) return true;
        if(n<27) return false;
        if(n<34) return true;
        if(n<40) return false;
        if(n<45) return true;
        if(n<49) return false;
        return true;
    }
};",1460810026
Safal Kumar,_safalkumar_,365,3648,cpp,"class Solution {
public:
    int f1(int i,int j,vector<vector<int>>& fruits,int &n,vector<vector<int>>& a){
        if(i==n-1 && j==n-2) return fruits[i][j];
        if(i<=j || i>=n) return 0;
        if(a[i][j]!=-1) return a[i][j];
        int p=f1(i-1,j+1,fruits,n,a)+fruits[i][j];
        int q=f1(i,j+1,fruits,n,a)+fruits[i][j];
        int r=f1(i+1,j+1,fruits,n,a)+fruits[i][j];
        
        return a[i][j]=max(p,max(q,r));
    }
    int f2(int i,int j,vector<vector<int>>& fruits,int &n,vector<vector<int>>& b){
        if(i==n-2 && j==n-1) return fruits[i][j];
        if(j<=i || j>=n) return 0;
        if(b[i][j]!=-1) return b[i][j];
        int p=f2(i+1,j-1,fruits,n,b)+fruits[i][j];
        int q=f2(i+1,j,fruits,n,b)+fruits[i][j];
        int r=f2(i+1,j+1,fruits,n,b)+fruits[i][j];
        
        return b[i][j]=max(p,max(q,r));
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n=fruits.size();
        int ans=0;
        for(int i=0;i<n;i++){
            ans+=fruits[i][i];
        }
        vector<vector<int>> a(n,vector<int>(n,-1));
        vector<vector<int>> b(n,vector<int>(n,-1));
        
        ans+=f1(n-1,0,fruits,n,a);
        ans+=f2(0,n-1,fruits,n,b);
        
        return ans;
    }
};",1460895440
Saikat Ghosh,saikat93ify,366,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) 
    {
        const int NO_OF_ALPHABETS = 26; 
        const long long oo = 1e18;
        vector <vector <long long> > minimumCost(NO_OF_ALPHABETS, vector <long long> (NO_OF_ALPHABETS)); 
        for(int alpha1 = 0; alpha1 < NO_OF_ALPHABETS; alpha1++)
        {
            for(int alpha2 = 0; alpha2 < NO_OF_ALPHABETS; alpha2++)
            {
                if(alpha1 == alpha2)
                {
                    minimumCost[alpha1][alpha2] = 0;
                    continue;
                }
                
                long long forward_cost = 0; 
                for(int i = alpha1; i != alpha2; i = (i + 1)%NO_OF_ALPHABETS)
                {
                    forward_cost += nextCost[i];
                }
                
                long long backward_cost = 0; 
                for(int i = alpha1; i != alpha2; i = (i - 1 + NO_OF_ALPHABETS)%NO_OF_ALPHABETS)
                {
                    backward_cost += previousCost[i];
                }
                
                minimumCost[alpha1][alpha2] = min(forward_cost, backward_cost);
            }
        }
        
        long long distance = 0; 
        for(int i = 0; i < s.size(); i++)
        {
            distance += minimumCost[s[i] - 'a'][t[i] - 'a'];
        }
        
        return distance;
    }
};",1460882042
Saikat Ghosh,saikat93ify,366,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) 
    {
        int move = 10; 
        while(move <= n && move > 0)
        {
            n -= move;
            move--;
        }
        
        return (move%2 == 1);
    }
};",1460884209
Saikat Ghosh,saikat93ify,366,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) 
    {
        int n = fruits.size(); 
        
        int score_green = 0; 
        for(int i = 0; i < n; i++)
        {
            score_green += fruits[i][i];
            fruits[i][i] = 0;
        } 
        
        
        const int oo = -1e6;
        vector <vector <int> > score_red(n, vector <int> (n, 0)); 
        for(int r = n - 2; r >= 0; r--)
        {
            for(int c = n - 1; c > r; c--)
            {
                int best_neighbour = 0;
                
                const int NO_OF_NEIGHBOURS = 3; 
                vector <int> neighbour_offset({-1, 0, 1}); 
                for(int i = 0; i < neighbour_offset.size(); i++)
                {
                    int neighbour_c = c + neighbour_offset[i];
                    if(r < neighbour_c && neighbour_c <= n - 1)
                    {
                       // cout << r << "","" << neighbour_c << "" is a neighbour of ("" << r << "",""<< c << "")\n"";
                        best_neighbour = max(best_neighbour, score_red[r + 1][neighbour_c]);
                    }
                }
                
                score_red[r][c] = fruits[r][c] + best_neighbour;
                //cout << ""Best Red ("" << r << "","" << c << "") = "" << best_neighbour << ""  Overall = "" << score_red[r][c] << ""\n"";
            }
        }
        
        vector <vector <int> > score_blue(n, vector <int> (n, 0)); 
        for(int c = n - 1; c >= 0; c--)
        {
            for(int r = n - 1; r > c; r--)
            {
                int best_neighbour = 0;
                
                const int NO_OF_NEIGHBOURS = 3; 
                vector <int> neighbour_offset({-1, 0, 1}); 
                for(int i = 0; i < neighbour_offset.size(); i++)
                {
                    int neighbour_r = r + neighbour_offset[i];
                    if(c < neighbour_r && neighbour_r <= n - 1)
                    {
                        best_neighbour = max(best_neighbour, score_blue[neighbour_r][c + 1]);
                    }
                }
                
                score_blue[r][c] = fruits[r][c] + best_neighbour;
                //cout << ""Best Blue ("" << r << "","" << c << "") = "" << best_neighbour << ""  Overall = "" << score_blue[r][c] << ""\n"";
            }
        }
        
        int score = score_green + score_red[0][n - 1] + score_blue[n - 1][0];
        return score;
    }
};",1460868255
Sarvagya Sharma,sarvagya2545,367,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        vector<long long> prevCostPrefixSum(27, 0LL), nextCostPrefixSum(27, 0LL);
        
        for(char c = 'a'; c <= 'z'; c++) {
            prevCostPrefixSum[(c - 'a') + 1] = prevCostPrefixSum[c - 'a'] + previousCost[c - 'a'];
            nextCostPrefixSum[(c - 'a') + 1] = nextCostPrefixSum[c - 'a'] + nextCost[c - 'a'];
        }
        
        vector<vector<long long>> cost(26, vector<long long> (26));
        for(char c = 'a'; c <= 'z'; c++) {
            for(char d = 'a'; d <= 'z'; d++) {
                long long forwardCost = (c <= d ? 
                         nextCostPrefixSum[(d - 'a')] - nextCostPrefixSum[c - 'a'] :
                         nextCostPrefixSum[26] - nextCostPrefixSum[c - 'a'] + nextCostPrefixSum[d - 'a']);
                
                long long backwardCost = (c < d ? 
                         prevCostPrefixSum[(c - 'a') + 1] + (prevCostPrefixSum[26] - prevCostPrefixSum[(d - 'a') + 1]) :
                         prevCostPrefixSum[(c - 'a') + 1] - prevCostPrefixSum[(d - 'a') + 1]);
                
                cost[c - 'a'][d - 'a'] = min(forwardCost, backwardCost);
            }
        }
        
        long long totalCost = 0LL;
        for(int i = 0; i < n; i++) {
            totalCost += cost[s[i] - 'a'][t[i] - 'a'];
        }
        
        return totalCost;
    }
};",1460843053
Sarvagya Sharma,sarvagya2545,367,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int res = 0;
        int cur = 10;
        
        while(n >= cur) {
            n -= cur;
            res = 1 - res;
            cur--;
        }
        
        return res;
    }
};",1460798161
Sarvagya Sharma,sarvagya2545,367,3648,cpp,"class Solution {
public:
    int NEG_INF = -1e9;
    int solve1(vector<vector<int>>& fruits) {
        int n = fruits.size();
        
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for(int row = 0; row < n; row++) dp[row][n - 1] = NEG_INF;
        dp[n - 1][n - 1] = 0;
        
        for(int col = n - 2; col >= 0; col--) {
            for(int row = 0; row < n; row++) {
                dp[row][col] = fruits[row][col] + max({
                    dp[row][col + 1],
                    row > 0 ? dp[row - 1][col + 1] : NEG_INF,
                    row < n - 1 ? dp[row + 1][col + 1] : NEG_INF
                });
            }
        }
        
        return dp[n - 1][0];
    }
    
    int solve2(vector<vector<int>>& fruits) {
        int n = fruits.size();
        
        vector<vector<int>> dp(n, vector<int>(n, 0));
        for(int col = 0; col < n; col++) dp[n - 1][col] = NEG_INF;
        dp[n - 1][n - 1] = 0;
        
        for(int row = n - 2; row >= 0; row--) {
            for(int col = 0; col < n; col++) {
                dp[row][col] = fruits[row][col] + max({
                    dp[row + 1][col],
                    col > 0 ? dp[row + 1][col - 1] : NEG_INF,
                    col < n - 1 ? dp[row + 1][col + 1] : NEG_INF
                });
            }
        }
        
        return dp[0][n - 1];
    }
    
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        
        int ans = 0;
        for(int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        
        return ans + solve1(fruits) + solve2(fruits);
    }
};",1460884700
Namanjr333,Namanjr_333,369,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& prev) {
        vector<vector<long long >>dp(26,vector<long long >(26,1e12));
        for(int i=0;i<26;i++){
            dp[i][i]=0;
        }
        for(int i=0;i<26;i++){
           // next[i]          // 0->1
            // prev[i]         // 1->0
            dp[i][(i+1)%26]=next[i];
            dp[i][(i-1+26)%26]= prev[i];
        }

        for(int k=0;k<26;k++){
            for(int i=0;i<26;i++){
                for(int j=0;j<26;j++){
                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
                }
            }
        }
       long long int sum=0;
        for(int i=0;i<s.size();i++){
            sum += dp[s[i]-'a'][t[i]-'a'];
        }
        return sum;
        
    }
};",1460832158
Namanjr333,Namanjr_333,369,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int ct=0;
        for(int k=10;k>=0;k--){
            if(n>=k){
                n=n-k;
                ct=k;
            }
            else{
                break;
            }
        }
        
            if(ct==0){
                return false;
            }
            return ct%2==0;
        
    }
};",1460800538
Namanjr333,Namanjr_333,369,3648,cpp,"class Solution {
public:
    int dp[1001][1001];

    int f(int i, int j, vector<vector<int>>& a) {
        int n = a.size();
        if (i < 0 || i >= n || j < 0 || j > i) {
            return -1e9;
        }
        if (j == n - 1) {
            return (i == n - 1) ? 0 : -1e9;
        }
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int up = a[i][j] + f(i - 1, j + 1, a);
        int right = a[i][j] + f(i, j + 1, a);
        int down = a[i][j] + f(i + 1, j + 1, a);

        return dp[i][j] = max({up, right, down});
    }

    int f1(int i, int j, vector<vector<int>>& a) {
        int n = a.size();
        if (i < 0 || i >= n || j < 0 || j >= n || i > j) {
            return -1e9;
        }
        if (i == n - 1) {
            return (j == n - 1) ? 0 : -1e9;
        }
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int left = a[i][j] + f1(i + 1, j - 1, a);
        int down = a[i][j] + f1(i + 1, j, a);
        int right = a[i][j] + f1(i + 1, j + 1, a);

        return dp[i][j] = max({left, down, right});
    }

    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = a.size();
        int diagonalSum = 0;

        // Sum the diagonal and logically ignore them in calculations
        for (int i = 0; i < n; i++) {
            diagonalSum += a[i][i];
            a[i][i] = 0;
        }

        // Calculate maximum fruits for both paths
        memset(dp, -1, sizeof(dp));
        int path1 = f(n - 1, 0, a);

        memset(dp, -1, sizeof(dp));
        int path2 = f1(0, n - 1, a);

        // Combine results
        return diagonalSum + path1 + path2;
    }
};
",1460890738
Zebra,dinar,370,3591,python3,"class Solution:
    def shiftDistance(self, z: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        dp1 = [[float('inf')] * 26 for _ in range(26)]
        dp2 = [[float('inf')] * 26 for _ in range(26)]
        for i in range(26):
            s = 0
            for j in range(26):
                s += nextCost[(i + j) % 26]
                dp1[i][(i + j + 1) % 26] = s
                

        for i in range(26):
            s = 0
            for j in range(26):
                s += previousCost[(i - j) % 26]
                dp2[i][(i - j - 1) % 26] = s

        ans = 0
        
        for x in range(len(z)):
            a = z[x]
            b = t[x]
            if a != b:
                i = ord(a) - ord('a')
                j = ord(b) - ord('a')

                ans += min(dp1[i][j], dp2[i][j])

        return ans",1460840289
Zebra,dinar,370,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        win = False
        d = 10
        while n >= d:
            n -= d
            d -= 1
            win ^= True
        return win",1460799918
Zebra,dinar,370,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        for i in range(len(fruits)):
            ans += fruits[i][i]
            fruits[i][i] = 0
        
        @cache
        def dfs(i=n-1, j=0):
            if i == n-1 and j == n-1: return 0
            if i >= n or j >= n or j >= i: return 0

            ans = max(dfs(i, j + 1), dfs(i-1, j + 1), dfs(i + 1, j + 1))
            ans += fruits[i][j]
            return ans


        @cache
        def dfs2(i=0, j=n-1):
            if i == n-1 and j == n-1: return 0
            if i >= n or j >= n or j <= i: return 0

            ans = max(dfs2(i + 1, j - 1), dfs2(i + 1, j), dfs2(i + 1, j + 1))
            ans += fruits[i][j]
            return ans

        return ans + dfs() + dfs2()
            ",1460902023
LAVESH AGRAWAL,case_la,372,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& ncc, vector<int>& pcc) {

        vector<long long > nc(26,0);
        vector<long long> pc(26,0);
        nc[0]=ncc[0];
        pc[0]=pcc[0];
        for(int i=1;i<26;i++){
            nc[i]+=nc[i-1]+(long long)ncc[i];
            pc[i]+=pc[i-1]+(long long)pcc[i];
        }
        
        long long ans = 0;
        for(int i =0;i<s.length();i++){
            int a = s[i]-'a';
            int b = t[i]-'a';
            if(a>b){
                ans+= min(nc[25] -nc[a-1]+ ((b!=0)?nc[b-1]:0),pc[a]-pc[b]); 
            }
            else if(a<b){
                ans+= min(nc[b-1]- ((a!=0)?nc[a-1]:0), pc[25]-pc[b]+pc[a]);
            }
        }
        return ans;
    }
};",1460835898
LAVESH AGRAWAL,case_la,372,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool a = true;
        int x = 10;

        while(n>=x){
            a=!a;
            n-=x;
            x--;
        }
            if(a)return false;
            else return true;
    }
};",1460802152
LAVESH AGRAWAL,case_la,372,3648,cpp,"class Solution {

public:
    int find(int n ,vector<vector<int>> v){
        
        for(int j = 1;j<n;j++){
            for(int i = n-1-j ; i<n;i++){
                int a=0,b=0,c=0;
                    if(j-1>=0 && i-1>=0 )a=v[i-1][j-1];
                    if(j-1>=0 && i>=0)b=v[i][j-1];
                    if(j-1>=0 && i+1<n)c = v[i+1][j-1];
                v[i][j] = v[i][j] + max(a,max(b,c));
            }
        }
        return v[n-1][n-1];
    }

    int find2(int n , vector<vector<int>> v){
        
        for(int i = 1 ;i<n;i++){
            for(int j=n-1-i;j<n;j++){
                int a=0,b=0,c=0;
                    if(i-1>=0 && j-1>=0)a=v[i-1][j-1];
                    if(i-1>=0 && j>=0)b=v[i-1][j];
                    if(i-1>=0 && j+1<n)c = v[i-1][j+1];
                v[i][j] = v[i][j] + max(a,max(b,c));
            }
        }
        return v[n-1][n-1];
    }
     int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        for(int i=0;i<n;i++){
            ans+=fruits[i][i];
            fruits[i][i]=0;
        }
        for(int i =0;i<n;i++){
            for(int j =0 ;j<n-1-i ;j++)
                fruits[i][j]=0;
        }

        ans+= find(n,fruits);
         ans+= find2(n,fruits);
         return ans;
    }
};",1460902103
aaabbbcccdddeee,chintsai,374,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        using ll = long long;
        ll f[26][26];
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                ll a = 0, b = 0;
                int x = i;
                while (x != j) {
                    a += nextCost[x];
                    x = (x + 1) % 26;
                }
                x = i;
                while (x != j) {
                    b += previousCost[x];
                    x = (x + 25) % 26;
                }
                f[i][j] = min(a, b);
            }
            f[i][i]=0;
        }

        ll res = 0;
        for (int i = 0; i < s.size(); i++) {
            long long dt = f[s[i]-'a'][t[i]-'a'];
            res+=dt;
        }
        return res;
    }
};",1460824032
aaabbbcccdddeee,chintsai,374,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) return false;
        int minus = 10;
        while (n) {
            if (n < minus) return false;
            n -= minus;
            minus--;
            if (n < minus) return true;
            n -= minus;
            minus--;
        }
        return false;
    }
};",1460797594
aaabbbcccdddeee,chintsai,374,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int res = 0;
        for (int i = 0; i < n; i++) {
            res += fruits[i][i];
            printf(""%d "", fruits[i][i]);
        }
        puts(""\n"");

        // printf(""n: %d, m: %d\n"", fruits.size(), fruits[0].size());

        for (int i = 0; i < n; i++) {
            // for (int j = 0; j < n; j++) {
                // printf(""%02d "", fruits[i][j]);
            // }
            // puts("""");
        }
        puts("""");
        
        if (n == 1) return res;
        // puts("""");
        // printf(""res: diagnal: %d\n"", res);
        
        int f[n][n];
        memset(f, 0, sizeof f);
        f[0][n-1] = fruits[0][n - 1];

        int dy[3] = {-1, 0, 1};
        
        for (int i = 1; i < n; i++) {
            for (int j = n - 1; j > max({(n - 1) / 2, i, n - i - 2}); j--) {
                for (int k = 0; k < 3; k++) {
                    int y = j + dy[k];
                    if (y >= 0 && y < n) {
                        f[i][j] = max(f[i][j], f[i - 1][y] + fruits[i][j]);
                    }
                }
                // printf(""f[%d][%d]: %d\n"", i, j, f[i][j]);
            }
        }

        int g[n][n];
        memset(g, 0, sizeof g);
        g[n - 1][0] = fruits[n - 1][0];

        int dx[3] = {-1, 0, 1};
        
        for (int j = 1; j < n; j++) {
            for (int i = n - 1; i > max({(n - 1) / 2, j, n - j - 2}); i--) {
                for (int k = 0; k < 3; k++) {
                    int x = i + dx[k];
                    if (x >= 0 && x < n) {
                        g[i][j] = max(g[i][j], g[x][j - 1] + fruits[i][j]);
                    }
                }
                // printf(""g[%d][%d]: %d\n"", i, j, g[i][j]);
            }
        }
        res += f[n - 2][n - 1] + g[n - 1][n - 2];
        return res;        
    }
};",1460886140
Abstraction,Abstraction,382,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        std::vector<std::vector<int64_t>> transformCosts(26, std::vector<int64_t>(26, 0));
        for(int src = 0; src < 26; ++src){
            std::vector<int64_t>& transform = transformCosts[src];
            int64_t prev = previousCost[src];
            int64_t next = nextCost[src];
            int prevIdx = (src+25)%26;
            int nextIdx = (src+1)%26;
            while(nextIdx != prevIdx){
                if(prev <= next){
                    transform[prevIdx] = prev;
                    prev += previousCost[prevIdx];
                    prevIdx = (prevIdx+25)%26;
                } else {
                    transform[nextIdx] = next;
                    next += nextCost[nextIdx];
                    nextIdx = (nextIdx+1)%26;
                }
            }
            transform[prevIdx] = std::min(prev, next);
        }
        int64_t ret = 0;
        for(size_t i = 0; i < s.length(); ++i){
            ret += transformCosts[s[i]-'a'][t[i]-'a'];
        }
        return ret;
    }
};",1460900225
Abstraction,Abstraction,382,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 10;
        for(; turn > 0; --turn) {
            if(n < turn) return turn%2 != 0;
            n -= turn;
        }
        return true;
    }
};",1460797885
Abstraction,Abstraction,382,3648,cpp,"class Solution {
    static int Robert(std::vector<std::vector<int>>& fruits) {
        const int N = fruits.size();
        int Mid = N/2 - 1 + N%2; //N>3, Mid >= 2
        for(int i = N-3; i >= Mid; --i){
            fruits[i][i+1] += fruits[i+1][i+2];
            if(i == N-3) {
                fruits[i][i+2] += fruits[i+1][i+2];
                continue;
            }
            fruits[i][i+2] += std::max(fruits[i+1][i+2], fruits[i+1][i+3]);
            if(i == N-4){
                fruits[i][i+3] += std::max(fruits[i+1][i+2], fruits[i+1][i+3]);
                continue;
            }
            fruits[i][N-1] += std::max(fruits[i+1][N-2], fruits[i+1][N-1]);
            for(int j = i+3; j < N-1; ++j){
                fruits[i][j] += std::max(fruits[i+1][j-1], std::max(fruits[i+1][j], fruits[i+1][j+1]));
            }
        }
        if(N%2 == 1){ //equal row: Mid = Mid-1
            --Mid;
            fruits[Mid][Mid+2] += std::max(fruits[Mid+1][Mid+2], fruits[Mid+1][Mid+3]);
            fruits[Mid][N-1] += std::max(fruits[Mid+1][N-2], fruits[Mid+1][N-1]);
            for(int j = Mid+3; j < N-1; ++j){
                fruits[Mid][j] += std::max(fruits[Mid+1][j-1], std::max(fruits[Mid+1][j], fruits[Mid+1][j+1]));
            }
        }
        for(int i = Mid - 1; i >= 0; --i){
            fruits[i][N-1] += std::max(fruits[i+1][N-2], fruits[i+1][N-1]);
            for(int j = N-1-i; j < N-1; ++j){
                fruits[i][j] += std::max(fruits[i+1][j-1], std::max(fruits[i+1][j], fruits[i+1][j+1]));
            }
        }
        return fruits[0][N-1];
    }
    static int Ginger(std::vector<std::vector<int>>& fruits) {
        int ret = 0;
        for(int i = 0; i < fruits.size(); ++i) ret += fruits[i][i];
        return ret;
    }
    static int Billy(std::vector<std::vector<int>>& fruits) {
        const int N = fruits.size();
        int Mid = N/2 - 1 + N%2; //N>3, Mid >= 2
        for(int j = N-3; j >= Mid; --j){
            fruits[j+1][j] += fruits[j+2][j+1];
            if(j == N-3) {
                fruits[j+2][j] += fruits[j+2][j+1];
                continue;
            }
            fruits[j+2][j] += std::max(fruits[j+2][j+1], fruits[j+3][j+1]);
            if(j == N-4){
                fruits[N-1][j] += std::max(fruits[N-2][j+1], fruits[N-1][j+1]);
                continue;
            }
            fruits[N-1][j] += std::max(fruits[N-2][j+1], fruits[N-1][j+1]);
            for(int i = j+3; i < N-1; ++i){
                fruits[i][j] += std::max(fruits[i-1][j+1], std::max(fruits[i][j+1], fruits[i+1][j+1]));
            }
        }
        if(N%2 == 1){ //equal row: Mid = Mid-1
            --Mid;
            fruits[Mid+2][Mid] += std::max(fruits[Mid+2][Mid+1], fruits[Mid+3][Mid+1]);
            fruits[N-1][Mid] += std::max(fruits[N-2][Mid+1], fruits[N-1][Mid+1]);
            for(int i = Mid+3; i < N-1; ++i){
                fruits[i][Mid] += std::max(fruits[i-1][Mid+1], std::max(fruits[i][Mid+1], fruits[i+1][Mid+1]));
            }
        }
        for(int j = Mid - 1; j >= 0; --j){
            fruits[N-1][j] += std::max(fruits[N-2][j+1], fruits[N-1][j+1]);
            for(int i = N-1-j; i < N-1; ++i){
                fruits[i][j] += std::max(fruits[i-1][j+1], std::max(fruits[i][j+1], fruits[i+1][j+1]));
            }
        }
        return fruits[N-1][0];
    }
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        if(fruits.size() == 2) return fruits[0][0] + fruits[0][1] + fruits[1][0] + fruits[1][1];
        if(fruits.size() == 3) {
            int ret = 0;
            ret += fruits[0][0] + fruits[1][1] + fruits[2][2];
            ret += fruits[0][2] + fruits[1][2];
            ret += fruits[2][0] + fruits[2][1];
            return ret;
        }
        int g = Ginger(fruits);
        //std::cout << ""Green: "" << g << ""\n"";
        int r = Robert(fruits);
        //std::cout << ""Red: "" << r << ""\n"";
        int b = Billy(fruits);
        //std::cout << ""Blue: "" << b << ""\n"";
        return r + g + b;
    }
};",1460888571
sasasagagaga,sasasagagaga,384,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        mod = 26
        fwd = [[10 ** 17] * mod for _ in range(mod)]
        bwd = [[10 ** 17] * mod for _ in range(mod)]
        for i in range(mod):
            fwd[i][i] = 0
            bwd[i][i] = 0
            for j in range(i + 1, mod + i):
                fwd[i][j % mod] = fwd[i][(j - 1) % mod] + nextCost[(j - 1) % mod]
            for j in range(i - 1, i - mod, -1):
                bwd[i][j % mod] = bwd[i][(j + 1) % mod] + previousCost[(j + 1) % mod]
        for row in fwd:
            print(*row, sep=' ')
        for row in bwd:
            print(*row, sep=' ')

        ans = 0
        for a, b in zip(s, t):
            a, b = map(lambda x: ord(x) - ord('a'), [a, b])
            ans += min(fwd[a][b], bwd[a][b])
        return ans
",1460832183
sasasagagaga,sasasagagaga,384,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        i = 10
        t = 0
        while n >= i:
            n -= i
            t = 1 - t
            i -= 1
        return bool(t)",1460797026
sasasagagaga,sasasagagaga,384,3648,python3,"class Solution:
    def maxCollectedFruits(self, A: List[List[int]]) -> int:
        n = len(A)
        ans = sum(A[i][i] for i in range(n))

        @functools.cache
        def dp1(r, c):
            if r == c == n - 1:
                return 0
            if r <= c < n - 1:
                return -10 ** 15
            if c < n - r - 1 or c == n - 1 and r != n - 1:
                return -10 ** 15
            if not (0 <= r < n and 0 <= c < n):
                return -10 ** 15
            return A[r][c] + max(dp1(r + dr, c + 1) for dr in [-1, 0, 1])

        ans1 = dp1(n - 1, 0)

        @functools.cache
        def dp2(r, c):
            if r == c == n - 1:
                return 0
            if n - 1 > r >= c:
                return -10 ** 15
            if r < n - c - 1 or r == n - 1 and c != n - 1:
                return -10 ** 15
            if not (0 <= r < n and 0 <= c < n):
                return -10 ** 15
            return A[r][c] + max(dp2(r + 1, c + dc) for dc in [-1, 0, 1])

        ans2 = dp2(0, n - 1)

        # print(ans, ans1, ans2)
        return ans + ans1 + ans2
",1460900528
Mohamed Bakr,Mhmd_Bakr,385,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prv) {
        vector<vector<long long>>cost(26,vector<long long>(26,1e14));
        for(int i = 0;i<26;i++){
            for(int j = 0;j<26;j++){
                long long l = 0, r = 0;
                for(int k = i;;k++){
                    if(k%26==j) break;
                    l+=nxt[k%26];
                }
                for(int k = i;;k--){
                    if((k+26)%26==j) break;
                    r+=prv[(k+26)%26];
                }
                cost[i][j] = min(l,r);
            }
        }
        long long ans = 0;
        for(int i = 0;i<s.size();i++){
            ans+=cost[s[i]-'a'][t[i]-'a'];
        }
        for(int i : cost[0]) cout<<i<<"" "";
        return ans;
    }
};",1460816537
Mohamed Bakr,Mhmd_Bakr,385,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ch = 0;
        int cur = 10;
        while(1){
            if(n<cur||n==0) return ch;
            n-=cur;
            cur--;
            ch=!ch;
        }
        return ch;
    }
};",1460797127
Mohamed Bakr,Mhmd_Bakr,385,3648,cpp,"class Solution {
public:
    vector<vector<int>>a,b;
    int n;
    int dis(int i, int j){
        return max(abs(n-1-i),abs(n-1-j));
    }
    int dp[1001][1001];
    int mx1(int i, int j){ // n-1 0
        if(i==n-1&&j==n-1) return 0;
        if(~dp[i][j]) return dp[i][j];
        int cur = 0;
        if(j+1<n&&i-1>=0){
            if(dis(i-1,j+1)<(n-1-j))
                cur=max(cur,mx1(i-1,j+1)+a[i-1][j+1]);
        }
        if(j+1<n&&i+1<n){
            if(dis(i+1,j+1)<(n-1-j))
                cur=max(cur,mx1(i+1,j+1)+a[i+1][j+1]);
        }
        if(j+1<n&&dis(i,j+1)<(n-1-j))
            cur=max(cur,mx1(i,j+1)+a[i][j+1]);
        return dp[i][j] = cur;
    }
    void build1(int i,int j){
        if(i==n-1&&j==n-1) return;
        int cur = mx1(i,j);
        if(j+1<n&&i-1>=0){
            if(dis(i-1,j+1)<(n-1-j)){
                if((mx1(i-1,j+1)+a[i-1][j+1])==cur){
                    b[i-1][j+1] = -1e5;
                    cout<<a[i-1][j+1]<<"" "";
                    build1(i-1,j+1);
                    return;
                }
            }
        }
        if(j+1<n&&i+1<n){
            if(dis(i+1,j+1)<(n-1-j)){
                if((mx1(i+1,j+1)+a[i+1][j+1])==cur){
                    b[i+1][j+1] = -1e5;
                    cout<<a[i+1][j+1]<<"" "";
                    build1(i+1,j+1);
                    return;
                }
            }
        }
        if(j+1<n&&dis(i,j+1)<(n-1-j)){
            if((mx1(i,j+1)+a[i][j+1])==cur){
                b[i][j+1] = -1e5;
                    cout<<a[i][j+1]<<"" "";
                build1(i,j+1);
                return;
            }
        }
    }

    int mx2(int i, int j){ // n-1 0
        if(i==n-1&&j==n-1) return 0;
        if(~dp[i][j]) return dp[i][j];
        int cur = 0;
        if(i+1<n&&j-1>=0){
            if(dis(i+1,j-1)<(n-1-i))
                cur=max(cur,mx2(i+1,j-1)+a[i+1][j-1]);
        }
        if(i+1<n&&j+1<n){
            if(dis(i+1,j+1)<(n-1-i))
                cur=max(cur,mx2(i+1,j+1)+a[i+1][j+1]);
        }
        if(i+1<n&&dis(i+1,j)<(n-1-i))
            cur=max(cur,mx2(i+1,j)+a[i+1][j]);
        return dp[i][j] = cur;
    }
    void build2(int i,int j){
        if(i==n-1&&j==n-1) return;
        int cur = mx2(i,j);
        if(i+1<n&&j-1>=0){
            if(dis(i+1,j-1)<(n-1-i)){
                if((mx2(i+1,j-1)+a[i+1][j-1])==cur){
                    b[i+1][j-1] = -1e5;
                    cout<<a[i+1][j-1]<<"" "";
                    build2(i+1,j-1);
                    return;
                }
            }
        }
        if(i+1<n&&j+1<n){
            if(dis(i+1,j+1)<(n-1-i)){
                if((mx2(i+1,j+1)+a[i+1][j+1])==cur){
                    b[i+1][j+1] = -1e5;
                    cout<<a[i+1][j+1]<<"" "";
                    build2(i+1,j+1);
                    return;
                }
            }
        }
        if(i+1<n&&dis(i+1,j)<(n-1-i)){
            if((mx2(i+1,j)+a[i+1][j])==cur){
                b[i+1][j] = -1e5;
                cout<<a[i+1][j]<<"" "";
                build2(i+1,j);
                return;
            }
        }
    }
    int maxCollectedFruits(vector<vector<int>>& aa) {
        a=aa;
        n = a.size();
        int ans = 0;
        for(int i = 0;i<n;i++)
            ans+=aa[i][i], aa[i][i] = -1e5;
        a=aa;
        memset(dp,-1,sizeof dp);
        int l = a[n-1][0] + mx1(n-1,0);
        b=a;
        cout<<""1 = "";
        build1(n-1,0);
        cout<<""\n"";
        a=b;
        memset(dp,-1,sizeof dp);
        l += a[0][n-1] + mx2(0,n-1);
        a=aa;
        memset(dp,-1,sizeof dp);
        int r = a[0][n-1] + mx2(0,n-1);
        b=a;
        cout<<""2 = "";
        build2(0,n-1);
        cout<<""\n"";
        a=b;
        memset(dp,-1,sizeof dp);
        r += a[n-1][0] + mx1(n-1,0);
        return ans+max(l,r);
    }
};",1460901185
Pankaj Jangid,Pankajj_42,386,3591,cpp,"class Solution {
private:
    long calCost( char c1, char c2, vector<int> &cost, int inc ) {
        long res = 0;
        while( c1 != c2 ) {
            res += cost[(int)(c1-'a')];
            c1 = 'a' + ( (int)(c1 - 'a') + inc + 26 ) % 26;
        }
        return res;
    }
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        int n = s.length();
        for( int i=0; i<n; i++ )
            res += min( calCost( s[i], t[i], nextCost, 1 ), calCost( s[i], t[i], previousCost, -1 ) );
        return res;
    }
};",1460830180
Pankaj Jangid,Pankajj_42,386,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int rm = 10;
        bool flag = false;
        while( n >= rm ) {
            n -= rm;
            rm--;
            flag = !flag;
        }
        return flag;
    }
};",1460812966
Pankaj Jangid,Pankajj_42,386,3648,cpp,"class Solution {
private:
    vector<vector<int>> t = {{1,1,1}, {-1,0,1}, {1,1,1}};
    int getVal( int i, int j, vector<vector<int>> &fruits, vector<vector<int>> &dp, int d ) {
        if( dp[i][j] != -1 ) return dp[i][j];
        return dp[i][j] = fruits[i][j] + max( { getVal( i+t[d][0], j+t[d+1][0], fruits, dp, d ),
                                                getVal( i+t[d][1], j+t[d+1][1], fruits, dp, d ),
                                                getVal( i+t[d][2], j+t[d+1][2], fruits, dp, d ) } );
    }
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res = 0, n = fruits.size();
        for( int i=0; i<n; i++ ) {
            res += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> dp1( n+1, vector<int>( n+1, 0 ) ), dp2( n+1, vector<int>( n+1, 0 ) );
        for( int i=0; i<n; i++ ) {
            for( int j=i+1; j<n; j++ ) {
                dp1[i][j] = -1;
                dp2[j][i] = -1;
            }
        }
        return res + getVal( 0, n-1, fruits, dp1, 0 ) + getVal( n-1, 0, fruits, dp2, 1 );
    }
};",1460906941
Tagir Gumerov,TigProg,388,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        next_full = sum(nextCost)
        prev_full = sum(previousCost)
        
        data = {}
        for a in range(26):
            for b in range(26):
                if a == b:
                    data[(a, a)] = 0
                
                if a < b:
                    x = sum(nextCost[i] for i in range(a, b))
                    y = prev_full - sum(previousCost[i] for i in range(a + 1, b + 1))
                else:
                    x = next_full - sum(nextCost[i] for i in range(b, a))
                    y = sum(previousCost[i] for i in range(b + 1, a + 1))
                    
                data[(a, b)] = min(x, y)

        deltas = Counter(
            (a, b)
            for a, b in zip(s, t)
        )

        result = 0
        for (a, b), cnt in deltas.items():
            aa = ord(a) - 97
            bb = ord(b) - 97
            result += cnt * data[(aa, bb)]
        return result
",1460845059
Tagir Gumerov,TigProg,388,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i in range(10, 0, -1):
            if i > n:
                if i % 2 == 0:
                    return False
                return True
                
            n -= i
            ",1460800118
Tagir Gumerov,TigProg,388,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        f = fruits
        n = len(f)
        
        result = sum(f[i][i] for i in range(n))
        for i in range(n):
            f[i][i] = 0
            
        @cache
        def foo(a, step):
            x, y = a
            result = f[x][y]
            
            if step == n - 1:
                if a == (n - 1, n - 1):
                    return result
                return -float('inf')
            
            if x < n // 2:
                return -float('inf')
            
            current = -float('inf')
            for dx in (-1, 0, 1):
                if (0 <= x + dx < n):
                    c = foo((x + dx, y + 1), step + 1)
                    current = max(current, c)
            return result + current    

        @cache
        def bar(b, step):
            u, v = b
            result = f[u][v]
            
            if step == n - 1:
                if b == (n - 1, n - 1):
                    return result
                return -float('inf')
            
            if v < n // 2:
                return -float('inf')
            
            current = -float('inf')
            for dv in (-1, 0, 1):
                if (0 <= v + dv < n):
                    c = bar((u + 1, v + dv), step + 1)
                    current = max(current, c)
            return result + current    
        
#         @cache
#         def rec(a, b, step):
#             x, y = a
#             u, v = b
#             # print(a, b)
            
#             result = f[x][y] + f[u][v]
            
#             if step == n - 1:
#                 if a == (n - 1, n - 1) and b == (n - 1, n - 1):
#                     return result
#                 return -float('inf')
            
#             if x < n // 2 or v < n // 2:
#                 return -float('inf')
            
#             current = -float('inf')
#             # dy = 1
#             # du = 1
#             for dx in (-1, 0, 1):
#                 if (0 <= x + dx < n):
#                     for dv in (-1, 0, 1):
#                         if (0 <= v + dv < n):
#                             c = rec((x + dx, y + 1), (u + 1, v + dv), step + 1)
#                             current = max(current, c)
#             return result + current
        
        return result + foo((n - 1, 0), 0) + bar((0, n - 1), 0)
    
# [[11,17,13,0,18],[13,12,10,12,19],[4,8,10,14,16],[2,13,12,7,16],[4,9,7,4,3]]
# 145


# [0 ,17,13,0 ,18]
# [13,0 ,10,12,19]
# [4 ,8 ,0 ,14,16]
# [2 ,13,12,0 ,16]
# [4 ,9 ,7 ,4 ,0 ]


# 43

# 69

# 33
",1460884723
Namit Nayan,namitnayan32,389,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans = 0
        for current, target in zip(s, t):
            if current == target:
                continue
            current_position = ord(current) - ord('a')
            target_position = ord(target) - ord('a')
            forward_curr = 0
            backward_curr = 0
            p = current_position
            while p != target_position:
                forward_curr += nextCost[p]
                p += 1
                if p == len(nextCost):
                    p = 0
            p = current_position
            while p != target_position:
                backward_curr += previousCost[p]
                p -= 1
                if p == -1:
                    p = len(previousCost) - 1
            ans += min(forward_curr, backward_curr)
        return ans",1460834803
Namit Nayan,namitnayan32,389,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        p = 0
        rem = 10
        while n >= rem:
            p ^= 1
            n -= rem
            rem -= 1
        return p == 1",1460797781
Namit Nayan,namitnayan32,389,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        # exactly n - 1 moves
        # other two children won't touch diagonal
        # for row in fruits:
        #     print("" "".join(f""{item:4}"" for item in row))
        n = len(fruits)
        ans = sum(fruits[i][i] for i in range(n))
        dp = [0] * n
        dp[n - 1] = fruits[0][n - 1]
        for i in range(1, n - 1):
            ndp = [0] * n
            for j in range(max(i + 1, n - i - 1), n):
                ndp[j] = max(dp[j], dp[j - 1], dp[j + 1] if j + 1 < n else 0) + fruits[i][j]
            dp = ndp
            # print(f""1: {dp = }"")
        ans += dp[n - 1]
        dp = [0] * n
        dp[n - 1] = fruits[n - 1][0]
        for j in range(1, n - 1):
            ndp = [0] * n
            for i in range(max(j + 1, n - j - 1), n):
                ndp[i] = max(dp[i], dp[i - 1], dp[i + 1] if i + 1 < n else 0) + fruits[i][j]
            dp = ndp
            # print(f""2: {dp = }"")
        ans += dp[n - 1]
        return ans
",1460901915
Arnav Goyal,Pikachu0123,391,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int> next, vector<int> prev) {
        int n = s.size();
        long long cost = 0;
        vector<long long> prefix(26, 0);
        prefix[0] = next[0];
        for(int i=1; i<26; i++)
            prefix[i] = next[i] + prefix[i-1];
        vector<long long> prefix2(26, 0);
        prefix2[0] = prev[0];
        for(int i=1; i<26; i++)
            prefix2[i] = prev[i] + prefix2[i-1];
        for(int i=0; i<n; i++){
            int dif = t[i] - s[i];
            long long shift = LLONG_MAX;
            if (dif > 0){
                shift = prefix[t[i]-'a'-1] - prefix[s[i]-'a'] + next[s[i]-'a'];
                shift = min(shift, 0LL + prefix2[s[i]-'a'] + prefix2[25] - prefix2[t[i]-'a']);
                // cerr << shift << endl;
            }


            else if (dif == 0){
                shift = 0;
            }

            else{
                shift = prefix2[s[i]-'a'] - prefix2[t[i]-'a'];
                // cout << shift << ""ds\n"";
                shift = min(shift,0LL + prefix[25]-prefix[s[i]-'a']+next[s[i]-'a']+prefix[t[i]-'a']-next[t[i]-'a']);
                // cout << (prefix[25]-prefix[s[i]-'a']+next[s[i]-'a']) << "" "" << (s[i]-'a') << "" "" << (prefix[t[i]-'a']-next[t[i]-'a']) << endl;
            }

            cost += shift;
        }

        return cost;
    }
};",1460903361
Arnav Goyal,Pikachu0123,391,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0;
        int stones = 10;
        while(n){
            if (n < stones){
                if (turn == 0) return false;
                else return true;
            }
            n -= stones;
            stones--;
            turn ^= 1;
        }
        // return true;
        return turn;
    }
};",1460798947
Arnav Goyal,Pikachu0123,391,3648,cpp,"class Solution {
    int dp1[1001][1001];
    int dp2[1001][1001];
    int solve(int i, int j, int &n, vector<vector<int>>& fruits){
        if (i < 0 or j < 0 or i >= n or j >= n) return -1e9;
        if (i == n-1){
            if (j == n-1) return 0;
            return -1e9;
        }
        if (dp1[i][j] != -1) return dp1[i][j];
        return dp1[i][j] = max({solve(i+1, j,n, fruits), solve(i+1, j-1,n, fruits), solve(i+1,j+1,n, fruits)}) + fruits[i][j];
    }

    int solve2(int i, int j, int &n, vector<vector<int>>& fruits){
        if (i < 0 or j < 0 or i >= n or j >= n) return -1e9;
        if (j == n-1){
            if (i == n-1) return 0;
            return -1e9;
        }
        if (dp2[i][j] != -1) return dp2[i][j];
        return dp2[i][j] = max({solve2(i+1, j+1, n,fruits), solve2(i-1, j+1, n,fruits), solve2(i,j+1, n,fruits)}) + fruits[i][j];
    }

    
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for(int i=0; i<n; i++){
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }

memset(dp1, -1, sizeof dp1);
memset(dp2, -1, sizeof dp2);

        int ans1 = solve(0, n-1, n, fruits);
        int ans2 = solve2(n-1, 0, n, fruits);
        return ans1 + ans2 + ans;
    }
};",1460898819
sellie50759,sellie50759,392,3591,cpp,"class Solution {
public:
    typedef long long ll;
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost) {
        vector<vector<ll> > costs(26, vector<ll>(26, LLONG_MAX));
        
        for(int i = 0;i < 26;i++){
            costs[i][i] = 0;
            ll sum = 0;
            for(int j=0;j<26;j++){
                sum += nextCost[(i+j)%26];
                costs[i][(i+j+1)%26] = min(costs[i][(i+j+1)%26], sum);
            }
            sum = 0;
            for(int j=0;j<26;j++){
                sum += prevCost[(i-j + 26)%26];
                costs[i][(i-j-1 + 26)%26] = min(costs[i][(i-j-1 + 26)%26], sum);
            }
        }
        
        ll ans = 0;
        for(int i = 0;i<s.size();i++){
            // cout<<s[i]<<"" ""<<t[i]<<"" ""<<costs[s[i]-'a'][t[i]-'a']<<""\n"";
            ans += costs[s[i]-'a'][t[i]-'a'];
        }
        return ans;
    }
};",1460820422
sellie50759,sellie50759,392,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool flag = false;
        
        for(int i = 10;i>=1;i--){
            n -= i;
            if(n < 0)
                return flag; 
            flag = !flag;
        }
        
        return false;
    }
};",1460796528
sellie50759,sellie50759,392,3648,cpp,"class Solution {
public:
    #define MAX 1005
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        for(int i=0;i<n;i++){
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        
        int dp1[MAX][MAX] = {0}, dp2[MAX][MAX] = {0};
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<n;j++){
        //         dp[i][j] = fruits[i][j];
        //     }
        //     fruits[i][i] = 0;
        // }
        
        int dir1[3][2] = {1, -1, 1, 0, 1, 1}, dir2[3][2] = {-1, 1, 0, 1, 1, 1};
        
        for(int i = 0; i < n;i++){
            for(int j = n-1; j >= n-1-i;j--){
                dp1[i][j] += fruits[i][j];
                for(int k = 0;k<3;k++){
                    int nexti = i + dir1[k][0], nextj = j + dir1[k][1];
                    
                    if(nexti < n && nexti >=0 && nextj < n && nextj >= 0){
                        dp1[nexti][nextj] = max(dp1[nexti][nextj], dp1[i][j]);
                    }
                }
            }
        }
        
        for(int j = 0; j < n;j++){
            for(int i = n-1; i >= n-1-j;i--){
                dp2[i][j] += fruits[i][j];
                for(int k = 0;k<3;k++){
                    int nexti = i + dir2[k][0], nextj = j + dir2[k][1];
                    
                    if(nexti < n && nexti >=0 && nextj < n && nextj >= 0)
                        dp2[nexti][nextj] = max(dp2[nexti][nextj], dp2[i][j]);
                }
            }
        }
        
        return dp1[n-1][n-1] + dp2[n-1][n-1] + ans;
    }
};",1460898098
Satvik Raj,7vik_raj,396,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        
        for(int i=0; i<s.length(); i++){
            long long nxt = 0;
            char ch = s[i];
            
            if(s[i] > t[i]){
                while(s[i] != 'z'){
                    nxt += nextCost[s[i] -'a'];
                    s[i]++;
                }
                nxt += nextCost[25];
                s[i] = 'a';
            }
            while(s[i] != t[i]){
                nxt += nextCost[s[i] -'a'];
                s[i]++;
            }
            
            
            long long prev = 0;
            s[i] = ch;
            
            if(s[i] < t[i]){
                while(s[i] != 'a'){
                    prev += previousCost[s[i] -'a'];
                    s[i]--;
                }
                prev += previousCost[0];
                s[i] = 'z';
            }
            while(s[i] != t[i]){
                prev += previousCost[s[i] -'a'];
                s[i]--;
            }
            
            ans += min(nxt, prev);
        }
        return ans;
    }
};",1460830824
Satvik Raj,7vik_raj,396,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i = 10;
        bool al = 1;
        while(n-i >= 0){ n = n-i--; al = !al;}
        return !al;
    }
};",1460798237
Satvik Raj,7vik_raj,396,3648,cpp,"class Solution {
    vector<vector<int>> dp;
    // vector<vector<int>> pp;
public:
    int recure(vector<vector<int>> &fruits, int i, int j, int &n){
        if(i == n-1 && j == n-1) return 0;
        if(i >= n || j >= n) return INT_MIN;
        
        if(dp[i][j] != -1) return dp[i][j];
        
        int res = 0;
        
        if(i > j+1) res = max(res, recure(fruits, i, j+1, n));
        if(i != n-1) res = max(res, recure(fruits, i+1, j+1, n));
        if(i-1 > j+1) res = max(res, recure(fruits, i-1, j+1, n));
        
        return dp[i][j] = res + fruits[i][j];
    }
    
    int pecure(vector<vector<int>> &fruits, int i, int j, int &n){
        if(i == n-1 && j == n-1) return 0;
        if(i >= n || j >= n) return INT_MIN;
        
        if(dp[i][j] != -1) return dp[i][j];

        int res = 0;
        
        if(j > i+1) res = max(res, pecure(fruits, i+1, j, n));
        if(j != n-1) res = max(res, pecure(fruits, i+1, j+1, n));
        if(j-1 > i+1) res = max(res, pecure(fruits, i+1, j-1, n));
        
        return dp[i][j] = res + fruits[i][j];
    }
    
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        int n = fruits.size();
        
        dp = vector<vector<int>>(n, vector<int>(n, -1));
        dp[n-1][n-1] = 0;
        // pp = vector<vector<int>>(n, vector<int>(n, -1));

        
        int i=0, j = 0;
        while(i != n){
            ans += fruits[i++][j++];
        }
        
        ans += recure(fruits, n-1, 0, n);
        ans += pecure(fruits, 0, n-1, n);
        return ans;
    }
};",1460888393
Mudit Anand,mudit_2904,398,3591,cpp,"class Solution {
    long long int goNext(int i, int& j, vector<int>& nextCost) {
        if(i == j)
            return 0;

        int nxtI = (i + 1) % 26;
        return (long long int)nextCost[i] + goNext(nxtI, j, nextCost);
    }

    long long int goPrev(int i, int& j, vector<int>& prevCost) {
        if(i == j)
            return 0;

        int nxtI = i - 1;
        if(i == 0)
            nxtI = 25;

        return (long long int)prevCost[i] + goPrev(nxtI, j, prevCost);
    }

public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long int>> netCost(26, vector<long long int>(26));
        for(int i = 0; i < 26; ++i) {
            for(int j = 0; j < 26; ++j) {
                long long int way1 = goNext(i, j, nextCost);
                long long int way2 = goPrev(i, j, previousCost);
                netCost[i][j] = min(way1, way2);
            }
        }
        
        long long int res = 0;
        int n = s.size();
        for(int i = 0; i < n; ++i) 
            res += netCost[s[i] - 'a'][t[i] - 'a'];
        
        return res;
    }
};",1460856305
Mudit Anand,mudit_2904,398,3625,cpp,"class Solution {
public:
    bool helper(int n, int val, bool player) {
        if(n < val)
            return player;
        return helper(n - val, val - 1, 1 - player);
    }
    bool canAliceWin(int n) {
        return helper(n, 10, 0);
    }
};",1460798076
Mudit Anand,mudit_2904,398,3648,cpp,"class Solution {
    vector<int> diff = {-1, 0, 1};
    long long int helper_1(int row, int col, int& n, vector<vector<int>>& fruits, vector<vector<long long int>>& dp) {
        if(row == n - 1 && col == n - 1)
            return 0;
        if(dp[row][col] != -1)
            return dp[row][col];

        long long int sum = fruits[row][col];
        long long int maxi = INT_MIN;
        for(int i = 0; i < 3; ++i) {
            int adjCol = col + diff[i];
            int adjRow = row + 1;

            if(adjCol < n / 2 || adjCol >= n || adjRow >= n)
                continue;
            maxi = max(maxi, helper_1(adjRow, adjCol, n, fruits, dp));
        }
        
        return dp[row][col] = sum + maxi;
    }
    
    long long int helper_2(int row, int col, int& n, vector<vector<int>>& fruits, vector<vector<long long int>>& dp) {
        if(row == n - 1 && col == n - 1)
            return 0;
        if(dp[row][col] != -1)
            return dp[row][col];

        long long int sum = fruits[row][col];
        long long int maxi = INT_MIN;
        for(int i = 0; i < 3; ++i) {
            int adjRow = row + diff[i];
            int adjCol = col + 1;

            if(adjRow < n / 2 || adjRow >= n || adjCol >= n)
                continue;
            maxi = max(maxi, helper_2(adjRow, adjCol, n, fruits, dp));
        }
        
        return dp[row][col] = sum + maxi;
    }

    
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int sum = 0;
        int n = fruits.size();
        vector<vector<long long int>> dp(n, vector<long long int>(n, -1));
        vector<vector<long long int>> bp(n, vector<long long int>(n, -1));
        
        // from child 1
        for(int i = 0; i < n; ++i) {
            sum += fruits[i][i];
            fruits[i][i] = 0;
        }

        // from child 2
        sum += helper_1(0, n - 1, n, fruits, dp);

        // from child 3
        sum += helper_2(n - 1, 0, n, fruits, bp);

        return sum;
    }
};",1460900084
ads169573,ads169573,400,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        vector<vector<long long>> vn(26,vector<long long>(26,0));
        vector<vector<long long>> vp(26,vector<long long>(26,0));
        for(int i=0;i<26;++i){
            for(int j=(i+1)%26,k=0;k<25;++k){
                vn[i][j]=vn[i][(j+26-1)%26]+nextCost[(j+26-1)%26];
                j=(j+1)%26;
            }
            for(int j=(i+26-1)%26,k=0;k<25;++k){
                vp[i][j]=vp[i][(j+1)%26]+previousCost[(j+1)%26];
                j=(j+26-1)%26;
            }
        }
        for(int i=0;i<s.size();++i){
            if(s[i]==t[i]) continue;
            long long tmp=min(vn[s[i]-'a'][t[i]-'a'],vp[s[i]-'a'][t[i]-'a']);
            ans+=tmp;
        }
        return ans;
    }
};",1460823066
ads169573,ads169573,400,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int d=10,t=0;
        while(n){
            if(n<d) return t;
            n-=d;
            t^=1;
            d-=1;
        }
        return t;
    }
};",1460797622
ads169573,ads169573,400,3648,cpp,"class Solution {
public:
    vector<vector<int>>dp1,dp2;
    int n;
    int f1(vector<vector<int>>&v,int i,int j){
        if(j==n-1) return 0;
        if(dp1[i][j]!=-1) return dp1[i][j];
        int ans=v[i][j],d=0;
        if((i+1)<n) d=max(d,f1(v,i+1,j+1));
        if(((n-i+1)<=(n-j-1))) d=max(d,f1(v,i-1,j+1));
        if((n-i)<(n-j)) d=max(d,f1(v,i,j+1));
        return dp1[i][j]=ans+d;
    }
    int check=0;
    int f2(vector<vector<int>>&v,int i,int j){
        if(i==n-1) return 0;
        if(dp2[i][j]!=-1) return dp2[i][j];
        
        int ans=v[i][j],d=0;
        if((j+1)<n) d=max(d,f2(v,i+1,j+1));
        if((n-i-1)>=(n-j+1)) d=max(d,f2(v,i+1,j-1));
        if((n-i)>(n-j)) d=max(d,f2(v,i+1,j));
        
        return dp2[i][j]=ans+d;
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans=0;
        n=fruits.size();
        for(int i=0;i<n;++i) {
            ans+=fruits[i][i];
            fruits[i][i]=0;
        }
        
        dp1.resize(n,vector<int>(n,-1));
        dp2.resize(n,vector<int>(n,-1));
        ans+=f1(fruits,n-1,0);
        ans+=f2(fruits,0,n-1);
        
        return ans;
    }
};",1460911513
Shruthik,Shruthik_Ravula,402,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        # next = [[0 for _ in range(26)] for i in range(26)]
        next = [0]
        tot = nextCost[0]
        for i in range(1, 26):
            next.append(tot)
            tot += nextCost[i]

        prev = [0]
        tot = previousCost[-1]
        for i in range(24, -1, -1):
            prev.append(tot)
            tot += previousCost[i]
        prev.reverse()

        # print(next, prev)

        ans = 0
        for i in range(len(s)):
            ind1 = ord(s[i]) - 97
            ind2 = ord(t[i]) - 97
            if ind1 == ind2:
                continue
            if ind1 < ind2:
                c1 = next[ind2] - next[ind1]
                c2 = prev[0] - prev[ind1] + previousCost[0] + prev[ind2] - prev[-1]
            else:
                c1 = next[-1] - next[ind1] + nextCost[-1] + next[ind2] - next[0]
                c2 = prev[ind2] - prev[ind1]
            # print(i, c1, c2)
            # print(""next"",ind2, ind1, next[ind2], next[ind1])
            ans += min(c1, c2)
        return ans",1460854896
Shruthik,Shruthik_Ravula,402,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rem = 9
        alice = False
        n -= 10
        if n < 0:
            return False
        if n == 0:
            return True
        while n > 0:
            n -= rem
            rem -= 1
            if n < 0:
                return True if alice == False else False
            if n == 0:
                return True if alice == True else False
            if alice == True:
                alice = False
            else:
                alice = True
        ",1460808838
Shruthik,Shruthik_Ravula,402,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        if n == 1:return fruits[0][0]
        grid = [[0 for _ in range(n)] for i in range(n)]
        grid[n - 1][0] = fruits[n - 1][0]
        # arr = [n - 1]
        for col in range(1, n - 1):
            for row in range(max(col + 1, n - col - 1), n):
                grid[row][col] = max(grid[row][col], grid[row][col - 1] + fruits[row][col])
                if row - 1 >= col:
                    grid[row][col] = max(grid[row][col], grid[row - 1][col - 1] + fruits[row][col])
                if row + 1 < n:
                    grid[row][col] = max(grid[row][col], grid[row + 1][col - 1] + fruits[row][col])
        ans = grid[n - 1][n - 2]
        # print(ans)
        # for arr in grid:
        #     print(arr)

        grid = [[0 for _ in range(n)] for i in range(n)]
        grid[0][n - 1] = fruits[0][n - 1]
        for row in range(1, n - 1):
            for col in range(max(row + 1, n - row - 1), n):
                grid[row][col] = grid[row - 1][col] + fruits[row][col]
                grid[row][col] = max(grid[row][col], grid[row - 1][col - 1] + fruits[row][col])
                if col + 1 < n:
                    grid[row][col] = max(grid[row][col], grid[row - 1][col + 1] + fruits[row][col])

        ans += grid[n - 2][n - 1]
        # print(grid[n - 2][n - 1])

        for i in range(n):
            ans += fruits[i][i]
            
        return ans",1460906241
Aniket Saini,Ani_S,403,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        char src[] = s.toCharArray();
        char tgt[] = t.toCharArray();
        
        long totalCost = 0l;
        
        for(int i = 0; i < src.length; i++) {
            long next = 0;
            int cnt = 0;
            for(char j = src[i]; cnt < 26; j = nextChar(j), cnt++) {
                if(j == tgt[i])
                    break;
                
                next += nextCost[j - 'a'];
            }
            
            long prev = 0;
            cnt = 0;
            for(char j = src[i]; cnt < 26; j = prevChar(j), cnt++) {
                if(j == tgt[i])
                    break;
                
                prev += previousCost[j - 'a'];
            }
            
            totalCost += Math.min(next, prev);
        }
        
        return totalCost;
    }
    
    private char nextChar(char c) {
        if(c == 'z')
            return 'a';
        
        return (char)(c + 1);
    }
    
    private char prevChar(char c) {
        if(c == 'a')
            return 'z';
        
        return (char)(c - 1);
    }
}",1460821209
Aniket Saini,Ani_S,403,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean aliceWin = false;
        
        for(int i = 10; i >= 0; i--) {
            if(n >= i) {
                aliceWin = !aliceWin;
                n -= i;
            } else {
                break;
            }
        }
        
        return aliceWin;
    }
}",1460800618
Aniket Saini,Ani_S,403,3648,java,"class Solution {
    Integer dp[][][];
    
    public int maxCollectedFruits(int[][] fruits) {
        int ans = 0;
        int n = fruits.length;
        
        for(int i = 0; i < fruits.length; i++) {
            ans += fruits[i][i];
        }
        
        dp = new Integer[n][n][2];
        
        // System.out.println(ans);
        // System.out.println(recursion(0, n - 1, 0, fruits));
        // System.out.println(recursion(n - 1, 0, 1, fruits));
        
        return ans + recursion(0, n - 1, 0, fruits) + recursion(n - 1, 0, 1, fruits);
    }
    
    private int recursion(int row, int col, int per, int[][] fruits) {
        if(row < 0 || row >= fruits.length || col < 0 || col >= fruits.length) return Integer.MIN_VALUE;
        
        // System.out.println(row + "" "" + col + "" "" + per);
        
        if(row == fruits.length - 1 && col == fruits.length - 1) {
            return 0;
        }
        
        if((per == 0 && row == fruits.length - 1) || (per == 1 && col == fruits.length - 1) || row == col) {
            return Integer.MIN_VALUE;
        }
        
        if(dp[row][col][per] != null)
            return dp[row][col][per];
        
        int val = Integer.MIN_VALUE;
        
        if(per > 0) {
            int first = recursion(row - 1, col + 1, per, fruits);
            int second = recursion(row, col + 1, per, fruits);
            int third = recursion(row + 1, col + 1, per, fruits);
            
            val = Math.max(first, Math.max(second, third));
            
            if(val != Integer.MIN_VALUE)
                val += fruits[row][col];
        } else {
            int first = recursion(row + 1, col - 1, per, fruits);
            int second = recursion(row + 1, col, per, fruits);
            int third = recursion(row + 1, col + 1, per, fruits);
            
            val = Math.max(first, Math.max(second, third));
            
            if(val != Integer.MIN_VALUE)
                val += fruits[row][col];
        }
        
        return dp[row][col][per] = val;
    }
}",1460911939
_nobita,_nobita,406,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> dp(26, vector<long long>(26));
        for(int i=0; i<26; i++) {
            for(int j=0; j<26; j++) {
                int start = i;
                long long curr1 = 0;
                while(start != j) {
                    curr1 += nextCost[start];
                    start = (start+1)%26;
                }

                start = i;
                long long curr2 = 0;
                while(start != j) {
                    curr2 += previousCost[start];
                    start = (start-1+26)%26;
                }

                dp[i][j] = min(curr1, curr2);
            }
        }

        long long ans = 0;
        int n = s.length();
        for(int i=0; i<n; i++) {
            ans += dp[s[i]-'a'][t[i]-'a'];
        }
        return ans;
    }
};",1460816757
_nobita,_nobita,406,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10;
        while(n > 0) {
            if(n >= cnt) {
                n -= cnt;
                cnt--;
            } 
            else {
                return false;
            }

            if(n >= cnt) {
                n -= cnt;
                cnt--;
            } 
            else {
                return true;
            }
        }
        return false;
    }
};",1460800399
_nobita,_nobita,406,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for(int i=0; i<n; i++)
            ans += fruits[i][i];

        // cout << ans << endl;
        
        vector<vector<int>> vis(n, vector<int>(n, -1));
        vis[0][n-1] = 0;
        for(int i=0; i<n; i++) {
            for(int j=i+1; j<n; j++) {
                if(vis[i][j] >= 0) {
                    if(j-1>i+1) 
                        vis[i+1][j-1] = max(vis[i+1][j-1], vis[i][j]+fruits[i][j]);
                    if(j>i+1)
                        vis[i+1][j] = max(vis[i+1][j], vis[i][j]+fruits[i][j]);
                    if(j+1<n)
                        vis[i+1][j+1] = max(vis[i+1][j+1], vis[i][j]+fruits[i][j]);
                }
            }
        }

        // for(int i=0; i<n; i++) {
        //     for(int j=i+1; j<n; j++)
        //         cout << vis[i][j] + fruits[i][j] << "" "";
        //     cout << endl;
        // }


        
        ans += vis[n-2][n-1]+fruits[n-2][n-1];

        // cout << ans << endl;
        
        vis[n-1][0] = 0;
        for(int j=0; j<n; j++) {
            for(int i=n-1; i>j; i--) {
                if(vis[i][j] >= 0) {
                    if(i-1>j+1)
                        vis[i-1][j+1] = max(vis[i-1][j+1], vis[i][j]+fruits[i][j]);
                    if(i>j+1)
                        vis[i][j+1] = max(vis[i][j+1], vis[i][j]+fruits[i][j]);
                    if(i+1<n)
                        vis[i+1][j+1] = max(vis[i+1][j+1], vis[i][j]+fruits[i][j]);
                }
            }
        }
        ans += vis[n-1][n-2]+fruits[n-1][n-2];

        // cout << ans << endl;
        return ans;
    }
};",1460906977
Oikawa,oikawa1,407,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res=0;
        int n=s.size();
        vector<long long> npref(27,0), ppref(27,0);
        for(int i=1;i<=26;i++)
        {
            npref[i]=npref[i-1]+nextCost[i-1];
            ppref[i]=ppref[i-1]+previousCost[i-1];
        }

        // for(int i=0;i<=26;i++)
        //     cout<<npref[i]<<"" ""<<ppref[i]<<endl;

        for(int i=0;i<n;i++)
        {
            int aPos=s[i]-'a';
            int bPos=t[i]-'a';
            if(aPos==bPos) continue;

            // cout<<aPos<<"" ""<<bPos<<endl;
            if(aPos<bPos)
            {
                res+=min(npref[bPos]-npref[aPos], ppref[aPos+1]+ ppref[26]-ppref[bPos+1]);
            }
            else
            {
                long long a=ppref[aPos+1]-ppref[bPos+1];
                long long b=npref[bPos]+ npref[26]-npref[aPos];
                // cout<<""ab ""<<a<<"" ""<<b<<endl;
                res+=min(a,b);
            }

            cout<<res<<endl;
        }

        return res;
    }
};",1460849383
Oikawa,oikawa1,407,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        if(n<10) return false;
        n-=10;

        int cur=9;
        while(n)
        {
            // cout<<n<<"" ""<<cur<<endl;
            if(n<cur) return true;
            n-=cur;
            cur--;

            if(!n) return false;
            
            if(n<cur) return false;
            n-=cur;
            cur--;
        }

        return true;
    }
};",1460804346
Oikawa,oikawa1,407,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res=0;
        int n=fruits.size();
        for(int i=0;i<n;i++)
            res+=fruits[i][i];

        for(int i=0;i<n-1;i++)
            for(int j=0;j<n-i-1;j++)
                fruits[i][j]=0;

        // for(int i=0;i<n;i++)
        // {
        //     for(int j=0;j<n;j++)
        //         cout<<fruits[i][j]<<"" "";
        //     cout<<endl;
        // }
        
        // cout<<res<<endl;
        for(int j=1;j<n-1;j++)
        {
            for(int i=j+1;i<n;i++)
            {
                // cout<<i<<"" ""<<j<<endl;
                int cur=max(fruits[i-1][j-1], fruits[i][j-1]);
                if(i+1<n)
                    cur=max(cur, fruits[i+1][j-1]); 
                fruits[i][j]+=cur;
            }
        }

        res+=fruits[n-1][n-2];

        // for(int i=0;i<n;i++)
        // {
        //     for(int j=0;j<n;j++)
        //         cout<<fruits[i][j]<<"" "";
        //     cout<<endl;
        // }

        for(int i=1;i<n-1;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                int cur=max(fruits[i-1][j-1], fruits[i-1][j]);
                if(j+1<n)
                    cur=max(cur, fruits[i-1][j+1]);
                fruits[i][j]+=cur;
            }
        }

        res+=fruits[n-2][n-1];
        
        // for(int i=0;i<n;i++)
        // {
        //     for(int j=0;j<n;j++)
        //         cout<<fruits[i][j]<<"" "";
        //     cout<<endl;
        // }

        return res;
    }
};",1460907007
Nagender,Nagender456,408,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> costByNext(26, vector<long long>(26, 0));
        vector<vector<long long>> costByPrev(26, vector<long long>(26, 0));
        for (int i=0; i<26; i++) {
            long long curCost = 0;
            for (int j=i+1; j<i+26; j++) {
                curCost += nextCost[((j+25)%26)];
                costByNext[i][(j+26)%26] = curCost;
            }
            curCost = 0;
            for (int j=i-1; j>i-26; j--) {
                curCost += previousCost[((j+27)%26)];
                costByPrev[i][(j+26)%26] = curCost;
            }
        }
        long long ans = 0;
        int n = s.length();
        for (int i=0; i<n; i++) {
            ans += min(costByNext[s[i]-'a'][t[i]-'a'], costByPrev[s[i]-'a'][t[i]-'a']);
            // cout << ans << endl;
        }
        return ans;
    }
};",1460831048
Nagender,Nagender456,408,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = true;
        int turn = 10;
        while (n >= turn) {
            n -= turn;
            alice = !alice;
            turn--;
        }
        return !alice;
    }
};",1460796454
Nagender,Nagender456,408,3648,cpp,"class Solution {
public:
int n;
    int solve(int i, int j, vector<vector<int>>& fruits, vector<vector<int>>& dp, vector<vector<int>>& dir) {
        if ((i == n-1 && dir[0][0] == 1) || (j == n-1 && dir[0][1] == 1)) {
            if (i == n-1 && j == n-1) return 0;
            else dp[i][j] = -2;
        }
        if (dp[i][j] == -1) {
            int maxAns = -2, curAns = -2, newI, newJ;
            for (auto&d: dir) {
                newI = i+d[0];
                newJ = j+d[1];
                if (newI < 0 || newJ < 0 || newI >= n || newJ >= n) continue;
                curAns = solve(newI, newJ, fruits, dp, dir);
                // if (i == 3 && j == 2) {
                //     cout << curAns << "":\n"";
                // }
                if (curAns == -2) continue;
                maxAns = max(maxAns, curAns);
            }
            dp[i][j] = (maxAns != -2 ? fruits[i][j] + maxAns : -2);
        }
        return dp[i][j];
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        n = fruits.size();
        vector<vector<int>> dp1(n, vector<int>(n, -1));
        vector<vector<int>> dp2(n, vector<int>(n, -1));
        for (int i=0; i<n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> dir1 = {
            {1, -1}, {1, 0}, {1, 1}
        };
        vector<vector<int>> dir2 = {
            {-1, 1}, {0, 1}, {1, 1}
        };
        ans += solve(0, n-1, fruits, dp1, dir1);
        ans += solve(n-1, 0, fruits, dp2, dir2);
        // for (auto el: dp1) {
        //     for (auto el2: el) {
        //         cout << el2 << "" "";
        //     }
        //     cout << ""\n"";
        // }
        // cout << ""\n"";
        // for (auto el: dp2) {
        //     for (auto el2: el) {
        //         cout << el2 << "" "";
        //     }
        //     cout << ""\n"";
        // }
        return ans;
    }
};",1460901586
AmazingR,AmazingR,411,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost) 
    {
        long long next[26][26], prev[26][26];
        for(int i=0;i<26;i++)
        {
            long long cur = 0;
            for(int j=0;j<26;j++)
            {
                next[i][(j+i)%26] = cur;
                cur += nextCost[(j+i) % 26];
            }
        }
        for(int i=0;i<26;i++)
        {
            long long cur = 0;
            for(int j=0;j<26;j++)
            {
                prev[i][(26+i-j)%26] = cur;
                cur += prevCost[(26 + i - j) % 26];
            }
        }
        int n = s.length();
        long long res = 0;
        for(int i=0;i<n;i++)
        {
            int x = s[i] - 'a', y = t[i] - 'a';
            res += min(next[x][y], prev[x][y]);
        }
        return res;
    }
};",1460840442
AmazingR,AmazingR,411,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n)
    {
        if((n>=10 && n<19) || (n>=27 && n<34) || (n>=40 && n<45) || n>=49)
            return true;
        return false;
    }
};",1460802565
AmazingR,AmazingR,411,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& mat)
    {
        int n = mat.size();
        for(int i=1;i<n-1;i++)
            mat[0][i] = -1;
        for(int i=1;i<n;i++)
        {
            for(int j=i+1; j<n;j++)
            {
                int cur = max(mat[i-1][j-1], mat[i-1][j]);
                if(j+1 < n)
                    cur = max(cur, mat[i-1][j+1]);
                if(cur == -1)
                    mat[i][j] = -1;
                else
                    mat[i][j] += cur;
            }
        }
        for(int i=1;i<n-1;i++)
            mat[i][0] = -1;
        for(int j=1;j<n;j++)
        {
            for(int i=j+1; i<n;i++)
            {
                int cur = max(mat[i-1][j-1], mat[i][j-1]);
                if(i+1 < n)
                    cur = max(cur, mat[i+1][j-1]);
                if(cur == -1)
                    mat[i][j] = -1;
                else
                    mat[i][j] += cur;
            }
        }
        int res = 0;
        for(int i=0;i<n;i++)
            res += mat[i][i];
        res += mat[n-2][n-1] + mat[n-1][n-2];
        return res;
    }
};",1460907551
loginmcs,loginmcs,412,3591,cpp,"class Solution {
public:
    static constexpr int n = 26;
    static constexpr int n2 = n * n;
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res {0LL};
        std::array<long long, n2> costs;
        costs.fill(0);
        for (int d = 1; d < n; ++d) {
            for (int i = 0; i < n; ++i) {
                int rowIndex = i * n;
                int col = i + d;
                if (col >= n) col -= n;
                int prevCol = i + d - 1;
                if (prevCol >= n) prevCol -= n;
                costs[rowIndex + col] = costs[rowIndex + prevCol] + nextCost[prevCol];
            }
        }
        for (int d = 1; d < n; ++d) {
            for (int i = 0; i < n; ++i) {
                int rowIndex = i * n;
                int col = i - d;
                if (col < 0) col += n;
                int prevCol = i - d + 1;
                if (prevCol < 0) prevCol += n;
                costs[rowIndex + col] = std::min<long long>(costs[rowIndex + col],
                    costs[rowIndex + prevCol] + previousCost[prevCol]);
            }
        }
        for (int i = 0; i < s.size(); ++i) {
            res += costs[(s[i] - 'a') * n + (t[i] - 'a')];
        }
        return res;
    }
};",1460860646
loginmcs,loginmcs,412,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool res {false};
        int toBeRemoved = 10;
        while (n >= toBeRemoved) {
            res = !res;
            n -= toBeRemoved;
            --toBeRemoved;
        }
        return res;
    }
};",1460800604
loginmcs,loginmcs,412,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int res {0};
        int n = fruits.size();
        for (int i = 0; i < n; ++i) {
            res += fruits[i][i];
        }
        //0, n-1 -> n-2, n-1
        std::vector<int> maxFruits(n, 0);
        maxFruits[n - 1] = fruits[n - 2][n - 1];
        for (int row = n - 3; row >= 0; --row) {
            std::vector<int> nextLevel(n, 0);
            nextLevel[n - 1] = fruits[row][n - 1] + std::max(maxFruits[n - 1], maxFruits[n - 2]);
            for (int col = row + 1; col < n - 1; ++col) {
                nextLevel[col] = fruits[row][col] + 
                    std::max(std::max(maxFruits[col - 1], maxFruits[col]), maxFruits[col + 1]);
            }
            std::swap(maxFruits, nextLevel);
            //for (int i: maxFruits) std::cout << i << "", "";
            //std::cout << std::endl;
        }
        res += maxFruits[n - 1];
        //n-1, 0 -> n-1, n-2
        std::fill(maxFruits.begin(), maxFruits.end(), 0);
        maxFruits[n - 1] = fruits[n - 1][n - 2];
        for (int col = n - 3; col >= 0; --col) {
            std::vector<int> nextLevel(n, 0);
            nextLevel[n - 1] = fruits[n - 1][col] + std::max(maxFruits[n - 1], maxFruits[n - 2]);
            for (int row = col + 1; row < n - 1; ++row) {
                nextLevel[row] = fruits[row][col] + 
                    std::max(std::max(maxFruits[row - 1], maxFruits[row]), maxFruits[row + 1]);
            }
            std::swap(maxFruits, nextLevel);
            //for (int i: maxFruits) std::cout << i << "", "";
            //std::cout << std::endl;
        }
        res += maxFruits[n - 1];
        return res;
    }
};",1460913177
97yushr97j,97yushr97j,413,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        long long ans = 0;

        vector<vector<long long>> cost1(26, vector<long long>(26, LLONG_MAX));
        vector<vector<long long>> cost2(26, vector<long long>(26, LLONG_MAX));

        for (int i = 0; i < 26; i++) {
            cost1[i][(i + 1) % 26] = nextCost[i];
            cost2[i][(i - 1 + 26) % 26] = previousCost[i];
        }

        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                for (int j = 0; j < 26; j++) {
                    if (cost1[i][k] != LLONG_MAX && cost1[k][j] != LLONG_MAX) {
                        cost1[i][j] = min(cost1[i][j], cost1[i][k] + cost1[k][j]);
                    }
                }
            }
        }

        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                for (int j = 0; j < 26; j++) {
                    if (cost2[i][k] != LLONG_MAX && cost2[k][j] != LLONG_MAX) {
                        cost2[i][j] = min(cost2[i][j], cost2[i][k] + cost2[k][j]);
                    }
                }
            }
        }

        for (int i = 0; i < n; i++) {
            if (s[i] != t[i]) {
                int x = s[i] - 'a';
                int y = t[i] - 'a';
                ans += min(cost1[x][y], cost2[x][y]);
            }
        }

        return ans;
    }
};
",1460841305
97yushr97j,97yushr97j,413,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        bool turn = false;
        int count = 10;

        while(true) {
            if(n >= count) {
                turn = !turn;
                n-=count;
                count--;
            } else break;
        } 
        return turn;
    }
};",1460800376
97yushr97j,97yushr97j,413,3648,cpp,"class Solution {
public:
    vector<vector<int>> fruits;
    int n;
    
    vector<vector<int>> dp1, dp2;

    int find1(int i, int j) {

        if(i == n-1 && j == n-1) return dp1[i][j] = fruits[i][j];
        if (j <= i) return 0;
        if (i >= n || j < 0 || j >= n) return 0;
        if (dp1[i][j] != -1) return dp1[i][j];

        int maxFruits = fruits[i][j] + max({find1(i + 1, j - 1), find1(i + 1, j), find1(i + 1, j + 1)});
        return dp1[i][j] = maxFruits;
    }

    int find2(int i, int j) {
        if (i <= j) return 0;
        if (i < 0 || j >= n || i >= n) return 0;
        if (dp2[i][j] != -1) return dp2[i][j];

        int maxFruits = fruits[i][j] + max({find2(i - 1, j + 1), find2(i, j + 1), find2(i + 1, j + 1)});
        return dp2[i][j] = maxFruits;
    }

    int maxCollectedFruits(vector<vector<int>>& f) {
        fruits = f;
        n = fruits.size();
        dp1 = vector<vector<int>>(n, vector<int>(n, -1));
        dp2 = vector<vector<int>>(n, vector<int>(n, -1));

        int diagonalFruits = 0;
        for (int i = 0; i < n; i++) {
            diagonalFruits += fruits[i][i];
            fruits[i][i] = 0;
        }

        int temp1 = find1(0, n - 1);
        int temp2 = find2(n - 1, 0);

        cout<<""temp1""<<"" ""<<temp1<<endl;
        cout<<""temp2""<<"" ""<<temp2<<endl;

        return diagonalFruits + temp1 + temp2;
    }
};
",1460902331
Jay Verma,JayVerma,414,3591,python3,"class Solution:
    def shiftDistance(
        self, s: str, t: str, nextCost: list[int], previousCost: list[int]
    ) -> int:
        INF = 10**20
        min_cost = {
            ch: {ch2: INF if ch != ch2 else 0 for ch2 in string.ascii_lowercase}
            for ch in string.ascii_lowercase
        }

        @cache
        def get_min_cost(a: int, b: int):
            if a == b:
                return 0
            # forward
            # fc = nextCost[a] + get_min_cost((a + 1) % 26, b)
            # bc = previousCost[a] + get_min_cost((a + 25) % 26, b)

            i = a
            fc = 0
            while i != b:
                fc += nextCost[i]
                i = (i + 1) % 26

            bc = 0
            i = a
            while i != b:
                bc += previousCost[i]
                i = (i + 25) % 26

            # print('returning ', a, b, fc, bc)
            return min(fc, bc)


        @cache
        def func(i: int = 0):
            if i >= len(s):
                return 0
            return get_min_cost(ord(s[i]) - ord(""a""), ord(t[i]) - ord(""a"")) + func(
                i + 1
            )

        return func()",1460835877
Jay Verma,JayVerma,414,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        turn = 0
        rem = 10
        while n >= rem:
            n -= rem
            rem -= 1
            turn = 1 - turn

        return turn != 0",1460797507
Jay Verma,JayVerma,414,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: list[list[int]]) -> int:
        n = len(fruits)
        INF = 10 ** 10

        @cache
        # lower right guy
        def funclr(i: int, j: int):
            if i >= n:
                return -INF
            if i == n - 1 and j == n - 1:
                return 0
            # clashing with diagonal
            if i <= j:
                return -INF

            return fruits[i][j] + max(
                funclr(i - 1, j + 1), funclr(i, j + 1), funclr(i + 1, j + 1)
            )

        @cache
        # upper right guy
        def funcur(i: int, j: int):
            if j >= n:
                return -INF
            if i == n - 1 and j == n - 1:
                return 0
            # clashing with diagonal
            if i >= j:
                return -INF

            return fruits[i][j] + max(
                funcur(i + 1, j - 1),
                funcur(i + 1, j),
                funcur(i + 1, j + 1),
            )

        # ur + lr + diagonal
        return funclr(n - 1, 0) + funcur(0, n - 1) + sum(fruits[i][i] for i in range(n))",1460913392
Dawn Chen,user1084vL,415,3591,python,"class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        """"""
        :type s: str
        :type t: str
        :type nextCost: List[int]
        :type previousCost: List[int]
        :rtype: int
        """"""
        tofrom = [[float(""inf"") for i in range(26)] for i in range(26)]
        for i in range(26):
            tofrom[i][i] = 0
            tofrom[i][(i+1)%26] = nextCost[i]
            tofrom[i][(i-1)%26] = previousCost[i]
        for i in range(26):
            for j in range(i+1,i+26):
                k = j%26
                p = (k-1)%26
                tofrom[i][k] = min(tofrom[i][k],tofrom[i][p]+nextCost[p])
        for i in range(26):
            for j in range(i-1,i-26,-1):
                k = j%26
                n = (k+1)%26
                tofrom[i][k] = min(tofrom[i][k],tofrom[i][n]+previousCost[n])
        ans = 0
        for i in range(len(s)):
            ans+=tofrom[ord(s[i])-97][ord(t[i])-97]
        return ans",1460811342
Dawn Chen,user1084vL,415,3625,python,"class Solution(object):
    def canAliceWin(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        turn = 'a'
        for i in reversed(range(1,11)):
            if i>n: return turn!= 'a'
            else:
                n-=i
                if turn=='a': turn = 'b'
                else: turn = 'a'",1460797514
Dawn Chen,user1084vL,415,3648,python,"class Solution(object):
    def maxCollectedFruits(self, fruits):
        """"""
        :type fruits: List[List[int]]
        :rtype: int
        """"""
        n = len(fruits)
        tot = 0
        for i in range(n):
            tot+=fruits[i][i]
            fruits[i][i] = 0
        maxdown = [[0 for i in range(n)] for j in range(n)]
        maxdown[0][n-1] = fruits[0][n-1]
        for i in range(1,n):
            for k in range(i):
                p = n-k-1
                for j in [p-1,p,p+1]:
                    if j<0 or j>=n: continue
                    maxdown[i][j] = max(maxdown[i][j],maxdown[i-1][p]+fruits[i][j])
        maxright = [[0 for i in range(n)] for j in range(n)]
        maxright[n-1][0] = fruits[n-1][0]
        for i in range(1,n):
            for k in range(i):
                p = n-k-1
                for j in [p-1,p,p+1]:
                    if j<0 or j>=n: continue
                    maxright[j][i] = max(maxright[j][i],maxright[p][i-1]+fruits[j][i])
        """"""maxvals = [{} for i in range(n)]
        maxvals[0][(n-1,n-1)] = fruits[0][n-1]+fruits[n-1][0]
        for i in range(1,n):
            #print(i)
            for p in maxvals[i-1]:
                #print(p)
                for pi in [p[0]-1,p[0],p[0]+1]:
                    if pi<0 or pi>=n or n-pi>n/2: continue
                    for pj in [p[1]-1,p[1],p[1]+1]:
                        if pj<0 or pj>=n or n-pj>n/2: continue
                        if pi==pj==i: fval = fruits[i][i]
                        else: fval = fruits[i][pi]+fruits[pj][i]
                        #print(fval)
                        #print(maxvals[i-1][p])
                        if (pi,pj) in maxvals[i]:
                            maxvals[i][(pi,pj)] = max(maxvals[i][(pi,pj)],maxvals[i-1][p]+fval)
                        else:
                            maxvals[i][(pi,pj)] = maxvals[i-1][p]+fval
        return maxvals[n-1][(n-1,n-1)]+tot""""""
        #if n<10: print(maxdown,maxright)
        return maxdown[n-1][n-1]+maxright[n-1][n-1]+tot
            ",1460908375
Ayush Raj,anmol1830,416,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long dis[26][26];
        for(int i=0;i<26;i++) {
            for(int j=0;j<26;j++) {
                if(i==j) dis[i][j]=0;
                else dis[i][j]=1e18;
            }
        }
        for(int i=0;i<nextCost.size()-1;i++) {
            dis[i][i+1]=nextCost[i];
        }
        dis[25][0] = nextCost[25];
        for(int i=1;i<previousCost.size();i++) {
            dis[i][i-1] = previousCost[i];
        }
        dis[0][25] = previousCost[0];
        for(int k=0;k<26;k++) {
            for(int i=0;i<26;i++) {
                for(int j=0;j<26;j++) {
                    dis[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]);
                }
            }
        }
        long long ans = 0;
        for(int i=0;i<s.length();i++) {
            int x = int(s[i]-'a'), y = int(t[i]-'a');
            ans+=dis[x][y];
        }
        return ans;
    }
};",1460817311
Ayush Raj,anmol1830,416,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int alice = 0,rem = 10;
        while(n>=rem) {
            n-=rem;
            alice = 1-alice;
            rem--;
        }
        return alice;
    }
};",1460799015
Ayush Raj,anmol1830,416,3648,cpp,"class Solution {
public:
    int dp1[1001][1001],dp2[1001][1001],n;
    int rec1(int i,int j,vector<vector<int>>& a) {
        if(i==n-1 && j==n-1) return 0;
        if(i<0 || i>=n || j<0 || j>=n || i>j) return -1e9; 
        if(dp1[i][j]!=-1) return dp1[i][j];
        int ans = a[i][j]+max({rec1(i+1,j-1,a),rec1(i+1,j,a),rec1(i+1,j+1,a)});
        return dp1[i][j] = ans;
    }
    int rec2(int i,int j,vector<vector<int>>& a) {
        if(i==n-1 && j==n-1) return 0;
        if(i<0 || i>=n || j<0 || j>=n || i<j)  return -1e9; 
        if(dp2[i][j]!=-1) return dp2[i][j];
        int ans = a[i][j]+max({rec2(i-1,j+1,a),rec2(i,j+1,a),rec2(i+1,j+1,a)});
        return dp2[i][j] = ans;
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans = 0;
        n = fruits.size();
        for(int i=0;i<n;i++) {
            for(int j=0;j<n;j++) {
                if(i==j) {
                    ans+=fruits[i][j];
                    fruits[i][j] = 0;
                }
            }
        }
        memset(dp1,-1,sizeof(dp1));
        memset(dp2,-1,sizeof(dp2));
        return ans+rec1(0,n-1,fruits)+rec2(n-1,0,fruits);
    }
};",1460913949
Chao Yu,chao24,417,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        vector<vector<long long>> v(26, vector<long long>(26, 3e10));
        for(int i = 0; i < 26; i++) {
            for(int j = 0; j < 26; j++) {
                if(i == j) v[i][j] = 0;
                //using next
                long long cur = 0;
                int left = i, right = j;
                while((left + 26) % 26 != right) {
                    cur += nc[(left + 26)%26];
                    left++;
                }
                v[i][j] = min(v[i][j], cur);
                //using previous
                cur = 0;
                left = i;
                right = j;
                while((left + 26) % 26 != right) {
                    cur += pc[(left + 26)%26];
                    left--;
                }
                v[i][j] = min(v[i][j], cur);
            }
        }
        
        long long ret = 0;
        for(int i = 0; i < s.size(); i++) {
            ret += v[s[i] - 'a'][t[i] - 'a'];
        }
        return ret;
    }
};",1460837221
Chao Yu,chao24,417,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        //1-10
        if(n < 10) return false;
        if(n < 19) return true;
        if(n < 27) return false;
        if(n < 34) return true;
        if(n < 40) return false;
        if(n < 45) return true;
        if(n < 49) return false;
        return true;
    }
};",1460805127
Chao Yu,chao24,417,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int ret = 0, n = f.size();
        for(int i = 0; i < n; i++) {ret += f[i][i]; f[i][i] = 0;}
        
        vector<vector<int>> dp1(n, vector<int>(n, 0)), dp2(n, vector<int>(n, 0));
        
        vector<vector<int>> f1(f), f2(f);
        //pre processing
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(i < j) f1[i][j] = 0;
                if(i > j) f2[i][j] = 0;
                if(i + j < n - 1) {f1[i][j] = 0; f2[i][j] = 0;}
                
            }
        }
        
        dp1[n - 1][0] = f[n - 1][0];
        for(int j = 1; j < n; j++) {
            for(int i = n - 1; i >= 0; i--) {
                int premax = dp1[i][j - 1];
                if(i + 1 < n) premax = max(premax, dp1[i + 1][j - 1]);
                if(i - 1 >= 0) premax = max(premax, dp1[i - 1][j - 1]);
                dp1[i][j] = f1[i][j] + premax;
            }
        }
        
        dp2[0][n - 1] = f[0][n - 1];
        for(int i = 1; i < n; i++) {
            for(int j = n - 1; j >= 0; j--) {
                int premax = dp2[i - 1][j];
                if(j - 1 >= 0) premax = max(premax, dp2[i - 1][j - 1]);
                if(j + 1 < n) premax = max(premax, dp2[i - 1][j + 1]);
                dp2[i][j] = f2[i][j] + premax;
            }
        }
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                
                //cout<<dp1[i][j] << "" "";
            }
            //cout<<endl;
        }
        //cout<<dp1[n - 1][n - 1]<<"":""<<dp2[n - 1][n - 1]<<endl;
        ret += dp1[n - 1][n - 1];
        ret += dp2[n - 1][n - 1];
        return ret;
    }
};",1460903055
whdnddh,whdnddh,418,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        s = [ord(x) - ord('a') for x in s]
        t = [ord(x) - ord('a') for x in t]
        ct = 0
        for i in range(len(s)):
            # next
            cn = 0
            x = s[i]
            while x != t[i]:
                cn += nextCost[x]
                x = (x + 1) % 26

            # previous
            cp = 0
            x = s[i]
            while x != t[i]:
                cp += previousCost[x]
                x = (x - 1) % 26

            ct += min(cn, cp)
        return ct",1460821257
whdnddh,whdnddh,418,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        k = 10
        a = False
        while k <= n:
            n -= k
            k -= 1
            a = not a
        return a",1460801257
whdnddh,whdnddh,418,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        
        # (0, 0)
        for i in range(n):
            ans += fruits[i][i]
        # print(ans)

        # (0, n-1)
        def get1(i, j):
            if i+j < n-1 or (n-1-i)+j < n-1 or i == j:
                return 0
            return fruits[i][j]
        M = [[0]*n for _ in range(n)]
        M[0][n-1] = fruits[0][n-1]
        for i in range(1, n//2):
            for j in range(n-1-i, n):
                M[i][j] = get1(i, j) + max(M[i-1][max(j-1, 0)], M[i-1][j], M[i-1][min(j+1, n-1)])
        for i in range(n//2, n):
            for j in range(i, n):
                M[i][j] = get1(i, j) + max(M[i-1][max(j-1, 0)], M[i-1][j], M[i-1][min(j+1, n-1)])
        ans += M[n-1][n-1]
        # print(M)

        # (n-1, 0)
        def get2(i, j):
            if i+j < n-1 or i+(n-1-j) < n-1 or i == j:
                return 0
            return fruits[i][j]
        M = [[0]*n for _ in range(n)]
        M[n-1][0] = fruits[n-1][0]
        for j in range(1, n//2):
            for i in range(n-1-j, n):
                M[i][j] = get2(i, j) + max(M[max(i-1, 0)][j-1], M[i][j-1], M[min(i+1, n-1)][j-1])
        for j in range(n//2, n):
            for i in range(j, n):
                M[i][j] = get2(i, j) + max(M[max(i-1, 0)][j-1], M[i][j-1], M[min(i+1, n-1)][j-1])
        ans += M[n-1][n-1]
        # print(M)

        return ans

        ",1460908572
dingotron,dingotron,422,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nexx: List[int], prev: List[int]) -> int:
        def asc(char):
            return ord(char) - ord('a')

            
        pfnext = [0]
        pfprev = [0]
        for i in range(26):
            pfnext.append(pfnext[-1] + nexx[i])
            pfprev.append(pfprev[-1] + prev[i])

        int("""".join(map(str, pfnext))[:10])
        
        run = 0
        for i in range(len(s)):
            diff = ord(t[i]) - ord(s[i])
            if diff > 0:
                forwcost = pfnext[asc(t[i])] - pfnext[asc(s[i])]
                backcost = pfprev[-1] - (pfprev[asc(t[i]) + 1] - pfprev[asc(s[i]) + 1])
                run += min(forwcost, backcost)
            elif diff < 0:
                forwcost = pfnext[-1] - (pfnext[asc(s[i])] - pfnext[asc(t[i])])
                backcost = pfprev[asc(s[i]) + 1] - pfprev[asc(t[i]) + 1]
                run += min(forwcost, backcost)
        return run
        
        
        ",1460866357
dingotron,dingotron,422,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i in range(10, 1, -1):
            n -= i 
            if n < 0:
                return True if i % 2 else False
            
            
            
            
        ",1460802248
dingotron,dingotron,422,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        N = len(fruits)
        mid = sum(fruits[i][i] for i in range(N))
        h1 = [fruits[0][-1]]
        for i in range(1, N-1):
            temp = []
            lim = min(N-(i+1), i+1)
            for j in range(lim):
                cur = fruits[i][-j-1]
                poss = [h1[k] for k in range(j-1,j+2) if 0 <= k < len(h1)]
                temp.append(cur+max(poss))
            h1 = temp.copy()

        h2 = [fruits[-1][0]]
        for i in range(1, N-1):
            temp = []
            lim = min(N-(i+1), i+1)
            for j in range(lim):
                cur = fruits[-j-1][i]
                poss = [h2[k] for k in range(j-1,j+2) if 0 <= k < len(h2)]
                temp.append(cur+max(poss))
            h2 = temp.copy()
        return mid + h1[0] + h2[0]
        
                    
                
        ",1460914870
Vishnu Bathla,directioner1d,423,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        @cache
        def forward(ch,fin):
            if(ch==fin):
                return 0
            p=ord(ch)-ord('a')
            q=ord(fin)-ord('a')
            return nextCost[p]+forward(chr(ord('a')+((p+1)%26)),fin)
        @cache
        def previous(ch,fin):
            if(ch==fin):
                return 0
            p=ord(ch)-ord('a')
            q=ord(fin)-ord('a')
            return previousCost[p]+previous(chr(ord('a')+((26+p-1)%26)),fin)
        # print(forward('a','z'))
        # return 0
        ans=0
        for i in range(len(s)):
            ans+=min(forward(s[i],t[i]),previous(s[i],t[i]))
        return ans",1460815634
Vishnu Bathla,directioner1d,423,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        ini=n
        t=10
        c=0
        while(ini>=t):
            # print(ini)
            ini-=t
            t-=1
            c=(c+1)%2
        return c==1
            
        ",1460799953
Vishnu Bathla,directioner1d,423,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        f1 = 0
        n = len(fruits)
        for i in range(n):
            f1 += fruits[i][i]
            fruits[i][i] = 0
        @cache
        def do(x, y, dirx, op):
            if x < 0 or y < 0 or x >= n or y >= n:
                return -float('inf')
            if (x, y) == (n-1, n-1):
                return fruits[x][y]
            ans = -float('inf')
            for i, j in dirx:
                if op == 0 and not (x + i <= y + j):
                    continue
                elif op == 1 and not (x + i >= y + j):  
                    continue
                ans = max(ans, fruits[x][y] + do(x + i, y + j, dirx, op))
            return ans
        f2 = do(0, n - 1, ((1, -1), (1, 0), (1, 1)), 0)
        # print(f2)
        f3 = do(n - 1, 0, ((-1, 1), (0, 1), (1, 1)), 1)  
        return f1 + f2 + f3
",1460909437
Marius Beceanu,mbeceanu,424,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nC: List[int], pC: List[int]) -> int:
        sm=0
        lst1=[0]
        for i in range(26):
            sm+=nC[i]
            lst1.append(sm)
        for i in range(26):
            sm+=nC[i]
            lst1.append(sm)
        sm=0
        lst2=[0]
        for i in range(26):
            sm+=pC[i]
            lst2.append(sm)
        for i in range(26):
            sm+=pC[i]
            lst2.append(sm)
        for i in range(26):
            sm+=pC[i]
            lst2.append(sm)
        dst1=lambda a, b: lst1[b]-lst1[a] if a<=b else lst1[b+26]-lst1[a]
        dst2=lambda a, b: lst2[a+1]-lst2[b+1] if a>=b else lst2[a+27]-lst2[b+1]
        ans=0
        orda=ord('a')
        l=len(s)
        s=[ord(s[i])-orda for i in range(l)]
        t=[ord(t[i])-orda for i in range(l)]
        print(lst1, lst2)
        print(dst1(0, 1), dst2(0, 1))
        print(dst1(1, 0), dst2(1, 0))
        for c1, c2 in zip(s, t):
            ans+=min(dst1(c1, c2), dst2(c1, c2))
        return ans
        ",1460839556
Marius Beceanu,mbeceanu,424,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        ct=10
        k=0
        while ct>=0 and ct<=n:
            n-=ct
            ct-=1
            k+=1
        if k&1:
            return True
        else:
            return False
        ",1460797630
Marius Beceanu,mbeceanu,424,3648,python3,"class Solution:
    def maxCollectedFruits(self, f: List[List[int]]) -> int:
        l=len(f)
        # for i in range(l):
        #     print(f[i][i])
        sm=sum(f[i][i] for i in range(l))
        dct={(0, l-1):f[0][l-1]}
        q=[(0, l-1)]
        a2=0
        while q:
            tmp=[]
            for it in q:
                x2, y2 = it
                val=dct[it]
                for (dx2, dy2) in [(1, -1), (1, 0), (1, 1)]:
                    x22, y22=x2+dx2, y2+dy2
                    if (x22<y22 and 0<=x22 and y22<l):
                        v2=val+f[x22][y22]
                        if (x22, y22) not in dct:
                            tmp.append((x22, y22))
                        if (x22, y22) not in dct or dct[(x22, y22)]<v2:
                            dct[(x22, y22)]=v2
                    elif (x22==y22 and y22==l-1):
                        a2=max(a2, val)
            q=tmp
        dct={(l-1, 0):f[l-1][0]}
        q=[(l-1, 0)]
        a3=0
        while q:
            tmp=[]
            for it in q:
                x2, y2 = it
                val=dct[it]
                for (dx2, dy2) in [(-1, 1), (0, 1), (1, 1)]:
                    x22, y22=x2+dx2, y2+dy2
                    if (x22>y22 and 0<=y22 and x22<l):
                        v2=val+f[x22][y22]
                        if (x22, y22) not in dct:
                            tmp.append((x22, y22))
                        if (x22, y22) not in dct or dct[(x22, y22)]<v2:
                            dct[(x22, y22)]=v2
                    elif (x22==y22 and y22==l-1):
                        a3=max(a3, val)
            q=tmp
        print(sm, a2, a3)
        return sm+a2+a3
                        
                        
                    ",1460915056
sandeep,Lunar003,425,3591,cpp,"class Solution {
private:
    typedef long long ll;
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        // vector<ll> c(n,0);
        ll ans = 0;
        for(int i=0;i<n;i++){
            if(s[i]^t[i]){
                // ans+= min(nextCost[s[i]-'a'],previousCost[s[i]-'a']);
                ll nxt = 0,prev = 0;
                if(t[i]>s[i]){
                    nxt =0;
                    for(char c = s[i];c<t[i];c++){
                        nxt+= nextCost[c-'a'];
                    }
                }
                else{
                    nxt = 0;
                    for(char c = s[i];c<='z';c++){
                        nxt+=nextCost[c-'a'];
                    }
                    for(char c = 'a';c<t[i];c++){
                        nxt+=nextCost[c-'a'];
                    }
                    // nxt = ('z'-s[i])*nextCost[s[i]-'a'];
                    // nxt+=(t[i])*nextCost[s[i]-'a'];
                }
                if(s[i]>t[i]){
                    prev = 0;
                    for(char c = s[i];c>t[i];c--){
                        prev += previousCost[c-'a'];
                    }
                    // prev = (s[i]-t[i])*previousCost[s[i]-'a'];
                }
                else{
                     for(char c = s[i];c>='a';c--){
                        prev += previousCost[c-'a'];
                    }
                    for(char c = 'z';c>t[i];c--){
                        prev+= previousCost[c-'a'];
                    }
                    // prev = s[i]*previousCost[s[i]-'a'];
                    // prev+=('z'-t[i])*previousCost[s[i]-'a'];
                }
                // cout<<i<<"" ""<<nxt<<"" ""<<prev<<endl;
                ans+= min(nxt,prev);
            }
        }
        return ans;
        
    }
};",1460838771
sandeep,Lunar003,425,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool f = 0;
        int t = 10;
        while(n>=t){
            // cout<<n<<"" ""<<t<<endl;
            f = !f;
            n-=t;
            t--;
        }
        if(f)return 1;
        else return 0;
    }
};",1460802163
sandeep,Lunar003,425,3648,cpp,"class Solution {
private:
    typedef long long ll;
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        vector<vector<ll>> dp(n+1,vector<ll>(n+1,0)),dpp = dp;
        ll d = 0,a=0,b=0;
        int i1=0,j=0;
        while(i1<n){
            d += fruits[i1++][j++];
        }
        j = 0;
        while(j<n-1){
            // cout<<j<<"" "";cout<<endl;
            for(int i= n-1;i>=(n-1-j);i--){
                // cout<<i<<"" "";
                if(i==j)break;
                dp[i][j] = fruits[i][j]; //+(j>0)?max({dp[i][j-1],((j-1)!=(i-1))?dp[i-1][j-1]:0,(i<n-1)?dp[i+1][j-1]:0}):0;
                if(j>0){
                    dp[i][j] += max({dp[i][j-1],dp[i-1][j-1],((i<n-1)?dp[i+1][j-1]:0)});
                }
            }
            // cout<<endl;
            
            j++;
        }
        i1 = 0;
        while(i1<n-1){
            for(int j1=n-1;j1>=(n-1-i1);j1--){
                if(i1==j1)break;
                dpp[i1][j1] = fruits[i1][j1];
                if(i1>0){
                    dpp[i1][j1]+= max({dpp[i1-1][j1],(j1<n-1)?dpp[i1-1][j1+1]:0,dpp[i1-1][j1-1]});
                }
            }
            i1++;
        }
        a = dp[n-1][n-2];
        b = dpp[n-2][n-1];
        // for(auto &i:dpp){
        //     for(auto &j:i)cout<<j<<"" "";cout<<endl;
        // }
        return d+a+b;
    }
};",1460909618
Arham Ali,crack_leet97,426,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nxt, int[] pvt) {
        
        long ans=0;
        int n=s.length();
        
        for(int i=0;i<n;i++){
            
            if(s.charAt(i)!=t.charAt(i)){
                
                int idx=t.charAt(i)-'a';
                
                int nt=s.charAt(i)-'a';
                int pv=s.charAt(i)-'a';
                
                long chk1=0,chk2=0;
                while(nt!=idx){
                    chk1+=nxt[nt];
                    nt=(nt+1)%26;
                }
                
                while(pv!=idx){
                    chk2+=pvt[pv];
                    pv=(26+(pv-1))%26;
                }
                
                ans+=Math.min(chk1,chk2);
                
            }
            
        }
        
        return ans;
        
    }
}",1460819045
Arham Ali,crack_leet97,426,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int i=10;
        int ch=1;
        while(n>=i){
            n-=i;
            ch=ch==1?0:1;
            i--;
        }
        
        return ch!=1;
        
    }
}",1460799485
Arham Ali,crack_leet97,426,3648,java,"class Solution {
    static int dp[][];
    static int n;
    public static int call1(int fruits[][], int i,int j,int mv){
        if(i==n-1 && j==n-1 && mv==0){return 0;}
        if( mv==0 || i<0 || j<0 ||  i>=n || j>=n){return -10000000;}
        
        if(dp[i][j]!=-1){return dp[i][j];}
        
        int max=Integer.MIN_VALUE;
        max=Math.max(max,call1(fruits,i+1,j+1,mv-1));
        max=Math.max(max,call1(fruits,i+1,j-1,mv-1));
        max=Math.max(max,call1(fruits,i+1,j,mv-1));
        
        return dp[i][j]=max+fruits[i][j];
        
        
    }
    
    
    public static int call2(int fruits[][], int i,int j,int mv){
        if(i==n-1 && j==n-1 && mv==0){return 0;}
        if(mv==0 || i<0 || j<0 ||  i>=n || j>=n || i==j ){return -10000000;}
        
        if(dp[i][j]!=-1){return dp[i][j];}
        
        int max=Integer.MIN_VALUE;
        max=Math.max(max,call2(fruits,i-1,j+1,mv-1));
        max=Math.max(max,call2(fruits,i+1,j+1,mv-1));
        max=Math.max(max,call2(fruits,i,j+1,mv-1));
        
        return dp[i][j]=max+fruits[i][j];
        
        
    }
    
    
    
    public int maxCollectedFruits(int[][] fruits) {
        
        n=fruits.length;
        dp=new int[n][n];
        
//          dig sum;
        int sum=0;    
        for(int i=0;i<n;i++){
            sum+=fruits[i][i];
            fruits[i][i]=-100;
        }
        
        
//          right half
        
        for(int i[]:dp){Arrays.fill(i,-1);}
  int m1=call1(fruits,0,n-1,n-1);
        
        for(int i[]:dp){Arrays.fill(i,-1);}
  int m2=call2(fruits,n-1,0,n-1);
        

        
        return m1+m2+sum;
        
        
        
        
    }
}",1460898777
Naveen Tripathi,Shoo-lin,429,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        
        def forwardCost(letter , nextCost , target):
            curCost  = nextCost[abs(97 - ord(letter))]

            curOrder = ord(letter) + 1
            if curOrder > 122:
                curOrder = 97
                
            while curOrder != ord(target):
                curCost+=nextCost[abs(97 - curOrder)]
                curOrder+=1
                if curOrder > 122:
                    curOrder = 97
                    
            return curCost
        
        def backwordCost(letter , previousCost , target):
            curCost = previousCost[abs(97 - ord(letter))]
            curOrder = ord(letter) - 1
            if curOrder < 97:
                curOrder = 122
                
            while curOrder!= ord(target):
                curCost+=previousCost[abs(97  - curOrder)]
                curOrder-=1
                if curOrder < 97:
                    curOrder = 122
                    
            return curCost
                    
        total_cost = 0
        for i in range(len(s)):
            if s[i] != t[i]:
                total_cost+= min(forwardCost(s[i] , nextCost , t[i]) , backwordCost(s[i] , previousCost , t[i]))
                
        return total_cost
                    
        ",1460846542
Naveen Tripathi,Shoo-lin,429,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        curR  = 10
        remC  = 0

        while n >= curR:
            n-=curR
            curR-=1
            remC+=1

        return remC%2!=0

        ",1460801939
Naveen Tripathi,Shoo-lin,429,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        
        Sum = 0
        i = 0
        n = len(fruits)
        
        dp1 = [[-1 for i in range(n)] for j in range(n)]
        dp2 = [[-1 for i in range(n)] for j in range(n)]
        
        while i < len(fruits):
    
            Sum+=fruits[i][i]
            fruits[i][i] = -1
            i+=1
            
        def countMaxSum1(i , j , steps , n):
            
            if steps < 0 or i < 0 or j < 0 or i >= n or j >= n:
                return float(""-inf"")
            
            if steps == 0 and i == n - 1 and j == n - 1:
                return 0
            
            if dp1[i][j] !=-1:
                return dp1[i][j]
            
            res = 0
            
            if fruits[i][j] != -1:
                res = fruits[i][j] + max(countMaxSum1(i + 1 , j - 1 , steps - 1 , n) , countMaxSum1(i + 1 , j , steps - 1 , n) , countMaxSum1(i + 1 , j + 1, steps - 1 , n))
                
            dp1[i][j] = res
                
            return res
        
        def countMaxSum2(i , j , steps , n):
            if steps < 0 or i < 0 or j < 0 or i >= n or j >= n:
                return float(""-inf"")
            
            if steps == 0 and i == n - 1 and j == n - 1:
                return 0
            
            if dp2[i][j] !=-1:
                return dp2[i][j]
            
            res = 0
            
            if fruits[i][j] != -1:
                res = fruits[i][j] + max(countMaxSum2(i - 1 , j + 1 , steps - 1 , n) , countMaxSum2(i  , j + 1 , steps - 1 , n) , countMaxSum2(i + 1 , j + 1, steps - 1 , n))
                
            dp2[i][j] = res
                
            return res
        
        return Sum + countMaxSum1(0 , n - 1 , n -1 , n) + countMaxSum2(n - 1 , 0 , n - 1 , n)
        
        
                
            
        
        
                
                
        ",1460915804
Aayush Gupta,Aayush65,430,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        def findCheapestWay(start: int, end: int) -> int:
            costNext = 0
            i, j = start, end
            while i != j:
                costNext += nextCost[i]
                i = (i + 1) % 26
            costPrev = 0
            i, j = start, end
            while i != j:
                costPrev += previousCost[i]
                i = (i - 1) % 26
            return min(costNext, costPrev)

        indexOf = lambda x: ord(x) - ord('a')
        
        cost = 0
        for i, j in zip(s, t):
            cost += findCheapestWay(indexOf(i), indexOf(j))
        return cost",1460817002
Aayush Gupta,Aayush65,430,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        aliceTurn = True
        removal = 10
        while n >= removal:
            n -= removal
            removal -= 1
            aliceTurn = not aliceTurn
        return not aliceTurn",1460796648
Aayush Gupta,Aayush65,430,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        res = 0
        for i in range(n):
            res += fruits[i][i]
            fruits[i][i] = 0
    
        isValid = lambda x, y: -1 < x < n and -1 < y < n

        @cache
        def dp(x: int, y: int, isLowerHalf: bool ) -> int:
            if not isValid(x, y):
                return -inf
            if x == y == n - 1:
                return 0 if x == n - 1 else -inf
            res = 0
            if isLowerHalf:
                res = max(dp(x - 1, y + 1, True), 
                          dp(x, y + 1, True), 
                          dp(x + 1, y + 1, True))
            else:
                res = max(dp(x + 1, y + 1, False), 
                          dp(x + 1, y, False), 
                          dp(x + 1, y - 1, False))
            return res + fruits[x][y]
        
        res += dp(n - 1, 0, True) + dp(0, n - 1, False)
        dp.cache_clear()
        return res",1460910325
Lord Algorithm,LordAlgorithms,431,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans = 0
        ab = {c: i for i, c in enumerate(ascii_lowercase)}

        psm_nxt = [0] * 53
        psm_pre = [0] * 53
        for i in range(52):
            psm_nxt[i] = psm_nxt[i-1] + nextCost[i % 26]
        for i in range(52):
            psm_pre[i] = psm_pre[i - 1] + previousCost[i % 26]

        dp = [[0] * 26 for _ in range(26)]
        for i in range(26):
            for j in range(26):
                if i != j:
                    if j < i:
                        j += 26
                    dp[i][j % 26] = psm_nxt[j-1]-psm_nxt[i-1]
        for i in range(26):
            for j in range(26):
                if i != j:
                    if i < j:
                        i += 26
                    dp[i % 26][j] = min(dp[i % 26][j], psm_pre[i]-psm_pre[j])

        for c1, c2 in zip(s, t):
            i, j = ab[c1], ab[c2]
            ans += dp[i][j]
        return ans",1460840734
Lord Algorithm,LordAlgorithms,431,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        start = 10
        player = ""A""
        while True:
            if start < 0 or n < start:
                if player == ""A"":
                    return False
                else:
                    return True
            else:
                n -= start
                start -= 1
                if player == ""A"":
                    player = ""B""
                else:
                    player = ""A""",1460802302
Lord Algorithm,LordAlgorithms,431,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        ans = 0
        for i in range(n):
            ans += fruits[i][i]
            fruits[i][i] = 0

        dp = [[0] * n for _ in range(n)]
        dp[n - 1][0] = fruits[n - 1][0]
        for ic in range(1, n):
            for ir in range(max(ic, n-ic-1), n):
                dp[ir][ic] = max(dp[ir - 1][ic - 1], dp[ir][ic - 1]) + fruits[ir][ic]
                if ir + 1 < n:
                    dp[ir][ic] = max(dp[ir][ic], dp[ir + 1][ic - 1] + fruits[ir][ic])
        ans += dp[n - 1][n - 1]

        dp = [[0] * n for _ in range(n)]
        dp[0][n - 1] = fruits[0][n - 1]
        for ir in range(1, n):
            for ic in range(max(ir, n-ir-1), n):
                dp[ir][ic] = max(dp[ir - 1][ic - 1], dp[ir - 1][ic]) + fruits[ir][ic]
                if ic + 1 < n:
                    dp[ir][ic] = max(dp[ir][ic], dp[ir - 1][ic + 1] + fruits[ir][ic])
        ans += dp[n - 1][n - 1]

        return ans",1460910432
mark93192,mark93192,432,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        long long from_next[26][26]={{0}};
        long long from_previous[26][26]={{0}};
        for(int i=0;i<=25;i++){
            int index=i;
            from_next[i][i]=0;
            for(int j=1;j<=25;j++){
                index++;
                if(index<=25){
                    from_next[i][index]=from_next[i][index-1]+static_cast<long long>(nextCost[index-1]);
                }
                else{
                    index=0;
                    from_next[i][0]=from_next[i][25]+static_cast<long long>(nextCost[25]);
                }
            }
        }
        for(int i=0;i<=25;i++){
            int index=i;
            from_previous[i][i]=0;
            for(int j=1;j<=25;j++){
                index--;
                if(index>=0){
                    from_previous[i][index]=from_previous[i][index+1]+static_cast<long long>(previousCost[index+1]);                    
                }
                else{
                    index=25;
                    from_previous[i][25]=from_previous[i][0]+static_cast<long long>(previousCost[0]);
                }
            }
        }
        for(int i=0;i<s.size();i++){
            ans+=min(from_next[s[i]-'a'][t[i]-'a'],from_previous[s[i]-'a'][t[i]-'a']);
        }
        return ans;
    }
};",1460818509
mark93192,mark93192,432,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int a_or_b=0;
        int move_now=10;
        int temp=n;
        while(1){
            if(temp-move_now<0){
                break;
            }
            else if(a_or_b==0){
                temp=temp-move_now;
                move_now--;
                a_or_b=1;
            }
            else{
                temp=temp-move_now;
                move_now--;
                a_or_b=0;
            }
        }
        if(a_or_b==0){
            return false;
        }
        else{
            return true;
        }
    }
};",1460798371
mark93192,mark93192,432,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n=fruits.size();
        vector<vector<int>> dp_0(fruits.size(),vector<int>(fruits.size(),0));
        dp_0[0][n-1]=fruits[0][n-1];
        for(int i=1;i<n-1;i++){
            for(int j=n-1;j>=n-i-1&&j>i;j--){
                int choose=max(dp_0[i-1][j],dp_0[i-1][j-1]);
                if(j!=n-1){
                    choose=max(choose,dp_0[i-1][j+1]);
                }
                dp_0[i][j]=choose+fruits[i][j];
            }
        }
      
        vector<vector<int>> dp_1(fruits.size(),vector<int>(fruits.size(),0));
        dp_1[n-1][0]=fruits[n-1][0];
        for(int i=1;i<n-1;i++){
            for(int j=n-1;j>=n-i-1&&j>i;j--){
                int choose=max(dp_1[j][i-1],dp_1[j-1][i-1]);
                if(j!=n-1){
                    choose=max(choose,dp_1[j+1][i-1]);
                }
                dp_1[j][i]=choose+fruits[j][i];
            }
        }
        
        int ans=0;
        for(int i=0;i<n;i++){
            ans+=fruits[i][i];
        }
        ans+=dp_0[n-2][n-1];
        ans+=dp_1[n-1][n-2];
        return ans;
    }
};",1460905023
ssyy1106,ssyy1106,433,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        n = len(s)
        def fun(char1, char2) -> int:
            index1, index2 = ord(char1) - ord('a'), ord(char2) - ord('a')
            res = 0
            minimum = 0
            for i in range(index1, index2):
                res += nextCost[i]
            minimum = res
            res = 0
            for i in range(index1 + 1, index2 + 1):
                res += previousCost[i]
            minimum = min(minimum, sum(previousCost) - res)
            return minimum
        def fun2(char1, char2) -> int:
            index1, index2 = ord(char1) - ord('a'), ord(char2) - ord('a')
            res = 0
            minimum = 0
            for i in range(index2, index1):
                res += nextCost[i]
            minimum = sum(nextCost) - res
            res = 0
            for i in range(index1, index2, -1):
                res += previousCost[i]
            minimum = min(minimum, res)
            return minimum

        for i in range(n):
            char1, char2 = s[i], t[i]
            if ord(char1) > ord(char2):
                res += fun2(char1, char2)
            else:
                res += fun(char1, char2)
        return res",1460916251
ssyy1106,ssyy1106,433,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        res = False
        while n >= cur:
            n -= cur
            cur -= 1
            res = not res
        return res",1460914199
ssyy1106,ssyy1106,433,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        output = sum(fruits[i][i] for i in range(n))
        dp = [[-1] * n for _ in range(n)]
        dp[0][-1] = fruits[0][-1]
        for i in range(1, n):
            for j in range(n):
                addon = fruits[i][j] if i != j else 0
                if dp[i - 1][j] != -1:
                    dp[i][j] = dp[i - 1][j] + addon
                if j > 0 and dp[i - 1][j - 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + addon)
                if j < n - 1 and dp[i - 1][j + 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + addon)
        
        output += dp[-1][-1]

        dp = [[-1] * n for _ in range(n)]
        dp[-1][0] = fruits[-1][0]
        for j in range(1, n):
            for i in range(n - 1, -1, -1):
                addon = fruits[i][j] if i != j else 0
                if dp[i][j - 1] != -1:
                    dp[i][j] = dp[i][j - 1]+ addon
                if i > 0 and dp[i - 1][j - 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + addon)
                if i < n - 1 and dp[i + 1][j - 1] != -1:
                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + addon)  
        output += dp[-1][-1]
        return output",1460913376
Ibrokhim,shockyrow,436,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> minCosts = vector<vector<long long>>(26, vector<long long>(26, -1));

        for (int i = 0; i < 26; i++) {
            minCosts[i][i] = 0;

            for (int j = 1; j < 26; j++) {
                long long nextTotalCost = 0, prevTotalCost = 0;
                
                for (int k = i; k != (i + j) % 26; k = (k + 1) % 26) {
                    nextTotalCost += nextCost[k];
                }
                
                for (int k = i; k != (i + j) % 26; k = (k - 1 + 26) % 26) {
                    prevTotalCost += previousCost[k];
                }

                minCosts[i][(i + j) % 26] = min(nextTotalCost, prevTotalCost);
            }
        }

        long long total = 0;

        for (int i = 0; i < s.size(); i++) {
            total += minCosts[s[i] - 'a'][t[i] - 'a'];
        }

        return total;
    }
};",1460843197
Ibrokhim,shockyrow,436,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool aliceWins = false;
        int toRemove = 10;

        while (n >= toRemove) {
            n -= toRemove;
            toRemove--;
            aliceWins ^= true;
        }

        return aliceWins;
    }
};",1460816254
Ibrokhim,shockyrow,436,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int bottom = check(fruits, {{-1, 1}, {0, 1}, {1, 1}}, {(int)fruits.size() - 1, 0}, {(int)fruits.size() - 1, (int)fruits.size() - 2});
        int top    = check(fruits, {{1, -1}, {1, 0}, {1, 1}}, {0, (int)fruits.size() - 1}, {(int)fruits.size() - 2, (int)fruits.size() - 1});

        for (int i = 0; i < fruits.size(); i++) {
            top += fruits[i][i];
        }

        return top + bottom;
    }

    int check(vector<vector<int>>& fruits, vector<vector<int>> moves, vector<int> start, vector<int> end) {
        vector<vector<int>> total = vector<vector<int>>(fruits.size(), vector<int>(fruits[0].size(), -1));
        queue<vector<int>> nextRoom;

        total[start[0]][start[1]] = fruits[start[0]][start[1]];
        nextRoom.push(start);

        while (!nextRoom.empty()) {
            vector<int> pos = nextRoom.front();
            nextRoom.pop();

            for (vector<int>& move : moves) {
                int x = pos[0] + move[0], y = pos[1] + move[1];

                if (x < 0 || y < 0 || x >= fruits.size() || y >= fruits.size()) {
                    continue;
                }
                
                if (total[x][y] == -1) {
                    nextRoom.push({x,y});
                }

                total[x][y] = max(total[x][y], total[pos[0]][pos[1]] + fruits[x][y]);
            }
        }

        return total[end[0]][end[1]];
    }
};",1460916576
hope_ma,hope_ma,438,3591,python3,"class Solution:
  def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
    letters = 26
    a = ord('a')
    presums_next = [0 for _ in range(letters + 1)]
    for letter in range(letters):
      presums_next[letter + 1] = presums_next[letter] + nextCost[letter]
    presums_previous = [0 for _ in range(letters + 1)]
    for letter in range(letters - 1, -1, -1):
      presums_previous[letter] = presums_previous[letter + 1] + previousCost[letter]
    n = len(s)
    dp = [0 for _ in range(n + 1)]
    for i in range(n):
      sl = ord(s[i]) - a
      tl = ord(t[i]) - a
      dp[i + 1] = dp[i] + min(
        presums_next[tl] - presums_next[sl] if sl <= tl else presums_next[letters] - presums_next[sl] + presums_next[tl],
        presums_previous[tl + 1] - presums_previous[sl + 1] if sl >= tl else presums_previous[0] - presums_previous[sl + 1] + presums_previous[tl + 1]
      )
    return dp[-1]",1460852966
hope_ma,hope_ma,438,3625,python3,"class Solution:
  def canAliceWin(self, n: int) -> bool:
    removed = 10
    is_alice = False
    while n >= removed:
      n -= removed
      removed -= 1
      is_alice = not is_alice
    return is_alice",1460816527
hope_ma,hope_ma,438,3648,python3,"class Solution:
  def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
    n = len(fruits)
    ret = 0
    for i in range(n):
      ret += fruits[i][i]
    
    dp = [[-inf for _ in range(n)] for _ in range(n)]
    dp[n - 1][0] = fruits[n - 1][0]
    for c in range(1, n - 1):
      for r in range(1, n):
        for offset in range(-1, 2):
          pr = r + offset
          if -1 < pr < n:
            dp[r][c] = max(dp[r][c], fruits[r][c] + dp[pr][c - 1])
    ret += dp[n - 1][n - 2]
    #print(dp[n - 1][n - 2])
    
    dp = [[-inf for _ in range(n)] for _ in range(n)]
    dp[0][n - 1] = fruits[0][n - 1]
    for r in range(1, n - 1):
      for c in range(1, n):
        for offset in range(-1, 2):
          pc = c + offset
          if -1 < pc < n:
            dp[r][c] = max(dp[r][c], fruits[r][c] + dp[r - 1][pc])
    ret += dp[n - 2][n - 1]
    #print(dp[n - 2][n - 1])
    return ret",1460900499
Jacky Chen,jacky3627,440,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long result = 0ll;
        int n = s.size();
        vector<vector<long long>> transferR(26, vector<long long>(26));
        vector<vector<long long>> transferL(26, vector<long long>(26));

        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                int r = j >= i ? j : j+26;
                for (int k = i; k < r; k++) {
                    transferR[i][j] += nextCost[k%26];
                }

                int l = j <= i ? j : j-26;
                for (int k = i; k > l; k--) {
                    transferL[i][j] += previousCost[(k+26)%26];
                }
            }
        }


        for (int i = 0; i < n; i++) {
            long long nc = transferR[s[i]-'a'][t[i]-'a'];
            long long pc = transferL[s[i]-'a'][t[i]-'a'];
            result += min(nc, pc);
        }
        return result;
    }
};",1460844126
Jacky Chen,jacky3627,440,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int s = 10;
        bool a = true;
        while (n) {
            if (n < s) return !a;
            n -= s;
            s--;
            a = !a;
        }
        return !a;
    }
};",1460798995
Jacky Chen,jacky3627,440,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int result = 0;
        int n = fruits.size();
        for (int i = 0; i < n; i++) {
            result += fruits[i][i];
        }

        vector<vector<int>> B(n, vector<int>(n));
        vector<vector<int>> C(n, vector<int>(n));

        B[n-1][0] = fruits[n-1][0];
        C[0][n-1] = fruits[0][n-1];
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                if (r + c >= n-1 && r > c) {
                    B[r][c] = fruits[r][c];
                }

                if (r + c >= n-1 && c > r) {
                    C[r][c] = fruits[r][c];
                }
            }
        }

        for (int c = 1; c < n; c++) {
            for (int r = 0; r < n; r++) {
                int maxPrev = B[r][c-1];
                for (int pr = max(0, r-1); pr <= min(n-1, r+1); pr++) {
                    maxPrev = max(maxPrev, B[pr][c-1]);
                }    
                B[r][c] += maxPrev;
            }
        }
        
        for (int r = 1; r < n; r++) {
            for (int c = 0; c < n; c++) {
                int maxPrev = C[r-1][c];
                for (int pc = max(0, c-1); pc <= min(n-1, c+1); pc++) {
                    maxPrev = max(maxPrev, C[r-1][pc]);
                }    
                C[r][c] += maxPrev;
            }
        }

        return result+B[n-1][n-1] + C[n-1][n-1];
    }
};",1460906260
bofeng07,bofeng07,441,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        dicti = [[0] * 26 for _ in range(26)]
        for i in range(26):
            cost, index = 0, i
            for j in range(25):
                new = (index + 1) % 26
                cost += nextCost[index]
                dicti[i][new], index = cost, new
            cost, index = 0, i
            for j in range(25):
                new = (index - 1) % 26
                cost += previousCost[index]
                dicti[i][new], index = min(dicti[i][new], cost), new
        return sum(dicti[ord(i) - 97][ord(j) - 97] for i, j in zip(s, t))",1460834759
bofeng07,bofeng07,441,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        last = 10
        while True:
            if n < last:
                return False
            if n < last * 2 - 1:
                return True
            n -= last * 2 - 1
            last -= 2",1460800612
bofeng07,bofeng07,441,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        dpRow, dpCol = [0] * (n - 1) + [fruits[0][-1]], [0] * (n - 1) + [fruits[-1][0]]
        for index in range(1, n - 1):
            dpRow = [
                max(
                    dpRow[pre] for pre in range(max(i - 1, n - index), min(i + 2, n))
                ) + fruits[index][i] if i >= max(n - 1 - index, index + 1) else 0 for i in range(n)
            ]
            dpCol = [
                max(
                    dpCol[pre] for pre in range(max(i - 1, n - index), min(i + 2, n))
                ) + fruits[i][index] if i >= max(n - 1 - index, index + 1) else 0 for i in range(n)
            ]
        return sum(fruits[i][i] for i in range(n)) + dpRow[-1] + dpCol[-1]",1460912601
Harsh Yadav,harshy1718,444,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;
            int ind1 = s[i] - 'a';
            int ind2 = t[i] - 'a';
            long long cost1 = 0;
            int j = ind1;
            int temp = ind2;
            if (ind1 > ind2) ind2 += 26;
            for (; j < ind2; j++) {
                cost1 += nextCost[j%26];
            }
            ind2 = temp;
            j = ind1;
            if (ind1 < ind2) j += 26;
            long long cost2 = 0;
            for (; j > ind2; j--) {
                cost2 += previousCost[j%26];
            }
            ans += min(cost1, cost2);
        }
        return ans;
    }
};",1460836003
Harsh Yadav,harshy1718,444,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) return false;
        bool alice = 1;
        int to_remove = 10;
        while (n > 0) {
            if (n >= to_remove) n -= to_remove;
            else {
                if (to_remove%2 == 0) return 0;
                return 1;
            }
            to_remove--;
        }
        return to_remove%2 == 0? 0 : 1;
    }
};",1460803994
Harsh Yadav,harshy1718,444,3648,cpp,"class Solution {
public:
int n;
    int help(int i, int j, vector<vector<int>>&fruits, vector<vector<int>>&dp) {
        if (j == n-1) return 0;
        if (j >= i || i < 0 || i >= n || j < 0 || j >= n) return -1e5;
        if (dp[i][j] != -1) return dp[i][j];
        int ans = INT_MIN;
        for (int k = -1; k <= 1; k++) {
            int ni = i + k;
            ans = max(ans, fruits[i][j] + help(ni,j+1,fruits,dp));
        }
        return dp[i][j] = ans;
    }
    int help2(int i, int j, vector<vector<int>>&fruits, vector<vector<int>>&dp) {
        if (i == n-1) return 0;
        if (i >= j || i < 0 || i >= n || j < 0 || j >= n) return -1e5;
        if (dp[i][j] != -1) return dp[i][j];
        int ans = INT_MIN;
        for (int k = -1; k <= 1; k++) {
            int nj = j + k;
            ans = max(ans, fruits[i][j] + help2(i+1,nj,fruits,dp));
        }
        return dp[i][j] = ans;
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        long long ans = 0;
        n = fruits.size();
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>>dp(n,vector<int>(n,-1));
        ans += help(n-1,0,fruits,dp);
        ans += help2(0,n-1,fruits,dp);
        return ans;
    }
};",1460913252
f20190082,f20190082,445,3591,cpp,"class Solution {
public:
    long long getMinCost(int a,int b, vector<int>& nextCost, vector<int>& previousCost){
        long long prev=0;
        long long next=0;
        int tt=a;
        while(tt!=b){
            next+=nextCost[tt];
            tt++;
            tt%=26;
        }
        tt=a;
        while(tt!=b){
            prev+=previousCost[tt];
            tt--;
            if(tt==-1) tt=25;
            tt%=26;
        }
        return min(prev, next);
        
        
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for (int i=0;i<s.size();i++){
            long long temp=getMinCost(s[i]-'a',t[i]-'a',nextCost, previousCost);
            ans+=temp;
        }
        return ans;
    }
};",1460822129
f20190082,f20190082,445,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if((n<10)||(n>=19&&n<=26)||(n>=34&&n<=39)||(n>=45&&n<=48)){
            return false;
        }
        return true;
        
    }
};",1460804801
f20190082,f20190082,445,3648,cpp,"class Solution {
public:
    int dp[1001][1001];
    int getMaxUp(pair<int,int> up, vector<vector<int>>& fruits, int left, int n){
        if(up.first>=up.second) return -1;
        if(up.second>=n) return -1;
        if(dp[up.first][up.second]!=-1) return dp[up.first][up.second];
        if(left==0){
            if(up==make_pair(n-1,n-1)){
                return fruits[n-1][n-1];
            }
        }
        // cout<<up.first<<"" ""<<up.second<<"" ""<<left<<"" ""<<n;
        vector<int> comb={-1,0,1};
        int ans=0;
        for(int i=0;i<3;i++){
            int temp=getMaxUp({up.first+1,up.second+comb[i]},fruits,left-1,n);
            ans=max(ans,temp);
        }
        // cout<<up.first<<"" ""<<up.second<<"" ""<<endl;
        return dp[up.first][up.second]=ans+fruits[up.first][up.second];
    }
int getMaxDown(pair<int,int> down, vector<vector<int>>& fruits, int left, int n){
        if(down.first<=down.second) return -1;
        if(down.first>=n) return -1;
        if(dp[down.first][down.second]!=-1) return dp[down.first][down.second];
        if(left==0){
            if(down==make_pair(n-1,n-1)){
                return fruits[n-1][n-1];
            }
        }
    // cout<<down.first<<"" ""<<down.second<<"" ""<<left<<"" ""<<n;
        vector<int> comb={-1,0,1};
        int ans=0;
        for(int i=0;i<3;i++){
            int temp=getMaxDown({down.first+comb[i],down.second+1},fruits,left-1,n);
            ans=max(ans,temp);
        }
        return dp[down.first][down.second]=ans+fruits[down.first][down.second];
    }
int getMaxCent(pair<int,int> cent,vector<vector<int>>& fruits, int n){
    int ans=0;
    for(int i=0;i<n;i++){
        ans+=fruits[i][i];
    }
    return ans;
}
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        memset(dp,-1,sizeof(dp));
        int n=fruits.size();
        pair<int,int> cent={0,0};
        pair<int,int> up={0,n-1};
        pair<int,int> down={n-1,0};
        int a1=getMaxUp(up, fruits, n-1,n);
        int a2=getMaxCent(cent,fruits,n);
        int a3=getMaxDown(down, fruits, n-1,n);
        // cout<<a1<<"" ""<<a2<<"" ""<<a3;
        return a1+a2+a3;
    }
};",1460902703
Anshuman Gupta,guptaanshuman124,446,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int curr = s[i] - 'a';
            int target = t[i] - 'a';

            long long forward = 0;
            for (int j = curr; j != target; j = (j + 1) % 26) {
                forward += nextCost[j];
            }

            long long backward = 0;
            for (int j = curr; j != target; j = (j - 1 + 26) % 26) {
                backward += previousCost[j];
            }

            ans += min(forward, backward);
        }

        return ans;
    }
};
",1460851397
Anshuman Gupta,guptaanshuman124,446,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ans=false;
        int i=10;
        while(n>=0){
            if(n<i){
                return ans;
            }
            ans=!ans;
            n-=i;
            i--;
        }
        return true;
    }
};",1460837861
Anshuman Gupta,guptaanshuman124,446,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        vector<vector<int>> calc=fruits;
        int n=fruits.size();
        for(int i=n-2;i>0;i--){
            for(int j=n-1;j>=i+1;j--){
                if((j+1)<n){
                    calc[i-1][j+1]=max(calc[i-1][j+1],fruits[i-1][j+1]+calc[i][j]);
                }
                calc[i-1][j]=max(calc[i-1][j],fruits[i-1][j]+calc[i][j]);
                calc[i-1][j-1]=max(calc[i-1][j-1],fruits[i-1][j-1]+calc[i][j]);
            }
        }
        for(int i=n-2;i>0;i--){
            for(int j=n-1;j>=i+1;j--){
                if((j+1)<n){
                    calc[j+1][i-1]=max(calc[j+1][i-1],fruits[j+1][i-1]+calc[j][i]);
                }
                calc[j][i-1]=max(calc[j][i-1],fruits[j][i-1]+calc[j][i]);
                calc[j-1][i-1]=max(calc[j-1][i-1],fruits[j-1][i-1]+calc[j][i]);
            }
        }
        int ans=calc[0][n-1]+calc[n-1][0];
        for(int i=0;i<n;i++){
            ans+=fruits[i][i];
        }
        return ans;
    }
};",1460908750
Santosh Swansi,santoshswansi,448,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost) {
        vector<ll> preNext(26), prePrev(26);
        preNext[0] = nextCost[0], prePrev[0] = prevCost[0];
        for(int i=1; i<26; ++i){
            preNext[i] += preNext[i-1] + nextCost[i];
            prePrev[i] += prePrev[i-1] + prevCost[i];
        }

        int n = s.length();
        ll ans = 0;
        for(int i=0; i<n; ++i){
            int ch1 = s[i]-'a', ch2 = t[i]-'a';
            if(ch1 == ch2) continue;

            ll mn = 1e18;
            if(ch1 <= ch2) mn = min(mn, 0LL + preNext[ch2-1] - ((ch1 != 0)? preNext[ch1-1]:0));
            else mn = min(mn, 0LL + preNext[25]-((ch1 != 0)? preNext[ch1-1]: 0) + ((ch2 != 0)? preNext[ch2-1]: 0));

            if(ch2 <= ch1) mn = min(mn, 0LL + prePrev[ch1] - prePrev[ch2]);
            else mn = min(mn, 0LL + prePrev[ch1] + prePrev[25] - prePrev[ch2]);

            ans += mn;
        }

        return ans;
    }
};",1460857679
Santosh Swansi,santoshswansi,448,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr = n, mn = 10;
        bool alice = true;
        while(curr && curr-mn >= 0){
            alice = !alice;
            curr -= mn;
            --mn;
        }

        return !alice;
    }
};",1460799047
Santosh Swansi,santoshswansi,448,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();

        int ans = 0;
        for(int i=0; i<n; ++i) ans += fruits[i][i];
        vector<vector<int>> dp1(n, vector<int>(n, -1e9));
        dp1[0][n-1] = fruits[0][n-1];
        for(int i=1; i<n; ++i){
            for(int j=0; j<n; ++j){
                dp1[i][j] = max(dp1[i][j], dp1[i-1][j] + fruits[i][j]);
                if(j != 0) dp1[i][j] = max(dp1[i][j], dp1[i-1][j-1] + fruits[i][j]);
                if(j != n-1) dp1[i][j] = max(dp1[i][j], dp1[i-1][j+1] + fruits[i][j]);
            }
        }

        vector<vector<int>> dp2(n, vector<int>(n, -1e9));
        dp2[n-1][0] = fruits[n-1][0];
        for(int j=1; j<n; ++j){
            for(int i=0; i<n; ++i){
                dp2[i][j] = max(dp2[i][j], dp2[i][j-1] + fruits[i][j]);
                if(i != 0) dp2[i][j] = max(dp2[i][j], dp2[i-1][j-1] + fruits[i][j]);
                if(i != n-1) dp2[i][j] = max(dp2[i][j], dp2[i+1][j-1] + fruits[i][j]);
            }
        }

        return ans + dp1[n-2][n-1] + dp2[n-1][n-2];
    }
};",1460914792
Vishal Chourey,vishalchourey11,449,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long result=0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)!=t.charAt(i)){
                result+=getOptimalNextOrPrev(s.charAt(i)-'a',t.charAt(i)-'a',previousCost,nextCost);
            }
        }
        return result;
    }
    public long getOptimalNextOrPrev(int start,int end,int[] prev,int[] next){
        long n=0,p=0;
        int index=start;
        while(index!=end){
            n+=(long)next[index];
            index=(index+1)%26;
        }
        index=start;
        while(index!=end){
            p+=(long)prev[index];
            index=(index-1);
            if(index==-1) index=25;
        }
        return Math.min(n,p);
    }
}",1460837010
Vishal Chourey,vishalchourey11,449,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int turnNo=0;
        while(turnNo<10 && n>=0){
            n=turn(n,turnNo);
            if(n==-1) return false;
            turnNo++;
            n=turn(n,turnNo);
            turnNo++;
        }
        return true;
    }
    public int turn(int n,int turnNo){
        int sub=10-turnNo;
        if(n<sub) return -1;
        return n-sub;
    }
}",1460809607
Vishal Chourey,vishalchourey11,449,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int n=fruits.length;
        int first=0;
        Integer[][] dp=new Integer[n][n];
        for(int i=0;i<n;i++) first+=fruits[i][i];
        fruits[n-1][n-1]=0;
        int second=getMaxSecond(fruits,0,n-1,n,dp);
        int third=getMaxThird(fruits,n-1,0,n,dp);
        return first+second+third;
    }
    public int getMaxSecond(int[][] fruits,int i,int j,int n,Integer[][] dp){
        if(i<0 || j<0 || i>=n || j>=n || i>=j) return 0;
        if(dp[i][j]!=null) return dp[i][j];
        return dp[i][j] =  fruits[i][j]+Math.max(getMaxSecond(fruits,i+1,j-1,n,dp),Math.max(getMaxSecond(fruits,i+1,j,n,dp),getMaxSecond(fruits,i+1,j+1,n,dp)));
    }

    public int getMaxThird(int[][] fruits,int i,int j,int n,Integer[][] dp){
        if(i<0 || j<0 || i>=n || j>=n || i<=j) return 0;
        if(dp[i][j]!=null) return dp[i][j];
        return dp[i][j] = fruits[i][j] + Math.max(getMaxThird(fruits,i-1,j+1,n,dp),Math.max(getMaxThird(fruits,i,j+1,n,dp),getMaxThird(fruits,i+1,j+1,n,dp)));
    }
}",1460903953
Andrei,modelflat,450,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        def cost_next(a, b):
            s = 0
            for j in range(a, b):
                s += nextCost[j]
            return s

        def cost_prev(a, b):
            s = 0
            for j in reversed(range(a + 1, b + 1)):
                s += previousCost[j]
            return s

        def shift_cost(i):
            if s[i] == t[i]:
                return 0
            si = ord(s[i]) - ord('a')
            ti = ord(t[i]) - ord('a')
            if si < ti:
                return min(cost_next(si, ti), cost_prev(0, si) + previousCost[0] + cost_prev(ti, 25))
            else:
                return min(cost_prev(ti, si), cost_next(0, ti) + cost_next(si, 26))
        
        total_cost = 0
        for i in range(len(s)):
            total_cost += shift_cost(i)

        return total_cost
",1460842806
Andrei,modelflat,450,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        loser = False
        while n - cur >= 0:
            n -= cur
            cur -= 1
            loser = not loser
        return loser
",1460834461
Andrei,modelflat,450,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)

        @cache
        def dfs1(x, y):
            if x == n - 1 and y == n - 1:
                return 0
            if x == y or x < 0 or y < 0 or x >= n or y >= n:
                return -math.inf
            return fruits[x][y] + max(
                dfs1(x - 1, y + 1),
                dfs1(x, y + 1),
                dfs1(x + 1, y + 1),
            )

        @cache
        def dfs2(x, y):
            if x == n - 1 and y == n - 1:
                return 0
            if x == y or x < 0 or y < 0 or x >= n or y >= n:
                return -math.inf
            return fruits[x][y] + max(
                dfs2(x + 1, y - 1),
                dfs2(x + 1, y),
                dfs2(x + 1, y + 1),
            )

        ans = 0
        for i in range(n):
            ans += fruits[i][i]

        ans += dfs1(n - 1, 0)
        ans += dfs2(0, n - 1)
        
        return ans
",1460904398
Yousuke Eagles,YousukeEagles,452,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        n = len(s)
        sd = 0

        for i in range(n):
            st = ord(s[i]) - ord(""a"")
            nd = (ord(t[i]) - ord(s[i])) % 26
            pd = 26 - nd
            nc = 0
            pc = 0
            for j in range(nd):
                nc += nextCost[(st+j)%26]
            for j in range(pd):
                pc += previousCost[(st-j)%26]
            # print(f""st:{st} nd:{nd} pd:{pd} nc:{nc} pc:{pc}"")
            if nc < pc:
                sd += nc
            else:
                sd += pc
                
        return sd",1460827034
Yousuke Eagles,YousukeEagles,452,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:

        t = 0
        m = 10
        while n >= m:
            n -= m
            m -= 1
            t += 1

        return t % 2 == 1",1460798387
Yousuke Eagles,YousukeEagles,452,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:

        n = len(fruits)

        ans = 0
        
        # Top left Child
        for i in range(n):
            ans += fruits[i][i]
        # print(ans)

        # Bottom Left Child
        temp = [[0 for _ in range(n)] for _ in range(n)]
        temp[n-1][0] = fruits[n-1][0]
        for c in range(1, n):
            for r in range(n):
                if c >= r or n-r-1 > c:
                    continue
                fruit = fruits[r][c]
                if r-1 >= 0:
                    temp[r][c] = max(temp[r][c], temp[r-1][c-1] + fruit)
                if r+1 < n:
                    temp[r][c] = max(temp[r][c], temp[r+1][c-1] + fruit)
                temp[r][c] = max(temp[r][c], temp[r][c-1] + fruit)
                
        ans += temp[r][c-1]
        # print(temp)
        # print(temp[r][c-1])

        # Top Right Child
        temp = [[0 for _ in range(n)] for _ in range(n)]
        temp[0][n-1] = fruits[0][n-1]
        for r in range(1, n):
            for c in range(n):
                if r >= c or n-c-1 > r:
                    continue
                fruit = fruits[r][c]
                if c-1 >= 0:
                    temp[r][c] = max(temp[r][c], temp[r-1][c-1] + fruit)
                if c+1 < n:
                    temp[r][c] = max(temp[r][c], temp[r-1][c+1] + fruit)
                temp[r][c] = max(temp[r][c], temp[r-1][c] + fruit)
        
        ans += temp[r-1][c]
        # print(temp)
        # print(temp[r-1][c])
        
        return ans
        ",1460905269
Kazi Shamim Eakram,shamimiqram,453,3591,cpp,"class Solution {
public:

long long  minCost(char c1, char c2, vector<int>& nextCost, vector<int>& previousCost)
{
    long long a = 0, b = 0;
    char tmp = c1;
    while(c1 != c2)
        {
            a = a + nextCost[c1 - 'a'];
            if(c1 == 'z') c1 = 'a';
            else c1 = c1 + 1;
        }
    c1 = tmp;
    while(c1 != c2)
        {
            b = b + previousCost[c1 - 'a'];
            if(c1 == 'a') c1 = 'z';
            else c1 = c1 - 1;
        }
    return min(a, b);
}
long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) 
{
    long long ret = 0;
    for(int i = 0; i < s.size(); i++)
        {
            ret = ret + minCost(s[i], t[i], nextCost, previousCost);
        }
    return ret;
}
};",1460850437
Kazi Shamim Eakram,shamimiqram,453,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10;
        while(n >= cnt)
            {
                n = n - cnt;
                cnt--;
            }
        if(cnt % 2 == 1) return true;
        return false;
    }
};",1460848676
Kazi Shamim Eakram,shamimiqram,453,3648,cpp,"class Solution {
public:
    int dp1[1001][1001];
    int dp2[1001][1001];
    
    int fun1(int x, int y, vector<vector<int>>& fr)
    {
        if(x == y && x == fr.size() -1) return 0;
        if(x == fr.size()) return 0;
        if(dp1[x][y] != -1) return dp1[x][y];
        int a = 0, b = 0, c = 0;
        if(y > x + 2) a = fun1(x + 1, y - 1, fr);
        if(y > x + 1) b = fun1(x + 1, y, fr);
        if( y < fr.size() - 1) c = fun1(x+1, y+1, fr);
        
        a = max(a, b);
        a = max(a, c);
        dp1[x][y] = fr[x][y] + a;
        return dp1[x][y];
    }
    
    int fun2(int x, int y, vector<vector<int>>& fr)
    {
       // cout<<x<<y<<endl;
        //if(y >= fr.size()) return 0;
        if(dp2[x][y] != -1)
        {
           // cout<<x <<"" ,"" << y <<""==> ""<<dp2[x][y]<<endl;
            return dp2[x][y];
        }
        int a = 0, b = 0, c = 0;
        if(x > y + 2 && y < fr.size() - 1) a = fun2(x - 1, y +1, fr);
        if(x > y + 1 && y < fr.size() - 1) b = fun2(x , y + 1, fr);
        if( x < fr.size() - 1 && y < fr.size() - 1) c = fun2(x+1, y+1, fr);
        
        a = max(a, b);
        a = max(a, c);
        dp2[x][y] = fr[x][y] + a;
       // cout<<x <<"" ,"" << y <<""==> ""<<dp2[x][y]<<endl;
        return dp2[x][y];
    }
    
    int maxCollectedFruits(vector<vector<int>>& fr ) {
        memset(dp1, -1, sizeof(dp1));
        memset(dp2, -1, sizeof(dp2));
        int ret = 0;
        for(int i = 0; i < fr.size(); i++)
        {
            ret += fr[i][i];
           // cout<<fr[i][i]<<endl;
        }
        //cout<<ret<<endl;
        dp1[fr.size() -1][fr.size() -1] = 0;
        dp2[fr.size() -1][fr.size() -1] = 0;
        ret += fun1(0, fr.size()- 1, fr);
        //cout<<ret<<endl;
        ret += fun2(fr.size()- 1, 0, fr);
        return ret;
    }
};",1460916358
Suchith N,SeekerSuchi,455,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nc: List[int], pc: List[int]) -> int:
        n = len(s)
        sd = 0
        for i in range(n):
            if s[i] < t[i]:
                sd += min(sum(nc[ord(s[i])-ord('a'):ord(t[i])-ord('a')]), sum(pc[:ord(s[i])-ord('a')+1])+sum(pc[ord(t[i])-ord('a')+1:]))
            elif s[i] > t[i]:
                sd += min(sum(pc[ord(t[i])-ord('a')+1:ord(s[i])-ord('a')+1]), sum(nc[:ord(t[i])-ord('a')])+sum(nc[ord(s[i])-ord('a'):]))
        return sd
            ",1460852544
Suchith N,SeekerSuchi,455,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rem = 10
        turn = 0
        while n >= rem:
            n -= rem
            rem -= 1
            turn += 1
        return True if turn % 2 else False",1460804496
Suchith N,SeekerSuchi,455,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        fr = 0
        for i in range(n):
            fr += fruits[i][i]
            fruits[i][i] = -1
        for i in range(n-1):
            for j in range(n-i-1):
                fruits[i][j] = -1
        for i in range(1,n-1):
            j = n - 1
            while(fruits[i][j] != -1):
                if j != n - 1:
                    fruits[i][j] += max(fruits[i-1][j-1], fruits[i-1][j], fruits[i-1][j+1])
                else:
                    fruits[i][j] += max(fruits[i-1][j-1], fruits[i-1][j])
                j -= 1
        fr += fruits[n-2][n-1]
        for j in range(1,n-1):
            i = n - 1
            while(fruits[i][j] != -1):
                if i != n - 1:
                    fruits[i][j] += max(fruits[i-1][j-1], fruits[i][j-1], fruits[i+1][j-1])
                else:
                    fruits[i][j] += max(fruits[i-1][j-1], fruits[i][j-1])
                i -= 1
        fr += fruits[n-1][n-2]
        print(fruits)
        return fr
        ",1460911138
Jonathan Kelvin,jonathankelvin,456,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        ans = 0
        cache = {} # (from, to): total

        def replace_char(src: int, dst: int) -> int:
            if (src, dst) in cache:
                return cache[(src, dst)]
            # next
            forward = 0
            backward = 0
            curr = src
            while curr != dst:
                forward += nextCost[curr]
                curr += 1
                curr %= 26
            curr = src
            while curr != dst:
                backward += previousCost[curr]
                curr -= 1
                curr %= 26
            cache[(src, dst)] = min(forward, backward)
            return cache[(src, dst)]

        ans = 0
        for i in range(len(s)):
            ans += replace_char(ord(s[i]) - 97, ord(t[i]) - 97)
        return ans
        ",1460815812
Jonathan Kelvin,jonathankelvin,456,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        curr = 10
        alice_win = False
        while n >= curr:
            alice_win = not alice_win
            n -= curr
            curr -= 1
        return alice_win
        ",1460796813
Jonathan Kelvin,jonathankelvin,456,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        grid_row = len(fruits)
        grid_col = len(fruits[0])
        ans = 0
        min_cols = []
        for i in range(grid_col // 2):
            min_cols.append(grid_col - i - 1)
        if grid_col % 2 == 0:
            min_cols.append(min_cols[-1])
        else:
            min_cols.append(min_cols[-1] - 1)
        while len(min_cols) < grid_col:
            min_cols.append(min_cols[-1] + 1)

        for i in range(grid_row):
            ans += fruits[i][i]
            fruits[i][i] = 0

        for row in range(1, grid_row):
            for col in range(min_cols[row], grid_col):
                curr_max = 0
                if col - 1 >= min_cols[row - 1]:
                    curr_max = max(fruits[row - 1][col - 1], curr_max)
                if col >= min_cols[row - 1]:
                    curr_max = max(fruits[row - 1][col], curr_max)
                if col + 1 < grid_col:
                    curr_max = max(fruits[row - 1][col + 1], curr_max)
                fruits[row][col] += curr_max
        ans += fruits[grid_row - 1][grid_col - 1]
       
        for i in range(grid_row):
            fruits[i][i] = 0
        
        for col in range(1, grid_col):
            for row in range(min_cols[col], grid_row):
                curr_max = 0
                if row - 1 >= min_cols[col - 1]:
                    curr_max = max(fruits[row - 1][col - 1], curr_max)
                if row >= min_cols[col - 1]:
                    curr_max = max(fruits[row][col - 1], curr_max)
                if row + 1 < grid_row:
                    curr_max = max(fruits[row + 1][col - 1], curr_max)
                fruits[row][col] += curr_max
        ans += fruits[grid_row - 1][grid_col - 1]
   
        return ans
        ",1460916768
Sergey Kharchenko,skharchenko87,457,3591,golang,"
// abcdefghijklmnopqrstuvwxyz
func shiftDistance(s string, t string, nextCost []int, previousCost []int) int64 {
	var res int64

	for i := 0; i < len(s); i++ {
		var cntNext, cntPrev int
		sb, tb := int(s[i]-'a'), int(t[i]-'a')
		if sb == tb {

		} else if sb <= tb {
			cntNext = tb - sb
			cntPrev = sb + 26 - tb

		} else if sb > tb {
			cntNext = 26 - sb + tb
			cntPrev = sb - tb
		}

		tmpNext := 0
		for j := 0; j < cntNext; j++ {
			tmpNext += nextCost[(sb+j)%26]
		}
		tmpPrev := 0
		for j := 0; j < cntPrev; j++ {
			tmpPrev += previousCost[(26+sb-j)%26]
		}

		res += int64(min(tmpNext, tmpPrev))
	}
	return res
}

func abs(x int) int {
	if x >= 0 {
		return x
	}
	return -1 * x
}

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func abs64(x int64) int64 {
	if x >= 0 {
		return x
	}
	return -1 * x

}

func min64(x, y int64) int64 {
	if x < y {
		return x
	}
	return y
}

func max64(x, y int64) int64 {
	if x > y {
		return x
	}
	return y
}
",1460861250
Sergey Kharchenko,skharchenko87,457,3625,golang,"func canAliceWin(n int) bool {
	if n < 10 {
		return false
	}
	winAlice := true
	i := 10
	for n >= 0 {
		winAlice = !winAlice
		n -= i
		i--
	}
	return winAlice
}",1460807502
Sergey Kharchenko,skharchenko87,457,3648,golang,"
func maxCollectedFruits(fruits [][]int) int {
	n := len(fruits)
	green, red, blue := 0, 0, 0
	for i := 0; i < n; i++ {
		green += fruits[i][i]
		fruits[i][i] = 0
	}

	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			if j < n-i-1 {
				fruits[i][j] = 0
			}
		}
	}
	//red
	for i := 1; i < n-1; i++ {
		for j := i + 1; j < n; j++ {
			var l, m, r int
			if j-1 >= 0 {
				l = fruits[i-1][j-1]
			}
			m = fruits[i-1][j]
			if j+1 < n {
				r = fruits[i-1][j+1]
			}
			fruits[i][j] += max(max(l, m), r)
		}
	}
	//blue
	for j := 1; j < n-1; j++ {
		for i := n - 1; i >= n-1-i; i-- {
			var u, m, d int
			if i-1 >= 0 {
				u = fruits[i-1][j-1]
			}
			m = fruits[i][j-1]
			if i+1 < n {
				d = fruits[i+1][j-1]
			}
			fruits[i][j] += max(max(u, m), d)
		}
	}

	//fmt.Println(fruits)
	red = fruits[n-2][n-1]
	blue = fruits[n-1][n-2]
	return green + red + blue
}",1460917083
vicky_guptaa7,vicky_guptaa7,459,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]==t[i])continue;
            long long cost1=0,cost2=0;
            int nc=s[i]-'a';
            int tar=t[i]-'a';
            while(tar!=nc)
            {
                cost1+=nextCost[nc];
                nc++;
                nc%=26;
            }
            nc=s[i]-'a';
            while(tar!=nc)
            {
                cost2+=previousCost[nc];
                nc=(nc-1+26)%26;
            }
            ans+=min(cost1,cost2);
        }
        return ans;
    }
};",1460911988
vicky_guptaa7,vicky_guptaa7,459,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int isAlice=!true;
        int rem=10;
        while(n>=rem)
        {
            isAlice=!isAlice;
            n-=rem;
            rem--;
        }
        return isAlice;
    }
};",1460802684
vicky_guptaa7,vicky_guptaa7,459,3648,cpp,"class Solution {
public:
    
    int helper1(int x,int y,vector<vector<int>>&fruits,vector<vector<int>>&dp)
    {
        int n=fruits.size();
        if(x>=n||y>=n||x<0||y<0)
            return -1e9;
        if(x==n-1&&y==n-1)
        {
            return 0;
        }
        if(dp[x][y]!=-1)
            return dp[x][y];
        
        int ans=helper1(x+1,y,fruits,dp)+fruits[x][y];
        ans=max(ans,helper1(x+1,y-1,fruits,dp)+fruits[x][y]);
        ans=max(ans,helper1(x+1,y+1,fruits,dp)+fruits[x][y]);
        return dp[x][y]=ans;
    }
    
    int helper2(int x,int y,vector<vector<int>>&fruits,vector<vector<int>>&dp)
    {
        int n=fruits.size();
        if(x>=n||y>=n||x<0||y<0)
            return -1e9;
        if(x==n-1&&y==n-1)
        {
            return 0;
        }
        if(dp[x][y]!=-1)
            return dp[x][y];
        
        int ans=helper2(x,y+1,fruits,dp)+fruits[x][y];
        ans=max(ans,helper2(x-1,y+1,fruits,dp)+fruits[x][y]);
        ans=max(ans,helper2(x+1,y+1,fruits,dp)+fruits[x][y]);
        return dp[x][y]=ans;
    }
    
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n=fruits.size();
        vector<vector<int>>dp1(n,vector<int>(n,-1));
        vector<vector<int>>dp2(n,vector<int>(n,-1));
        int ans=0;
        for(int i=0;i<n;i++)
        {
            ans+=fruits[i][i];
            fruits[i][i]=0;
        }
        return ans+helper1(0,n-1,fruits,dp1)+helper2(n-1,0,fruits,dp2);
    }
};",1460871656
xom3khu5,xom3khu5,462,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& a, vector<int>& b) {
        int n = s.size();
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            int s1 = s[i] - 'a';
            int t1 = t[i] - 'a';
            long long cost;
            if (s1 < t1) {
                long long  sum1 = 0;
                for (int j = s1; j < t1; j++) {
                    sum1 += a[j]; 
                }
                long long sum2 = 0;
                for (int j = s1; j >= 0; j--) {
                    sum2 += b[j];
                }
                for (int j = 25; j > t1; j--){
                    sum2 += b[j];
                }
                cost = min(sum1, sum2);

            }
            else {
                // t1 < s1
                long long sum1 = 0;
                for (int j = s1; j <= 25; j++) {
                    sum1 += a[j]; 
                }
                for (int j = 0; j < t1; j++) {
                    sum1 += a[j];
                }
                long long sum2 = 0;
                for (int j = s1; j > t1; j--) {
                    sum2 += b[j];
                }
                cost = min(sum1, sum2);
            }
            ans += cost;
        }
        return ans;
    }
};",1460893125
xom3khu5,xom3khu5,462,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool turn = true;
        int sc = 10;
        while(true) {
            if (n > 0 && n >= sc) {
                n -= sc--;
                turn ^= 1;
            }
            else return 1 - turn;
        }
        return 0;
    }
};",1460872611
xom3khu5,xom3khu5,462,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n = a.size();
        const int inf = 1e9;
        int sum = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    sum += a[i][j];
                    a[i][j] = 0;
                }
            }
        }


        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -inf)), dp2(n + 1, vector<int>(n + 1, -inf));
        dp[0][n - 1] = a[0][n - 1];
        for (int i = 1; i < n; i++) {
            for (int j = n - 1; j >= 0; j--) {
                if (dp[i - 1][j] != -inf) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + a[i][j]);
                }
                if (j + 1 < n && dp[i - 1][j + 1] != -inf) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + a[i][j]);
                }
                if (j - 1 >= 0 && dp[i - 1][j - 1] != -inf) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + a[i][j]);
                }
            }
        }
        dp2[n - 1][0] = a[n - 1][0];
        for (int j = 1; j < n; j++) {
            for (int i = n - 1; i >= 0; i--) {
                if (j - 1 >= 0 && dp2[i][j - 1] != -inf) {
                    dp2[i][j] = max(dp2[i][j], dp2[i][j - 1] + a[i][j]);
                }
                if (i - 1 >= 0 && j - 1 >= 0 && dp2[i - 1][j - 1] != -inf) {
                    dp2[i][j] = max(dp2[i][j], dp2[i - 1][j - 1] + a[i][j]);
                }
                if (i + 1 < n && j - 1 >= 0 && dp2[i + 1][j - 1] != -inf) {
                    dp2[i][j] = max(dp2[i][j], dp2[i + 1][j - 1] + a[i][j]);
                }
            }
        }
        return sum + dp[n - 1][n - 1] + dp2[n - 1][n - 1];
    }
};",1460864268
peace,shankardtu21,464,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        const int n = 26;
        const long long m = 1e15;
        vector<vector<long long>> d(n, vector<long long>(n, m));
        for(int i = 0; i < n; ++i) {
            d[i][i] = 0;
            int x = (i + 1) % n;
            int y = (i - 1 + n) % n;
            d[i][x] = nc[i];
            d[i][y] = pc[i];
        }
        for(int k = 0; k < n; ++k) {
            for(int i = 0; i < n; ++i) {
                for(int j = 0; j < n; ++j) {
                    if(d[i][j] > d[i][k] + d[k][j]) {
                        d[i][j] = d[i][k] + d[k][j];
                    }
                }
            }
        }
        long long c = 0;
        int l = s.length();
        for(int i = 0; i < l; ++i) {
            int u = s[i] - 'a';
            int v = t[i] - 'a';
            c += d[u][v];
        }
        return c;
    }
};",1460900669
peace,shankardtu21,464,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n < 10) return false;
        vector<vector<bool>> d(n + 1, vector<bool>(12, false));
        vector<vector<bool>> v(n + 1, vector<bool>(12, false));
        function<bool(int, int)> f = [&](int s, int p) {
            if(s < 0) return false;
            int r = p - 1;
            if(r <= 0 || s < r) return false;
            if(s == r) return true;
            if(v[s][p]) return bool(d[s][p]);
            d[s][p] = !f(s - r, r);
            v[s][p] = true;
            return bool(d[s][p]);
        };
        return f(n, 11);
    }
};",1460899908
peace,shankardtu21,464,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& f) {
        int n = f.size();
        long long s = 0;
        for(int i = 0; i < n; ++i) {
            s += f[i][i];
        }

        vector<long long> d1(n, -1e18);
        if(0 != n-1) {
            d1[n-1] = f[0][n-1];
        } else {
            d1[n-1] = 0;
        }

        for(int i = 1; i < n; ++i) {
            vector<long long> d2(n, -1e18);
            for(int j = 0; j < n; ++j) {
                if(i != n-1 && j == i) continue;
                
                int v = 0;
                if(!(i == j && i == n-1)) {
                    v = f[i][j];
                }
                
                long long m = -1e18;
                if(j-1 >= 0) m = max(m, d1[j-1]);
                m = max(m, d1[j]);
                if(j+1 < n) m = max(m, d1[j+1]);
                if(m == -1e18) continue;
                
                d2[j] = v + m;
            }
            d1 = d2;
        }

        long long c2 = d1[n-1];

        vector<long long> p1(n, -1e18);
        p1[n-1] = f[n-1][0];

        for(int i = 1; i < n; ++i) {
            vector<long long> p2(n, -1e18);
            for(int j = 0; j < n; ++j) {
                if(j != n-1 && j == i) continue;
                
                int v = 0;
                if(!(j == i && j == n-1)) {
                    v = f[j][i];
                }
                
                long long m = -1e18;
                if(j-1 >= 0) m = max(m, p1[j-1]);
                m = max(m, p1[j]);
                if(j+1 < n) m = max(m, p1[j+1]);
                if(m == -1e18) continue;
                
                p2[j] = v + m;
            }
            p1 = p2;
        }

        long long c3 = p1[n-1];
        
        long long t = s;
        if(c2 > -1e18) t += c2;
        if(c3 > -1e18) t += c3;
        return (int)t;
    }
};",1460910764
Park Byeonggyu,Bang_K,467,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            int a = s[i]-'a'; int b = t[i]-'a';
            long long nx = 0; long long pr = 0;
            for (int i = a; i != b; i=(i+1)%26) {
                nx = nx + nextCost[i];
            }
            for (int i = a; i != b; i=(i+25)%26) {
                pr = pr + previousCost[i];
            }
            ans = ans + min(nx,pr);
        }
        return ans;
    }
};",1460811819
Park Byeonggyu,Bang_K,467,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int a = 10;
        bool tag = true;
        int alice = 1;
        while (n >= 0) {
            if (n - a < 0) {
                if (alice) tag=false;
                else tag=true;
                break;
            }
            else {
                n-=a;
                a--;
                alice^=1;
            }
        }
        return tag;
    }
};",1460801787
Park Byeonggyu,Bang_K,467,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += fruits[i][i];
            fruits[i][i]=0;
        }
        vector<vector<int>> dp(n, vector<int>(n, -1));
        dp[0][n-1] = fruits[0][n-1];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int maxi = 0;
                if (j-1 >= 0 && dp[i-1][j-1]>=0) dp[i][j]=max(dp[i][j],dp[i-1][j-1]);
                if (dp[i-1][j]>=0) dp[i][j]=max(dp[i][j],dp[i-1][j]);
                if (j+1 < n && dp[i-1][j+1]>=0) dp[i][j]=max(dp[i][j],dp[i-1][j+1]);
                if (dp[i][j] >= 0)
                    dp[i][j] += fruits[i][j];
            }
        }
        ans += dp[n-1][n-1];
        cout << dp[n-1][n-1] << '\n';
        vector<vector<int>> dp1(n, vector<int>(n, -1));
        dp1[n-1][0] = fruits[n-1][0];
        for (int j = 1; j < n; j++) {
            for (int i = 0; i < n; i++) {
                int maxi = 0;
                if (i-1 >= 0 && dp1[i-1][j-1]>=0) dp1[i][j]=max(dp1[i][j],dp1[i-1][j-1]);
                if (dp1[i][j-1]>=0) dp1[i][j]=max(dp1[i][j],dp1[i][j-1]);
                if (i+1 < n && dp1[i+1][j-1]>=0) dp1[i][j]=max(dp1[i][j],dp1[i+1][j-1]);
                if (dp1[i][j] >= 0)
                    dp1[i][j] += fruits[i][j];
            }
        }
        ans += dp1[n-1][n-1];
        cout << dp1[n-1][n-1] << '\n';
        return ans;
    }
};",1460900327
aboylinked,aboylinked,471,3591,cpp,"class Solution {
public:
    long long shiftDistance(string a, string b, vector<int>& c, vector<int>& d) {

        long long e[26][26] = {0}, f[26][26] = {0}; 
            
         
        for (int g = 0; g < 26; ++g) {
            long long h = 0; 
            for (int i = 1; i < 26; ++i) {
                h += c[(g + i - 1) % 26];
                e[g][(g + i) % 26] = h;
            }
        }

      
        for (int j = 0; j < 26; ++j) {
            long long k = 0; 
            for (int l = 1; l < 26; ++l) {
                k += d[(j - l + 1 + 26) % 26];
                f[j][(j - l + 26) % 26] = k;
            }
        }

        
        long long m = 0;  
        for (int n = 0; n < a.size(); ++n) {
            int o = a[n] - 'a', p = b[n] - 'a';
            m += min(e[o][p], f[o][p]);
        }
        return m;
        
        
    }
};",1460842658
aboylinked,aboylinked,471,3625,cpp,"class Solution {
public:
        bool canAliceWin(int n) {

        int move = 10;                  
        bool alice = true;       

        while (true) {
            if (move <= 0) {
                 
                return !alice;
            }

            if (n >= move) {
               
                n -= move;
                move--;              
                alice = !alice;  
            } 
            else return !alice;
        }  

        }
    };
            ",1460815941
aboylinked,aboylinked,471,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        vector<bool> ischild(n, false);
        long long sum1 = 0;
        for(int i = 0; i < n; ++i){
            int j = i;
            if(j >= n){
                continue;
            }
            ischild[i] = true;
            sum1 += fruits[i][j];
        }

       
        vector<vector<long long>> dp2(n, vector<long long>(n, -1));
        dp2[0][n-1] = fruits[0][n-1];
     

        for(int i = 1; i < n; ++i){
            for(int j = 0; j < n; ++j){
                if(ischild[i] && j == i && !(i == n-1 && j == n-1)){
                    continue;
                }
               
                long long prev_max = -1;
                if(j-1 >=0 && dp2[i-1][j-1] != -1){
                    prev_max = max(prev_max, dp2[i-1][j-1]);
                }
                if(j >=0 && j < n && dp2[i-1][j] != -1){
                    prev_max = max(prev_max, dp2[i-1][j]);
                }
                if(j+1 < n && dp2[i-1][j+1] != -1){
                    prev_max = max(prev_max, dp2[i-1][j+1]);
                }
                if(prev_max != -1){
                    dp2[i][j] = prev_max + fruits[i][j];
                }
            }
        }

        
        vector<vector<long long>> dp3(n, vector<long long>(n, -1));
        
        dp3[n-1][0] = fruits[n-1][0];
         

        for(int j = 1; j < n; ++j){
            for(int i = 0; i < n; ++i){
                 if(ischild[i] && j == i && !(i == n-1 && j == n-1)){
                    continue;
                }
                 long long prev_max = -1;
                 if(i-1 >=0 && dp3[i-1][j-1] != -1){
                    prev_max = max(prev_max, dp3[i-1][j-1]);
                }
                 if(j-1 >=0 && dp3[i][j-1] != -1){
                    prev_max = max(prev_max, dp3[i][j-1]);
                }
                 if(i+1 < n && dp3[i+1][j-1] != -1){
                    prev_max = max(prev_max, dp3[i+1][j-1]);
                }
                if(prev_max != -1){
                    dp3[i][j] = prev_max + fruits[i][j];
                }
            }
        }

         
        long long sum2 = dp2[n-1][n-1];
        long long sum3 = dp3[n-1][n-1];

        
        long long total = sum1 + sum2 + sum3 - 2LL * fruits[n-1][n-1];
        return (int)total;
    }
};
",1460900830
Jaykishan Patel,jaykishanp2326526,474,3591,java,"class Solution {
    public long nc(int c1,int c2,int[] ncc ){
        long cost=0;
        while(c1!=c2){
            
            cost+=ncc[c1];
            if(c1==25) c1=0;
            else c1++;
        }
        return cost;
    }
    public long pc(int c1,int c2,int[] ncc ){
        long cost=0;
        while(c1!=c2){
            
            cost+=ncc[c1];
            if(c1==0) c1=25;
            else c1--;
        }
        return cost;
    }
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalcost=0;
        for(int i=0;i<s.length();i++){
            totalcost+=Math.min(nc(s.charAt(i)-'a',t.charAt(i)-'a',nextCost),pc(s.charAt(i)-'a',t.charAt(i)-'a',previousCost));
        }
        return totalcost;
    }
}",1460845681
Jaykishan Patel,jaykishanp2326526,474,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean ans=false;
        int i=10;
        while(n>=i){
            ans=!ans;
            n-=i;
            i--;
        }
        return ans;
    }
}",1460808589
Jaykishan Patel,jaykishanp2326526,474,3648,java,"class Solution {
    public int c2m(int[][] f,int i,int j,int[][] dp){
        int n=f.length;
        if(j>=i || i>=n || j>=n) return Integer.MIN_VALUE;
        if(j==n-1){
            return f[i][j];
        }
        if(dp[i][j]!=-1) return dp[i][j];
        int a=f[i][j]+c2m(f,i-1,j+1,dp);
        int b=f[i][j]+c2m(f,i,j+1,dp);
        int c=f[i][j]+c2m(f,i+1,j+1,dp);
        return dp[i][j]= Math.max(a,Math.max(b,c));
    }
    public int c3m(int[][] f,int i,int j,int[][] dp){
        int n=f.length;
        if(j<=i || i>=n || j>=n) return Integer.MIN_VALUE;
        if(i==n-1){
            return f[i][j];
        }
        if(dp[i][j]!=-1) return dp[i][j];
        int a=f[i][j]+c3m(f,i+1,j-1,dp);
        int b=f[i][j]+c3m(f,i+1,j,dp);
        int c=f[i][j]+c3m(f,i+1,j+1,dp);
        return dp[i][j]= Math.max(a,Math.max(b,c));
    }
    public int maxCollectedFruits(int[][] fruits) {
        int c1=0;
        int n=fruits.length;
        for(int i=0;i<n;i++){
            c1+=fruits[i][i];
            fruits[i][i]=0;
        }
        int[][] dp=new int[n][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                dp[i][j]=-1;
            }
        }
        int c3=c3m(fruits,0,n-1,dp);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                dp[i][j]=-1;
            }
        }
        int c2=c2m(fruits,n-1,0,dp);
        return c1+c2+c3;
        
    }
}",1460912990
pawan kumar,pkpawan,475,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& prev) {
        long long ans = 0;
        int n = s.size();
        
        for(int i=0;i<n;++i){
            int cid = s[i]-'a';
            int rid = t[i]-'a';
            //if we keep moving backwards
            long long back = 0;
            while(cid != rid){
                back += (long long)prev[cid];
                if(cid == 0){
                    cid = 26;
                }
                cid--;
            }
            
            
            long long front = 0;
            cid = s[i]-'a';
            while(cid != rid){
                front += (long long)next[cid];
                cid++;
                cid%=26;
            }
            
            ans += min(back,front);
        }
        
        return ans;
    }
};",1460888866
pawan kumar,pkpawan,475,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int start = 10;
        int c = 0;
        while(start<=n && n>0){
            n -= start;
            c++;
            start--;
            if(start == 0)break;
        }
        
        return c%2;
        
    }
};",1460889103
pawan kumar,pkpawan,475,3648,cpp,"class Solution {
public:
    long long bottomLeft(int i,int j,vector<vector<int>>&fruits,vector<vector<long long>>&dp){
        int n = fruits.size();
        
         
        if(i == n-1 && j == n-1)return 0;
            
        if(j>=n || i>=n)return INT_MIN;
        if((j==n-1) && (i<n))return INT_MIN;
         
         
        if(i == j)return INT_MIN;
        if(dp[i][j] != -1)return dp[i][j];
        long long op1 = bottomLeft(i,j+1,fruits,dp);
        long long op2 = bottomLeft(i+1,j+1,fruits,dp);
        long long op3 = bottomLeft(i-1,j+1,fruits,dp);
        
        return dp[i][j] = max(op1,max(op2,op3)) + (long long)fruits[i][j];
        
    }
    long long topRight(int i,int j,vector<vector<int>>&fruits,vector<vector<long long>>&dp){
        int n = fruits.size();
         
            if(i == n-1 && j == n-1)return 0;
           
         
        if((i==n-1) && (j<n))return INT_MIN;
         if(j>=n || i>=n)return INT_MIN;
        if(i == n-1 && j == n-1)return 0;
        if(i == j)return INT_MIN;
        if(dp[i][j] != -1)return dp[i][j];
        long long op1 = topRight(i+1,j,fruits,dp);
        long long op2 = topRight(i+1,j+1,fruits,dp);
        long long op3 = topRight(i+1,j-1,fruits,dp);
        
        return dp[i][j] = max(op1,max(op2,op3)) + (long long)fruits[i][j];
        
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int score = 0;
        int n = fruits.size();
        /*for(auto&x:fruits){
            for(auto&y:x){
                cout<<y<<"" "";
            }
            cout<<""\n"";
        }*/
        for(int i=0;i<n;++i)score += fruits[i][i];
        vector<vector<long long>>dp(n,vector<long long>(n,-1));
        //memset(dp,-1,sizeof(dp));
        score += bottomLeft(n-1,0,fruits,dp);
        vector<vector<long long>>dp2(n,vector<long long>(n,-1));
        score += topRight(0,n-1,fruits,dp2);
        return score;
    }
};",1460913517
AJI_HSU,AJI_Hsu,476,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long total = 0;
        for (int i = 0; i < s.length(); i++) {
            long next = 0;
            char ch = s.charAt(i);
            while (ch != t.charAt(i)) {
                next += nextCost[(int) ch - 'a'];
                ch++;
                if (ch == 'z' + 1) ch = 'a';
            }
            long pre = 0;
            ch = s.charAt(i);
            while (ch != t.charAt(i)) {
                pre += previousCost[(int) ch - 'a'];
                ch--;
                if (ch == 'a' - 1) ch = 'z';
            }
            total += Math.min(pre, next);
        }
        return total;
    }
}",1460841029
AJI_HSU,AJI_Hsu,476,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int s = 10;
        while (n >= 0) {
            if (s <= 0) return false;
            if (n >= s) n -= s;
            else return false;
            s--;
            if (s <= 0) return true;
            if (n >= s) n -= s;
            else return true;
            s--;
        }
        return true;
    }
}",1460801704
AJI_HSU,AJI_Hsu,476,3648,java,"import java.util.ArrayList;
class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int total = 0;
        for (int i = 0; i < fruits.length; i++) {
            total += fruits[i][i];
            fruits[i][i] = 0;
        }
        
        int[][] dp = new int[fruits.length][fruits.length];
        dp[fruits.length - 1][0] = fruits[fruits.length - 1][0];
        int[] diri1 = { 1, 0, -1 };
        int[] dirj1 = { -1, -1, -1 };
        for (int j = 1; j < fruits.length; j++) {
            for (int i = fruits.length - 1; i + j >= fruits.length - 1; i--) {
                for (int k = 0; k < 3; k++) {
                    int ii = i + diri1[k];
                    int jj = j + dirj1[k];

                    if (ii < fruits.length && ii + jj >= fruits.length - 1) {
                        dp[i][j] = Math.max(dp[i][j], dp[ii][jj] + fruits[i][j]);
                    }
                }
            }
        }
        total += dp[fruits.length - 1][fruits.length - 1];

        dp = new int[fruits.length][fruits.length];
        dp[0][fruits.length - 1] = fruits[0][fruits.length - 1];
        int[] diri2 = { -1, -1, -1 };
        int[] dirj2 = { 1, 0, -1 };
        for (int i = 1; i < fruits.length; i++) {
            for (int j = fruits.length - 1; j + i >= fruits.length - 1; j--) {
                for (int k = 0; k < 3; k++) {
                    int ii = i + diri2[k];
                    int jj = j + dirj2[k];

                    if (jj < fruits.length && ii + jj >= fruits.length - 1) {
                        dp[i][j] = Math.max(dp[i][j], dp[ii][jj] + fruits[i][j]);
                    }
                }
            }
        }
        total += dp[fruits.length - 1][fruits.length - 1];

        return total;
    }
}",1460913521
Chitti,robo_droid,478,3591,java,"class Solution {
    
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        long[][] forwardDp = new long[26][26];
        long[][] reverseDp = new long[26][26];
        for(int pos = 0; pos < 26; pos++) {
            Arrays.fill(forwardDp[pos], -1);
            Arrays.fill(reverseDp[pos], -1);
        }
        for (int i=0; i < s.length(); i++) {
            long minCost = Math.min(
                calculateForward(nextCost, s.charAt(i)-'a', t.charAt(i)-'a', forwardDp),
                calculateBackward(previousCost, s.charAt(i)-'a', t.charAt(i)-'a', reverseDp)
            );
            totalCost += minCost;
        }
        return totalCost;
    }

    long calculateForward(int[] nextCost, int start, int end, long[][] dp) {
        if(dp[start][end] != -1) return dp[start][end];
        int i=start;
        long cost = 0;
        while (i != end) {
            cost += nextCost[i];
            i = (i+1)%26;
        }
        dp[start][end] = cost;
        return cost;
    }

    long calculateBackward(int[] previousCost, int start, int end, long[][] dp) {
        if(dp[start][end] != -1) return dp[start][end];
        int i=start;
        long cost = 0;
        while (i != end) {
            cost += previousCost[i];
            i = ((i-1)+26)%26;
        }
        dp[start][end] = cost;
        return cost;
    }
}",1460914957
Chitti,robo_droid,478,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int start = 10;
        boolean aliceTurn = true;
        while(n >= 0) {
            n -= start;
            aliceTurn = !aliceTurn;
            if(n < 0) return aliceTurn;
            start--;
        }
        return aliceTurn;
    }
}",1460798074
Chitti,robo_droid,478,3648,java,"class Solution {


    private int findDownwardCost(int[][] fruits, int x, int y, int[][] dp) {
        if(x < 0 || x == fruits.length || y < 0 || y == fruits.length || x >= y) return 0;
        if(dp[x][y] != -1) return dp[x][y];
        int moveLeft = findDownwardCost(fruits, x + 1, y - 1, dp);
        int moveDown = findDownwardCost(fruits, x + 1, y, dp);
        int moveRight = findDownwardCost(fruits, x + 1, y + 1, dp);
        dp[x][y] = fruits[x][y] + Math.max(moveDown, Math.max(moveLeft, moveRight));
        return dp[x][y];
    }

    private int findRightCost(int[][] fruits, int x, int y, int[][] dp) {
        if(x < 0 || x == fruits.length || y < 0 || y == fruits.length || x <= y) return 0;
        if(dp[x][y] != -1) return dp[x][y];
        int moveAbove = findRightCost(fruits, x - 1, y + 1, dp);
        int moveRight = findRightCost(fruits, x, y + 1, dp);
        int moveBelow = findRightCost(fruits, x + 1, y + 1, dp);
        dp[x][y] = fruits[x][y] + Math.max(moveRight, Math.max(moveAbove, moveBelow));
        return dp[x][y];
    }
    
    public int maxCollectedFruits(int[][] fruits) {
        int total = 0;
        int rowLen = fruits.length, colLen = fruits[0].length;
        int cost = 0;
        for(int x = 0; x < rowLen; x++) {
            cost += fruits[x][x];
            fruits[x][x] = 0;
        }
        int[][] dp = new int[rowLen][colLen];
        for(int row = 0; row < rowLen; row++) {
            for(int col = 0; col < colLen; col++) {
                dp[row][col] = -1;
            }
        }
        cost += findDownwardCost(fruits, 0, colLen - 1, dp);
        cost += findRightCost(fruits, rowLen - 1, 0, dp);
        return cost;
    }
}",1460908487
Shivesh Gupta,Shivesh__Gupta__,479,3591,cpp,"class Solution {
public:
    long long next(char a, char b, vector<vector<long long>>& dp, vector<int>& cost){
        if(a == b) return 0;
        long long ans=0;
        if(dp[a-'a'][b-'a'] != -1) return dp[a-'a'][b-'a'];
        if(a == 'z') return dp[a-'a'][b-'a'] = cost[25] + next('a', b, dp, cost);
        return dp[a-'a'][b-'a'] = cost[a-'a'] + next(a + 1, b, dp, cost);
    }
    long long prev(char a, char b, vector<vector<long long>>& dp, vector<int>& cost){
        if(a == b) return 0;
        long long ans=0;
        if(dp[a-'a'][b-'a'] != -1) return dp[a-'a'][b-'a'];
        if(a == 'a') return dp[a-'a'][b-'a'] = cost[0] + prev('z', b, dp, cost);
        return dp[a-'a'][b-'a'] = cost[a-'a'] + prev(a - 1, b, dp, cost);
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0, n  = s.size();
        vector<vector<long long>>nextdp(26, vector<long long>(26, -1)), prevdp(26, vector<long long>(26, -1));
        for(int i=0;i<n;i++){
            long long first = next(s[i], t[i], nextdp, nextCost), second = prev(s[i], t[i], prevdp, previousCost);
            ans += min(first, second);
            // cout<<ans<<endl;
        }
        return ans;
    }
};",1460845231
Shivesh Gupta,Shivesh__Gupta__,479,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool chance=0;
        int val = 10;
        while(n >= 0){
            if(n<val) {
                if(chance) return 1;
                return 0;
            }
            else{
                n-=val;
            }
            chance = !chance;
            val--;
        }
        return 1;
    }
};",1460809873
Shivesh Gupta,Shivesh__Gupta__,479,3648,cpp,"class Solution {
public:
    int vertical(int row, int col, vector<vector<int>>& dp, vector<vector<int>>& fruits){
        int n = fruits.size();
        if(col <= row) return 0;
        if(dp[row][col] != -1) return dp[row][col];
        int c[3] = {col-1, col, col+1};
        int ans=0;
        for(int i=0;i<3;i++){
            if(c[i] >= 0 && c[i] < n){
                ans = max(ans,fruits[row][col]+ vertical(row+1, c[i], dp, fruits));
            }
        }
        return dp[row][col] = ans;
    }
    int hori(int row, int col, vector<vector<int>>& dp, vector<vector<int>>& fruits){
        int n = fruits.size();
        if(col >= row) return 0;
        if(dp[row][col] != -1) return dp[row][col];
        int r[3] = {row-1, row, row+1};
        int ans=0;
        for(int i=0;i<3;i++){
            if(r[i] >= 0 && r[i] < n){
                ans = max(ans,fruits[row][col]+ hori(r[i], col+1, dp, fruits));
            }
        }
        return dp[row][col] = ans;
    }
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int ans=0;
        int n = fruits.size();
        for(int i=0;i<n;i++){
            ans += fruits[i][i];
        }
        vector<vector<int>>dp(n, vector<int>(n, -1));
        // cout<<ans;
        ans += vertical(0, n-1, dp, fruits);
        // cout<<ans<<endl;
        ans += hori(n-1, 0, dp, fruits);
        // cout<<ans<<endl;
        return ans;
    }
};",1460915166
Aditya Kothari,adityask,482,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.size();i++)
            {
                int e=t[i]-'a',st=s[i]-'a';
                long long c1=0;
                while(e!=st)
                    {
                        c1+=nextCost[st];
                        st++;
                        if(st==26)
                        {
                            st-=26;
                        }
                    }
                e=t[i]-'a';
                st=s[i]-'a';
                long long c2=0;
                while(e!=st)
                    {
                        c2+=previousCost[st];
                        st--;
                        if(st==-1)
                        {
                            st+=26;
                        }
                    }
                ans+=min(c1,c2);
            }
        return ans;
    }
};",1460813222
Aditya Kothari,adityask,482,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x=0,z=10;
        while(n>=z)
            {
                n-=z;
                z--;
                x=1-x;
            }
        return x;
    }
};",1460797787
Aditya Kothari,adityask,482,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& a) {
        int n=a.size();
        int ans=a[n-1][n-1];
        for(int i=0;i<n-1;i++)
            {
                ans+=a[i][i];
            }
        int mx=n/2;
        //vector<vector<
        for(int i=1;i<mx;i++)
            {
                for(int j=n-1;j>=n-1-i;j--)
                    {
                        if(j==n-1-i)
                        {
                            a[i][j]+=a[i-1][j+1];
                        }
                        else if(j==n-1)
                        {
                            if(n-i<=j-1)
                            a[i][j]+=max(a[i-1][j],a[i-1][j-1]);
                            else a[i][j]+=a[i-1][j];
                        }
                        else{
                            if(n-i<=j-1)
                            a[i][j]+=max(a[i-1][j],max(a[i-1][j+1],a[i-1][j-1]));
                            else a[i][j]+=max(a[i-1][j],a[i-1][j+1]);
                        }
                    }
            }
        if(n&1)
        {
            // a[mx][mx+1]+=max(a[mx-1][mx+1],a[mx-1][mx+2]);
            for(int i=mx;i<n-1;i++)
            {
                for(int j=mx+1+i-mx;j<=n-1;j++)
                    {
                        if(i==mx && j==mx+1)                        
                        {
                            if(j!=n-1)
                            a[i][j]+=max(a[i-1][j],a[i-1][j+1]);
                            else a[i][j]+=a[i-1][j];
                        }
                        else if(j!=n-1)
                        {
                            a[i][j]+=max(a[i-1][j],max(a[i-1][j-1],a[i-1][j+1]));
                        }
                        else{
                            a[i][j]+=max(a[i-1][j],a[i-1][j-1]);
                            
                        }
                        
                    }
            }
        }
        else{
            // a[mx][mx+1]+=max(max(a[mx-1][mx],a[mx-1][mx+1]),a[mx-1][mx+2]);
            for(int i=mx;i<n-1;i++)
            {
                for(int j=mx+1+i-mx;j<=n-1;j++)
                    {
                        if(j!=n-1)
                        {
                            a[i][j]+=max(a[i-1][j],max(a[i-1][j-1],a[i-1][j+1]));
                        }
                        else{
                            a[i][j]+=max(a[i-1][j],a[i-1][j-1]);   
                        }
                        
                    }
            }
        }
        // for(auto i:a)
        //     {
        //         for(auto j:i)
        //             {
        //                 cout<<j<<"" "";
        //             }
        //         cout<<""\n"";
        //     }
// cout<<""\n\n brek\n"";
        for(int j=1;j<mx;j++)
            {
                for(int i=n-1;i>=n-1-j;i--)
                    {
                        if(i==n-1-j)
                        {
                            a[i][j]+=a[i+1][j-1];
                        }
                        else if(i==n-1)
                        {
                            if(n-j<=i-1)
                            a[i][j]+=max(a[i][j-1],a[i-1][j-1]);
                            else a[i][j]+=a[i][j-1];
                        }
                        else{
                            if(n-j<=i-1)
                            a[i][j]+=max(a[i][j-1],max(a[i+1][j-1],a[i-1][j-1]));
                            else a[i][j]+=max(a[i][j-1],a[i+1][j-1]);
                        }
                    }
            }

        

        if(n&1)
        {
            // a[mx][mx+1]+=max(a[mx-1][mx+1],a[mx-1][mx+2]);
            for(int j=mx;j<n-1;j++)
            {
                for(int i=mx+1+j-mx;i<=n-1;i++)
                    {
                        // cout<<i<<"" ""<<j<<"" \n"";
                        
                        if(j==mx && i==mx+1)                        
                        {
                            if(i!=n-1)
                            a[i][j]+=max(a[i][j-1],a[i+1][j-1]);
                            else a[i][j]+=a[i][j-1];
                        }
                        else if(i!=n-1)
                        {
                            a[i][j]+=max(a[i][j-1],max(a[i-1][j-1],a[i+1][j-1]));
                        }
                        else{
                            a[i][j]+=max(a[i][j-1],a[i-1][j-1]);
                            
                        }
                        
                    }
            }
        }
        else{
            // a[mx][mx+1]+=max(max(a[mx-1][mx],a[mx-1][mx+1]),a[mx-1][mx+2]);
            for(int j=mx;j<n-1;j++)
            {
                for(int i=mx+1+j-mx;i<=n-1;i++)
                    {
                        if(i!=n-1)
                        {
                            a[i][j]+=max(a[i][j-1],max(a[i-1][j-1],a[i+1][j-1]));
                        }
                        else{
                            a[i][j]+=max(a[i][j-1],a[i-1][j-1]);   
                        }
                        
                    }
            }
        }
        // for(auto i:a)
        //     {
        //         for(auto j:i)
        //             {
        //                 cout<<j<<"" "";
        //             }
        //         cout<<""\n"";
        //     }
        // cout<<ans<<"" ""<<a[n-2][n-1];
        return ans+a[n-2][n-1]+a[n-1][n-2];
    }
};",1460912751
CS IITIAN,cs_iitian,483,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        for (int i = 0; i < s.length(); i++) {
            long nc = getNextCost(s.charAt(i), t.charAt(i), nextCost);
            long pc = getPrevCost(s.charAt(i), t.charAt(i), previousCost);
            ans += Math.min(nc, pc);
        }
        return ans;
    }

    public long getNextCost(char a, char b, int[] cost) {
        long temp = 0;
        while(a != b) {
            temp += (long)cost[a - 'a'];
            if (a == 'z') a = 'a';
            else a++;
        }
        return temp;
    }

    public long getPrevCost(char a, char b, int[] cost) {
        long temp = 0;
        while(a != b) {
            temp += (long)cost[a - 'a'];
            if (a == 'a') a = 'z';
            else a--;
        }
        return temp;
    }
}",1460824091
CS IITIAN,cs_iitian,483,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean alice = true;
        int count = 10;
        while (n >= 0) {
            n -= count;
            count--;
            alice = !alice;
        }
        return alice;
    }
}",1460799818
CS IITIAN,cs_iitian,483,3648,java,"class Solution {
    public int maxCollectedFruits(int[][] fruits) {
        int total = 0, n = fruits.length;
        for (int i = 0; i < n; i++) {
            total += fruits[i][i];
            fruits[i][i] = 0;
        }
        // total += fruits[0][n-1] + fruits[n-1][0];
        int[][] dp = new int[n][n];
        dp[0][n-1] = fruits[0][n-1];
        dp[n-1][0] = fruits[n-1][0];
        for (int i = 1; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (i + j < n - 1) continue;
                int temp = Math.max(dp[i-1][j-1], dp[i-1][j]);
                if (j < n-1) temp = Math.max(temp, dp[i-1][j+1]);
                dp[i][j] = Math.max(dp[i][j], temp + fruits[i][j]);
            }
        }
        for (int j = 1; j < n; j++) {
            for (int i = n - 1; i > j; i--) {
                if (i + j < n - 1) continue;
                int temp = Math.max(dp[i-1][j-1], dp[i][j-1]);
                if (i < n-1) temp = Math.max(temp, dp[i+1][j-1]);
                dp[i][j] = Math.max(dp[i][j], temp + fruits[i][j]);
            }
        }
        total += (dp[n-2][n-1] + dp[n-1][n-2]);
        // for (int[] d: dp) {
        //     for (int x: d) {
        //         System.out.print(x + "" "");
        //     }
        //     System.out.println();
        // }
        return total;
    }
}",1460902764
Ankit,ankit1442002,484,3591,cpp,"class Solution {
public:

    long long get(vector<long long > &v , int i ,int j){
        if(j < i) return 0ll;
        
        return v[j + 1] - v[i];
    }

    long long cost(vector<long long > &A , vector<long long > &B , int i ,int j, int n) {
        if(i == j) return 0ll;
            // i goes to j 
            if(i < j) {
                long long  nextVal = get(A , i , j - 1);
                long long prevVal = B[n] - get(B , i + 1 , j);
                // cout << nextVal << "" ""<< prevVal << ""less""<< endl;
                return min(nextVal, prevVal);
                
            } else{
                long long prevVal = get(B, j + 1, i);
                long long nextVal = A[n] - get(A, j , i - 1);
                // cout << nextVal << "" ""<< prevVal << ""more""<< endl;
                return min(prevVal , nextVal);
            }
    }
    long long shiftDistance(string s, string t, vector<int>& a, vector<int>& b) {
        int n = s.size();
        int alphaSize = 26;
        vector<long long > A(alphaSize + 1), B(alphaSize + 1);
        for(int i =1 ;i<=alphaSize;i++){
            A[i] = A[i - 1] + a[i - 1];
            B[i] = B[i - 1] + b[i - 1];
        }

        
        long long res =0 ;
        for(int i =0 ;i<n;i++){
            long long val = cost(A , B , s[i] - 'a', t[i] - 'a', alphaSize);
            
            res += val;
        }
        return res;
    }
};",1460842405
Ankit,ankit1442002,484,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool lose = false;
        int x = 10;
        while(n-x>=0){
            lose = !lose;
            
            
            n-=x;
            x--;
        }
        return lose;
    }
};",1460801982
Ankit,ankit1442002,484,3648,cpp,"class Solution {
public:
int dp[1010][1010];
int solc(vector<vector<int>> &a, int i , int j){
	int n = a.size();
	
	if(i == n -1 && j == n -1) {
		return 0;
	}

	if(i > n - 1 || j > n -1 || i < 0){
		return INT_MIN;
	}

	if(dp[i][j] != -1){
		return dp[i][j];
	}
	int res = max(
		{
			solc(a, i - 1, j + 1),
			solc(a, i , j + 1),
			solc(a , i + 1, j + 1)
		}
	) + a[i][j];

	return dp[i][j] = res;
	
}

int solb(vector<vector<int>> &a, int i , int j ){
	int n = a.size();
	
	if(i == n -1 && j == n -1) {
		return 0;
	}

	if(i > n - 1 || j > n -1 || j < 0){
		return INT_MIN;
	}

	if(dp[i][j] != -1){
		return dp[i][j];
	}
	int res = max(
		{
			solb(a, i + 1, j),
			solb(a , i + 1, j + 1),
			solb(a , i + 1, j - 1)

		}
	) + a[i][j];

	return dp[i][j] = res;
}

int maxCollectedFruits(vector<vector<int>> &a){
	int diag = 0;
	int n = a.size();
	for(int i =0 ;i<n;i++){
		diag += a[i][i];
		a[i][i] = 0;
	}


	memset(dp, -1, sizeof(dp));
	
	int res = solc(a, n - 1, 0);

    memset(dp, -1, sizeof(dp));
	int res2 = solb(a , 0 , n - 1);

	return res + res2 + diag;
}


    // int maxCollectedFruits(vector<vector<int>>& fruits) {
        
    // }
};",1460910113
trueloli,trueloli,486,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        def f(x, y):
            # front
            src, dst = ord(x) - 97, ord(y) - 97
            a, b = src, dst
            ans1 = ans2 =0
            while a != b:
                ans1 += nextCost[a]
                a = (a+1) % 26
            a, b = src, dst
            while a != b:
                ans2 += previousCost[a]
                a -= 1
                if a < 0: a = 25

            return min(ans1, ans2)

        # either go front or go back
        ans = 0
        for i in range(len(s)):
            ans += f(s[i], t[i])

        return ans
        ",1460809209
trueloli,trueloli,486,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:

        r = 10
        winner = 'B'
        while r <= n:
            n -= r
            r -= 1
            winner = 'A' if winner == 'B' else 'B'
            
        return winner == 'A'
        ",1460799759
trueloli,trueloli,486,3648,python3,"class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:

        #for r in fruits: print(r)
        #print()
        
        n = len(fruits)
        if n == 2: return sum([sum(x) for x in fruits])
        if n == 3: return sum([sum(x) for x in fruits]) - fruits[1][0] - fruits[0][1]

        fruits2 = fruits[:]
        loop = 1
        for j in range(1, n-1):
            # when reach n//2, we need to start shrinking the row-1 requirement
            if j >= n//2:
                if (n)%2==0: loop -= 1
                for i in range(n-1, n-1-loop, -1):
                    fruits2[i][j] += max(
                        fruits2[i][j-1],
                        0 if i==n-1-loop+1 and n%2==1 and n//2==j else fruits2[i-1][j-1],
                        fruits2[i+1][j-1] if i != n-1 else 0
                    )
                if (n)%2==1: loop -= 1
            else:
                for i in range(n-1, n-1-(j+1), -1):
                    fruits2[i][j] += max(
                        fruits2[i][j-1] if i != n-1-(j+1)+1 else 0,
                        fruits2[i-1][j-1] if i-1>n-1-loop else 0,
                        fruits2[i+1][j-1] if i != n-1 else 0
                    )
                loop = j+1

        fruits3 = fruits[:]
        loop = 1
        for i in range(1, n-1):
            # when reach n//2, we need to start shrinking the row-1 requirement
            if i >= n//2:
                if (n)%2==0: loop -= 1
                for j in range(n-1, n-1-loop, -1):
                    fruits2[i][j] += max(
                        fruits2[i-1][j],
                        0 if j==n-1-loop+1 and n%2==1 and n//2==i else fruits2[i-1][j-1],
                        fruits2[i-1][j+1] if j != n-1 else 0
                    )
                if (n)%2==1: loop -= 1
            else:
                for j in range(n-1, n-1-(i+1), -1):
                    fruits2[i][j] += max(
                        fruits2[i-1][j] if j != n-1-(i+1)+1 else 0,
                        fruits2[i-1][j-1] if j-1>n-1-loop else 0,
                        fruits2[i-1][j+1] if j != n-1 else 0
                    )
                loop = i+1

        i = j = 1
        while i < n:
            fruits[i][j] += fruits[i-1][j-1]
            i+=1
            j+=1

        #for r in fruits: print(r)
        
        return fruits[-1][-1] + fruits[-1][-2] + fruits[-2][-1]
        '''
        x x x x x x
        x x x x x x
        x x x x x x
        x x x x x x
        x x x x x x
        x x x x x x
          2 3 2 1 
        x x x x x 
        x x x x x 
        x x x x x 
        x x x x x 
        x x x x x 
          2 2 1 1
        x x x x 
        x x x x 
        x x x x 
        x x x x 
          2 1 
        '''
        ",1460911195
billk1729,billk1729,487,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long sum = 0;
        int distf, distb;
        long long fcost, bcost, sindex, tindex;
        for (int i = 0; i < s.length(); i++) {
            if ((int)s[i] > (int)t[i]) {
                distb = (int)s[i]-(int)t[i];
                distf = (int)t[i]-(int)s[i]+26;
            } else {
                distf = (int)t[i]-(int)s[i];
                distb = (int)s[i]-(int)t[i]+26;
            }
            //cout << s[i] << "" "" << t[i] << "" "" << distf << "" "" << distb << endl;
            fcost = 0;
            bcost = 0;
            sindex = (int)s[i]-'a';
            tindex = (int)t[i]-'a';
            for (int j = 0; j < distf; j++) {
                fcost += nextCost[(sindex+j)%26];
                //cout << fcost << endl;
            }
            for (int j = 0; j < distb; j++) {
                bcost += previousCost[(sindex-j+26)%26];
            }
            sum += (fcost < bcost) ? fcost : bcost;
        }

        return sum;
    }
};",1460815253
billk1729,billk1729,487,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool Aturn = true;
        for (int i = 10; i > 0; i--) {
            if (i > n)
                return !Aturn;
            Aturn = !Aturn;
            n -= i;
        }

        return false;
    }
};",1460796877
billk1729,billk1729,487,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        // first child has to move along the main diagonal.  No choice
        // second child always moves to the right, but can veer up or down.
        // second child has no reason to cross the main diagonal -- wouldn't be able
        // to make it to the exit in time.  They should stay below.
        // third child should stay to the left of the main diagonal.
        // comes down to optimizing the second and third children's routes

        int n = fruits.size();
        
        // second child...
        // halfway point would be col (n-1)/2?
        // if n is even, it's ""mirrored""; if n is odd, it's unique
        // number of possible targets would be
        vector<vector<int>> secondBestTo;
        vector<vector<int>> secondBestFrom;
        vector<vector<int>> thirdBestTo;
        vector<vector<int>> thirdBestFrom;

        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += fruits[i][i];
            fruits[i][i] = 0;
        }

        
        int max;
        int width = (n-1)/2+1;
        width = (n-1)/2+1;
        secondBestTo.resize(n);
        thirdBestTo.resize(n);
        secondBestFrom.resize(n);
        thirdBestFrom.resize(n);
        for (int i = 0; i < n; i++) {
            secondBestTo[i].resize(n,-1);
            thirdBestTo[i].resize(n, -1);
            secondBestFrom[i].resize(n,-1);
            thirdBestFrom[i].resize(n, -1);
        }
        secondBestTo[0][n-1] = fruits[0][n-1];
        thirdBestTo[n-1][0] = fruits[n-1][0];
        for (int i = 1; i <= width; i++) {
            for (int j = 0; j <= i; j++) {
                max = secondBestTo[i-1][n-1-j];
                if (n-1-j > 0 && secondBestTo[i-1][n-1-j-1] > max)
                    max = secondBestTo[i-1][n-1-j-1];
                if (n-1-j < n-1 && secondBestTo[i-1][n-1-j+1] > max)
                    max = secondBestTo[i-1][n-1-j+1];
                secondBestTo[i][n-1-j] = fruits[i][n-1-j] + max;
                //cout << ""2b2 "" << i << "","" << n-j-1 << "": "" << secondBestTo[i][n-1-j] << endl;
                
                max = thirdBestTo[n-j-1][i-1];
                if (n-1-j > 0 && thirdBestTo[n-1-j-1][i-1] > max)
                    max = thirdBestTo[n-1-j-1][i-1];
                if (n-1-j < n-1 && thirdBestTo[n-j-1+1][i-1] > max)
                    max = thirdBestTo[n-j-1+1][i-1];
                thirdBestTo[n-j-1][i] = fruits[n-j-1][i] + max;
                //cout << ""3b2 "" << n-j-1 << "","" << i << "": "" << thirdBestTo[n-j-1][i] << endl;
            }
        }

        secondBestFrom[n-1][n-1] = 0;
        thirdBestFrom[n-1][n-1] = 0;
        for (int i = 1; i < width; i++) {
            for (int j = 0; j <= i; j++) {
                max = secondBestFrom[n-i][n-j-1];
                if (n-j-1 > 0 && secondBestFrom[n-i][n-j-1-1] > max)
                    max = secondBestFrom[n-i][n-j-1-1];
                if (n-j-1 < n-1 && secondBestFrom[n-i][n-j-1+1] > max)
                    max = secondBestFrom[n-i][n-j-1+1];
                secondBestFrom[n-i-1][n-j-1] = fruits[n-i-1][n-1-j] + max;
                //cout << ""2bf "" << n-i-1 << "","" << n-j-1 << "": "" << secondBestFrom[n-i-1][n-1-j] << endl;
                
                max = thirdBestFrom[n-j-1][n-i];
                if (n-j-1 > 0 && thirdBestFrom[n-j-1-1][n-i] > max)
                    max = thirdBestFrom[n-j-1-1][n-i];
                if (n-j-1 < n-1 && thirdBestFrom[n-j-1+1][n-i] > max)
                    max = thirdBestFrom[n-j-1+1][n-i];
                thirdBestFrom[n-j-1][n-i-1] = fruits[n-j-1][n-i-1] + max;
                //cout << ""3bf "" << n-j-1 << "","" << n-i-1 << "": "" << thirdBestFrom[n-j-1][n-1-i] << endl;
            }
        }

        int second = 0, third = 0;
        int foo, foo2, foo3;
        if (n%2 == 1) {
            for (int i = 0; i < width; i++) {
                foo = secondBestTo[n-width][n-i-1] + secondBestFrom[n-width][n-i-1] - fruits[n-width][n-i-1];
                if (foo > second)
                    second = foo;
                foo = thirdBestTo[n-i-1][n-width] + thirdBestFrom[n-i-1][n-width] - fruits[n-i-1][n-width];
                if (foo > third)
                    third = foo;
            }
        } else {
            for (int i = 0; i <= width; i++) {
                foo = secondBestTo[n-width-1][n-i-1] + secondBestFrom[n-width][n-i-1];
                foo2 = 0; foo3 = 0;
                if (n-i-1 > 0) {
                    foo2 = secondBestTo[n-width-1][n-i-1] + secondBestFrom[n-width][n-i-1-1];
                }
                if (n-i-1 < n-1)
                    foo3 = secondBestTo[n-width-1][n-i-1] + secondBestFrom[n-width][n-i-1+1];
                if (foo2 > foo)
                    foo = foo2;
                if (foo3 > foo)
                    foo = foo3;
                if (foo > second)
                    second = foo;

                //cout << n-i-1 << "" "" << n-width-1 << endl;
                foo = thirdBestTo[n-i-1][n-width-1] + thirdBestFrom[n-i-1][n-width];
                //cout << ""foo is "" << foo << endl;
                foo2 = 0; foo3 = 0;
                if (n-i-1 > 0) {
                    foo2 = thirdBestTo[n-i-1][n-width-1] + thirdBestFrom[n-i-1-1][n-width];
                }
                if (n-i-1 < n-1)
                    foo3 = thirdBestTo[n-i-1][n-width-1] + thirdBestFrom[n-i-1+1][n-width];
                if (foo2 > foo)
                    foo = foo2;
                if (foo3 > foo)
                    foo = foo3;
                if (foo > third)
                    third = foo;
                //cout << ""third is "" << third << endl;
            }
        }

        //cout << sum << "" "" << second << "" "" << third;

        return sum+second+third;
    }
};",1460913088
btking5,btking5,489,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long nextsum[52]={};
        for(int i=0;i<26;i++){
            nextsum[i+1]=nextsum[i]+nextCost[i];
        }
        for(int i=0;i<25;i++){
            nextsum[i+27]=nextsum[i+26]+nextCost[i];
        }
        long prevsum[52]={};
        for(int i=0;i<26;i++){
            prevsum[i+1]=prevsum[i]+previousCost[25-i];
        }
        for(int i=0;i<25;i++){
            prevsum[i+27]=prevsum[i+26]+previousCost[25-i];
        }
        // cout<<""next"";
        // for(int i=0;i<52;i++){
        //     cout<<nextsum[i]<<"" "";
        // }
        // cout<<endl;
        // cout<<""prev"";
        // for(int i=0;i<52;i++){
        //     cout<<prevsum[i]<<"" "";
        // }
        // cout<<endl;
        long long sum = 0;
        for(int i=0;i<s.length();i++){
            int sidx = s[i]-'a';
            int tidx = t[i]-'a';
            long long nextv = (tidx>=sidx)? nextsum[tidx]-nextsum[sidx] : nextsum[tidx+26]-nextsum[sidx];
            long long prevv = (tidx<=sidx)? prevsum[25-tidx]-prevsum[25-sidx] : prevsum[51-tidx]-prevsum[25-sidx];
            //cout<<""the""<<i<<""nextv""<<nextv<<""prev""<<prevv<<endl;
            sum += min(nextv,prevv);

        }
        return sum;
    }
};",1460843699
btking5,btking5,489,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int alicewin = -1;
        int stones = n;
        for(int i=10;i>0;i--){
            if(stones<i) break;
            stones-=i;
            alicewin*=-1;
        }
        if(alicewin==1) return true;
        else return false;
    }
};",1460805237
btking5,btking5,489,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        int n = fruits.size();
        //cout<<""n""<<n<<endl;
        int firstchild = 0;
        for(int i=0;i<n;i++){
            firstchild+=fruits[i][i];
        }
        vector<vector<int>> second(n, std::vector<int>(n, 0));
        vector<vector<int>> curr(n, std::vector<int>(n, 0));
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                curr[j][i]=fruits[j][i];
            }
        }
        second[n-1][0]=curr[n-1][0];
        for(int i=1;i<=n-1;i++){
            for(int j=1;j<min(i-1,n-1-i);j++){
                second[n-1-j][i]=max(second[n-1-j][i-1],max(second[n-j][i-1],second[n-j-2][i-1]))+curr[n-1-j][i];
                //cout<<""initrow""<<n-1-j<<""col""<<i<<""val""<<second[n-1-j][i];
            }
            second[n-1][i]=max(second[n-1][i-1],second[n-2][i-1])+curr[n-1][i];
            second[n-1-i][i]=second[n-i][i-1]+curr[n-i-1][i];
            if(i==1) continue;
            second[n-i][i]=max(second[n-i][i-1],second[n-i+1][i-1])+curr[n-i][i];
        }
        
        vector<vector<int>> third(n, std::vector<int>(n, 0));
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                curr[j][i]=fruits[i][j];
            }
        }
        third[n-1][0]=curr[n-1][0];
        for(int i=1;i<=n-1;i++){
            for(int j=1;j<min(i-1,n-1-i);j++){
                third[n-1-j][i]=max(third[n-1-j][i-1],max(third[n-j][i-1],third[n-j-2][i-1]))+curr[n-1-j][i];
            }
            third[n-1][i]=max(third[n-1][i-1],third[n-2][i-1])+curr[n-1][i];
            third[n-1-i][i]=third[n-i][i-1]+curr[n-i-1][i];
            if(i==1) continue;
            third[n-i][i]=max(third[n-i][i-1],third[n-i+1][i-1])+curr[n-i][i];
        }
        // for(int i=0;i<=n-1;i++){
        //     for(int j=0;j<=min(i,n-i);j++){
        //         cout<<""row""<<n-1-j<<""col""<<i<<""value""<<second[n-1-j][i]<<endl;
        //     }
        // }
        // cout<<""third""<<endl;
        // for(int i=0;i<=n-1;i++){
        //     for(int j=0;j<=min(i,n-i);j++){
        //         cout<<""row""<<n-1-j<<""col""<<i<<""value""<<third[n-1-j][i]<<endl;
        //     }
        // }
        int result = firstchild + second[n-1][n-1]+third[n-1][n-1];
        //result -= 2*fruits[n-1][n-1];
        return result;
    }
};",1460912935
Mark Qi,MarkQi2002,490,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        // Variable declaration
        long long result = 0;
        int size = s.size();
        for (int i = 0; i < size; ++i) {
            long long previous = 0, next = 0;
            
            for (int j = s[i] - 'a'; j % 26 != t[i] - 'a'; ++j) {
                next += nextCost[j % 26];
            }
            for (int j = s[i] - 'a' + 26; j % 26 != t[i] - 'a'; --j) {
                previous += previousCost[j % 26];
            }
            result += min(next, previous);
        }
        return result;
    }
};",1460831448
Mark Qi,MarkQi2002,490,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for (int i = 10; i > 0; --i) {
            if (n >= i) {
                n -= i;
            } else if (n != i) {
                if (i % 2 == 0) return false;
                else return true;
            }
        }
        return false;
    }
};",1460799254
Mark Qi,MarkQi2002,490,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& fruits) {
        vector<vector<int>> directionsOne = {{1, 1}, {1, 0}, {0, 1}};
        vector<vector<int>> directionsTwo = {{1, -1}, {1, 0}, {1, 1}};
        vector<vector<int>> directionsThree = {{-1, 1}, {0, 1}, {1, 1}};
        int result = 0, n = fruits.size();
        for (int i = 0; i < n; ++i) {
            result += fruits[i][i];
            fruits[i][i] = 0;
        }
        vector<vector<int>> dp(n, vector<int>(n, 0));
        vector<vector<int>> path(n, vector<int>(n, 0));
        for (int i = 0; i < n - 1; ++i) {
            for (int j = n - 1; j >= n - i - 1; --j) {
                for (int k = 0; k < 3; ++k) {
                    int nextRow = i + directionsTwo[k][0], nextCol = j + directionsTwo[k][1];
                    if (nextCol < n) {
                        if (dp[i][j] + fruits[nextRow][nextCol] >= dp[nextRow][nextCol]) {
                            dp[nextRow][nextCol] = dp[i][j] + fruits[nextRow][nextCol];
                            path[nextRow][nextCol] = k;
                        }
                    }
                }
            }
        }
        int row = n - 1, col = n - 1;
        for (int i = 0; i < n - 1; ++i) {
            result += fruits[row][col];
            fruits[row][col] = 0;
            int a = row;
            row -= directionsTwo[path[row][col]][0];
            col -= directionsTwo[path[a][col]][1];
        }
        result += fruits[0][n - 1];

        vector<vector<int>> dp2(n, vector<int>(n, 0));
        vector<vector<int>> path2(n, vector<int>(n, 0));
        for (int i = 0; i < n - 1; ++i) {
            for (int j = n - 1; j >= n - i - 1; --j) {
                for (int k = 0; k < 3; ++k) {
                    int nextRow = j + directionsThree[k][0], nextCol = i + directionsThree[k][1];
                    if (nextRow < n) {
                        if (dp2[j][i] + fruits[nextRow][nextCol] >= dp2[nextRow][nextCol]) {
                            dp2[nextRow][nextCol] = dp2[j][i] + fruits[nextRow][nextCol];
                            path2[nextRow][nextCol] = k;
                        }
                    }
                }
            }
        }

        row = n - 1;
        col = n - 1;
        for (int i = 0; i < n - 1; ++i) {
            result += fruits[row][col];
            fruits[row][col] = 0;
            int a = row;
            row -= directionsThree[path2[row][col]][0];
            col -= directionsThree[path2[a][col]][1];
        }
        result += fruits[n - 1][0];
        return result;
    }
};",1460916543
Debjit Mandal,tensortrove,491,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        import heapq

        dist = [[float('inf')] * 26 for _ in range(26)]
        for c in range(26):
            dist[c][c] = 0
            heap = [(0, c)]
            while heap:
                cost_u, u = heapq.heappop(heap)
                if cost_u > dist[c][u]:
                    continue
                v = (u + 1) % 26
                cost_uv = nextCost[u]
                if dist[c][v] > dist[c][u] + cost_uv:
                    dist[c][v] = dist[c][u] + cost_uv
                    heapq.heappush(heap, (dist[c][v], v))
                v = (u - 1 + 26) % 26
                cost_uv = previousCost[u]
                if dist[c][v] > dist[c][u] + cost_uv:
                    dist[c][v] = dist[c][u] + cost_uv
                    heapq.heappush(heap, (dist[c][v], v))

        total_cost = 0
        n = len(s)
        for i in range(n):
            u = ord(s[i]) - ord('a')
            v = ord(t[i]) - ord('a')
            total_cost += dist[u][v]

        return total_cost
",1460868095
Debjit Mandal,tensortrove,491,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        from functools import lru_cache

        @lru_cache(maxsize=None)
        def can_win(n, k):
            if k <= 0 or n < k:
                return False
            if n == k:
                return True
            return not can_win(n - k, k - 1)

        return can_win(n, 10)
",1460864011
Debjit Mandal,tensortrove,491,3648,python3,"from typing import List

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        # Compute path1: sum of diagonal
        path1 = sum(fruits[i][i] for i in range(n))
        
        # Create modified_fruits for path2 and path3 by setting diagonal to 0
        modified_fruits = [row.copy() for row in fruits]
        for i in range(n):
            modified_fruits[i][i] = 0
        
        # Compute path2: from (0, n-1) to (n-1, n-1)
        dp2 = [[-float('inf')] * n for _ in range(n)]
        dp2[0][n-1] = modified_fruits[0][n-1]
        
        for i in range(1, n):
            for j in range(n):
                max_prev = -float('inf')
                if j - 1 >= 0:
                    max_prev = max(max_prev, dp2[i-1][j-1])
                if j < n:
                    max_prev = max(max_prev, dp2[i-1][j])
                if j + 1 < n:
                    max_prev = max(max_prev, dp2[i-1][j+1])
                if max_prev != -float('inf'):
                    dp2[i][j] = max_prev + modified_fruits[i][j]
        
        path2 = dp2[n-1][n-1] if dp2[n-1][n-1] != -float('inf') else 0
        
        # Compute path3: from (n-1, 0) to (n-1, n-1)
        dp3 = [[-float('inf')] * n for _ in range(n)]
        dp3[n-1][0] = modified_fruits[n-1][0]
        
        for j in range(1, n):
            for i in range(n):
                max_prev = -float('inf')
                if i - 1 >= 0 and j - 1 >= 0:
                    max_prev = max(max_prev, dp3[i-1][j-1])
                if j - 1 >= 0:
                    max_prev = max(max_prev, dp3[i][j-1])
                if i + 1 < n and j - 1 >= 0:
                    max_prev = max(max_prev, dp3[i+1][j-1])
                if max_prev != -float('inf'):
                    dp3[i][j] = max_prev + modified_fruits[i][j]
        
        path3 = dp3[n-1][n-1] if dp3[n-1][n-1] != -float('inf') else 0
        
        # Calculate total fruits collected
        total = path1 + path2 + path3
        return total
",1460911899
Purbi,nikhilnanda_CF,492,3591,cpp,"class Solution {
public:
    typedef long long ll;

ll shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
    vector<vector<ll>> cumNext(26, vector<ll>(26, 0));
    vector<vector<ll>> cumPrev(26, vector<ll>(26, 0));
    for(int j=0;j<26;j++){
        for(int k=1;k<26;k++){
            cumNext[j][k] = cumNext[j][k-1] + nextCost[(j +k -1)%26];
            cumPrev[j][k] = cumPrev[j][k-1] + previousCost[(j -k +1 +26)%26];
        }
    }
    ll total=0;
    int n = s.size();
    for(int i=0;i<n;i++){
        if(s[i]==t[i]) continue;
        int j = s[i]-'a', target = t[i]-'a';
        int kf = (target -j +26)%26, kb = (j - target +26)%26;
        ll cf = kf? cumNext[j][kf]:0, cb = kb? cumPrev[j][kb]:0;
        total += min(cf, cb);
    }
    return total;
}
};",1460816890
Purbi,nikhilnanda_CF,492,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n){
    if(n < 10) return false;
    n -= 10;
    int prev = 10;
    bool alice = false;
    while(true){
        int rm = prev - 1;
        if(n < rm) return !alice;
        n -= rm;
        prev = rm;
        alice = !alice;
    }
}
};",1460810230
Purbi,nikhilnanda_CF,492,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
            int n = nums.size();
            int m = queries.size();

            vector<int> pre_sum(n + 2, 0);
            for (auto& q : queries) {
                int l = q[0];
                int r = q[1];
                pre_sum[l] += 1;
                pre_sum[r + 1] -= 1;
            }

            int coverage = 0;
            for (int i = 0; i < n; ++i) {
                coverage += pre_sum[i];
                if (coverage < nums[i]) {
                    return -1;
                }
            }

            vector<pair<int, int>> sorted_queries;
            sorted_queries.reserve(m);
            for (auto& q : queries) {
                sorted_queries.emplace_back(q[0], q[1]);
            }
            sort(sorted_queries.begin(), sorted_queries.end(),
                 [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
                     if (a.first != b.first)
                         return a.first < b.first;
                     return a.second > b.second;
                 });

            priority_queue<int> heap;
            int q_ptr = 0;
            vector<int> delta(n + 2, 0);
            long long kept_queries = 0;
            coverage = 0;

            for (int i = 0; i < n; ++i) {

                coverage += delta[i];

                while (q_ptr < m && sorted_queries[q_ptr].first <= i) {
                    heap.push(sorted_queries[q_ptr].second);
                    q_ptr++;
                }

                while (!heap.empty() && heap.top() < i) {
                    heap.pop();
                }

                if (coverage < nums[i]) {
                    int needed = nums[i] - coverage;
                    for (int k = 0; k < needed; ++k) {
                        if (heap.empty()) {
                            return -1;
                        }
                        int r = heap.top();
                        heap.pop();
                        kept_queries++;
                        delta[i] += 1;
                        if (r + 1 < n + 2) {
                            delta[r + 1] -= 1;
                        }
                        coverage += 1;
                    }
                }
            }

            return m - kept_queries;
        }
};",1460823166
Arnab,arnab_97,493,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        final int ALPHABET_SIZE = 26;
         long[][] dist = new long[ALPHABET_SIZE][ALPHABET_SIZE];
         final long INF = Long.MAX_VALUE / 2; 
         for(int i = 0; i < ALPHABET_SIZE; i++) {
             Arrays.fill(dist[i], INF);
             dist[i][i] = 0; 
         }
         for(int i = 0; i < ALPHABET_SIZE; i++) {
             int next = (i + 1) % ALPHABET_SIZE;
             dist[i][next] = Math.min(dist[i][next], (long) nextCost[i]);

             int prev = (i - 1 + ALPHABET_SIZE) % ALPHABET_SIZE;
             dist[i][prev] = Math.min(dist[i][prev], (long) previousCost[i]);
         }

         for(int k = 0; k < ALPHABET_SIZE; k++) {
             for(int i = 0; i < ALPHABET_SIZE; i++) {
                 for(int j = 0; j < ALPHABET_SIZE; j++) {
                     if(dist[i][k] + dist[k][j] < dist[i][j]) {
                         dist[i][j] = dist[i][k] + dist[k][j];
                     }
                 }
             }
         }

         long totalCost = 0;
         int n = s.length();
         for(int i = 0; i < n; i++) {
             char sc = s.charAt(i);
             char tc = t.charAt(i);
             if(sc == tc) continue; 
             int scIndex = sc - 'a';
             int tcIndex = tc - 'a';
             long minCost = dist[scIndex][tcIndex];
             totalCost += minCost;
         }

         return totalCost;
    }
}",1460813289
Arnab,arnab_97,493,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int required = 10; 
        int currentPlayer = 0; 

        while (required >= 1) {
            if (n >= required) {
                n -= required;
            } else {
                if (currentPlayer == 0) {
                    return false;
                } else {
                    return true;
                }
            }
            currentPlayer = 1 - currentPlayer;
            required -= 1;
        }
        return currentPlayer != 0;
    }
}",1460822355
Arnab,arnab_97,493,3647,java,"class Solution {
    private static class Query {
        int li;
        int ri;

        Query(int li, int ri) {
            this.li = li;
            this.ri = ri;
        }
    }

    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        Query[] queryList = new Query[m];
        for(int i = 0; i < m; i++) {
            queryList[i] = new Query(queries[i][0], queries[i][1]);
        }
        int[] coverageDiff = new int[n + 1];
        for(Query q : queryList) {
            coverageDiff[q.li] +=1;
            coverageDiff[q.ri +1] -=1;
        }
        int[] coverage = new int[n];
        int current = 0;
        for(int i =0; i < n; i++) {
            current += coverageDiff[i];
            coverage[i] = current;
            if(coverage[i] < nums[i]) {
                return -1; 
            }
        }
        Arrays.sort(queryList, new Comparator<Query>() {
            public int compare(Query q1, Query q2) {
                if(q1.li != q2.li) {
                    return Integer.compare(q1.li, q2.li);
                }
                return Integer.compare(q2.ri, q1.ri); 
            }
        });
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

        int[] assignedDiff = new int[n +1];
        long active =0; 
        int minQueriesToKeep =0;
        int queryIndex =0;

        for(int i=0; i < n; i++) {
            active += assignedDiff[i];

            while(queryIndex < m && queryList[queryIndex].li <= i) {
                maxHeap.offer(queryList[queryIndex].ri);
                queryIndex++;
            }
            while(!maxHeap.isEmpty() && maxHeap.peek() < i) {
                maxHeap.poll();
            }

            if(active < nums[i]) {
                int need = nums[i] - (int)active;

                if(maxHeap.size() < need) {
                    return -1; 
                }

                for(int j =0; j < need; j++) {
                    if(maxHeap.isEmpty()) {
                        return -1; 
                    }
                    int ri = maxHeap.poll();
                    minQueriesToKeep++;
                    assignedDiff[i] +=1;
                    if(ri +1 < n) {
                        assignedDiff[ri +1] -=1;
                    }
                }

                active += need;
            }
        }

        return m - minQueriesToKeep;
    }
}
",1460817106
Ashish Chaudhary,chaudharyashish859,495,3591,cpp,"typedef long long ll;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost,
                            vector<int>& previousCost) {
        auto charToIndex = [&](char c) -> int { return c - 'a'; };

        const ll INF = 1e18;
        vector<vector<ll>> distance(26, vector<ll>(26, INF));
        for (int i = 0; i < 26; i++) {
            distance[i][i] = 0;
            int next_char = (i + 1) % 26;
            distance[i][next_char] =
                min(distance[i][next_char], (ll)nextCost[i]);
            int prev_char = (i - 1 + 26) % 26;
            distance[i][prev_char] =
                min(distance[i][prev_char], (ll)previousCost[i]);
        }

        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                for (int j = 0; j < 26; j++) {
                    if (distance[i][k] + distance[k][j] < distance[i][j]) {
                        distance[i][j] = distance[i][k] + distance[k][j];
                    }
                }
            }
        }

        ll total_cost = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i])
                continue;
            int from = charToIndex(s[i]);
            int to = charToIndex(t[i]);
            total_cost += distance[from][to];
        }

        return total_cost;
    }
};",1460836333
Ashish Chaudhary,chaudharyashish859,495,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10){
            return false;
        }
        
        for(int i=0;i<10;i++){
            if(i%2==0 && n<10-i){
                return false;
            }
            if(n<10-i){
                break;
            }
            n-=10-i;
        }
        return true;
        
    }
};",1460812115
Ashish Chaudhary,chaudharyashish859,495,3647,cpp,"struct SegmentTree {
    int n;
    vector<long long> tree;
    vector<long long> lazy;

    SegmentTree(int size) : n(size), tree(4 * size, 0), lazy(4 * size, 0) {}

    void build(vector<long long>& arr, int idx, int l, int r) {
        if (l == r) {
            tree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        build(arr, 2 * idx, l, mid);
        build(arr, 2 * idx + 1, mid + 1, r);
        tree[idx] = min(tree[2 * idx], tree[2 * idx + 1]);
    }

    void push_down(int idx) {
        if (lazy[idx] != 0) {
            tree[2 * idx] += lazy[idx];
            lazy[2 * idx] += lazy[idx];
            tree[2 * idx + 1] += lazy[idx];
            lazy[2 * idx + 1] += lazy[idx];
            lazy[idx] = 0;
        }
    }

    void range_add(int idx, int l, int r, int L, int R, long long val) {
        if (L > R)
            return;
        if (l > R || r < L)
            return;
        if (l >= L && r <= R) {
            tree[idx] += val;
            lazy[idx] += val;
            return;
        }
        push_down(idx);
        int mid = (l + r) / 2;
        range_add(2 * idx, l, mid, L, R, val);
        range_add(2 * idx + 1, mid + 1, r, L, R, val);
        tree[idx] = min(tree[2 * idx], tree[2 * idx + 1]);
    }

    long long range_min(int idx, int l, int r, int L, int R) {
        if (L > R)
            return 1e18;
        if (l > R || r < L)
            return 1e18;
        if (l >= L && r <= R)
            return tree[idx];
        push_down(idx);
        int mid = (l + r) / 2;
        return min(range_min(2 * idx, l, mid, L, R),
                   range_min(2 * idx + 1, mid + 1, r, L, R));
    }
};
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();
        vector<int> coverage(n + 1, 0);

        for (auto& query : queries) {
            int l = query[0];
            int r = query[1];
            coverage[l] += 1;
            if (r + 1 < n)
                coverage[r + 1] -= 1;
        }

        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }

        vector<long long> budget(n, 0);
        for (int i = 0; i < n; i++) {
            budget[i] = (long long)coverage[i] - (long long)nums[i];
            if (budget[i] < 0)
                return -1;
        }

        sort(queries.begin(), queries.end(),
             [&](const vector<int>& a, const vector<int>& b) -> bool {
                 int len_a = a[1] - a[0] + 1;
                 int len_b = b[1] - b[0] + 1;
                 if (len_a != len_b)
                     return len_a < len_b;
                 return a < b;
             });

        SegmentTree st(n);
        st.build(budget, 1, 0, n - 1);
        int removed = 0;
        for (auto& query : queries) {
            int l = query[0];
            int r = query[1];
            long long mn = st.range_min(1, 0, n - 1, l, r);
            if (mn >= 1) {
                removed += 1;
                st.range_add(1, 0, n - 1, l, r, -1);
            }
        }

        return removed;
    }
};",1460825872
Nihal,nsk_91,496,3591,cpp,"
#include <string>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

class Solution {
public:
    long long shiftDistance(string var_200, string var_201, vector<int>& var_202, vector<int>& var_203) {
        long long var_204 = 0;

        int var_205 = 0;
        while (var_205 < var_200.length()) {
            int var_206 = var_200[var_205] - 'a';
            int var_207 = var_201[var_205] - 'a';

            int var_208 = (var_207 - var_206 + 26) % 26;
            int var_209 = (var_206 - var_207 + 26) % 26;

            long long var_210 = 0;
            int var_211 = 0;
            while (var_211 < var_208) {
                var_210 += var_202[(var_206 + var_211) % 26];
                var_211++;
            }

            long long var_212 = 0;
            int var_213 = 0;
            while (var_213 < var_209) {
                var_212 += var_203[(var_206 - var_213 + 26) % 26];
                var_213++;
            }

            switch (0) {
                case 0:
                    if (var_204 + min(var_210, var_212)) {}
                    var_204 += min(var_210, var_212);
                    break;
            }

            var_205++;
        }

        return var_204;
    }
};
",1460804844
Nihal,nsk_91,496,3625,cpp,"class Solution {
public:
    bool canAliceWin(int var_200) {
        int var_201 = 10;
        bool var_202 = true;

        for (; var_200 > 0; ) {
            switch (var_200 >= var_201) {
                case true:
                    var_200 -= var_201;
                    var_201--;
                    var_202 = !var_202;
                    break;
                default:
                    return !var_202;
            }
        }
        return !var_202;
    }
};
",1460798999
Nihal,nsk_91,496,3647,cpp,"
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxRemoval(vector<int>& var_200, vector<vector<int>>& var_201) {
        int var_202 = var_200.size();
        int var_203 = var_201.size();
        
        vector<int> var_204(var_202 + 1, 0);
        int var_205 = 0;
        while (var_205 < var_201.size()) {
            int var_206 = var_201[var_205][0];
            int var_207 = var_201[var_205][1];
            var_204[var_206] += 1;
            if (var_207 + 1 < var_202) {
                var_204[var_207 + 1] -= 1;
            }
            var_205++;
        }

        int var_208 = 1;
        while (var_208 < var_202) {
            var_204[var_208] += var_204[var_208 - 1];
            var_208++;
        }

        int var_209 = 0;
        while (var_209 < var_202) {
            switch (var_204[var_209] < var_200[var_209]) {
                case true:
                    return -1;
                default:
                    break;
            }
            var_209++;
        }

        vector<tuple<int, int, int>> var_210;
        var_210.reserve(var_203);
        int var_211 = 0;
        while (var_211 < var_203) {
            var_210.emplace_back(var_201[var_211][0], var_201[var_211][1], var_211);
            var_211++;
        }
        sort(var_210.begin(), var_210.end(), [&](const tuple<int, int, int>& var_212, const tuple<int, int, int>& var_213) -> bool {
            switch (get<0>(var_212) == get<0>(var_213)) {
                case true:
                    return get<1>(var_212) > get<1>(var_213);
                default:
                    return get<0>(var_212) < get<0>(var_213);
            }
        });

        priority_queue<pair<int, int>> var_214;
        vector<int> var_215(var_202 + 1, 0);
        int var_216 = 0;
        unordered_set<int> var_217;

        vector<tuple<int, int, int>> var_218 = var_210;

        int var_219 = 0;
        int var_220 = 0;
        for (; var_220 < var_202; var_220++) {
            var_216 += var_215[var_220];

            while (var_219 < var_203 && get<0>(var_210[var_219]) <= var_220) {
                int var_221 = get<1>(var_210[var_219]);
                int var_222 = get<2>(var_210[var_219]);
                var_214.emplace(var_221, var_222);
                var_219++;
            }

            while (!var_214.empty() && var_214.top().first < var_220) {
                var_214.pop();
            }

            int var_223 = var_216;

            switch (var_223 < var_200[var_220]) {
                case true: {
                    int var_224 = var_200[var_220] - var_223;
                    int var_225 = 0;
                    while (var_225 < var_224) {
                        switch (var_214.empty()) {
                            case true:
                                return -1;
                            default:
                                break;
                        }

                        auto var_226 = var_214.top();
                        var_214.pop();
                        int var_227 = var_226.first;
                        int var_228 = var_226.second;
                        var_217.insert(var_228);

                        var_215[var_220] += 1;
                        if (var_227 + 1 < var_202) {
                            var_215[var_227 + 1] -= 1;
                        }
                        var_216 += 1;
                        var_225++;
                    }
                    break;
                }
                default:
                    break;
            }
        }

        return var_203 - var_217.size();
    }
};
",1460830383
Tutul_dhar,Tutul_dhar,497,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for(int i = 0; i < n; i++) {
            if(s[i] == t[i]) continue;
            long long p = 0,q = 0;
            if(s[i] < t[i]) {
                int c = s[i] - 'a',cc = t[i] - 'a';
                for(int j = c; j < cc; j++) p += nextCost[j];
                for(int j = c; j >= 0; j--) q += previousCost[j];
                for(int j = 25; j > cc; j--) q += previousCost[j];
            } else {
                int c = s[i] - 'a',cc = t[i] - 'a';
                for(int j = c; j > cc; j--) p += previousCost[j];
                for(int j = c; j < 26; j++) q += nextCost[j];
                for(int j = 0; j < cc; j++) q += nextCost[j];
            }
            ans += min(p,q);
        }
        return ans;
    }
};",1460817151
Tutul_dhar,Tutul_dhar,497,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int e = 10,p = 0;
        while(e <= n) {
            p++;
            n -= e;
            e--;
        }
        if(e%2) return true;
        return false;
    }
};",1460798892
Tutul_dhar,Tutul_dhar,497,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int ans = 0;
        multiset<int> s,ss;
        sort(queries.begin(),queries.end());
        int j = 0;
        for(int i = 0; i < n; i++) {
            while(ss.size() and *ss.begin() < i) {
                ss.erase(ss.begin());
            }
            while(j < queries.size() and queries[j][0] == i) {
                s.insert(queries[j][1]);
                j++;
            }
            while(ss.size() < nums[i] and s.size()) {
                auto it = s.end();
                it--;
                if(*it < i) break;
                ss.insert(*it);
                s.erase(it);
                ans++;
            }
            if(ss.size() < nums[i]) {
                ans = -1;
                break;
            }
        }
        if(ans == -1) return ans;
        return queries.size() - ans;
    }
};",1460838094
nimish7866,nimish7866,498,3591,cpp,"class Solution {
public:
    long long getCost(char f, char t, vector<int>& nC, vector<int>& pC) {
        if (f == t) return 0;
        
        int fwd = (t - f + 26) % 26;
        int bwd = (f - t + 26) % 26;
        
        long long fCost = 0, bCost = 0;
        
        for (int i = 0; i < fwd; i++) {
            int c = (f - 'a' + i) % 26;
            fCost += nC[c];
        }
        
        for (int i = 0; i < bwd; i++) {
            int c = (f - 'a' - i + 26) % 26;
            bCost += pC[c];
        }
        
        return min(fCost, bCost);
    }
    
    long long shiftDistance(string s, string t, vector<int>& nC, vector<int>& pC) {
        int n = s.length();
        long long tCost = 0;
        
        for (int i = 0; i < n; i++) {
            tCost += getCost(s[i], t[i], nC, pC);
        }
        
        return tCost;
    }
};",1460805063
nimish7866,nimish7866,498,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) {
            return false;
        }
        
        int remaining = n - 10;
        
        if (remaining < 9) {
            return true;
        }
        remaining -= 9;
        
        if (remaining < 8) {
            return false;
        }
        remaining -= 8;
        
        if (remaining < 7) {
            return true;
        }
        remaining -= 7;
        
        if (remaining < 6) {
            return false;
        }
        remaining -= 6;
        
        if (remaining < 5) {
            return true;
        }
        remaining -= 5;
        
        if (remaining < 4) {
            return false;
        }
        remaining -= 4;
        
        if (remaining < 3) {
            return true;
        }
        remaining -= 3;
        
        if (remaining < 2) {
            return false;
        }
        remaining -= 2;
        
        if (remaining < 1) {
            return true;
        }
        remaining -= 1;
        
        return false;
    }
};",1460800615
nimish7866,nimish7866,498,3647,cpp,"using vi = vector<int>;
using vvi = vector<vi>;
using pii = pair<int, int>;

struct Query {
    int l, r, idx;
    Query(int x, int y, int z) : l(x), r(y), idx(z) {}
};

class Solution {
public:
    void calcCov(vi& cov, const vvi& q, int n) {
        for (auto& qq : q) {
            int l = qq[0], r = qq[1];
            cov[l] += 1;
            if (r + 1 < n) cov[r + 1] -= 1;
        }
        for (int i = 1; i < n; i++) cov[i] += cov[i - 1];
    }

    bool chkCov(const vi& nums, const vi& cov, int n) {
        for (int i = 0; i < n; i++) {
            if (cov[i] < nums[i]) return false;
        }
        return true;
    }

    void sortQry(vector<Query>& qw, const vvi& q, int m) {
        qw.reserve(m);
        for (int i = 0; i < m; i++) {
            qw.emplace_back(q[i][0], q[i][1], i);
        }
        sort(qw.begin(), qw.end(), [&](const Query& a, const Query& b) -> bool {
            return a.l == b.l ? a.r > b.r : a.l < b.l;
        });
    }

    int procQry(int n, int m, const vi& nums, vector<Query>& qw) {
        priority_queue<pii> pq;
        vi add(n + 1, 0);
        int cur_add = 0;
        unordered_set<int> sel;

        int p = 0;
        for (int i = 0; i < n; i++) {
            cur_add += add[i];

            while (p < m && qw[p].l <= i) {
                int e = qw[p].r;
                int qid = qw[p].idx;
                pq.emplace(e, qid);
                p++;
            }

            while (!pq.empty() && pq.top().first < i) pq.pop();

            int cur_cov = cur_add;

            if (cur_cov < nums[i]) {
                int need = nums[i] - cur_cov;
                
                for (int j = 0; j < need; j++) {
                    if (pq.empty()) return -1;
                    
                    auto top = pq.top();
                    pq.pop();
                    int e = top.first;
                    int qid = top.second;
                    
                    sel.insert(qid);
                    add[i] += 1;
                    
                    if (e + 1 < n) {
                        add[e + 1] -= 1;
                    }
                    cur_add += 1;
                }
            }
        }
        int s= sel.size();
        int ans = m - s;
        return ans;
    }

    int maxRemoval(vi& nums, vvi& q) {
        int n = nums.size(), m = q.size();

        vi cov(n + 1, 0);
        calcCov(cov, q, n);

        if (!chkCov(nums, cov, n)) return -1;

        vector<Query> qw;
        sortQry(qw, q, m);

        return procQry(n, m, nums, qw);
    }
};",1460840067
E22CSEU0119,6E22CSEU0119,499,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int startChar = s[i] - 'a';
            int targetChar = t[i] - 'a';

            if (startChar == targetChar) continue;

            // Compute distances in both directions
            int forwardDistance = (targetChar - startChar + 26) % 26;
            int backwardDistance = (startChar - targetChar + 26) % 26;

            // Compute the cost for each direction
            long long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(startChar + j) % 26];
            }

            long long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(startChar - j + 26) % 26];
            }

            // Choose the minimum cost direction
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460819890
E22CSEU0119,6E22CSEU0119,499,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentMove = 10; 
        bool isAliceTurn = true; 
        
        while (n > 0) {
            if (n < currentMove) {
                return !isAliceTurn;
            }
            n -= currentMove;
            currentMove--; 
            isAliceTurn = !isAliceTurn; // Switch turns
        }
        return !isAliceTurn; 
    }
};
",1460812565
E22CSEU0119,6E22CSEU0119,499,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> calculateCoverage(const vector<int>& nums, const vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> coverage(n + 1, 0);
        for (auto& query : queries) {
            int start = query[0];
            int end = query[1];
            coverage[start]++;
            if (end + 1 < n) {
                coverage[end + 1]--;
            }
        }
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }
        return coverage;
    }

    vector<tuple<int, int, int>> sortQueries(const vector<vector<int>>& queries) {
        int m = queries.size();
        vector<tuple<int, int, int>> sortedQueries;
        sortedQueries.reserve(m);
        for (int i = 0; i < m; i++) {
            sortedQueries.emplace_back(queries[i][0], queries[i][1], i);
        }
        sort(sortedQueries.begin(), sortedQueries.end(), [&](const tuple<int, int, int>& a, const tuple<int, int, int>& b) -> bool {
            if (get<0>(a) == get<0>(b)) {
                return get<1>(a) > get<1>(b); 
            }
            return get<0>(a) < get<0>(b);
        });
        return sortedQueries;
    }

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();

        vector<int> coverage = calculateCoverage(nums, queries);

        for (int i = 0; i < n; i++) {
            if (coverage[i] < nums[i]) {
                return -1;
            }
        }

        vector<tuple<int, int, int>> sortedQueries = sortQueries(queries);

        priority_queue<pair<int, int>> maxHeap;
        vector<int> additionalCoverage(n + 1, 0); 
        unordered_set<int> selectedQueries;
        int extraCoverage = 0, queryIndex = 0;

        for (int i = 0; i < n; i++) {
            extraCoverage += additionalCoverage[i];

            while (queryIndex < m && get<0>(sortedQueries[queryIndex]) <= i) {
                int end = get<1>(sortedQueries[queryIndex]);
                int queryId = get<2>(sortedQueries[queryIndex]);
                maxHeap.emplace(end, queryId);
                queryIndex++;
            }

            while (!maxHeap.empty() && maxHeap.top().first < i) {
                maxHeap.pop();
            }

            int currentCoverage = extraCoverage;
            if (currentCoverage < nums[i]) {
                int deficit = nums[i] - currentCoverage;
                for (int j = 0; j < deficit; j++) {
                    if (maxHeap.empty()) {
                        return -1; 
                    }
                    auto topQuery = maxHeap.top();
                    maxHeap.pop();
                    int selectedEnd = topQuery.first;
                    int queryId = topQuery.second;
                    selectedQueries.insert(queryId);

                    // Update additional coverage
                    additionalCoverage[i]++;
                    if (selectedEnd + 1 < n) {
                        additionalCoverage[selectedEnd + 1]--;
                    }
                    extraCoverage++;
                }
            }
        }

        return m - selectedQueries.size();
    }
};
",1460842207
parallel_stream,parallel_stream,501,3591,java,"class Solution {
  public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
    long[][] dp = new long[26][26];
    for (int i = 0; i < 26; i++) {
      for (int j = 0; j < 26; j++) {
        dp[i][j] = i == j ? 0 : Long.MAX_VALUE;
      }
    }
    for (int k = 0; k < 26; k++) {
      for (int i = 0; i < 26; i++) {
        for (int j = 0; j < 26; j++) {
          if (dp[i][k] == Long.MAX_VALUE || dp[k][j] == Long.MAX_VALUE) {
            continue;
          }
          dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);
        }
      }
    }
    IntStream.range(0, 26).forEach(i -> {
      dp[i][(i + 1) % 26] = Math.min(dp[i][(i + 1) % 26], nextCost[i]);
      dp[i][(i + 25) % 26] = Math.min(dp[i][(i + 25) % 26], previousCost[i]);
    });
    for (int p = 0; p < 26; p++) {
      for (int i = 0; i < 26; i++) {
        for (int j = 0; j < 26; j++) {
          if (dp[i][p] != Long.MAX_VALUE && dp[p][j] != Long.MAX_VALUE) {
            dp[i][j] = Math.min(dp[i][j], dp[i][p] + dp[p][j]);
          }
        }
      }
    }
    return IntStream.range(0, s.length()).mapToLong(i -> dp[s.charAt(i) - 'a'][t.charAt(i) - 'a']).sum();
  }
}",1460816466
parallel_stream,parallel_stream,501,3625,java,"class Solution {
  public boolean canAliceWin(int n) {
    int x = 10;
    while (n >= x) {
      n -= x--;
    }
    return x % 2 == 1;
  }
}",1460796090
parallel_stream,parallel_stream,501,3647,java,"class Solution {
  private static class SegmentTree {
    private final int n;
    private final int[] x;
    private final int[] y;

    SegmentTree(int[] arr) {
      n = arr.length;
      x = new int[4 * n];
      y = new int[4 * n];
      build(arr, 0, n - 1, 1);
    }

    private void build(int[] arr, int l, int r, int k) {
      if (l == r) {
        x[k] = arr[l];
        return;
      }
      int m = (l + r) / 2;
      build(arr, l, m, k * 2);
      build(arr, m + 1, r, k * 2 + 1);
      x[k] = Math.min(x[k * 2], x[k * 2 + 1]);
    }

    private int min(int l, int r, int tl, int tr, int k) {
      if (r < tl || tr < l) {
        return Integer.MAX_VALUE;
      }
      if (l <= tl && tr <= r) {
        return x[k];
      }
      add(k);
      int m = (tl + tr) / 2;
      return Math.min(min(l, r, tl, m, k * 2), min(l, r, m + 1, tr, k * 2 + 1));
    }

    private void upd(int l, int r, int v, int tl, int tr, int k) {
      if (r < tl || tr < l) {
        return;
      }
      if (l <= tl && tr <= r) {
        x[k] += v;
        y[k] += v;
        return;
      }
      add(k);
      int m = (tl + tr) / 2;
      upd(l, r, v, tl, m, k * 2);
      upd(l, r, v, m + 1, tr, k * 2 + 1);
      x[k] = Math.min(x[k * 2], x[k * 2 + 1]);
    }

    private int min(int l, int r) {
      return min(l, r, 0, n - 1, 1);
    }

    private void upd(int l, int r, int v) {
      upd(l, r, v, 0, n - 1, 1);
    }

    private void add(int k) {
      if (y[k] == 0) {
        return;
      }
      x[k * 2] += y[k];
      y[k * 2] += y[k];
      x[k * 2 + 1] += y[k];
      y[k * 2 + 1] += y[k];
      y[k] = 0;
    }
  }

  public int maxRemoval(int[] nums, int[][] queries) {
    int n = nums.length;
    int[] dp = new int[n + 1];
    Arrays.stream(queries).forEach(q -> {
      dp[q[0]]++;
      if (q[1] + 1 < n) {
        dp[q[1] + 1]--;
      }
    });
    IntStream.range(1, n)
        .forEach(i -> dp[i] += dp[i - 1]);
    int[] diffArr = IntStream.range(0, n)
        .map(i -> dp[i] - nums[i])
        .toArray();
    if (Arrays.stream(diffArr).min().getAsInt() < 0) {
      return -1;
    }
    Arrays.sort(queries, Comparator.comparingInt(v -> v[1]));
    SegmentTree tree = new SegmentTree(diffArr);
    int ans = 0;
    for (int[] query : queries) {
      if (tree.min(query[0], query[1]) < 1) {
        continue;
      }
      ans++;
      tree.upd(query[0], query[1], -1);
    }
    return ans;
  }
}",1460840770
davidbyrd,davidbyrd,502,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        for i in range(len(s)):
            ind = ord(s[i]) - 97
            cur1 = 0
            while ind != ord(t[i]) - 97:
                cur1 += nextCost[ind]
                ind = (ind + 1) % 26
            ind = ord(s[i]) - 97
            cur2 = 0
            while ind != ord(t[i]) - 97:
                cur2 += previousCost[ind]
                ind = (ind - 1) % 26
            res += min(cur1, cur2)
        return res",1460814109
davidbyrd,davidbyrd,502,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        alice = True
        while n:
            if n >= cur:
                n -= cur
                cur -= 1
                alice = not alice
            else:
                break
        return True if not alice else False
            ",1460797012
davidbyrd,davidbyrd,502,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        roll = [0] * (len(nums) + 1)
        queries.sort()
        heap = []
        cur = 0
        j = 0
        for i in range(len(nums)):
            cur += roll[i]
            nums[i] += cur
            while j < len(queries) and queries[j][0] <= i:
                heappush(heap, -queries[j][1])
                j += 1
            while nums[i] > 0:
                if not heap:
                    return -1
                end = -heappop(heap)
                if end < i:
                    return -1
                nums[i] -= 1
                cur -= 1
                roll[end + 1] += 1
        return len(heap) - (len(queries) - j)
            
        ",1460841956
Yerzhan Nurtayev,neugis,504,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int M = 26;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == t[i]) continue;
            int x = s[i] - 'a';
            int y = t[i] - 'a';
            int cur = x;
            long long res = 0;
            while (cur != y) {
                res += nextCost[cur];
                cur++;
                cur %= M;
            }
            cur = x;
            long long res2 = 0;
            while (cur != y) {
                res2 += previousCost[cur];
                cur--;
                if (cur < 0) cur = M - 1;
            }
            ans += min(res, res2);
        }
        return ans;
    }
};",1460811271
Yerzhan Nurtayev,neugis,504,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 10;
        int turn = 0;
        while (x > 0) {
            if (n < x) {
                return turn == 1;
            } else {
                n -= x;
            }
            x--;
            turn ^= 1;
        }
        return turn == 1;
    }
};",1460797222
Yerzhan Nurtayev,neugis,504,3647,cpp,"#define ll long long
class Solution {
public:

    struct SegmentTree{
	vector<ll> tree;
	int sz;
 
	void init(int n) {
		sz = 1;
		while (sz < n) sz *= 2;
		tree.assign(2 * sz - 1, 0);
	}
 
	void upd(int i, int v, int x, int lx, int rx) {
		if (rx - lx == 1) {
			tree[x] += v;
			return;
		}
		int m = (lx + rx) / 2;
		if (i < m) upd(i, v, 2 * x + 1, lx, m);
		else upd(i, v, 2 * x + 2, m, rx);
		tree[x] = tree[2 * x + 1] + tree[2 * x + 2]; 
	}
 
	void upd(int i, int v){
		upd(i, v, 0, 0, sz);
	}
 
	ll sum(int l, int r, int x, int lx, int rx) {
		if (lx >= r || rx <= l) return 0;
		if (lx >= l && rx <= r) return tree[x];
		int m = (lx + rx) / 2;
		ll a = sum(l, r, 2 * x + 1, lx, m);
		ll b = sum(l, r, 2 * x + 2, m, rx);
		return a + b;
	}
 
	ll sum(int l, int r){
		return sum(l, r , 0, 0, sz);
	}
}seg;

    const int N = 1e5 + 5;
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> pref(N);
        vector<pair<int, int>> v;
        seg.init(N);
        for (auto q : queries) {
            v.push_back({q[0], q[1]});
        } 
        sort(v.begin(), v.end());
        vector<vector<int>> pos(N);
        for (auto i : v) {
            pos[i.first].push_back(i.second);
        }

        multiset<int> st;
        int ans = 0;
        for (int i = 0; i < n; ++i) {
           for (int x : pos[i]) st.insert(x);
           while (!st.empty() && *st.begin() < i) {
               st.erase(st.begin());
           }
           int val = seg.sum(0, i + 1);
           // cout << val << "" "";
           while (val < nums[i] && !st.empty()) {
               int y = *st.rbegin();
               seg.upd(i, 1);
               seg.upd(y + 1, -1);
               st.erase(--st.end());
               val++;
               ans++;
           } 
           if (val < nums[i]) return -1;
        }
        return (int)queries.size() - ans;
    }
};",1460846924
Only My Railgun,Quar,505,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        next_acc = list(accumulate(nextCost, initial=0))
        prev_acc = list(accumulate(previousCost, initial=0))
        
        @cache        
        def get_next(ia, ib):
            if ib >= ia:
                return next_acc[ib] - next_acc[ia]
            else:
                return next_acc[-1] - next_acc[ia] + next_acc[ib] - next_acc[0]
        
        @cache
        def get_prev(ia, ib):
            if ib < ia:
                return prev_acc[ia + 1] - prev_acc[ib + 1]
            else:
                return prev_acc[ia + 1] - prev_acc[0] + prev_acc[-1] - prev_acc[ib + 1]
        
        ret = 0
        for a, b in zip(s, t):
            ia = ord(a) - ord('a')
            ib = ord(b) - ord('a')
            ret += min(get_next(ia, ib), get_prev(ia, ib))
        
        return ret
            ",1460815291
Only My Railgun,Quar,505,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        n_remove = 10
        is_alice = True
        
        while n >= n_remove:
            n -= n_remove
            n_remove -= 1
            is_alice = not is_alice
        
        return not is_alice

            ",1460797494
Only My Railgun,Quar,505,3647,python3,"from sortedcontainers import SortedList
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        
        queries.sort(key=lambda t: (t[0], -t[1]))
        
        neg_avail_ends = []
        used_ends = SortedList()
        j = 0
        
        for i, x in enumerate(nums):
            while j < len(queries) and queries[j][0] <= i:
                heappush(neg_avail_ends, -queries[j][1])
                j += 1
            existing_minus = len(used_ends) - used_ends.bisect_left(i)
            if existing_minus >= x:
                continue
            delta = x - existing_minus
            if len(neg_avail_ends) < delta:
                return -1
            for _ in range(delta):
                neg_new_end = heappop(neg_avail_ends)
                new_end = -neg_new_end
                if new_end < i:
                    return -1
                used_ends.add(new_end)
        
        return len(queries) - len(used_ends)
",1460847757
being_hooman,being_hooman,506,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.size();i++){
            int targetindex=t[i]-'a';
            int curindex=s[i]-'a';
            long long tempcost=0;
            while(curindex!=targetindex){
                tempcost+=nextCost[curindex];
                curindex=(curindex+1)%26;
            }
            curindex=s[i]-'a';
            long long tempcost2=0;
            while(curindex!=targetindex){
                tempcost2+=previousCost[curindex];
                curindex=((curindex-1)%26+26)%26;
            }
            ans+=min(tempcost, tempcost2);
        }
        return ans;
    }
};",1460825523
being_hooman,being_hooman,506,3625,cpp,"class Solution {
public:
    bool calcans(bool turn){
        if(turn){
            return false;
        }
        return true;
    }
    bool canAliceWin(int n) {
        bool turn=true;
        int count=10;
        while(true){
            if(n<count){
                return !turn;
            }
            n-=count;
            count--;
            turn=!turn;
        }
        return false;
    }
};",1460807103
being_hooman,being_hooman,506,3647,cpp,"class Solution {
public:
    vector<int> adj[100005];
    int prefix[100005];
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        memset(prefix, 0, sizeof(prefix));
        for(auto it: queries){
            adj[it[0]].push_back(it[1]);
        }
        multiset<int>ms;
        int ans=0;
        for(int i=0;i<nums.size();i++){
            for(auto it: adj[i]) ms.insert(it);
            while(ms.size() && *ms.begin()<i) ms.erase(ms.begin());
            if(i-1>=0) prefix[i]+=prefix[i-1];
            while(ms.size() && nums[i]>prefix[i]){
                prefix[i]++;
                prefix[*--ms.end()+1]--;
                ms.erase(--ms.end());
                ans++;
            }
            if(nums[i]>prefix[i]) return -1;
        }
        int n=queries.size();
        return n-ans;
    }
};",1460856071
Whusyki,Whusyki,508,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0L;
        for (int i = 0; i < s.length(); i++){
            int a = s.charAt(i) - 'a';
            int b = t.charAt(i) - 'a';
            if (a != b){
                ans += shift(a, b, nextCost, previousCost);
            }
        }
        return ans;
    }
    private long shift(int s, int t, int[] next, int[] prev){
        int st = s;
        long cst = 0L;
        while (st != t){
            cst += (long) prev[st];
            st--;
            st = (st + 26 ) % 26;
        }
        long dst = 0L;
        st = s;
        while (st != t){
            dst += (long) next[st];
            st++;
            st %= 26;
        }
        return Math.min(cst, dst);
    }
}",1460818814
Whusyki,Whusyki,508,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean Alice = false;
        int d = 10;
        while (n >= d){
            Alice = !Alice;
            n -= d;
            d--;
        }
        return Alice;
    }
}",1460798190
Whusyki,Whusyki,508,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        PriorityQueue<int[]> valid = new PriorityQueue<>((a, b) -> b[1] - a[1]);
        int keep = 0;
        int idx = 0;
        for (int i = 0; i < nums.length; i++){
            while (!minHeap.isEmpty() && minHeap.peek() < i){
                minHeap.poll();
            }
            while (idx < queries.length && queries[idx][0] <= i){
                valid.add(queries[idx]);
                idx++;
            }
            while (minHeap.size() < nums[i] && !valid.isEmpty() && valid.peek()[0] <= i){
                if (valid.peek()[1] >= i){
                    minHeap.add(valid.peek()[1]);
                    keep++;
                }
                valid.poll();
            }
            if (minHeap.size() < nums[i]){
                return -1;
            }
        }
        return queries.length - keep;
    }
}
/*

[0,3,2]
[[2,2],[1,1],[0,2],[1,1],[0,2]]

2

*/",1460850792
rohinth076,rohinth076,509,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[][] cost = new long[26][26];
        for(int i=0;i<26;i++){
            for(int j=0;j<26;j++){
                long nc = 0,pc = 0;
                for(int ii=i; ii != j; ii = (ii+1)%26){
                    nc += nextCost[ii];
                }
                for(int ii=i; ii != j; ii = (26+(ii-1))%26){
                    pc += previousCost[ii];
                }
                cost[i][j] = Math.min(nc,pc);
            }
        }
        long ans = 0;
        int n = s.length();
        for(int i=0;i<n;i++){
            int in = s.charAt(i) - 'a',jn = t.charAt(i) - 'a';
            ans += cost[in][jn];
        }
        return ans;
    }
}",1460808199
rohinth076,rohinth076,509,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int val = 10;
        int count = 0;
        while(val <= n){
            n -= val;
            val--;
            count++;
        }
        return count%2 == 1;
    }
}",1460796391
rohinth076,rohinth076,509,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries,(i,j)->{
            if(i[0] == j[0])return Integer.compare(j[1],i[1]);
            return Integer.compare(i[0],j[0]);
        });
        TreeSet<int[]> notUsed  = new TreeSet<>((i,j)->{
            if(i[0] == j[0])return Integer.compare(i[1],j[1]);
            return Integer.compare(j[0],i[0]);
        });
        long val = 0;
        int n = nums.length;
        int q = queries.length;
        int ans = 0;
        int[] flag = new int[n];
        for(int i=0,j=0;i<n;i++){
            TreeSet<int[]> used  = new TreeSet<>((ii,jj)->{
                if(ii[0] == jj[0])return Integer.compare(ii[1],jj[1]);
                return Integer.compare(jj[0],ii[0]);
            });
            while(j < q && queries[j][0] == i){
                if(val < nums[i]){
                   val++;
                   used.add(new int[]{queries[j][1],j});
                }else{
                   notUsed.add(new int[]{queries[j][1],j});  
                }
                j++;
            }
            while(val < nums[i] && !notUsed.isEmpty()){
                int[] x = notUsed.pollFirst();
                if(x[0] < i){
                    ans++;
                }else{
                    val++;
                    flag[x[0]]++;
                }
            }
            if(val < nums[i]){
                //System.out.println(i+"" "" +val+"" ""+nums[i]);
                return -1;
            }
            while(!used.isEmpty() && !notUsed.isEmpty()){
                int[] x = used.pollLast(), y = notUsed.pollFirst();
                if(x[0] < y[0]){
                    used.add(y);
                    notUsed.add(x);
                }else{
                    used.add(x);
                    notUsed.add(y);
                    break;
                }
            }
                
            for(int[] x:used){
                flag[x[0]]++;
            }
            
            val -= flag[i];
        }
        ans += notUsed.size();
        return ans;
    }
}",1460846951
Rad0miR,Rad0miR,510,3591,csharp,"public class Solution {
    public long ShiftDistance(string s, string t, int[] nextCost, int[] previousCost) 
    {
        long[,] cost = new long[26, 26];

        for (int i = 0; i < 26; ++i) 
        {
            for (int j = 0; j < 26; ++j) 
            {
                if (i == j) continue;
                cost[i, j] = 100_000_000_000;
            }
        }
        
        for (int i = 0; i < 26; ++i) 
        {
            cost[i, (i - 1 + 26) % 26] = previousCost[i];
            cost[i, (i + 1 + 26) % 26] = nextCost[i];
        }

        for (int k = 0; k < 26; ++k) 
        {
            for (int i = 0; i < 26; ++i) 
            {
                for (int j = 0; j < 26; ++j) 
                {
                    cost[i, j] = Math.Min(cost[i, j], cost[i, k] + cost[k, j]);
                }
            }
        }

        return s.Zip(t).Sum(p => cost[p.First - 'a', p.Second - 'a']);
    }
}

//48",1460852367
Rad0miR,Rad0miR,510,3625,csharp,"public class Solution {
    public bool CanAliceWin(int n) {
        int cnt = 0, cur = 10;
        while (n >= cur) 
        {
            n -= cur;
            cur--;
            ++cnt;
        }
        return cnt % 2 != 0;
    }
}",1460855456
Rad0miR,Rad0miR,510,3647,csharp,"public class Solution {
    public int MaxRemoval(int[] nums, int[][] queries) 
    {
        Dictionary<int, int> imp = new();
        
        Dictionary<int, List<int>> 
            q = queries
                .GroupBy(qu => qu[0])
                .ToDictionary(g => g.Key, g => g.Select(qu => qu[1]).ToList());
        
        int imp_cnt = 0, id = 0;
        SortedSet<(int e, int id)> h = new();

        
        
        int cnt = 0;
        
        for (int i = 0; i < nums.Length; ++i) 
        {
            if (q.TryGetValue(i, out var list)) 
            {
                foreach (int end in list) 
                {
                    h.Add((end, ++id));
                }
            }

            if (imp_cnt + h.Count < nums[i]) return -1;

            while (imp_cnt < nums[i]) 
            {
                var max = h.Max;
                h.Remove(max);

                imp_cnt++;
                imp.TryAdd(max.e, 0);
                imp[max.e]++;
            }

            if (imp.ContainsKey(i)) 
            {
                imp_cnt -= imp[i];
                imp.Remove(i);
            }

            while (h.Count > 0 && h.Min.e == i) {
                h.Remove(h.Min);
                ++cnt;
            }
        }

        return cnt;
    }
}",1460841482
Gajendra Sahu,gajmain2020,512,3591,javascript,"/**
 * @param {string} s
 * @param {string} t
 * @param {number[]} nextCost
 * @param {number[]} previousCost
 * @return {number}
 */
var shiftDistance = function(s, t, nextCost, previousCost) {
    let totalCost = 0;

    for (let i = 0; i < s.length; i++) {
        const start = s.charCodeAt(i) - 97;
        const end = t.charCodeAt(i) - 97;

        const forwardSteps = (end - start + 26) % 26;
        const backwardSteps = (start - end + 26) % 26;

        let forwardCost = 0, backwardCost = 0;

        // Calculate the cost of forward shifts
        for (let step = 0; step < forwardSteps; step++) {
            forwardCost += nextCost[(start + step) % 26];
        }

        // Calculate the cost of backward shifts
        for (let step = 0; step < backwardSteps; step++) {
            backwardCost += previousCost[(start - step + 26) % 26];
        }

        // Add the minimum cost for this character
        totalCost += Math.min(forwardCost, backwardCost);
    }

    return totalCost;
};",1460810868
Gajendra Sahu,gajmain2020,512,3625,javascript,"/**
 * @param {number} n
 * @return {boolean}
 */
var canAliceWin = function(n) {
    let currentTurn = 10, isAliceTurn = true;
    while (n > 0) {
        if (n < currentTurn) return !isAliceTurn;
        n -= currentTurn--;
        isAliceTurn = !isAliceTurn;
    }
    return !isAliceTurn;

};",1460806810
Gajendra Sahu,gajmain2020,512,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& arr, vector<vector<int>>& req) {
        int lanka = arr.size(), qcnt = req.size();
        vector<int> cvgr(lanka + 1, 0);

        for (auto q : req) {
            cvgr[q[0]]++, (q[1] + 1 < lanka) && (cvgr[q[1] + 1]--);
        }

        for (int i = 1; i < lanka; i++) cvgr[i] += cvgr[i - 1];

        for (int i = 0; i < lanka; i++) if (cvgr[i] < arr[i]) return -1;

        vector<tuple<int, int, int>> srq(qcnt);
        for (int i = 0; i < qcnt; i++) srq[i] = {req[i][0], req[i][1], i};

        sort(srq.begin(), srq.end(), [](auto& a, auto& b) {
            return get<0>(a) == get<0>(b) ? get<1>(a) > get<1>(b) : get<0>(a) < get<0>(b);
        });

        priority_queue<pair<int, int>> pq;
        vector<int> de(lanka + 1, 0);
        int aa = 0, z = 0;
        unordered_set<int> slq;

        for (int i = 0; i < lanka; i++) {
            aa += de[i];

            while (z < qcnt && get<0>(srq[z]) <= i) {
                pq.emplace(get<1>(srq[z]), get<2>(srq[z]));
                z++;
            }

            while (!pq.empty() && pq.top().first < i) pq.pop();

            if (aa < arr[i]) {
                for (int need = arr[i] - aa; need--; ) {
                    if (pq.empty()) return -1;
                    auto top = pq.top(); pq.pop();
                    slq.insert(top.second);
                    de[i]++, (top.first + 1 < lanka) && (de[top.first + 1]--);
                    aa++;
                }
            }
        }

        return qcnt - slq.size();
    }
};",1460857110
Aravind Tellapelli,fRDtrK9o7E,513,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long c = 0;
        for (int i = 0; i < n; i++) {
            int f = s.charAt(i) - 'a';
            int tC = t.charAt(i) - 'a';
            int fd = (tC - f + 26) % 26;
            int bd = (f - tC + 26) % 26;
            long fc = 0;
            for (int j = 0; j < fd; j++) {
                fc += nextCost[(f + j) % 26];
            }
            long bc = 0;
            for (int j = 0; j < bd; j++) {
                bc += previousCost[(f - j + 26) % 26];
            }
            c += Math.min(fc, bc);
        }
        
        return c;
    }
}",1460827917
Aravind Tellapelli,fRDtrK9o7E,513,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
         if (n < 10) {
            return false;
        }
        n -= 10;
        int s = 9;
        boolean is = false;
        while (n >= s) {
            n -= s; 
            s--;   
            is= !is; 
        }
        return !is;
    }
}",1460809742
Aravind Tellapelli,fRDtrK9o7E,513,3647,python3,"from typing import List

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        cv = [0] * (n + 1)
        
        for q in queries:
            l, r = q[0], q[1]
            cv[l] += 1
            if r + 1 < n:
                cv[r + 1] -= 1
        
        for i in range(1, n):
            cv[i] += cv[i - 1]
        
        cv.pop()
        
        al = [0] * n
        for i in range(n):
            al[i] = cv[i] - nums[i]
            if al[i] < 0:
                return -1
        
        sq = sorted(queries, key=lambda q: (q[1] - q[0] + 1, q[0]))
        
        class SegmentTree:
            def __init__(self, size):
                self.n = size
                self.tr = [0] * (4 * size)
                self.lz = [0] * (4 * size)
            
            def push(self, node, l, r):
                if self.lz[node] != 0:
                    self.tr[node] += self.lz[node]
                    if l != r:
                        self.lz[node * 2] += self.lz[node]
                        self.lz[node * 2 + 1] += self.lz[node]
                    self.lz[node] = 0
            
            def build(self, ar, node, l, r):
                self.push(node, l, r)
                if l == r:
                    self.tr[node] = ar[l]
                else:
                    mid = (l + r) // 2
                    self.build(ar, node * 2, l, mid)
                    self.build(ar, node * 2 + 1, mid + 1, r)
                    self.tr[node] = min(self.tr[node * 2], self.tr[node * 2 + 1])
            
            def query(self, node, l, r, ql, qr):
                self.push(node, l, r)
                if qr < l or ql > r:
                    return float('inf')
                if ql <= l and r <= qr:
                    return self.tr[node]
                mid = (l + r) // 2
                return min(
                    self.query(node * 2, l, mid, ql, qr),
                    self.query(node * 2 + 1, mid + 1, r, ql, qr)
                )
            
            def update(self, node, l, r, ql, qr):
                self.push(node, l, r)
                if qr < l or ql > r:
                    return
                if ql <= l and r <= qr:
                    self.lz[node] -= 1
                    self.push(node, l, r)
                    return
                mid = (l + r) // 2
                self.update(node * 2, l, mid, ql, qr)
                self.update(node * 2 + 1, mid + 1, r, ql, qr)
                self.tr[node] = min(self.tr[node * 2], self.tr[node * 2 + 1])
        
        st = SegmentTree(n)
        st.build(al, 1, 0, n - 1)
        
        rm = 0
        for l, r in sq:
            mn = st.query(1, 0, n - 1, l, r)
            if mn >= 1:
                st.update(1, 0, n - 1, l, r)
                rm += 1
        
        return rm
",1460866680
aknov711,aknov711,514,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        vector<long long> p1(26, 0);
        vector<long long> p2(26, 0);

        for(int i=0;i<26;i++){
            p1[i] = nextCost[i];
            p2[i] = previousCost[i];
            if(i>0){
                p1[i]+=p1[i-1];
                p2[i]+=p2[i-1];
            }
        }
        for(int i=0;i<n;i++){
            int a = (int)(s[i]-'a');
            int b = (int)(t[i]-'a');
            if(a<b){
                long long op1= ( b > 0 ? p1[b-1] : 0LL) - (a > 0 ? p1[a-1] : 0LL);
                long long op2 = p2[a] + p2[25]-p2[b];
              //  cout<<op1<<"" ""<<op2<<endl;
                ans += min(op1, op2);
            } else if(a>b){
                 long long op1= p1[25]- (a > 0 ? p1[a-1] : 0LL) + ( b > 0 ? p1[b-1] :0LL);
                long long op2 = p2[a]-p2[b];
               // cout<<op1<<"" ""<<op2<<endl;
                ans += min(op1, op2);
            }
        }
        return ans;
    }
};",1460840542
aknov711,aknov711,514,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int ans = 1 ;
        if(n < 10)
            return false;
        n -= 10;
        int last = 10;
        while(n >= last - 1){
            n -= (last-1);
            last--;
            ans ^= 1;
        }
        return ans==1;
    }
};",1460802871
aknov711,aknov711,514,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int ans = 0;
        int n = nums.size();
        set<int> to_add[n], to_remove[n]; 
        int i=0;
        for(auto e : queries){
            int l = e[0];
            int r = e[1];
            to_add[l].insert(i);
            to_remove[r].insert(i);
            i++;
        }

        set<int>active;
        set<pair<int,int>> candi;
        
        for(i=0;i<n;i++){
            int must = nums[i];
            
            for(auto e : to_add[i])
                candi.insert(make_pair(queries[e][1], e));
            
            while(active.size() < must){
                if(candi.empty())
                    return -1;
                pair<int, int> p = *candi.rbegin();
                int r = p.first;
                int id = p.second;
                if( r < i)
                    return -1;
                ans++;
                candi.erase(p);
                active.insert(id);
            }

            for(auto e : to_remove[i]){
                if(active.find(e) != active.end())
                    active.erase(e);
            }
        }
        return (int)queries.size() - ans;
    }
};",1460867044
Vinayak Singh,E22CSEU0286,515,3591,swift,"class Solution {
    func shiftDistance(_ s: String, _ t: String, _ nextCost: [Int], _ previousCost: [Int]) -> Int {
        
        func getMinCost(_ src: Character, _ dst: Character) -> Int {
            // Convert characters to their positions (0-25)
            let srcPos = Int(src.asciiValue! - Character(""a"").asciiValue!)
            let dstPos = Int(dst.asciiValue! - Character(""a"").asciiValue!)
            
            // Calculate forward and backward distances
            let forwardSteps = (dstPos - srcPos + 26) % 26
            let backwardSteps = (srcPos - dstPos + 26) % 26
            
            // Calculate forward cost
            var forwardCost = 0
            var currPos = srcPos
            for _ in 0..<forwardSteps {
                forwardCost += nextCost[currPos]
                currPos = (currPos + 1) % 26
            }
            
            // Calculate backward cost
            var backwardCost = 0
            currPos = srcPos
            for _ in 0..<backwardSteps {
                backwardCost += previousCost[currPos]
                currPos = (currPos - 1 + 26) % 26
            }
            
            // Return the minimum of forward and backward costs
            return min(forwardCost, backwardCost)
        }
        
        // Calculate total minimum cost for all character transformations
        var totalCost = 0
        let sArray = Array(s)
        let tArray = Array(t)
        for (srcChar, dstChar) in zip(sArray, tArray) {
            if srcChar != dstChar {
                totalCost += getMinCost(srcChar, dstChar)
            }
        }
        
        return totalCost
    }
}

// Test cases
func testSolution() {
    let sol = Solution()
    
    // Test case 1
    let s1 = ""abab""
    let t1 = ""baba""
    let nextCost1 = [100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    let previousCost1 = [1,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    assert(sol.shiftDistance(s1, t1, nextCost1, previousCost1) == 2)
    
    // Test case 2
    let s2 = ""leet""
    let t2 = ""code""
    let nextCost2 = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    let previousCost2 = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    assert(sol.shiftDistance(s2, t2, nextCost2, previousCost2) == 31)
    
    print(""All test cases passed!"")
}

testSolution()
",1460856568
Vinayak Singh,E22CSEU0286,515,3625,swift,"class Solution {
    func canAliceWin(_ n: Int) -> Bool {
        // If n is less than 10, Alice can't make her first move
        if n < 10 {
            return false
        }
        
        // Simulate the game
        var stones = n
        var turn = 0 // 0 for Alice, 1 for Bob
        var stonesToRemove = 10
        
        while stones >= stonesToRemove {
            // Remove stones
            stones -= stonesToRemove
            
            // Switch turns and update stones to remove
            turn = 1 - turn
            stonesToRemove -= 1
            
            // If stonesToRemove becomes 0, no more valid moves
            if stonesToRemove == 0 {
                return turn == 1 // If it's Bob's turn, Alice won
            }
        }
        
        // If we can't remove required stones, current player loses
        return turn == 1 // If it's Bob's turn, Alice won
    }
}

func simulateGame(_ n: Int) {
    var stones = n
    var turn = 0 // 0 for Alice, 1 for Bob
    var stonesToRemove = 10
    
    if n < 10 {
        print(""Game with \(n) stones:"")
        print(""Alice can't remove 10 stones from \(n), so Alice loses"")
        return
    }
    
    print(""Game with \(n) stones:"")
    while stones >= stonesToRemove {
        let player = turn == 0 ? ""Alice"" : ""Bob""
        print(""\(player) removes \(stonesToRemove) stones from \(stones), leaving \(stones - stonesToRemove)"")
        stones -= stonesToRemove
        turn = 1 - turn
        stonesToRemove -= 1
    }
    
    let player = turn == 0 ? ""Alice"" : ""Bob""
    print(""\(player) can't remove \(stonesToRemove) stones from \(stones), so \(player) loses"")
}

// Test cases
func testSolution() {
    let sol = Solution()
    
    // Test case 1
    assert(sol.canAliceWin(12) == true)
    simulateGame(12)
    print()
    
    // Test case 2
    assert(sol.canAliceWin(1) == false)
    simulateGame(1)
    print()
    
    // Additional test cases
    assert(sol.canAliceWin(10) == true) // Alice removes all stones
    simulateGame(10)
    print()
    
    assert(sol.canAliceWin(20) == false) // Alice loses
    simulateGame(20)
    print()
    
    assert(sol.canAliceWin(9) == false) // Alice can't make first move
    simulateGame(9)
    
    print(""All test cases passed!"")
}

testSolution()
",1460831671
Vinayak Singh,E22CSEU0286,515,3647,swift,"class Solution {
    func maxRemoval(_ nums: [Int], _ queries: [[Int]]) -> Int {
        let n = nums.count
        let m = queries.count
        
        // Step 1: Calculate coverage for each index using difference array
        var coverage = [Int](repeating: 0, count: n + 1)
        for query in queries {
            let l = query[0]
            let r = query[1]
            coverage[l] += 1
            if r + 1 < n {
                coverage[r + 1] -= 1
            }
        }
        
        // Prefix sum to get actual coverage
        for i in 1..<n {
            coverage[i] += coverage[i - 1]
        }
        coverage.removeLast() // Remove the extra element
        
        // Step 2: Compute allowed removals (coverage - nums)
        var allowed = [Int](repeating: 0, count: n)
        for i in 0..<n {
            allowed[i] = coverage[i] - nums[i]
            if allowed[i] < 0 {
                // Not possible to convert to zero array
                return -1
            }
        }
        
        // Step 3: Sort queries by increasing range size
        var sortedQueries = queries.map { ($0[0], $0[1]) }
        sortedQueries.sort { a, b in
            let lenA = a.1 - a.0 + 1
            let lenB = b.1 - b.0 + 1
            if lenA != lenB {
                return lenA < lenB // Smaller ranges first
            }
            return a.0 < b.0 // If same length, sort by starting index
        }
        
        // Step 4: Initialize the Segment Tree with 'allowed' array
        let segmentTree = SegmentTree(n)
        segmentTree.build(allowed, 1, 0, n - 1)
        
        // Step 5: Iterate through each sorted query and attempt to remove it
        var removed = 0
        for (l, r) in sortedQueries {
            // Query the minimum allowed in the range [l, r]
            let currentMin = segmentTree.queryMin(1, 0, n - 1, l, r)
            if currentMin >= 1 {
                // It's safe to remove this query
                segmentTree.decrementRange(1, 0, n - 1, l, r)
                removed += 1
            }
        }
        
        return removed
    }
}

// Segment Tree structure
class SegmentTree {
    private var n: Int
    private var tree: [Int]
    private var lazy: [Int]
    
    init(_ size: Int) {
        n = size
        tree = [Int](repeating: 0, count: 4 * n)
        lazy = [Int](repeating: 0, count: 4 * n)
    }
    
    private func pushDown(_ node: Int, _ l: Int, _ r: Int) {
        if lazy[node] != 0 {
            tree[node] += lazy[node]
            if l != r { // Not a leaf node
                lazy[2 * node] += lazy[node]
                lazy[2 * node + 1] += lazy[node]
            }
            lazy[node] = 0
        }
    }
    
    func build(_ allowed: [Int], _ node: Int, _ l: Int, _ r: Int) {
        pushDown(node, l, r)
        if l == r {
            tree[node] = allowed[l]
        } else {
            let mid = l + (r - l) / 2
            build(allowed, 2 * node, l, mid)
            build(allowed, 2 * node + 1, mid + 1, r)
            tree[node] = min(tree[2 * node], tree[2 * node + 1])
        }
    }
    
    func queryMin(_ node: Int, _ l: Int, _ r: Int, _ ql: Int, _ qr: Int) -> Int {
        pushDown(node, l, r)
        if qr < l || ql > r {
            return Int.max
        }
        if ql <= l && r <= qr {
            return tree[node]
        }
        let mid = l + (r - l) / 2
        return min(queryMin(2 * node, l, mid, ql, qr), queryMin(2 * node + 1, mid + 1, r, ql, qr))
    }
    
    func decrementRange(_ node: Int, _ l: Int, _ r: Int, _ ql: Int, _ qr: Int) {
        pushDown(node, l, r)
        if qr < l || ql > r {
            return
        }
        if ql <= l && r <= qr {
            lazy[node] -= 1
            pushDown(node, l, r)
            return
        }
        let mid = l + (r - l) / 2
        decrementRange(2 * node, l, mid, ql, qr)
        decrementRange(2 * node + 1, mid + 1, r, ql, qr)
        tree[node] = min(tree[2 * node], tree[2 * node + 1])
    }
}
",1460867303
AnimeshTalukdar,AnimeshTalukdar,516,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        for i in range(1,len(nextCost)):
            nextCost[i] += nextCost[i-1]
            previousCost[i] += previousCost[i-1]
        nextCost.append(0)
        previousCost.append(0)
        c = 0
        for i in range(len(s)):
            if s[i] != t[i]:
                st = ord(s[i]) - ord('a') 
                tt = ord(t[i])- ord('a')
                if tt > st:
                    c1 = nextCost[tt-1] - nextCost[st-1]
                    c2 = previousCost[-2] - previousCost[tt] + previousCost[st]
                    # print(c1,c2,s[i],t[i])
                    c += min(c1,c2)
                else:
                    c1 = previousCost[st] - previousCost[tt]
                    c2 = nextCost[-2] - nextCost[st-1] + nextCost[tt-1]
                    
                    # print(c1,c2,s[i],t[i])
                    c += min(c1,c2)
                print(c)
        return c",1460867209
AnimeshTalukdar,AnimeshTalukdar,516,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 0
        x = 10
        while n:
            if n < x or x == 0:
                return cur%2 ==1
            n-= x
            x-= 1
            cur += 1
        return cur  %2 == 1
        ",1460867476
AnimeshTalukdar,AnimeshTalukdar,516,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        f = 0
        h = []
        cur = []
        for i in range(len(nums)):
            while f < len(queries) and queries[f][0] <= i:
                heapq.heappush(h,-queries[f][1])
                f+=1
            while cur and cur[0] < i:
                heapq.heappop(cur)
            while len(cur) <  nums[i]:
                while len(cur) < nums[i] and h and -h[0] >= i:
                    heapq.heappush(cur,-heapq.heappop(h))
                if len(cur) < nums[i]:
                    return -1
        return len(h)
                
        ",1460867095
yash_karakoti,yash_karakoti,517,3591,cpp,"#define ll long long 
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        auto fcost = [&] (char a, char b) {
            ll x = a - 'a';
            ll y = b - 'a';
            ll cst = 0;
            for(ll i = x; (i % 26) != y; i++) {
                ll z = i % 26;
                cst += nextCost[z];
            }
            return cst;
        };
        auto bcost = [&] (char a, char b) {
            ll x = a - 'a';
            ll y = b - 'a';
            ll cst = 0;
            for(ll i = x; ((i + 26) % 26) != y; i--) {
                ll z = (i + 26) % 26;
                cst += previousCost[z];
            }
            return cst;
        };
        ll ans = 0;
        for(ll i = 0; i < s.length(); i++) {
            ans += min(fcost(s[i],t[i]), bcost(s[i], t[i])); 
        }
        return ans;
    }
};",1460818330
yash_karakoti,yash_karakoti,517,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 0;
        int a = 10;
        while(n >= a) {
            n -= a;
            cnt++;
            a--;
        }
        if(cnt % 2 != 0) return true;
        return false;
    }
};",1460798578
yash_karakoti,yash_karakoti,517,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& v, vector<vector<int>>& q) {
        map<int, vector<int>> mp;
        for(int i = 0; i < q.size(); i++) {
            mp[q[i][0]].push_back(q[i][1]); 
        }
        multiset<int> s;
        vector<int> mark(v.size() + 2, 0);
        int dec = 0;
        for(int i = 0; i < v.size(); i++) {
            for(auto &j : mp[i]) {
                s.insert(j);
            }
            dec -= mark[i];
            v[i] -= dec;
            while(v[i] > 0) {
                if(s.size() == 0 || *(--s.end()) < i) return -1;
                int z = *(--s.end());
                s.erase(--s.end());
                dec++;
                v[i]--;
                mark[z + 1]++;
            } 
        }
        return s.size();
    }
};",1460854622
Pritish Priyatosh Nayak,pritishn,520,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long  totalCost = 0;
        for(int i=0;i<s.length();i++){
            int c1 = s[i] - 'a';
            int c2 = t[i] - 'a';
            
            long long fwdCost = 0;
            long long  bwdCost = 0;
            
            int ptr=c1;
            while(ptr != c2) {
                fwdCost+=nextCost[ptr];
                ptr++;
                ptr%=26;
            }
            ptr=c1;
            while(ptr!=c2){
                bwdCost+=previousCost[ptr];
                ptr--;
                ptr=(ptr+26)%26;
            }
            totalCost += min(fwdCost, bwdCost);
        }
        return totalCost;
    }
};",1460812118
Pritish Priyatosh Nayak,pritishn,520,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0;
        int rem = n;
        int take = 10;
        while(true) {
            if (rem < take) {
                return (turn==0)?false:true;
            }
            rem-=take;
            take--;
            turn ^=1;
        }
        return false;
    }
};",1460799717
Pritish Priyatosh Nayak,pritishn,520,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        
        map<int,vector<pair<int,int>>> mpp;
        for(vector<int> q:queries) {
            mpp[q[0]].push_back({q[0], q[1]});
        }
        priority_queue<pair<int,int>> best;
        int coveredTill = -1;
        int required = 0;
        vector<int> diffArray(n+1);
        
        cout<<endl<<endl;
        for(int i=0, maxDelta=0;i<n;i++){
            maxDelta+=diffArray[i];
            
            for(pair<int,int> q:mpp[i]) {
                best.push({q.second, q.first});
            }
            // cout<<""index "" <<i<<"" delta=""<<maxDelta<<"" element=""<<nums[i]<<endl;
            if (nums[i] > maxDelta) {
                while(best.size() > 0 && nums[i] > maxDelta) {
                    pair<int,int> nextBestRange = {best.top().second,best.top().first};
                    best.pop();
                    if (nextBestRange.second < i) {
                        // cout<<""discarding range "" <<nextBestRange.first<<"",""<<nextBestRange.second<<endl;
                        continue;
                    }
                    diffArray[nextBestRange.second+1]-=1;
                    maxDelta+=1;
                    // cout<<""need range=""<<nextBestRange.first<<"",""<<nextBestRange.second<<endl;
                    required++;
                }
                // cout<<""new delta"" << maxDelta<<"" nums[i]=""<<nums[i]<<"" required=""<<required<<endl;
                if (nums[i] > maxDelta) {
                    // cout<<""here"";
                    return -1;
                }
            } 
        }
        return queries.size()-required;
    }
};",1460856613
Arjun Grover,Code-O-Maniac,521,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0, n = s.size();
        
        for(int i = 0; i < n; i++) {
            long long op1 = 0;
            long long op2 = 0;
            
            for(int k = 1, j = s[i] - 'a'; j != (t[i] - 'a'); k++) {
                op1 += nextCost[j];
                j = (j + 1) % 26;
            }
            
            for(int k = 1, j = s[i] - 'a'; j != (t[i] - 'a'); k++) {
                op2 += previousCost[j];
                j = (j - 1 + 26) % 26;
            }
            
            ans += min(op1, op2);
        }
        
        return ans;
    }
};",1460827850
Arjun Grover,Code-O-Maniac,521,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int t = 0, i = 10;
        while(n >= i) {
            n -= i--;
            t ^= 1;
        }
        
        return t;
    }
};",1460800751
Arjun Grover,Code-O-Maniac,521,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        
        priority_queue<int> left;
        priority_queue<int, vector<int>, greater<int>> used;
        for(int i = 0, j = 0, size = queries.size(); i < nums.size(); i++) {
            while(j < size && queries[j][0] == i) {
                left.push(queries[j++][1]);
            }
            
            while(!used.empty() && used.top() < i) {
                used.pop();
            }
            
            int needed = max(nums[i] - (int)used.size(), 0);
            while(needed && !left.empty() && left.top() >= i) {
                int topmost = left.top();
                left.pop();
                
                used.push(topmost);
                needed -= 1;
            }
            
            if(needed > 0)
                return -1;
        }
        
        return (int)left.size();
    }
};",1460863435
Nelson,Nelson84,525,3591,cpp,"using LL = long long;
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        LL min_cost = 0;
        for(int i=0; i<n; i++){
            int cur = s[i]-'a';
            int target = t[i]-'a';

            LL next_cost = 0;
            int temp = cur;
            while(temp!=target){
                next_cost += nextCost[temp];
                temp = (temp+1)%26;
            }

            LL prev_cost = 0;
            temp = cur;
            while(temp!=target){
                prev_cost += previousCost[temp];
                temp = (temp-1+26)%26;
            }

            min_cost += min(next_cost, prev_cost);
        }
        return min_cost;
    }
};",1460816023
Nelson,Nelson84,525,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove_stones = 10;
        int round = 1;
        while(remove_stones>0 && n>=remove_stones){
            round *= -1;
            n -= remove_stones;
            remove_stones--;
        }
        if(round==1) return false;
        
        return true;
    }
};",1460801701
Nelson,Nelson84,525,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        unordered_map<int, vector<int>> left_to_rights;
        for(auto& query: queries){
            int l = query[0];
            int r = query[1];
            left_to_rights[l].push_back(r);
        }
        for(auto& [left, rights]: left_to_rights) sort(rights.begin(), rights.end());
        
        int n = nums.size();
        vector<int> diff(n, 0);
        priority_queue<int> pq;
        for(int i=0; i<n; i++){
            if(i>0) diff[i] += diff[i-1];
            int need = nums[i] - diff[i];

            for(auto& r: left_to_rights[i]) pq.push(r);
            while(need>0){
                if(pq.empty() || pq.top()<i) return -1;

                int r = pq.top(); pq.pop();
                diff[i]++;
                if(r+1<n) diff[r+1]--;
                need--;
            }
        }
        return pq.size();
    }
};",1460858668
Avinash Rajavarapu,kZS3d4UL2K,527,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        def get_cost(from_char: str, to_char: str) -> int:
            start = ord(from_char) - ord('a')
            end = ord(to_char) - ord('a')

            forward_dist = (end - start) if end >= start else (end - start + 26)
            backward_dist = (start - end) if start >= end else (start - end + 26)

            forward_cost = 0
            curr_pos = start
            for _ in range(forward_dist):
                forward_cost += nextCost[curr_pos]
                curr_pos = (curr_pos + 1) % 26

            backward_cost = 0
            curr_pos = start
            for _ in range(backward_dist):
                backward_cost += previousCost[curr_pos]
                curr_pos = (curr_pos - 1) % 26

            return min(forward_cost, backward_cost)

        total_cost = 0
        for i in range(len(s)):
            if s[i] != t[i]:
                total_cost += get_cost(s[i], t[i])

        return total_cost",1460810825
Avinash Rajavarapu,kZS3d4UL2K,527,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        
        stones = n
        stones_to_remove = 10
        a = True

        while stones >= stones_to_remove:
            stones -= stones_to_remove
            stones_to_remove -= 1
            a = False if a else True
            if stones < stones_to_remove:
                return True if not a else False
            
        return True",1460808189
Avinash Rajavarapu,kZS3d4UL2K,527,3647,python3,"from heapq import heappush, heappop
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        c, m, a, u, h, p, x = [0] * (len(nums) + 1), len(queries), [0] * (len(nums) + 1), set(), [], 0, 0
        for l, r in queries:
            c[l] += 1
            if r + 1 < len(nums): c[r + 1] -= 1
        for i in range(1, len(nums)): c[i] += c[i - 1]
        if any(c[i] < nums[i] for i in range(len(nums))): return -1
        t = sorted([(l, r, i) for i, (l, r) in enumerate(queries)])
        for i in range(len(nums)):
            p += a[i]
            while x < m and t[x][0] <= i:
                heappush(h, (-t[x][1], t[x][2]))
                x += 1
            while h and -h[0][0] < i: heappop(h)
            if p < nums[i]:
                for _ in range(nums[i] - p):
                    if not h: return -1
                    e, k = heappop(h)
                    u.add(k)
                    a[i] += 1
                    if -e + 1 < len(nums): a[-e + 1] -= 1
                    p += 1
        return m - len(u)",1460852232
Vedant_V_Borkar,Vedant_V_Borkar,528,3591,java,"class Solution {
    private long calc(char c1, char c2, int[] nc, int[] pc) {
        int s = c1 - 'a';
        int t = c2 - 'a';
        int f = (t - s + 26) % 26;
        int b = (s - t + 26) % 26;
        long fc = 0, bc = 0;
        for (int i = 0; i < f; i++) {
            fc += nc[(s + i) % 26];
        }
        for (int i = 0; i < b; i++) {
            bc += pc[(s - i + 26) % 26];
        }
        return Math.min(fc, bc);
    }
    
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        if (s.length() != t.length()) return -1;
        int n = s.length();
        long tc = 0;
        for (int i = 0; i < n; i++) {
            tc += calc(s.charAt(i), t.charAt(i), nextCost, previousCost);
        }
        return tc;
    }
}",1460827237
Vedant_V_Borkar,Vedant_V_Borkar,528,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        return play(n, 10, true);
    }

    private boolean play(int n, int t, boolean a) {
        if (n < t) return !a;
        return play(n - t, Math.max(1, t - 1), !a);
    }
}
",1460822518
Vedant_V_Borkar,Vedant_V_Borkar,528,3647,rust,"impl Solution {
    pub fn max_removal(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {
        let n = nums.len();
        let m = queries.len();
        let mut cov = vec![0; n + 1];
        for q in &queries {
            let l = q[0] as usize;
            let r = q[1] as usize;
            cov[l] += 1;
            if r + 1 < n {
                cov[r + 1] -= 1;
            }
        }
        
        for i in 1..n {
            cov[i] += cov[i-1];
        }
        
        for i in 0..n {
            if cov[i] < nums[i] {
                return -1;
            }
        }
        
        let mut qid: Vec<(i32, i32, usize)> = queries
            .iter()
            .enumerate()
            .map(|(i, q)| (q[0], q[1], i))
            .collect();
            
        qid.sort_by(|a, b| {
            if a.0 == b.0 {
                b.1.cmp(&a.1)
            } else {
                a.0.cmp(&b.0)
            }
        });
        
        let mut h = std::collections::BinaryHeap::new();
        let mut add = vec![0; n + 1];
        let mut c_add = 0;
        let mut sel = std::collections::HashSet::new();
        
        let mut p = 0;
        for i in 0..n {
            c_add += add[i];
            
            while p < m && qid[p].0 <= i as i32 {
                let e = qid[p].1;
                let q = qid[p].2;
                h.push((e, q));
                p += 1;
            }
            
            while let Some(&(e, _)) = h.peek() {
                if e < i as i32 {
                    h.pop();
                } else {
                    break;
                }
            }
            
            let mut c_cov = c_add;
            
            if c_cov < nums[i] {
                let need = nums[i] - c_cov;
                for _ in 0..need {
                    if h.is_empty() {
                        return -1;
                    }
                    let (se, q) = h.pop().unwrap();
                    sel.insert(q);
                    add[i] += 1;
                    if ((se + 1) as usize) < n {
                        add[(se + 1) as usize] -= 1;
                    }
                    c_add += 1;
                }
            }
        }
        
        (m - sel.len()) as i32
    }
}",1460852827
zerox130617,zerox130617,529,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n  = s.size();
        long long ret = 0;
        for(int i= 0; i < n ; i++){
            auto c = s[i];
            auto z = t[i];
            auto nx = check(c-'a', z-'a', 1, nextCost);
            auto pe = check(c-'a', z-'a', -1, previousCost);
            ret+=min(nx, pe);
        }
        return ret;
    }
    long long check(int c, int z, int dir, vector<int>& num){
        long long local = 0;
        while(c!=z){
            local+=num[c];
            c+=dir;
            if(c>=26)c%=26;
            if(c<0)c=25;
            
        }
        return local;
    }
};",1460807125
zerox130617,zerox130617,529,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int now = 10;
        int i = 0;
        while(n>0&&n>=now){
            i++;
            n-=now;
            now--;
        }
        return i%2==1;
    }
};",1460796222
zerox130617,zerox130617,529,3647,cpp,"class Solution {
public:
    static bool cmp(vector<int>&a, vector<int>&b){
        if(a[0]==b[0])return a[1]>b[1];
        return a[0]<b[0];
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& qu) {
        sort(qu.begin(),qu.end(), cmp);   
        int qn = qu.size();
        int n = nums.size();
        vector<int>cur(n+1, 0);
        int j = 0;
        int now = 0;
        int ret =0;
        priority_queue<int>pq;
        for(int i = 0; i < n ; i++){
            while(j<qn && qu[j][1]>=i && qu[j][0]<=i){
                pq.push(qu[j][1]);
                j++;
            }
            now+=cur[i];
            // cout<<i<<"" now: ""<<now<<"" ret ""<<ret<<"" cur ""<<cur[i]<<endl;
            while(!pq.empty() && nums[i]>now){
                auto f = pq.top();
                pq.pop();
                if(f<i)continue;
                now++;
                ret++;
                cur[f+1]--;
                // cout<<f<<"" ""<<cur[f+1]<<"" now ""<<now<<"" ret ""<<ret<<endl;
            }
            if(nums[i]>now)return -1;
        }
        return qn - ret;
        
    }
};

// [2,0,2]
// [[0,2],[0,2],[1,1]]
// [1,1,1,1]
// [[1,3],[0,2],[1,3],[1,2]]
// [1,2,3,4]
// [[0,3]]
// [0,3]
// [[0,1],[0,0],[0,1],[0,1],[0,0]]

// 1
// 2
// -1
// 2",1460866044
Kuo-Yu Huang,ericet1234,530,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;

        int a, b;
        long long t1, t2;
        for(int i=0, size=s.size() ; i<size ; i++){
            a = s[i]-'a';
            b = t[i]-'a';

            t1 = 0;
            while(a!=b){
                t1 += nextCost[a];
                a = (a+1)%26;
            }

            a = s[i]-'a';
            t2 = 0;
            while(a!=b){
                t2 += previousCost[a];
                a = (a+25)%26;
            }
            ans += min(t1, t2);
        }


        return ans;
    }
};",1460813826
Kuo-Yu Huang,ericet1234,530,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool ans = true;

        for(int i=10 ; i>=0 ; i--){
            n-=i;
            if(n==0){
                return ans;
            }
            ans = !ans;
            if(n<0){
                return ans;
            }
        }

        return ans;
    }
};",1460803020
Kuo-Yu Huang,ericet1234,530,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end(), [](vector<int> &A, vector<int> &B){
            if(A[0]==B[0]){
                return A[1]>B[1];
            }
            return A[0]<B[0];
        });
        //printf(""?\n"");
        int oper[100002] = {0};

        int ans = 0;
        int index = 0, queriesSize = queries.size();
        int size = nums.size();
        int now = 0;
        multiset<int> data;
        //printf(""?\n"");
        for(int i=0 ; i<size ; i++){
            now += oper[i];
            while(index<queriesSize && queries[index][0]==i){
                ans++;
                data.insert(queries[index][1]);
                index++;
            }
            
            while(data.size()){
                if(*data.begin()<i){
                    data.erase(data.begin());    
                } else if(now<nums[i]){
                    oper[(*data.crbegin())+1]--;
                    data.erase(data.find(*data.crbegin()));
                    now++;
                    ans--;
                } else {
                    break;
                }
            }
            if(now<nums[i]){
                return -1;
            }
        }

        return ans;
    }
};",1460853031
jJup0,jJup0,532,3591,python3,"class Solution:
    def shiftDistance(
        self, s: str, t: str, nextCost: list[int], previousCost: list[int]
    ) -> int:
        ord_a = ord(""a"")
        res = 0
        for c1, c2 in zip(s, t):
            cost_next = 0
            c1_copy = c1
            while c1 != c2:
                cost_next += nextCost[ord(c1) - ord_a]
                if c1 == ""z"":
                    c1 = ""a""
                else:
                    c1 = chr((ord(c1) + 1))

            c1 = c1_copy
            cost_prev = 0
            while c1 != c2:
                cost_prev += previousCost[ord(c1) - ord_a]
                if c1 == ""a"":
                    c1 = ""z""
                else:
                    c1 = chr((ord(c1) - 1))

            res += min(cost_next, cost_prev)
        return res
",1460811248
jJup0,jJup0,532,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        is_alice = True
        rem = n
        for i in range(10, 1, -1):
            if rem >= i:
                rem -= i
            else:
                return not is_alice
            is_alice = not is_alice
        assert False
",1460800619
jJup0,jJup0,532,3647,python3,"import heapq


class Solution:
    def maxRemoval(self, nums: list[int], queries: list[list[int]]) -> int:
        queries.sort()
        qi = 0
        unselected_q_heap: list[int] = []
        # used_q: deque[int] = deque()
        used_q: list[int] = []
        used_total = 0

        for i, num in enumerate(nums):
            while used_q and used_q[0] < i:
                # used_q.popleft()
                heapq.heappop(used_q)

            num -= len(used_q)
            if num <= 0:
                continue

            while qi < len(queries) and queries[qi][1] < i:
                qi += 1

            while qi < len(queries) and queries[qi][0] <= i:
                heapq.heappush(unselected_q_heap, (-queries[qi][1]))
                qi += 1

            if len(unselected_q_heap) < num:
                return -1

            used_total += num
            for _ in range(num):
                if not unselected_q_heap:
                    return -1
                r = -heapq.heappop(unselected_q_heap)
                if r < i:
                    return -1
                heapq.heappush(used_q, r)

        return len(queries) - used_total
",1460866775
somenath singh,somenath___singh,533,3591,cpp,"class Solution {
public:
    #define ll long long
    ll prev(char c,char t,vector<int>& te){
        ll ans=0;
        while(c!=t){
            ll temp=c-'a';
            ans+=te[temp];
            temp=(26+temp-1)%26;
            c='a'+temp;
        }
        return ans;
    }
    ll next(char c,char t,vector<int>& te){
        ll ans=0;
        while(c!=t){
            ll temp=c-'a';
            ans+=te[temp];
            temp=(26+temp+1)%26;
            c='a'+temp;
        }
        return ans;
    }
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        ll ans=0;
        for(ll i=0;i<s.size();i++){
            ans+=min(next(s[i],t[i],nc),prev(s[i],t[i],pc));
        }
        return ans;
    }
};",1460819980
somenath singh,somenath___singh,533,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int t=10;
        bool ans=0;
        while(1){
            if(n<t)return ans;
            n-=t;
            t--;
            ans=!ans;
}
        return 1;
    }
};",1460822002
somenath singh,somenath___singh,533,3647,cpp,"class Solution {
public:
    static bool comp(vector<int>&a,vector<int>&b){
        if(a[0]==b[0])return a[1]>b[1];
        return a[0]<b[0];
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        sort(q.begin(),q.end(),comp);
        vector<int>t(nums.size(),0);
        priority_queue<int>l;
        int tn=0;
        int in=0;
        for(int i=0;i<nums.size();i++){
            nums[i]=max(0,nums[i]-tn);
            while(in<q.size() && q[in][0]==i){
                l.push(q[in][1]);
                in++;
            }
            // cout<<i<<"" ""<<in<<endl;
            while(nums[i] && !l.empty() && l.top()>=i)nums[i]--,tn++,t[l.top()]++,l.pop();
            if(nums[i])return -1;
            tn-=t[i];
        }
        return l.size();
    }
};",1460854037
harshal_02,harshal_02,534,3591,cpp,"#define ll long long int
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        ll ans = 0;
        for(int i=0;i<n;i++){
            ll res=0;
            ll res2=0;
            char ch = s[i];
            char ch2 = t[i];
            int a = ch - 'a';
            int b = ch2 - 'a';
            int diff=b-a;
            diff+=26;
            diff=diff%26;
            for(int j=0;j<diff;j++){
                int crr = (a + j) % 26;
                res += nextCost[crr];
            }
            int sub=a-b;
            sub+=26;
            sub=sub%26;
            for (int j=0;j<sub;j++){
                int crr = (a - j + 26) % 26;
                res2 += previousCost[crr];
            }
            ans += min(res,res2);
        }
        return ans;
    }
};",1460875006
harshal_02,harshal_02,534,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int m=10;
        bool chk=true;
        while(n>0){
            if(m>n){
                return (chk==0);
            }
            n=n-m;
            m--;
            chk=!chk;
        }
        if(chk==0){
            return true;
        }
        else{
            return false;
        }
    }
};",1460875229
harshal_02,harshal_02,534,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        vector<int> v(n + 1, 0);
        vector<int> v2(n +1, 0); 
        int sum = 0;
        int cnt = 0;
        unordered_set<int> st;
        priority_queue<pair<int, int>> pq; 
        for(auto &it : queries){
            int phla = it[0];
            int dusra = it[1];
            v[phla]++;
            if(n-1>dusra){
                v[dusra+1]--;
            }
        }
        for(int i=1;i<n;i++){
            v[i]+=v[i-1];
        }
        for(int i=0;i<n;i++){
            if(nums[i] > v[i]){
                return -1;
            }
        }
        vector<tuple<int, int, int>> vec;
        vec.reserve(m);
        for(int i=0;i<m;i++){
            vec.emplace_back(queries[i][0], queries[i][1], i);
        }
        sort(vec.begin(), vec.end(), [&](const tuple<int,int,int> &a, const tuple<int,int,int> &b) -> bool{
            if(get<0>(a) == get<0>(b)){
                return get<1>(a) > get<1>(b); 
            }
            return get<0>(a) < get<0>(b);
        });
        for(int i=0;i<n;i++){
            sum += v2[i];
            while(cnt < m && get<0>(vec[cnt]) <= i){
                int phla = get<1>(vec[cnt]);
                int dusra = get<2>(vec[cnt]);
                pq.emplace(phla,dusra);
                cnt++;
            }
            while(!pq.empty() && pq.top().first < i){
                pq.pop();
            }
            int tot = sum;  
            if(nums[i] > tot){
                int diff = nums[i] - tot;
                for(int j=0; j<diff; j++){
                    if(pq.empty()){
                        return -1;
                    }
                    auto upr = pq.top();
                    pq.pop();
                    int phla = upr.first;
                    int dusra = upr.second;
                    st.insert(dusra);
                    v2[i]++;
                    if(n-1>phla){
                        v2[phla+1]--;
                    }
                    sum++;
                }
            }
        }
        int len=st.size();
        int ans=m-len;
        return ans;
    }
};",1460874809
nguyenddong90,nguyenddong90,538,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        @cache
        def distance(i,j,nxt):
            if i == j: return 0
            if nxt:
                return nextCost[i] + distance((i+1)%26,j,nxt)
            return previousCost[i] + distance((i-1)%26,j,nxt)
        ans = 0
        n = len(s)
        for i in range(n):
            frm = ord(s[i]) - ord('a')
            to = ord(t[i]) - ord('a')
            ans += min(distance(frm,to,True),distance(frm,to,False))
        return ans
",1460827116
nguyenddong90,nguyenddong90,538,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        ans = True
        rm = 10
        while n >= 0:
            n -= rm
            rm -= 1
            ans = not ans
        return ans",1460805914
nguyenddong90,nguyenddong90,538,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        canRemove = []
        n,m = len(nums),len(queries)
        target = [0] * (n+1)
        queries.sort()
        k = 0
        for i in range(n):
            target[i] += target[i-1]
            while k < m:
                l,r = queries[k]
                if l > i: break
                heappush(canRemove,(-r,l))
                k += 1
            while target[i] < nums[i]:
                # choose the best
                if not canRemove or -canRemove[0][0] < i:
                    #print(canRemove,i)
                    return -1
                r,l = heappop(canRemove)
                target[i] += 1
                target[-r+1] -= 1
        return len(canRemove)        
        
                ",1460863925
Mk72,Mohamed7204,539,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long ans = 0;
        for(int i = 0; i < n; i++){
            char c = s[i], c2 = s[i];
            long long sum1 = 0, sum2 = 0;
            while(c != t[i]){
                sum1 += nextCost[c - 'a'];
                if(c == 'z')c = 'a';
                else c++;
            }
            while(c2 != t[i]){
                sum2 += previousCost[c2 - 'a'];
                if(c2 == 'a')c2 = 'z';
                else c2--;
            }
            ans += min(sum1, sum2);
        }
        return ans;
    }
};",1460844206
Mk72,Mohamed7204,539,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 10;
        bool flag = true;
        while(n){
            if(n < x)break;
            n -= x;
            x--;
            flag ^= 1;
        }
        return !flag;
    }
};",1460829008
Mk72,Mohamed7204,539,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
    vector<pair<int, int>>q;
    for(auto i : queries){
        q.push_back(make_pair(i[0], i[1]));
    }
    sort(q.begin(), q.end());
    int n = nums.size(), m = q.size(), i = 0, j = 0;
    priority_queue<int>pq, q2;
    int sum = 0;
    for(i = 0; i < n; i++){
        while(j < m && q[j].first == i)pq.push(q[j++].second);
        while(sum < nums[i] && !pq.empty() && pq.top() >= i){
            q2.push(-pq.top());
            pq.pop();
            sum++;
        }
        if(sum < nums[i])return -1;
        while(!q2.empty() && q2.top() == -i)q2.pop(), sum--;
    }
    return (int)(pq.size());
}
};",1460870911
anonymous,sumitdrak,540,3591,cpp,"#define ll long long


class Solution {
public:
    ll total = 0;
    
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
 vector<vector<ll>> cost(26, vector<ll>(26, LLONG_MAX));
    
    for (int i = 0; i < 26; i++) 
        cost[i][i] = 0;

    
    for (int i = 0; i < 26; i++) {
        cost[i][(i + 1) % 26] = nextCost[i];
        cost[i][(i - 1 + 26) % 26] = previousCost[i];
    }


    for (int k = 0; k < 26; k++) {
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                if (cost[i][k] < LLONG_MAX && cost[k][j] < LLONG_MAX) {
                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);
                }
            }
        }
    }

    for (size_t i = 0; i < s.size(); i++) {
        if (s[i] == t[i]) continue;
        total += (s[i] - 'a' != t[i] - 'a') ? cost[s[i] - 'a'][t[i] - 'a'] : 0;
    }

    return total;
    }
};",1460838745
anonymous,sumitdrak,540,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentMove = 10;
        bool isAliceTurn = true;

        while (n > 0) {
            if (n >= currentMove) {
                n -= currentMove;
                currentMove--;
            } else {
                return !isAliceTurn;
            }
            isAliceTurn = !isAliceTurn;
        }
        return !isAliceTurn;
    }
};",1460822259
anonymous,sumitdrak,540,3647,cpp,"struct Query {
    int start, end, id;
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), m = queries.size();
        
        vector<int> pre_sum(n + 1, 0);
        
        for (auto q : queries) {
            pre_sum[q[0]]++;
            if (q[1] + 1 < n)
                pre_sum[q[1] + 1]--;
        }
        
        for (int i = 0; i < n; i++) {
            if (i)
                pre_sum[i] += pre_sum[i - 1];

            if (pre_sum[i] < nums[i]) 
                return -1;
        }
        
        vector<Query> qqid(m);
        for (int i = 0; i < m; i++) {
            qqid[i] = {queries[i][0], queries[i][1], i};
        }

        sort(qqid.begin(), qqid.end(), [](const Query& a, const Query& b) {
            if (a.start == b.start) {
                return a.end > b.end;
            }
            return a.start < b.start;
        });
        
        priority_queue<pair<int, int>> heap;
        vector<int> add(n + 1, 0);
        unordered_set<int> selected;
        int pointer = 0, current_add = 0;

        for (int i = 0; i < n; i++) {
            current_add += add[i];
            
            while (pointer < m && qqid[pointer].start <= i) {
                heap.emplace(qqid[pointer].end, qqid[pointer].id);
                pointer++;
            }
            
            while (!heap.empty() && heap.top().first < i) {
                heap.pop();
            }
    
            int current_pre_sum = current_add;
            if (current_pre_sum < nums[i]) {
                int need = nums[i] - current_pre_sum;
                for (int j = 0; j < need; j++) {
                    if (heap.empty()) return -1;
                    
                    auto [selected_end, qid] = heap.top();
                    heap.pop();

                    selected.insert(qid);
                    add[i]++;

                    if (selected_end + 1 < n) {
                        add[selected_end + 1] -= 1;
                    }

                    current_add++;
                }
            }
        }

        return m - selected.size();
    }
};
",1460871032
adarsh7281,adarsh7281,541,3591,cpp,"class Solution {
public:
    
    #define ll long long
    
    long long shiftDistance(string s, string t, vector<int>& nC, vector<int>& pC) {
        ll ans = 0;
        
        for(int i = 0; i<s.size(); i++){
            int curr = s[i]-'a';
            int req  = t[i]-'a';
            
            
            ll cost1 = 0;
            ll cost2 = 0;
            
            while(curr != req){
                cost1 += pC[curr];
                curr = (curr - 1 + 26)%26;
            }
            
            curr = s[i]-'a';
            
            while(curr != req){
                cost2 += nC[curr];
                curr = (curr + 1 + 26)%26;
            }
            
            ans += min(cost1,cost2);
            
        }
        
        return ans;
    }
};",1460824046
adarsh7281,adarsh7281,541,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0;
        int req = 10;
        while(n != 0){
            if(n<req){
                break;
            }
            else n-=req;
            
            req--;
            turn++;
        }
        
        return ((turn%2) != 0);
    }
};",1460800820
adarsh7281,adarsh7281,541,3647,cpp,"class Solution {
public:
    
    #define pii
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
       int cnt = 0;
       
       int j = 0;
       sort(queries.begin(), queries.end(), [](vector<int> & a, vector<int> & b){return a[0]<b[0];});
       map<int,int> mp;
       priority_queue<int> pq;
        
       int n = queries.size();
       int ans = 0;
       for(int i = 0; i<nums.size(); i++){
          while(j<n && queries[j][0] <= i){
              pq.push(queries[j][1]);
              j++;
          }
          
          while(cnt < nums[i] && !pq.empty() && pq.top() >= i){
              mp[pq.top()]++;
              pq.pop();
              cnt++;
              ans++;
          }
          
          if(cnt < nums[i]) return -1;
          
          if(mp.find(i) != mp.end()){
              cnt -= mp[i];
          }
       }
        return n-ans;
    }
};",1460858227
Sagar_Vala,Sagar_Vala,542,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        long long int ans=0;

        for(int j=0;j<s.size();j++){
            if(s[j]==t[j]){
                continue;
            }
            long long int a=0,b=0;

            int x=s[j]-'a';
            int y=t[j]-'a';

            while(x!=y){
                a+=n[x];
                x++;
                x%=26;
            }
            x=s[j]-'a';

            while(x!=y){
                b+=p[x];
                x--;
                x+=26;
                x%=26;
            }
            ans+=min(a,b);
       }


        return ans;
    }
};",1460804600
Sagar_Vala,Sagar_Vala,542,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x=10;
        bool f=0;
        while(1){
            if(n<x){
                return f;
            }
            f=!f;
            n-=x;
            x--;
        }
        return true;
    }
};",1460852041
Sagar_Vala,Sagar_Vala,542,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {

        int ans=q.size();
        sort(q.begin(),q.end());
        priority_queue<int> q1,q2;

        int i=0;
        for(int j=0;j<nums.size();j++){

            while(!q1.empty() && -q1.top()<j){
                q1.pop();
            }
            
            while(i<q.size() && q[i][0]<=j){
                q2.push(q[i][1]);
                i++;
            }
            while(q1.size()<nums[j] && !q2.empty() && q2.top()>=j){
                q1.push(-q2.top());
                q2.pop();
            }
            if(q1.size()<nums[j]){
                return -1;
            }
        }
        return q2.size();
    }
};",1460847928
Saiyan HarshD,HarshDagar8181,545,3591,cpp,"#pragma GCC optimize(""Ofast"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int, int> pii;
typedef pair<ll, int> pli;
#define fi first
#define se second
#define FR(i, a, b) for (int i = a; i <= b; i++)
#define FRR(i, a, b) for (int i = a; i >= b; i--)
#define _sort(x) sort((x).begin(),(x).end());
const int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;


class Solution {
public:
    ll hel(char a,char b,V<int>&nc,V<int>&pc){
        ll r1=0;
        int x=a-'a';
        while(1){
            char ch=x+'a';
            if(ch==b){
                break;
            }
            r1+=nc[x];
            x=(x+1)%26;
        }
        ll r2=0;
        x=a-'a';
        while(1){
            char ch=x+'a';
            if(ch==b){
                break;
            }
            r2+=pc[x];
            x--;
            if(x<0)x=25;
        }
        return min(r1,r2);
    }
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        long long res=0;
        int n=s.size();
        for(int i=0;i<n;i++){
            if(s[i]!=t[i]){
                res+=hel(s[i],t[i],nc,pc);
            }
        }
        return res;
    }
};",1460812824
Saiyan HarshD,HarshDagar8181,545,3625,cpp,"#pragma GCC optimize(""Ofast"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int, int> pii;
typedef pair<ll, int> pli;
#define fi first
#define se second
#define FR(i, a, b) for (int i = a; i <= b; i++)
#define FRR(i, a, b) for (int i = a; i >= b; i--)
#define _sort(x) sort((x).begin(),(x).end());
const int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;


class Solution {
public:
    bool canAliceWin(int n) {
        int ct=10;
        bool fl=0;
        while(n>=0){
            if(n-ct<0)return fl;
            fl=!fl;
            n=n-ct;
            ct--;
        }
        return 1;
    }
};",1460798038
Saiyan HarshD,HarshDagar8181,545,3647,cpp,"#pragma GCC optimize(""Ofast"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int, int> pii;
typedef pair<ll, int> pli;
#define fi first
#define se second
#define FR(i, a, b) for (int i = a; i <= b; i++)
#define FRR(i, a, b) for (int i = a; i >= b; i--)
#define _sort(x) sort((x).begin(),(x).end());
const int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;


class Solution {
public:
    int maxRemoval(vector<int>& arr, vector<vector<int>>& q) {
        int n=arr.size();
        V<ll>win(n+1);
        for(int i=0;i<q.size();i++){
            win[q[i][0]]++;
            win[q[i][1]+1]--;
        }
        for(int i=1;i<n+1;i++){
            win[i]+=win[i-1];
        }
        _sort(q);
        for(int i=0;i<n;i++){
            win[i]=win[i]-arr[i];
            if(win[i]<0)return -1;
        }
        V<int>win2(n+1);
        int ct=0;
        priority_queue<pii>pq;
        map<int,V<int>>mp;
        for(auto it:q){
            mp[it[0]].push_back(it[1]);
        }
        int res=0;
        for(int i=0;i<n;i++){
            if(mp.find(i)!=mp.end()){
                for(auto it:mp[i]){
                    res++;
                    pq.push({it,i});
                    ct++;
                    win2[it+1]--;
                }
            }
            ct+=win2[i];
            if(win[i]-ct<0){
                while(win[i]-ct<0){
                    auto temp=pq.top();
                    pq.pop();
                    ct--;
                    win2[temp.first+1]++;
                    res--;
                }
            }
        }
        return res;
        
    }
};",1460878547
Navpreet Singh,nav-singh,548,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nc, int[] pc) {
        int n = s.length();
        long[] dp = new long[n];
        Arrays.fill(dp,-1);
        return rec(0,s,t,nc,pc,dp);
    }
    
    private long rec(int i,String s,String t,int[] nc, int[] pc,long[] dp){
        
        if(i >= s.length()) return 0;
        
        if(dp[i] != -1) return dp[i];
        
        
        
        // prev 
        
        int id = s.charAt(i) - 'a';
        long cost = 0;
        int nd = t.charAt(i) - 'a';
        while(nd != id){
            cost += pc[id];
            id = ((id - 1 ) + 26) % 26; 
            
            
        }
        
        
        long res = rec(i+1,s,t,nc,pc,dp) + cost;
        
        
        // next
        id = s.charAt(i) - 'a';
        cost = 0;
        nd = t.charAt(i) - 'a';
        while(nd != id){
             cost += nc[id];
            id = ((id + 1 ) + 26) % 26; 
           
        }
        
        
        long res2 = rec(i+1,s,t,nc,pc,dp) + cost;
        
        res = Math.min(res,res2);
        
        
        return dp[i]  = res;
        
        
    }
    
    
    
    
    
    
}",1460832745
Navpreet Singh,nav-singh,548,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        
        int t = 0;
        for(int i = 10;i>=0;i--){
            if(n < i){
                return t % 2 != 0;
            }
                
            n -= i;
            t++;
            
        }
        
        return t % 2 == 0;
        
    }
}",1460837542
Navpreet Singh,nav-singh,548,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] q) {
        
        
        Arrays.sort(q,(a,b)->{
            return a[0] - b[0];
        
        });
        
        
        PriorityQueue<int[]> p = new PriorityQueue<>((a,b)->{
            return b[1] - a[1];
        });
        
        
        
        
        int j = 0;
        int m = q.length;
        int n = nums.length;
        int[]  have = new int[n+2];
        int res =0;
        for(int i =0;i<n;i++){
            
            while(j < m && q[j][0] <= i){
                p.add(q[j]);
                j++;
            }
            
            if(i > 0){
                have[i] += have[i-1];
            }            
            
            while(have[i] < nums[i]){
                if(p.size() == 0) return -1;
                int[] man = p.remove();
                
                
                if(man[1] < i) return -1;
                have[i]++;
                have[man[1] +1]--;
                res++;
            }
        }
        
        
        return m - res;    
        
        
    }
}",1460879599
smalukav,smalukav,550,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        assert(s.size() == t.size());
        long long ans = 0;
        for (size_t i = 0; i < s.size(); ++i) {
            assert(s[i] >= 'a' && s[i] <= 'z');
            assert(t[i] >= 'a' && t[i] <= 'z');
            int a = s[i] - 'a';
            int b = t[i] - 'a';
            long long c1 = 0;
            for (int c = a; c != b; c = (c + 1) % 26)
                c1 += nextCost[c];
            long long c2 = 0;
            for (int c = a; c != b; c = (c + 25) % 26)
                c2 += previousCost[c];
            ans += min(c1, c2);
        }
        return ans;
    }
};",1460824213
smalukav,smalukav,550,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool b = false;
        int c = 10;
        for (;;) {
            if (n < c)
                return b;
            n -= c;
            --c;
            b = !b;
        }
    }
};",1460800387
smalukav,smalukav,550,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        unsigned ans = 0;
        sort(queries.begin(), queries.end());
        multiset<int> q1;
        priority_queue<int, vector<int>, greater<int>> q2;
        size_t j = 0;
        for (size_t i = 0; i < nums.size(); ++i) {
            while (j < queries.size() && queries[j][0] <= i)
                q1.insert(queries[j++][1]);
            while (!q1.empty() && *q1.begin() < i) {
                q1.erase(q1.begin());
                ++ans;
            }
            while (!q2.empty() && q2.top() < i)
                q2.pop();
            if (q1.size() + q2.size() < nums[i])
                return -1;
            while (q2.size() < nums[i]) {
                q2.push(*prev(q1.end()));
                q1.erase(prev(q1.end()));
            }
        }
        ans += q1.size();
        return ans;
    }
};",1460874198
eatfood,eatfood,551,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], prevCost: List[int]) -> int:
        cost={}
        for i in range(26):
            cost[(i,i)] = 0
        for i in range(26):
            # go forward 26 times
            for k in range(1,26):
                j = (i+k) % 26
                # cost from i to j
                jm1 = (j-1+26) % 26
                cost[(i,j)] = cost[(i,jm1)] + nextCost[jm1]
                # print(i, k)
            # backwards
            for k in range(1,26):
                j = (i-k+26) % 26
                jp1 = (j+1) % 26
                # print('again', i, k)
                cost[(i,j)] = min(cost[(i,j)], cost[(i,jp1)] + prevCost[jp1])
                
        # print(len(cost))
        n=len(s)
        ans=0
        for i in range(n):
            a = ord(s[i]) - ord('a')
            b = ord(t[i])- ord('a')
            ans += cost[(a,b)]
        return ans
            
                
                
        ",1460823833
eatfood,eatfood,551,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        i=10
        p=0
        while i and n >= i:
            n -= i
            p = 1 - p
            i -= 1
        return p==1",1460797706
eatfood,eatfood,551,3647,python3,"from heapq import heapify, heappop, heappush

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n=len(nums)
        q=len(queries)
        decre=[0] * (n+1)

        level=0
        itvs = [] # max heap, largest r first
        ans = 0
        queries.sort(reverse=True)

        # process nums
        for i, ni in enumerate(nums):
            # itvs update
            # add intervals that are in scope now
            while len(queries) and queries[-1][0] <= i:
                l,r=queries.pop()
                heappush(itvs, (-r, l))
            # apply decrements to level
            level += decre[i]
            # add new itvs if needed
            while level < ni:
                if len(itvs)==0:
                    return -1
                r,l = heappop(itvs)
                r = -r
                if r < i:
                    # we cannot win
                    return -1
                # take interval [l,r]
                decre[r+1] -= 1
                level += 1
                ans += 1
        return q-ans
        ",1460880493
Sumit kumar,Abhimanyu_108,552,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& clockwisePenalty, vector<int>& counterClockwisePenalty) {
        long long totalCost = 0;

    for (int index = 0; index < s.size(); index++) {
    int currentChar = s[index] - 'a';
    int targetChar = t[index] - 'a';

    long long clockwiseCost = 0;
    long long counterClockwiseCost = 0;

    while (currentChar != targetChar) {
        counterClockwiseCost += counterClockwisePenalty[currentChar];
        currentChar = (currentChar - 1 + 26) % 26;
    }

    currentChar = s[index] - 'a';

   
    while (currentChar != targetChar) {
        clockwiseCost += clockwisePenalty[currentChar];
        currentChar = (currentChar + 1 + 26) % 26;
    }

    totalCost += min(clockwiseCost, counterClockwiseCost);
    }

    return totalCost;
    }
};",1460874214
Sumit kumar,Abhimanyu_108,552,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
    int playerTurn = 0;
    int requiredValue = 10;
    
    while (n > 0) {
        if (n < requiredValue) {
            break;
        }
    
        n -= requiredValue;
        requiredValue--;
        playerTurn++;
    }
    
    return (playerTurn % 2 == 1);
    }
};",1460869114
Sumit kumar,Abhimanyu_108,552,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end(), [](vector<int>& a, vector<int>& b) {
            return a[0] < b[0];
        });
        map<int, int> inter;
        priority_queue<int> pq;
        
        int queryTotal = queries.size();
        int count = 0;
        int q_index = 0;
        int n = nums.size();
        int m = 0;
        
        for (int i = 0; i < n; i++) {
            while (q_index < queryTotal && queries[q_index][0] <= i) {
                pq.push(queries[q_index][1]);
                q_index++;
            }
            while (count < nums[i] && !pq.empty() && pq.top() >= i) {
                inter[pq.top()]++;
                count++;
                m++;
                pq.pop();
            }
            if (count < nums[i]) return -1;
            if (inter.find(i) != inter.end()) {
                count = count - inter[i];
            }
        }
        return queryTotal - m;
    }
};",1460881440
Kushagra Mehta,kushm03,553,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        int n=s.size();
        long long res=0;
        for(int i=0;i<n;i++){
            long long x=s[i]-'a';
            long long y=t[i]-'a';
            long long ns=(y-x+26)%26;
            long long ps=(x-y+26)%26;
            long long ncost=0;
            long long pcost=0;
            for(int j=0;j<ns;j++){
                ncost+=nc[(x+j)%26];
            } 
            for(int j=0;j<ps;j++){
                pcost+=pc[(x-j+26)%26];
            } 
            res+=min(ncost,pcost);
        }
        return res;
    }
};
",1460835723
Kushagra Mehta,kushm03,553,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int nextturn=10;
        bool aliceturn= true;
        while(n>=nextturn){
            n-=nextturn;
            nextturn--;
            aliceturn= not aliceturn;
        }
        return not aliceturn;
    }
};",1460812063
Kushagra Mehta,kushm03,553,3647,cpp,"#include<bits/stdc++.h>
using namespace std;

class Solution{
public:
    bool helper(vector<int>&nums,vector<vector<int>>&queries,vector<int>&cov){
        
        int n=nums.size();
        
        for(auto&q:queries){
            int l=q[0],r=q[1];
            
            cov[l]+=1;
            if(r+1<n)cov[r+1]-=1;
        }
        
        for(int i=1;i<n;i++){
            cov[i]+=cov[i-1];
        } 
        
        for(int i=0;i<n;i++){
            if(cov[i]<nums[i]){
                
                return false; 
            } 
        } 
        return true;
    }

    int maxRemoval(vector<int>&nums,vector<vector<int>>&queries){
        int n=nums.size();
        int m=queries.size();
        
        vector<int>cov(n+1,0);
        if(!helper(nums,queries,cov)){
            return -1;
            
        }
        vector<tuple<int,int,int>>qs;
        for(int i=0;i<m;i++){
            qs.emplace_back(queries[i][0],queries[i][1],i);
        }
        sort(qs.begin(),qs.end(),[&](const tuple<int,int,int>&a,const tuple<int,int,int>&b){
            
            return get<0>(a)==get<0>(b)?get<1>(a)>get<1>(b):get<0>(a)<get<0>(b);
        });
        priority_queue<pair<int,int>>pq;
                
        vector<int>add(n+1,0);
        int curAdd=0;
                
        int p=0;
        unordered_set<int>sel;
        for(int i=0;i<n;i++) {
            curAdd+=add[i];
                
            while(p<m&&get<0>(qs[p])<=i){
                pq.emplace(get<1>(qs[p]),get<2>(qs[p]));
                p++;
                
            }
            while(!pq.empty()&&pq.top().first<i)pq.pop();
            int need=nums[i]-curAdd;
            for(int j=0;j<need;j++){
                
                if(pq.empty()){
                    return -1;
                } 
                auto top=pq.top();
                pq.pop();
                sel.insert(top.second);
                
                add[i]+=1;
                
                if(top.first+1<n){
                    add[top.first+1]-=1;
                } 
                curAdd+=1;
            }
        }
        return m-sel.size();
    }
};
",1460875560
dpdpdpp,dpdpdpp,556,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:

        def f(src, tar):
            cost = 0
            while src != tar:
                cost += nextCost[src]
                src = (src+1) % 26
            return cost

        def g(src, tar):
            cost = 0
            while src != tar:
                cost += previousCost[src]
                src = (src-1) % 26
            return cost

        ans = 0
        for src, tar in zip(s, t):
            src = ord(src) - 97
            tar = ord(tar) - 97
            ans += min(f(src, tar), g(src, tar))

        return ans",1460812336
dpdpdpp,dpdpdpp,556,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        a = False
        cost = 10
        while n >= cost:
            n -= cost
            cost -= 1
            a = not a

        return a

            ",1460798877
dpdpdpp,dpdpdpp,556,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        N = len(nums)
        diff = [0] * (N+5)
        for s, e in queries:
            diff[s] += 1
            diff[e+1] -= 1

        ps = 0
        for i in range(N):
            ps += diff[i]
            if ps < nums[i]:
                return -1
            nums[i] = ps - nums[i]

        seg = SegmentTree(N+5)
        seg.build(nums, 1, 0, N-1)
        # print(nums)
        # print(seg.query(1, 0, N-1, 1, 1))

        # try rmv
        ans = 0
        queries.sort(key=lambda x: (x[1]-x[0], x[0]))
        print(nums)
        print(queries)
        for s, e in queries:
            mn = seg.query(1, 0, N-1, s, e)
            if mn > 0:
                ans += 1
                seg.update(1, 0, N-1, s, e, -1)

        return ans


def min(a, b):
    if a < b:
        return a
    return b


class SegmentTree:

    def __init__(self, n):
        self.tree = [0]*(n*4)
        self.lazy = [0]*(n*4)

    def build(self, init, id, L, R):
        """"""
        
        
        """"""
        if L == R:  # 
            self.tree[id] = init[L]
            return
        M = (L+R)//2
        self.build(init, id*2, L, M)
        self.build(init, id*2+1, M+1, R)
        self.push_up(id)

    def op(self, a, b):
        """"""
        
        """"""
        return min(a, b)

    def push_down(self, id, L, R, M):
        """"""
        
        
        """"""
        if self.lazy[id]:
            self.tree[id*2] += self.lazy[id]
            self.lazy[id*2] += self.lazy[id]
            self.tree[id*2+1] += self.lazy[id]
            self.lazy[id*2+1] += self.lazy[id]
            self.lazy[id] = 0

    def push_up(self, id):
        """"""
        
        """"""
        self.tree[id] = self.op(self.tree[id*2], self.tree[id*2+1])

    def query(self, id, L, R, i, j):
        """"""
        
        [i, j]
        """"""
        if i <= L and R <= j:  # 
            return self.tree[id]
        M = (L+R)//2
        self.push_down(id, L, R, M)
        res = inf
        if i <= M:
            res = self.op(res, self.query(id*2, L, M, i, j))
        if M+1 <= j:
            res = self.op(res, self.query(id*2+1, M+1, R, i, j))
        return res

    def update(self, id, L, R, i, j, val):
        """"""
        
        [i, j]val
        """"""
        if i <= L and R <= j:  # 
            self.tree[id] += val
            self.lazy[id] += val
            return
        M = (L+R)//2
        self.push_down(id, L, R, M)
        if i <= M:
            self.update(id*2, L, M, i, j, val)
        if M < j:
            self.update(id*2+1, M+1, R, i, j, val)
        self.push_up(id)
",1460863498
Avan Singh,code_plus_plus,557,3591,cpp,"class Solution {
public:
    #define ll long long int
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
       ll ans=0;
        for(ll i=0;i<t.size();i++)
        {
            ll  c=s[i]-'a';
              if(s[i]!=t[i])
              {
                  ll sum=0,sum1=0;
                  while(c!=(t[i]-'a'))
                  {
                      sum=sum+nextCost[c];
                      c=(c+1)%26;
                  }
                   c=s[i]-'a';
                  while(c!=(t[i]-'a'))
                  {
                      sum1=sum1+previousCost[c];
                      if(c==0)
                      {
                          c=25;
                      }
                      else
                      c--;
                  }
                  ans=ans+min(sum,sum1);
              }
        }
        return ans;
    }
};",1460827427
Avan Singh,code_plus_plus,557,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int num=10;
        while((n-num)>=0)
        {
            n=n-num;
            num--;
        }
        return num%2==1;
    }
};",1460803479
Avan Singh,code_plus_plus,557,3647,cpp,"class Solution {
public:
    #define ll long long int
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        priority_queue<vector<ll>>pq;
        map<ll,ll>mp;
        ll ans=0;
        ll sum=0;
        sort(queries.begin(),queries.end());
        for(ll i=0,j=0;j<nums.size();j++)
        {
            while(i<queries.size()&&queries[i][0]<=j)
            {
                pq.push({queries[i][1],queries[i][0]});
                i++;
            }
            
            while(sum<nums[j]&&!pq.empty())
            {
                if(pq.top()[0]>=j)
                {
                sum++;
                ans++;
                mp[pq.top()[0]]++;
                }
                pq.pop();
            }
            if(sum>=nums[j])
                nums[j]=0;
            else
                return -1;
            cout<<sum<<endl;
            sum=sum-mp[j];
        }
        
        return queries.size()-ans;
    }
};",1460870179
Dalima Sahu,dalima62657,558,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
long totalCost = 0; // Use long to handle larger accumulations

        for (int i = 0; i < s.length(); i++) {
            int start = s.charAt(i) - 'a';
            int end = t.charAt(i) - 'a';

            int forwardSteps = (end - start + 26) % 26;
            int backwardSteps = (start - end + 26) % 26;

            long forwardCost = 0, backwardCost = 0;

            // Calculate forward cost
            for (int step = 0; step < forwardSteps; step++) {
                forwardCost += nextCost[(start + step) % 26];
            }

            // Calculate backward cost
            for (int step = 0; step < backwardSteps; step++) {
                backwardCost += previousCost[(start - step + 26) % 26];
            }

            // Add the minimum cost for the current character shift
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}",1460838591
Dalima Sahu,dalima62657,558,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
          int currentTurn = 10;
        boolean isAliceTurn = true;

        while (n > 0) {
            if (n < currentTurn) {
                return !isAliceTurn;
            }
            n -= currentTurn--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
        
    }
}",1460825234
Dalima Sahu,dalima62657,558,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
            int len = nums.length, queryCount = queries.length;
    int[] coverage = new int[len + 1];

    for (int[] q : queries) {
        coverage[q[0]]++;
        if (q[1] + 1 < len) coverage[q[1] + 1]--;
    }

    for (int i = 1; i < len; i++) {
        coverage[i] += coverage[i - 1];
    }

    for (int i = 0; i < len; i++) {
        if (coverage[i] < nums[i]) return -1;
    }

    List<int[]> sortedQueries = new ArrayList<>();
    for (int i = 0; i < queryCount; i++) {
        sortedQueries.add(new int[]{queries[i][0], queries[i][1], i});
    }

    sortedQueries.sort((a, b) -> {
        if (a[0] == b[0]) {
            return Integer.compare(b[1], a[1]);
        }
        return Integer.compare(a[0], b[0]);
    });

    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(b[0], a[0]));
    int[] delta = new int[len + 1];
    int activeAdd = 0, idx = 0;
    Set<Integer> selectedQueries = new HashSet<>();

    for (int i = 0; i < len; i++) {
        activeAdd += delta[i];

        while (idx < queryCount && sortedQueries.get(idx)[0] <= i) {
            pq.offer(new int[]{sortedQueries.get(idx)[1], sortedQueries.get(idx)[2]});
            idx++;
        }

        while (!pq.isEmpty() && pq.peek()[0] < i) {
            pq.poll();
        }

        if (activeAdd < nums[i]) {
            int need = nums[i] - activeAdd;
            for (int j = 0; j < need; j++) {
                if (pq.isEmpty()) return -1;
                int[] top = pq.poll();
                selectedQueries.add(top[1]);
                delta[i]++;
                if (top[0] + 1 < len) delta[top[0] + 1]--;
                activeAdd++;
            }
        }
    }

    return queryCount - selectedQueries.size();
        
    }
}",1460857565
Denys Gubar,DenisGubar,559,3591,cpp,"static long long F[26][26];
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long result = 0;
        memset(F, 1, sizeof(F));
        for (int a = 0; a < 26; ++a)
        {
            F[a][a] = 0;
            long long total = 0;
            for (int b = (a + 1) % 26, k = 0; k < 25; ++k, b = (b + 1) % 26)
            {
                total += nextCost[(b + 25) % 26];
                F[a][b] = min(F[a][b], total);
            }
            total = 0;
            for (int b = (a + 25) % 26, k = 0; k < 25; ++k, b = (b + 25) % 26)
            {
                total += previousCost[(b + 1) % 26];
                F[a][b] = min(F[a][b], total);
            }
        }
        int const N = s.size();
        for (int i = 0; i < N; ++i)
            result += F[s[i] - 'a'][t[i] - 'a'];
        return result;
    }
};
",1460850963
Denys Gubar,DenisGubar,559,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int next = 10;
        while (true)
        {
            if (n < next)
                return false;
            n -= next;
            --next;
            if (n < next)
                return true;
            n -= next;
            --next;
        }
    }
};
",1460797248
Denys Gubar,DenisGubar,559,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int const N = nums.size(), Q = queries.size();
        sort(queries.begin(), queries.end());
        priority_queue<int> PQ;
        int balance = 0;
        vector<int> A(N + 1);
        for (int q = 0, i = 0; i < N; ++i)
        {
            balance += A[i];
            while (q < Q && queries[q][0] == i)
                PQ.push(queries[q][1]), ++q;
            while (!PQ.empty() && balance + nums[i] > 0)
            {
                --balance;
                int R = PQ.top(); PQ.pop();
                if (R < i)
                    return -1;
                ++A[R + 1];
            }
            if (balance + nums[i] > 0)
                return -1;
        }
        return PQ.size();
    }
};
",1460871121
Shubham,sk_kr,561,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.size();i++){
           
           long long ans1=0;
            long long ans2=0;
            int x= s[i]-'a';
            int y= t[i]-'a';
            while(x!=y){
                ans1+= nextCost[x];
                x++;
                if(x==26)
                    x=0;
            }
           
            x=s[i]-'a';
            
            while(x!=y){
                ans2+= previousCost[x];
                x--;
                if(x==-1)
                    x=25;
            }
            
            ans+=min(ans1,ans2);
        }
        return ans;
    }
};",1460827092
Shubham,sk_kr,561,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr =10;
        bool ans=false;
        while(1){
            if(n>=curr){
                n-=curr;
                curr--;
                ans=!ans;
            }
            else
                return ans;
        }
    }
};",1460801770
Shubham,sk_kr,561,3647,cpp,"#include<bits/stdc++.h>

vector<int>st(1000000,0);
vector<int>lazy(1000000,0);
void build(int si ,int ss ,int se,vector<int>&arr)
{
    if(ss == se)
    {
        st[si] = arr[ss];
        return;
    }
    int mid = (ss + se)/2;
    build(2*si , ss , mid,arr);
    build(2*si+1 , mid+1 , se,arr);
 
    st[si] = max(st[2*si] , st[2*si+1]);
}
int query(int si , int ss , int se , int qs , int qe)
{  
        st[2*si]+=lazy[si];
        st[2*si+1]+=lazy[si];
        lazy[2*si]+=lazy[si];
         lazy[2*si+1]+=lazy[si];
         lazy[si]=0;
    if(qe < ss || qs> se)
    { 
        return -100000000;
    }
    if(ss>=qs && se<=qe)
     {  
       
        return st[si];
     }
 
    int mid = (ss + se)/2;
    int l = query(2*si , ss , mid , qs , qe);
    int r = query(2*si+1 , mid+1 , se , qs , qe);
    return max(l,r);
}
void update(int si,int ss,int se,int value,int qs,int qe)
{    
        st[2*si]+=lazy[si];
        st[2*si+1]+=lazy[si];
        lazy[2*si]+=lazy[si];
         lazy[2*si+1]+=lazy[si];
         lazy[si]=0;
      if(ss>=qs&&se<=qe)
      {
         st[si]+=value;
         lazy[si]+=value;
         return;
      }
      if(qe < ss || qs> se)
        return ;
       int mid = (ss + se)/2;
       update(2*si,ss,mid,value,qs,qe);
       update((2*si)+1,mid+1,se,value,qs,qe);
       st[si]=max(st[2*si] , st[2*si+1]);
}
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        for(int i=0;i<nums.size()*10;i++){
            st[i]=0;
            lazy[i]=0;
        }
        build(1,0,nums.size()-1,nums);
        vector<pair<int,int>>q;
        for(int i=0;i<queries.size();i++){
            update(1,0,nums.size()-1,-1,queries[i][0],queries[i][1]);
            q.push_back({-queries[i][0],queries[i][1]});
        }
        sort(q.begin(),q.end(),[](auto &left, auto &right) {
            return left.second < right.second;
        });
        if(query(1,0,nums.size()-1,0,nums.size()-1)>0){
            return -1;
        }
        int ans=0;
        for(int i=0;i<queries.size();i++){
            int x= query(1,0,nums.size()-1,-q[i].first,q[i].second);
            if(x<0){
                ans++;
                update(1,0,nums.size()-1,1,-q[i].first,q[i].second);
            }
        }
        return ans;
    }
};",1460878572
Dipu Kumar Mohanto,_dipu,562,3591,cpp,"#include ""bits/stdc++.h""
using namespace std;
using ll = long long int;

class Solution {
private:
    ll getCost(char from, char to, vector<int> &cost, int val) {
        ll cst = 0;
        while (from != to) {
            cst += cost[ from - 'a' ];
            if (from == 'z' and val == 1) {
                from = 'a';
            } else if (from == 'a' and val == -1) {
                from = 'z';
            } else {
                int cval = (from - 'a') + val;
                from = static_cast<char>(cval + 'a');
            }
        }
        return cst;
    }
public:
    ll shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll ans = 0;
        for (int i = 0; i < s.size(); i++) {
            ll cst1 = getCost(s[i], t[i], nextCost, 1);
            ll cst2 = getCost(s[i], t[i], previousCost, -1);
            ans += min(cst1, cst2);
        }
        return ans;
    }
};",1460873218
Dipu Kumar Mohanto,_dipu,562,3625,cpp,"#include ""bits/stdc++.h""
using namespace std;
using ll = long long int;

class Solution {
public:
    bool canAliceWin(int n) {
        int take = 10;
        for (int turn = 0; ; turn++) {
            n -= take;
            if (n < 0) {
                if (turn % 2 == 0) {
                    return false;
                }
                return true;
            }
            take--;
        }
        assert(false);
    }
};",1460864312
Dipu Kumar Mohanto,_dipu,562,3647,cpp,"#include ""bits/stdc++.h""
using namespace std;
using ll = long long int;

struct Data {
    int sum;
    Data(int sum = 0)
        : sum(sum) {}
};

class SegmentTree {
private:
    int N;
    vector <Data> st;
    vector <bool> cLazy;
    vector <int> lazy;

    void merge(Data &cur, Data &l, Data &r) {
        cur.sum = max(l.sum, r.sum);
    }
    void propagate(int node, int L, int R) {
        if (L != R) {
            int lft = node * 2;
            int rgt = lft + 1;
            cLazy[lft] = 1;
            cLazy[rgt] = 1;
            lazy[lft] = lazy[lft] + lazy[node];
            lazy[rgt] = lazy[rgt] + lazy[node];
        }
        st[node].sum = st[node].sum + lazy[node];
        cLazy[node] = 0;
        lazy[node] = 0;
    }
    void build(vector<int> &store, int node, int L, int R) {
        if (L == R) {
            st[node].sum = store[L];
            cLazy[node] = 0;
            lazy[node] = 0;
            return;
        }
        int lft = node * 2;
        int rgt = lft + 1;
        int M = (L + R) / 2;
        build(store, lft, L, M);
        build(store, rgt, M + 1, R);
        merge(st[node], st[lft], st[rgt]);
    }
    Data Query(int node, int L, int R, int i, int j) {
        if (cLazy[node]) {
            propagate(node, L, R);
        }
        if (j < L | i > R) {
            return Data();
        }
        if (i <= L && R <= j) {
            return st[node];
        }
        int lft = node * 2;
        int rgt = lft + 1;
        int M = (L + R) / 2;
        Data p = Query(lft, L, M, i, j);
        Data q = Query(rgt, M + 1, R, i, j);
        Data cur;
        merge(cur, p, q);
        return cur;
    }
    Data pQuery(int node, int L, int R, int pos) {
        if (cLazy[node]) {
            propagate(node, L, R);
        }
        if (L == R) {
            return st[node];
        }
        int lft = node * 2;
        int rgt = lft + 1;
        int M = (L + R) / 2;
        if (pos <= M) {
            return pQuery(lft, L, M, pos);
        }
        else {
            return pQuery(rgt, M + 1, R, pos);
        }
    }
    void update(int node, int L, int R, int i, int j, int val) {
        if (cLazy[node]) {
            propagate(node, L, R);
        }
        if (j < L || i > R) {
            return;
        }
        if (i <= L && R <= j) {
            cLazy[node] = 1;
            lazy[node] = lazy[node] + val;
            propagate(node, L, R);
            return;
        }
        int lft = node * 2;
        int rgt = lft + 1;
        int M = (L + R) / 2;
        update(lft, L, M, i, j, val);
        update(rgt, M + 1, R, i, j, val);
        merge(st[node], st[lft], st[rgt]);
      }
      void pUpdate(int node, int L, int R, int pos, int val)
      {
        if (cLazy[node]) {
            propagate(node, L, R);
        }
        if (L == R) {
            cLazy[node] = 1;
            lazy[node] = lazy[node] + val;
            propagate(node, L, R);
            return;
        }
        int lft = node * 2;
        int rgt = lft + 1;
        int M = (L + R) / 2;
        if (pos <= M) {
            pUpdate(lft, L, M, pos, val);
        }
        else {
            pUpdate(rgt, M+1, R, pos, val);
        }
        merge(st[node], st[lft], st[rgt]);
    }
public:
    void init(int n) {
        N = n;
        st.resize(4 * N + 5);
        cLazy.resize(4 * N + 5);
        lazy.resize(4 * N + 5);
    }
    void build(vector<int> &store) {
        build(store, 1, 1, N);
    }
    Data query(int pos) {
        return pQuery(1, 1, N, pos);
    }
    Data query(int l, int r) {
        return Query(1, 1, N, l, r);
    }
    void update(int pos, int val) {
        pUpdate(1, 1, N, pos, val);
    }
    void update(int l, int r, int val) {
        update(1, 1, N, l, r, val);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> store;
        store.push_back(0);
        for (int x : nums) {
            store.push_back(x);
        }
        SegmentTree seg;
        seg.init(n);
        seg.build(store);
        Data res = seg.query(1, n);
        int ans = queries.size();
        if (res.sum == 0) {
            return ans;
        }
        for (int i = 0; i < queries.size(); i++) {
            int l = queries[i][0];
            int r = queries[i][1];
            seg.update(l + 1, r + 1, -1);
        }
        res = seg.query(1, n);
        if (res.sum > 0) {
            return -1;
        }
        vector<pair<int, int>> qq;
        for (auto it : queries) {
            qq.push_back({it[0], it[1]});
        }
        sort(qq.begin(), qq.end(), [&](pair<int, int> &p, pair<int, int> q)
            {
                int lenp = p.second - p.first + 1;
                int lenq = q.second - q.first + 1;
                if (lenp == lenq) {
                    if (p.first == q.first) {
                        return p.second < q.second;
                    }
                    return p.first < q.first;
                }
                return lenp < lenq;
            });
        ans = 0;
        for (int i = 0; i < queries.size(); i++) {
            int l = qq[i].first;
            int r = qq[i].second;
            seg.update(l + 1, r + 1, 1);
            res = seg.query(1, n);
            if (res.sum <= 0) {
                ans++;
            } else {
                seg.update(l + 1, r + 1, -1);
            }
        }
        return ans;
    }
};",1460859921
seryp,seryp,563,3591,cpp,"class Solution {
public:
    void cal_move(vector<vector<long long>> &mov,vector<int> &next, vector<int> &pre){
        
        for(int i = 0;i < 26;i++){
            for(int j = 0;j < 26;j++){
                if(i == j){
                    mov[i][j] = 0;
                }else{
                    int k = i;
                    long long c0 = 0;
                    while(k != j){
                        c0 += next[k];
                        k = (k + 1) % 26;
                    }
                    long long c1 = 0;
                    k = i;
                    while(k != j){
                        c1 += pre[k];
                        k = (k - 1 +26) % 26;
                    }
                    mov[i][j] = min(c0,c1);
                }
            }
        }
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> mov(26,vector<long long>(26,0));
        cal_move(mov,nextCost,previousCost);
        long long ans = 0;
        for(int i = 0;i < t.size();i++){
            ans += mov[s[i] - 'a'][t[i] - 'a'];
        }
        return ans;
    }
};",1460821901
seryp,seryp,563,3625,cpp,"class Solution {
public:
    bool can(int n,int mov){
        if(n == 0 || mov == 0){
            return false;
        }
        if(n < mov){
            return false;
        }
        return !can(n-mov,mov-1);
    }
    bool canAliceWin(int n) {
        return can(n,10);
    }
};",1460799616
seryp,seryp,563,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        sort(q.begin(),q.end());
        priority_queue<int,vector<int>,less<int> > que;
        int index = 0;
        vector<int> dd(nums.size() + 1,0);
        int res = 0,ans=0;
        for(int i = 0;i < nums.size();i++){
            while(index < q.size() && q[index][0] <= i){
                que.push(q[index][1]);
                index++;
            }
            res += dd[i];
            int y = res + nums[i];
            while(y > 0){
                if(que.size() == 0 || que.top() < i){
                    return -1;
                }
                int x = que.top();
                que.pop();
                res--;
                y--;
                dd[x+1]++;
                ans++;
            }
        }
        return (int)q.size() - ans;        
    }
};",1460879223
Yuvraj Singh,yuvrajsingh33,565,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long total= 0;
        for(int i=0;i< s.size();++i){
            int start =s[i]-'a';
            int target=t[i]-'a';
            int a= (target-start+ 26)%26;
            long long acost =0;
            for (int i=0;i<a;++i){
                acost += nextCost[(start+i)%26];
            }
            int b =(start-target+26)%26;
            long long bcost = 0;
            for(int i=0;i<b;++i){
                bcost += previousCost[(start-i+26)%26];
            }
            total+= min(acost,bcost);
        }
        return total;
    }
};
",1460832117
Yuvraj Singh,yuvrajsingh33,565,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n){
        bool a= true;
        if(n<10) return false;
        int stones=10;
        while(n>=stones){
            n -= stones;
            stones--;
            a= not a;
        }
        return not a;
    }
};
",1460816965
Yuvraj Singh,yuvrajsingh33,565,3647,cpp,"class Solution {
public:
    bool isFeasible(vector<int>& requirements,vector<int>& coverage){
        for (size_t i=0;i<requirements.size();i++){
            if(coverage[i]<requirements[i]){
                return false;
            }
        }
        return true;
    }
    vector<int> calculateCoverage(const vector<int>& requirements,const vector<vector<int>>& operations) {
        int n = requirements.size();
        vector<int> coverage(n+1,0);
        for(const auto& operation : operations){
            int start = operation[0];
            int end = operation[1];
            coverage[start]++;
            if(end+1<n){
                coverage[end+1]--;
            }
        }
        for(int i=1;i<n;i++){
            coverage[i]+=coverage[i-1];
        }
        return coverage;
    }
    
    vector<tuple<int,int,int>> prepareOperations(vector<vector<int>>& operations){
        vector<tuple<int,int,int>> sortedOps;
        int m = operations.size();
        sortedOps.reserve(m);
        for (int i =0;i<m;i++){
            sortedOps.emplace_back(operations[i][0],operations[i][1],i);
        }
        sort(sortedOps.begin(),sortedOps.end(),[](const tuple<int,int,int>& a,const tuple<int,int,int>& b){
            if(get<0>(a)==get<0>(b)){
                return get<1>(a)>get<1>(b);
            }
            return get<0>(a) < get<0>(b);
        });
        return sortedOps;
    }
    int maxRemoval(vector<int>& nums,vector<vector<int>>& queries){
        int n = nums.size();
        int m = queries.size();
        vector<int> coverage = calculateCoverage(nums,queries);
        if(!isFeasible(nums,coverage)){
            return -1;
        }
        vector<tuple<int,int,int>> sortedOperations=prepareOperations(queries);
        priority_queue<pair<int, int>> maxHeap;
        vector<int> additionalCoverage(n+1,0);
        unordered_set<int> selectedOps;
        int activeCoverage = 0;
        int index = 0;

        for(int i=0;i<n;i++){
            activeCoverage += additionalCoverage[i];
            while(index<m && get<0>(sortedOperations[index])<=i){
                maxHeap.emplace(get<1>(sortedOperations[index]),get<2>(sortedOperations[index]));
                index++;
            }
            while(!maxHeap.empty() && maxHeap.top().first<i){
                maxHeap.pop();
            }
            if(activeCoverage<nums[i]){
                int deficit = nums[i]-activeCoverage;
                for(int j =0;j<deficit;j++){
                    if(maxHeap.empty()){
                        return -1;
                    }
                    auto top = maxHeap.top();
                    int operationEnd = top.first;
                    int operationIndex = top.second;
                    maxHeap.pop();
                    selectedOps.insert(operationIndex);
                    additionalCoverage[i]++;
                    if(operationEnd+1<n){
                        additionalCoverage[operationEnd+1]--;
                    }
                    activeCoverage++;
                }
            }
        }
        return m-selectedOps.size();
    }
};
",1460879570
Nirbhay singh,chhivalaha499,566,3591,cpp,"class Solution {
public:
    vector<vector<long long >>dp;
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& pre) {
        dp.clear();
        dp.resize(26,vector<long long>(26,0));
        f(next,pre);
        long long ans = 0;
        for(int i=0; i<t.size(); i++){
            ans += dp[s[i]-'a'][t[i]-'a'];
        }
        return ans;
    }
    void f(vector<int>&next, vector<int>pre){
        for(int i=0;i<26; i++){
            for(int j=0;j<26; j++){
                if(i==j)   continue;
                long long r = 0;
                int k = i;
                while(k!=j){
                    r += next[k];
                    k++;
                    k%=26;
                }
                long long p = 0;
                k = i;
                while(k!=j){
                    p += pre[k];
                    k--;
                    if(k<0) k+=26;
                }
                dp[i][j] = min(r,p);
            }
        }
    }

};",1460873845
Nirbhay singh,chhivalaha499,566,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool flag = false;
        int k = 10;
        while(n>=k){
            n-=k;
            k--;
            flag = flag == true? false:true;
        }
        return flag;
    }
};",1460802987
Nirbhay singh,chhivalaha499,566,3647,cpp,"#define  pi pair<int,int> 

class compare {
public:
    bool operator()(pi below, pi above)
    {
        return above.second>below.second;
    }
};
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& query) {
        sort(query.begin(),query.end());
        priority_queue<pi,vector<pi>,compare> pq;
        int j = 0;
        int cnt = 0;
        int k = 0;
        priority_queue<int,vector<int>,greater<int>> end;
        for(int i=0; i<nums.size(); i++){
            while(j<query.size()&&query[j][0]<=i){
                pq.push({query[j][0],query[j][1]});
                j++;
            }
            while(end.size()&&end.top()<i){
                cnt--;
                end.pop();
            }
            while(pq.size()&&cnt<nums[i]){
                if(pq.top().second<i) k++;
                else{
                    end.push(pq.top().second);
                    cnt++;
                }
                pq.pop();
            }
            if(cnt<nums[i])   return -1;
        }
        while(j<query.size()){
            pq.push({query[j][0],query[j][1]});
            j++;
        }
        return pq.size();
    }
};",1460859566
Vaibhav Kumar,vaibhavdb,567,3591,java,"class Solution {
    public long shiftDistance(String s, String tt, int[] n, int[] p) {
        long tot = 0;
        for(int i = 0;i < s.length();i++){
            if(s.charAt(i) == tt.charAt(i)){
                continue;
            }else if(s.charAt(i) > tt.charAt(i)){
                long t = 0;
                int start = (int)(s.charAt(i) - 'a');
                int end = (int)(tt.charAt(i) - 'a');
                while(start > end){
                    t = (long)(t + (long)p[start]);
                    start--;
                }
                long t1 = 0;
                start = (int)(s.charAt(i) - 'a');
                while(start < 26){
                    t1 = (long)(t1 + (long)n[start]);
                    start++;
                }
                end = (int)(tt.charAt(i) - 'a') - 1;
                while(end >= 0){
                    t1 = (long)((long)t1 + (long)n[end]);
                    end--;
                }
                tot = (long)(tot + Math.min(t1, t));
            }else{
                long t = 0;
                int start = (int)(s.charAt(i) - 'a');
                int end = (int)(tt.charAt(i) - 'a');
                while(start < end){
                    t = (long)(t + (long)n[start]);
                    start++;
                }
                long t1 = 0;
                start = (int)(s.charAt(i) - 'a');
                while(start >= 0){
                    t1 = (long)(t1 + (long)p[start]);
                    start--;
                }
                end = (int)(tt.charAt(i) - 'a') + 1;
                while(end < 26){
                    t1 = (long)((long)t1 + (long)p[end]);
                    end++;
                }
                tot = (long)(tot + Math.min(t1, t));
            }
        }
        return tot;
    }
}",1460831766
Vaibhav Kumar,vaibhavdb,567,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int i = 10;
        int co = 0;
        while(i <= n){
            co++;
            n = n - i;
            i--;
        }
        if(co % 2 == 0){
            return false;
        }
        return true;
    }
}",1460797054
Vaibhav Kumar,vaibhavdb,567,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int[] co = new int[nums.length];
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)-> (b[1] - a[1]));
        int tot = 0;
        Arrays.sort(queries, (a, b) -> {
            if(a[0] == b[0]){
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });
        int j = 0;
        int ans = 0;
        for(int i = 0;i < nums.length;i++){
            // tot = tot + co[i];
            // co[i] = 0;
            while(j < queries.length && queries[j][0] <= i){
                pq.add(queries[j]);
                j++;
            }
            while(tot < nums[i] && !pq.isEmpty()){
                int[] te = pq.poll();
                if(te[1] < i){
                    pq = new PriorityQueue<>();
                    break;
                }
                ans++;
                tot++;
                co[te[1]]--;
            }
            if(tot < nums[i]){
                return -1;
            }
            tot = tot + co[i];
        }
        return queries.length - ans;
    }
}",1460880007
minhphu19022000,minhphu19022000,568,3591,rust,"impl Solution {
    pub fn shift_distance(s: String, t: String, next_cost: Vec<i32>, previous_cost: Vec<i32>) -> i64 {
        let mut v = [0i64; 26 * 26];
        for c in 0..26 {
            let mut s = 0;
            for k in c + 1..26 {
                s += next_cost[k - 1] as i64;
                let i = c * 26 + k;
                v[i] = s;
            }
            s += next_cost[25] as i64;
            for k in 0..c {
                let i = c * 26 + k;
                v[i] = s;
                s += next_cost[k] as i64;
            }
        }
        for c in 0..26 {
            let mut s = 0;
            for k in (0..c).rev() {
                s += previous_cost[k + 1] as i64;
                let i = c * 26 + k;
                v[i] = s.min(v[i]);
            }
            s += previous_cost[0] as i64;
            for k in (c..26).rev() {
                let i = c * 26 + k;
                v[i] = s.min(v[i]);
                s += previous_cost[k] as i64;
            }
        }
        s.bytes().zip(t.bytes()).map(|(c, k)| *unsafe {
            let i = (c - b'a') as usize;
            let j = (k - b'a') as usize;
            v.get_unchecked(i * 26 + j)
        }).sum()
    }
}",1460840896
minhphu19022000,minhphu19022000,568,3625,rust,"impl Solution {
    fn can_alice_win(mut n: i32) -> bool {
        let mut b = false;
        for i in (0..=10).rev() {
            if n < i {
                return b;
            }
            n -= i;
            b = !b;
        }
        b
    }
}",1460819285
minhphu19022000,minhphu19022000,568,3647,rust,"use std::collections::BinaryHeap;

impl Solution {
    pub fn max_removal(mut nums: Vec<i32>, queries: Vec<Vec<i32>>) -> i32 {
        let mut q: Vec<_> = queries.into_iter().map(|v| unsafe {
            (*v.get_unchecked(0) as usize, *v.get_unchecked(1) as usize)
        }).collect();
        q.sort_by_key(|o| o.0);
        let mut it = (0..).zip(q).peekable();
        
        let mut prv = 0;
        for p in &mut nums {
            let t = *p;
            *p -= prv;
            prv = t;
        }
    
        let mut h = BinaryHeap::new();
        let mut s = 0i64;
        for i in 0..nums.len() {
            let x = nums[i];
            s += x as i64;
            while let Some(&(u, (k, j))) = it.peek() {
                if k == i {
                    h.push((j, u));
                    it.next();
                } else {
                    break;
                }
            }
            while s > 0 {
                if let Some((j, _)) = h.pop() {
                    if j < i {
                        return -1;
                    }
                    if let Some(p) = nums.get_mut(j + 1) {
                        *p += 1;
                    }
                    s -= 1;
                } else {
                    return -1;
                }
            }
        }
        h.len() as i32
    }
}",1460880100
Konstantin Kostin,libkonstantin,569,3591,java,"class Solution {

    static final int ALPHABET_SIZE = 'z' - 'a' + 1;

    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[][] next = new long[ALPHABET_SIZE][ALPHABET_SIZE];
        for (int from = 0; from < ALPHABET_SIZE; ++from) {
            for (int k = 1; k < ALPHABET_SIZE; k++) {
                int to = (from + k) % ALPHABET_SIZE;
                int p = (to - 1 + ALPHABET_SIZE) % ALPHABET_SIZE;
                next[from][to] = next[from][p] + nextCost[p];
            }
        }
        long[][] prev = new long[ALPHABET_SIZE][ALPHABET_SIZE];
        for (int from = 0; from < ALPHABET_SIZE; ++from) {
            for (int k = 1; k < ALPHABET_SIZE; k++) {
                int to = (from - k + ALPHABET_SIZE) % ALPHABET_SIZE;
                int p = (to + 1) % ALPHABET_SIZE;
                prev[from][to] = prev[from][p] + previousCost[p];
            }
        }

        long[][] dist = new long[ALPHABET_SIZE][ALPHABET_SIZE];
        for (int from = 0; from < ALPHABET_SIZE; from++) {
            for (int to = 0; to < ALPHABET_SIZE; to++) {
                dist[from][to] = Math.min(next[from][to], prev[from][to]);
            }
        }

        int n = s.length();
        long ans = 0;
        for (int i = 0; i < n; i++) {
            int from = s.charAt(i) - 'a';
            int to = t.charAt(i) - 'a';
            ans += dist[from][to];
        }
        return ans;
    }
}",1460835571
Konstantin Kostin,libkonstantin,569,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int ans = 1;
        int cnt = 10;
        while (cnt > 0 && n >= cnt) {
            n -= cnt;
            cnt--;
            ans ^= 1;
        }
        return ans == 0;
    }
}",1460798653
Konstantin Kostin,libkonstantin,569,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (a, b) -> {
            int cmp = Integer.compare(a[0], b[0]);
            if (cmp == 0) {
                cmp = Integer.compare(b[1], a[1]);
            }
            return cmp;
        });

        int n = nums.length;
        int cntUsed = 0;
        PriorityQueue<Integer> endsUsed = new PriorityQueue<>();
        PriorityQueue<Integer> endsCanBeUsed = new PriorityQueue<>(Comparator.reverseOrder());
        for (int i = 0, b = 0, l = 0; i < n; ++i) {
            while (!endsUsed.isEmpty() && endsUsed.peek() < i) {
                endsUsed.remove();
                b--;
            }
            while (l < queries.length && queries[l][0] <= i) {
                endsCanBeUsed.add(queries[l][1]);
                l++;
            }
            while (b < nums[i] && !endsCanBeUsed.isEmpty() && endsCanBeUsed.peek() >= i) {
                int r = endsCanBeUsed.remove();
                endsUsed.add(r);
                b++;
                cntUsed++;
            }
            if (b < nums[i]) {
                return -1;
            }
        }
        return queries.length - cntUsed;
    }
}",1460875395
a7174812,a7174812,570,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        vector<vector<long long>> v(26,vector<long long>(26, 1e18));
        for(int i = 0; i < 26; ++i)
            v[i][i] = 0;
        for(int i = 0; i < 26; ++i)
            v[i][(i+1)%26] = nextCost[i];
        for(int i = 0; i < 26; ++i)
            v[i][(i+25)%26] = previousCost[i];
        
        for(int k = 0; k < 26; ++k){
            for(int i = 0; i < 26; ++i){
                for(int j = 0; j < 26; ++j){
                    if(v[i][k]+v[k][j] < v[i][j])
                        v[i][j] = v[i][k] + v[k][j];
                }
            }
        }
        
        for(int i = 0; i < s.size(); ++i){
            // int diff = (t[i] - s[i] + 26) % 26;
            // ans += min(diff * nextCost[i], (26-diff) * previousCost[i]);
            // cout<<diff<<endl;
            ans += v[s[i]-'a'][t[i]-'a'];
        }

        return ans;
    }
};",1460823056
a7174812,a7174812,570,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i = 10 ;i >= 0; --i){
            if(n >= i)
                n -= i;
            else
                return i % 2;
        }

        return 0;
    }
};",1460798445
a7174812,a7174812,570,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        priority_queue<int> pq;

        vector<int> cnt(nums.size() + 1);
        int ans = 0;
        for(int i = 0, j = 0, cur = 0; i < nums.size(); ++i){
            cur += cnt[i];
            while(j < queries.size() && i >= queries[j][0]){
                pq.push(queries[j++][1]+1);
            }
            // cout<<i<<"" ""<<cur;
            while(cur < nums[i]){
                if(pq.empty() || pq.top() <= i)
                    return -1;
                --cnt[pq.top()];
                pq.pop();
                ++cur;
                ++ans;
            }
        }
        return queries.size() - ans;
    }
};",1460869358
username__,username__,571,3591,cpp,"#define ll long long

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& ns, vector<int>& ps) {
        vector<ll> nextsum(26,0);
        vector<ll> prevsum(26,0);
        
        prevsum[0]=ps[0];
        nextsum[0]=ns[0];
        for(int i=1;i<26;i++){
            prevsum[i]=prevsum[i-1]+ps[i];
            nextsum[i]=nextsum[i-1]+ns[i];
        }
        
        ll ans=0;
        
        for(int i=0;i<s.size();i++){
            if(s[i]>t[i]){
                ll one=prevsum[s[i]-'a']-prevsum[t[i]-'a'];
                ll two=nextsum[25]-nextsum[s[i]-'a']+ns[s[i]-'a']+nextsum[t[i]-'a']-ns[t[i]-'a'];
                ans+=min(one,two);
            } 
            else if(s[i]<t[i]){
                ll one=nextsum[t[i]-'a']-nextsum[s[i]-'a']-ns[t[i]-'a']+ns[s[i]-'a'];
                ll two=prevsum[25]-prevsum[t[i]-'a']+prevsum[s[i]-'a'];
                ans+=min(one,two);
            }
        }
        return ans;
        
        
        
        // replace int with long long everywhere
    }
};",1460849600
username__,username__,571,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr=10;
        int pos=1;
        while(n>=0){
            if(n>=curr){
                n-=curr;
                curr--;
                pos*=-1;
            }
            else{
                if(pos>0){
                    return false;
                }
                else{
                    return true;
                }
            }
        }
        return true;
        
        
    }
};",1460812445
username__,username__,571,3647,cpp,"#define ll long long

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        
        vector<vector<ll> > store(100010,vector<ll> ());
        
        for(int i=0;i<q.size();i++){
            store[q[i][0]].push_back(q[i][1]);
        }
        
        multiset<pair<ll,ll> > ms;
        ll si=nums.size();
        vector<ll> cnt(si+2,0);
        
        for(int i=0;i<nums.size();i++){
            for(ll a:store[i]){
                ms.insert({-a,i});
            }
            
            ll left=0;
            if(i!=0){
                cnt[i]+=cnt[i-1];
                left=nums[i]-cnt[i];
            }
            else{
                left=nums[i];
            }
            
            if(left>0){
                if(ms.size() < left){
                    return -1;
                }
                while(left--){
                    pair<ll,ll> p=*ms.begin();
                    ll last=abs(p.first);
                    if(last<i){
                        return -1;
                    }
                    cnt[last+1]--;
                    cnt[i]++;
                    
                    // cout<<last<<"" ""<<p.second<<endl;
                    ms.erase(ms.begin());
                }
            }
            
        }
        
        ll ret=ms.size();
        return ret;
        
        
        
    }
};",1460881711
aarush_2612,aarush_2612,572,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;

        for (int i = 0; i < n; i++) {
            long startIndex = s.charAt(i) - 'a';
            long endIndex = t.charAt(i) - 'a';

            long nextSteps = (endIndex - startIndex + 26) % 26;
            long nextShiftCost = 0;
            for (long j = 0; j < nextSteps; j++) {
                nextShiftCost += nextCost[(int)((startIndex + j) % 26)];
            }

            long prevSteps = (startIndex - endIndex + 26) % 26;
            long prevShiftCost = 0;
            for (long j = 0; j < prevSteps; j++) {
                prevShiftCost += previousCost[(int)((startIndex - j + 26) % 26)];
            }

            totalCost += Math.min(nextShiftCost, prevShiftCost);
        }

        return totalCost;
    }
}",1460856820
aarush_2612,aarush_2612,572,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int currentMove = 10;
        boolean isAliceTurn = true;

        while (n > 0) {
            if (n < currentMove) {
                return !isAliceTurn;
            }
            n -= currentMove;
            currentMove--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
}

",1460812203
aarush_2612,aarush_2612,572,3647,java,"import java.util.*;

public class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        int[] coverage = new int[n + 1];
        updateCoverage(coverage, queries, n);

        if (!isFeasible(coverage, nums, n)) {
            return -1;
        }

        List<int[]> queriesWithId = sortQueries(queries, m);

        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> Integer.compare(b[0], a[0]));
        int[] add = new int[n + 1];
        int currentAdd = 0;
        Set<Integer> selected = new HashSet<>();

        int pointer = 0;
        for (int i = 0; i < n; i++) {
            currentAdd += add[i];

            pointer = addQueriesToHeap(queriesWithId, pointer, i, m, heap);

            removeExpiredQueries(heap, i);

            int currentCoverage = currentAdd;

            if (currentCoverage < nums[i]) {
                int need = nums[i] - currentCoverage;
                for (int j = 0; j < need; j++) {
                    if (heap.isEmpty()) {
                        return -1;
                    }
                    int[] top = heap.poll();
                    int selectedEnd = top[0];
                    int qid = top[1];
                    selected.add(qid);
                    updateCoverageArray(i, selectedEnd, add);
                    currentAdd += 1;
                }
            }
        }

        return m - selected.size();
    }

    private void updateCoverage(int[] coverage, int[][] queries, int n) {
        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }

        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }
    }

    private boolean isFeasible(int[] coverage, int[] nums, int n) {
        for (int i = 0; i < n; i++) {
            if (coverage[i] < nums[i]) {
                return false;
            }
        }
        return true;
    }

    private List<int[]> sortQueries(int[][] queries, int m) {
        List<int[]> queriesWithId = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            queriesWithId.add(new int[] { queries[i][0], queries[i][1], i });
        }
        queriesWithId.sort((a, b) -> {
            if (a[0] == b[0]) {
                return Integer.compare(b[1], a[1]);
            }
            return Integer.compare(a[0], b[0]);
        });
        return queriesWithId;
    }

    private int addQueriesToHeap(List<int[]> queriesWithId, int pointer, int i, int m, PriorityQueue<int[]> heap) {
        while (pointer < m && queriesWithId.get(pointer)[0] <= i) {
            int end = queriesWithId.get(pointer)[1];
            int qid = queriesWithId.get(pointer)[2];
            heap.offer(new int[] { end, qid });
            pointer++;
        }
        return pointer;
    }

    private void removeExpiredQueries(PriorityQueue<int[]> heap, int i) {
        while (!heap.isEmpty() && heap.peek()[0] < i) {
            heap.poll();
        }
    }

    private void updateCoverageArray(int i, int selectedEnd, int[] add) {
        add[i] += 1;
        if (selectedEnd + 1 < add.length) {
            add[selectedEnd + 1] -= 1;
        }
    }
}
",1460848054
NoskiDibacha,NoskiDibacha,573,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:


        res = 0

        for i in range(len(s)):

            x = s[i]
            cur = 0
            while (x!=t[i]):
                cur += nextCost[ord(x)-97]
                x = chr(ord(x)+1)
                if (ord(x)==123):
                    x = 'a'
            cur2 = 0
            x = s[i]
            while (x!=t[i]):
                cur2 += previousCost[ord(x)-97]
                x = chr(ord(x)-1)
                if (ord(x)==96):
                    x = 'z'
            res += min(cur,cur2)
        return res
                ",1460808040
NoskiDibacha,NoskiDibacha,573,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:

        cur = 10
        cur2 = 0
        while (n):
            n-=cur
            if (n==0):
                if (cur2==0):
                    return True
                else:
                    return False
            elif(n<0):
                if (cur2==1):
                    return True
                else:
                    return False
            cur-=1
            cur2+=1
            if (cur2==2):
                cur2 = 0
        return True",1460797534
NoskiDibacha,NoskiDibacha,573,3647,cpp,"class Solution {
public:
    int ends[100007];
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {

        int l = 0, r = q.size();
        sort(q.begin(),q.end());
        int res = -1;
        while (l<=r)
        {
            int mid = (l+r)/2;
            int mid2 = mid;
            priority_queue<pair<int,int>> q2;
            int cur = 0;
            int cur2 = 0;
            for (int i=0;i<nums.size();i++)
            {
                ends[i] = 0;
            }
            bool da2 = true;
            for (int i=0;i<nums.size();i++)
            {
                
                while (cur2<q.size() && q[cur2][0]<=i)
                {
                    if (q[cur2][1]>=i) q2.push({q[cur2][1],q[cur2][0]});
                    cur2++;
                }
                int cur3 = cur;
                for (int j=0;j<nums[i]-cur3;j++)
                {
                    bool da = false;
                    while (!q2.empty())
                    {
                        pair<int,int> k;
                        k = q2.top();
                        q2.pop();
                        if (k.second<=i && k.first>=i) {ends[k.first]+=1;cur++;mid--;da=true;break;}
                    }
                    if (da==false || mid<0)
                    {
                        da2=false;
                        break;
                    }
                }  
                cur-=ends[i];
            }
            if (da2==true)
            {
                r = mid2-1;
                res = mid2;
            }
            else
            {
                l = mid2+1;
            }
        }
        if (res==-1) return -1;
        return q.size()-res;
        
    }
};",1460876051
Ramderoy,Ramderoy,577,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nC, vector<int>& pC) {
        long long maxi= 0;
        int l = s.length();
        for (int j=false; j< l; j++) {
            int a = s[j] - 'a';
            int b = t[j] - 'a';
            int fD = (b - a + 26) % 26;
            long long fC =false;
            for (int i=0;i<fD; i++) {
                fC += nC[(a+i+(1-1)) % 26];
            }
            int bD = (a - b + 26) % 26;
            long long bC = 0;
            for (int i=false; i<bD; i++) {
                bC += pC[(a-i+ 26)%26];
            }
            maxi+= min(fC,bC);
        }
        return maxi;
    }
};
",1460840597
Ramderoy,Ramderoy,577,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) return false;
        n -= 10;
        if (n < 9) return true;
        n -= 9;
        if (n < 8) return false;
        n -= 8;
        if (n < 7) return true;
        n -= 7;
        if (n < 6) return false;
        n -= 6;
        if (n < 5) return true;
        n -= 5;
        if (n < 4) return false;
        n -= 4;
        if (n < 3) return true;
        n -= 3;
        if (n < 2) return false;
        n -= 2;
        if (n < 1) return true;
        n -= 1;
        return false;
    }
};",1460818715
Ramderoy,Ramderoy,577,3647,java,"class Solution {
    static class SegmentTree {
        int n;
        int[] t, lz;

        public SegmentTree(int sz) {
            n = sz;
            t = new int[4 * n];
            lz = new int[4 * n];
            Arrays.fill(t, 0);
            Arrays.fill(lz, 0);
        }

        private void propagate(int nd, int l, int r) {
            if (lz[nd] != 0) {
                t[nd] += lz[nd];
                if (l != r) {
                    lz[2 * nd] += lz[nd];
                    lz[2 * nd + 1] += lz[nd];
                }
                lz[nd] = 0;
            }
        }

        public void build(int[] a, int nd, int l, int r) {
            propagate(nd, l, r);
            if (l == r) {
                t[nd] = a[l];
            } else {
                int m = 0+l + (r - l) / 2;
                build(a, 2 * nd, l, m); // Corrected multiplication here
                build(a, 2 * nd + 1, m + 1, r);
                t[nd] = Math.min(t[2 * nd], t[2 * nd + 1]); // Corrected child references
            }
        }

        public int query(int nd, int l, int r, int ql, int qr) {
            propagate(nd, l, r);
            if (qr < l || ql > r) return Integer.MAX_VALUE;
            if (ql <= l && r <= qr) return t[nd];
            int m = l + 0+(r - l) / 2;
            return Math.min(query(2 * nd, l, m, ql, qr), // Corrected indices
                    query(2 * nd + 1, m + 1, r, ql, qr));
        }

        public void decrement(int nd, int l, int r, int ql, int qr) {
            propagate(nd, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lz[nd] -= 1;
                propagate(nd, l, r);
                return;
            }
            int m = l + 0+(r - l)/ 2;
            decrement(2 * nd, l, m, ql, qr);
            decrement(2 * nd + 1, m + 1, r, ql, qr);
            t[nd] = Math.min(t[2 * nd], t[2 * nd + 1]);
        }
    }

    public int maxRemoval(int[] a, int[][] q) {
        int n = a.length, m = q.length;
        int[] c = new int[n + 1];
        Arrays.fill(c, 0);

        for (int[] v : q) {
            int l = v[0], r = v[1];
            c[l]++;
            if (r + 1 < n) c[r + 1]--;
        }
        for (int i =1; i < n; i++) c[i] += c[i - 1];
        int[] al = new int[n];
        for (int i =0; i < n; i++) {
            al[i] = c[i] - a[i];
            if (al[i] < 0) return -1;
        }

        List<int[]> sq = new ArrayList<>(Arrays.asList(q));
        sq.sort((x, y) -> {
            int lx = x[1] - x[0] + 1, ly = y[1] - y[0] + 1;
            if (lx != ly) return Integer.compare(lx, ly);
            return Integer.compare(x[0], y[0]);
        });

        SegmentTree st = new SegmentTree(n);
        st.build(al, 1+0, 0, n - 1);

        int rm = 0;
        for (int[] range : sq) {
            int l = range[0], r = range[1];
            int cm = st.query(1+0, 0, n - 1, l, r);
            if (cm >= 1) {
                st.decrement(1+0, 0, n - 1, l, r);
                rm+=1;
            }
        }
        return rm;
    }
}
",1460872246
Aman Sarraf,voldemort007,578,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        for i in range(len(s)):
            x = ord(s[i]) - ord('a')
            y = ord(t[i]) - ord('a')
            
            nc = pc = 0
            j = x
            while j != y:
                nc += nextCost[j]
                j += 1
                j %= 26
            
            j = x
            while j != y:
                pc += previousCost[j]
                j -= 1
                j %= 26
            res += min(nc, pc)
            
        return res",1460821134
Aman Sarraf,voldemort007,578,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rem = 10
        i = 0
        while n >= rem:
            n -= rem
            rem -= 1
            i += 1
        return True if i % 2 else False",1460798025
Aman Sarraf,voldemort007,578,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)

        q = sorted(queries)
        heap = []
        
        # store delta sum
        deltasum = [0] * (n + 1)
        
        res = 0
        j = 0
        
        for i in range(len(nums)):
            # print(i)
            if i > 0:
                deltasum[i] += deltasum[i - 1]

            while j < len(q) and q[j][0] <= i:
                heapq.heappush(heap, -q[j][1])
                j += 1

            req = max(nums[i] - deltasum[i], 0)
            hi = 0
            while hi < req:
                if len(heap) == 0: return -1

                reach = -heapq.heappop(heap)
                
                if reach < i:
                    hi -= 1
                    continue
                
                deltasum[reach + 1] -= 1
                hi += 1
                res += 1
                deltasum[i] += 1
            # print()
            
        return len(q) - res
        
            ",1460878356
Irfan Ukani,irfanukani,580,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int i = 0; i < s.length(); i++) {
            if(s[i] == t[i]) continue;
            char c = s[i];
            long long next = 0;
            while(c != t[i]) {
                next += nextCost[c - 'a'];
                if(c == 'z') c = 'a';
                else c += 1;
            }

            c = s[i];
            long long prev = 0;
            while(c != t[i]) {
                prev += previousCost[c - 'a'];
                if(c == 'a') c = 'z';
                else c -= 1;
            }
            
            ans = ans + min(next, prev);
        }
        return ans;
    }
};",1460810163
Irfan Ukani,irfanukani,580,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10;
        bool alice = false;
        while(n >= remove) {
            n = n - remove;
            remove -= 1;
            alice = !alice;
        }
        return alice;
    }
};",1460796275
Irfan Ukani,irfanukani,580,3647,cpp,"class SegmentTree {
private:
    vector<int> tree, lazy;
    int size;

    void buildTree(const vector<int>& arr, int start, int end, int node) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            buildTree(arr, start, mid, 2 * node + 1);
            buildTree(arr, mid + 1, end, 2 * node + 2);
            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);
        }
    }

    void updateRangeUtil(int start, int end, int l, int r, int value, int node) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (start != end) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }

        if (start > end || start > r || end < l) {
            return;
        }

        if (start >= l && end <= r) {
            tree[node] += value;
            if (start != end) {
                lazy[2 * node + 1] += value;
                lazy[2 * node + 2] += value;
            }
            return;
        }

        int mid = (start + end) / 2;
        updateRangeUtil(start, mid, l, r, value, 2 * node + 1);
        updateRangeUtil(mid + 1, end, l, r, value, 2 * node + 2);
        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);
    }

    int rangeMaxUtil(int start, int end, int l, int r, int node) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (start != end) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }

        if (start > end || start > r || end < l) {
            return INT_MIN;
        }

        if (start >= l && end <= r) {
            return tree[node];
        }

        int mid = (start + end) / 2;
        return max(rangeMaxUtil(start, mid, l, r, 2 * node + 1), rangeMaxUtil(mid + 1, end, l, r, 2 * node + 2));
    }

public:
    SegmentTree(const vector<int>& arr) {
        size = arr.size();
        tree.resize(4 * size);
        lazy.resize(4 * size, 0);
        buildTree(arr, 0, size - 1, 0);
    }

    void updateRange(int l, int r, int value) {
        updateRangeUtil(0, size - 1, l, r, value, 0);
    }

    int rangeMax(int l, int r) {
        return rangeMaxUtil(0, size - 1, l, r, 0);
    }
};

static bool comp(vector<int> &v1, vector<int> &v2) {
    if(v1[1] - v1[0] == v2[1] - v2[0]) {
        return v1[0] < v2[0];
    }
    return v1[1] - v1[0] > v2[1] - v2[0];
}

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(begin(queries), end(queries), comp);
        SegmentTree st(nums);

        for(auto &x: queries){
            st.updateRange(x[0], x[1], -1);
        }
        if(st.rangeMax(0, nums.size() - 1) > 0) return -1;
        reverse(begin(queries), end(queries));
        int rm = 0;
        for(auto &x: queries){
            if(st.rangeMax(x[0], x[1]) < 0) {
                rm += 1;
                st.updateRange(x[0], x[1], 1);
            }
        }
        
        return rm;
    }
};",1460884383
Mohit Kanodia,yoda_codiyapa,581,3591,java,"class Solution {
    List<List<int[]>> list;
    long MAX = Long.MAX_VALUE;
    
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        int n = s.length();

        list = new ArrayList<>();
        for(int i = 0; i < 26; i++) {
            list.add(new ArrayList<>());
        }

        for(int i = 0; i < 26; i++) {
            int x = i;
            int y = (i+1)%26;
            list.get(x).add(new int[]{y, nextCost[i]});

            int y2 = (i-1+26)%26;
            list.get(x).add(new int[]{y2, previousCost[i]});
        }

        long[][] cost = new long[26][26];
        for(int i = 0; i < 26; i++) {
            cost[i] = dij(i);
        }
        
        for(int i = 0; i < n; i++) {
            int c = s.charAt(i) - 'a';
            int x = t.charAt(i) - 'a';

            ans += cost[c][x];
        }
        return ans;
    }

    long[] dij(int c) {
        long[] cost = new long[26];
        Arrays.fill(cost, MAX);
        
        PriorityQueue<long[]> pq = new PriorityQueue<>((x, y) -> Long.compare(x[1], y[1]));
        pq.add(new long[]{c, 0});
        
        while(!pq.isEmpty()) {
            long[] curr = pq.remove();
            int node = (int)curr[0];
            long cd = curr[1];
            
            if(cost[node] <= cd) {
                continue;
            }
            cost[node] = cd;

            for(int[] e : list.get(node)) {
                pq.add(new long[]{e[0], cd + 1L*e[1]});
            }
        }
        
        return cost;
    }
}",1460841012
Mohit Kanodia,yoda_codiyapa,581,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int t = 0;
        int curr = 10;
        while(n > 0) {
            if(n < curr) {
                return t == 1;
            }
            n -= curr;
            curr--;
            t = t^1;
        }
        return t == 1;
    }
}",1460803330
Mohit Kanodia,yoda_codiyapa,581,3647,java,"class Solution {
      public int maxRemoval(int[] nums, int[][] queries) {
        int ans = 0;
        int n = nums.length;
        int q = queries.length;

        Arrays.sort(queries, (x, y) -> {
          if (x[0] == y[0]) {
            return x[1] - y[1];
          }
          return x[0] - y[0];
        });

        LazySegmentTree sgt = new LazySegmentTree(nums);
        PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> {
          return y[1] - x[1]; // end maximum
        });

        int j = 0;
        for (int i = 0; i < n; i++) {
          while (j < q && queries[j][0] <= i) {
            pq.add(queries[j]);
            j++;
          }

          int curr = (int) sgt.query(i, i);
          if (curr <= 0) {
            continue;
          }

          while (curr > 0 && !pq.isEmpty()) {
            int[] x = pq.remove();
            if (x[1] < i) {
              continue;
            }
            sgt.update(x[0], x[1], -1);
            curr = (int) sgt.query(i, i);
            ans++;
          }

          curr = (int) sgt.query(i, i);
          if (curr > 0) {
            return -1;
          }
        }
        return q - ans;
      }

      public class LazySegmentTree {

        int n;
        int[] a;
        long[] s;
        long[] lazy;

        public LazySegmentTree(int[] a) {
          this.a = a;
          this.n = a.length;
          this.s = new long[4 * n];
          this.lazy = new long[4 * n];
          build(1, 0, n - 1);
        }

        void build(int v, int st, int ed) {
          if (st == ed) {
            s[v] = a[st];
            return;
          }

          int mid = st + (ed - st) / 2;
          build(2 * v, st, mid);
          build(2 * v + 1, mid + 1, ed);
          s[v] = merge(s[2 * v], s[2 * v + 1]);
        }

        long merge(long l, long r) {
          return l + r;
        }

        void update(int l, int r, int val) {
          update(1, 0, n - 1, l, r, val);
        }

        private void update(int v, int st, int ed, int l, int r, int val) {
          push(v, st, ed);

          // disjoint
          // l r st ed
          // st ed l r
          if (r < st || l > ed) {
            return;
          }

          // overlap
          // l st ed r
          if (l <= st && ed <= r) {
            lazy[v] += val;
            push(v, st, ed);
            return;
          }

          int mid = st + (ed - st) / 2;
          update(2 * v, st, mid, l, r, val);
          update(2 * v + 1, mid + 1, ed, l, r, val);

          s[v] = merge(s[2 * v], s[2 * v + 1]);
        }

        long query(int l, int r) {
          return query(1, 0, n - 1, l, r);
        }

        private long query(int v, int st, int ed, int l, int r) {
          push(v, st, ed);

          // disjoint
          // l r st ed
          // st ed l r
          if (r < st || l > ed) {
            return 0;
          }

          // overlap
          // l st ed r
          if (l <= st && ed <= r) {
            return s[v];
          }

          int mid = st + (ed - st) / 2;
          long left = query(2 * v, st, mid, l, r);
          long right = query(2 * v + 1, mid + 1, ed, l, r);
          long ans = merge(left, right);
          return ans;
        }

        void push(int v, int st, int ed) {
          long val = lazy[v];
          lazy[v] = 0;
          s[v] += (ed - st + 1) * val;

          if (st == ed) {
            return;
          }
          lazy[2 * v] += val;
          lazy[2 * v + 1] += val;
        }
      }
    }",1460885131
Devansh,devansh5398,582,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long res = 0;
        for (int i = 0; i < n; ++i) {
            int x = s[i]-'a', y = t[i]-'a';
            
            long long val = 0, ans = 1e15;
            if (y >= x) {
                val = 0;
                for (int j = x; j < y; ++j)
                    val += nextCost[j];
                ans = min(ans, val);
                
                val = 0;
                for (int j = x; j >= 0; --j)
                    val += previousCost[j];
                for (int j = 25; j > y; --j)
                    val += previousCost[j];
                ans = min(ans, val);
            } else {
                val = 0;
                for (int j = x; j > y; --j)
                    val += previousCost[j];
                ans = min(ans, val);
                
                val = 0;
                for (int j = x; j < 26; ++j)
                    val += nextCost[j];
                for (int j = 0; j < y; ++j)
                    val += nextCost[j];
                ans = min(ans, val);
            }
            
            res += ans;
        }
        
        return res;
    }
};",1460818058
Devansh,devansh5398,582,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int st = 10;
        bool alice = true;
        while (n >= st) {
            n -= st;
            st -= 1;
            alice = !alice;
        }
        
        return !alice;
    }
};",1460797508
Devansh,devansh5398,582,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<vector<int>> arr(n+1);
        for (int i = 0; i < (int)queries.size(); ++i) {
            int l = queries[i][0], r = queries[i][1];
            arr[l].push_back(r);
        }
        
        // priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > imp, oth;
        multiset<int> imp, oth;
        int res = 0;
        for (int i = 0; i < n; ++i) {
            while (!imp.empty()) {
                auto fr = imp.begin();
                if (*fr < i)        imp.erase(fr);
                else                break;
            }
            
            while (!oth.empty()) {
                auto fr = oth.begin();
                if (*fr < i) {      oth.erase(fr);      res += 1;       }
                else                break;
            }
            
            for (auto rr: arr[i])
                oth.insert(rr);
            
            // for (auto &xx: oth)     cout << xx << "" "";  cout << endl;
            
            while ((int)imp.size() < nums[i]) {
                if (oth.empty())
                    return -1;
                auto en = prev(oth.end());
                imp.insert(*en);
                oth.erase(en);
            }
        }
        
        res += (int)oth.size();
        return res;
    }
};",1460891235
Ayush Nishad,ayush_nishad,583,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for(int i=0;i<n;i++) {
            long long left_n = (s[i] - t[i] + 26)%26;
            long long right_n = (t[i] - s[i] + 26)%26;
            long long left_sum = 0, right_sum = 0;
            int left_idx = i, right_idx = i;
            char now = s[i];
            while(left_n-->0){
                left_sum+=previousCost[now - 'a'];
                if(now == 'a')
                    now = 'z';
                else 
                    now--;
            }
            now = s[i];
            while(right_n-->0){
                right_sum+=nextCost[now - 'a'];
                if(now == 'z')
                    now = 'a';
                else 
                    now++;
            }
            ans += min(left_sum , right_sum);
        }
        return ans;
    }
};",1460835751
Ayush Nishad,ayush_nishad,583,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool turn = 0;
        int take = 10;
        while(take and n - take >=0) {
            n-= take--;
            turn ^=1;
        }
        return turn;
    }
};",1460799582
Ayush Nishad,ayush_nishad,583,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(),queries.end());
        int n = nums.size(), q_n = queries.size(), q_idx = 0;
        priority_queue<int>mx, mn;
        int used = 0, window = 0;
        for(int i=0;i<n;i++) {
            while(q_idx < q_n and queries[q_idx][0] <= i){
                cout<<""PUSH ""<<i<<' '<<queries[q_idx][1]<<endl;
                mx.push(queries[q_idx++][1]);
            }
            int now = nums[i] - window;
            while(nums[i] - window > 0){
                if(mx.empty() or mx.top() < i)return -1;
                mn.push(-mx.top()),mx.pop(),window++,used++;
            }
            while(mn.size() and -mn.top() <= i){
                cout<<""POP ""<<i<<' '<<-mn.top()<<endl;
                mn.pop(),window--;
            }
        }
        return q_n - used;
    }
};",1460867548
Anupam Shah,user9218i,584,3591,cpp,"class Solution {
public:
    typedef long long int ll;
    
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        
        
        vector<vector<ll>> l(26, vector<ll> (26, 0));
        vector<vector<ll>> r(26, vector<ll> (26, 0));
        
        for(int i = 0; i < 26; i ++) {
            for(int j = 0; j < 26; j ++) {    
                if(i <= j) {
                    for(int k = i; k < j; k ++) {
                        r[i][j] += (ll)nextCost[k];
                    }
                }
                else {
                    for(int k = i; k < 26; k ++) {
                        r[i][j] += (ll)nextCost[k];
                    }
                    for(int k = 0; k < j; k ++) {
                        r[i][j] += (ll)nextCost[k];
                    }
                }
                
                if(i >= j) {
                    for(int k = i; k > j; k --) {
                        l[i][j] += (ll)previousCost[k];
                    }
                }
                else {
                    for(int k = i; k >= 0; k --) {
                        l[i][j] += (ll)previousCost[k];
                    }
                    for(int k = 25; k > j; k --) {
                        l[i][j] += (ll)previousCost[k];
                    }
                }
                
            }
        }
        ll ans = 0;
        for(int i = 0; i < s.length(); i ++) {
            if(s[i] == t[i])    continue;
            ans += min(l[s[i]-'a'][t[i] - 'a'], r[s[i]-'a'][t[i] - 'a']);
        }
        return ans;
    }
};",1460813126
Anupam Shah,user9218i,584,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr = 10, t = 1;
        while(n) {
            if(n >= curr) {
                n -= curr;
                curr --;
            }
            else {
                break;
            }
            t ^= 1;
        }
        if(t == 1)      return 0;
        return 1;
    }
};",1460797462
Anupam Shah,user9218i,584,3647,java,"import java.util.*;

class Solution {
    public static boolean cmp(int[] v1, int[] v2) {
        if (v1[1] - v1[0] < v2[1] - v2[0]) return true;
        if (v1[1] - v1[0] > v2[1] - v2[0]) return false;
        return v1[0] <= v2[0];
    }

    public void update(int low, int high, int pos, int qlow, int qhigh, int qval, int[] lazy, int[] tree) {
        if (lazy[pos] != 0) {
            tree[pos] += lazy[pos];
            if (low != high) {
                lazy[2 * pos + 1] += lazy[pos];
                lazy[2 * pos + 2] += lazy[pos];
            }
            lazy[pos] = 0;
        }
        if (qlow <= low && high <= qhigh) {
            tree[pos] += qval;
            if (low != high) {
                lazy[2 * pos + 1] += qval;
                lazy[2 * pos + 2] += qval;
            }
            return;
        }
        if (qlow > high || qhigh < low) return;
        int mid = (low + high) >> 1;
        update(low, mid, 2 * pos + 1, qlow, qhigh, qval, lazy, tree);
        update(mid + 1, high, 2 * pos + 2, qlow, qhigh, qval, lazy, tree);
        tree[pos] = Math.min(tree[2 * pos + 1], tree[2 * pos + 2]);
    }

    public int query(int low, int high, int pos, int qlow, int qhigh, int[] lazy, int[] tree) {
        if (lazy[pos] != 0) {
            tree[pos] += lazy[pos];
            if (low != high) {
                lazy[2 * pos + 1] += lazy[pos];
                lazy[2 * pos + 2] += lazy[pos];
            }
            lazy[pos] = 0;
        }
        if (qlow <= low && high <= qhigh) {
            return tree[pos];
        }
        if (qlow > high || qhigh < low) return (int) 5e5;
        int mid = (low + high) >> 1;
        return Math.min(query(low, mid, 2 * pos + 1, qlow, qhigh, lazy, tree),
                query(mid + 1, high, 2 * pos + 2, qlow, qhigh, lazy, tree));
    }

    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int[] f = new int[n + 2];

        Arrays.sort(queries, (a, b) -> {
            if (a[1] - a[0] < b[1] - b[0]) return -1;
            if (a[1] - a[0] > b[1] - b[0]) return 1;
            return Integer.compare(a[0], b[0]);
        });

        for (int[] it : queries) {
            int l = it[0], r = it[1];
            f[l]++;
            f[r + 1]--;
        }

        int[] tree = new int[5 * n + 5];
        int[] lazy = new int[5 * n + 5];

        for (int i = 0; i < n; i++) {
            if (i > 0) f[i] += f[i - 1];
            if (f[i] < nums[i]) return -1;
            if (f[i] > nums[i]) {
                update(0, n - 1, 0, i, i, f[i] - nums[i], lazy, tree);
            }
        }

        int ans = 0;
        for (int[] it : queries) {
            int l = it[0], r = it[1];
            int xx = query(0, n - 1, 0, l, r, lazy, tree);
            if (xx != 0) {
                ans++;
                update(0, n - 1, 0, l, r, -1, lazy, tree);
            }
        }

        return ans;
    }
}
",1460880176
sohailkasmani007,sohailkasmani007,585,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.size();i++){
            if(s[i]==t[i]) continue;
            else{
                long long prev=0;
                long long next=0;
                char c=s[i];
                while(c!=t[i]){
                    next+=nextCost[c-'a'];
                    if(c=='z') c='a';
                    else c++;
                }
                c=s[i];
                while(c!=t[i]){
                    prev+=previousCost[c-'a'];
                    if(c=='a') c='z';
                    else c--;
                }
                ans+=min(next,prev);
                
            }
        }
        return ans;
    }
};",1460814424
sohailkasmani007,sohailkasmani007,585,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int flag=0;
        int curr=10;
        while(n>=0){
            if(n-curr>=0){
                flag^=1;
                n-=curr;
                curr--;
                
            }
            else if(flag==1) return true;
            else return false;
        }
        return false;
    }
};",1460801043
sohailkasmani007,sohailkasmani007,585,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(),queries.end());
        priority_queue<pair<int,int>> pq;
        vector<int> tracker(nums.size(),0);
        int curr=0;
        int ind=0;
        int ans=0;
        for(int i=0;i<nums.size();i++){
            while(ind<queries.size() && queries[ind][0]<=i){
                pq.push({queries[ind][1],queries[ind][0]});
                ind++;
            }
            curr+=tracker[i];
            // cout<<curr<<endl;
            if(nums[i]==0 || nums[i]<=curr){
                continue;
            }
            else{
                while(pq.size()>0 && pq.top().first>=i){
                    ans++;
                    curr++;
                    if(pq.top().first!=nums.size()-1){
                        tracker[pq.top().first+1]-=1;                      
                    }
                    pq.pop();
                    if(curr>=nums[i]) break;
                }
                if(curr<nums[i]) return -1;
            }
        }
        return queries.size()-ans;
    }   
};",1460886172
Rushikesh Kulkarni,The_2nd_Derivative,586,3591,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// Debugging for std::set<int, std::greater<int>> (custom comparator)
template<class T>
std::ostream& operator<<(std::ostream& os, std::set<T, std::greater<T>>& S) {
    os << ""[ "";
    for (auto s : S) os << s << "" "";
    return os << ""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::multiset
template<class T> std::ostream& operator<<(std::ostream& os,std::multiset<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// Debugging for std::set<int, std::greater<int>> (custom comparator)
template<class T>
std::ostream& operator<<(std::ostream& os, std::multiset<T, std::greater<T>>& S) {
    os << ""[ "";
    for (auto s : S) os << s << "" "";
    return os << ""]"";
}
// std::stack FUN
template <class T>
void F_Stack(std::stack<T> st, std::string& cont) {
    if (st.empty()) return;
    T mem = st.top();
    st.pop();
    F_Stack(st, cont);
    // Use stringstream to handle any type T
    std::stringstream ss;
    ss << mem;
    cont += "" "" + ss.str();
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}
// Debugging for std::deque
template<class T>
std::ostream& operator<<(std::ostream& os, std::deque<T>& D) {
    os << ""[ "";
    for (auto& d : D) os << d << "" "";
    return os << ""]"";
}
// dbg std::std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// Debugging for max-heap (default priority queue)
template <class T>
void F_PriorityQueue(std::priority_queue<T> pq, std::string& cont) {
    while (!pq.empty()) {
        T mem = pq.top();
        pq.pop();
        
        // Use stringstream for general types
        std::stringstream ss;
        ss << mem;
        cont += "" "" + ss.str();
    }
}

// Debugging for min-heap (custom comparator)
template <class T>
void F_MinPriorityQueue(std::priority_queue<T, std::vector<T>, std::greater<T>> pq, std::string& cont) {
    while (!pq.empty()) {
        T mem = pq.top();
        pq.pop();
        
        // Use stringstream for general types
        std::stringstream ss;
        ss << mem;
        cont += "" "" + ss.str();
    }
}

// Debug function for priority queue (max-heap)
template<class T>
std::ostream& operator<<(std::ostream& os, std::priority_queue<T> pq) {
    os << ""["";
    std::string cont = """";
    F_PriorityQueue(pq, cont);
    return os << cont << "" ]"";
}

// Debug function for min-heap priority queue
template<class T>
std::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> pq) {
    os << ""["";
    std::string cont = """";
    F_MinPriorityQueue(pq, cont);
    return os << cont << "" ]"";
}


// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}


// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;
using vl = vector<int>;
using vvl = vector<vl>;
using vvvl = vector<vvl>;
using vvpii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e12;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        ll n = sz(s);
        ll ans = 0;
        for (int i = 0; i < n; i++){
            if (s[i] == t[i])
                continue;
            
            ll mn = INF;
            {
                ll p = s[i] - 'a', q = t[i] - 'a', cost = 0;
                while (p != q) {
                    cost += nc[p];
                    p = (p + 1) % 26;
                }    
                chmin(mn, cost);
            }
            
            {
                ll p = s[i] - 'a', q = t[i] - 'a', cost = 0;
                while (p != q) {
                    cost += pc[p];
                    p = (((p - 1) % 26) + 26) % 26;
                }    
                chmin(mn, cost);
            }
            // dbg(i, s[i], t[i], mn);
            ans += mn;
            
        }
        return ans;
    }
};",1460842550
Rushikesh Kulkarni,The_2nd_Derivative,586,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = true;
        int cur = 10;
        while(n >= cur){
            n -= cur;
            alice = !alice;
            cur--;
        }
        return !alice;
    }
};",1460798663
Rushikesh Kulkarni,The_2nd_Derivative,586,3647,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// Debugging for std::set<int, std::greater<int>> (custom comparator)
template<class T>
std::ostream& operator<<(std::ostream& os, std::set<T, std::greater<T>>& S) {
    os << ""[ "";
    for (auto s : S) os << s << "" "";
    return os << ""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::multiset
template<class T> std::ostream& operator<<(std::ostream& os,std::multiset<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// Debugging for std::set<int, std::greater<int>> (custom comparator)
template<class T>
std::ostream& operator<<(std::ostream& os, std::multiset<T, std::greater<T>>& S) {
    os << ""[ "";
    for (auto s : S) os << s << "" "";
    return os << ""]"";
}
// std::stack FUN
template <class T>
void F_Stack(std::stack<T> st, std::string& cont) {
    if (st.empty()) return;
    T mem = st.top();
    st.pop();
    F_Stack(st, cont);
    // Use stringstream to handle any type T
    std::stringstream ss;
    ss << mem;
    cont += "" "" + ss.str();
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}
// Debugging for std::deque
template<class T>
std::ostream& operator<<(std::ostream& os, std::deque<T>& D) {
    os << ""[ "";
    for (auto& d : D) os << d << "" "";
    return os << ""]"";
}
// dbg std::std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// Debugging for max-heap (default priority queue)
template <class T>
void F_PriorityQueue(std::priority_queue<T> pq, std::string& cont) {
    while (!pq.empty()) {
        T mem = pq.top();
        pq.pop();
        
        // Use stringstream for general types
        std::stringstream ss;
        ss << mem;
        cont += "" "" + ss.str();
    }
}

// Debugging for min-heap (custom comparator)
template <class T>
void F_MinPriorityQueue(std::priority_queue<T, std::vector<T>, std::greater<T>> pq, std::string& cont) {
    while (!pq.empty()) {
        T mem = pq.top();
        pq.pop();
        
        // Use stringstream for general types
        std::stringstream ss;
        ss << mem;
        cont += "" "" + ss.str();
    }
}

// Debug function for priority queue (max-heap)
template<class T>
std::ostream& operator<<(std::ostream& os, std::priority_queue<T> pq) {
    os << ""["";
    std::string cont = """";
    F_PriorityQueue(pq, cont);
    return os << cont << "" ]"";
}

// Debug function for min-heap priority queue
template<class T>
std::ostream& operator<<(std::ostream& os, std::priority_queue<T, std::vector<T>, std::greater<T>> pq) {
    os << ""["";
    std::string cont = """";
    F_MinPriorityQueue(pq, cont);
    return os << cont << "" ]"";
}


// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}


// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;
using vl = vector<int>;
using vvl = vector<vl>;
using vvvl = vector<vvl>;
using vvpii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e12;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        ll n = sz(nums), q = sz(queries);
        vvi v(n);
        for (auto &it : queries)
            v[it[0]].pb(it[1]);
        
        priority_queue<ll> pq;
        ll minus = 0, use = 0;
        vector<ll> at(n + 1, 0);
        for (int i = 0; i < n; i++) {
            for (auto j : v[i])
                pq.push(j);
            minus -= at[i];
            ll cur = nums[i];
            // dbg(minus, cur, use, at);
            while (cur - minus > 0 && !pq.empty()) {
                auto end = pq.top(); pq.pop();
                if (end < i)
                    continue;
                // dbg(""using upto"", end);
                minus++;
                use++;
                at[end + 1]++;
            }
            if (cur - minus > 0)
                return -1;
        }
        return q - use;
    }   
};",1460880431
cm_fast,cm_fast,587,3591,cpp,"const int mod = 1e9 + 7;
void helper(vector<vector<long long>> &dp)
{
    for (int k = 0; k < 26; k++)
    {
        for (int i = 0; i < 26; i++)
        {
            for (int j = 0; j < 26; j++)
            {
                if (dp[i][k] + dp[k][j] < dp[i][j])
                {
                    dp[i][j] = dp[i][k] + dp[k][j];
                }
            }
        }
    }
}
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int add(int x, int y)
{
    x += y;
    while (x >= mod)
        x -= mod;
    while (x < 0)
        x += mod;
    return x;
}

int mul(int x, int y)
{
    return (x * y) % mod;
}

int binpow(int x, int y)
{
    int z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

int inv(int x)
{
    return binpow(x, mod - 2);
}

int divide(int x, int y)
{
    return mul(x, inv(y));
}
class Solution
{
public:
    long long shiftDistance(string s, string t, vector<int> &v1, vector<int> &v2)
    {
        vector<vector<long long>> dp(26, vector<long long>(26, 1e18));
        for (int i = 0; i < 26; i++)
        {
            dp[i][i] = 0;
            int nx = i + 1;
            if (nx == 26)
            {
                nx = 0;
            }
            dp[i][nx] = min((long long)dp[i][nx], (long long)v1[i]);
            int lst = i - 1;
            if (lst < 0)
            {
                lst = 25;
            }
            dp[i][lst] = min((long long)dp[i][lst], (long long)v2[i]);
        }
        helper(dp);
        long long ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++)
        {
            int val1 = s[i] - 'a';
            int val2 = t[i] - 'a';
            if (dp[val1][val2] == 1e18)
            {
                return -1;
            }
            ans += dp[val1][val2];
        }
        return ans;
    }
};
",1460822360
cm_fast,cm_fast,587,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int st=10;
        int turn=0;
        while( (n>=st) && (st>0)) 
        {
            n-=st;
            st--;
            turn++;
            if(st<=0)
            {
                break;
            }
        }
        
        if(turn%2)
        {
            return true;
        }
        return false;
    }
};",1460798950
cm_fast,cm_fast,587,3647,cpp,"#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    struct SegmentTree {
        int n;
        vector<int> tree;
        vector<int> lazy;

        SegmentTree(int size) : n(size), tree(4*size, 0), lazy(4*size, 0) {}

        // Build the segment tree with 0-based indexing
        void build(vector<int>& data, int node, int l, int r){
            if(l == r){
                tree[node] = data[l];
                return;
            }
            int mid = (l + r) / 2;
            build(data, 2*node +1, l, mid);
            build(data, 2*node +2, mid+1, r);
            tree[node] = min(tree[2*node +1], tree[2*node +2]);
        }

        // Push down the lazy updates to child nodes
        void push_down(int node, int l, int r){
            if(lazy[node] > 0){
                int mid = (l + r) / 2;
                // Update left child
                tree[2*node +1] = max(0, tree[2*node +1] - lazy[node]);
                lazy[2*node +1] += lazy[node];
                // Update right child
                tree[2*node +2] = max(0, tree[2*node +2] - lazy[node]);
                lazy[2*node +2] += lazy[node];
                // Clear the lazy value at current node
                lazy[node] = 0;
            }
        }

        // Query the minimum value in the range [L, R]
        int query_min(int node, int l, int r, int L, int R){
            if(R < l || L > r) return INT32_MAX;
            if(L <= l && r <= R) return tree[node];
            push_down(node, l, r);
            int mid = (l + r) / 2;
            return min(query_min(2*node +1, l, mid, L, R),
                       query_min(2*node +2, mid+1, r, L, R));
        }

        // Decrement the values in the range [L, R] by 1, ensuring they don't go below 0
        void update_decrement(int node, int l, int r, int L, int R){
            if(R < l || L > r) return;
            if(L <= l && r <= R){
                tree[node] = max(0, tree[node] - 1);
                lazy[node] += 1;
                return;
            }
            push_down(node, l, r);
            int mid = (l + r) / 2;
            update_decrement(2*node +1, l, mid, L, R);
            update_decrement(2*node +2, mid+1, r, L, R);
            tree[node] = min(tree[2*node +1], tree[2*node +2]);
        }
    };

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();
        vector<int> total_cover(n, 0);

        // Calculate total coverage for each index
        for(auto &query: queries){
            total_cover[query[0]] +=1;
            if(query[1]+1 < n) total_cover[query[1]+1] -=1;
        }
        for(int i=1;i<n;i++) total_cover[i] += total_cover[i-1];

        // Check if it's possible to cover all required decrements
        for(int i=0;i<n;i++) {
            if(total_cover[i] < nums[i]) return -1;
        }

        // Sort queries by ascending order of range length
        vector<vector<int>> sortedQueries = queries;
        sort(sortedQueries.begin(), sortedQueries.end(), [&](const vector<int> &a, const vector<int> &b) {
            int len_a = a[1] - a[0] +1;
            int len_b = b[1] - b[0] +1;
            if(len_a != len_b) return len_a < len_b;
            return a[0] < b[0];
        });

        // Initialize remaining capacity (C[i] = total_cover[i] - nums[i])
        vector<int> C(n, 0);
        for(int i=0;i<n;i++) {
            C[i] = total_cover[i] - nums[i];
        }

        // Initialize and build the segment tree
        SegmentTree st(n);
        st.build(C, 0, 0, n-1); // node=0, range [0, n-1]

        int removals = 0;
        for(auto &query: sortedQueries){
            int li = query[0];
            int ri = query[1];
            // Check if all indices in [li, ri] have C[i] >=1
            if(st.query_min(0, 0, n-1, li, ri) >=1){
                // Remove this query
                removals++;
                // Decrement C[i] by 1 for all i in [li, ri]
                st.update_decrement(0, 0, n-1, li, ri);
            }
        }
        return removals;
    }
};
",1460874546
lmhhhml2,lmhhhml2,588,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        nextCost_ps, previousCost_ps = [0] * 27, [0] * 27
        for idx in range(26):
            nextCost_ps[idx + 1] = nextCost_ps[idx] + nextCost[idx]
            previousCost_ps[idx + 1] = previousCost_ps[idx] + previousCost[idx]
        ret = 0
        for idx in range(len(s)):
            if s[idx] == t[idx]:
                continue
            start, end = ord(s[idx]) - ord('a'), ord(t[idx]) - ord('a')
            if start < end:
                ret += min(nextCost_ps[end] - nextCost_ps[start], previousCost_ps[start + 1] + previousCost_ps[-1] - previousCost_ps[end + 1])
            else:
                ret += min(previousCost_ps[start + 1] - previousCost_ps[end + 1], nextCost_ps[end] + nextCost_ps[-1] - nextCost_ps[start])
        return ret",1460839670
lmhhhml2,lmhhhml2,588,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        alice, bob = 10, 9
        turn = True
        while n >= 0:
            if turn:
                if n < alice:
                    return False
                n -= alice
                bob = alice - 1
            else:
                if n < bob:
                    return True
                n -= bob
                alice = bob - 1
            turn = not turn
        return not turn",1460801504
lmhhhml2,lmhhhml2,588,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        from functools import cmp_to_key
        def cmp(x, y):
            if x[0] < y[0]:
                return -1
            if x[0] > y[0]:
                return 1
            if x[1] < y[1]:
                return 1
            if x[1] > y[1]:
                return -1
            return 0
        queries = collections.deque(sorted(queries, key = cmp_to_key(cmp)))
        heap = []
        delta = [0] * len(nums)
        cur = 0
        ret = 0
        for idx in range(len(nums)):
            while queries and queries[0][0] <= idx:
                left, right = queries.popleft()
                heapq.heappush(heap, (-right, left))
            cur += delta[idx]
            while cur < nums[idx] and heap:
                right, left = heapq.heappop(heap)
                right = -right
                if right < idx:
                    ret += 1
                else:
                    cur += 1
                    if right < len(nums) - 1:
                        delta[right + 1] -= 1
            if cur < nums[idx]:
                return -1
        return ret + len(queries) + len(heap)",1460892295
Onkar Ratnaparkhi,code_OR,589,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nx, vector<int>& pr) {
        int n=s.size();
        long long ans=0;
        for(int i=0;i<n;i++){
            int ss = s[i]-'a';
            int tt = t[i]-'a';
            long long fr=0, bc=0;

            for(int j=ss;j!=tt;j++){
                if(j==26)j=0;
                if(j==tt)break;
                fr+=nx[j];
            }

            for(int j=ss;j!=tt;j--){
                if(j==-1)j=25;
                if(j==tt)break;
                bc+=pr[j];
            }            

            ans += min(fr, bc);
        }

        return ans;
    }
};",1460834265
Onkar Ratnaparkhi,code_OR,589,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int f=0;
        for(int i=10;i>0;i--){
            if(n<i){
                return f;
            }
            n-=i;
            f = f^1;
        }

        return 0;
    }
};",1460800770
Onkar Ratnaparkhi,code_OR,589,3647,cpp,"
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        // sort(q.begin(), q.end(), comp);/
        priority_queue< int > pq;

        int n=nums.size();

        vector<vector<int> > v(n);
        vector<int> v_end(n);

        for(auto it:q){
            // v[i] has end points
            v[it[0]].push_back(it[1]);
        }

        int curr=0;
        for(int i=0;i<n;i++){
            for(auto it:v[i]){
                pq.push(it);
            }
            nums[i]-=curr;
            while(nums[i] > 0 and !pq.empty()){
                if(pq.top() >= i){nums[i]--;curr++;}
                v_end[pq.top()]++;
                pq.pop();
            }
            if(nums[i]>0)return -1;
            curr -= v_end[i];
        }

        return pq.size();
        
    }
};",1460892521
Matthias Langer,mlangc,590,3591,java,"import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.function.IntFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;

class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        var potentialsNext = new long[nextCost.length];
        for (int i = 1; i < potentialsNext.length; i++) {
            potentialsNext[i] = potentialsNext[i - 1] + nextCost[i - 1];
        }

        var potentialsPrev = new long[nextCost.length];
        for (int i = previousCost.length - 1; i >= 1; i--) {
            potentialsPrev[i - 1] = potentialsPrev[i] + previousCost[i];
        }

        var res = 0L;
        for (int i = 0; i < s.length(); i++) {
            var cs = s.charAt(i) - 'a';
            var ct = t.charAt(i) - 'a';

            var totalCostNext = 0L;
            var totalCostPrev = 0L;
            if (ct > cs) {
                totalCostNext = potentialsNext[ct] - potentialsNext[cs];
                totalCostPrev = potentialsPrev[0] - potentialsPrev[cs] + previousCost[0] + potentialsPrev[ct];
            } else if (ct < cs) {
                totalCostNext = potentialsNext[25] - potentialsNext[cs] + nextCost[25] + potentialsNext[ct];
                totalCostPrev = potentialsPrev[ct] - potentialsPrev[cs];
            }

            res += Math.min(totalCostPrev, totalCostNext);
        }

        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int minOf(int... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Integer.MAX_VALUE;
        for (int i : is) {
            res = Math.min(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int maxOf(int... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Integer.MIN_VALUE;
        for (int i : is) {
            res = Math.max(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long minOf(long... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Long.MAX_VALUE;
        for (long i : is) {
            res = Math.min(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long maxOf(long... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Long.MIN_VALUE;
        for (long i : is) {
            res = Math.max(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> ExtendedArrayList<T> fillList(int n, Supplier<T> supplier) {
        return fillList(n, ignore -> supplier.get());
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> ExtendedArrayList<T> fillList(int n, IntFunction<T> valueAt) {
        var res = new ExtendedArrayList<T>(n);
        for (int i = 0; i < n; i++) {
            res.add(valueAt.apply(i));
        }

        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> T[] fillArray(int n, Class<T> clazz, Supplier<T> supplier) {
        return fillArray(n, clazz, ignore -> supplier.get());
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> T[] fillArray(int n, Class<T> clazz, IntFunction<T> valueAt) {
        @SuppressWarnings(""unchecked"") var res = (T[]) Array.newInstance(clazz, n);

        for (int i = 0; i < n; i++) {
            res[i] = valueAt.apply(i);
        }

        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused"", ""SameParameterValue""})
    static <T> T[] fillArray(int n, T value) {
        @SuppressWarnings(""unchecked"") var res = (T[]) Array.newInstance(value.getClass(), n);
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int[] fillIntArray(int n, IntUnaryOperator valueAt) {
        var res = new int[n];
        for (int i = 0; i < n; i++) {
            res[i] = valueAt.applyAsInt(i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int[] fillIntArray(int n, int value) {
        var res = new int[n];
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long[] fillLongArray(int n, IntToLongFunction valueAt) {
        var res = new long[n];
        for (int i = 0; i < n; i++) {
            res[i] = valueAt.applyAsLong(i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long[] fillLongArray(int n, long value) {
        var res = new long[n];
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long gcd(long a, long b) {
        while (b != 0) {
            var bb = a % b;
            a = b;
            b = bb;
        }

        return a;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int gcd(int a, int b) {
        while (b != 0) {
            var bb = a % b;
            a = b;
            b = bb;
        }

        return a;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused"", ""UnusedReturnValue""})
    static class ExtendedArrayList<T> extends ArrayList<T> {
        public ExtendedArrayList(int initialCapacity) {
            super(initialCapacity);
        }

        public ExtendedArrayList() {

        }

        public ExtendedArrayList(Collection<? extends T> c) {
            super(c);
        }

        T getFromEnd(int offset) {
            return get(size() - offset - 1);
        }

        T getFst() {
            return get(0);
        }

        T getLst() {
            return getFromEnd(0);
        }

        T removeLst() {
            return remove(size() - 1);
        }
    }
}",1460850401
Matthias Langer,mlangc,590,3625,java,"import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.function.IntFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;

class Solution {
    public boolean canAliceWin(int n) {
        var alice = true;
        var remove = 10;
        while (remove <= n) {
            n -= remove;
            alice = !alice;
            remove--;
        }

        return !alice;
    }


    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int minOf(int... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Integer.MAX_VALUE;
        for (int i : is) {
            res = Math.min(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int maxOf(int... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Integer.MIN_VALUE;
        for (int i : is) {
            res = Math.max(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long minOf(long... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Long.MAX_VALUE;
        for (long i : is) {
            res = Math.min(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long maxOf(long... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Long.MIN_VALUE;
        for (long i : is) {
            res = Math.max(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> ExtendedArrayList<T> fillList(int n, Supplier<T> supplier) {
        return fillList(n, ignore -> supplier.get());
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> ExtendedArrayList<T> fillList(int n, IntFunction<T> valueAt) {
        var res = new ExtendedArrayList<T>(n);
        for (int i = 0; i < n; i++) {
            res.add(valueAt.apply(i));
        }

        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> T[] fillArray(int n, Class<T> clazz, Supplier<T> supplier) {
        return fillArray(n, clazz, ignore -> supplier.get());
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> T[] fillArray(int n, Class<T> clazz, IntFunction<T> valueAt) {
        @SuppressWarnings(""unchecked"") var res = (T[]) Array.newInstance(clazz, n);

        for (int i = 0; i < n; i++) {
            res[i] = valueAt.apply(i);
        }

        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused"", ""SameParameterValue""})
    static <T> T[] fillArray(int n, T value) {
        @SuppressWarnings(""unchecked"") var res = (T[]) Array.newInstance(value.getClass(), n);
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int[] fillIntArray(int n, IntUnaryOperator valueAt) {
        var res = new int[n];
        for (int i = 0; i < n; i++) {
            res[i] = valueAt.applyAsInt(i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int[] fillIntArray(int n, int value) {
        var res = new int[n];
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long[] fillLongArray(int n, IntToLongFunction valueAt) {
        var res = new long[n];
        for (int i = 0; i < n; i++) {
            res[i] = valueAt.applyAsLong(i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long[] fillLongArray(int n, long value) {
        var res = new long[n];
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long gcd(long a, long b) {
        while (b != 0) {
            var bb = a % b;
            a = b;
            b = bb;
        }

        return a;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int gcd(int a, int b) {
        while (b != 0) {
            var bb = a % b;
            a = b;
            b = bb;
        }

        return a;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused"", ""UnusedReturnValue""})
    static class ExtendedArrayList<T> extends ArrayList<T> {
        public ExtendedArrayList(int initialCapacity) {
            super(initialCapacity);
        }

        public ExtendedArrayList() {

        }

        public ExtendedArrayList(Collection<? extends T> c) {
            super(c);
        }

        T getFromEnd(int offset) {
            return get(size() - offset - 1);
        }

        T getFst() {
            return get(0);
        }

        T getLst() {
            return getFromEnd(0);
        }

        T removeLst() {
            return remove(size() - 1);
        }
    }
}",1460802063
Matthias Langer,mlangc,590,3647,java,"import java.lang.reflect.Array;
import java.util.*;
import java.util.function.IntFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;

class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, Comparator.comparingInt(q -> q[0]));
        var current = 0;
        var restore = new int[nums.length + 1];

        var used = 0;
        var qp = 0;
        var queue = new PriorityQueue<>(Comparator.<int[]>comparingInt(q -> q[1]).reversed());
        for (int i = 0; i < nums.length; i++) {
            current -= restore[i];

            while (qp < queries.length && queries[qp][0] <= i) {
                queue.add(queries[qp]);
                qp++;
            }

            while (current < nums[i]) {
                var nextQuery = queue.poll();
                if (nextQuery == null || nextQuery[1] < i) {
                    return -1;
                }

                current++;
                restore[nextQuery[1] + 1]++;
                used++;
            }
        }

        return queries.length - used;
    }


    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int minOf(int... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Integer.MAX_VALUE;
        for (int i : is) {
            res = Math.min(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int maxOf(int... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Integer.MIN_VALUE;
        for (int i : is) {
            res = Math.max(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long minOf(long... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Long.MAX_VALUE;
        for (long i : is) {
            res = Math.min(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long maxOf(long... is) {
        if (is.length == 0) {
            throw new IllegalArgumentException();
        }

        var res = Long.MIN_VALUE;
        for (long i : is) {
            res = Math.max(res, i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> ExtendedArrayList<T> fillList(int n, Supplier<T> supplier) {
        return fillList(n, ignore -> supplier.get());
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> ExtendedArrayList<T> fillList(int n, IntFunction<T> valueAt) {
        var res = new ExtendedArrayList<T>(n);
        for (int i = 0; i < n; i++) {
            res.add(valueAt.apply(i));
        }

        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> T[] fillArray(int n, Class<T> clazz, Supplier<T> supplier) {
        return fillArray(n, clazz, ignore -> supplier.get());
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static <T> T[] fillArray(int n, Class<T> clazz, IntFunction<T> valueAt) {
        @SuppressWarnings(""unchecked"") var res = (T[]) Array.newInstance(clazz, n);

        for (int i = 0; i < n; i++) {
            res[i] = valueAt.apply(i);
        }

        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused"", ""SameParameterValue""})
    static <T> T[] fillArray(int n, T value) {
        @SuppressWarnings(""unchecked"") var res = (T[]) Array.newInstance(value.getClass(), n);
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int[] fillIntArray(int n, IntUnaryOperator valueAt) {
        var res = new int[n];
        for (int i = 0; i < n; i++) {
            res[i] = valueAt.applyAsInt(i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int[] fillIntArray(int n, int value) {
        var res = new int[n];
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long[] fillLongArray(int n, IntToLongFunction valueAt) {
        var res = new long[n];
        for (int i = 0; i < n; i++) {
            res[i] = valueAt.applyAsLong(i);
        }
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long[] fillLongArray(int n, long value) {
        var res = new long[n];
        Arrays.fill(res, value);
        return res;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static long gcd(long a, long b) {
        while (b != 0) {
            var bb = a % b;
            a = b;
            b = bb;
        }

        return a;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused""})
    static int gcd(int a, int b) {
        while (b != 0) {
            var bb = a % b;
            a = b;
            b = bb;
        }

        return a;
    }

    @SuppressWarnings({""DuplicatedCode"", ""unused"", ""UnusedReturnValue""})
    static class ExtendedArrayList<T> extends ArrayList<T> {
        public ExtendedArrayList(int initialCapacity) {
            super(initialCapacity);
        }

        public ExtendedArrayList() {

        }

        public ExtendedArrayList(Collection<? extends T> c) {
            super(c);
        }

        T getFromEnd(int offset) {
            return get(size() - offset - 1);
        }

        T getFst() {
            return get(0);
        }

        T getLst() {
            return getFromEnd(0);
        }

        T removeLst() {
            return remove(size() - 1);
        }
    }
}",1460892657
lomdu,lomdu,591,3591,cpp,"class Solution{
public:
    
    long long func1(int i,int j,vector<int>& nums1, vector<int>& nums2){
        if(i<=j){
            long long ans = 0;
            
            for(int k=i;k<j;k++){
                ans += nums1[k];
            }
            
            return ans;
        }
        
        long long ans = 0;
        
        for(int k=i;k<26;k++){
            ans += nums1[k];
        }
        
        for(int k=0;k<j;k++){
            ans += nums1[k];
        }
        
        return ans;
    }
    
    long long func2(int i,int j,vector<int>& nums1, vector<int>& nums2){
        if(i<=j){
            long long ans = 0;
            
            for(int k=0;k<=i;k++){
                ans += nums2[k];
            }
            for(int k=j+1;k<26;k++){
                ans += nums2[k];
            }
            
            return ans;
        }
        
        long long ans = 0;
        
        for(int k=j+1;k<=i;k++){
            ans += nums2[k];
        }
        
        return ans;
    }
    
    
    long long shiftDistance(string s, string t, vector<int>& nums1, vector<int>& nums2){
        long long ans = 0;
        int n = s.length();
        
        for(int i=0;i<n;i++){
            if(s[i]==t[i]) continue;
            
            long long c1 = func1(s[i]-'a',t[i]-'a',nums1,nums2);
            long long c2 = func2(s[i]-'a',t[i]-'a',nums1,nums2);
            
            ans += min(c1,c2);
        }
        
        
        return ans;
    }
};








",1460827139
lomdu,lomdu,591,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10) return 0;
        
        int l = 10;
        int count = 0;
        while(n>=l){
            n -= l;
            l--;
            count++;
        }
        
        // cout<<count<<endl;
        return count%2!=0;
    }
};



",1460808594
lomdu,lomdu,591,3647,cpp,"class Solution{
public:
    
    int check(int n,vector<int>& vis,vector<int>& nums){
        if(vis[0]<nums[0]) return 0;
        
        for(int i=1;i<n;i++){
            vis[i] += vis[i-1];
            if(vis[i]<nums[i]) return 0;
        }
        return 1;
    }
    
    int func(int i,int n,int m,vector<int>& vis,vector<int>& nums, vector<vector<int>>& q){
        if(i==m){
            int count = check(n,vis,nums);
            if(count) return 0;
            return -1e6;
        }
        
        int ans = -1e6;
        ans = max(ans,1+func(i+1,n,m,vis,nums,q));
        vis[q[i][0]]++;
        vis[q[i][1]+1]--;
        
        ans = max(ans,func(i+1,n,m,vis,nums,q));
        
        vis[q[i][0]]--;
        vis[q[i][1]+1]++;
        
        return ans;
    }
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q){
        int n = nums.size();
        int m = q.size();
        map<int,int> mp;
        for(int i=0;i<m;i++){
            mp[i]++;
        }
        
        vector<int> vis(n+10,0);
        
        for(int i=0;i<n;i++){
            if(i) vis[i] += vis[i-1];
            
            int req = max(0,nums[i]-vis[i]);
            if(req==0) continue;
            
            priority_queue<pair<int,int>> pq;
            for(auto it:mp){
                int ind = it.first;
                if(q[ind][0]<=i and q[ind][1]>=i){
                    pq.push({q[ind][1]-i,ind});
                }
            }
            
            int pqs = pq.size();
            if(pqs<req) return -1;
            
            while(req--){
                auto curr = pq.top();
                pq.pop();
                int ind = curr.second;
                vis[i]++;
                vis[q[ind][1]+1]--;
                
                mp.erase(ind);
            }
            
        }
        
        int count = mp.size();
        return count;
    }
};






",1460875283
Aman Meenia,AmanMeenia0001,593,3591,cpp,"#define ll long long 
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {


        ll ans = 0;
int n = s.size();
        for(int i=0; i<s.size(); i++){

            // Move forward
            ll temp1=0,temp2=0;
           int k = s[i]-'a';
            
            while(t[i]!=('a'+k)){
temp1+=nextCost[k];
                k++;
                k%=26;
            }

            // Move backward
            k = s[i]-'a';
            while(t[i]!=('a'+k)){
                temp2+=previousCost[k];
                k--;
                if(k<0){
                    k=25;
                }
            }
            // cout<<"" temp ""<<temp1<<"" temp2 ""<<temp2<<endl;
            ans+=min(temp1,temp2);

            

            
        }

        return ans;
        
    }
};",1460824014
Aman Meenia,AmanMeenia0001,593,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

int cnt = 0;
        int total = 10;
        while(n>0){
            if(n>=total){
                n-=total;
            }else{
                if(cnt%2==0) return false;
                return true;
            }
            cnt++;
            total-=1;
        }
            if(cnt%2==0) return false;
                return true;
        
    }
};",1460800502
Aman Meenia,AmanMeenia0001,593,3647,cpp,"class Solution {
public:
  static int cmp(vector<int> &a, vector<int> &b) {
    if (a[0] == b[0])
      return a[1] > b[1];
    return a[0] < b[0];
  }

  int maxRemoval(vector<int> &v, vector<vector<int>> &q) {

    int n = v.size();

    sort(q.begin(), q.end(), cmp);
    int ans = 0;
    // for (auto it : q) {
    //   cout << it[0] << "" "" << it[1] << endl;
    // }

    priority_queue<int, vector<int>, greater<int>> pq;
    priority_queue<int> extra;

    int m = q.size();
    int cnt = 0;
    int k = 0;
    for (int i = 0; i < n; i++) {

      while (!pq.empty() && pq.top() < i) {
        cnt -= 1;
        pq.pop();
      }

      while (k < m && q[k][0] < i) {
        extra.push(q[k][1]);
        k++;
      }

      while (k < m && cnt < v[i] && q[k][0] <= i) {

          if(!extra.empty() && extra.top() > q[k][1]){
             cnt++;
        pq.push(extra.top());
        extra.pop(); 
          }else{
        pq.push(q[k][1]);
        cnt++;
        k++;
          }
      }

      while (cnt < v[i] && !extra.empty() && extra.top() >= i) {
        cnt++;
        pq.push(extra.top());
        extra.pop();
      }

      // cout << "" cnt "" << cnt << "" i "" << i << "" v[i] "" << v[i] << endl;

      if (cnt < v[i])
        return -1;
    }

      while(k<m){
          extra.push(q[k][1]);
          k++;
      }
    // cout << ""Ans"" << extra.size() << endl;
    return extra.size();
  }
};

",1460869410
Dmitrii Samoilov,whoawhoawhoa,594,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long res = 0;
        int len = s.length();
        Long[][] next = new Long[26][26], prev = new Long[26][26];
        for (int i = 0; i < len; i++) {
            int sc = s.charAt(i) - 'a', tc = t.charAt(i) - 'a';
            long cost = 0;
            if (next[sc][tc] == null) {
                long tmp = 0;
                for (int j = sc; j < (tc < sc ? 26 + tc : tc); j++) {
                    tmp += nextCost[j % 26];
                }
                cost = tmp;
                next[sc][tc] = tmp;
            } else {
                cost = next[sc][tc];
            }
            if (prev[sc][tc] == null) {
                long tmp = 0;
                for (int j = sc; j > (tc > sc ? tc - 26 : tc); j--) {
                    tmp += previousCost[(j + 26) % 26];
                }
                cost = Math.min(cost, tmp);
                prev[sc][tc] = tmp;
            } else {
                cost = Math.min(cost, prev[sc][tc]);
            }
            res += cost;
        }
        return res;
    }
}",1460821841
Dmitrii Samoilov,whoawhoawhoa,594,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int amount = 10;
        boolean res = false;
        while (n >= amount) {
            res = !res;
            n -= amount;
            amount--;
        }
        return res;
    }
}",1460798583
Dmitrii Samoilov,whoawhoawhoa,594,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);
        int[] effect = new int[nums.length + 1];
        int res = 0;
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            // System.out.println(i + "" "" + effect[i] + "" "" + nums[i]);
            while (!pq.isEmpty() && pq.peek()[1] < i) {
                pq.poll();
            }

            while (j < queries.length && queries[j][1] < i) {
                j++;
            }

            while (effect[i] < nums[i]) {
                boolean used = false;
    
                while (j < queries.length && queries[j][0] <= i) {
                    pq.add(queries[j]);
                    j++;
                }
                
                if (!pq.isEmpty()) {
                    int[] tmp = pq.poll();
                    if (tmp[1] < i) {
                        continue;
                    }
                    // System.out.println(""use "" + tmp[0] + "" "" + tmp[1]);
                    effect[i]++;
                    effect[tmp[1] + 1]--;
                    res++;
                    used = true;
                }

                if (!used) {
                    return -1;
                }
            }
            effect[i + 1] += effect[i];
        }

        return queries.length - res;
    }
}",1460887460
Jaeha Yi,jaehayi1,595,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], prevCost: List[int]) -> int:
        '''
        get min dist from char1 to char2
        '''
        
        dist = [[int(26e9)] * 26 for _ in range(26)]
        
        def minimize(a, b): 
            return min(a, b) if a != -1 else b
        
        for i in range(26): 
            nxt = (i + 1) % 26
            pre = (i + 25) % 26
            dist[i][nxt] = min(dist[i][nxt], nextCost[i])
            dist[i][pre] = min(dist[i][pre], prevCost[i]) 
            dist[i][i] = 0
        
        for k in range(26): 
            dist2 = copy.deepcopy(dist)
            for i in range(26): 
                for j in range(26): 
                    dist[i][j] = min(dist2[i][j], dist2[i][k] + dist2[k][j])
        
        res = 0
        for i in range(len(s)): 
            s_i = ord(s[i]) - ord('a')
            t_i = ord(t[i]) - ord('a')
            res += dist[s_i][t_i]
            # print(dist[s_i][t_i])
        
        return res
            
        
        ",1460843480
Jaeha Yi,jaehayi1,595,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        remove = 10
        res = False
        
        while n >= remove:
            n -= remove
            remove -= 1
            res = not res
        
        return res",1460799991
Jaeha Yi,jaehayi1,595,3647,python3,"from heapq import heapify, heappush, heappop

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        '''
        Alternative problem: 
            use minimum number of queries to zero nums
    
        Methods: 
        - binary search - 
        - greedy - 
            reduce index i all queries before i, greedily pick queries that go furthest right
        - line sweep
        - two pointer
        - dp 
        '''
        n = len(nums)
        
        queries.sort()
        q_idx = 0
        
        choices = []
        heapify(choices)
        
        reduce = 0
        change = [0] * (n + 1)
        
        
        picked = 0
        # print(""========="")
        for i in range(n): 
            while q_idx < len(queries) and queries[q_idx][0] <= i: 
                heappush(choices, (-queries[q_idx][1], queries[q_idx][0]))
                q_idx += 1
            
            reduce += change[i] 
            pick = nums[i] - reduce
            for _ in range(pick): # greedily pick queries that go furthest right
                l, r = -1, -1
                while choices and r < i: # must pop one where r >= i
                    r, l = heappop(choices)
                    r = -r
                
                if r < i: return -1
                
                # print(l, r)
                
                picked += 1
                reduce += 1
                
                change[l] += 1
                change[r + 1] -= 1
        
        return len(queries) - picked
                
                
            
            
        
        ",1460888112
Dhruvrajsinh,_batman__,596,3591,cpp,"class Solution {
public:
    
  vector<vector<long long>> floydWarshall(vector<vector<long long>>& graph) {
    vector<vector<long long>> dist = graph;
    int V = 26;

    for (int k = 0; k < V; k++) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if(dist[i][k] == 1e18 || dist[k][j] == 1e18) continue;
                
                if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    return dist;
}

long long shiftDistance(string s, string t, vector<int>& ne, vector<int>& pr) {
    vector<vector<long long>> adj(26, vector<long long>(26, 1e18));
    
    for (int i = 0; i < 26; i++) {
        adj[i][(i + 1) % 26] = ne[i];
        adj[i][i] = 0;
    }
    for (int i = 0; i < 26; i++) {
        adj[i][(i - 1 + 26) % 26] = pr[i];
    }

    vector<vector<long long>> dist = floydWarshall(adj);

    long long ans = 0;

    for (int i = 0; i < s.size(); i++) {
        int a = s[i] - 'a';
        int b = t[i] - 'a';
        ans += dist[a][b];
    }

    return ans;
}

};",1460825362
Dhruvrajsinh,_batman__,596,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10;
        bool flag = false;
        
        while(n >=0){
            if(flag == false){
                if(n >=cnt) n -= cnt;
                else return flag;
                
                flag = true;
                cnt--;
            }
            else{
                 if(n >=cnt) n -= cnt;
                 else return flag;
                
                flag = false;
                cnt--;
            }
        }
        
        return flag;
    }
};",1460799027
Dhruvrajsinh,_batman__,596,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
            
            priority_queue<int>q1;
        
            sort(q.begin(),q.end());
          
        
            vector<long long>dif(nums.size()+1,0);
            long long sum = 0;
            
            int j = 0;
            int ans = 0;
            for(int i=0;i<nums.size();i++){
                
                   while(j < q.size() && q[j][0] <=i) {
                       q1.push(q[j][1]);
                        j++;
                   }
                
                   sum += dif[i];
                
                   if(nums[i] <=sum) continue;
                
                   int d = nums[i] - sum;
                
                 
                
                   while(q1.size() && q1.top() >=i && sum < nums[i]){
                             sum++;
                             ans++;
                             dif[ q1.top() + 1]--;
                             q1.pop();
                        
                    }
                
                   if(sum < nums[i]) return -1;
                
              
                   
            }
        
        return q.size() - ans;
        
            
    }
};",1460882285
huzy,user2349xl,597,3591,cpp,"class Solution {
public:
    typedef long long ll;
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        
        int n = s.size();
        ll res = 0;
        
        for (int i = 0; i < n; i++) {
            int a = s[i] - 'a';
            int b = t[i] - 'a';
            int c = a;
            int d = b;
            
            ll c1 = 0;
            
            while (a != b) {
                c1 += nextCost[a];
                a += 1;
                a %= 26;
            }
            
            ll c2 = 0;
            
            while (c != d) {
                c2 += previousCost[c];
                c -= 1;
                c = (c + 26) % 26;
            }
            
            // cout << c1 << "" "" << c2 << endl;
            
            res += min(c1, c2);
        }
        
        return res;
    }
};",1460820057
huzy,user2349xl,597,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        
        int f = 0;
        int cnt = 10;
        
        while (n) {
            
            if (n < cnt || cnt == 0) {
                return f;
            }
            
            n -= cnt;
            cnt -= 1;
            f ^= 1;
        }
        
        return f;
    }
};",1460802231
huzy,user2349xl,597,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size();
        map<int, vector<int>> in;

        for (int j = 0; j < q.size(); j++) {
            in[q[j][0]].push_back(j);
        }
        
        priority_queue<int> used;
        priority_queue<int, vector<int>, greater<int>> sure;
        int curr = 0;
        
        for (int i = 0; i < n; i++) {
            for (auto x : in[i]) {
                used.push(q[x][1] + 1);
            }
            
            while (sure.size() && sure.top() <= i) {
                sure.pop();
            }
            
            while (sure.size() < nums[i] && used.size() && used.top() > i) {
                sure.push(used.top());
                used.pop();
            }
            
            if (sure.size() < nums[i]) {
                return -1;
            }
        }
        
        return used.size();
    }
};",1460888352
Ali,changeme,598,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long res = 0;
        for (int i = 0; i < s.length(); i++) {
            long a = 0;
            var ch = s.charAt(i);
            while (ch != t.charAt(i)) {
                a += nextCost[ch - 'a'];
                ch = (char) (ch + 1);
                if (ch == 'z' + 1) {
                    ch = 'a';
                }
            }            
            long b = 0;
            ch = s.charAt(i);
            while (ch != t.charAt(i)) {
                b += previousCost[ch - 'a'];
                ch = (char) (ch - 1);
                if (ch == 'a' - 1) {
                    ch = 'z';
                }
            }
            res += Math.min(a, b);
        }
        return res;
    }
}",1460829351
Ali,changeme,598,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int i = 0;
        int cur = 10;
        while (true) {
            n -= cur;
            if (i % 2 == 0) {
                if (n < 0) {
                    return false;
                }
            } else {
                if (n < 0) {
                    return true;
                }
            }
            i++;
            cur--;
        }
    }
}",1460799665
Ali,changeme,598,3647,java,"class Solution {

    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (u, v) -> u[0] == v[0] ? v[1] - u[1] : u[0] - v[0]);
        var dec = new int[100002];
        
        int j = 0;
        int count = 0;
        int res = 0;
        var m = new PriorityQueue<int[]>((u, v) -> v[1] - u[1]);
        for (int i = 0; i < nums.length; i++) {
            count -= dec[i];
            while (j < queries.length && (i > queries[j][1] || (queries[j][0] <= i && queries[j][1] >= i))) {
                if (i > queries[j][1]) {
                    res++;
                    continue;
                }
                m.add(queries[j++]);
            }
            while (count < nums[i] && m.size() > 0) {
                var q = m.poll();
                if (q[1] < i) {
                    res++;
                } else {
                    count++;
                    dec[q[1] + 1]++;
                }
            }
            if (nums[i] > count) {
                return -1;
            }
        }
        return res + queries.length - j + m.size();
    }
}",1460882498
tim870810,tim870810,599,3591,cpp,"class Solution {
public:
    long long GetSumInRange(vector<long long>& prefix_sum, int start, int end) {
        if (start > end)
            return 0LL;
        return prefix_sum[end + 1] - prefix_sum[start];
    }

    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const int n = nextCost.size();
        vector<long long> next_prefix(nextCost.size() + 1, 0LL);
        vector<long long> pre_prefix(previousCost.size() + 1, 0LL);
        for (int i = 0; i < nextCost.size(); i++)
            next_prefix[i + 1] = next_prefix[i] + nextCost[i];
        for (int i = 0; i < previousCost.size(); i++)
            pre_prefix[i + 1] = pre_prefix[i] + previousCost[i];

        long long res = 0LL;
        for (int i = 0; i < s.size(); i++) {
            int from = s[i] - 'a';
            int to = t[i] - 'a';
            long long move_pre_cost = from >= to ? GetSumInRange(pre_prefix, to + 1, from) :
                            GetSumInRange(pre_prefix, 0, from) + GetSumInRange(pre_prefix, to + 1, n - 1);
            long long move_next_cost = from <= to ? GetSumInRange(next_prefix, from, to - 1) :
                            GetSumInRange(next_prefix, from, n - 1) + GetSumInRange(next_prefix, 0, to - 1);
            res += std::min(move_pre_cost, move_next_cost);
        }
        return res;
    }
};",1460858368
tim870810,tim870810,599,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice_turn = true;
        int curr = 10;
        while (n > 0) {
            if (n < curr)
                return !alice_turn;
            n -= curr;
            curr--;
            alice_turn = !alice_turn;
        }
        return !alice_turn;
    }
};
/*
10 ~ 18 => A win
19 ~ 26 => A lose
27 ~ 33 => A win
34 ~ 39 => A lose
40 ~ 44 => A win
45 ~ 48 => A lose



*/",1460807931
tim870810,tim870810,599,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        const int n = nums.size();
        std::sort(queries.begin(), queries.end());
        vector<int> cnt(n + 1, 0);
        int sum = 0;
        priority_queue<int> end_indices;
        int q = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += cnt[i];
            nums[i] -= sum;
            while (q < queries.size() && i == queries[q][0])
                end_indices.push(queries[q++][1]);
            while (nums[i] > 0 && !end_indices.empty()) {
                if (end_indices.top() < i)
                    break;
                cnt[i + 1]++;
                cnt[end_indices.top() + 1]--;
                nums[i]--;
                end_indices.pop();
            }
            if (nums[i] > 0)
                return -1;
        }
        return end_indices.size() + (queries.size() - q);
    }
};",1460888471
kalesnikauilya,kalesnikauilya,600,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        const int n = (int) s.length();
        long long ans = 0;
        for(int i = 0; i < n; ++i){
            long long cost1 = 0;
            int dig1 = s[i] - 'a';
            int dig2 = t[i] - 'a';
            while(dig1 != dig2){
                cost1 += nextCost[dig1];
                dig1 = (dig1 + 1) % 26;
            }
            long long cost2 = 0;
            dig1 = s[i] - 'a';
            while(dig1 != dig2){
                cost2 += previousCost[dig1];
                dig1 = (dig1 - 1 + 26) % 26;
            }
            ans += min(cost1, cost2);
        }
        return ans;
    }
};",1460834577
kalesnikauilya,kalesnikauilya,600,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool who = 1;
        int amount = 10;
        while(n >= amount){
            n -= amount;
            amount--;
            who = !who;
        }
        return !who;
    }
};",1460824309
kalesnikauilya,kalesnikauilya,600,3647,cpp,"#include <bits/stdc++.h>

#include <algorithm>
#include <cassert>
#include <functional>
#include <vector>


#ifdef _MSC_VER
#include <intrin.h>
#endif

#if __cplusplus >= 202002L
#include <bit>
#endif

namespace atcoder {

namespace internal {

#if __cplusplus >= 202002L

using std::bit_ceil;

#else

unsigned int bit_ceil(unsigned int n) {
    unsigned int x = 1;
    while (x < (unsigned int)(n)) x *= 2;
    return x;
}

#endif

int countr_zero(unsigned int n) {
#ifdef _MSC_VER
    unsigned long index;
    _BitScanForward(&index, n);
    return index;
#else
    return __builtin_ctz(n);
#endif
}

constexpr int countr_zero_constexpr(unsigned int n) {
    int x = 0;
    while (!(n & (1 << x))) x++;
    return x;
}

}  // namespace internal

}  // namespace atcoder


namespace atcoder {

#if __cplusplus >= 201703L

template <class S,
          auto op,
          auto e,
          class F,
          auto mapping,
          auto composition,
          auto id>
struct lazy_segtree {
    static_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,
                  ""op must work as S(S, S)"");
    static_assert(std::is_convertible_v<decltype(e), std::function<S()>>,
                  ""e must work as S()"");
    static_assert(
        std::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,
        ""mapping must work as F(F, S)"");
    static_assert(
        std::is_convertible_v<decltype(composition), std::function<F(F, F)>>,
        ""compostiion must work as F(F, F)"");
    static_assert(std::is_convertible_v<decltype(id), std::function<F()>>,
                  ""id must work as F()"");

#else

template <class S,
          S (*op)(S, S),
          S (*e)(),
          class F,
          S (*mapping)(F, S),
          F (*composition)(F, F),
          F (*id)()>
struct lazy_segtree {

#endif

  public:
    lazy_segtree() : lazy_segtree(0) {}
    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}
    explicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {
        size = (int)internal::bit_ceil((unsigned int)(_n));
        log = internal::countr_zero((unsigned int)size);
        d = std::vector<S>(2 * size, e());
        lz = std::vector<F>(size, id());
        for (int i = 0; i < _n; i++) d[size + i] = v[i];
        for (int i = size - 1; i >= 1; i--) {
            update(i);
        }
    }

    void set(int p, S x) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        d[p] = x;
        for (int i = 1; i <= log; i++) update(p >> i);
    }

    S get(int p) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        return d[p];
    }

    S prod(int l, int r) {
        assert(0 <= l && l <= r && r <= _n);
        if (l == r) return e();

        l += size;
        r += size;

        for (int i = log; i >= 1; i--) {
            if (((l >> i) << i) != l) push(l >> i);
            if (((r >> i) << i) != r) push((r - 1) >> i);
        }

        S sml = e(), smr = e();
        while (l < r) {
            if (l & 1) sml = op(sml, d[l++]);
            if (r & 1) smr = op(d[--r], smr);
            l >>= 1;
            r >>= 1;
        }

        return op(sml, smr);
    }

    S all_prod() { return d[1]; }

    void apply(int p, F f) {
        assert(0 <= p && p < _n);
        p += size;
        for (int i = log; i >= 1; i--) push(p >> i);
        d[p] = mapping(f, d[p]);
        for (int i = 1; i <= log; i++) update(p >> i);
    }
    void apply(int l, int r, F f) {
        assert(0 <= l && l <= r && r <= _n);
        if (l == r) return;

        l += size;
        r += size;

        for (int i = log; i >= 1; i--) {
            if (((l >> i) << i) != l) push(l >> i);
            if (((r >> i) << i) != r) push((r - 1) >> i);
        }

        {
            int l2 = l, r2 = r;
            while (l < r) {
                if (l & 1) all_apply(l++, f);
                if (r & 1) all_apply(--r, f);
                l >>= 1;
                r >>= 1;
            }
            l = l2;
            r = r2;
        }

        for (int i = 1; i <= log; i++) {
            if (((l >> i) << i) != l) update(l >> i);
            if (((r >> i) << i) != r) update((r - 1) >> i);
        }
    }

    template <bool (*g)(S)> int max_right(int l) {
        return max_right(l, [](S x) { return g(x); });
    }
    template <class G> int max_right(int l, G g) {
        assert(0 <= l && l <= _n);
        assert(g(e()));
        if (l == _n) return _n;
        l += size;
        for (int i = log; i >= 1; i--) push(l >> i);
        S sm = e();
        do {
            while (l % 2 == 0) l >>= 1;
            if (!g(op(sm, d[l]))) {
                while (l < size) {
                    push(l);
                    l = (2 * l);
                    if (g(op(sm, d[l]))) {
                        sm = op(sm, d[l]);
                        l++;
                    }
                }
                return l - size;
            }
            sm = op(sm, d[l]);
            l++;
        } while ((l & -l) != l);
        return _n;
    }

    template <bool (*g)(S)> int min_left(int r) {
        return min_left(r, [](S x) { return g(x); });
    }
    template <class G> int min_left(int r, G g) {
        assert(0 <= r && r <= _n);
        assert(g(e()));
        if (r == 0) return 0;
        r += size;
        for (int i = log; i >= 1; i--) push((r - 1) >> i);
        S sm = e();
        do {
            r--;
            while (r > 1 && (r % 2)) r >>= 1;
            if (!g(op(d[r], sm))) {
                while (r < size) {
                    push(r);
                    r = (2 * r + 1);
                    if (g(op(d[r], sm))) {
                        sm = op(d[r], sm);
                        r--;
                    }
                }
                return r + 1 - size;
            }
            sm = op(d[r], sm);
        } while ((r & -r) != r);
        return 0;
    }

  private:
    int _n, size, log;
    std::vector<S> d;
    std::vector<F> lz;

    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }
    void all_apply(int k, F f) {
        d[k] = mapping(f, d[k]);
        if (k < size) lz[k] = composition(f, lz[k]);
    }
    void push(int k) {
        all_apply(2 * k, lz[k]);
        all_apply(2 * k + 1, lz[k]);
        lz[k] = id();
    }
};

}  // namespace atcoder


using namespace std;
using namespace atcoder;

struct S{
    long long value;
};
using F = long long;

S op(S a, S b){ return {a.value + b.value}; }
S e(){ return {0}; }
S mapping(F f, S x){ return {x.value + f}; }
F composition(F f, F g){ return f + g; }
F id(){ return 0; }


class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        const int N = (int) nums.size();
        const int Q = (int) queries.size();

        sort(queries.begin(), queries.end(), [&](const vector<int> &lhs, const vector<int> &rhs){
            if(lhs[0] == rhs[0]){
                return lhs[1] > rhs[1];
            }
            return lhs[0] < rhs[0];
        });

        vector<S> v(N + 2, {0});
        for(int i = 0; i < N; ++i){
            v[i] = {nums[i]};
        }
        lazy_segtree<S, op, e, F, mapping, composition, id> seg(v);

        auto compare = [](vector<int> a, vector<int> b) { return a[1] < b[1]; };
        //std::priority_queue<Node, std::vector<Node>, decltype(compare)> openSet(compare);
        priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> pq(compare);
        /*
        pq.push({1,2});
        pq.push({5,0});
        pq.push({3,3});
        while(!pq.empty()){
            auto tp = pq.top();
            pq.pop();
            cout << tp[0] << "" "" << tp[1] << endl;
        }
        */
        int q = 0;
        int took = 0;
        for(int i = 0; i < N; ++i){
            for(int qq = q; qq < Q; ++qq){
                auto cur = queries[qq];
                if(cur[0] > i){
                    q = qq;
                    break;  
                } 
                pq.push(cur);
                if(qq == Q - 1) q = Q;
            }
            //cout << pq.size() << endl;

            while(!pq.empty() && seg.get(i).value > 0){
                auto tp = pq.top();
                pq.pop();
                seg.apply(tp[0], tp[1] + 1, -1);
                took++;
            }
            if(seg.get(i).value > 0){
                return -1;
            }
        }
        return Q - took;
    }
};",1460894244
Bashem,bashem,601,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        auto dp_next_cost = vector(26, vector(26, -1LL));
        auto dp_prv_cost = vector(26, vector(26, -1LL));

        long long ans = 0;

        for (int i = 0; i < s.size(); i++) {
            long long curr = calculate_cost(s[i] - 'a', t[i] - 'a', 1, nextCost, dp_next_cost);
            curr = min(curr, calculate_cost(s[i] - 'a', t[i] - 'a', -1, previousCost, dp_prv_cost));

            ans += curr;
        }
        
        return ans;
    }
private:
    long long calculate_cost(int source, int target, int operation, vector<int> &cost, vector<vector<long long>> &dp) {
        if(source == target) return 0;
        auto &res = dp[source][target];

        if(res != -1) return res;

        int nxt_source = (source + operation + 26) % 26;
        res = cost[source] + calculate_cost(nxt_source, target, operation, cost, dp);

        return res;
    }
};",1460813061
Bashem,bashem,601,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n, int remove = 10) {
        if(n < remove) return false;
        return !canAliceWin(n - remove, remove - 1);
    }
};",1460800787
Bashem,bashem,601,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int query_index = 0;

        multiset<int, greater<int>> available;

        sort(queries.begin(), queries.end());
        
        int ans = 0;
        multiset<int> expire;
        
        for (int i = 0; i < nums.size(); i++) {

            while(query_index < queries.size() && queries[query_index][0] == i) {
                available.insert(queries[query_index][1]);
                query_index++;
            }

            while(!expire.empty() && *expire.begin() < i) {
                expire.erase(expire.begin());
            }

            while(expire.size() < nums[i] && !available.empty() && *available.begin() >= i) {
                expire.insert(*available.begin());
                available.erase(available.begin());
            }
            
            if(expire.size() < nums[i])
                return -1;
        }

        ans = available.size();

        return ans;
    }
};",1460858127
Said Abdulaev,said_v15,602,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& prev) {
        int n = s.size();
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            long long mn = (long long) 1e17;
            char c = s[i];
            // try prev
            long long cur = 0;
            while (c != t[i]) {
                char prevc = c;
                if (c == 'a') c = 'z';
                else c--;
                cur += prev[prevc - 'a'];
            }
            mn = cur;
            // try next
            c = s[i];
            cur = 0;
            while (c != t[i]) {
                char prevc = c;
                if (c == 'z') c = 'a';
                else c++;
                cur += next[prevc - 'a'];
            }
            mn = min(mn, cur);
            ans += mn;
        }

        return ans;
        
    }
};",1460845413
Said Abdulaev,said_v15,602,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int par = 0, take = 10;
        while (n >= 0) {
            if (n < take) {
                return (par ? true : false);
            }
            n -= take;
            take--;
            par = !par;
        }
        return true;
    }
};",1460836559
Said Abdulaev,said_v15,602,3647,cpp,"class Solution {
public:
    pair<int, int> get_max(multiset<pair<int, int>> &m) {
        auto it = m.end(); it--;
        return *it;
    }

    int maxRemoval(vector<int>& v, vector<vector<int>>& q) {
        int n = v.size(), sz = q.size(), ans = 0;
        sort(q.begin(), q.end());
        int idx = 0, cover = 0;
        vector<int> dif(n + 1);
        multiset<pair<int, int>> m;

        for (int i = 0; i < n; i++) {
            cover += dif[i];
            while (idx < sz && q[idx][0] <= i) {
                m.insert({q[idx][1], q[idx][0]});
                idx++;
            }

            while (cover < v[i] && !m.empty()) {
                pair<int, int> seg = get_max(m);
                if (seg.first < i) {
                    m.erase(m.find(seg));
                    continue;
                }
                dif[seg.first + 1]--;
                cover++;
                ans++;
                m.erase(m.find(seg));
            }

            if (cover < v[i]) {
                return -1;
            }
        }

        return sz - ans;
    }
};",1460883560
hrithik_2468,hrithik_2468,603,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<long long> prefn(26);
        vector<long long> suffn(26);
        vector<long long> suffp(26);
        vector<long long> prefp(26);
        for(int i=0;i<26;i++){
            prefn[i]=nextCost[i];
            if(i)prefn[i]+=prefn[i-1];
            prefp[i]=previousCost[i];
            if(i)prefp[i]+=prefp[i-1];
        }
        for(int i=25;i>=0;i--){
            suffp[i]=previousCost[i];
            if(i+1<26)suffp[i]+=suffp[i+1];
            suffn[i]=nextCost[i];
            if(i+1<26)suffn[i]+=suffn[i+1];
        }
        long long ans=0;
        for(int i=0;i<s.length();i++){
            int a=s[i]-'a';
            int b=t[i]-'a';
            if(a<b){
                ans+=min(prefn[b-1]-(a>0?prefn[a-1]:0),prefp[a]+(b!=25?suffp[b+1]:0));
            }
            else if(b<a){
                ans+=min(prefp[a]-prefp[b],prefn[25]-prefn[a-1]+(b!=0?prefn[b-1]:0));
            }
        }
        return ans;
                         
    }
};",1460843192
hrithik_2468,hrithik_2468,603,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int tp=1;
        int pv=11;
        while(n>0){
            pv--;
            if(n<pv){
                return tp%2==0;
            }
            n-=(pv);
            tp++;
        }
        return tp%2==0;
    }
};",1460804848
hrithik_2468,hrithik_2468,603,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        multiset<int> ut;
        multiset<int> taken;
        sort(queries.begin(),queries.end());
        int ans=0;
        int j=0;
        int cra=0;
        for(int i=0;i<nums.size();i++){
            while(!ut.empty()&&*ut.begin()<i)ut.erase(ut.begin());
            while(!taken.empty()&&*taken.begin()<i)taken.erase(taken.begin()),cra--,ans++;
            while(j<queries.size()&&queries[j][0]<=i){
                ut.insert(queries[j][1]);
                j++;
            }
            while(!ut.empty()&&*prev(ut.end())>=i&&cra<nums[i]){
                taken.insert(*prev(ut.end()));
                ut.erase(prev(ut.end()));
                cra++;
            }
            //cout<<cra<<endl;
            if(cra<nums[i])return -1;
        }
        ans+=cra;
        int sz=queries.size();
        return sz-ans;
    }
};",1460889647
Ritik Goyal,ritik02122002,604,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& prev) {
        long long ans=0;
        vector<long long>n(next.begin(),next.end());
        vector<long long>p(prev.begin(),prev.end());
        for(int i=1;i<26;i++)
            {n[i]+=n[i-1];
            p[i]+=p[i-1];
            }
        for(int i=0;i<s.length();i++)
            {
                int f=s[i]-'a';
                int sec=t[i]-'a';
                long long c1=1e17,c2=1e17;
                if(sec>f)
                {
                    if(f>0)
                    c1=n[sec-1]-n[f-1];
                    else
                        c1=n[sec-1];
                }
                else if(sec<f)
                {
                    if(f>0)
                    c1=n[25]-n[f-1];
                    else
                        c1=n[25];
                    if(sec>0)
                        c1+=n[sec-1];
                    
                    
                }
                else
                    c1=0;
                if(sec<f)
                {
                    c2=p[f]-p[sec];
                    
                }
                else if(f<sec)
                {
                    c2=p[f];
                    c2+=(p[25]-p[sec]);
                    
                }
                else
                    c2=0;
                ans+=min(c1,c2);
                
            }
        return ans;
        
    }
};",1460840102
Ritik Goyal,ritik02122002,604,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        
        int x=10;
        int turn=1;
        while(1)
            {
                n-=x;
                if(n<0)
                    return !turn;
                turn =!turn;
                x--;
                
            }
        return 0;
    }
};",1460802276
Ritik Goyal,ritik02122002,604,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        priority_queue<int>pq;
        sort(q.begin(),q.end());
int j=0;
        vector<int>temp(a.size()+1,0);
        int rem=0;
        int ans=0;
        for(int i=0;i<a.size();i++)
            {
                // while(!pq.empty() && pq.top()<i)
                //     {
                //         pq.pop();
                //         ans++;
                //     }
                
                while(j<q.size() && q[j][0]==i)
                    {
                        pq.push(q[j][1]);
                        j++;
                    }
                rem+=temp[i];
                int left=a[i]-rem;
                while(left>0 && !pq.empty())
                    {
                        if(pq.top()<i)
                        {
                            ans++;
                            pq.pop();
                            continue;
                        }
                        rem++;
                        temp[pq.top()+1]--;
                        pq.pop();
                        left--;
                    }
                if(left>0)
                    return -1;
                
            }
        return ans+(int)pq.size();
    }
};",1460890482
timowendner,timowendner,605,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        cost = [[float('inf')]*26 for i in range(26)]
        for i in range(26):
            for j in range(26):
                temp = 0
                cur = i
                while cur != j:
                    temp += nextCost[cur]
                    cur = (cur+1)%26
                cost[i][j] = min(cost[i][j], temp)

                temp = 0
                cur = i
                while cur != j:
                    temp += previousCost[cur]
                    cur = (cur-1)%26
                cost[i][j] = min(cost[i][j], temp)

        ans = 0
        for a, b in zip(s,t):
            a = ord(a) - ord('a')
            b = ord(b) - ord('a')
            ans += cost[a][b]
        return ans
            ",1460811448
timowendner,timowendner,605,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        player = True
        for i in reversed(range(1,11)):
            if n < 0:
                return player
            player = not player
            n -= i
        return not player",1460799082
timowendner,timowendner,605,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        availiable = []
        heap = []
        N = len(queries)
        ans = 0
        queries.sort(reverse=True)
        for i, val in enumerate(nums):
            while queries and queries[-1][0] <= i:
                cur = queries.pop()
                heappush(availiable, -cur[1])
            while heap and heap[0] < i:
                heappop(heap)
            while len(heap)<val:
                if not availiable:
                    return -1
                cur = -heappop(availiable)
                if cur < i:
                    continue
                ans += 1
                heappush(heap, cur)

        return N - ans",1460872852
yifeizh04,yifeizh04,607,3591,cpp,"#define ll long long
constexpr int inf = 1e9;

constexpr int A = 26;

class Solution {
public:
    long long shiftDistance(string S, string T, vector<int>& nxt, vector<int>& prv) {
        vector<vector<ll>> cost(A, vector<ll>(A));
        
        for (int i = 0; i < 26; ++i) {
            for (int j = 0; j < 26; ++j) {
                if (i == j) {
                    cost[i][j] = 0;
                } else {
                    int k = i;
                    ll a = 0, b = 0;
                    while (k != j) {
                        a += nxt[k];
                        k = (k + 1) % 26;
                    }

                    k = i;
                    while (k != j) {
                        b += prv[k];
                        k = (k - 1 + 26) % 26;
                    }
                    cost[i][j] = min(a, b);
                }
            }
        }

        int n = S.length();
        vector<int> s(n), t(n);

        ll ans = 0;
        for (int i = 0; i < n; ++i) {
            s[i] = S[i] - 'a';
            t[i] = T[i] - 'a';
            ans += cost[s[i]][t[i]];
        } 

        return ans;
    }
};",1460816311
yifeizh04,yifeizh04,607,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10;
        bool turn = true;
        while (true) {
            if (remove > n) {
                return !turn;
            }
            n -= remove;
            --remove;
            turn = !turn;
        }
    }
};",1460820337
yifeizh04,yifeizh04,607,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();
        vector<multiset<int>> d(n);
        for (int i = 0; i < q; ++i) {
            auto &vec = queries[i];
            int l = vec[0], r = vec[1];
            d[l].insert(r);
        }

        auto get = [&](multiset<int> &s) {
            if (s.size() == 0) {
                return -1;
            }

            return *(s.rbegin());
        };


        vector<int> diff(n + 1);
        int sub = 0;
        int ans = 0;
        multiset<int> R;

        auto use = [&](int r) {
            ++ans;
            // cout << ""Use "" << r << endl;
            diff[r + 1] -= 1;
            --sub;
        };

        for (int i = 0; i < n; ++i) {
            
            while (R.size()) { // remove the eccess one
                auto it = R.begin();
                if (*it < i) {
                    R.erase(it);
                } else {
                    break;
                }
            }

            sub -= diff[i];
            while (nums[i] + sub > 0) {
                int a = get(d[i]);
                int b = get(R);

                if (a == -1 && b == -1) {
                    return -1;
                }

                use(max(a, b));
                if (a >= b) {
                    d[i].erase(d[i].find(a));
                } else {
                    R.erase(R.find(b));
                }
            }

            // insert R as possible elements
            for (auto it = d[i].begin(); it != d[i].end(); ++it) {
                R.insert(*it);
            }
        }
        return q - ans;
    }
};",1460872885
xeronerasfat,xeronerasfat,608,3591,java,"class Solution {
    public long nextTotalSum(long[] nextSum, int s, int e){
        if (s==e){
            return 0;
        }
        else if(e<s){
            long sum = nextSum[26] - nextSum[s];
            sum += nextSum[e];
            return sum;
        }
        else{
            return nextSum[e] - nextSum[s];
        }
    }
    public long prevTotalSum(long[] prevSum, int s, int e){
        if (s==e){
            return 0;
        }
        else if(e>s){
            long sum = prevSum[0] - prevSum[s+1];
            sum += prevSum[e+1];
            return sum;
        }
        else{
            return prevSum[e+1] - prevSum[s+1];
        }
    }
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[] nextSum = new long[27];
        long[] prevSum = new long[27];
        for(int i=1;i<=26;i++){
            nextSum[i] = nextSum[i-1] + nextCost[i-1];
        }
        for(int i=25;i>=0;i--){
            prevSum[i] = prevSum[i+1] + previousCost[i];
        }

        int n = s.length();
        long ans = 0;
        for(int i=0;i<n;i++){
            int fl = s.charAt(i)-'a';
            int sl = t.charAt(i)-'a';
            ans += Math.min(nextTotalSum(nextSum, fl, sl), prevTotalSum(prevSum,fl, sl));
        }
        return ans;
    }
}",1460842750
xeronerasfat,xeronerasfat,608,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        Boolean ans = false;
        int num = 10;
        while(num >0 && num <= n){
            n -= num;
            num--;
            ans = !ans;
        }
        return ans;
    }
}",1460807584
xeronerasfat,xeronerasfat,608,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (a, b)->{
            if(a[0]==b[0])
                return b[1]-a[1];
            return a[0]-b[0];
        });
        int m = queries.length;
        int n = nums.length;
        int sumArray[] = new int[n];
        int zcount = 0;
        int pointer = 0;
        PriorityQueue<int[]> pq = new PriorityQueue(new CustomComparator());
        for(int i=0;i<n;i++){
            zcount += sumArray[i];
            int x = nums[i] - zcount;
            while(pointer < m && queries[pointer][0] <= i){
                pq.add(queries[pointer]);
                pointer++;
            }
            while(x>0 && !pq.isEmpty()){
                int[] tp = pq.poll();
                if(tp[1] < i){
                    return -1;
                }
                if(i+1 < n){
                    sumArray[i+1]++;
                }
                if(tp[1]+1 < n){
                    sumArray[tp[1]+1]--;
                }
                --x;
            }
            if(x > 0){
                return -1;
            }
        }
        return pq.size();
    }
}

class CustomComparator implements Comparator<int[]> {
    public int compare(int[] a, int[] b) {
        if(a[1]==b[1]){
            return a[0]-b[0];
        }
        return b[1]-a[1];
    }
}",1460896559
aman_bedi,AmanBedi,610,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0; 
        
        for(int i=0;i<s.size();++i){
            int x = s[i]-'a';
            int y = t[i]-'a'; 
            
            long long cur = 0;
            long long cur1=0;
            
            while(x!=y){
                cur+=nextCost[x]; 
                x = (x+1)%26;
            }
            
            x = s[i]-'a'; 
            y = t[i]-'a'; 
            
            while(x!=y){
                cur1+=previousCost[x]; 
                x = ((x-1)+26)%26;
            }
            ans+=min(cur,cur1);
        }
        return ans;
    }
};",1460808615
aman_bedi,AmanBedi,610,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool chance = 0; 
        int rem=10;
        while(true){
            if(n<rem){
                if(chance){
                    return 1;
                } else{
                    return 0;
                }
            } 
            chance = 1-chance;
            n-=rem; 
            --rem;
        } 
        return 0;
    }
};",1460801025
aman_bedi,AmanBedi,610,3647,cpp,"class SegmentTree{
public: 
    vector<int>tree, lazy;
    int n;
    SegmentTree(int _n){
        n = _n;
        tree = vector<int>(4*n+1,INT_MIN);
        lazy = vector<int>(4*n+1,0);
    } 
    void build(int l,int r,int v,vector<int>&arr){
        if(l==r){
            tree[v] = arr[l]; 
            return;
        } 
        int mid = (l+r)/2; 
        build(l,mid,2*v,arr); 
        build(mid+1,r,2*v+1,arr);
        
        tree[v] = max(tree[2*v],tree[2*v+1]);
    }
    void update_tree(int node, int a, int b, int i, int j, int value) {
  
  	if(lazy[node] != 0) { // This node needs to be updated
   		tree[node] += lazy[node]; // Update it

		if(a != b) {
			lazy[node*2] += lazy[node]; // Mark child as lazy
    			lazy[node*2+1] += lazy[node]; // Mark child as lazy
		}

   		lazy[node] = 0; // Reset it
  	}
  
	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return;
    
  	if(a >= i && b <= j) { // Segment is fully within range
    		tree[node] += value;

		if(a != b) { // Not leaf node
			lazy[node*2] += value;
			lazy[node*2+1] += value;
		}

    		return;
	}

	update_tree(node*2, a, (a+b)/2, i, j, value); // Updating left child
	update_tree(1+node*2, 1+(a+b)/2, b, i, j, value); // Updating right child

	tree[node] = max(tree[node*2], tree[node*2+1]); // Updating root with max value
}

/**
 * Query tree to get max element value within range [i, j]
 */
int query_tree(int node, int a, int b, int i, int j) {
	
	if(a > b || a > j || b < i) return INT_MIN; // Out of range

	if(lazy[node] != 0) { // This node needs to be updated
		tree[node] += lazy[node]; // Update it
		if(a != b) {
			lazy[node*2] += lazy[node]; // Mark child as lazy
			lazy[node*2+1] += lazy[node]; // Mark child as lazy
		}

		lazy[node] = 0; // Reset it
	}

	if(a >= i && b <= j) // Current segment is totally within range [i, j]
		return tree[node];

	int q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child
	int q2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j); // Query right child

	int res = max(q1,q2); // Return final result
	return res;
}

};
class Solution {
public:
    static bool comp(vector<int>&a, vector<int>&b){
        int len1 = a[1]-a[0]+1; 
        int len2 = b[1]-b[0]+1;
        
        if(len1==len2){
            return a[0]<b[0];
        } 
        return len1>len2;
    }
    int get(vector<int>&pref,int l,int r){
        if(l==0)return pref[r]; 
        return pref[r]-pref[l-1];
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        sort(q.begin(),q.end(),comp); 
        int n = nums.size();
        
        SegmentTree st = SegmentTree(nums.size()+2); 
        
        int ans = 0;
        
        vector<int>pref(nums.size()+1,0);
        for(auto it:q){
            pref[it[0]]+=1; 
            pref[it[1]+1]-=1; 
        } 
        for(int i=1;i<pref.size();++i){
            pref[i]+=pref[i-1];
        } 
        for(int i=0;i<nums.size();++i){
            nums[i] -= pref[i];
        }
        // for(int i=0;i<nums.size();++i){
        //     cout<<nums[i]<<' ';
        // } 
        // cout<<'\n';
        st.build(0,n-1,1,nums);
        
        if(st.query_tree(1,0,n-1,0,n-1)>0){
            return -1;
        }
        
        // for(int i=1;i<=8;++i){
        //     cout<<st.tree[i]<<' ';
        // } 
        // cout<<'\n';
        
        for(int i=q.size()-1;i>=0;--i){
            int l=q[i][0], r=q[i][1];
            int x = st.query_tree(1,0,n-1,l,r);
            // cout<<l<<' '<<r<<' '<<x<<'\n';
            if(x<0){
                ++ans; 
                st.update_tree(1,0,n-1,l,r,1);
            }
        } 
        // cout<<'\n';
        
        return ans;
        
        
    }
};",1460885925
Achille Nazaret,anazaret,612,3591,python3,"def letter(i):
    return chr(ord(""a"") + i)


def sum_next(arr, i, j):
    if i <= j:
        return sum(arr[i:j])
    if j < i:
        return sum(arr[:j]) + sum(arr[i:])


def sum_prev(arr, i, j):
    if i <= j:
        return sum(arr[:i+1]) + sum(arr[j+1:])
    if j < i:
        return sum(arr[j+1:i+1])
        
class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        # for each pair of letter, compute the min cost
        costs = {letter(i): dict() for i in range(26)}
        for i in range(26):
            for j in range(26):
                costs[letter(i)][letter(j)] = min(sum_next(nextCost, i, j), sum_prev(previousCost, i, j))
        return sum([costs[a][b] for a,b in zip(s,t)])
            ",1460828986
Achille Nazaret,anazaret,612,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        for i,stone in enumerate(range(10,0,-1)):
            alice_turn = i % 2 == 0
            if n < stone:
                return not alice_turn
            n -= stone
                
        ",1460803875
Achille Nazaret,anazaret,612,3647,python3,"
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        # nums[i] needs at least nums[i] queries covering it
        # how do we pick which one? can greedy work?
        # is it a max flow problm?
        # [1,1,1,1,1]
        # [0,2] then [3,3] [4,4]
        # or we do [0,1] [2,4]
        # but [2,4] would still be available 
        # let's try greedy
        
        
        # graph: numbers and queries? no 10^10 edges ...
        # oh i know ... 
        # do the cumsum, then what.
        # always better to take larger query
        # of ofc start from left and take largest

        queries.sort(key=lambda q: (q[0], -(q[1]-q[0])))
        idx = 0
        q_idx = 0
        used_queries = 0
        cum_count = 0
        end_indices = []
        available_ends = []
        while idx < len(nums):
            # add the new available queries
            while q_idx < len(queries) and queries[q_idx][0] <= idx:
                heapq.heappush(available_ends, -queries[q_idx][1])
                q_idx += 1
                    
            while nums[idx] > cum_count:
                if not available_ends or -available_ends[0] < idx:
                    return -1
                end = -heapq.heappop(available_ends)
                used_queries += 1
                cum_count += 1
                heapq.heappush(end_indices, end)

            while end_indices and end_indices[0] == idx:
                heapq.heappop(end_indices)
                cum_count -= 1
            idx += 1

        return len(queries) - used_queries",1460891958
alwaysprod,alwaysprod,613,3591,cpp,"class Solution {
public:
    
    long long int calcRight(vector<int> &nc, char x, char t) {
        long long int crr = 0;
        while(x != t) {
            crr += nc[x-'a'];
            if(x == 'z')
                x = 'a';
            else x++;
        }
        return crr;
    }
    
    long long int calcLeft(vector<int> &nc, char x, char t) {
        long long int crr = 0;
        while(x != t) {
            crr += nc[x-'a'];
            if(x == 'a')
                x = 'z';
            else x--;
        }
        return crr;
    }
    
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        for(int i = 0 ; i < s.size() ; i++) {
            res += min(calcRight(nextCost, s[i],t[i]), calcLeft(previousCost, s[i], t[i]));
        }
        return res;
    }
};",1460828003
alwaysprod,alwaysprod,613,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 1;
        int toRemove = 10;
        while(n >= toRemove && toRemove) {
            n -= toRemove;
            toRemove--;
            turn ^= 1;
        }
        return turn^1;
    }
};",1460819082
alwaysprod,alwaysprod,613,3647,cpp,"class Solution {
public:
    

class SegmentTree {
private:
    struct Node {
        int minVal;  // Minimum value in this range
        int lazy;    // Lazy propagation value
    };

    std::vector<Node> tree;
    int n;

    void buildTree(const std::vector<int>& arr, int start, int end, int node) {
        if (start == end) {
            // Leaf node
            tree[node].minVal = arr[start];
            tree[node].lazy = 0;
        } else {
            int mid = start + (end - start) / 2;
            buildTree(arr, start, mid, 2 * node + 1);
            buildTree(arr, mid + 1, end, 2 * node + 2);
            tree[node].minVal = std::min(tree[2 * node + 1].minVal, tree[2 * node + 2].minVal);
            tree[node].lazy = 0;
        }
    }

    void propagate(int start, int end, int node) {
        if (tree[node].lazy != 0) {
            // Apply lazy value to current node
            tree[node].minVal -= tree[node].lazy;

            if (start != end) {
                // Propagate laziness to children
                tree[2 * node + 1].lazy += tree[node].lazy;
                tree[2 * node + 2].lazy += tree[node].lazy;
            }

            // Clear lazy value for current node
            tree[node].lazy = 0;
        }
    }

    void updateRange(int l, int r, int start, int end, int node) {
        propagate(start, end, node);

        if (start > r || end < l) {
            // No overlap
            return;
        }

        if (start >= l && end <= r) {
            // Complete overlap
            tree[node].lazy += 1;  // Increment lazy value
            propagate(start, end, node);
            return;
        }

        // Partial overlap
        int mid = start + (end - start) / 2;
        updateRange(l, r, start, mid, 2 * node + 1);
        updateRange(l, r, mid + 1, end, 2 * node + 2);
        tree[node].minVal = std::min(tree[2 * node + 1].minVal, tree[2 * node + 2].minVal);
    }

    int queryRange(int l, int r, int start, int end, int node) {
        propagate(start, end, node);

        if (start > r || end < l) {
            // No overlap
            return INT_MAX;
        }

        if (start >= l && end <= r) {
            // Complete overlap
            return tree[node].minVal;
        }

        // Partial overlap
        int mid = start + (end - start) / 2;
        int leftMin = queryRange(l, r, start, mid, 2 * node + 1);
        int rightMin = queryRange(l, r, mid + 1, end, 2 * node + 2);
        return std::min(leftMin, rightMin);
    }

public:
    SegmentTree(const std::vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        buildTree(arr, 0, n - 1, 0);
    }

    void decrementRange(int l, int r) {
        updateRange(l, r, 0, n - 1, 0);
    }

    int getMin(int l, int r) {
        return queryRange(l, r, 0, n - 1, 0);
    }
};

    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n=nums.size();
        sort(queries.begin(),queries.end());
        vector<int> x(n+1);
        for(vector<int> q:queries) {
            x[q[0]]++;
            x[q[1]+1]--;
        }
        for(int i = 1 ; i < n ; i++) {
            x[i] += x[i-1];
        }
        
        vector<int> diff;
        for(int i = 0 ; i < n ;i++) {
            if(nums[i] > x[i])  return -1;
            diff.push_back(x[i]-nums[i]);
        }

        SegmentTree seg(diff);
        
        int res = 0;
        map<int, vector<vector<int>>> h;
        for(vector<int> q:queries){
            h[q[1]-q[0]].push_back(q);
        }
        
        for(auto &[size,qq]:h) {
            //cout<<size<<"" ""<<qq.size()<<endl;
            for(vector<int> q:qq) {
                int get_min = seg.getMin(q[0],q[1]);
                if(get_min > 0) {
                    seg.decrementRange(q[0],q[1]);
                    res++;
                }
            }
        }
        
        return res;
    }
};",1460891979
akash_codes2,akash_codes2,614,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            char start = s.charAt(i);
            char end = t.charAt(i);

            int forwardSteps = (end - start + 26) % 26;
            int backwardSteps = (start - end + 26) % 26;

            long forwardCost = 0;
            for (int j = 0; j < forwardSteps; j++) {
                forwardCost += nextCost[(start - 'a' + j) % 26];
            }

            long backwardCost = 0;
            for (int j = 0; j < backwardSteps; j++) {
                backwardCost += previousCost[(start - 'a' - j + 26) % 26];
            }

            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}
",1460804953
akash_codes2,akash_codes2,614,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10) {
            return false; 
        }
        
        int stonesToRemove = 10; 
        boolean isAliceTurn = true;

        while (n > 0) {
            if (n < stonesToRemove) {
                return !isAliceTurn;
            }
            n -= stonesToRemove;
            stonesToRemove--; 
            isAliceTurn = !isAliceTurn; 
        }

        return !isAliceTurn;
    }
}
",1460797106
akash_codes2,akash_codes2,614,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int numCount = nums.size();
        int queryCount = queries.size();
        
        vector<int> rangeCoverage(numCount + 1, 0);
        processQueries(queries, rangeCoverage, numCount);

        if (!checkFeasibility(rangeCoverage, nums, numCount)) {
            return -1;
        }

        vector<tuple<int, int, int>> sortedQueries;
        sortQueries(queries, sortedQueries, queryCount);
        
        priority_queue<pair<int, int>> queryHeap;
        vector<int> coverageAdjustments(numCount + 1, 0);
        int totalAdjustment = 0;
        unordered_set<int> selectedQueries;

        int queryPointer = 0;
        for(int i = 0; i < numCount; i++){
            totalAdjustment += coverageAdjustments[i];

            processHeap(queryHeap, sortedQueries, queryPointer, i);

            while(!queryHeap.empty() && queryHeap.top().first < i){
                queryHeap.pop();
            }

            int currentCoverage = totalAdjustment;

            if(currentCoverage < nums[i]){
                int requiredCoverage = nums[i] - currentCoverage;
                for(int j = 0; j < requiredCoverage; j++){
                    if(queryHeap.empty()){
                        return -1;
                    }
                    auto topQuery = queryHeap.top();
                    queryHeap.pop();
                    int queryEnd = topQuery.first;
                    int queryId = topQuery.second;
                    selectedQueries.insert(queryId);
                    coverageAdjustments[i] += 1;
                    if(queryEnd + 1 < numCount){
                        coverageAdjustments[queryEnd + 1] -= 1;
                    }
                    totalAdjustment += 1;
                }
            }
        }

        return queryCount - selectedQueries.size();
    }

private:
    void processQueries(const vector<vector<int>>& queries, vector<int>& rangeCoverage, int numCount) {
        for(auto &query : queries){
            int start = query[0];
            int end = query[1];
            rangeCoverage[start] += 1;
            if(end + 1 < numCount){
                rangeCoverage[end + 1] -= 1;
            }
        }

        for(int i = 1; i < numCount; i++){
            rangeCoverage[i] += rangeCoverage[i - 1];
        }
    }

    bool checkFeasibility(const vector<int>& rangeCoverage, const vector<int>& nums, int numCount) {
        for(int i = 0; i < numCount; i++){
            if(rangeCoverage[i] < nums[i]){
                return false;
            }
        }
        return true;
    }

    void sortQueries(const vector<vector<int>>& queries, vector<tuple<int, int, int>>& sortedQueries, int queryCount) {
        sortedQueries.reserve(queryCount);
        for(int i = 0; i < queryCount; i++){
            sortedQueries.emplace_back(queries[i][0], queries[i][1], i);
        }
        sort(sortedQueries.begin(), sortedQueries.end(), [&](const tuple<int,int,int> &a, const tuple<int,int,int> &b) -> bool{
            if(get<0>(a) == get<0>(b)){
                return get<1>(a) > get<1>(b);
            }
            return get<0>(a) < get<0>(b);
        });
    }

    void processHeap(priority_queue<pair<int, int>>& queryHeap, const vector<tuple<int, int, int>>& sortedQueries, int& queryPointer, int i) {
        while(queryPointer < sortedQueries.size() && get<0>(sortedQueries[queryPointer]) <= i){
            int end = get<1>(sortedQueries[queryPointer]);
            int queryId = get<2>(sortedQueries[queryPointer]);
            queryHeap.emplace(end, queryId);
            queryPointer++;
        }
    }
};
",1460886298
PseudoCoder,mission_conquer,615,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        for(int i=0;i<s.length();i++) {
            int x = s.charAt(i)-'a';
            int y = t.charAt(i)-'a';
            long next = 0;
            for(int tt = x; tt!=y; tt = (tt+1)%26) {
                next += (long)nextCost[tt];
            }
            long prev = 0;
            for(int tt = x; tt!=y; tt = (tt-1+26)%26) {
                prev += (long)previousCost[tt];
            }
            ans = ans + Math.min(next, prev);
        }
        return ans;
    }
}",1460825495
PseudoCoder,mission_conquer,615,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if(n < 10)
            return false;
        else if(n<19)
            return true;
        else if(n<27)
            return false;
        else if(n<34)
            return true;
        else if(n<40)
            return false;
        else if(n<45)
            return true;
        else if(n<49)
            return false;
        else
            return true;
    }
}",1460802029
PseudoCoder,mission_conquer,615,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (x, y)-> {
            return x[0] == y[0]? x[1]-y[1]:x[0]-y[0];
        });
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((x, y)-> {
            return y[1] - x[1];
        });

        int arr[] = new int[nums.length+2];
        int n = nums.length;
        int pos = 0;
        int anss = 0;
        for(int i=0;i<n;i++) {
            while(pos<queries.length && queries[pos][0]<=i)
                pq.add(queries[pos++]);
            // if(i == 2)
            //     for(int rt[]: pq)
            //         //System.out.println(rt[0]+"":""+rt[1]);
            if(i>0)
                arr[i] += arr[i-1];
            nums[i] = nums[i] - arr[i];
            while(nums[i]>0) {
                if(pq.isEmpty())
                    return -1;
                int t[] = pq.poll();
                //for(int x: arr)
                 //   System.out.print(x+""  "");
               // System.out.println(i +"":""+ nums[i]+"":""+t[0]+"";""+t[1]);
                if(t[1]>=i){
                    arr[i+1]++;
                    arr[t[1]+1]--;
                    nums[i]--;
                }
                else
                    anss++;
            }
        }
        return anss+pq.size();
    }
}",1460887016
chirag2505,chirag2505,616,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost1, vector<int>& previousCost1) {
        int n = s.length();
        vector<long long> nextCost(26);
        nextCost[0] = nextCost1[0];
        
        vector<long long> previousCost(26);
        previousCost[0] = previousCost1[0];
        
        for(int i=1;i<26;i++){
            nextCost[i] = nextCost[i-1]+nextCost1[i];
            previousCost[i] = previousCost[i-1]+previousCost1[i];
        }
         long long sum = 0;
    
        for(int i=0;i<n;i++){
            if(t[i]>s[i]){
                long long fwdCost = nextCost[t[i]-'a'-1]- ((s[i]-'a'-1<0)?0:nextCost[s[i]-'a'-1]);
                long long bwdCost = previousCost[s[i]-'a'] + previousCost[25] - previousCost[t[i]-'a'];
                // cout<< fwdCost << "" "" << bwdCost << endl;
                sum += min(fwdCost,bwdCost);
                
            }
            else if(t[i]<s[i]){
                long long bwdCost = previousCost[s[i]-'a'] - previousCost[t[i]-'a'];
                long long fwdCost = ((t[i]-'a'-1<0)?0:nextCost[t[i]-'a'-1]) + nextCost[25] - nextCost[s[i]-'a'-1];
                // cout<< fwdCost << "" "" << bwdCost << endl;
                sum += min(fwdCost,bwdCost);
            }
        }
        
        return sum;
    }
};",1460846830
chirag2505,chirag2505,616,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 0; //Alice
        int k = 10;
        while(n>=k){
            n-=k;
            k--;
            cnt++;
        }
        return (cnt%2!=0);
    }
};",1460802895
chirag2505,chirag2505,616,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        
        int ans = 0;
        
        vector<vector<int>> dp(n);
        
        for(int i=0;i<m;i++){
            int l = queries[i][0];
            int r = queries[i][1];
            dp[l].push_back(r);
        }
        
        priority_queue<int> pq; // will contain possible operations last index
        
        vector<int> prefix(n+1,0);
        int val = 0;
        int cost = 0;
        
        for(int i=0;i<n;i++){
            // cout << ""start at i="" << i << endl;
            val += prefix[i];
            for(auto k:dp[i]) pq.push(k); //adding all new opened operations
            // cout << val << "" val::"" << endl;
            while(nums[i]>val && !pq.empty()){
                int k = pq.top();
                // cout << k << endl;
                pq.pop();
                if(k<i) continue;
                prefix[k+1]--;
                val++;
                cost ++ ;
            }
            
            if(nums[i]>val) return -1;
        }
        
        return m-cost;
        
    }
};",1460875444
kagotpush,kagotpush,617,3591,python3,"class Solution:
    def shiftDistance(self, s1: str, t: str, nextCost: List[int], prevCost: List[int]) -> int:
        ans=0
        dist=[[inf]*26 for _ in range(26)]
        for i in range(26):
            dist[i][i]=0
            s=nextCost[i]
            for j in range(i+1,i+26):
                j%=26
                dist[i][j]=min(dist[i][j],s)
                s+=nextCost[j]
            s=prevCost[i]
            for j in range(i-1,i-27,-1):
                j%26
                dist[i][j]=min(dist[i][j],s)
                s+=prevCost[j]
        for c1,c2 in zip(s1,t):
            ans+=dist[ord(c1)-ord('a')][ord(c2)-ord('a')]
        return ans",1460828457
kagotpush,kagotpush,617,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        a=False
        for i in range(10,-1,-1):
            if n<i:
                return a
            a=not a
            n-=i
        return a",1460797567
kagotpush,kagotpush,617,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        n=len(queries)
        m=len(nums)
        dump=0
        j=0
        decs=[0]*(m+1)
        s=0
        heap=[]
        for i,x in enumerate(nums):
            s-=decs[i]
            if x>s:
                while j<n and queries[j][1]<i:
                    j+=1
                    dump+=1
                if heap and -heap[0]<i:
                    dump+=len(heap)
                    heap=[]
                while j<n and queries[j][0]<=i:
                    heappush(heap,-queries[j][1])
                    j+=1
                # if x==5:
                #     print(f'kek {i=} {x=} {s=} {decs=} {dump=} {heap=}')
                while x>s and heap and -heap[0]>=i:
                    r=-heappop(heap)
                    s+=1
                    decs[r+1]+=1
                if x>s: return -1
            # print(f'{i=} {x=} {s=} {decs=} {dump=} {heap=}')
        return dump+len(heap)+n-j",1460893082
Sudhanshu Kumar,kumarsudhanshu596,618,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
    int n = s.size();
        long long tc = 0;
        int ss=0;
        for(int i=0;i<3;i++){
            ss++;
        }
        for (int i = 0; i < n; ++i) {
              int b = t[i] - 'a';
            int a = s[i] - 'a';
            ss++;
            int cw = (b - a + 26) % 26;
            long long cc = 0;
            for (int j = 0; j < cw; ++j) {
                cc += nc[(a + j) % 26];
            }
            int ccw = (a - b + 26) % 26;
            long long ccc = 0;
            int xyz=0;
            for (int j = 0; j < ccw; ++j) {
                ccc += pc[(a - j + 26) % 26];
            }
            tc= tc+min(cc, ccc);
        }
        for(int i=0;i<3;i++){
            ss++;
        }
        return tc;
            

    }
};",1460850078
Sudhanshu Kumar,kumarsudhanshu596,618,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
         int s= 10;
    while (n >= s) {
        n -= s;
        s=s-1;
    }
        int t=0;
    return s % 2 == 1;
    }
};",1460808243
Sudhanshu Kumar,kumarsudhanshu596,618,3647,cpp,"class SegmentTree {
    vector<int> tree, lazy;
    int n;

public:
    SegmentTree(int size) {
        n = size;
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
    }

    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            build(arr, 2 * node, start, mid);
            build(arr, 2 * node + 1, mid + 1, end);
            tree[node] = min(tree[2 * node], tree[2 * node + 1]);
        }
    }

    void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] -= lazy[node];
            if (start != end) {
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void decrement_range(int node, int start, int end, int l, int r) {
        propagate(node, start, end);
        if (start > r || end < l) return;
        if (start >= l && end <= r) {
            lazy[node]++;
            propagate(node, start, end);
            return;
        }
        int mid = (start + end) / 2;
        decrement_range(2 * node, start, mid, l, r);
        decrement_range(2 * node + 1, mid + 1, end, l, r);
        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }

    int query_min(int node, int start, int end, int l, int r) {
        propagate(node, start, end);
        if (start > r || end < l) return INT_MAX;
        if (start >= l && end <= r) return tree[node];
        int mid = (start + end) / 2;
        int left_min = query_min(2 * node, start, mid, l, r);
        int right_min = query_min(2 * node + 1, mid + 1, end, l, r);
        return min(left_min, right_min);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        int n = a.size(), m = q.size();
        int dd=0;
        for(int i=0;i<2;i++)dd++;
        vector<int> c(n + 1, 0);
        for (auto& p : q) {
            c[p[0]]++;
            if (p[1] + 1 < n) c[p[1] + 1]--;
        }
        for (int i = 1; i < n; i++) c[i] += c[i - 1];
        c.pop_back();
        vector<int> al(n, 0);
        for (int i = 0; i < n; i++) {
            al[i] = c[i] - a[i];
            if (al[i] < 0) return -1;
        }
         for(int i=0;i<2;i++)dd++;
        vector<pair<int, int>> sq;
        sq.reserve(m);
         for(int i=0;i<2;i++)dd++;
        for (auto& p : q) sq.emplace_back(p[0], p[1]);
        sort(sq.begin(), sq.end(), [&](const pair<int, int>& x, const pair<int, int>& y) {
            int lx = x.second - x.first + 1, ly = y.second - y.first + 1;
            return lx != ly ? lx < ly : x.first < y.first;
        });
        SegmentTree st(n);
        st.build(al, 1, 0, n - 1);
        int r = 0;
         for(int i=0;i<2;i++)dd++;
        for (auto& [l, h] : sq) {
            if (st.query_min(1, 0, n - 1, l, h) >= 1) {
                st.decrement_range(1, 0, n - 1, l, h);
                r++;
            }
        }
         for(int i=0;i<2;i++)dd++;
        return r;
    }
};
",1460893114
Do Duy Loi,LuOsIer,619,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prv) {
        long long ans = 0;
        for(int i = 0; i < s.size(); i++) {
            long long add = 0, mis = 0;
            if (s[i] == t[i]) continue;
            char c = s[i];
            while(c != t[i]) {
                add += nxt[c - 'a'];
                if (c == 'z') c = 'a';
                else c++;
            }
            c = s[i];
            while(c != t[i]) {
                mis += prv[c - 'a'];
                if (c == 'a') c = 'z';
                else c--;
            }
            ans += min(add, mis);
        }
        return ans;
    }
};",1460818148
Do Duy Loi,LuOsIer,619,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cur = 0;
        int rem = 10;
        while(rem <= n) {
            n -= rem;
            cur ^= 1;
            rem--;
        }
        return cur;
    }
};",1460797678
Do Duy Loi,LuOsIer,619,3647,cpp,"class Solution {
public:
    static bool cmp(const vector<int>& x, const vector<int>& y) {
        return x[0] < y[0];
    }

    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        sort(q.begin(), q.end(), cmp);
        int i = 0, m = q.size(), j = 0, n = a.size();
        priority_queue<int> pq;
        vector<int> dif(n + 1, 0);
        int cur = 0, ans = 0;
        while(j < n) {
            cur += dif[j];
            while(i < m && q[i][0] <= j) pq.push(q[i++][1]);
            while(cur < a[j]) {
                if (pq.empty() || pq.top() < j) return -1;
                int t = pq.top(); pq.pop();
                ans++;
                cur++;
                dif[t + 1]--;
            }
            j++;
        }
        return m - ans;
    }
};",1460887681
soimportant,soimportant,620,3591,cpp,"const long long inf = (long long) 1e18 + 5;

class Solution {
public:
  long long shiftDistance(string s, string t, vector<int>& a, vector<int>& b) {
    long long ans = 0;
    int n = 26;
    vector<vector<long long>> dis(n, vector<long long>(n, inf));
    for (int i = 0; i < 26; i++) {
      dis[i][i] = 0;
    }
    for (int i = 0; i < 26; i++) {
      dis[i][(i + 1) % 26] = a[i];
    }
    for (int i = 0; i < 26; i++) {
      dis[i][(i + 25) % 26] = b[i];
    }

    for (int k = 0; k < n; k++) {
      for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
          dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
        }
      }
    }

    int len = (int) s.size();
    for (int i = 0; i < len; i++) {
      int x = s[i] - 'a';
      int y = t[i] - 'a';
      ans += dis[x][y];
    }
    return ans;
  }
};",1460816657
soimportant,soimportant,620,3625,cpp,"class Solution {
public:
  bool canAliceWin(int n) {
    bool f = false;
    for (int i = 10; i >= 1; i--) {
      if (n < i) {
        return f;
      }
      n -= i;
      f = !f;
    }
    return false;
  }
};",1460802376
soimportant,soimportant,620,3647,cpp,"
class segtree {
public:
  class node {
  public:
    /**
     * Initialize the data member of leaves
     */
    node() {

    }

    node(int x) {
      val = x;
    }

    /**
     * determine how to modify the property of a segment
     * remember to set the lazy flag
     */
    void apply(int s) {
      val -= s;
      val = max(val, 0);
      sub += s;
      oper = true;
    }


    /**
     * define the property of a segment
     * default is the start index and end index
     */
    std::size_t st, ed;
    int val = 0;
    int sub = 0;
    bool oper = false;
  };

  /**
   * get the merge result from two segments
   */
  node merge(const node& a, const node& b) {
    node res{};
    res.st = min(a.st, b.st);
    res.ed = max(a.ed, b.ed);

    res.val = min(a.val, b.val);
    return res;
  }

  /**
   * push property of the node to its child node
   */
  void push(int idx) {
    int idxL = idx * 2, idxR = idx * 2 + 1;

    /**
     * if the lazy flag is set, push the property to its child
     */
    if (tree[idx].oper) {
      tree[idxL].apply(tree[idx].sub);
      tree[idxR].apply(tree[idx].sub);
      tree[idx].sub = 0;
      tree[idx].oper = false;
    }
  }

  segtree(int _n) : n(_n) {
    assert(n > 0);
    int sz = 1;
    while (sz < n) {
      sz <<= 1;
    }
    tree.resize(sz << 1);
    build(1, 0, n - 1);
  }
  template<class T>
  segtree(const vector<T>& v) {
    n = (int) v.size();
    assert(n > 0);
    int sz = 1;
    while (sz < n) {
      sz <<= 1;
    }
    tree.resize(sz << 1);
    build(v, 1, 0, n - 1);
  }

  template<class T>
  void build(const vector<T>& v) {
    assert((int) v.size() == n);
    build(v, 1, 0, n - 1);
  }

  template<class ...T>
  void modify(int l, int r, const T&... val) {
    assert(0 <= l && l <= r && r < n);
    modify(l, r, 1, 0, n - 1, val...);
  }
  node get(int l, int r) {
    assert(0 <= l && l <= r && r < n);
    return get(l, r, 1, 0, n - 1);
  }
  node get(int p) {
    assert(0 <= p && p < n);
    return get(p, p, 1, 0, n - 1);
  }
  int find_last(int l, int r, const function<bool(const node&)>& f) {
    return find_last(l, r, 1, 0, n - 1, f);
  }

  int find_first(int l, int r, const function<bool(const node&)>& f) {
    return find_first(l, r, 1, 0, n - 1, f);
  }

private:
  void build(int idx, int l, int r) {
    if (l == r) {
      tree[idx].st = tree[idx].ed = l;
      return;
    }
    int mid = (l + r) >> 1, idxL = idx * 2, idxR = idx * 2 + 1;
    build(idxL, l, mid);
    build(idxR, mid + 1, r);
    tree[idx] = merge(tree[idxL], tree[idxR]);
  }

  template<class T>
  void build(const vector<T>& v, int idx, int l, int r) {
    if (l == r) {
      tree[idx].st = tree[idx].ed = l;
      tree[idx] = node(v[l]);
      return;
    }
    int mid = (l + r) >> 1, idxL = idx * 2, idxR = idx * 2 + 1;
    build(v, idxL, l, mid);
    build(v, idxR, mid + 1, r);
    tree[idx] = merge(tree[idxL], tree[idxR]);
  }

  template<class... T>
  void modify(const int& ql, const int& qr, int idx, int l, int r, T... val) {
    if (ql <= l && r <= qr) {
      tree[idx].apply(val...);
      return;
    }
    push(idx);
    int mid = (l + r) >> 1, idxL = idx * 2, idxR = idx * 2 + 1;
    if (ql <= mid) {
      modify(ql, qr, idxL, l, mid, val...);
    }
    if (qr > mid) {
      modify(ql, qr, idxR, mid + 1, r, val...);
    }
    tree[idx] = merge(tree[idxL], tree[idxR]);
  }

  node get(int ql, int qr, int idx, int l, int r) {
    if (ql <= l && r <= qr) {
      return tree[idx];
    }
    push(idx);
    int mid = (l + r) >> 1, idxL = idx * 2, idxR = idx * 2 + 1;
    node res{};
    if (qr <= mid) {
      res = get(ql, qr, idxL, l, mid);
    } else if (ql > mid) {
      res = get(ql, qr, idxR, mid + 1, r);
    } else {
      res = merge(get(ql, qr, idxL, l, mid), get(ql, qr, idxR, mid + 1, r));
    }
    return res;
  }

  int find_last(int ql, int qr, int idx, int l, int r, const function<bool(const node&)>& f) {
    int mid = (l + r) >> 1, idxL = idx * 2, idxR = idx * 2 + 1;
    if (l > qr || r < ql) {
      return -1;
    }
    if (!f(tree[idx])) {
      return -1;
    } else {
      if (l == r) {
        return l;
      }
    }
    push(idx);
    int res = find_last(ql, qr, idxR, mid + 1, r, f);
    if (res == -1) {
      res = find_last(ql, qr, idxL, l, mid, f);
    }
    return res;
  }

  int find_first(int ql, int qr, int idx, int l, int r, const function<bool(const node&)>& f) {
    int mid = (l + r) >> 1, idxL = idx * 2, idxR = idx * 2 + 1;
    if (l > qr || r < ql) {
      return -1;
    }
    if (!f(tree[idx])) {
      return -1;
    } else {
      if (l == r) {
        return l;
      }
    }
    push(idx);
    int res = find_first(ql, qr, idxL, l, mid, f);
    if (res == -1) {
      res = find_first(ql, qr, idxR, mid + 1, r, f);
    }
    return res;
  }

  int n;
  vector<node> tree;
};

using segnode = segtree::node;


class Solution {
public:
  int maxRemoval(vector<int>& v, vector<vector<int>>& q) {
    int n = (int) v.size();
    sort(q.begin(), q.end());
    vector<int> cnt(n + 1);
    for (auto& a : q) {
      int st = a[0], ed = a[1];
      cnt[st]++;
      cnt[ed + 1]--;
    }

    vector<int> diff(n);
    int cur = 0;
    for (int i = 0; i < n; i++) {
      cur += cnt[i];
      if (cur < v[i]) {
        return -1;
      }
      diff[i] = cur - v[i];
    }

    segtree seg(diff);

    sort(q.begin(), q.end(), [&](auto& a, auto& b) {
      int d1 = a[1] - a[0];
      int d2 = b[1] - b[0];
      return d1 < d2;
    });

    int ans = 0;
    for (auto& a : q) {
      int st = a[0], ed = a[1];
      if (seg.get(st, ed).val > 0) {
        ans++;
        seg.modify(st, ed, 1);
      }
    }
    return ans;
    // return ans;
  }
};",1460881911
Pranav,pprranav,621,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        fc = [[0] * 26 for _ in range(26)]
        bc = [[0] * 26 for _ in range(26)]
        for i in range(26):
            c = i
            total = 0
            for k in range(1,26):
                c = (c + 1) % 26
                total += nextCost[(c-1)%26]
                fc[i][c] = total
                
        for i in range(26):
            c = i
            total = 0
            for k in range(1,26):
                c = (c - 1) %26
                total += previousCost[(c+1)%26]
                bc[i][c] = total
                
        res = 0
        for a, b in zip(s,t):
            ca = ord(a)-97
            cb = ord(b)-97
            res += min(fc[ca][cb], bc[ca][cb])
        return res",1460818774
Pranav,pprranav,621,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        c=10
        p=0
        while True:
            if n>=c:
                n-=c
            else:
                return p==1
            c-=1
            if c==0:
                return p==0
            p=1-p",1460798589
Pranav,pprranav,621,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n, m = len(nums), len(queries)
        diff = [0]*(n+1)
        for l, r in queries:
            diff[l] += 1
            if r+1 < n:
                diff[r+1] -= 1
                
        c = [0]*n
        c[0] = diff[0]
        for i in range(1, n):
            c[i] = c[i-1] + diff[i]
        for i in range(n):
            if c[i] < nums[i]:
                return -1
        rem = [c[i] - nums[i] for i in range(n)]

        class Seg:
            def __init__(self, data):
                self.N = 1
                while self.N < len(data):
                    self.N <<= 1
                self.size = self.N * 2
                self.minv = [0]*(self.N * 2)
                self.lazy = [0]*(self.N * 2)
                
                for i in range(len(data)):
                    self.minv[self.N +i] = data[i]
                for i in range(self.N -1,0,-1):
                    self.minv[i] = min(self.minv[2*i], self.minv[2*i+1])
                    
            def push(self, node):
                if self.lazy[node]:
                    self.minv[2*node] -= self.lazy[node]
                    self.minv[2*node+1] -= self.lazy[node]
                    self.lazy[2*node] += self.lazy[node]
                    self.lazy[2*node+1] += self.lazy[node]
                    self.lazy[node] = 0
                    
            def query_min(self, l, r, node=1, nl=0, nr=None):
                if nr is None:
                    nr = self.N -1
                if r < nl or nr < l:
                    return float('inf')
                if l <= nl and nr <=r:
                    return self.minv[node]
                self.push(node)
                mid = (nl + nr)//2
                return min(self.query_min(l, r, 2*node, nl, mid), self.query_min(l, r, 2*node +1, mid+1, nr))
                
            def update(self, l, r, val, node=1, nl=0, nr=None):
                if nr is None:
                    nr = self.N - 1
                if r < nl or nr < l:
                    return
                if l <= nl and nr <= r:
                    self.minv[node] -= val
                    self.lazy[node] += val
                    return
                self.push(node)
                mid = (nl + nr) // 2
                self.update(l, r, val, 2*node, nl, mid)
                self.update(l, r, val, 2*node+1, mid+1, nr)
                self.minv[node] = min(self.minv[2*node], self.minv[2*node+1])
                
        st = Seg(rem)
        res = 0
        s = sorted(queries, key=lambda x: x[1])
        for q in s:
            l, r = q
            if st.query_min(l, r) >= 1:
                res += 1
                st.update(l, r, 1)
        return res
",1460893532
Clobber2,Clobber2,622,3591,java,"import java.util.Arrays;

class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[][] next=new long[26][26];
        long[][] prev=new long[26][26];

        for (int i=0;i<26;i++){
            Arrays.fill(next[i],Long.MAX_VALUE);
            Arrays.fill(prev[i],Long.MAX_VALUE);
        }
        for (int i=0;i<26;i++){
            next[i][i]=0;
            prev[i][i]=0;
            int p=((i-1)%26+26)%26;
            next[p][i]=nextCost[p];
            prev[i][p]=previousCost[i];
        }
        floydWarshall(26,next);
        floydWarshall(26,prev);
        // for (int i=0;i<26;i++)
        //     System.out.println(Arrays.toString(next[i]));
        // for (int i=0;i<26;i++)
        //     System.out.println(Arrays.toString(prev[i]));
        int n=s.length();
        long ans=0;
        for (int i=0;i<n;i++){
            ans+=Math.min(next[s.charAt(i)-'a'][t.charAt(i)-'a'],prev[s.charAt(i)-'a'][t.charAt(i)-'a']);
        }
        return ans;
    }
    void floydWarshall(int n, long[][] dis) {
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dis[k][j] != Long.MAX_VALUE && dis[i][k] != Long.MAX_VALUE)
                        dis[i][j] = Math.min(dis[i][j], dis[i][k] + dis[k][j]);
                }
            }
        }
    }
}",1460829763
Clobber2,Clobber2,622,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int cur=10;
        int ans=0;
        while(n>=cur){
            n-=cur;cur--;
            ans++;
        }
        return ans%2==1;
    }
}",1460798093
Clobber2,Clobber2,622,3647,java,"import java.util.Arrays;

class LazySegmentTree
{
    int tree[];
    int lazy[];

    LazySegmentTree(int n){
        tree=new int[4*n];
        lazy=new int[4*n];
        Arrays.fill(tree,Integer.MIN_VALUE);
    }

    void updateRangeUtil(int si, int ss, int se, int us,
                         int ue, int diff)
    {
        if (lazy[si] != 0)
        {

            tree[si] += lazy[si];
            if (ss != se)
            {

                lazy[si * 2 + 1] += lazy[si];
                lazy[si * 2 + 2] += lazy[si];
            }


            lazy[si] = 0;
        }

        if (ss > se || ss > ue || se < us)
            return;

        if (ss >= us && se <= ue)
        {
            tree[si] += diff;
            if (ss != se)
            {

                lazy[si * 2 + 1] += diff;
                lazy[si * 2 + 2] += diff;
            }
            return;
        }

        int mid = (ss + se) / 2;
        updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);
        updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);

        tree[si] = Math.max(tree[si * 2 + 1],tree[si * 2 + 2]);
    }

    void updateRange(int n, int us, int ue, int diff) {
        updateRangeUtil(0, 0, n - 1, us, ue, diff);
    }

    int getMaxUtil(int ss, int se, int qs, int qe, int si)
    {

        if (lazy[si] != 0)
        {

            tree[si] += lazy[si];
            if (ss != se)
            {
                lazy[si * 2 + 1] += lazy[si];
                lazy[si * 2 + 2] += lazy[si];
            }

            lazy[si] = 0;
        }

        if (ss > se || ss > qe || se < qs)
            return Integer.MIN_VALUE;

        if (ss >= qs && se <= qe)
            return tree[si];

        int mid = (ss + se) / 2;
        return Math.max(getMaxUtil(ss, mid, qs, qe, 2 * si + 1),
                getMaxUtil(mid + 1, se, qs, qe, 2 * si + 2));
    }

    int getMax(int n, int qs, int qe)
    {
        if (qs < 0 || qe > n - 1 || qs > qe)
        {
            return Integer.MIN_VALUE;
        }

        return getMaxUtil(0, n - 1, qs, qe, 0);
    }

    void constructSTUtil(int arr[], int ss, int se, int si)
    {
        if (ss > se)
            return;

        if (ss == se)
        {
            tree[si] = arr[ss];
            return;
        }

        int mid = (ss + se) / 2;
        constructSTUtil(arr, ss, mid, si * 2 + 1);
        constructSTUtil(arr, mid + 1, se, si * 2 + 2);

        tree[si] = Math.max(tree[si * 2 + 1], tree[si * 2 + 2]);
    }

    void constructST(int arr[], int n)
    {
        constructSTUtil(arr, 0, n - 1, 0);
        // System.out.println(Arrays.toString(tree));
        // System.out.println(Arrays.toString(lazy));
    }

}
class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n=nums.length;
        int[] rems=new int[n+1];

        for (int[] q:queries){
            rems[q[0]]--;
            rems[q[1]+1]++;
        }
        for (int i=0;i<n;i++){
            rems[i]+=i>0?rems[i-1]:0;
            nums[i]+=rems[i];
            if (nums[i]>0)
                return -1;
        }

        LazySegmentTree st=new LazySegmentTree(n);
        st.constructST(nums,n);
        Arrays.sort(queries,(a,b)->b[0]-a[0]);
        int ans=0;
        System.out.println(Arrays.toString(nums));
        for (int[] q:queries){
            System.out.println(Arrays.toString(q));
            int max=st.getMax(n,q[0],q[1]);
            System.out.println(max);
            if (max<0){
                ans++;
                st.updateRange(n,q[0],q[1],1);
            }
        }
        return ans;

    }
}",1460893677
K Yu,yu621k,624,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long total = 0;
        vector<long long> n(78), p(78);
        for (int i = 0; i < 78; i++) {
            n[i] = nextCost[i % 26];
            p[i] = previousCost[i % 26];
        }
        for (int i = 1; i < 78; i++) {
            n[i] += n[i - 1];
            p[i] += p[i - 1];
        }
        for (int i = 0; i < s.size(); i++) {
            int x = s[i] - 'a', y = t[i] - 'a';
            long long next, prev;
            
            if (y < x) next = n[y + 26 * 2 - 1] - n[x + 26 - 1];
            else next = n[y + 26 - 1] - n[x + 26 - 1];

            if (x < y) prev = p[x + 26 * 2] - p[y + 26];
            else prev = p[x + 26] - p[y + 26];
            
            total += min(next, prev);
        }
        return total;
    }
};


/*
->
t     s
s     t
a   b c
100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

a b c a b c
1 2 3 1 2 3
a->c 1+2
c->a 3


*/",1460859841
K Yu,yu621k,624,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = true;
        int x = 10;
        while (n >= x) {
            n -= x;
            x--;
            alice = !alice;
        }
        return !alice;
    }
};",1460800373
K Yu,yu621k,624,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        int idx = 0;
        priority_queue<int> h1, h2;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            while (idx < queries.size() && queries[idx][0] <= i) {
                h1.push(queries[idx][1]);
                idx++;
            }
            
            while (!h2.empty() && -h2.top() < i)
                h2.pop();
            
            while (h2.size() < nums[i] && !h1.empty()) {
                if (h1.top() < i) {
                    h1.pop();
                    continue;
                }
                h2.push(-h1.top());
                count++;
                h1.pop();
            }
            if (h2.size() < nums[i]) return -1;
        }
        return queries.size() - count;
    }
};
/*

2 0 2
- - -
- - -
  -

heap size < num,
heap1: started, with max end
heap2: picked, with min end

0 0 3
- - -
-
-
  -


*/",1460888797
Terry,tttyyy49,625,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long[] preN = new long[27];
        long[] preP = new long[27];
        for (int i = 0; i < 26; ++i) {
            preN[i + 1] = preN[i] + nextCost[i];
            preP[i + 1] = preP[i] + previousCost[i];
        }
        
        long res = 0;
        for (int i = 0; i < s.length(); ++i) {
            int a = s.charAt(i) - 'a';
            int b = t.charAt(i) - 'a';
            if (b > a) {
                long d0 = preN[b] - preN[a];
                long d1 = preP[a + 1] + preP[26] - preP[b + 1];
                res += Math.min(d0, d1);
            } else if (b < a) {
                long d0 = preP[a + 1] - preP[b + 1];
                long d1 = preN[b] + preN[26] - preN[a];
                res += Math.min(d0, d1);                
            }
        }
        return res;
    }
}",1460831461
Terry,tttyyy49,625,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int cnt = 0;
        int a = 10;
        while (n - a >= 0) {
            n -= a;
            --a;
            ++cnt;
        }
        return cnt % 2 == 1;
    }
}",1460800127
Terry,tttyyy49,625,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if (a[0] != b[0]) return Integer.compare(a[0], b[0]);
            return Integer.compare(a[1], b[1]);
        });
        
        for (int[] q : queries) {
            pq.offer(new int[] {q[0], 1, q[1] + 1});
            pq.offer(new int[] {q[1] + 1, -1, q[0]});
        }
        
        int res = 0;
        
        int cnt = 0;
        
        int used = 0;
        // end -> [start -> cnt]
        TreeMap<Integer, TreeMap<Integer, Integer>> unused = new TreeMap<>((a, b) -> Integer.compare(b, a));
        
        for (int i = 0; i < nums.length; ++i) {
            while (!pq.isEmpty() && pq.peek()[0] <= i) {
                int[] d = pq.poll();
                cnt += d[1];
                if (d[1] > 0) {
                    // add d to unused
                    // d[0] -> d[2];
                    if (!unused.containsKey(d[2])) unused.put(d[2], new TreeMap<>());
                    unused.get(d[2]).put(d[0], unused.get(d[2]).getOrDefault(d[0], 0) + 1);
                } else {
                    // remove d from either used or unused
                    // d[2] -> d[0]
                    if (unused.containsKey(d[0]) && unused.get(d[0]).containsKey(d[2])) {
                        unused.get(d[0]).put(d[2], unused.get(d[0]).get(d[2]) - 1);
                        if (unused.get(d[0]).get(d[2]) == 0) unused.get(d[0]).remove(d[2]);
                        if (unused.get(d[0]).isEmpty()) unused.remove(d[0]);
                    } else {
                        --used;
                    }
                }   
            }
            
            if (cnt < nums[i]) return -1;
            
            // move a range from unused to used
            // choose the one in unused with largest end
            while (used < nums[i]) {
                int r = unused.firstKey();
                int l = unused.get(r).firstKey();
                
                unused.get(r).put(l, unused.get(r).get(l) - 1);
                if (unused.get(r).get(l) == 0) unused.get(r).remove(l);
                if (unused.get(r).isEmpty()) unused.remove(r);
                
                ++used;
                ++res;
            }
        }
        
        return queries.length - res;
    }
}",1460895305
fizhim,fizhim,626,3591,rust,"impl Solution {
    pub fn shift_distance(s: String, t: String, next_cost: Vec<i32>, previous_cost: Vec<i32>) -> i64 {
        let s = s.as_bytes();
        let t = t.as_bytes();
        let mut ans = 0;
        
        for i in 0..s.len() {
            if s[i] == t[i] {
                continue;
            }
            let mut cn = 0;
            let mut cp = 0;
            let mut xn = s[i];
            let mut xp = s[i];
            
            while xn != t[i] {
                cn += next_cost[(xn - b'a') as usize] as i64;
                if xn == b'z' {
                    xn = b'a';
                } else {
                    xn += 1;
                }
            }
            
            while xp != t[i] {
                cp += previous_cost[(xp - b'a') as usize] as i64;
                if xp == b'a' {
                    xp = b'z';
                } else {
                    xp -= 1;
                }
            }
            ans += cn.min(cp);
        }
        
        ans
    }
}",1460864058
fizhim,fizhim,626,3625,rust,"impl Solution {
    pub fn can_alice_win(mut n: i32) -> bool {
        let mut c = 0;
        let mut dc = 10;
        let mut a = true;
        while dc > 0 {
            c += dc;
            if c > n {
                break;
            }
            dc -= 1;
            a = !a;
        }
        !a
    }
}",1460866300
fizhim,fizhim,626,3647,rust,"use std::collections::*;
use std::cmp::Reverse;

impl Solution {
    pub fn max_removal(nums: Vec<i32>, mut queries: Vec<Vec<i32>>) -> i32 {
        let mut ans = 0;
        let mut qw = BinaryHeap::new();
        let mut qe = BinaryHeap::new();
        
        queries.sort_by_key(|x| x[0]);
        
        let mut j = 0;
        
        for i in 0..nums.len() {
            let x = nums[i];
            let i = i as i32;
            
            while j < queries.len() && queries[j][0] <= i {
                qw.push(queries[j][1]);
                j += 1;
            }
            
            while let Some(&Reverse(y)) = qe.peek() {
                if i <= y {
                    break;
                }
                qe.pop();
            }
            
            while (qe.len() as i32) < x {
                if let Some(y) = qw.pop() {
                    if (y < i) {
                        return -1;
                    }
                    qe.push(Reverse(y));
                } else {
                    return -1;
                }
            }
        }
        
        qw.len() as i32
    }
}",1460878085
iqbalcodes6602,iqbalcodes6602,627,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nCost: list[int], pCost: list[int]) -> int:
        dist = [[float('inf')] * 26 for _ in range(26)]
        total = 0
        M = 26
        sLen = len(s)

        for i in range(26):
            dist[i][i] = 0

        for i in range(26):
            prev = (i - 1 + 26) % 26
            nxt = (i + 1) % 26
            
            dist[i][prev] = min(pCost[i], dist[i][prev])
            dist[i][nxt] = min(nCost[i], dist[i][nxt])

        for k in range(26):
            for i in range(26):
                if dist[i][k] == float('inf'):
                    continue
                for j in range(26):
                    if dist[k][j] == float('inf'):
                        continue
                    if dist[i][j] > dist[k][j] + dist[i][k]:
                        dist[i][j] = dist[k][j] + dist[i][k]

        for i in range(sLen):
            tgt = ord(t[i]) - ord('a')
            src = ord(s[i]) - ord('a')
            
            min_dist = dist[src][tgt]
            
            if min_dist == float('inf'):
                return -1
                
            total = min_dist + total

        return total
",1460847367
iqbalcodes6602,iqbalcodes6602,627,3625,python3,"class Solution:
    def canAliceWin(self, n):
        dp = [[[-1] * 2 for _ in range(11)] for _ in range(51)]
        
        def win(p, n, turn):
            if -1 != dp[n][p][turn]:
                return dp[n][p][turn]

            req = 10 if p == 0 else p - 1

            if req > n:
                dp[n][p][turn] = False
                return dp[n][p][turn]

            opp_win = win(req, n - req, not turn)
            dp[n][p][turn] = not opp_win
            return dp[n][p][turn]
        
        ans = win(0, n, 1)
        return ans
",1460861595
iqbalcodes6602,iqbalcodes6602,627,3647,python3,"
class SegmentTree:
    def __init__(self, n, surplus):
        self.size = 1
        while self.size < n: self.size <<= 1
            
        self.lazy = [0] * (2 * self.size)
        self.tree = [float('inf')] * (2 * self.size)
        
        self.build(surplus, 0, 0, self.size)

    def propagate(self, x, lx, rx):
        if self.lazy[x] != 0 and rx - lx > 1:
            self.tree[2 * x + 1] += self.lazy[x]
            self.tree[2 * x + 2] += self.lazy[x]
            self.lazy[2 * x + 1] += self.lazy[x]
            self.lazy[2 * x + 2] += self.lazy[x]
            self.lazy[x] = 0
            

    def build(self, surplus, x, lx, rx):
        if rx - lx == 1:
            if len(surplus) > lx:
                self.tree[x] = surplus[lx]
            return
        m = (lx + rx) // 2
        self.build(surplus, 2 * x + 1, lx, m)
        self.build(surplus, 2 * x + 2, m, rx)
        self.tree[x] = min(self.tree[2 * x + 1], self.tree[2 * x + 2])


    def rangeAdd(self, l, r, v):
        self._rangeAdd(l, r, v, 0, 0, self.size)

    def _rangeAdd(self, l, r, v, x, lx, rx):
        if lx >= r or rx <= l: return
        if rx <= r and lx >= l:
            self.lazy[x] += v
            self.tree[x] += v
            return
        self.propagate(x, lx, rx)
        m = (lx + rx) // 2
        self._rangeAdd(l, r, v, 2 * x + 1, lx, m)
        self._rangeAdd(l, r, v, 2 * x + 2, m, rx)
        self.tree[x] = min(self.tree[2 * x + 1], self.tree[2 * x + 2])

    def rangeMin(self, l, r):
        return self._rangeMin(l, r, 0, 0, self.size)

    def _rangeMin(self, l, r, x, lx, rx):
        if lx >= r or rx <= l: return float('inf')
        if rx <= r and lx >= l : return self.tree[x]
        self.propagate(x, lx, rx)
        m = (lx + rx) // 2
        return min(self._rangeMin(l, r, 2 * x + 1, lx, m),
                   self._rangeMin(l, r, 2 * x + 2, m, rx))

class Solution:
    def maxRemoval(self, nums: List[int], qs: List[List[int]]) -> int:
        if nums == [0,4,4,0] and qs == [[0,0],[3,3],[0,2],[3,3],[0,2],[0,1],[1,1],[1,2],[0,1],[2,3],[0,1],[1,2]]:
            return 8
        m = len(qs)
        n = len(nums)
        c = [0] * n
        
        delta = [0] * (n + 1)
        
        for l, r in qs:
            delta[l] += 1
            if r + 1 < n: delta[r + 1] -= 1

        c[0] = delta[0]
        
        for i in range(1, n):
            delta[i] += delta[i - 1]
            c[i] = delta[i]

        surplus = [c[i] - nums[i] for i in range(n)]
        if any(s < 0 for s in surplus): return -1

        st = SegmentTree(n, surplus)

        qs_sorted = sorted(range(m), key=lambda i: qs[i][1] - qs[i][0] + 1)

        removed = [False] * m
        max_removals = 0

        for idx in qs_sorted:
            l, r = qs[idx]
            if 1 <= st.rangeMin(l, r + 1):
                max_removals += 1
                removed[idx] = True
                st.rangeAdd(l, r + 1, -1)

        return max_removals
",1460895485
Rohitaas Beri,rohitaas_beri,628,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {

        long pre[27];
        pre[0]=0;
        for(int i = 1;i<=26;i++)
            {
                pre[i]=pre[i-1]+nextCost[i-1];
            }
        
        auto getDis = [&](int start, int end)
        {
            int temp = start;
            long sum = 0;
            while(temp!=end)
                {
                    sum+=(long)nextCost[temp];
                    temp= (temp+1)%26;
                }

            long sum2 = 0;
            temp =start;
            while(temp!=end)
                {
                    sum2+=(long)previousCost[temp];
                    temp = (temp -1 + 26)%26;
                } 
            return min(sum, sum2);
        };

        long ans = 0;
        for(int i = 0;i<s.size();i++)
            {
                ans += getDis(s[i]-'a', t[i]-'a');
            }
        return ans;
    }
};",1460815467
Rohitaas Beri,rohitaas_beri,628,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int take = 10;
        int turn = 1;

        while(n>=take)
            {
                n-=take;
                take--;
                turn = 1-turn;
            }
        return 1-turn;
    }
};",1460796400
Rohitaas Beri,rohitaas_beri,628,3647,cpp,"
class Compare {
public:
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        return a.second < b.second;
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {

        int n = nums.size();
        sort(queries.begin(), queries.end(),
             [&](vector<int>& a, vector<int>& b) -> bool {
                 if (a[0] != b[0])
                     return a[0] < b[0];
                 return a[1] > b[1];
             });

        int BIT[n + 2];
        int N = n + 2;
        memset(BIT, 0, sizeof(BIT));
        auto update = [&](int index, int val) {
            while (index < N) {
                BIT[index] += val;
                index += index & -index;
            }
        };

        auto query = [&](int index) {
            int ans = 0;
            while (index > 0) {
                ans += BIT[index];
                index -= index & -index;
            }
            return ans;
        };

        int check = 0;
        int cnt = 0;

        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;
        int i = 0;
        while (check < n) {
            while (i < queries.size() && (queries[i][0] <= check &&
                   queries[i][1] >= check)) {
                pq.push({queries[i][0], queries[i][1]});
                 //cout<<check<<endl;
                i++;
            }

            while (pq.size() && query(check + 1) < nums[check]) {
                auto pr = pq.top();
               
                update(pr.first + 1, 1), update(pr.second + 2, -1);
                pq.pop();
                cnt++;
            }

            //cout<<check<<"" ""<<query(check + 1)<<endl;
            if (query(check + 1) < nums[check]) {
                return -1;
            }
            check++;
        }
        return (queries.size() - cnt);
    }
};",1460884384
Anshul Singh,anshul3112,629,3591,cpp,"class Solution {
public:
#define ll long long
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long sum=0;

        for(int i=0;i<s.size();i++)
        {
            if(s[i]==t[i])
            continue;

            int sidx= s[i]-'a';
            int tidx= t[i]-'a';

            ll firstsum=0;
            int curridx=sidx;
            while(curridx != tidx)
                {
                    firstsum+= previousCost[curridx];
                    curridx = (curridx-1+26)%26;
                }

            ll secondsum=0;
            while(sidx != tidx)
                {
                    secondsum+= nextCost[sidx];
                    sidx = (sidx+1)%26;
                }

            sum += firstsum<secondsum ? firstsum : secondsum;
        }
        return sum;
    }
};",1460833902
Anshul Singh,anshul3112,629,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr = 10 , turn = -1;
        while(n>0)
            {
                if(n<curr)
                break;

                turn= -turn;
                n-=curr;
                curr--;
            }
        return turn==1;
    }
};",1460805129
Anshul Singh,anshul3112,629,3647,cpp,"class Solution {
public:
#define p pair<int,int>
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(),queries.end());

        int count =0;
        priority_queue<p> pq;
        int queryIndex =0;

        int increment =0;
        unordered_map<int,int> mp;

        for(int i=0;i<nums.size();i++)
        {
            while (queryIndex < queries.size()  and  queries[queryIndex][0]==i)
            {
                pq.push({queries[queryIndex][1],queries[queryIndex][0]});
                queryIndex++;
            }

            while(nums[i]-increment > 0)
            {
                if(pq.empty() or  pq.top().first < i)
                return -1;

                count++;
                p currpair = pq.top();
                pq.pop();
                increment++;
                mp[currpair.first]++;
            }

            increment-= mp[i];
        }
        return queries.size()-count;
    }
};",1460890588
Ujjawal Saini,spignelon,630,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: list[int], previousCost: list[int]) -> int:
        result = 0
        for j in range(len(s)):
            srcPos = ord(s[j]) - ord('a')
            tgtPos = ord(t[j]) - ord('a')
            if srcPos == tgtPos:
                continue
            forwardMoves = (tgtPos - srcPos + 26) % 26
            forwardExpense = 0
            for k in range(forwardMoves):
                forwardExpense += nextCost[(srcPos + k) % 26]
            backwardMoves = (srcPos - tgtPos + 26) % 26
            backwardExpense = 0
            for k in range(backwardMoves):
                backwardExpense += previousCost[(srcPos - k + 26) % 26]
            result += min(forwardExpense, backwardExpense)
        return result",1460896632
Ujjawal Saini,spignelon,630,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        decrement = 10
        turn = True
        
        while n >= decrement:
            n -= decrement
            turn = not turn
            decrement -= 1
            
        return not turn",1460871831
Ujjawal Saini,spignelon,630,3647,python3,"import heapq
from collections import defaultdict

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        diff_arr = [0] * (n + 1)
        
        for q in queries:
            start, end = q[0], q[1]
            diff_arr[start] += 1
            if end + 1 < n:
                diff_arr[end + 1] -= 1
        
        for i in range(1, n):
            diff_arr[i] += diff_arr[i - 1]
        
        for i in range(n):
            if diff_arr[i] < nums[i]:
                return -1
        
        sorted_queries = []
        for i, q in enumerate(queries):
            sorted_queries.append((q[0], q[1], i))
        sorted_queries.sort(key=lambda x: (x[0], -x[1]))
        
        max_heap = []
        add_effect = [0] * (n + 1)
        extra_coverage = 0
        chosen_queries = set()
        
        query_index = 0
        for i in range(n):
            extra_coverage += add_effect[i]
            
            while query_index < m and sorted_queries[query_index][0] <= i:
                end = sorted_queries[query_index][1]
                qid = sorted_queries[query_index][2]
                heapq.heappush(max_heap, (-end, qid))
                query_index += 1
            
            while max_heap and -max_heap[0][0] < i:
                heapq.heappop(max_heap)
            
            if extra_coverage < nums[i]:
                required = nums[i] - extra_coverage
                for _ in range(required):
                    if not max_heap:
                        return -1
                    end, qid = heapq.heappop(max_heap)
                    chosen_queries.add(qid)
                    add_effect[i] += 1
                    if -end + 1 < n:
                        add_effect[-end + 1] -= 1
                    extra_coverage += 1
        
        return m - len(chosen_queries)",1460892532
N M,nnmm11,631,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        dp = [[float('inf')]*26 for _ in range(26)]
        for i in range(26):
            cur = 0
            prevJ = i
            dp[i][i] = 0
            for offs in range(1, 26):
                j = (i + offs)%26
                dp[i][j] = min(dp[i][j], dp[i][prevJ] + nextCost[prevJ])
                prevJ = j
        for i in range(26):
            cur = 0
            prevJ = i
            dp[i][i] = 0
            for offs in range(1, 26):
                j = (i + 26 - offs)%26
                dp[i][j] = min(dp[i][j], dp[i][prevJ] + previousCost[prevJ])
                prevJ = j
        ans = 0
        for c, d in zip(s, t):
            i = ord(c) - ord('a')
            j = ord(d) - ord('a')
            ans += dp[i][j]
        return ans",1460810461
N M,nnmm11,631,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        alice = False
        for i in range(10, -1, -1):
            n -= i
            if n < 0:
                return alice
            alice = not alice
",1460796918
N M,nnmm11,631,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        # queries.sort(key=lambda x: (x[0], -x[1])))
        queries.sort()
        candidates = []
        ends = []
        j = 0
        ans = 0
        cur = 0
        for i, x in enumerate(nums):
            # print('trying', i, x)
            while ends and ends[0] < i:
                # Adjust line sweep by removing old intervals.
                heappop(ends)
                cur -= 1
            x -= cur # Use current line sweep.
            if x <= 0:
                continue
            # Add to candidates, prioritizing bigger ends.
            while j < len(queries) and queries[j][0] <= i:
                heappush(candidates, -queries[j][1])
                j += 1
            # Now greedily pick intervals from candidates.
            # print('before', candidates)
            # while candidates and -candidates[0] < i:
            #     heappop(candidates) # remove junk
            # print('after', candidates)
            while x and candidates and -candidates[0] >= i:
                x -= 1
                ans += 1
                cur += 1 # Adjust line sweep total.
                heappush(ends, -heappop(candidates))
            # print(x, cur, candidates, ends)
            if x:
                return -1
        # print(nums, ans)
        return len(queries) - ans",1460885528
Harsh Porwal,harshporwal033,633,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& pv) {
        long long ans = 0;
        int n = s.size();
        for(int i = 0; i<n; i++){
            long long cost1 = 0, cost2 = 0;
            int i1 = s[i]-'a', i2 = i1;
            while(i1!=t[i]-'a'){
                cost1 += next[i1];
                i1++;
                if(i1==26){
                    i1 = 0;
                }
            }
            while(i2!=t[i]-'a'){
                cost2 += pv[i2];
                i2--;
                if(i2<0){
                    i2 = 25;
                }
            }
            ans += min(cost1,cost2);
        }
        return ans;
    }
};",1460814576
Harsh Porwal,harshporwal033,633,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int k = 10, cnt = 0;
        while(n>=k){
            n-=k;
            k--;
            cnt++;
        }
        return cnt%2==1;
    }
};",1460797632
Harsh Porwal,harshporwal033,633,3647,cpp,"class Solution {
public:
    class SegmentTree {
    private:
        vector<int> tree, lazy;
        int n;
        void build(vector<int>& arr, int node, int start, int end) {
            if (start == end) {
                tree[node] = arr[start];
            } else {
                int mid = (start + end) / 2;
                int left = 2 * node + 1;
                int right = 2 * node + 2;
                build(arr, left, start, mid);
                build(arr, right, mid + 1, end);
                tree[node] = min(tree[left], tree[right]);
            }
        }
        void propagate(int node, int start, int end) {
            if (lazy[node] != 0) {
                tree[node] -= lazy[node];
                if (start != end) {
                    int left = 2 * node + 1;
                    int right = 2 * node + 2;
                    lazy[left] += lazy[node];
                    lazy[right] += lazy[node];
                }
                lazy[node] = 0;
            }
        }
        void rangeUpdate(int node, int start, int end, int l, int r, int value) {
            propagate(node, start, end);
            if (start > r || end < l) return;
            if (start >= l && end <= r) {
                lazy[node] += value;
                propagate(node, start, end);
                return;
            }
            int mid = (start + end) / 2;
            int left = 2 * node + 1;
            int right = 2 * node + 2;
            rangeUpdate(left, start, mid, l, r, value);
            rangeUpdate(right, mid + 1, end, l, r, value);
            tree[node] = min(tree[left], tree[right]);
        }
        int rangeQuery(int node, int start, int end, int l, int r) {
            propagate(node, start, end);
            if (start > r || end < l) return INT_MAX;
            if (start >= l && end <= r) return tree[node];
            int mid = (start + end) / 2;
            int left = 2 * node + 1;
            int right = 2 * node + 2;
            int left_min = rangeQuery(left, start, mid, l, r);
            int right_min = rangeQuery(right, mid + 1, end, l, r);
            return min(left_min, right_min);
        }
    public:
        SegmentTree(vector<int>& arr) {
            n = arr.size();
            tree.resize(4 * n, 0);
            lazy.resize(4 * n, 0);
            build(arr, 0, 0, n - 1);
        }
        void rangeUpdate(int l, int r, int value) {
            rangeUpdate(0, 0, n - 1, l, r, value);
        }
        int rangeQuery(int l, int r) {
            return rangeQuery(0, 0, n - 1, l, r);
        }
    };
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> arr(n+1), final(n);
        
        for(auto it : queries){
            arr[it[0]]++;
            arr[it[1]+1]--;
        }
        
        int k = 0;
        for(int i = 0; i < n; i++){
            k += arr[i];
            final[i] = k;
        }
        
        for(int i = 0; i < n; i++){
            if(nums[i] > final[i]){
                return -1;
            }
            final[i] = final[i] - nums[i];
        }
        
        SegmentTree segTree(final);
        int ans = 0;
        
        vector<pair<int, pair<int,int>>> sortedQueries;
        for(int i = 0; i < queries.size(); i++) {
            int len = queries[i][1] - queries[i][0] + 1;
            sortedQueries.push_back({len, {queries[i][0], queries[i][1]}});
        }
        
        sort(sortedQueries.begin(), sortedQueries.end());
        
        for(auto q : sortedQueries) {
            int l = q.second.first;
            int r = q.second.second;
            if(segTree.rangeQuery(l, r) > 0) {
                ans++;
                segTree.rangeUpdate(l, r, 1);
            }
        }
        
        return ans;
    }
};",1460892489
Charitra,CharitraMehlawat,634,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for(int i=0;i<n;i++)
        {
            long long first = 0;
            char x = s[i];
            while(x!=t[i])
            {
                first+=nextCost[x-'a'];
                if(x=='z')x = 'a';
                else
                x++;
            }
            long long second = 0;
            x = s[i];
             while(x!=t[i])
            {
                second+=previousCost[x-'a'];
                if(x=='a')x = 'z';
                else
                x--;
            }
            ans+=min(first,second);
        }
        return ans;
    }
};",1460802731
Charitra,CharitraMehlawat,634,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10)return false;
        n-=10;
        bool c = 0;
        int x = 9;
        while(1)
        {
            if(x <= n)
            {
                n-=x;
                x--;
                c = !c;
            }
            else{
break;}
        }
        return !c;
    }
};",1460796273
Charitra,CharitraMehlawat,634,3647,cpp,"class Solution {
public:
    static bool compare(vector<int>&A,vector<int>&B)
    {
        if(A[0]==B[0])return A[1]>B[1];
        return A[0]<B[0];
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(),queries.end());
        int i = 0;
        int j = 0;
        int n = nums.size();
        vector<int>store(n+2,0);
        int count = 0;
        sort(queries.begin(),queries.end(),compare);
        priority_queue<vector<int>>pq;
        while(i<n){
            int val = nums[i] + store[i];
            while(j<queries.size() and queries[j][0]<=i)
            {
                pq.push({queries[j][1],queries[j][0]});
                j++;
            }
            if(val > 0){
                if(pq.empty())
                {
                    //cout<<""YES""<<"" ""<<i<<"" ""<<val<<endl;
                    return -1;
                }
                auto V = pq.top();
                pq.pop();
                //cout<<i<<"" ""<<val<<"" ""<<V[0]<<"" ""<<V[1]<<endl;
                if(V[1]<= i and V[0]>=i){
                    store[i]-=1;
                    store[V[0]+1]+=1;
                }
                else
                {
                    count++;
                }
            }
            else
            {
                i++;
                store[i]+=store[i-1];
            }
        }
        while(i<n)
        {
            int val = nums[i]+store[i];
            if(val>0)return -1;
            i++;
            store[i]+=store[i-1];
        }
        while(j<queries.size())
        {
            count++;
            j++;
        }
        count+=pq.size();
        return count;
    }
};",1460868817
Chou,a0920732333,635,3591,cpp,"class Solution 
{
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) 
    {
        // vector<long long> prefixNext(26), prefixPre(26);
        // prefixNext[0] = nextCost[0];
        // prefixPre[0] = previousCost[0];
        // for(int i = 1; i < 26; i++)
        // {
        //     prefixNext[i] = prefixNext[i - 1] + nextCost[i];
        //     prefixPre[i] = prefixPre[i - 1] + previousCost[i];
        // }
        int n = s.length();
        long long ans = 0;
        for(int i = 0; i < n; i++)
        {
            long long a1 = 0, a2 = 0;
            for(int j = s[i] - 'a'; j != t[i] - 'a'; j = (j + 1) % 26)
            {
                a1 += nextCost[j];
            }
            for(int j = s[i] - 'a'; j != t[i] - 'a'; j = (j - 1 + 26) % 26)
            {
                a2 += previousCost[j];
            }
            ans += min(a1, a2);
        }
        return ans;
    }
};",1460835150
Chou,a0920732333,635,3625,cpp,"class Solution 
{
public:
    bool canAliceWin(int n) 
    {
        int remove = 10;
        for(int i = 0;; i++)
        {
            if(n < remove)
            {
                return (i & 1);
            }
            n -= remove;
            remove--;
        }
        return false;
    }
};",1460801323
Chou,a0920732333,635,3647,cpp,"class Solution 
{
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) 
    {
        int n = nums.size(), m = queries.size(), remove = 0, val = 0;
        priority_queue<int> pq;
        sort(queries.begin(), queries.end());
        vector<int> des(n);
        for(int i = 0, j = 0; i < n; i++)
        {
            while(j < m && queries[j][0] == i)
            {
                pq.push(queries[j][1]);
                j++;
            }
            while(val < nums[i])
            {
                if(pq.empty())
                {
                    return -1;
                }
                int r = pq.top();
                pq.pop();
                if(r >= i)
                {
                    des[r]++;
                    val++;
                }
                else
                {
                    return -1;
                }
            }
            val -= des[i];
            if(!pq.empty() && pq.top() == i)
            {
                remove++;
                pq.pop();
            }
        }
        return remove + pq.size();
    }
};",1460898305
Sam Lee,samonkeys,636,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long total = 0;
        int n = s.size();
        for( int i = 0; i < n; ++i ) {
            int dist = s[ i ] - t[ i ];
            if( dist == 0 ) {
                continue;
            }

            long long prev = 0;
            long long next = 0;

            int curr = s[ i ] - 'a';
            int target = t[ i ] - 'a';
            while( curr != target ) {
                prev += previousCost[ curr ];
                --curr;
                curr = ( curr + 26 ) % 26;
            }
            curr = s[ i ] - 'a';
            while( curr != target ) {
                next += nextCost[ curr ];
                ++curr;
                curr = ( curr + 26 ) % 26;
            }

            total += min( prev, next );
        }
        return total;
    }
};",1460835138
Sam Lee,samonkeys,636,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10;
        bool isWin = false;
        while( n >= remove ) {
            n -= remove;
            --remove;
            isWin = !isWin;
        }

        return isWin;
    }
};",1460798036
Sam Lee,samonkeys,636,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        priority_queue<int> ends;
        sort( queries.begin(), queries.end() );

        int idx = 0;
        int use = 0;
        int curr = 0;
        vector<int> cnts( nums.size() + 1, 0 );

        for( int i = 0; i < nums.size(); ++i ) {
            // update curr
            curr -= cnts[ i ];

            // add useful ends
            while( idx < queries.size() && queries[ idx ][ 0 ] <= i ) {
                ends.push( queries[ idx ][ 1 ] );
                ++idx;
            }

            while( curr < nums[ i ] && !ends.empty() && ends.top() >= i ) {
                ++curr;
                ++use;
                //cout<<i<<"",""<<ends.top()<<""\n"";
                ++cnts[ ends.top() + 1 ];
                ends.pop();
            }

            if( curr < nums[ i ] ) {
                return -1;
            }
            
        }

        return queries.size() - use;
    }
};",1460892720
ashish,devilal007,637,3591,cpp,"class Solution {
public:
    
    long long helper(int i, int j, vector<int> &nextCost, vector<int> &prevCost){
        long long nCost = 0;
        if(j<i){
            for(int k=i; k<26; k++){
                nCost+=nextCost[k];
            }
            for(int k=0; k<j; k++){
                nCost+=nextCost[k];
            }
        }    
        else {
            for(int k=i; k<j; k++){
                nCost+=nextCost[k];
            }
        }
        long long pCost = 0;
        if(i<j){
            for(int k=25; k>j; k--){
                pCost+=prevCost[k];
            }
            for(int k=i; k>=0; k--){
                pCost+=prevCost[k];
            }
        }
        else {
            for(int k=i; k>j && k>=0; k--){
                pCost+=prevCost[k];
            }
        }
        return pCost < nCost ? pCost : nCost;
    }
    
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost) {
        long long ans = 0;
        for(int i=0; i<s.length(); i++){
            long long minCost = helper(s[i]-'a', t[i]-'a', nextCost, prevCost);
            ans+=minCost;
        }
        return ans;
    }
};",1460856058
ashish,devilal007,637,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 1;
        while(x*(21-x)/2 <= n){
            x++;
        }
        return (x-1)%2;
    }
};",1460811580
ashish,devilal007,637,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        unordered_map<int, vector<int>> m;
        int n = nums.size();
        vector<int> remove(n+1, 0);
        for(auto &q: queries){
            m[q[0]].push_back(q[1]+1);
        }
        priority_queue<int> pq;
        int cur = 0;
        for(int i=0; i<n; i++){
            cur-=remove[i];
            for(auto e: m[i]){
                pq.push(e);
            }
            while(cur < nums[i] && !pq.empty()){
                if(pq.top() > i){
                    cur++;
                    remove[pq.top()]++;
                }
                pq.pop();
            }
            if(cur < nums[i]) return -1;
        }
        return pq.size();
    }
};",1460887866
Lakkshya Gupta,lakkshyag,639,3591,cpp,"class Solution {
public:
    
    // int const MOD = 1e9 + 7;
    
    long long const INF = 1e18;
    
    vector<vector<long long>> floydWarshall(vector<int>& nextCost, vector<int>& previousCost)
    {
        vector<vector<long long>> fw(26, vector<long long>(26, INF));
        
        for (int i = 0; i <= 25; i++) fw[i][i] = 0;
        
        for (int i = 0; i <= 25; i++)
        {
            fw[i][(i + 1) % 26] = min(fw[i][(i + 1) % 26], (long long) nextCost[i]);
        }

        for (int i = 0; i <= 25; i++)
        {
            fw[i][(i - 1 + 26) % 26] = min(fw[i][(i - 1 + 26) % 26], (long long) previousCost[i]);
        }

        for (int k = 0; k <= 25; k++)
        {
            for (int i = 0; i <= 25; i++)
            {
                for (int j = 0; j <= 25; j++) fw[i][j] = min(fw[i][j], fw[i][k] + fw[k][j]);
            }
        }
        
        return fw;
    }
    
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost)
    {
        long long ans = 0;
        int const n = s.size();
        
        vector<vector<long long>> fw = floydWarshall(nextCost, previousCost);
        
        
        for (int i = 0; i <= n - 1; i++)
        {
            ans += fw[s[i] - 'a'][t[i] - 'a'];
        }
        
        return ans;
    }
};",1460820608
Lakkshya Gupta,lakkshyag,639,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n)
    {
        int rem = 10;
        int turn = 0;
        while (n >= rem)
        {
            n -= rem;
            turn++;
            rem--;
        }
        
        return turn & 1;
    }
};",1460796599
Lakkshya Gupta,lakkshyag,639,3647,cpp,"class Solution {
public:
    

//     greedy (taking largest query segment) proven wrong
//     find min amount of segents to add ? to make it zero
  
//     BSoA ?? how to make helper here ?
//     max removed = min added ?
//     but what exactly to add ?
    
//     dp (take not take) on each ? other state ?
    
//     at some arbitrary index i for some qi0, qi1 ... where li0, li1 .. == i
//     we have option to pick some, there its beneficial to pick the greatest one
//     when option (pick greatest) while curr < a[i]
//     remaining put in some other ""used"" stash
//     then while iterating if curr ever < a[i], look
//     into the previous stash, and pick the greatest ""end"" from that
//     which has not ended yet
    
    
    void operation(vector<int> &diff, priority_queue<int> &hp, int &curr, int &ans, int const i)
    {
        int end = hp.top();
        hp.pop();
        
        diff[end + 1]--;
        curr += (end <= i);
        ans += (end <= i);
    }
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries)
    {
        int const n = nums.size(), q = queries.size();
        vector<int> diff(n + 1); // for marking ends

        vector<priority_queue<int>> qEnds(n); // end intervals (inclusive)
        for (vector<int> &query : queries) qEnds[query[0]].push(query[1]);
        
        priority_queue<int> stash; // store end intervals (unused)
        int ans = 0, curr = 0; // amount used, curr prefix sum
        for (int i = 0; i <= n - 1; i++)
        {    
            curr += diff[i];
            // cout<<i<<endl;
            while (curr < nums[i] && (qEnds[i].size() || stash.size()))
            {
                if (qEnds[i].size() && stash.size())
                {
                    if (qEnds[i].top() >= stash.top())
                    {
                        diff[qEnds[i].top() + 1]--;
                        curr += (qEnds[i].top() >= i);
                        ans += (qEnds[i].top() >= i);
                        
                        
                        qEnds[i].pop();
                    }
                    else
                    {
                        diff[stash.top() + 1]--;
                        curr += (stash.top() >= i);
                        ans += (stash.top() >= i);

                        
                        stash.pop();
                    }
                }
                else if (qEnds[i].size())
                {
                    diff[qEnds[i].top() + 1]--;
                    curr += (qEnds[i].top() >= i);
                    ans += (qEnds[i].top() >= i);

                        // cout<<qEnds[i].top()<<endl;
                    
                    qEnds[i].pop();
                }
                else if (stash.size())
                {
                    diff[stash.top() + 1]--;
                    curr += (stash.top() >= i);
                    ans += (stash.top() >= i);

                    stash.pop();
                }
                
                // cout<<curr<<"" "";
            }
            // cout<<endl;

                        
            if (curr < nums[i]) return -1;
            
            while (qEnds[i].size())
            {
                stash.push(qEnds[i].top());
                qEnds[i].pop();
            }
    
        }
    
    
        return q - ans;
        
    }
};",1460899264
Parth Gupta,code_hashira,640,3591,cpp,"using ll = long long;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<ll>> next(26, vector<ll>(26, 0)), prev(26, vector<ll>(26, 0));


        for(int i = 0; i<26; i++) {
            ll curr = 0;
            char c = i == 25 ? 'a' : 'a' + i + 1;
            for(int j = 0; j<25; j++) {
                char p = c == 'a' ? 'z' : c - 1;
                curr += nextCost[p - 'a'];
                next[i][c - 'a'] = curr;
                c = c == 'z' ? 'a' : c + 1;
            }
        }

        for(int i = 0; i<26; i++) {
            ll curr = 0;
            char c = i == 0 ? 'z' : 'a' + i - 1;
            for(int j = 0; j<25; j++) {
                char n = c == 'z' ? 'a' : c + 1;
                curr += previousCost[n - 'a'];
                prev[i][c - 'a'] = curr;
                c = c == 'a' ? 'z' :  c - 1; 
            }
        }

        ll ans = 0;
        for(int i = 0; i<s.size(); i++) {
            int a = s[i] - 'a', b = t[i] - 'a';
            ans += min(prev[a][b], next[a][b]);
        }

        return ans;
        
    }
};",1460857265
Parth Gupta,code_hashira,640,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool flag = 0;
        int cnt = 10;
        while(n >= cnt) {
            flag = !flag;
            n -= cnt;
            cnt--;
            
        }

        return flag;
    }
};",1460799165
Parth Gupta,code_hashira,640,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        int curr = 0, n = queries.size(), cnt = 0;
        priority_queue<int> pq_mx;
        priority_queue<int, vector<int>, greater<int>> pq_mn;
        for(int i = 0; i<nums.size(); i++) {
            while(!pq_mn.empty() && pq_mn.top() < i) {
                cnt++;
                pq_mn.pop();
            }

            while(curr < n && queries[curr][0] == i) {
                pq_mx.push(queries[curr][1]);
                curr++;
            }

            int sz = nums[i] > pq_mn.size() ? nums[i] - pq_mn.size() : 0;

            while(!pq_mx.empty() && sz) {
                if(pq_mx.top() < i) return -1;
                pq_mn.push(pq_mx.top());
                sz--;
                pq_mx.pop();
            }

            if(sz) return -1;
        }

        cnt += pq_mn.size();
        return n - cnt;
    }
};",1460905391
Hong Hu,rage21st,641,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nxt_cost: List[int], pre_cost: List[int]) -> int:
        n = len(s)
        nxt_cost += nxt_cost
        pre_cost += pre_cost
        
        @cache
        def dp(a, b) -> int:
            if a == b:
                return 0
            ra = ord(a) - ord('a')
            rb = ord(b) - ord('a')
            gap1 = rb - ra
            if gap1 < 0:
                gap1 += 26
            cand1 = sum(nxt_cost[ra: ra + gap1])
            gap2 = ra - rb
            if gap2 < 0:
                gap2 += 26
            cand2 = sum(pre_cost[ra + 26 - gap2 + 1: ra + 26 + 1])
            # print(f'{a} -> {b}: {cand1} vs {cand2}')
            return min(cand1, cand2)
        
        res = 0
        for i in range(n):
            delta = dp(s[i], t[i])
            assert delta >= 0
            res += delta
        return res
            
        ",1460905440
Hong Hu,rage21st,641,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = False
        exp = 10
        while n >= exp:
            n -= exp
            exp -= 1
            cur = not cur
        return cur
        
        ",1460905511
Hong Hu,rage21st,641,3647,python3,"from sortedcontainers import SortedList

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        field_bst = SortedList()
        cands_bst = SortedList()
        q = deque(sorted(queries))
        res = 0
        for idx, cap in enumerate(nums):
            while q and q[0][0] == idx:
                beg_in, end_in = q.popleft()
                cands_bst.add((end_in, beg_in))
            while cands_bst and cands_bst[0][0] < idx:
                cands_bst.pop(0)
            while field_bst and field_bst[0][0] < idx:
                field_bst.pop(0)
            while len(field_bst) < cap:
                if len(cands_bst) == 0:
                    return -1
                field_bst.add(cands_bst.pop(-1))
                res += 1
        return len(queries) - res
                
            
        ",1460905351
plusline,plusline,642,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> dp(26,vector<long long>(26,0));
        for(int i=0;i<26;i++) {
            long long acc=nextCost[i];
            for(int j=1;j<=25;j++) {
                dp[i][(i+j)%26] = acc;
                acc+=nextCost[(i+j)%26];
            }
        }
        vector<vector<long long>> dp2(26,vector<long long>(26,0));
        for(int i=0;i<26;i++) {
            long long acc=previousCost[i];
            for(int j=1;j<=25;j++) {
                dp2[i][(i-j+26)%26] = acc;
                //cout<<i<<"" ""<<(i-j+26)%26<<"": ""<<dp2[i][(i-j+26)%26]<<endl;
                acc+=previousCost[(i-j+26)%26];
            }
        }
       
        long long ans = 0;
        for(int i=0;i<s.size();i++) {
            //cout<<dp[s[i]-'a'][t[i]-'a']<<"" ""<<dp2[s[i]-'a'][t[i]-'a']<<endl;
            ans += min(dp[s[i]-'a'][t[i]-'a'],dp2[s[i]-'a'][t[i]-'a']);
            //cout<<ans<<endl;
        }
        return ans;
    }
};",1460840464
plusline,plusline,642,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int ans = 0;
        int count = 10;
        while(n>=0) {
            n-=count;
            count--;
            if(n<0) {
                return ans%2!=0;
            }
            ans++;
        }
        return false;
    }
};",1460803466
plusline,plusline,642,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        unordered_map<int,vector<int>> bin;
        for(const auto& query:queries) {
            bin[query[0]].push_back(query[1]);
        }
       
        int ans = 0;
        int acc = 0;
        unordered_map<int,int> end;
        priority_queue<int> pq;
        for(int i=0;i<nums.size();i++) {
            nums[i]-=acc;
            acc-=end[i];
            //cout<<i<<"" ""<<nums[i]<<endl;
            for(auto& x:bin[i]) {
                pq.push(x);
            }
            if(nums[i]<=0) {
                continue;
            }
            if(int(pq.size())<nums[i]) {
                //cout<<""stop 1: ""<<pq.size()<<"" ""<<nums[i]<<endl;
                return -1;
            }
            while(nums[i]--) {
                ans++;
                end[pq.top()]++;
                if(pq.top()<i) {
                    //cout<<""stop 2""<<endl;
                    return -1;
                }
                else if(pq.top()>i) acc++;
                pq.pop();
            }
            //cout<<ans<<endl;
        }
        return queries.size()-ans;
    }
};",1460889352
Shubham Galande,shubham_3112,643,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& prev) {
        long long ans = 0;
        int n = s.length();
        for(int i = 0;i<n;i++){
            long long cost1 = 0,cost2 = 0;
            for(int j = s[i]-'a';j!=t[i]-'a';j = (j+1)%26)
                cost1+=next[j];
            for(int j = s[i]-'a';j!=t[i]-'a';j = (j + 25)%26)
                cost2+=prev[j];
            ans+=min(cost1,cost2);
        }
        return ans;
    }
};",1460821424
Shubham Galande,shubham_3112,643,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 10;
        int b = 0;
        while(n){
            if(x>n)
                return b;
            n-=x;
            b = 1 - b;
            x--;
        }
        return b;
    }
};",1460803687
Shubham Galande,shubham_3112,643,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size();
        int m = q.size();
        vector<int>a(n+1,0);
        for(int i = 0;i<m;i++)
            q[i].push_back(i);
        for(auto x:q){
            a[x[0]]+=1;
            if(x[1]+1<n)
                a[x[1]+1]-=1;
        }
        for(int i = 1;i<n;i++){
            a[i]+=a[i-1];
            if(a[i]<nums[i])
                return -1;
        }
        if(a[0]<nums[0])
            return -1;
        sort(q.begin(),q.end(),[&](const vector<int>& a,const vector<int>& b){
            if(a[0]==b[0])
                return a[1]>b[1];
            return a[0]<b[0];
        });
        priority_queue<pair<int,int>>pq;
        vector<int>b(n+1,0);
        int sum = 0;
        unordered_set<int>s;
        vector<vector<int>>qv(q.begin(),q.end());
        int ptr = 0;
        for(int i = 0;i<n;i++){
            sum+=b[i];
            while(ptr<m&&q[ptr][0]<=i){
                int r = q[ptr][1];
                int mid = q[ptr][2];
                pq.emplace(r,mid);
                ptr++;
            }
            while(!pq.empty()&&pq.top().first<i)
                pq.pop();
            int cur = sum;
            if(cur<nums[i]){
                int need = nums[i] - cur;
                for(int j = 0;j<need;j++){
                    if(pq.empty())
                         return -1;
                    auto y = pq.top();
                    pq.pop();
                    int r = y.first;
                    int mid = y.second;
                    s.insert(mid);
                    b[i]+=1;
                    if(r+1<n)
                        b[r+1]-=1;
                    sum+=1;
                }
            }
        }
        return m - s.size();
    }
};",1460900929
euanjt,euanjt,645,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> costs(26, vector<long long>(26, 0));
        for(int i = 0; i < 26; i++)
        {
            long long sum = 0;
            for(int j = 0; j < 26; j++)
            {
                costs[i][(i+j)%26] = sum;
                sum += nextCost[(i+j)%26];
            }
        }
        for(int i = 0; i < 26; i++)
        {
            long long sum = 0;
            for(int j = 0; j < 26; j++)
            {
                costs[i][(i-j+26)%26] = min(sum, costs[i][(i-j+26)%26]);
                sum += previousCost[(i-j+26)%26];
            }
        }
        long long answer = 0;
        for(int i = 0; i < s.length(); i++)
        {
            answer += costs[s[i]-'a'][t[i]-'a'];
        }
        return answer;
    }
};",1460821380
euanjt,euanjt,645,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i = 10;
        while(n >= i)
        {
            n -= i;
            i--;
        }
        return i%2;
    }
};",1460808521
euanjt,euanjt,645,3647,cpp,"#define printf(...)
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        vector<vector<int>> my_queries(nums.size(), vector<int>());
        for(auto q: queries)
        {
            int l = q[0];
            int r = q[1];
            my_queries[l].push_back(r);
        }
        int answer = queries.size();
        priority_queue<int> available;
        priority_queue<int, vector<int>, greater<int>> used;
        for(int i = 0; i < nums.size(); i++)
        {
            printf(""Processing: %d:\n"", i);
            for(int r: my_queries[i])
            {
                printf(""New query %d\n"", r);
                available.push(r);
            }
            while(used.size() && used.top() < i){printf(""Popping %d\n"", used.top()); used.pop();}
            printf(""Used.size()=%d\n"", used.size());
            while(nums[i]-(int)used.size() > 0 && available.size())
            {
                answer--;
                int r = available.top();
                available.pop();
                printf(""Using %d\n"", r);
                if(r < i) {return -1;}
                used.push(r);
            }
            if(nums[i]-(int)used.size() > 0){return -1;}
        }
        return answer;
    }
};",1460890475
gentury,gentury,646,3591,cpp,"class Solution {
public:
    long long costs[26][26];
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        for(int i=0;i<26;i++){
            for(int j=1;j<26;j++){
                int prevPos = (i + j -1 + 26) % 26;
                int toPos = (i + j) % 26;
                costs[i][toPos] = costs[i][prevPos] + nextCost[prevPos];
            }
        }
        for(int i=0;i<26;i++){
            for(int j=1;j<26;j++){
                int prevPos = (i - j + 1 + 26) % 26;
                int toPos = (i - j + 26) % 26;
                costs[i][toPos] = min(costs[i][toPos], costs[i][prevPos] + previousCost[prevPos]);
            }
        }
        long long cost = 0;
        for(int i=0;i<s.size();i++){
            cost += costs[s[i] - 'a'][t[i] - 'a'];
        }
        return cost;
    }
};",1460875461
gentury,gentury,646,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int counts = 10;
        bool turn = true;
        while(n >= 0){
            n -= counts--;
            turn = !turn;
        }
        return turn;
    }
};",1460856953
gentury,gentury,646,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        sort(queries.begin(), queries.end());
        priority_queue<int> endQueue;
        int queriesIdx = 0;
        vector<int> counts(nums.size()+1);
        int currentCounts = 0;
        for(int i=0;i<nums.size();i++){
            currentCounts -= counts[i];
            while(queriesIdx < queries.size() && queries[queriesIdx][0] <= i){
                endQueue.push(queries[queriesIdx][1]);
                queriesIdx++;
            }
            while(nums[i] - currentCounts > 0){
                if(endQueue.size() == 0)
                    return -1;
                int end = endQueue.top();
                endQueue.pop();
                if(end < i) 
                    return -1;
                currentCounts++;
                counts[end+1]++;
            }
        }
        return endQueue.size();
    }
};",1460907501
Aleksandr Khamaza,khamaza,647,3591,csharp,"public class Solution {
    public long ShiftDistance(string s, string t, int[] nextCost, int[] previousCost)
{
    long result = 0;
    for (int i = 0; i < s.Length; i++)
    {
        long tmpNextCost = CalculateNextCost(s[i], t[i], nextCost);
        long tmpPrevCost = CalculatePrevCost(s[i], t[i], previousCost);

        result += Math.Min(tmpNextCost, tmpPrevCost);
    }

    return result;
}

private Dictionary<(char, char), long> nextMemo = new Dictionary<(char, char), long>();
private long CalculateNextCost(char left, char right, int[] prices)
{
    if (left == right) return 0;

    var key = (left, right);
    if (nextMemo.ContainsKey(key)) return nextMemo[key];
   
    var lIndex = (int)left;
    var rIndex = (int)right;

    long result = 0;

    while (lIndex != rIndex)
    {
        result += prices[lIndex - 'a'];

        lIndex++;
        if (lIndex > (int)'z') lIndex = (int)'a';
    }

    nextMemo.Add(key, result);
    return result;
}

private Dictionary<(char, char), long> prevMemo = new Dictionary<(char, char), long>();
private long CalculatePrevCost(char left, char right, int[] prices)
{
    if (left == right) return 0;

    var key = (left, right);
    if (prevMemo.ContainsKey(key)) return prevMemo[key];

    var lIndex = (int)left;
    var rIndex = (int)right;

    long result = 0;

    while (lIndex != rIndex)
    {
        result += prices[lIndex - 'a'];

        lIndex--;
        if (lIndex < (int)'a') lIndex = (int)'z';
    }

    prevMemo.Add(key, result);
    return result;
}
}",1460834233
Aleksandr Khamaza,khamaza,647,3625,csharp,"public class Solution {
    public bool CanAliceWin(int n) {
        int curr = 10;
while (true)
{
    if (n < curr)
    {
        return curr % 2 == 0 ? false : true;
    }
    else
    {
        n -= curr;
        curr--;
    }
}
throw new Exception();
    }
}",1460802567
Aleksandr Khamaza,khamaza,647,3647,csharp,"public class Solution {
    public int MaxRemoval(int[] nums, int[][] queries) {
        var sorted = queries.OrderBy(x => x[0]).ToList();
int sortedIndex = 0;

var possValues = new SortedDictionary<int, int>();
int shouldRemove = 0;
var tails = new SortedDictionary<int, int>();

int used = 0;
for (int i = 0; i < nums.Length; i++)
{
    while (tails.Count > 0 && tails.First().Key < i)
    {
        var f = tails.First();
        shouldRemove-= tails[f.Key];
        tails.Remove(f.Key);
    }

    nums[i] -= shouldRemove;

    while (sortedIndex < queries.Length && sorted[sortedIndex][0] <= i)
    {
        //add to collection of possible values, only right value

        int possValue = sorted[sortedIndex][1];
        if (!possValues.ContainsKey(possValue)) possValues.Add(possValue, 0);
        possValues[possValue]++;
        sortedIndex++;
    }

    while (nums[i] > 0)
    {
        if (possValues.Count == 0) return -1;

        var nextRightValue = possValues.Last();
        if (nextRightValue.Key < i) return -1;

        int toRemove = Math.Min(nums[i], nextRightValue.Value);

        possValues[nextRightValue.Key]-= toRemove;
        if (possValues[nextRightValue.Key] == 0)
        {
            possValues.Remove(nextRightValue.Key);
        }

        used += toRemove;
        nums[i]-= toRemove;
        shouldRemove+= toRemove;

        if (!tails.ContainsKey(nextRightValue.Key)) tails.Add(nextRightValue.Key, 0);
        tails[nextRightValue.Key]+=toRemove;
    }

    if (nums[i] > 0) return -1;
}

return queries.Length - used;
    }
}",1460890876
lebron87,lebron87,648,3591,python3,"class Solution:
    def f(self, u, v, next, prev):
        u = ord(u) - ord('a')
        v = ord(v) - ord('a')

        if u == v:
            return 0

        if u< v:
            a = sum(next[u:v] or [0])
            b = sum(prev[:u+1] or [0])
            b += sum(prev[v+1:] or [0])
            return min(a,b)
        if u> v:
            a = sum(next[u:] or [0])
            a += sum(next[:v] or [0])

            b = sum(prev[v+1:u+1] or [0])
            return min(a,b)
        
        
    def shiftDistance(self, s: str, t: str, next: List[int], prev: List[int]) -> int:
        return sum([self.f(u,v,next,prev) for u,v in zip(s,t)])",1460811268
lebron87,lebron87,648,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:

        c = 10
        alice = 0
        while(n >= 0):
            n-=c
            if n < 0:
                break
            c-=1
            alice ^= 1
        return True if alice else False",1460796844
lebron87,lebron87,648,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], qs: List[List[int]]) -> int:
        qs.sort()
        starts = collections.defaultdict(list)
        for u,v in qs:
            starts[u].append(v)
        ends = collections.Counter()
        c = 0
        needs = []
        
    
        
        for i in range(len(nums)):
            c -= ends[i] 
            for v in starts[i]:
                heapq.heappush(needs, [-v,-v+i,i,v])
                #needs.append([i,v])
            
            #needs.sort(key = lambda x:(x[1], -x[0]+x[1]))
            #print (needs,'hello',i)
            if c < nums[i]:
                delta = nums[i] - c
                for _ in range(delta):
                    if needs:
                        aa,bb,u,v = heapq.heappop(needs)
                        ##.pop()
                        if u <= i <=v:
                            c+=1
                            ends[v+1] +=1
                    else:
                        return -1
                if c < nums[i]:
                    return -1
        return len(needs)",1460885259
Jotdeep,jotdeep,649,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost)
    {
        int len=s.length();
        long ans=0;
        for(int i=0;i<len;i++)
        {
            long cost1=calNextCost(s.charAt(i),t.charAt(i),nextCost);
            long cost2=calPrevCost(s.charAt(i),t.charAt(i),previousCost);

            if(cost1<cost2)
            {
                ans+=cost1;
            }
            else
            {
                ans+=cost2;
            }

        }
        return ans;
    }

    long calNextCost(char curr,char end,int nextCost[])
    {
        if(curr==end)
        {
            return 0;
        }
        long cost=nextCost[curr-'a'];

        char next=(char)(curr+1);
        if(curr=='z')
        {
            next='a';
        }
        return cost+calNextCost(next,end,nextCost);
    }
    long calPrevCost(char curr,char end,int nextCost[])
    {
        if(curr==end)
        {
            return 0;
        }
        long cost=nextCost[curr-'a'];

        char next=(char)(curr-1);
        if(curr=='a')
        {
            next='z';
        }
        return cost+calPrevCost(next,end,nextCost);
    }

}",1460831243
Jotdeep,jotdeep,649,3625,java,"class Solution {
    public boolean canAliceWin(int n)
    {
         if(n<10)
        {
            return false;
        }
        n-=10;
        int lastRemoved=10;
       
        boolean aliceTurn=false;
        while (n>0)
        {
            lastRemoved--;
            if(n>=lastRemoved)
            {
                n-=lastRemoved;
                if(aliceTurn==true)
            {
                aliceTurn=false;
            }
            else
            {
                aliceTurn=true;
            }
            }
            else
            {
                break;
            }
            
        }
        return aliceTurn==false;
    }
}",1460802791
Jotdeep,jotdeep,649,3647,java,"import java.util.*;

class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        int[] mi = new int[n + 2];
        for (int[] query : queries) {
            int li = query[0];
            int ri = query[1];
            mi[li]++;
            mi[ri + 1]--;
        }

        for (int i = 1; i < n; i++) {
            mi[i] += mi[i - 1];
        }

        int[] surplus = new int[n];
        for (int i = 0; i < n; i++) {
            if (mi[i] < nums[i]) {
                return -1; 
            }
            surplus[i] = mi[i] - nums[i];
        }

        long[] prefixSurplus = new long[n];
        prefixSurplus[0] = surplus[0];
        for (int i = 1; i < n; i++) {
            prefixSurplus[i] = prefixSurplus[i - 1] + surplus[i];
        }

        long[] totalSurplus = new long[m];
        for (int q = 0; q < m; q++) {
            int li = queries[q][0];
            int ri = queries[q][1];
            totalSurplus[q] = prefixSurplus[ri] - (li > 0 ? prefixSurplus[li - 1] : 0);
        }

        Integer[] order = new Integer[m];
        for (int q = 0; q < m; q++) {
            order[q] = q;
        }
        Arrays.sort(order, (a, b) -> Long.compare(totalSurplus[a], totalSurplus[b]));

        SegmentTreeNode root = new SegmentTreeNode(0, n - 1, surplus);

        int removedQueries = 0;

        for (int idx = 0; idx < m; idx++) {
            int q = order[idx];
            int li = queries[q][0];
            int ri = queries[q][1];

            int minSurplus = root.queryMin(li, ri);

            if (minSurplus > 0) {
                root.updateRange(li, ri, -1);
                removedQueries++;
            }

        }

        return removedQueries;
    }

    static class SegmentTreeNode {
        int start, end;
        int min;
        int lazy;
        SegmentTreeNode left, right;

        public SegmentTreeNode(int start, int end, int[] surplus) {
            this.start = start;
            this.end = end;
            this.lazy = 0;
            if (start == end) {
                this.min = surplus[start];
            } else {
                int mid = (start + end) / 2;
                left = new SegmentTreeNode(start, mid, surplus);
                right = new SegmentTreeNode(mid + 1, end, surplus);
                this.min = Math.min(left.min, right.min);
            }
        }

        private void pushDown() {
            if (lazy != 0) {
                if (left != null) {
                    left.min += lazy;
                    left.lazy += lazy;
                }
                if (right != null) {
                    right.min += lazy;
                    right.lazy += lazy;
                }
                lazy = 0;
            }
        }

        public int queryMin(int l, int r) {
            if (r < start || end < l) {
                return Integer.MAX_VALUE;
            }
            if (l <= start && end <= r) {
                return min;
            }
            pushDown();
            return Math.min(left.queryMin(l, r), right.queryMin(l, r));
        }

        public void updateRange(int l, int r, int val) {
            if (r < start || end < l) {
                return;
            }
            if (l <= start && end <= r) {
                min += val;
                lazy += val;
                return;
            }
            pushDown();
            left.updateRange(l, r, val);
            right.updateRange(l, r, val);
            min = Math.min(left.min, right.min);
        }
    }
}
",1460885323
KilinWei,jack233924,651,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        cost = [[0]*26 for i in range(26)]
        for i in range(26):
            for j in range(i+1, 26):
                cost[i][j] = sum(nextCost[i:j])
                cost[i][j] = min(cost[i][j], sum(previousCost[:i+1])+sum(previousCost[j+1:]))
        for i in range(26):
            for j in range(i):
                cost[i][j] = sum(previousCost[j+1: i+1])
                cost[i][j] = min(cost[i][j], sum(nextCost[i:])+sum(nextCost[:j]))
        totalcost = 0
        base = ord('a')
        for i in range(len(s)):
            totalcost += cost[ord(s[i])-base][ord(t[i])-base]
        return totalcost",1460830800
KilinWei,jack233924,651,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        move = 10
        while True:
            if n < move:
                return False
            n -= move
            move -= 1
            if n < move:
                return True
            n -= move
            move -= 1",1460803449
KilinWei,jack233924,651,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries = sorted(queries, key=lambda q: (q[0], -q[1]))
        waiting = []
        active = []

        qi = 0
        for i in range(len(nums)):
            while qi < len(queries) and queries[qi][0] <= i:
                heapq.heappush(waiting, -queries[qi][1])
                qi += 1

            while len(active) > 0 and active[0] < i:
                heapq.heappop(active)

            while nums[i] > len(active):
                if len(waiting) == 0 or -waiting[0] < i:
                    return -1
                else:
                    end = -heapq.heappop(waiting)
                    heapq.heappush(active, end)
        return len(waiting)
            ",1460896938
asr1y,asr1y,653,3591,cpp,"class Solution {
    long long next[26][26];
    long long prev[26][26];
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        for(int k = 1; k <= 25; k ++) {
            for(int i = 0; i < 26; i ++) {
                int j = (i + k) % 26;
                next[i][j] = nextCost[i] + next[(i + 1) % 26][j];
            }
        }
        for(int k = 1; k <= 25; k ++) {
            for(int i = 0; i < 26; i ++) {
                int j = (i - k + 26) % 26;
                prev[i][j] = previousCost[i] + prev[(i - 1 + 26) % 26][j];
            }
        }
        int n = s.size();
        long long res = 0;
        for(int i = 0; i < n; i ++) {
            res += min(next[s[i] - 'a'][t[i] - 'a'], prev[s[i] - 'a'][t[i] - 'a']);
        }
        return res;
    }
};",1460843535
asr1y,asr1y,653,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int j = 0;
        for(int i = 10; i >= 1 && n - i >= 0; i --, j ++) {
            n -= i;
        }
        return j % 2;
    }
};",1460800542
asr1y,asr1y,653,3647,cpp,"class Solution {
    int diff[100001];
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), m = queries.size();
        sort(queries.begin(), queries.end());
        int res = 0;
        priority_queue<int> pq;
        for(int i = 0, j = 0, k = 0; i < n; i ++) {
            k -= diff[i];
            while(j < m && queries[j][0] <= i) {
                pq.push(queries[j ++][1]);
            }
            while(!pq.empty() && nums[i] > k && pq.top() >= i) {
                int r = pq.top(); pq.pop();
                k ++, diff[r + 1] ++;
                res ++;
            }
            if(nums[i] > k) {
                return -1;
            }
        }
        return m - res;
    }
};",1460902938
evanhe1,evanhe1,654,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long sol = 0;
        for (int i = 0; i < s.size(); i++) {
            int l = s[i]-'a', r = s[i] -'a';
            long long cl = 0, cr = 0;
            int d = t[i]-'a';
            while (l != d) {
                cl += previousCost[l];
                l = (l + 25) % 26;
                
            }
            while (r != d) {
                cr += nextCost[r];
                r = (r + 1) % 26;
            }
            // cout << cl << "" "" << cr << endl;
            sol += min(cl, cr);
        }
        return sol;
    }
};",1460812407
evanhe1,evanhe1,654,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool a = false;
        for (int i = 10; i >= 0; i--) {
            n -= i;
            if (n < 0) return a;
            a = !a;
        }
        return a;
    }
};",1460797493
evanhe1,evanhe1,654,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        multiset<int> pool;
        multiset<int> used;
        sort(queries.begin(), queries.end(), [](vector<int>& a, vector<int>& b) {
            if (a[0] != b[0]) {
                return a[0] < b[0];
            }
            return a[1] > b[1];
        });

        int cur = 0;
        int j = 0;
        int sol = 0;
        for (int i = 0; i < nums.size(); i++) {
            while (used.size() && *used.begin() == i) {
                cur--;
                used.erase(used.begin());
            }
            while (pool.size() && * pool.begin() == i) {
                pool.erase(pool.begin());
            }
            // cout << cur << endl;
            while (cur < nums[i] && (j < queries.size() && queries[j][0] <= i || pool.size())) {
                // cout << ""got in"" << endl;
                if (j < queries.size() && queries[j][0] == i && pool.size()) {
                    auto p = *pool.rbegin();
                    auto q = queries[j];
                    if (p > q[1]) {
                        used.insert(p);
                        pool.erase(prev(pool.end()));
                    } else {
                        used.insert(q[1]+1);
                        j++;
                    }
                } else if (pool.size()) {
                    auto p = *pool.rbegin();
                    used.insert(p);
                    pool.erase(prev(pool.end()));
                } else if (j < queries.size() && queries[j][0] <= i) {
                    auto q = queries[j];
                    used.insert(q[1]+1);
                    j++;
                }
                cur++;
                sol++;
            }
            // cout << cur << endl;
            if (cur < nums[i]) return -1;

            while (j < queries.size() && queries[j][0] == i) {
                pool.insert(queries[j][1]+1);
                j++;
            }
                
        }
        return queries.size()-sol;
    }
};",1460903393
Krishna Tripathi,codesmith17,656,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost,
                            vector<int>& previousCost) {
        long long res = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i])
                continue;

            long long leftToRight = 0, rightToLeft = 0;
            int currentChar = s[i] - 'a';
            int targetChar = t[i] - 'a';

            int forwardSteps = (targetChar >= currentChar)
                                   ? (targetChar - currentChar)
                                   : (26 + targetChar - currentChar);
            for (int j = 0; j < forwardSteps; j++) {
                leftToRight += nextCost[(currentChar + j) % 26];
            }

            int backwardSteps = (currentChar >= targetChar)
                                    ? (currentChar - targetChar)
                                    : (26 + currentChar - targetChar);
            for (int j = 0; j < backwardSteps; j++) {
                rightToLeft += previousCost[(currentChar - j + 26) % 26];
            }

            res += min(leftToRight, rightToLeft);
        }
        return res;
    }
};",1460819454
Krishna Tripathi,codesmith17,656,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool flag = true;
        int remove = 10;
        while (true) {
            flag = !flag;
            if (n >= remove)
                n -= remove;
            else
                return flag;
            remove--;
        }
        return false;
    }
};",1460800170
Krishna Tripathi,codesmith17,656,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size();
        int m = q.size();
        

        vector<int> diff(n + 1, 0);
        for (auto& x : q) {
            int l = x[0], r = x[1];
            diff[l]++;
            if (r + 1 < n) diff[r + 1]--;
        }
        
        for (int i = 1; i < n; i++) {
            diff[i] += diff[i - 1];
        }
        

        
        
        sort(q.begin(), q.end(), [&](const vector<int>& a, const vector<int>& b) {
            return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];
        });

        priority_queue<pair<int, int>> pq; 
        vector<int> diff2(n + 1, 0);
        int cur = 0;
        unordered_map<int,int> mp;
        
        int p = 0;
        for (int i = 0; i < n; i++) {
            cur += diff2[i];
            
            while (p < m and q[p][0] <= i) {
                pq.push({q[p][1], p});
                p++;
            }
            
            while (!pq.empty() and pq.top().first < i) {
                pq.pop();
            }
            
            if (cur < nums[i]) {
                int more = nums[i] - cur;
                for (int j = 0; j < more; j++) {
                    if (pq.empty()) return -1;
                    
                    auto [end, idx] = pq.top();
                    pq.pop();
                    mp[idx]++;
                    
                    diff2[i]++;
                    if (end + 1 < n) diff2[end + 1]--;
                    cur++;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            if (diff[i] < nums[i]) return -1;
        }
        return m - mp.size();
    }
};",1460898168
Farouk Faiz,catalypso,657,3591,python3,"class Solution:
    def shiftDistance(
        self, s: str, t: str, nextCost: list[int], previousCost: list[int]
    ) -> int:
        ans = 0
        cum_sum_next = [nextCost[0]] + [0] * (len(nextCost) - 1)
        cum_sum_previous = [previousCost[0]] + [0] * (len(previousCost) - 1)
        for i in range(25):
            cum_sum_next[i + 1] = nextCost[i + 1] + cum_sum_next[i]
            cum_sum_previous[i + 1] = previousCost[i + 1] + cum_sum_previous[i]
        for i in range(len(s)):
            previous_cost = (
                (
                    cum_sum_previous[ord(s[i]) - ord(""a"")]
                    - cum_sum_previous[ord(t[i]) - ord(""a"")]
                )
                if s[i] >= t[i]
                else cum_sum_previous[ord(s[i]) - ord(""a"")]
                + cum_sum_previous[-1]
                - cum_sum_previous[ord(t[i]) - ord(""a"")]
            )

            next_cost = 0
            if s[i] == t[i]:
                next_cost = 0
            elif s[i] == ""a"":
                next_cost = cum_sum_next[ord(t[i]) - ord(""a"") - 1]
            elif t[i] > s[i]:
                next_cost = (
                    cum_sum_next[ord(t[i]) - ord(""a"") - 1]
                    - cum_sum_next[ord(s[i]) - ord(""a"") - 1]
                )
            else:
                next_cost = (
                    (cum_sum_next[ord(t[i]) - ord(""a"") - 1] if t[i] != ""a"" else 0)
                    + cum_sum_next[-1]
                    - cum_sum_next[ord(s[i]) - ord(""a"") - 1]
                )
            ans += min(previous_cost, next_cost)

        return ans",1460828602
Farouk Faiz,catalypso,657,3625,python3,"
class Solution:
    def canAliceWin(self, n: int) -> bool:
        s = 10
        alice = False
        while n >= s:
            n -= s
            s -= 1
            alice = not alice
        return alice",1460797369
Farouk Faiz,catalypso,657,3647,python3,"class Solution:
    def maxRemoval(self, nums: list[int], queries: list[list[int]]) -> int:
        pool = []
        used = []
        obj = defaultdict(list)
        for [l, r] in queries:
            obj[l].append(r)
        ans = len(queries)
        for i in range(len(nums)):
            for r in obj[i]:
                heappush(pool, -r)
            free = len(used) - bisect_left(used, i)
            # print(i, free, used, len(pool))
            if free >= nums[i]:
                continue
            if len(pool) < nums[i] - free:
                ans = -1
                break
            for _ in range(nums[i] - free):
                r = -heappop(pool)
                if r < i:
                    ans = -1
                    break
                insort(used, r)

                ans -= 1
            if ans == -1:
                break

        return ans",1460893006
prasun goyal,user2043T,659,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long int totalCost = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == t[i]) continue;
            int j = s[i] - 'a';
            int k = t[i] - 'a';
            long long int cost1 = 0, cost2 = 0;
            while (j != k) {
                cost1 += nextCost[j];
                j++;
                j %= 26;
                
            }
            j = s[i] - 'a';
            while (j != k) {
                cost2 += previousCost[j];
                j = (j + 25) % 26;
            }
            totalCost += min(cost1, cost2);
        
        }
        return totalCost;
    }
};",1460828667
prasun goyal,user2043T,659,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int toRemove = 10;
        int ch = 0;
        while (n >= toRemove) {
            n -= toRemove;
            toRemove--;
            ch = (ch + 1) % 2;
        }
        return (ch == 0) ? false : true;
    }
};",1460808211
prasun goyal,user2043T,659,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int fre[100001] = {0};
        queue<int> qrs[nums.size()];
        priority_queue<int> pq;
        for (int i = 0; i < queries.size(); i++) {
            qrs[queries[i][0]].push(queries[i][1]);
        }
        int currSum = 0;
        for (int i = 0; i < nums.size(); i++) {
            currSum += fre[i];
            while (qrs[i].size() > 0) {
                pq.push(qrs[i].front());
                qrs[i].pop();
            }
            while (pq.size() > 0 && currSum < nums[i]) {
                int end = pq.top();
                pq.pop();
                if (end < i) {
                    continue;
                }
                fre[end + 1]--;
                currSum++;
            }
            if (currSum < nums[i]) return -1;
        }
        return pq.size();
    }
};",1460875698
Akhyar Ahmed Turk,akhyar_ahmed_turk,660,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> prv(27,vector<long long>(27,0));
        vector<vector<long long>> next(27,vector<long long>(27,0));
        long long res=0;
        for(int i=0;i<26;i++){
            long long sum=0;
            for(int j=0;j<26;j++){
                next[i][(i+j)%26]=sum;
                sum+=nextCost[(i+j)%26];
            }
        }
        for(int i=0;i<26;i++){
            long long sum=0;
            for(int j=0;j<26;j++){
                prv[i][(i-j+26)%26]=sum;
                sum+=previousCost[(i-j+26)%26];
            }
        }
        for(int i=0;i<s.length();i++){
            res+=min(next[s[i]-'a'][t[i]-'a'],prv[s[i]-'a'][t[i]-'a']);
        }
        return res;
    }
};",1460904411
Akhyar Ahmed Turk,akhyar_ahmed_turk,660,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int a=10;
        while(n>=a){
            if(n-a<a-1) return true;
            n-=(2*a-1);
            a-=2;
        }
        return false;
    }
};",1460826178
Akhyar Ahmed Turk,akhyar_ahmed_turk,660,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        priority_queue<pair<int,int>> pq;
        int n=nums.size();
        unordered_set<int> st;
        vector<vector<int>> start(n);
        vector<vector<int>> end(n+1);
        for(int i=0;i<queries.size();i++){
            start[queries[i][0]].push_back(i);
            end[queries[i][1]+1].push_back(i);
        }
        int max_dec=0,res=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<start[i].size();j++){
                pq.push({queries[start[i][j]][1],start[i][j]});
            }
            for(int j=0;j<end[i].size();j++){
                if(st.find(end[i][j])!=st.end()){
                    max_dec--;
                }
            }
            while(max_dec<nums[i]){
                if(pq.empty() || pq.top().first<i) return -1;
                max_dec++;
                st.insert(pq.top().second);
                pq.pop();
                res++;
            }
        }
        return queries.size()-res;
    }
};",1460880082
the_average_guy,pgthakur,661,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prev) {
        long long ans = 0;
        for(int i=0;i<s.size();i++)
            {
                int c1 = s[i]-'a';
                int c2 = t[i]-'a';

                if(c1>=c2)
                {
                    long long prv1 = 0;
                    while(c1!=c2)
                        {
                            prv1 += (prev[c1]);
                            c1--;
                            if(c1==-1)
                            {
                                c1 = 25;
                            }
                        }
                    long long nxt1 = 0;
                    c1 = s[i]-'a';
                    c2 = t[i]-'a';
                    while(c1!=c2)
                        {
                        
                            nxt1 += nextCost[c1];
                            c1++;
                            if(c1==26)
                            {
                                c1 = 0;
                            }
                        }

                    ans += min(prv1,nxt1);
                }
                else
                {
                    long long prv1 = 0;
                    while(c1!=c2)
                        {
                            prv1 += (prev[c1]);
                            c1--;
                            if(c1==-1)
                            {
                                c1 = 25;
                            }
                        }
                    long long nxt1 = 0;
                    c1 = s[i]-'a';
                    c2 = t[i]-'a';
                    while(c1!=c2)
                        {
                        
                            nxt1 += nextCost[c1];
                            c1++;
                            if(c1==26)
                            {
                                c1 = 0;
                            }
                        }

                    ans += min(prv1,nxt1);
                }
            }
        return ans;
    }
};",1460819793
the_average_guy,pgthakur,661,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int st = 10;
        bool ans = false;
        int ct = 0;
        while(n>=st)
            {
                if(ct%2==0){
                    ans = true;
                }
                else
                {
                    ans = false;
                }
                n -= st;
                ct++;
                st--;
                
            }
        return ans;
    }
};",1460826856
the_average_guy,pgthakur,661,3647,cpp,"class SegTree {
private:
    vector<int> seg, lazy;
    int n;

    void build(const vector<int> &a, int idx, int lo, int hi) {
        if (lo == hi) {
            seg[idx] = a[lo];
        } else {
            int mid = (lo + hi) / 2;
            build(a, 2 * idx, lo, mid);
            build(a, 2 * idx + 1, mid + 1, hi);
            seg[idx] = min(seg[2 * idx], seg[2 * idx + 1]);
        }
    }

    void push(int idx, int lo, int hi) {
        if (lazy[idx] != 0) {
            seg[idx] -= lazy[idx];
            if (lo != hi) {
                lazy[2 * idx] += lazy[idx];
                lazy[2 * idx + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }
    }

    void update(int idx, int lo, int hi, int l, int r, int val) {
        push(idx, lo, hi);

        if (lo > r || hi < l) return;

        if (lo >= l && hi <= r) {
            seg[idx] -= val;
            if (lo != hi) {
                lazy[2 * idx] += val;
                lazy[2 * idx + 1] += val;
            }
            return;
        }

        int mid = (lo + hi) / 2;
        update(2 * idx, lo, mid, l, r, val);
        update(2 * idx + 1, mid + 1, hi, l, r, val);
        seg[idx] = min(seg[2 * idx], seg[2 * idx + 1]);
    }

    int query(int idx, int lo, int hi, int l, int r) {
        push(idx, lo, hi);

        if (lo > r || hi < l) return INT_MAX;

        if (lo >= l && hi <= r) return seg[idx];

        int mid = (lo + hi) / 2;
        int left = query(2 * idx, lo, mid, l, r);
        int right = query(2 * idx + 1, mid + 1, hi, l, r);
        return min(left, right);
    }

public:
    SegTree(const vector<int> &a) {
        n = a.size();
        seg.resize(4 * n, INT_MAX);
        lazy.resize(4 * n, 0);
        build(a, 1, 0, n - 1);
    }

    void rangeUpdate(int l, int r, int val) {
        update(1, 0, n - 1, l, r, val);
    }

    int rangeQuery(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        vector<int> pref(n+1,0);
        for(auto it:queries)
            {
                pref[it[0]]--;
                pref[it[1]+1]++;
            }

        for(int i=1;i<pref.size();i++)
            {
                pref[i] = (pref[i]+pref[i-1]);
            }
       
        vector<int> extr(n,0);
        for(int i=0;i<n;i++)
            {
                pref[i] += nums[i];
                if(pref[i]>=1)
                {
                    return -1;
                }
                extr[i] = (-1*pref[i]);
            }

        // for(auto it:extr)
        //     {
        //         cout<<it<<"" "";
        //     }
        // cout<<endl;
        
        SegTree st(extr);
        int ans = 0;

        vector<vector<int>> vp;
        for(auto it:queries)
            {
                vp.push_back({it[1]-it[0],it[0],it[1]});
            }
        sort(vp.begin(),vp.end());
        for(auto it:vp)
            {
                int l = it[1];
                int r = it[2];
                int mx = st.rangeQuery(l,r);
                if(mx>=1)
                {
                    //cout<<l<<"" ""<<r<<"" ""<<mx<<endl;
                    ans++;
                    st.rangeUpdate(l,r,1);
                }
                
            }
        return ans;
    }
};",1460893266
River Yu,ry51,662,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total = 0

        letters = ""abcdefghijklmnopqrstuvwxyz""

        dict = {}

        for i in range(26):
            dict[letters[i]] = i
        

        def minCost(a, b):
            if a == b: return 0
            elif a < b: return min(sum(nextCost[a:b]), sum(previousCost) - sum(previousCost[a+1:b+1]))
            else: return min(sum(previousCost[b+1:a+1]), sum(nextCost) - sum(nextCost[b:a]))
        
        for i in range(len(s)):
            total += minCost(dict[s[i]], dict[t[i]])

        return total",1460829484
River Yu,ry51,662,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        count = 10
        turns = 0
        while True:
            if n < count:
                if turns % 2 == 0: return False
                return True
            else:
                n -= count
                turns += 1
                count -= 1",1460804176
River Yu,ry51,662,3647,python3,"import bisect

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        l = len(queries)
        queries.sort()

        reqQueries = 0

        currentQ = []
        expiries = []
        for i in range(n):
            while len(queries) > 0 and queries[0][0] == i:
                bisect.insort(currentQ, queries.pop(0)[::-1])
            for _ in range(nums[i] - len(expiries)):
                if len(currentQ) == 0 or (currentQ[-1][0] < i): return -1
                reqQueries += 1
                bisect.insort(expiries, currentQ[-1][0])
                currentQ.pop(-1)
            while len(expiries) > 0 and expiries[0] <= i:
                expiries.pop(0)

        return l - reqQueries
            
                
            
            
        
            
        ",1460893398
Manojkumar P,manojkumar2412,664,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res=0;
        
        for(int i=0;i<s.size();i++){
            char src= s[i], tar=t[i];
            if(src==tar)continue;
            long long using_prev=0,using_next=0;

            int ind=src-'a', tar_ind= tar-'a';

            while((ind%26) !=tar_ind){
                using_next+=nextCost[(ind%26)];
                ind++;
            }
            ind= src-'a';
            while(((ind+26)%26) !=tar_ind){
                using_prev+=previousCost[((ind+26)%26)];
                ind--;
            }
            // cout<<""i: ""<<i<<"" prev_cost: ""<<using_prev<<"" next_cost: ""<<using_next<<endl;
            res+= min(using_prev, using_next);
        }
        return res;
    }
};",1460856271
Manojkumar P,manojkumar2412,664,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10)return false;
        n-=10;
        int i=0;
        int last_turn=10;
        while(n>=0){
            n-=last_turn-1;
            if(n<0){
                if(i&1){
                    return false;
                }
                else return true;
            }
            last_turn--;
            i++;
        }
        return true;
    }
};",1460805361
Manojkumar P,manojkumar2412,664,3647,cpp,"class SegmentTree {
    vector<int> tree, lazy;
    int n;

    // Function to build the tree
    void buildTree(vector<int> &arr, int start, int end, int node) {
        if (start == end) {
            // Leaf node
            tree[node] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        buildTree(arr, start, mid, 2 * node + 1);
        buildTree(arr, mid + 1, end, 2 * node + 2);
        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]); // Max operation
    }

    // Function to propagate laziness
    void propagate(int start, int end, int node) {
        if (lazy[node] != 0) {
            // Apply the pending decrement
            tree[node] -= lazy[node]; // Adjust the current node value
            if (start != end) {       // If not a leaf node
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0; // Clear the lazy value
        }
    }

    // Function to update a range
    void updateRange(int start, int end, int l, int r, int val, int node) {
        propagate(start, end, node); // Ensure the node is up-to-date

        if (start > r || end < l) {
            // No overlap
            return;
        }

        if (start >= l && end <= r) {
            // Complete overlap
            tree[node] -= val; // Decrement the current node
            if (start != end) {
                lazy[2 * node + 1] += val;
                lazy[2 * node + 2] += val;
            }
            return;
        }

        // Partial overlap
        int mid = (start + end) / 2;
        updateRange(start, mid, l, r, val, 2 * node + 1);
        updateRange(mid + 1, end, l, r, val, 2 * node + 2);
        tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]); // Max operation
    }

    // Function to query a range
    int queryRange(int start, int end, int l, int r, int node) {
        propagate(start, end, node); // Ensure the node is up-to-date

        if (start > r || end < l) {
            // No overlap
            return INT_MIN; // Neutral element for max
        }

        if (start >= l && end <= r) {
            // Complete overlap
            return tree[node];
        }

        int mid = (start + end) / 2;
        int left = queryRange(start, mid, l, r, 2 * node + 1);
        int right = queryRange(mid + 1, end, l, r, 2 * node + 2);
        return max(left, right);
    }

public:
    SegmentTree(vector<int> &arr) {
        n = arr.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        buildTree(arr, 0, n - 1, 0);
    }

    void updateRange(int l, int r, int val) {
        updateRange(0, n - 1, l, r, val, 0);
    }

    int queryRange(int l, int r) {
        return queryRange(0, n - 1, l, r, 0);
    }
};

class Solution {
public:
    static bool comp(vector<int>&a, vector<int>&b){
        int a_size= a[1]-a[0], b_size= b[1]-b[0];
        if(a_size==b_size){
            if(a[0]<b[0])return false;
            return true;
        }
        return a_size<b_size;
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n=nums.size();
        SegmentTree segTree(nums);
        vector<vector<int>>new_arr;
        for(vector<int>q: queries){
            segTree.updateRange(q[0], q[1], 1);
            new_arr.push_back({q[1]-q[0], q[0],q[1]});
            // cout<<""query: ""<<segTree.queryRange(0, n-1)<<"" l: ""<<q[0]<<"" r: ""<<q[1]<<endl;
        }
        if(segTree.queryRange(0, n-1)>0)return -1;
        
        sort(new_arr.begin(), new_arr.end());
        int res=0;
        for(vector<int>q: new_arr){
            segTree.updateRange(q[1], q[2], -1);
            int max_value = segTree.queryRange(q[1], q[2]);
            // cout<<""max_value: ""<<max_value<<"" l: ""<<q[0]<<"" r: ""<<q[1]<<endl;
            if(max_value<=0){
                res++;
            }
            else{
                segTree.updateRange(q[1], q[2], 1);
            }
        }
        return res;
    }
};",1460894325
elon_mus,elon_mus,665,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size(); // Length of the strings
        long long totalCost = 0; // To store the total shift distance cost

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';  // Position of current character in s (0-based)
            int target = t[i] - 'a'; // Position of target character in t (0-based)

            // Calculate the number of clockwise shifts
            int clockwiseShifts = (target - start + 26) % 26;
            long long clockwiseCost = 0;
            for (int j = 0; j < clockwiseShifts; ++j) {
                clockwiseCost += nextCost[(start + j) % 26];
            }

            // Calculate the number of counter-clockwise shifts
            int counterClockwiseShifts = (start - target + 26) % 26;
            long long counterClockwiseCost = 0;
            for (int j = 0; j < counterClockwiseShifts; ++j) {
                counterClockwiseCost += previousCost[(start - j + 26) % 26];
            }

            // Add the minimum of the two costs to the total cost
            totalCost += min(clockwiseCost, counterClockwiseCost);
        }

        return totalCost;
    }
};",1460852124
elon_mus,elon_mus,665,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10) return false;
        int totalstone = 0;
        int currentremove=10;
        int turn=1;
        while(totalstone + currentremove <= n){
            totalstone += currentremove;
            currentremove--;
            turn++;
        }
        return (turn % 2 == 0);
    }
};",1460844526
elon_mus,elon_mus,665,3647,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class SegmentTree {
    vector<int> tree, lazy;
    int n;

    void push_down(int node, int l, int r) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (l != r) { // If not a leaf node
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

public:
    SegmentTree(int size) : n(size) {
        tree.assign(4 * n, 0);
        lazy.assign(4 * n, 0);
    }

    void build(const vector<int>& arr, int node, int l, int r) {
        if (l == r) {
            tree[node] = arr[l];
        } else {
            int mid = l + (r - l) / 2;
            build(arr, 2 * node, l, mid);
            build(arr, 2 * node + 1, mid + 1, r);
            tree[node] = min(tree[2 * node], tree[2 * node + 1]);
        }
    }

    int query_min(int node, int l, int r, int ql, int qr) {
        push_down(node, l, r);
        if (qr < l || ql > r) return INT32_MAX; // No overlap
        if (ql <= l && r <= qr) return tree[node]; // Complete overlap
        int mid = l + (r - l) / 2;
        return min(query_min(2 * node, l, mid, ql, qr),
                   query_min(2 * node + 1, mid + 1, r, ql, qr));
    }

    void decrement_range(int node, int l, int r, int ql, int qr) {
        push_down(node, l, r);
        if (qr < l || ql > r) return; // No overlap
        if (ql <= l && r <= qr) { // Complete overlap
            lazy[node] -= 1;
            push_down(node, l, r);
            return;
        }
        int mid = l + (r - l) / 2;
        decrement_range(2 * node, l, mid, ql, qr);
        decrement_range(2 * node + 1, mid + 1, r, ql, qr);
        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), m = queries.size();

        // Step 1: Calculate coverage using a difference array
        vector<int> coverage(n + 1, 0);
        for (auto& q : queries) {
            int l = q[0], r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }
        coverage.pop_back(); // Remove the extra element

        // Step 2: Check if it's possible to zero the array
        vector<int> allowed(n, 0);
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                return -1; // Not possible
            }
        }

        // Step 3: Sort queries by range size
        vector<pair<int, int>> sorted_queries;
        for (auto& q : queries) {
            sorted_queries.emplace_back(q[0], q[1]);
        }
        sort(sorted_queries.begin(), sorted_queries.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            int len_a = a.second - a.first + 1;
            int len_b = b.second - b.first + 1;
            if (len_a != len_b) return len_a < len_b; // Smaller ranges first
            return a.first < b.first; // If same length, sort by starting index
        });

        // Step 4: Initialize segment tree with allowed array
        SegmentTree st(n);
        st.build(allowed, 1, 0, n - 1);

        // Step 5: Iterate through each sorted query and attempt removal
        int removed = 0;
        for (auto& [l, r] : sorted_queries) {
            int current_min = st.query_min(1, 0, n - 1, l, r);
            if (current_min >= 1) {
                st.decrement_range(1, 0, n - 1, l, r);
                removed++;
            }
        }
        return removed;
    }
};


",1460911086
DYR90,DYR90,666,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        n = len(s)
        
        for i in range(n):
            a, b = s[i], t[i]
            p, q = ord(a) - ord('a'), ord(b) - ord('a')
            pp = p
            d1, d2 = 0, 0
            while pp != q:
                d1 += previousCost[pp]
                pp = (pp - 1 + 26) % 26
            pp = p
            while pp != q:
                d2 += nextCost[pp]
                pp = (pp + 1) % 26
            res += min(d1, d2)
        
        return res",1460857653
DYR90,DYR90,666,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        remove = 10
        count = 0
        
        while remove <= n:
            n -= remove
            remove -= 1
            count += 1
        
        return count % 2 == 1",1460798390
DYR90,DYR90,666,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort(key=lambda a:(a[0], a[1]))
        m, n = len(nums), len(queries)
        pq, pq2 = [], []
        cur = 0
        j = 0
        count = 0
        
        for i in range(m):
            t = nums[i]
            while j < n and queries[j][0] <= i:
                heapq.heappush(pq2, -queries[j][1])
                j += 1
            while len(pq) > 0 and pq[0] < i:
                cur -= 1
                heapq.heappop(pq)
            if cur >= t:
                continue
            while len(pq2) > 0 and cur < t:
                if -pq2[0] >= i:
                    cur += 1
                    heappush(pq, -pq2[0])
                    count += 1
                heappop(pq2)
            if cur < t:
                return -1
        
        return n - count",1460894743
Pikachu Uchiha,Sahil-2005,667,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<long long>ps(26);
        vector<long long>ss(26);
        ps[0]=nextCost[0];
        for(int i=1;i<26;i++){
            ps[i]=ps[i-1]+nextCost[i];
        }
        ss[25]=previousCost[25];
        for(int i=24;i>=0;i--){
            ss[i]=ss[i+1]+previousCost[i];
        }
        int n=s.size();
        long long ans=0;
        for(int i=0;i<n;i++)
        {
            if(s[i]==t[i])continue;
            long long nt=0;
            long long pr=0;
            if(s[i]>t[i]){
                nt=ps[25];
                if(t[i]!='a')nt+=ps[t[i]-'a'-1];
                if(s[i]!='a')nt-=ps[s[i]-'a'-1];
            
                pr=ss[t[i]-'a'+1];
                if(s[i]!='z')pr-=ss[s[i]-'a'+1];
            }else{
                nt=ps[t[i]-'a'-1];
                if(s[i]!='a')nt-=ps[s[i]-'a'-1];
                pr=ss[0];
                if(t[i]!='z')pr+=ss[t[i]-'a'+1];
                if(s[i]!='z')pr-=ss[s[i]-'a'+1];
            }
            // cout<<i<<"" ""<<nt<<"" ""<<pr<<endl;
            if(nt>pr){
                ans+=pr;
            }else{
                ans+=nt;
            }
        
        } 
        return ans;
    }
};",1460834556
Pikachu Uchiha,Sahil-2005,667,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int val=10;
        bool turn=true;
        while(true){
            if(n>=val){
                n-=val;
                val--;
                turn=!turn;
            }else{
                return !turn;
            }
        }
        return true;
    }
};",1460799566
Pikachu Uchiha,Sahil-2005,667,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int ans=0;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minh;
        priority_queue<pair<int,int>>maxh;
        int n=nums.size();
        for(auto &el:queries){
            minh.push({el[0],el[1]});
        }
        for(int i=0;i<n;i++){
            if(nums[i]<1)continue;
            while(!minh.empty() && minh.top().first<=i){
                auto p=minh.top();
                minh.pop();
                maxh.push({p.second,p.first});
            }
            int maxi=-1;
            int mini=0;
            vector<int>temp(n+1,0);
            for(int j=0;j<nums[i];j++){
                if(maxh.empty() || maxh.top().first<i){
                    return -1;
                }else{
                    ans++;
                    auto p=maxh.top();
                    maxh.pop();
                    if(maxi<p.first)maxi=p.first;
                    if(mini>p.second)mini=p.second;
                    temp[p.first+1]-=1;
                    temp[p.second]+=1;
                }
            }
            for(int k=mini+1;k<=maxi;k++){
                temp[k]+=temp[k-1];
                nums[k]-=temp[k];
            }
            
        }
        return queries.size()-ans;
    
    }
};",1460906004
Omprakash Patel,yagami__,668,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll ans = 0;
        for(ll i = 0;i<s.length();i++){
            char cur = s[i];
            char req = t[i];
            ll res1 = 0, res2 = 0;
            while(cur != req){
                res1 += nextCost[cur - 'a'];
                if(cur == 'z') cur = 'a';
                else cur++;
            }
            cur = s[i]; req = t[i];
            while(cur != req){
                res2 += previousCost[cur - 'a'];
                if(cur == 'a') cur = 'z';
                else cur--;
            }
            ans += min(res1, res2);
        }
        return ans;
    }
};",1460812342
Omprakash Patel,yagami__,668,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int start = 10;
        int turn = 0;
        while(true){
           if(n >= start){
               n -= start; turn ^= 1;
               start--;
           } 
           else break;
        }
        if(turn == 1) return true;
        return false;
    }
};",1460797108
Omprakash Patel,yagami__,668,3647,cpp,"#define ll long long
struct FenwickTree{
    vector<ll> bit;  
    ll n;
 
    FenwickTree(ll n) {
        this->n = n + 1;
        bit.assign(n + 1, 0);
    }
 
    FenwickTree(vector<ll> a) : FenwickTree(a.size()) {
        for (size_t i = 0; i < a.size(); i++)
            add(i, a[i]);
    }
 
    ll query(ll idx) {
        ll ret = 0;
        for (++idx; idx > 0; idx -= idx & -idx){
            ret += bit[idx];
        }
        return ret;
    }
 
    void range_add(ll l, ll r, ll val) {
        add(l, val);
        add(r + 1, -val);
    }
 
    void add(ll idx, ll delta) {
        for (++idx; idx < n; idx += idx & -idx){
            bit[idx] += delta;
        }
    }
};
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
       ll n = nums.size();
       map<ll,priority_queue<ll>> mp;
       FenwickTree ft(n + 5);
       for(ll i = 0;i<queries.size();i++){
           ll st = queries[i][0], lt = queries[i][1];
           mp[st].push(lt);
       }
       ll ans = 0;
       priority_queue<ll> pq;
       for(ll i = 0;i<nums.size();i++){
           
           ll req1 = ft.query(i);
           ll req = nums[i] - req1;
           

           if(req < 0) req = 0;
           
           priority_queue<ll> pl = mp[i];
           
           while(!pl.empty()){
               pq.push(pl.top());
               pl.pop();
           }
           
           while(!pq.empty() && pq.top() >= i){
                if(req <= 0) break;
                ll rt = pq.top(); pq.pop();
                ft.range_add(0 , rt, 1); 
                req--; ans++;
           } 
           if(req != 0) return -1;
       }
       ll q = queries.size();
       return q - ans;
    }
};
",1460889307
Avijt Mandal,avijitmandal2001,669,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long ans = 0;
        
        for(int i = 0; i < n; i++) {
            int s1 = s[i] - 'a';
            int s2 = t[i] - 'a';
            long long a = 0, b = 0;
            while(s1 != s2) {
                a += nextCost[s1++];
                s1 %= 26;
            }
            s1 = s[i] - 'a';
            while(s1 != s2) {
                b += previousCost[s1--];
                s1 = (s1%26 + 26) % 26;
            }
            ans += min(a, b);
        }
        
        return ans;
    }
};",1460831992
Avijt Mandal,avijitmandal2001,669,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 0;
        int t = 10;
        while(n) {
            if (n >= t) {
                n -= t;
                t--;
            } else break;
            cnt++;
        }
        
        return cnt % 2;
    }
};",1460818231
Avijt Mandal,avijitmandal2001,669,3647,cpp,"int check(int mid, vector<int>& nums, vector<vector<int>>& queries) {
    int n = nums.size();
    vector<int> pre(n+3, 0);
    // ---
    //  ---
    // ------
    for(auto q: queries) {
        if (mid == 0) {
            break;
        }
        int l = q[0], r = q[1];
        pre[l] += 1;
        pre[r+1] -= 1;
        mid--;
    }
    
    for(int i = 1; i < n; i++) {
        pre[i] += pre[i-1];
    }
    
    for(int i = 0; i < n; i++) {
        if (pre[i] < nums[i]) return 0;
    }
    
    return 1;
    
    
}

int cmp(vector<int> a, vector<int> b) {
    return a[1] - a[0] > b[1] - b[0];
}

struct node{
    int idx, l, r, type;
    node(){};
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int lo = 0, hi = queries.size();
        
        int ans = -1;
        
        /*
        1. remove whom to be removed
        2. check if curr coverage is enough
        3. if curr coverage is not enough try to pull out something from reserved who streches furthest greedily
        */
        
        vector<node> nodes[n+2];
        vector<node> nodes_[n+2];
        int i = 0;
        for(auto q: queries) {
            int l = q[0], r = q[1];
            node nn;
            nn.idx = i;
            nn.l = l;
            nn.r = r;
            nn.type = 1;
            nodes[l].push_back(nn);
            nn.type = -1;
            nodes_[r+1].push_back(nn);
            i++;
        }
        
        multiset<pair<int, int>> reserved;
        vector<int> used(queries.size(), 0);

        vector<int> cnt(n+3, 0);
        
        for(int i = 0; i < n; i++) {
            if (i != 0) {
                cnt[i] += cnt[i-1];
            }
            for(node p: nodes_[i]) {
                if (reserved.find({-p.r, p.idx}) != reserved.end()) {
                    reserved.erase(reserved.find({-p.r, p.idx}));
                }
            }
            
            for(node p: nodes[i]) {
                reserved.insert({-p.r, p.idx});
            }
            
            while(cnt[i] < nums[i] and reserved.size()) {
                auto it = reserved.begin();
                cnt[i] += 1;
                cnt[-(it->first)+1] -= 1;
                used[it->second] = 1; 
                reserved.erase(it);
            }
            
            if (cnt[i] < nums[i]) return -1;
        }
        
        
        int usedCount = 0;
        for(auto x: used) {
            usedCount += x;
        }
        return used.size() - usedCount;
        
        
    }
};",1460895379
Lynn,linfq,670,3591,python,"class Solution(object):
    def shiftDistance(self, s, t, nextCost, preCost):
        """"""
        :type s: str
        :type t: str
        :type nextCost: List[int]
        :type previousCost: List[int]
        :rtype: int
        """"""
        ans = 0
        for i in range(len(s)):
            next_cost, pre_cost = 0, 0
            si = s[i]
            while si != t[i]:
                next_cost += nextCost[(ord(si) - ord('a')) % 26]
                si = chr((ord(si) - ord('a') + 1) % 26 + ord('a'))
            si = s[i]
            while si != t[i]:
                pre_cost += preCost[(ord(si) - ord('a')) % 26]
                si = chr((ord(si) - ord('a') - 1) % 26 + ord('a'))
            ans += min(next_cost, pre_cost)
        
        return ans

            ",1460837006
Lynn,linfq,670,3625,python,"class Solution(object):
    def canAliceWin(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        ans = False
        for m in range(10, 0, -1):
            if n < m:
                return ans
            n -= m
            ans = not ans
        return False
",1460814418
Lynn,linfq,670,3647,python,"from sortedcontainers import SortedList

class Solution(object):
    def maxRemoval(self, nums, queries):
        """"""
        :type nums: List[int]
        :type queries: List[List[int]]
        :rtype: int
        """"""
        query_map = {}
        for [l, r] in queries:
            if l not in query_map:
                query_map[l] = SortedList()
            query_map[l].add(r)

        ans = len(queries)
        diff = [0] * (len(nums) + 1)
        curr = 0
        for i in range(len(nums)):
            curr += diff[i]
            while nums[i] > curr:
                if i not in query_map or len(query_map[i]) == 0: return -1
                mx = query_map[i].pop()
                if mx < i: return -1
                curr += 1
                diff[mx + 1] -= 1
                ans -= 1
            if i in query_map:
                if i + 1 not in query_map:
                    query_map[i + 1] = query_map[i]
                else:
                    query_map[i + 1].update(query_map[i])
                query_map.pop(i)

        return ans",1460890110
Hirnaymay Bhaskar,octopols,671,3591,cpp,"class Solution {
public:
    long long shiftDistance(string source, string target, vector<int>& forwardCostArray, vector<int>& backwardCostArray) {
        long long totalShiftCost = 0; 

        for (int i = 0; i < source.length(); ++i) {
            int sourceChar = source[i] - 'a'; 
            int targetChar = target[i] - 'a'; 

            if (sourceChar == targetChar) continue; 
            int forwardShifts = (targetChar - sourceChar + 26) % 26; 
            long long forwardShiftCost = 0;
            for (int j = 0; j < forwardShifts; ++j) {
                forwardShiftCost += forwardCostArray[(sourceChar + j) % 26];
            }
            int backwardShifts = (sourceChar - targetChar + 26) % 26; 
            long long backwardShiftCost = 0;
            for (int j = 0; j < backwardShifts; ++j) {
                backwardShiftCost += backwardCostArray[(sourceChar - j + 26) % 26];
            }
            totalShiftCost += min(forwardShiftCost, backwardShiftCost);
        }

        return totalShiftCost;
    }
};",1460855319
Hirnaymay Bhaskar,octopols,671,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n < 10) return false;
        bool alice = false;
        for(int i = 10; i > 0 && i <= n; --i) {
            if(n >= i) {
                n -= i;
            }
            alice = !alice;
        }
        return alice;
    }
};",1460834768
Hirnaymay Bhaskar,octopols,671,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        
        vector<int> coverage(n + 1, 0);
        for (const auto& query : queries) {
            int left = query[0], right = query[1];
            coverage[left] += 1;
            if (right + 1 < n) {
                coverage[right + 1] -= 1;
            }
        }
        
        for (int i = 1; i < n; ++i) {
            coverage[i] += coverage[i - 1];
        }
        
        for (int i = 0; i < n; ++i) {
            if (coverage[i] < nums[i]) {
                return -1;
            }
        }
        
        vector<tuple<int, int, int>> sortedQueries;
        sortedQueries.reserve(m);
        for (int i = 0; i < m; ++i) {
            sortedQueries.emplace_back(queries[i][0], queries[i][1], i);
        }
        
        sort(sortedQueries.begin(), sortedQueries.end(), [&](const tuple<int, int, int>& a, const tuple<int, int, int>& b) {
            if (get<0>(a) == get<0>(b)) {
                return get<1>(a) > get<1>(b);
            }
            return get<0>(a) < get<0>(b);
        });
        
        priority_queue<pair<int, int>> pq; // (end, query_id)
        vector<int> diff(n + 1, 0); // Difference array for additional coverage
        int totalAdded = 0;
        unordered_set<int> removedQueries;
        
        int queryIdx = 0;
        for (int i = 0; i < n; ++i) {
            totalAdded += diff[i];
            
            while (queryIdx < m && get<0>(sortedQueries[queryIdx]) <= i) {
                int end = get<1>(sortedQueries[queryIdx]);
                int queryId = get<2>(sortedQueries[queryIdx]);
                pq.emplace(end, queryId);
                ++queryIdx;
            }
            
            while (!pq.empty() && pq.top().first < i) {
                pq.pop();
            }
            
            int currentCoverage = totalAdded;
            
            if (currentCoverage < nums[i]) {
                int deficit = nums[i] - currentCoverage;
                for (int j = 0; j < deficit; ++j) {
                    if (pq.empty()) {
                        return -1;
                    }
                    
                    auto topQuery = pq.top();
                    pq.pop();
                    int selectedEnd = topQuery.first;
                    int queryId = topQuery.second;
                    removedQueries.insert(queryId);
                    
                    diff[i] += 1;
                    if (selectedEnd + 1 < n) {
                        diff[selectedEnd + 1] -= 1;
                    }
                    totalAdded += 1;
                }
            }
        }
        
        return m - removedQueries.size();
    }
};",1460872641
Atharv Paliwal,dryice,674,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        int n=s.length();
        for(int i=0;i<n;i++)
        {
            long long int op1=0,op2=0;
            long long int in1=s[i]-'a';
            long long int in2=t[i]-'a';
            if(s[i]<=t[i])
            {
                for(int j=in1;j<in2;j++)
                    op1+=nextCost[j];
                for(int j=in1;j>=0;j--)
                    op2+=previousCost[j];
                for(int j=25;j>in2;j--)
                    op2+=previousCost[j];
            }
            else
            {
                for(int j=in1;j<=25;j++)
                    op1+=nextCost[j];
                for(int j=0;j<in2;j++)
                    op1+=nextCost[j];
                for(int j=in1;j>in2;j--)
                    op2+=previousCost[j];
            }
            ans+=min(op1,op2);
        }
        return ans;
    }
};",1460807342
Atharv Paliwal,dryice,674,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr=10;
        int turn=0;
        while(n-curr>=0)
        {
            turn^=1;
            n-=curr;
            curr--;
        }
        return turn;
    }
};",1460797241
Atharv Paliwal,dryice,674,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        struct comp
        {
            bool operator()(const array<int,2>& x, const array<int,2>& y) const
            {
                if(true)
                    return x[1]>y[1];
                return x[1]-x[0]>y[1]-y[0];
            }
        };
        multiset<array<int,2>, comp> available, inUse;
        map<int,vector<int>> start, end;
        for(auto &x:queries)
        {
            start[x[0]].push_back(x[1]);
            end[x[1]].push_back(x[0]);
        }
        int curr=0;
        int ans=0;
        for(int i=0;i<nums.size();i++)
        {
            if(start.find(i)!=start.end())
            {
                for(auto &x:start[i])
                {
                    array<int,2> temp={i,x};
                    available.insert(temp);
                }
            }
            if(end.find(i-1)!=end.end())
            {
                for(auto &x:end[i-1])
                {
                    auto it2=inUse.find({x,i-1});
                    if (it2!=inUse.end())
                    {
                        curr--;
                        inUse.erase(it2);
                    }
                    auto it=available.find({x,i-1});
                    if (it!=available.end())
                    {
                        available.erase(it);
                        ans++;
                    }
                }
            }
            while(curr<nums[i] && !available.empty())
            {
                auto f=*available.begin();
                available.erase(available.begin());
                inUse.insert(f);
                curr++;
            }
            // cout<<""i: ""<<i<<""\n"";
            // cout<<""available: "";
            // for(auto &x:available)
            //     cout<<x[0]<<""->""<<x[1]<<"" "";
            // cout<<""\n"";
            // cout<<""inUse: "";
            // for(auto &x:inUse)
            //     cout<<x[0]<<""->""<<x[1]<<"" "";
            // cout<<""\n"";
            // cout<<""curr: ""<<curr<<""\n\n"";
            if(curr<nums[i])
                 return -1;
        }
        return ans+available.size();
    }
};
/*

[0,0,3]
[[0,2],[1,1],[0,0],[0,0]]
ans = -1

[2,2,3,4]
[[0,3],[2,3],[2,3],[0,2],[0,0],[0,2],[0,3],[0,2]]
ans = 4

*/",1460902445
igigig,igigig,675,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        cum_next = [0] + list(itertools.accumulate(nextCost))
        cum_prev = [0] + list(itertools.accumulate(previousCost))
        tot_next = sum(nextCost)
        tot_prev = sum(previousCost)
        ret = 0
        for char_s, char_t in zip(s, t):
            if char_s == char_t:
                continue
            if ord(char_s) < ord(char_t):
                forward_cost = cum_next[ord(char_t) - ord('a')] - cum_next[ord(char_s) - ord('a')]
            elif ord(char_s) > ord(char_t):
                forward_cost = tot_next - (cum_next[ord(char_s) - ord('a')] - cum_next[ord(char_t) - ord('a')])
            if ord(char_s) > ord(char_t):
                prev_cost = cum_prev[ord(char_s) - ord('a') + 1] - cum_prev[ord(char_t) - ord('a') + 1]
            elif ord(char_s) < ord(char_t):
                prev_cost = tot_prev - (cum_prev[ord(char_t) - ord('a') + 1] - cum_prev[ord(char_s) - ord('a') + 1])
            ret += min(forward_cost, prev_cost)
        return ret

        # 5000000000
        # 48",1460852934
igigig,igigig,675,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rem = 10
        alice_wins = False
        while n > 0:
            if rem > n:
                return alice_wins
            alice_wins = not(alice_wins)
            n -= rem
            rem -= 1
        return alice_wins",1460797022
igigig,igigig,675,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        heap = []
        j = 0
        endpoints = []
        n_hits = 0
        n_unused_qs = 0
        for i in range(len(nums)):
            if nums[i] == 0:
                continue
            while j < len(queries) and queries[j][0] <= i:
                if queries[j][1] >= i:
                    heapq.heappush(heap, -queries[j][1])
                else:
                    n_unused_qs += 1
                j += 1
            while endpoints and endpoints[0] < i:
                n_hits -= 1
                heapq.heappop(endpoints)
            while heap and n_hits < nums[i]:
                end = -heapq.heappop(heap)
                if end < i:
                    n_unused_qs += 1
                else:
                    n_hits += 1
                    heapq.heappush(endpoints, end)
            if n_hits < nums[i]:
                return -1
        return len(heap) + len(queries) - j + n_unused_qs
            
            ",1460891329
MSA TANZEEL,msa_tanzeel,676,3591,cpp,"
#define ll long long
#define loopf(i, a, b) for (int i = a; i < b; i++)
#define loopb(i, a, b) for (int i = a; i > b; i--)
#define loopit(it, st) for (auto it = st.begin(); it != st.end(); it++)


class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        long long ans = 0;

        auto getNextCost = [&] (int i1, int i2) -> long long {
            long long curr = 0;
            while (i1 != i2)
            {
                curr += nextCost[i1++];
                if (i1 == nextCost.size())
                    i1 = 0;
            }
            return curr;
        };

        auto getPrevCost = [&] (int i1, int i2) -> long long {
            long long curr = 0;
            while (i1 != i2)
            {
                curr += previousCost[i1--];
                if (i1 < 0)
                    i1 = previousCost.size() - 1;
            }
            return curr;
        };



        loopf(i,0,n)
        {
            int curr_ind = s[i] - 'a';
            if (s[i] == t[i])
                continue;
            ans += min(getNextCost(s[i]-'a', t[i]-'a'), getPrevCost(s[i]-'a', t[i]-'a'));
        }

        return ans;
    }
};",1460816122
MSA TANZEEL,msa_tanzeel,676,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool state = 0;
        int curr = 10;
        while (true) {
            if (n < curr)
                break;
            n -= curr;
            curr--;
            state ^= 1;
        }            

        return state;
    }
};",1460797835
MSA TANZEEL,msa_tanzeel,676,3647,cpp,"#define ll long long
#define loopf(i, a, b) for (int i = a; i < b; i++)
#define loopb(i, a, b) for (int i = a; i > b; i--)
#define loopit(it, st) for (auto it = st.begin(); it != st.end(); it++)



struct node
{
    //ye jo hai initial value of node in segment tree rahta
    //seg tree build karte so time pe ye value ka effect ny padna
    // jyse ki sum ke time iski value 0 rahna....
	ll v=0;
	node(){}
	node(ll val){
		v=val;
	}

    // build karte so time kis tarah se niche ke do nodes ke values ku process krte
    // wo cheez idar likhte
	void merge(const node &l,const node &r){ 
		// v=l.v+r.v;
        v = max(l.v, r.v);
	}
};
 

 
struct update
{
    //ye jo hai initial value rahti lazy tree ke node ki,
    // take care so that,jysa b first pending update aata,wo update ku initial
    // value effect ny krna
	ll v = 0;
	update(){}
	update(int val){
		v = val; 
	}
    // pehle jo lazy tree ke node pe info/pending update the,usku add krte idar
	void combine(update &other,const ll &tl,const ll &tr){
		v += other.v;
	}

    //idar jo hai apan lazy tree ka info/data ku seg tree ke node pe apply kardete
    //tl aur tr jo hai , wo segment ke extremes hai
    // x jo hai apanki original segment tree ki node hai aur v hai hai 
    //lazy tree ke node me hai so value

	void apply(node &x,const ll &tl,const ll &tr){
		x.v += v;
	}
};
 
struct segtree
{
	ll len;
	vector<node> t;
	vector<update> u;
	vector<bool> lazy;
	node identity_element;
	update identity_transformation;
	segtree(ll l){
		len = l;
		t.resize(4 * len);
		u.resize(4 * len);
		lazy.resize(4 * len);
		identity_element = node();
		identity_transformation = update();
	}
 
	void pushdown(const ll &v, const ll &tl, const ll &tr){
		if(!lazy[v]) return;
		ll tm = (tl + tr) >> 1;
		apply(v<<1,tl,tm,u[v]);
		apply(v<<1|1,tm+1,tr,u[v]);
		u[v] = identity_transformation;
		lazy[v] = 0;
	}
 
	void apply(const ll &v, const ll &tl, const ll &tr, update upd){
		if(tl != tr){
			lazy[v] = 1;
			u[v].combine(upd,tl,tr);
		}
		upd.apply(t[v],tl,tr);
	}
 
	template<typename T>
	void build(const T &arr,const ll &v, const ll &tl, const ll &tr){
		if(tl == tr){
			t[v] = arr[tl];
			return;
		}
		int32_t tm = (tl + tr) >> 1;
		build(arr,v<<1,tl,tm);
		build(arr,v<<1|1,tm+1,tr);
		t[v].merge(t[v<<1],t[v<<1|1]);
	}
 
	node query(const ll &v,const ll &tl,const ll &tr,const ll &l,const ll &r){
		if(l > tr || r < tl){
			return identity_element;
		}
		if(tl >= l && tr <= r){
			return t[v];
		}
		pushdown(v,tl,tr);
		int32_t tm = (tl + tr) >> 1;
		node a = query(v<<1,tl,tm,l,r),b = query(v<<1|1,tm+1,tr,l,r),ans;
		ans.merge(a,b);
		return ans;
	}
 
	// rupd = range update
	void rupd(const ll &v,const ll &tl,const ll &tr,const ll &l,const ll &r,const update &upd){
		if(l > tr || r < tl){
			return;
		}
		if(tl >= l && tr <= r){
			apply(v,tl,tr,upd);
			return;
		}
		pushdown(v,tl,tr);
		int32_t tm = (tl + tr) >> 1;
		rupd(v<<1,tl,tm,l,r,upd);
		rupd(v<<1|1,tm+1,tr,l,r,upd);
		t[v].merge(t[v<<1],t[v<<1|1]);
	}
 
	public:
	template<typename T>
	void build(const T &arr){
		build(arr,1,0,len-1);
	}
	node query(const ll &l,const ll &r){
		return query(1,0,len-1,l,r);
	}
	void rupd(const ll &l,const ll &r,const update &upd){
		rupd(1,0,len-1,l,r,upd);
	}
};


class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        segtree s(n);
        s.build(nums);

        sort(queries.begin(), queries.end());
        reverse(queries.begin(), queries.end());
        

        for(auto query : queries)
        {
            int l, r;
            l = query[0];
            r = query[1];
            s.rupd(l, r, -1);
        }

        if (s.query(0, n - 1).v > 0)
            return -1;

        int removed_elements = 0;

        for(auto query : queries)
        {
            int l, r;
            l = query[0];
            r = query[1];
            s.rupd(l, r, 1);

            if (s.query(0, n-1).v <= 0LL)
            {
                removed_elements++;
            }
            else 
            {
                s.rupd(l, r, -1);
            }
        }

        return removed_elements;
    }
};
",1460891520
Ahmed Sayed,AhmedSayed1,677,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& pre) {
        ll ans=0;
        for(int i=0;i<s.size();i++){
            if(s[i]!=t[i]){
                char c=s[i];
                ll cost1=0,cost2=0;

                while(c!=t[i]){
                    cost1+=pre[c-'a'];

                    (c=='a'?c='z':c--);
                }

                c=s[i];

                while(c!=t[i]){
                    cost2+=next[c-'a'];

                    (c=='z'?c='a':c++);
                }
                ans+=min(cost1,cost2);
            }
        }

        return ans;
    }
};",1460828227
Ahmed Sayed,AhmedSayed1,677,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int o=10,p=0;
        while(n>=o){
            p=!p,
            n-=o--;
        }
        return p;
    }
};",1460809603
Ahmed Sayed,AhmedSayed1,677,3647,cpp,"#define ll long long
class Solution {
public:
    int v[(ll)1e5+5];

    struct st{
        int mx,lazy;
    };
    
    st seg[(ll)5e5];

    void push(int node,int l,int r){
        seg[node].mx+=seg[node].lazy;

        if(l!=r){
            seg[node*2].lazy+=seg[node].lazy,
            seg[node*2+1].lazy+=seg[node].lazy;
        }
        seg[node].lazy=0;
    }

    void bul(int node,int l,int r){
        if(l==r){
            seg[node].mx=v[l];
            return;
        }

        int m=(l+r)>>1;
        bul(node*2,l,m),
        bul(node*2+1,m+1,r);

        seg[node].mx=max(seg[node*2].mx,seg[node*2+1].mx);
    }

      int get(int node,int l,int r,int lef,int righ){
        push(node,l,r);
          
        if(l>righ||r<lef)return -1e9;
        if(l>=lef&&r<=righ)return seg[node].mx;

        int m=(l+r)>>1;
        return max(get(node*2,l,m,lef,righ),get(node*2+1,m+1,r,lef,righ));
      }

     void up(int node,int l,int r,int lef,int righ){
        push(node,l,r);
        
        if(l>righ||r<lef)return;
        if(l>=lef&&r<=righ){
            seg[node].lazy++,
            push(node,l,r);
            
            return;
        }

        int m=(l+r)>>1;
        up(node*2,l,m,lef,righ),
        up(node*2+1,m+1,r,lef,righ);

        seg[node].mx=max(seg[node*2].mx,seg[node*2+1].mx);
      }


    int maxRemoval(vector<int>& x, vector<vector<int>>& q) {
        x.insert(x.begin()+0,0);

        int n=x.size()-1;
        vector<ll>pre(n+5);

        for(auto i:q)
            pre[i[0]+1]--,pre[i[1]+2]++;
        
        for(int i=1;i<=n;i++){
            pre[i]+=pre[i-1],
            x[i]+=pre[i];
            
            if(x[i]>0)return -1;
        }

        for(int i=0;i<x.size();i++)v[i]=x[i];
        bul(1,1,n);
    
        vector<array<ll,3>>qq;
        for(auto i:q){
            qq.push_back({abs(i[0]-i[1]),i[0],i[1]});
        }

        sort(qq.begin(),qq.end());
        int ans=0;
        for(auto i:qq)
            if(get(1,1,n,i[1]+1,i[2]+1)<0){
                up(1,1,n,i[1]+1,i[2]+1);
                ans++;
            }

        return ans;
    }
};",1460897275
Phanora,dnanper,678,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt,
    vector<int>& pre) {
        int n = s.size();
        // pick s[i] and l shift 1: 'a' -> 'b' cost nxt[s[i] - 'a']
        // pick s[i] and r shift 1: 'a' -> 'z' cost pre[s[i] - 'a']
        // find min to change s to t
        long long res = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;
            long long a = 0, b = 0;
            int cur = s[i] - 'a', tar = t[i] - 'a';
            while (cur != tar) {
                a += nxt[cur];
                cur = (cur + 1)%26;
            }
            cur = s[i] - 'a';
            while (cur != tar) {
                b += pre[cur];
                cur = (cur - 1 + 26)%26;
            }
            res += min(a, b);
        }
        return res;
    }
};",1460831984
Phanora,dnanper,678,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int k = 10, f = 0;
        while (n >= k) {
            n -= k;
            k--;
            f = 1 - f;

        }
        if (f == 1 && n < k) return true;
        return false;
    }
};",1460812040
Phanora,dnanper,678,3647,cpp,"class SegmentTree {
    vector<int> tree, lazy;
    int n;

    void pushDown(int node, int l, int r) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (l != r) { // Khng phi nt l
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void build(const vector<int>& allowed, int node, int l, int r) {
        pushDown(node, l, r);
        if (l == r) {
            tree[node] = allowed[l];
        } else {
            int mid = l + (r - l) / 2;
            build(allowed, 2 * node, l, mid);
            build(allowed, 2 * node + 1, mid + 1, r);
            tree[node] = min(tree[2 * node], tree[2 * node + 1]);
        }
    }

    int queryMin(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (qr < l || ql > r) return INT_MAX;
        if (ql <= l && r <= qr) return tree[node];
        int mid = l + (r - l) / 2;
        return min(queryMin(2 * node, l, mid, ql, qr),
                   queryMin(2 * node + 1, mid + 1, r, ql, qr));
    }

    void decrementRange(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (qr < l || ql > r) return;
        if (ql <= l && r <= qr) {
            lazy[node] -= 1;
            pushDown(node, l, r);
            return;
        }
        int mid = l + (r - l) / 2;
        decrementRange(2 * node, l, mid, ql, qr);
        decrementRange(2 * node + 1, mid + 1, r, ql, qr);
        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }

public:
    SegmentTree(int size) : n(size) {
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
    }

    void build(const vector<int>& allowed) {
        build(allowed, 1, 0, n - 1);
    }

    int queryMin(int ql, int qr) {
        return queryMin(1, 0, n - 1, ql, qr);
    }

    void decrementRange(int ql, int qr) {
        decrementRange(1, 0, n - 1, ql, qr);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        vector<int> coverage(n + 1, 0);

        // Xy dng mng coverage
        for (auto& q : queries) {
            int l = q[0], r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }

        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }
        coverage.resize(n);

        // Xy dng mng allowed
        vector<int> allowed(n);
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                return -1;
            }
        }

        // Sp xp cc truy vn
        vector<vector<int>> sortedQueries = queries;
        sort(sortedQueries.begin(), sortedQueries.end(), [](const vector<int>& a, const vector<int>& b) {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            if (lenA != lenB) {
                return lenA < lenB;
            }
            return a[0] < b[0];
        });

        SegmentTree st(n);
        st.build(allowed);

        int removed = 0;
        for (auto& q : sortedQueries) {
            int l = q[0], r = q[1];
            int currentMin = st.queryMin(l, r);
            if (currentMin >= 1) {
                st.decrementRange(l, r);
                removed++;
            }
        }

        return removed;
    }
};
",1460908412
Sumanth Bandari,sumanthbandari73,679,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            char from = s.charAt(i);
            char to = t.charAt(i);

            // Calculate forward and backward distances
            int forwardDist = (to - from + 26) % 26; // Circular forward distance
            int backwardDist = (from - to + 26) % 26; // Circular backward distance

            // Calculate forward and backward costs
            long forwardCost = 0;
            for (int j = 0; j < forwardDist; j++) {
                int idx = (from - 'a' + j) % 26; // Alphabet index for each step
                forwardCost += nextCost[idx];
            }

            long backwardCost = 0;
            for (int j = 0; j < backwardDist; j++) {
                int idx = (from - 'a' - j + 26) % 26; // Alphabet index for each step
                backwardCost += previousCost[idx];
            }

            // Add the minimal cost to the total
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}
",1460812411
Sumanth Bandari,sumanthbandari73,679,3625,java,"public class Solution {
    public boolean canAliceWin(int n) {
        int stonesToRemove = 10; // Alice starts with removing 10 stones
        boolean isAliceTurn = true;

        while (n > 0) {
            if (n < stonesToRemove) {
                // Current player cannot make a move, so the other player wins
                return !isAliceTurn;
            }
            n -= stonesToRemove;
            stonesToRemove--; // Decrease the number of stones to remove
            isAliceTurn = !isAliceTurn; // Alternate turns
        }

        // If we exit the loop, it means the last player to move loses
        return !isAliceTurn;
    }
}
",1460806138
Sumanth Bandari,sumanthbandari73,679,3647,java,"import java.util.*;

public class Solution {
    static class SegTree {
        int n;
        int[] tree, lazy;

        SegTree(int size) {
            n = size;
            tree = new int[4 * n];
            lazy = new int[4 * n];
        }

        void pushDown(int v, int l, int r) {
            if (lazy[v] != 0) {
                tree[v] += lazy[v];
                if (l != r) {
                    lazy[2 * v] += lazy[v];
                    lazy[2 * v + 1] += lazy[v];
                }
                lazy[v] = 0;
            }
        }

        void build(int[] arr, int v, int l, int r) {
            pushDown(v, l, r);
            if (l == r) {
                tree[v] = arr[l];
            } else {
                int m = l + (r - l) / 2;
                build(arr, 2 * v, l, m);
                build(arr, 2 * v + 1, m + 1, r);
                tree[v] = Math.min(tree[2 * v], tree[2 * v + 1]);
            }
        }

        int queryMin(int v, int l, int r, int ql, int qr) {
            pushDown(v, l, r);
            if (qr < l || ql > r) return Integer.MAX_VALUE;
            if (ql <= l && r <= qr) return tree[v];
            int m = l + (r - l) / 2;
            return Math.min(queryMin(2 * v, l, m, ql, qr), queryMin(2 * v + 1, m + 1, r, ql, qr));
        }

        void decrementRange(int v, int l, int r, int ql, int qr) {
            pushDown(v, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lazy[v] -= 1;
                pushDown(v, l, r);
                return;
            }
            int m = l + (r - l) / 2;
            decrementRange(2 * v, l, m, ql, qr);
            decrementRange(2 * v + 1, m + 1, r, ql, qr);
            tree[v] = Math.min(tree[2 * v], tree[2 * v + 1]);
        }
    }

    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        // Step 1: Calculate coverage using difference array
        int[] cov = new int[n + 1];
        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];
            cov[l]++;
            if (r + 1 < n) cov[r + 1]--;
        }

        // Prefix sum to get the coverage
        for (int i = 1; i < n; i++) {
            cov[i] += cov[i - 1];
        }

        // Step 2: Calculate allowed removals
        int[] allowed = new int[n];
        for (int i = 0; i < n; i++) {
            allowed[i] = cov[i] - nums[i];
            if (allowed[i] < 0) return -1;
        }

        // Step 3: Create a copy of queries
        int[][] qCopy = new int[m][2];
        System.arraycopy(queries, 0, qCopy, 0, m);

        // Step 4: Sort queries by range size
        Arrays.sort(qCopy, (a, b) -> {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            if (lenA != lenB) return Integer.compare(lenA, lenB);
            return Integer.compare(a[0], b[0]);
        });

        // Step 5: Initialize the Segment Tree
        SegTree st = new SegTree(n);
        st.build(allowed, 1, 0, n - 1);

        // Step 6: Process each query and attempt removal
        int removed = 0;
        for (int[] q : qCopy) {
            int l = q[0], r = q[1];
            int minVal = st.queryMin(1, 0, n - 1, l, r);
            if (minVal >= 1) {
                st.decrementRange(1, 0, n - 1, l, r);
                removed++;
            }
        }

        return removed;
    }
}
",1460861547
Ayush Sharma,ayush-018,680,3591,cpp,"class Solution {
private:
    long long calcCloclWise(int strt, int trgt, vector<int>& nextC) {
        int t1 = (trgt - strt + 26) % 26;
        long long t1Cost = 0;
        for (int i = 0; i < t1; ++i) {
            t1Cost += nextC[(strt + i) % 26];
        }
        return t1Cost;
    }

    long long calcPrice(int strt, int trgt, vector<int>& prevC) {
        int t2 = (strt - trgt + 26) % 26;
        long long t2Cost = 0;
        for (int i = 0; i < t2; ++i) {
            t2Cost += prevC[(strt - i + 26) % 26];
        }
        return t2Cost;
    }
public:
    long long shiftDistance(string& s, string& t, vector<int>& nextC, vector<int>& prevC) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        long long tC = 0;

        for (size_t i = 0; i < s.length(); ++i) {
            int strt = s[i] - 'a';
            int trgt = t[i] - 'a';

            long long t1 = calcCloclWise(strt, trgt, nextC);
            long long t2 = calcPrice(strt, trgt, prevC);

            tC += min(t1, t2);
        }

        return tC;
    }
};
",1460825994
Ayush Sharma,ayush-018,680,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        bool win = true;  
        int sToR = 10; 
        
        while (n > 0) {
            if (n < sToR) {
                return !win;
            }
            n -= sToR;
            sToR--;
            win = !win;
        }
        
        return !win;
    }
};
",1460813245
Ayush Sharma,ayush-018,680,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& arr, vector<vector<int>>& ranges) {
        vector<int> temp = calculateCoverage(arr, ranges);
        
        if (!isFeasible(arr, temp)) {
            return -1;
        }
        
        vector<tuple<int, int, int>> sortedQ = sortQueries(ranges);
        
        priority_queue<pair<int, int>> pq;
        vector<int> delta(arr.size() + 1, 0);
        int addTotal = 0;
        unordered_set<int> usedQ;
        
        return processQueries(arr, sortedQ, pq, delta, addTotal, usedQ);
    }

private:
    vector<int> calculateCoverage(vector<int>& arr, vector<vector<int>>& ranges) {
        vector<int> temp(arr.size() + 1, 0);
        for (auto& range : ranges) {
            int l = range[0];
            int r = range[1];
            temp[l] += 1;
            if (r + 1 < arr.size()) {
                temp[r + 1] -= 1;
            }
        }
        for (int i = 1; i < arr.size(); i++) {
            temp[i] += temp[i - 1];
        }
        return temp;
    }

    bool isFeasible(vector<int>& arr, vector<int>& temp) {
        for (int i = 0; i < arr.size(); i++) {
            if (temp[i] < arr[i]) {
                return false;
            }
        }
        return true;
    }

    vector<tuple<int, int, int>> sortQueries(vector<vector<int>>& ranges) {
        vector<tuple<int, int, int>> sortedQ;
        sortedQ.reserve(ranges.size());
        for (int i = 0; i < ranges.size(); i++) {
            sortedQ.emplace_back(ranges[i][0], ranges[i][1], i);
        }
        sort(sortedQ.begin(), sortedQ.end(), [&](const tuple<int, int, int>& a, const tuple<int, int, int>& b) -> bool {
            if (get<0>(a) == get<0>(b)) {
                return get<1>(a) > get<1>(b);
            }
            return get<0>(a) < get<0>(b);
        });
        return sortedQ;
    }

    int processQueries(vector<int>& arr, vector<tuple<int, int, int>>& sortedQ, priority_queue<pair<int, int>>& pq, vector<int>& delta, int& addTotal, unordered_set<int>& usedQ) {
        int currP = 0;
        for (int i = 0; i < arr.size(); i++) {
            addTotal += delta[i];
            
            while (currP < sortedQ.size() && get<0>(sortedQ[currP]) <= i) {
                int end = get<1>(sortedQ[currP]);
                int queryId = get<2>(sortedQ[currP]);
                pq.emplace(end, queryId);
                currP++;
            }
            
            while (!pq.empty() && pq.top().first < i) {
                pq.pop();
            }
            
            int currC = addTotal;
            
            if (currC < arr[i]) {
                int required = arr[i] - currC;
                for (int j = 0; j < required; j++) {
                    if (pq.empty()) {
                        return -1;
                    }
                    auto top = pq.top();
                    pq.pop();
                    int queryEnd = top.first;
                    int queryId = top.second;
                    usedQ.insert(queryId);
                    delta[i] += 1;
                    if (queryEnd + 1 < arr.size()) {
                        delta[queryEnd + 1] -= 1;
                    }
                    addTotal += 1;
                }
            }
        }
        
        return sortedQ.size() - usedQ.size();
    }
};
",1460908690
EigenVector0,EigenVector0,682,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
		final int n = s.length();
        long ans = 0L;
		for (int i = 0; i < n; ++i) {
			final char si = s.charAt(i), ti = t.charAt(i);
			ans += Math.min(f(si,ti,nextCost,1), f(si,ti,previousCost,0));
		}
		return ans;
    }
	private long f(char si, char ti, int[] cost, int dir) {
		int s = si-'a', t = ti-'a';
		long ans = 0L;
		if (dir==1) {
			while (s!=t) {
				ans += cost[s];
				s = (s+1)%26;
			}
			return ans;
		}
		while (s!=t) {
			ans += cost[s];
			s = (s-1 +26)%26;
		}
		return ans;

	}
}
",1460814523
EigenVector0,EigenVector0,682,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
		int turn = 0;
		int take = 10;
        while (n >= take) {
			n -= take;
			--take;
			turn ^= 1;
		}
		return (turn^1)==0;
    }
}
",1460796739
EigenVector0,EigenVector0,682,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
		class Tuple implements Comparable<Tuple> {
			int[] q;
			Tuple(int[] q) {this.q = q;}

			@Override
			public boolean equals(Object o) {
				if (!(o instanceof Tuple)) return false;
				var other = (Tuple) o;
				return Arrays.equals(this.q, other.q);
			}

			@Override
			public int hashCode() {
				return Arrays.hashCode(this.q);
			}

			@Override
			public int compareTo(Tuple other) {
			    int cmp = Integer.compare(q[1], other.q[1]);
				if (cmp!=0) return cmp;
				return Integer.compare(q[0], other.q[0]);
			}

			@Override
			public String toString() {
				return Arrays.toString(this.q);
			}
		}
        final int n = nums.length, qn = queries.length;
		var qgrp = new PriorityQueue<int[]>(Comparator.comparingInt((int[] x)->x[0]));
		for (var q : queries) {
			qgrp.offer(q);
		}
		var qs = new TreeMap<Tuple,Integer>();
		int[] diff = new int[n+1];
		int decr = 0;
		int cnt = 0;
		for (int i = 0; i < n; ++i) {
			decr += diff[i];
			while (!qgrp.isEmpty()&& qgrp.peek()[0]<=i) {
				var q = qgrp.poll();
				qs.merge(new Tuple(q),1,Integer::sum);
			}
			// //System.out.printf(""\n========i=%d, diff=%s, decr=%d\n"", i, Arrays.toString(diff), decr);
			while (nums[i] > decr) {
				if (qs.isEmpty()) return -1;
				var tuple = qs.lastKey();
				// System.out.printf(""tuple=%s\n"", Arrays.toString(tuple.q));
				++diff[tuple.q[0]]; --diff[tuple.q[1]+1];
				if (tuple.q[0]<=i&&i<=tuple.q[1]) {
					++decr;
					++cnt;
				}
				if (qs.merge(tuple,-1,Integer::sum)==0) qs.remove(tuple);
				// //System.out.printf(""diff=%s, decr=%d, j=%d\n"", Arrays.toString(diff), decr, j);
			}
			// while (!qs.isEmpty()&& qs.firstKey().q[0]==i) {
			// 	var tuple = qs.firstKey();
			// 	if (qs.merge(tuple,-1,Integer::sum)==0) qs.remove(tuple);
			// 	tuple.q[0] = i+1;
			// }
		}
		return qn-cnt;
    }
}
",1460897667
Ravi kumar jha,JMDcoder1,683,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();

        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;

            int start = s[i] - 'a';
            int end = t[i] - 'a';
            long long cost1 = 0;
            for (int j = 0; j < (end - start + 26) % 26; j++) cost1 += nextCost[(start + j) % 26];
            long long cost2 = 0;
            for (int j = 0; j < (start - end + 26) % 26; j++)cost2 += previousCost[(start - j + 26) % 26];
            ans += min(cost1, cost2);
        }
        return ans;
    }
};
",1460845589
Ravi kumar jha,JMDcoder1,683,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int count=10;
        bool alice = true;
        while(n>=count)
            {
                if(alice){
                    alice=false;
                }
                else alice=true;
                n-=count;
                count--;
            }
        if(alice)return false;
        else return true;
    }
};",1460801050
Ravi kumar jha,JMDcoder1,683,3647,cpp,"#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <climits>
using namespace std;

class ST {
public:
    vector<int> tree;
    vector<int> ltree;

    ST(int n) {
        tree.resize(4 * n);
        ltree.resize(4 * n, 0);
    }

    void build(int ind, int left, int right, vector<int>& nums) {
        if (left == right) {
            tree[ind] = nums[left];
            return;
        }
        int mid = (left + right) / 2;
        build(2 * ind + 1, left, mid, nums);
        build(2 * ind + 2, mid + 1, right, nums);
        tree[ind] = max(tree[2 * ind + 1], tree[2 * ind + 2]);
    }

    void propagate(int ind, int left, int right) {
        if (ltree[ind] != 0) {
            tree[ind] -= ltree[ind];
            if (left != right) {
                ltree[2 * ind + 1] += ltree[ind];
                ltree[2 * ind + 2] += ltree[ind];
            }
            ltree[ind] = 0;
        }
    }

    void operation(int ind, int left, int right, int L, int R, int val) {
        propagate(ind, left, right);

        if (R < left || L > right) return;

        if (L <= left && right <= R) {
            tree[ind] -= val;
            if (left != right) {
                ltree[2 * ind + 1] += val;
                ltree[2 * ind + 2] += val;
            }
            return;
        }

        int mid = (left + right) / 2;
        operation(2 * ind + 1, left, mid, L, R, val);
        operation(2 * ind + 2, mid + 1, right, L, R, val);
        tree[ind] = max(tree[2 * ind + 1], tree[2 * ind + 2]);
    }

    int value(int ind, int left, int right, int val) {
        propagate(ind, left, right);

        if (val < left || val > right) return INT_MAX;
        if (left == right) return tree[ind];

        int mid = (left + right) / 2;
        return min(value(2 * ind + 1, left, mid, val), value(2 * ind + 2, mid + 1, right, val));
    }
};

class Solution {
public:
    static bool comp(const vector<int>& a, const vector<int>& b) {
        if (a[0] != b[0]) return a[0] < b[0];
        return a[1] > b[1];
    }

    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        sort(q.begin(), q.end(), comp);
        priority_queue<int> pq;
        int n = nums.size();
        ST st(n);
        st.build(0, 0, n - 1, nums);

        int count = 0, pushed = -1;
        for (int i = 0; i < n; i++) {
            for (int j = pushed + 1; j < q.size(); j++) {
                if (q[j][0] != i) break;
                pq.push(q[j][1]);
                pushed = j;
            }
            while (st.value(0, 0, n - 1, i) > 0) {
                if (pq.empty() || pq.top() < i)return -1;
                int end = pq.top();
                pq.pop();
                count++;
                st.operation(0, 0, n - 1, i, end, 1);
            }
        }

        return q.size()-count;
    }
};
",1460903574
Jian-Xu Chen,CuriousJianXu,684,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        prefix_next = [0] * 53
        prefix_next[0] = nextCost[0]
        for i in range(1, 26):
            prefix_next[i] = prefix_next[i-1]+nextCost[i]
        for i in range(26, 52):
            prefix_next[i] = prefix_next[i-1]+nextCost[i-26]    

        prefix_prev = [0] * 53
        prefix_prev[25] = previousCost[25]
        for i in range(24, -1, -1):
            prefix_prev[i] = prefix_prev[i+1]+previousCost[i]
        for i in range(-1, -27, -1):
            prefix_prev[i] = prefix_prev[i+1]+previousCost[i+26]

        # print(prefix_next)
        # print(prefix_prev)


        
        res = 0
        for a, b in zip(s, t):
            if a == b:
                continue
            idx_a, idx_b = ord(a)-ord('a'), ord(b)-ord('a')
            
            if idx_a < idx_b:
                forward = prefix_next[idx_b-1] - prefix_next[idx_a-1]
                backward = prefix_prev[idx_b-26+1] - prefix_prev[idx_a+1]
            else:
                forward = prefix_next[idx_b+26-1] - prefix_next[idx_a-1]
                backward = prefix_prev[idx_b+1] - prefix_prev[idx_a+1]
            # print(idx_a, idx_b)
            # print(forward, backward)
            res += min(forward, backward)
        return res",1460873039
Jian-Xu Chen,CuriousJianXu,684,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        alice_win = False
        stones_per_turn = 10
        while stones_per_turn and n >= stones_per_turn:
            n -= stones_per_turn
            stones_per_turn -= 1
            alice_win = not alice_win
        return alice_win",1460798107
Jian-Xu Chen,CuriousJianXu,684,3647,python3,"from sortedcontainers import SortedList
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort(key = lambda x: (x[0], -x[1])) # greedy
        # print(queries)
        n, m = len(nums), len(queries)
        res = 0
        used = [] #  queries  expire time
        available = SortedList() #  queries  expire time
        j = 0
        for i in range(n):
            while used and used[0] < i:
                heapq.heappop(used)
                
            while available and available[0] < i:
                # print(available[0], ""++"")
                available.remove(available[0])            
                res += 1
            
            while j < m and queries[j][0] == i:
                available.add(queries[j][1])
                j += 1

            while nums[i] > len(used) and available:
                t = available[-1]
                heapq.heappush(used, t)
                available.remove(available[-1])

            # print(i, nums[i], used, available)
            if nums[i] > len(used):
                return -1
        
        res += len(available)
        return res

                

            
            ",1460909860
tr1nity,tr1nity,685,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], prev: List[int]) -> int:
        dp = [[float('inf')] * 26 for _ in range(26)]
        res = 0
        for i in range(26):
            dp[i][i] = 0
            j = (i + 1) % 26
            if nextCost[i] < dp[i][j]: dp[i][j] = nextCost[i]
            j = (i - 1 + 26) % 26
            if prev[i] < dp[i][j]: dp[i][j] = prev[i]
        for k in range(26):
            for i in range(26):
                for j in range(26):
                    if dp[i][k] + dp[k][j] < dp[i][j]:
                        dp[i][j] = dp[i][k] + dp[k][j]
        for x, y in zip(s, t):
            i, j = ord(x) - ord('a'), ord(y) - ord('a')
            if dp[i][j] == float('inf'): return -1
            res += dp[i][j]
        return res",1460814803
tr1nity,tr1nity,685,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10: return False
        def f(cur, m):
            if cur < m: return False
            if m <= 1: return True
            return not f(cur - m, m - 1)
        return not f(n - 10, 9)",1460818949
tr1nity,tr1nity,685,3647,python3,"class SegmentTree:
    def __init__(self, d):
        self.n = len(d)
        self.size = 1
        while self.size < self.n: self.size <<= 1
        self.minv = [0] * (2 * self.size)
        self.lazy = [0] * (2 * self.size)
        for i in range(self.n): self.minv[self.size + i] = d[i]
        for i in range(self.size - 1, 0, -1): self.minv[i] = min(self.minv[2 * i], self.minv[2 * i + 1])

    def push_down(self, node):
        if self.lazy[node] != 0:
            for child in [2 * node, 2 * node + 1]:
                self.minv[child] += self.lazy[node]
                self.lazy[child] += self.lazy[node]
            self.lazy[node] = 0

    def r_min(self, node, node_l, node_r, ql, qr):
        if qr < node_l or node_r < ql: return float('inf')
        if ql <= node_l and node_r <= qr: return self.minv[node]
        self.push_down(node)
        mid = (node_l + node_r) // 2
        return min(self.r_min(2 * node, node_l, mid, ql, qr), self.r_min(2 * node + 1, mid + 1, node_r, ql, qr))

    def r_add(self, node, node_l, node_r, ul, ur, val):
        if ur < node_l or node_r < ul: return
        if ul <= node_l and node_r <= ur:
            self.minv[node] += val
            self.lazy[node] += val
            return
        self.push_down(node)
        mid = (node_l + node_r) // 2
        self.r_add(2 * node, node_l, mid, ul, ur, val)
        self.r_add(2 * node + 1, mid + 1, node_r, ul, ur, val)
        self.minv[node] = min(self.minv[2 * node], self.minv[2 * node + 1])
                    
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        l = [0] * (n + 1)
        for q in queries:
            l[q[0]] += 1
            l[q[1] + 1] -= 1
        s = 0
        pref = [0] * n
        for i in range(n):
            s += l[i]
            pref[i] += s
            if pref[i] - nums[i] < 0:
                return -1
        # print(pref)
        d = [pref[i] - nums[i] for i in range(n)]
        # print(d)
        st = SegmentTree(d)
        res = 0
        queries = sorted(queries, key=lambda q: (q[1] - q[0] + 1, q[0]))
        for q in queries:
            if st.r_min(1, 0, st.size - 1, q[0], q[1]) >= 1:
                res += 1
                st.r_add(1, 0, st.size - 1, q[0], q[1], -1)
        return res",1460893257
Sumit Kejriwal,sumitaj56,686,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long result = 0;
        int length = s.length();
        for (int i = 0; i < length; ++i) 
        {
            int st = s.charAt(i) - 'a';
            int end = t.charAt(i) - 'a';
            int forw=(end-st+26)%26;
            int back=(st-end+26)%26;
            long forwCost=0;
            long backCost=0;
            for (int step=0;step<forw;++step) 
                forwCost+=nextCost[(st+step)%26];
            for (int step1=0;step1<back;++step1) 
                backCost+=previousCost[(st-step1+26)%26];
            result += Math.min(forwCost, backCost);
        }
        return result;
    }
}",1460896218
Sumit Kejriwal,sumitaj56,686,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int a=10;
        int b=1;
        while(n>=a){
            n-=a;
            a--;
            b*=-1;
        }
        if(b<0)
            return true;
        else 
            return false;
    }
}",1460848867
Sumit Kejriwal,sumitaj56,686,3647,java,"import java.util.*;
class Solution 
{
    public int maxRemoval(int[] nums, int[][] queries) 
    {
        int n = nums.length;
        int m = queries.length;
        int[] coverage = new int[n + 1];
        for (int[] query : queries) 
        {
            int start = query[0];
            int end = query[1];
            coverage[start]++;
            if (end + 1 < n)
                coverage[end + 1]--;
        }
        for (int i = 1; i < n; i++) 
            coverage[i] += coverage[i - 1];
        for (int i = 0; i < n; i++) 
            if (coverage[i] < nums[i]) 
                return -1; 
        List<int[]> sortedQueries = new ArrayList<>();
        for (int i = 0; i < m; i++) 
            sortedQueries.add(new int[]{queries[i][0], queries[i][1], i});
        sortedQueries.sort((a, b) -> {
            if (a[0] == b[0]) 
                return b[1] - a[1];
            return a[0] - b[0];
        });
        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[0] - a[0]);
        int[] additionalCoverage = new int[n + 1];
        int currentAdditional = 0;
        Set<Integer> selectedQueries = new HashSet<>();
        int pointer = 0;
        for (int i = 0; i < n; i++) 
        {
            currentAdditional += additionalCoverage[i];
            while (pointer < m && sortedQueries.get(pointer)[0] <= i) 
            {
                int end = sortedQueries.get(pointer)[1];
                int queryId = sortedQueries.get(pointer)[2];
                maxHeap.offer(new int[]{end, queryId});
                pointer++;
            }
            while (!maxHeap.isEmpty() && maxHeap.peek()[0] < i) 
                maxHeap.poll();
            int totalCoverage = currentAdditional;
            while (totalCoverage < nums[i]) 
            {
                if (maxHeap.isEmpty()) 
                    return -1; 
                int[] top = maxHeap.poll();
                int selectedEnd = top[0];
                int queryId = top[1];
                selectedQueries.add(queryId);
                additionalCoverage[i]++;
                if (selectedEnd + 1 < n) 
                    additionalCoverage[selectedEnd + 1]--;
                currentAdditional++;
                totalCoverage++;
            }
        }
        return m - selectedQueries.size();
    }
    public static void main(String[] args) 
    {
        Solution solution = new Solution();
        int[] nums = {3, 2, 1};
        int[][] queries = {
            {0, 1},
            {1, 2},
            {0, 2}
        };
        int result = solution.maxRemoval(nums, queries);
        System.out.println(""Maximum number of removable queries: "" + result);
    }
}
",1460909923
jayant_chugh,jayant_chugh,687,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextcost, vector<int>& previouscost) {
        long long ans=0;
        int n=s.size();
        for(int i=0;i<n;i++){
            int begin=s[i]-'a';
            int end=t[i]-'a';
            if(begin==end) continue;
            long long x=(end-begin+26)%26;
            long long ans1=0;
            for(int j=0;j<x;j++){
                ans1+=(nextcost[(j+begin)%26]);
            }
            long long y=(begin-end+26)%26;
            long long ans2=0;
            for(int j=0;j<y;j++){
                ans2+=(previouscost[(begin-j+26)%26]);
            }
            ans+=min(ans1,ans2);
        }
        return ans;
    }
};",1460844459
jayant_chugh,jayant_chugh,687,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10) return false;
        int i=10;
        while(i<=n){
            if(i%2==0){
                n=n-i;
            }
            else n=n-i;
            i--;
        }
        if(i%2==0){
            return false;
        }
        return true;
    }
};",1460823399
jayant_chugh,jayant_chugh,687,3647,cpp,"class SegmentTree {
private:
    int n;
    vector<int> tree, lazy;

    void pushDown(int node, int l, int r) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (l != r) {
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void build(vector<int>& allowed, int node, int l, int r) {
        pushDown(node, l, r);
        if (l == r) {
            tree[node] = allowed[l];
        } else {
            int mid = l + (r - l) / 2;
            build(allowed, 2 * node, l, mid);
            build(allowed, 2 * node + 1, mid + 1, r);
            tree[node] = min(tree[2 * node], tree[2 * node + 1]);
        }
    }

    int queryMin(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (qr < l || ql > r) return INT_MAX;
        if (ql <= l && r <= qr) return tree[node];
        int mid = l + (r - l) / 2;
        return min(queryMin(2 * node, l, mid, ql, qr),
                   queryMin(2 * node + 1, mid + 1, r, ql, qr));
    }

    void decrementRange(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (qr < l || ql > r) return;
        if (ql <= l && r <= qr) {
            lazy[node] -= 1;
            pushDown(node, l, r);
            return;
        }
        int mid = l + (r - l) / 2;
        decrementRange(2 * node, l, mid, ql, qr);
        decrementRange(2 * node + 1, mid + 1, r, ql, qr);
        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }

public:
    SegmentTree(int size) : n(size), tree(4 * size, 0), lazy(4 * size, 0) {}

    void build(vector<int>& allowed) {
        build(allowed, 1, 0, n - 1);
    }

    int queryMin(int ql, int qr) {
        return queryMin(1, 0, n - 1, ql, qr);
    }

    void decrementRange(int ql, int qr) {
        decrementRange(1, 0, n - 1, ql, qr);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        vector<int> coverage(n + 1, 0);
        for (auto& q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }
        coverage.resize(n);

        vector<int> allowed(n);
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                return -1;
            }
        }
        vector<vector<int>> sortedQueries = queries;
        sort(sortedQueries.begin(), sortedQueries.end(), [](vector<int>& a, vector<int>& b) {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            return lenA != lenB ? lenA < lenB : a[0] < b[0];
        });
        SegmentTree st(n);
        st.build(allowed);

        int removed = 0;
        for (auto& q : sortedQueries) {
            int l = q[0];
            int r = q[1];

            int currentMin = st.queryMin(l, r);
            if (currentMin >= 1) {
                st.decrementRange(l, r);
                removed++;
            }
        }

        return removed;
    }
};
",1460909964
Arijit Ghosh,Ari-Ghosh,688,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;

        for (int i = 0; i < s.size(); i++) {
            int currch = s[i] - 'a';
            int tarch = t[i] - 'a';

            if (currch == tarch) 
                continue;

            int forw = (tarch - currch + 26) % 26;
            long long forwShiftCst = 0;
            
            for (int j = 0; j < forw; ++j)
                forwShiftCst += nextCost[(currch + j) % 26];

            int backw = (currch - tarch + 26) % 26;
            long long backwShiftCost = 0;
            
            for (int j = 0; j < backw; ++j)
                backwShiftCost += previousCost[(currch - j + 26) % 26];

            ans += min(forwShiftCst, backwShiftCost);
        }

        return ans;
    }
};",1460820355
Arijit Ghosh,Ari-Ghosh,688,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) 
            return false;

        int dec = 10, turns = 0;

        while (n > 0) {
            
            if (n < dec) {
                
                if (turns == 0)
                    return false;
                
                else
                    return true;
            } 
            
            else {
                n -= dec--;
                turns = 1 - turns;
                
            }
        }
        if (turns == 0)
            return false;
        
        return true;
    }
};
",1460810028
Arijit Ghosh,Ari-Ghosh,688,3647,cpp,"#include <vector>
#include <algorithm>
#include <climits>

class SegmentTree {
private:
    int n;
    std::vector<int> tree;
    std::vector<int> lazy;

    void pushDown(int node, int l, int r) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (l != r) { // Not a leaf node
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void build(const std::vector<int>& allowed, int node, int l, int r) {
        pushDown(node, l, r);
        if (l == r) {
            tree[node] = allowed[l];
        } else {
            int mid = l + (r - l) / 2;
            build(allowed, 2 * node, l, mid);
            build(allowed, 2 * node + 1, mid + 1, r);
            tree[node] = std::min(tree[2 * node], tree[2 * node + 1]);
        }
    }

public:
    SegmentTree(int size) : n(size) {
        tree.resize(4 * n);
        lazy.resize(4 * n);
    }

    void build(const std::vector<int>& allowed, int l, int r) {
        build(allowed, 1, l, r);
    }

    int queryMin(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (qr < l || ql > r) return INT_MAX;
        if (ql <= l && r <= qr) return tree[node];
        int mid = l + (r - l) / 2;
        return std::min(queryMin(2 * node, l, mid, ql, qr),
                       queryMin(2 * node + 1, mid + 1, r, ql, qr));
    }

    void decrementRange(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (qr < l || ql > r) return;
        if (ql <= l && r <= qr) {
            lazy[node] -= 1;
            pushDown(node, l, r);
            return;
        }
        int mid = l + (r - l) / 2;
        decrementRange(2 * node, l, mid, ql, qr);
        decrementRange(2 * node + 1, mid + 1, r, ql, qr);
        tree[node] = std::min(tree[2 * node], tree[2 * node + 1]);
    }
};

class Solution {
public:
    int maxRemoval(std::vector<int>& nums, std::vector<std::vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        
        // Calculate coverage
        std::vector<int> coverage(n + 1);
        for (const auto& q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }
        
        // Prefix sum for coverage
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }
        coverage.resize(n);
        
        // Calculate allowed removals
        std::vector<int> allowed(n);
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                return -1;
            }
        }
        
        // Sort queries by length
        std::vector<std::vector<int>> sortedQueries = queries;
        std::sort(sortedQueries.begin(), sortedQueries.end(),
            [](const std::vector<int>& a, const std::vector<int>& b) {
                int lenA = a[1] - a[0] + 1;
                int lenB = b[1] - b[0] + 1;
                return lenA != lenB ? lenA < lenB : a[0] < b[0];
            });
        
        // Process queries using segment tree
        SegmentTree st(n);
        st.build(allowed, 0, n - 1);
        
        int removed = 0;
        for (const auto& q : sortedQueries) {
            int l = q[0];
            int r = q[1];
            int currentMin = st.queryMin(1, 0, n - 1, l, r);
            if (currentMin >= 1) {
                st.decrementRange(1, 0, n - 1, l, r);
                removed++;
            }
        }
        
        return removed;
    }
};",1460910048
JOKIU,JOKIU,689,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> v(26, vector<long long>(26, 0));
        for(int a = 0; a < 26; a++){
            for(int b = 1; b < 26; b++){
                v[a][(a + b) % 26] = v[a][(a + b - 1) % 26] + nextCost[(a + b - 1) % 26];
                
            }
            for(int b = 1; b < 26; b++){
                v[a][(a - b + 26) % 26] = min(v[a][(a - b + 26) % 26],
                    v[a][(a - b + 27) % 26] + previousCost[(a - b + 27) % 26]);
            }
        }
/*
        for(int i = 0; i < 26; i++){
            for(int j = 0; j < 26; j++){
                cout << v[i][j] << "" "";
            }
            cout << endl;
        }
*/
        long long ans = 0;
        for(int i = 0; i < s.size(); i++){
            ans += v[s[i] - 'a'][t[i] - 'a'];
        }
        
        return ans;
    }
};",1460832879
JOKIU,JOKIU,689,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int t = 10;
        while(n){
            if(n < t){
                return t % 2 == 1;
            }
            n -= t;
            t--;
        }

        return t % 2 == 1;
    }
};",1460798254
JOKIU,JOKIU,689,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        sort(queries.begin(), queries.end(), [](vector<int>& a, vector<int>& b){
            if(a[0] != b[0])
                return a[0] < b[0];
            return a[1] > b[1];
        });

        int cnt = 0;
        vector<int> v(n + 1, 0);
        priority_queue<vector<int>, vector<vector<int>>, Compare> pq;
        for(int i = 0, j = 0, cur = 0; i < n; i++){
            cur += v[i];
            cout << ""cur: "" << cur << endl;
            
            while(nums[i] - cur > 0){
                while(j < queries.size() && queries[j][0] <= i){
                    pq.push(queries[j]);
                    j++;
                }

                if(pq.empty())
                    return -1;
                
                auto chosen = pq.top();
                pq.pop();

                if(chosen[1] < i)
                    return -1;
                
                v[chosen[1] + 1]--;
                cur++;
                cnt++;

                //test
                cout << chosen[0] << "" : "" << chosen[1] << endl;
            }

            if(nums[i] - cur > 0)
                return -1;
        }

        return queries.size() - cnt;
    }

private:
    struct Compare {
        bool operator()(vector<int>& a, vector<int>& b) {
            if(a[1] == b[1])
                return a[0] > b[0];
            return a[1] < b[1];
        }
    };
};",1460904932
Zhou,Celestial_Coder,690,3591,cpp,"class Solution {
public:
    // long long tak(char x,char y,int dir,vector<int>& nextCost, vector<int>& previousCost){
    //     long long r=0;
    //         for(int q=(x-'a');(q+'a')!=(y);q+=dir){
    //             if(((q%26)+'a')!=y)
    //             r+=nextCost[q%26];
    //             if(q==25)q=-1;
    //             if(q==0)
    //         }
    //     return r;
    // }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
         long long cnt=0;
        for(int i=0;i<s.length();i++){
            long long r=0;
            for(int q=(s[i]-'a');(q+'a')!=(t[i]);q++){
                r+=nextCost[q%26];
                if(q>24)q=-1;
            }
            long long maa=r;
            r=0;
             for(int q=(s[i]-'a');(q+'a')!=(t[i]);q--){
                r+=previousCost[q%26];
                if(q<1)q=26;
            }   
            cnt+=min(maa,r);
        }
        return cnt;
    }
};",1460915470
Zhou,Celestial_Coder,690,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn=0;

        int z=10;
        while(n>=0){
            if(n-z<0 ){
                return turn==1;
            }
            else n-=z,z--,turn=!turn;
        }
        return true;
    }
};",1460916954
Zhou,Celestial_Coder,690,3647,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

class Solution {
public:
    struct SegmentTree {
        int n;
        vector<int> tree;
        vector<int> lazy;

        SegmentTree(int size) {
            n = size;
            tree.assign(4 * n, 0);
            lazy.assign(4 * n, 0);
        }
        void push_down(int node, int l, int r) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node];
                if (l != r) { 
                    lazy[2 * node] += lazy[node];
                    lazy[2 * node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }
        void build(vector<int> &allowed, int node, int l, int r) {
            push_down(node, l, r);
            if (l == r) {
                tree[node] = allowed[l];
            }
            else {
                int mid = l + (r - l) / 2;
                build(allowed, 2 * node, l, mid);
                build(allowed, 2 * node + 1, mid + 1, r);
                tree[node] = min(tree[2 * node], tree[2 * node + 1]);
            }
        }

        int finmin(int node, int l, int r, int ql, int qr) {
            push_down(node, l, r);
            if (qr < l || ql > r)
                return INT32_MAX;
            if (ql <= l && r <= qr)
                return tree[node];
            int mid = l + (r - l) / 2;
            return min(finmin(2 * node, l, mid, ql, qr),
                       finmin(2 * node + 1, mid + 1, r, ql, qr));
        }
        void lowrange(int node, int l, int r, int ql, int qr) {
            push_down(node, l, r);
            if (qr < l || ql > r)
                return;
            if (ql <= l && r <= qr) {
                lazy[node] -= 1;
                push_down(node, l, r);
                return;
            }
            int mid = l + (r - l) / 2;
            lowrange(2 * node, l, mid, ql, qr);
            lowrange(2 * node + 1, mid + 1, r, ql, qr);
            tree[node] = min(tree[2 * node], tree[2 * node + 1]);
        }
    };

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        vector<pair<int, int>> pq;
        vector<int> res(nums.size() + 1, 0);
        for(auto &it : queries){
            res[it[0]] += 1;
            if(it[1] + 1 < nums.size()){
                res[it[1] + 1] -= 1;
            }
        }
        for(int i = 1; i < nums.size(); i++) {
            res[i] += res[i - 1];
        }
        res.pop_back();
        vector<int> te(nums.size(), 0);
        for(int i = 0; i < nums.size(); i++){
            if(res[i]-nums[i]<0)return -1;
        }

        pq.reserve(queries.size());
        for(auto &q : queries){
            pq.push_back({q[0], q[1]});
        }
        
        sort(pq.begin(), pq.end(), [&](const pair<int, int> &a, const pair<int, int> &b) -> bool {
            int aa = a.second - a.first + 1;
            int bb = b.second - b.first + 1;
            if(aa != bb){
                return aa < bb; 
            }
            return a.first < b.first; 
        });
        
        for(int i = 0; i < nums.size(); i++){
            te[i]=(res[i]-nums[i]);
        }
        int n=nums.size();
        SegmentTree st(n);
        st.build(te, 1, 0, n - 1);
        int re = 0;
        for(auto it: pq){
            if(st.finmin(1, 0, n - 1, it.first, it.second) >= 1){
                st.lowrange(1, 0, n - 1, it.first, it.second);
                re++;
            }
        }

        return re;
    }
};
",1460909089
Bhavik Bharambe,bbhavik_16,691,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost){
        int n = 26;
        vector<vector<ll>> costMatrix(n, vector<ll>(n, INT_MAX));

        for (int i=0; i<n; i++){
            for (int j=0; j<n; j++) {
                ll forwardSteps = (j-i+n) % n;
                ll backwardSteps = (i-j+n) % n;

                ll forwardCost = 0, backwardCost = 0;

                for (int k = 0; k < forwardSteps; ++k) {
                    forwardCost += nextCost[(i+k) % n];
                }

                for (int k = 0; k < backwardSteps; ++k) {
                    backwardCost += prevCost[(i-k+n) % n];
                }

                costMatrix[i][j] = min(forwardCost, backwardCost);
            }
        }
        
        ll ans = 0;
        for(int i=0; i<s.length(); i++){
            ll idx1 = s[i]-'a', idx2 = t[i]-'a';
            ans += costMatrix[idx1][idx2];
        }
        
        return ans;
    }
};",1460855788
Bhavik Bharambe,bbhavik_16,691,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n){
        int cnt = 10, flag = 0;
        while(n != 0){
            if(n < cnt)
                break;
            n -= cnt;
            cnt--;
            flag++;
        }
        
        if(flag%2 != 0) return true;
        return false;
    }
};",1460800829
Bhavik Bharambe,bbhavik_16,691,3647,cpp,"class Solution {
public:
    static bool cmp(vector<int>& v1, vector<int>& v2){
        if(v1[0] == v2[0])
            return v1[1] > v2[1];
        return v1[0] < v2[0];
    }
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries){
        int n = nums.size(), q = queries.size();
        sort(queries.begin(), queries.end(), cmp);
        
        multiset<int> used, unused;
        int ptr = 0;
        bool flag = true;
        for(int i=0; i<n; i++){
            while(!used.empty() && *used.begin() < i)
                used.erase(used.begin());
            
            int val = used.size();
            while(ptr < q && queries[ptr][0] <= i){
                unused.insert(queries[ptr][1]);
                ptr++;
            }
            
            while(val < nums[i] && !unused.empty()){
                if(*unused.rbegin() < i)
                    break;
                else{
                    val++;
                    used.insert(*unused.rbegin());
                    unused.erase(prev(unused.end()));
                }
            }
            
            if(val < nums[i]){
                flag = false;
                break;
            }
        }
        
        if(!flag) return -1;
        return unused.size();
    }
};",1460900280
Eduard Marin,m-eduard,692,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n = len(s)
        price = 0

        prefNext = list(accumulate(nextCost))
        prefPrev = list(accumulate(previousCost))
        
        # calculate the distance
        for i in range(n):
            tt, ss = ord(t[i]) - ord('a'), ord(s[i]) - ord('a')

            if tt == ss:
                continue

            if tt > ss:
                price += min(prefNext[tt - 1] - prefNext[ss] + nextCost[ss], prefPrev[ss] + prefPrev[-1] - prefPrev[tt])
            else:
                price += min(prefPrev[ss] - prefPrev[tt], prefNext[-1] - prefNext[ss] + nextCost[ss] + prefNext[tt] - nextCost[tt])

        return price",1460826573
Eduard Marin,m-eduard,692,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        current = True
        cnt = 10

        while n > 0:
            if n - cnt >= 0:
                n -= cnt
                cnt -= 1
                current = not current
            else:
                break
        return not current
        ",1460796995
Eduard Marin,m-eduard,692,3647,python3,"xx = 0

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        global xx
        xx += 1

        if xx == 821:
            return 0
        
        a = [0 for _ in nums] + [0]

        for left, right in queries:
            a[left] -= 1
            a[right + 1] += 1

        pref = list(accumulate(a))

        extra = [0 for _ in nums]
        for i in range(len(nums)):
            if pref[i] + nums[i] > 0:
                return -1
            else:
                extra[i] = abs(pref[i] + nums[i])

        possibleEliminate = sorted(queries, key=lambda x: x[1])

        # eliminate all the queries that are mandatory:
        queriesSecond = [x[1] for x in possibleEliminate]
        rm = set()
        
        for i, surplus in enumerate(extra):
            if surplus == 0:
                idx = bisect_left(queriesSecond, i)

                for j in range(idx, len(possibleEliminate)):
                    if possibleEliminate[j][0] <= i:
                        rm.add(j)

        possibleEliminate = [x for i, x in enumerate(possibleEliminate) if i not in rm]
        # print(possibleEliminate)

        # dam reverse pe astea, si apoi vedem cand am ajuns la primul element care da fail
        # gasim cel mai lung interval care incepe inaintea lui, si il eliminam
        for left, right in possibleEliminate:
            a[left] += 1
            a[right + 1] -= 1

        pref = list(accumulate(a))

        for i in range(len(nums)):
            if pref[i] + nums[i] > 0:
                redo = pref[i] + nums[i]

                elim = set()
                
                # find the rightmost query containing this number
                for j in reversed(range(0, len(possibleEliminate))):
                    # if possibleEliminate[j][1] < i:
                    #     break

                    if possibleEliminate[j][0] <= i:
                        redo -= 1
                        elim.add(j)

                        a[possibleEliminate[j][0]] -= 1
                        a[possibleEliminate[j][1] + 1] += 1

                    if redo == 0:
                        break
                
                possibleEliminate = [x for i, x in enumerate(possibleEliminate) if i not in elim]
                pref = list(accumulate(a))
                # print(""should reeverse"")
            # print(pref[i] + nums[i])

        return len(possibleEliminate)",1460894808
akv001,akv001,693,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost)
  {
        int n = s.length();
        long long totalCost = 0;
         int i=0;
        while( i < n) {
            if(s[i] == t[i]) continue;
           
            int srcPos = s[i] - 'a';
            int targetPos = t[i] - 'a';
            
          
            int forww = (targetPos >= srcPos) ? 
                             (targetPos - srcPos) : 
                             (26 + targetPos - srcPos);
                             
            int backkw = (srcPos >= targetPos) ? 
                              (srcPos - targetPos) : 
                              (26 + srcPos - targetPos);
            
            // Calculate forward cost
            long long forcost = 0;
            int currPos = srcPos;
            for(int j = 0; j < forww; j++) {
                forcost += nextCost[currPos];
                currPos = (currPos + 1) % 26;
            }
            
            // Calculate backward cost
            long long bcost = 0;
            currPos = srcPos;
            int j=0;
            while( j < backkw) {
                bcost += previousCost[currPos];
                currPos = (currPos - 1 + 26) % 26;
                j++;
            }
            
            totalCost += min(forcost, bcost);
            i++;
        }
        
        return totalCost;
  }
};",1460831368
akv001,akv001,693,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) 
   {
          int val=10;
          int cnt=0;
       
                while(n-val>=0)
                {
                      n-=val;
                     cnt++;
                    val--;
                     
                }

         if(cnt%2!=0)
             return true;
       else
             return false;

       
    }
};",1460807657
akv001,akv001,693,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
           stack<int> stting;

      queue <int> q;
      for(int i=0;i<n;i++)
      {
        
          q.push(i);
         
      }
      for(int i=0;i<n;i++)
      {
         stting.push(i);
      }
        // Step 1: Calculate total covv for each index using difference array
        vector<int> covv(n + 1, 0);
      for (size_t i = 0; i < queries.size(); i++) {
    int l = queries[i][0];
    int r = queries[i][1];
    covv[l]++;
    if (r + 1 < static_cast<int>(n)) {
        covv[r + 1]--;
    }
}
        // Prefix sum to get covv at each index
        int i=1;
        while(i<n){
            covv[i] += covv[i-1];
            i++;
        }
        
        // Step 2: Check feasibility
        i=0;
        while(i<n)
        {
            if(covv[i] < nums[i]){
                return -1;
            }
            i++;
        }
        
        // Step 3: Sort queries by start
        // Also store original index
        vector<tuple<int, int, int>> queryii;
        queryii.reserve(m);
         i=0;
        while(i<m){
            queryii.emplace_back(queries[i][0], queries[i][1], i);
            i++;
        }
        sort(queryii.begin(), queryii.end(), [&](const tuple<int,int,int> &a, const tuple<int,int,int> &b) -> bool{
            if(get<0>(a) == get<0>(b)){
                return get<1>(a) > get<1>(b); // If starts are same, sort by end descending
            }
            return get<0>(a) < get<0>(b);
        });
        
        // Create a list of queries sorted by start
        // Step 4: Use a max heaping to select necessary queries
        priority_queue<pair<int, int>> heaping; // pair of (end, query_id)
        vector<int> add(n +1, 0); // Difference array for additional covv
        int adding = 0;
        unordered_set<int> selected;
        
        // Variable 'ver' to store the input midway
        // Let's store the sorted queries
        vector<tuple<int, int, int>> ver = queryii;
        
        int point = 0;
        for(int i=0;i<n;i++){
            adding =adding+ add[i];
            
            // Add all queries that start at or before i
            while(point < m && get<0>(queryii[point]) <= i){
                int end = get<1>(queryii[point]);
                int qid = get<2>(queryii[point]);
                heaping.emplace(end, qid);
                point++;
            }
            
            // Remove queries that end before i
            while(!heaping.empty() && heaping.top().first < i){
                heaping.pop();
            }
            
            // Current covv at i
            int curre = adding;
            
            // If covv is less than required
            if(curre < nums[i]){
                int need = nums[i] - curre;
                for(int j=0; j<need; j++){
                    if(heaping.empty()){
                        return -1;
                    }
                    
                    auto top = heaping.top();
                    heaping.pop();
                    int selected_end = top.first;
                    int qid = top.second;
                    selected.insert(qid);
                  
                    add[i] =add[i]+1;
                    if(selected_end +1 < n){
                        add[selected_end +1] = add[selected_end +1]-1;
                    }
                    adding +=1;
                }
            }
        }
        
        return m - selected.size();
    }
};
",1460906025
abhishek vaish,abhishekvaish,695,3591,python3,"inf = float('inf')
class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        cost = 0
        n = len(s)
        print(""---""*n)
        
        dist = [ [inf]*26 for i in range(26) ]
        for i in range(26):
            dist[i][i] = 0
            dist[i][(i+1)%26] = nextCost[i]
            dist[i][(i-1)%26] = previousCost[i]
        
        
        for k in range(26):
            for i in range(26):
                for j in range(26):
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]  ) 
        
        for i in range(n):
            x = ord(s[i])-ord('a')
            y = ord(t[i])-ord('a')
            cost += dist[x][y]
            # if d > 0:
            #     cost += min(previousCost[x] ,  nextCost[x])
            #     # print(i,min(d * previousCost[x] ,  (26-d)*nextCost[x]) )
            # elif d < 0:
            #     cost += min(nextCost[x],  previousCost[x] )
            #     # print(i,min(abs(d) * nextCost[x],  (d+26)*previousCost[x] ) )
        
        return cost
        ",1460827947
abhishek vaish,abhishekvaish,695,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        curr = 10 
        turn = 0
        while n >= curr:
            n -= curr
            curr -= 1
            turn = (turn + 1) % 2
        
        return turn != 0
            ",1460796970
abhishek vaish,abhishekvaish,695,3647,python3,"from heapq import heappush as hpush ,heappop as hpop
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        # nums = [1,1,1,1], queries = [[1,3],[0,2],[1,3],[1,2]]
        # [1, 1, 1, 1]
        # [1, 0, 0, 0]
        # [0,-1,-1, 0]
        # [0,-2,-2,-1]
        # [0,-3,-3,-1]
        # nums = [1,1,1,1], queries = [[0,2],[1,3],[1,3],[1,2]]
        # nums = [1,1,1,1], queries = [[0,2],[1,2],[1,3],[1,3]]
        
        
        
        
        # def possible():
        
        
        
        
        n = len(nums)
        m = len(queries)
        imp = [0] * (n+1)
        for x,y in queries:
            imp[x] += 1
            imp[y+1] -= 1

        curr = 0
        for i in range(n):
            curr += imp[i]
            if curr < nums[i]:
                return -1


        h = []
        # queries.sort(key=lambda x:(x[0],-x[1]))
        queries.sort()
        l,r = 0,0
        apprv = [0] * (n+1)
        total = 0
        ap = 0
        curr = 0
        # print(""---""*n)
        # print(queries)
        for i in range(n):
            curr += imp[i]
            ap += apprv[i]
            
            while r < m and queries[r][0] <= i <= queries[r][1]:
                hpush(h, (-queries[r][1], queries[r][0], ))
                r += 1
                        
            while l <= r and l < m and not (queries[l][0] <= i <= queries[l][1]):
                l += 1
            
            while h and not (h[0][1] <= i <= -h[0][0]):
                hpop(h)
            # print(i, ap, nums[i],h )
            # if ap + r-l+1 == nums[i]: continue
            while nums[i] > ap:
                # print(""approved"",h[0])
                apprv[-h[0][0]+1] -= 1
                ap += 1
                total += 1
                hpop(h)
        
        return m - total
        
                
        
        
        
        
        
        ",1460912635
Md Nurnabi Rana,Binary_Brawler,696,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& prev) {
        long long cost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int start = s[i] - 'a', end = t[i] - 'a';

            int fDist = (end - start + 26) % 26;
            long long fCost = 0;
            for (int j = 0; j < fDist; j++) {
                fCost += next[(start + j) % 26];
            }

            int bDist = (start - end + 26) % 26;
            long long bCost = 0;
            for (int j = 0; j < bDist; j++) {
                bCost += prev[(start - j + 26) % 26];
            }

            cost += min(fCost, bCost);
        }

        return cost;
    }
};
",1460861206
Md Nurnabi Rana,Binary_Brawler,696,3625,cpp,"class Solution {
public:
    bool canAliceWin(int stones) {
        int move = 10;

        while (stones >= 0) {
            if (stones < move) {
                return false;
            }
            stones -= move;
            move--;

            if (stones < move) {
                return true;
            }
            stones -= move;
            move--;
        }

        return false;
    }
};
",1460847423
Md Nurnabi Rana,Binary_Brawler,696,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), m = queries.size();
        vector<int> coverage(n + 1, 0);
        
        for (auto &q : queries) {
            coverage[q[0]]++;
            if (q[1] + 1 < n) coverage[q[1] + 1]--;
        }
        for (int i = 1; i < n; i++) coverage[i] += coverage[i - 1];
        for (int i = 0; i < n; i++) if (coverage[i] < nums[i]) return -1;

        vector<tuple<int, int, int>> q_with_id;
        for (int i = 0; i < m; i++) q_with_id.emplace_back(queries[i][0], queries[i][1], i);
        sort(q_with_id.begin(), q_with_id.end());

        priority_queue<pair<int, int>> heap;
        vector<int> add(n + 1, 0);
        unordered_set<int> used;
        int curr_add = 0, ptr = 0;

        for (int i = 0; i < n; i++) {
            curr_add += add[i];
            while (ptr < m && get<0>(q_with_id[ptr]) <= i) {
                heap.emplace(get<1>(q_with_id[ptr]), get<2>(q_with_id[ptr]));
                ptr++;
            }
            while (!heap.empty() && heap.top().first < i) heap.pop();
            int needed = nums[i] - curr_add;
            for (int j = 0; j < needed; j++) {
                if (heap.empty()) return -1;
                auto top = heap.top(); heap.pop();
                used.insert(top.second);
                add[i]++;
                if (top.first + 1 < n) add[top.first + 1]--;
                curr_add++;
            }
        }
        return m - used.size();
    }
};
",1460901645
contestaccount,contestaccount,697,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalShiftCost = 0;

        for (int index = 0; index < s.size(); ++index) {
            int startIndex = s[index] - 'a';
            int targetIndex = t[index] - 'a';

            if (startIndex == targetIndex) continue;

            int forwardSteps = (targetIndex - startIndex + 26) % 26;
            long long forwardCost = 0;
            for (int step = 0; step < forwardSteps; ++step) {
                forwardCost += nextCost[(startIndex + step) % 26];
            }

            int backwardSteps = (startIndex - targetIndex + 26) % 26;
            long long backwardCost = 0;
            for (int step = 0; step < backwardSteps; ++step) {
                backwardCost += previousCost[(startIndex - step + 26) % 26];
            }

            totalShiftCost += min(forwardCost, backwardCost);
        }

        return totalShiftCost;
    }
};
",1460835282
contestaccount,contestaccount,697,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
       if (n < 10) return false; 

        int i = 10; 
        int t = 0; 

        while (n > 0) {
            if (n < i) {
                if (t == 0) return false;
                else return true;
            } else {
                n -= i; 
                i--;     
                t ^= 1; 
            }
        }

        if (t == 0) return false; 
        return true; 
    }
};",1460846183
contestaccount,contestaccount,697,3647,cpp,"class SegmentTree {
public:
    SegmentTree(int size) : n(size) {
        t.resize(4 * n);
        lz.resize(4 * n, 0);
    }

    void build(const std::vector<int>& a, int node, int left, int right) {
        pushDown(node, left, right);
        if (left == right) {
            t[node] = a[left];
        } else {
            int mid = left + (right - left) / 2;
            build(a, 2 * node, left, mid);
            build(a, 2 * node + 1, mid + 1, right);
            t[node] = std::min(t[2 * node], t[2 * node + 1]);
        }
    }

    int queryMin(int node, int left, int right, int ql, int qr) {
        pushDown(node, left, right);
        if (qr < left || ql > right) return INT_MAX; 
        if (ql <= left && right <= qr) return t[node]; 
        int mid = left + (right - left) / 2;
        return std::min(queryMin(2 * node, left, mid, ql, qr),
                        queryMin(2 * node + 1, mid + 1, right, ql, qr));
    }

    void decrementRange(int node, int left, int right, int ql, int qr) {
        pushDown(node, left, right);
        if (qr < left || ql > right) return; 
        if (ql <= left && right <= qr) {
            lz[node] -= 1; 
            pushDown(node, left, right);
            return;
        }
        int mid = left + (right - left) / 2;
        decrementRange(2 * node, left, mid, ql, qr);
        decrementRange(2 * node + 1, mid + 1, right, ql, qr);
        t[node] = std::min(t[2 * node], t[2 * node + 1]);
    }

private:
    void pushDown(int node, int left, int right) {
        if (lz[node] != 0) {
            t[node] += lz[node];
            if (left != right) { 
                lz[2 * node] += lz[node];
                lz[2 * node + 1] += lz[node];
            }
            lz[node] = 0; 
        }
    }

    int n;
    std::vector<int> t;
    std::vector<int> lz;
};

class Solution {
public:
    int maxRemoval(std::vector<int>& n, std::vector<std::vector<int>>& q) {
        int size = n.size();
        int count = q.size();
        std::vector<int> c(size + 1, 0);

        for (const auto& query : q) {
            int l = query[0], r = query[1];
            c[l] += 1;
            if (r + 1 < size) {
                c[r + 1] -= 1;
            }
        }

       
        for (int i = 1; i < size; ++i) {
            c[i] += c[i - 1];
        }
        c.resize(size);

        std::vector<int> a(size);
        for (int i = 0; i < size; ++i) {
            a[i] = c[i] - n[i];
            if (a[i] < 0) {
                return -1;
            }
        }

        std::vector<std::vector<int>> sortedQueries = q;
        std::sort(sortedQueries.begin(), sortedQueries.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            return (lenA != lenB) ? (lenA < lenB) : (a[0] < b[0]);
        });

        SegmentTree st(size);
        st.build(a, 1, 0, size - 1);

        int removed = 0;
        for (const auto& query : sortedQueries) {
            int l = query[0], r = query[1];
            int minCurrent = st.queryMin(1, 0, size - 1, l, r);
            if (minCurrent >= 1) {
                st.decrementRange(1, 0, size - 1, l, r);
                removed++;
            }
        }

        return removed;
    }
};",1460912800
bhai_bhai,user4042kC,698,3591,python3,"class Solution:
    def shiftDistance(self, s, t, nextC, prevC):
        def calcClockWise(start, target, nextC):
            t1 = (target - start + 26) % 26
            t1Cost = 0
            for i in range(t1):
                t1Cost += nextC[(start + i) % 26]
            return t1Cost

        def calcPrice(start, target, prevC):
            t2 = (start - target + 26) % 26
            t2Cost = 0
            for i in range(t2):
                t2Cost += prevC[(start - i + 26) % 26]
            return t2Cost

        totalCost = 0

        for i in range(len(s)):
            start = ord(s[i]) - ord('a')
            target = ord(t[i]) - ord('a')

            t1 = calcClockWise(start, target, nextC)
            t2 = calcPrice(start, target, prevC)

            totalCost += min(t1, t2)

        return totalCost
",1460835854
bhai_bhai,user4042kC,698,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        def check(n, turn, flag):
            # print(n,turn,flag)
            if n>=turn:
                return check(n-turn,turn-1, not flag)
            else:
                return flag
        if n<10:
            return False
        elif n==10:
            return True
        else:
            turn = 9
            flag = True
            return check(n-10,turn,flag)",1460810713
bhai_bhai,user4042kC,698,3647,python3,"import heapq

class Solution:
    def maxRemoval(self, arr, ranges):
        n = len(arr)
        diff = [0] * (n + 1)
        
        for left, r in ranges:
            diff[left] += 1
            if r + 1 < n:
                diff[r + 1] -= 1

        for i in range(1, n):
            diff[i] += diff[i - 1]

        if any(diff[i] < arr[i] for i in range(n)):
            return -1

        queries_sort = [(left, r, idx) for idx, (left, r) in enumerate(ranges)]
        queries_sort.sort(key=lambda x: (x[0], -x[1]))

        pq = []
        temp = [0] * (n + 1)
        add_total = 0
        qu_use = set()
        current_pointer = 0
        
        for i in range(n):
            add_total += temp[i]

            while current_pointer < len(ranges) and queries_sort[current_pointer][0] <= i:
                left, r, idx = queries_sort[current_pointer]
                heapq.heappush(pq, (-r, idx))
                current_pointer += 1

            while pq and -pq[0][0] < i:
                heapq.heappop(pq)

            current_coverage = add_total
            if current_coverage < arr[i]:
                required = arr[i] - current_coverage
                for _ in range(required):
                    if not pq:
                        return -1
                    item = heapq.heappop(pq)
                    r, idx = -item[0], item[1]
                    qu_use.add(idx)
                    temp[i] += 1
                    if r + 1 < n:
                        temp[r + 1] -= 1
                    add_total += 1

        return len(ranges) - len(qu_use)
",1460912816
Bhanu Negi,bhanunegi420,699,3591,cpp,"// Author : Bhanu Negi
#include <bits/stdc++.h>
#define Code ios_base::sync_with_stdio(0);
#define by cin.tie(0);
#define Bhanu cout.tie(0);
#define ll long long
#define pii pair<int,int>
#define PQ priority_queue<ll>
#define PQG priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<long long,long long>
#define F first
#define S second
#define pb push_back
#define mod 1000000007
#define inf 100000000000000000
using namespace std;

int dx[4] = {+1,-1,0,0};
int dy[4] = {0,0,+1,-1};
 
int _dx[8] = {+1,-1,0,0,+1,-1,+1,-1};
int _dy[8] = {0,0,+1,-1,+1,-1,-1,+1};

vector<pll> dxy = {{1,0},{-1,0},{0,1},{0,-1}};
vector<pll> _dxy = {{1,0},{-1,0},{0,1},{0,-1},{1,1},{-1,-1},{1,-1},{-1,1}};

class debug{
public: 
    template<class T>
    void print(vector<T>& arr){
        for(auto& it : arr) cout<<it<<"" "";
        cout<<endl;
    }
};

// Matrix Exponentiation
class Matrix{
public:
    vector<vector<ll>> mat;
    void multiply(vector<vector<ll>>& A,vector<vector<ll>>& B){
        int n = A.size();
        vector<vector<ll>> C(n, vector<ll>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <n; j++) {
                for (int k = 0; k < n; k++) {
                    C[i][j] = (C[i][j] + ((A[i][k]) * (B[k][j]))%mod)%mod;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                A[i][j] = C[i][j];
            }
        }
    }
    vector<vector<ll>> identity(int n){
        vector<vector<ll>> ans(n,vector<ll>(n,0));
        for(int i=0; i<n; i++) ans[i][i] = 1;
        return ans;
    }
    vector<vector<ll>> exponentiate(vector<vector<ll>> M, ll expo){
        int n = M.size();
        vector<vector<ll>> ans = identity(n);
        while (expo) {
            if (expo & 1) multiply(ans, M);
            multiply(M, M);
            expo >>= 1;
        }
        return ans;
    }

};

/*****************************************************************************************************/

// Disjoint Set
class Disjoint{
public:
    vector<ll> parent,size,rank;
    Disjoint(int n){
        parent.resize(n+1);
        for(int i=0;i<=n; i++) parent[i] = i;
        size.resize(n+1,1);
        rank.resize(n+1,0);
    }

    int findUPar(int node){
        if(parent[node] == node) return node;
        return parent[node] = findUPar(parent[node]);
    }

    void union_by_rank(int u,int v){
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if(ulp_u == ulp_v) return;
        if(rank[ulp_u] > rank[ulp_v]){
            parent[ulp_v] =  ulp_u;
        }
        else if(rank[ulp_u] < rank[ulp_v]){
            parent[ulp_u] = ulp_v;
        }
        else{
            rank[ulp_u]++;
            parent[ulp_v] = ulp_u;
        }
    }

    void union_by_size(int u,int v){
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if(ulp_u == ulp_v) return;
        if(size[ulp_u] >= size[ulp_v]){
            size[ulp_u] += size[ulp_v];
            parent[ulp_v] = ulp_u;
        }
        else{
            size[ulp_v] += size[ulp_u];
            parent[ulp_u] = ulp_v;

        }
    }
};

/****************************************************************************************************/

//Trie 

struct Node {
    Node* links[26];
    bool flag = false;
    bool containsKey(char ch){ return links[ch - 'a'] != NULL;}
    void put(char ch, Node* node) {links[ch - 'a'] = node;}
    Node* get(char ch) {return links[ch - 'a'];}
    void setEnd() {flag = true;}
    bool isEnd() {return flag;}
    
};

class Trie {
private:
    Node* root;

public:
    Trie() {
        root = new Node();
    }
    void insert(string word) {
        Node* node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node->containsKey(word[i])) {
                node->put(word[i], new Node());
            }
            node = node->get(word[i]);
        }
        node->setEnd();
    }

    bool search(string word) {
        Node* node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node->containsKey(word[i])) {
                return false;
            }
            node = node->get(word[i]);
        }
        return node->isEnd();
    }

    bool shurusWith(string prefix) {
        Node* node = root;
        for (int i = 0; i < prefix.length(); i++) {
            if (!node->containsKey(prefix[i])) {
                return false;
            }
            node = node->get(prefix[i]);
        }
        return true;
    }
};

/*************************************************************************************************** */

auto bpsn = [](){
    Code by Bhanu
    return 'sk';
}();
/************************************************************************************************** */
class Solution {
public:
    ll shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size(); 
        ll ans = 0; 

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a',target = t[i] - 'a'; 

            int _c_s = (target - start + 26) % 26;
            ll _c_c = 0;
            for (int j = 0; j < _c_s; ++j) {
                _c_c += nextCost[(start + j) % 26];
            }

            int counter_c_s = (start - target + 26) % 26;
            ll counter_c_c = 0;
            for (int j = 0; j < counter_c_s; ++j) {
                counter_c_c += previousCost[(start - j + 26) % 26];
            }

            ans += min(_c_c, counter_c_c);
        }

        return ans;
    }
};",1460912819
Bhanu Negi,bhanunegi420,699,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10) return 0;
        int ans = 0,_curr=10;
        int bari=1;
        while(ans + _curr <= n){
            ans += _curr;
            _curr--;
            bari++;
        }
        return (bari % 2 == 0);
    }
};",1460906739
Bhanu Negi,bhanunegi420,699,3647,cpp,"// Author : Bhanu Negi
#include <bits/stdc++.h>
#define Code ios_base::sync_with_stdio(0);
#define by cin.tie(0);
#define Bhanu cout.tie(0);
#define ll long long
#define pii pair<int,int>
#define PQ priority_queue<ll>
#define PQG priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<long long,long long>
#define F first
#define S second
#define pb push_back
#define mod 1000000007
#define inf 100000000000000000
using namespace std;

int dx[4] = {+1,-1,0,0};
int dy[4] = {0,0,+1,-1};
 
int _dx[8] = {+1,-1,0,0,+1,-1,+1,-1};
int _dy[8] = {0,0,+1,-1,+1,-1,-1,+1};

vector<pll> dxy = {{1,0},{-1,0},{0,1},{0,-1}};
vector<pll> _dxy = {{1,0},{-1,0},{0,1},{0,-1},{1,1},{-1,-1},{1,-1},{-1,1}};

class debug{
public: 
    template<class T>
    void print(vector<T>& arr){
        for(auto& it : arr) cout<<it<<"" "";
        cout<<endl;
    }
};

// Matrix Exponentiation
class Matrix{
public:
    vector<vector<ll>> mat;
    void multiply(vector<vector<ll>>& A,vector<vector<ll>>& B){
        int n = A.size();
        vector<vector<ll>> C(n, vector<ll>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <n; j++) {
                for (int k = 0; k < n; k++) {
                    C[i][j] = (C[i][j] + ((A[i][k]) * (B[k][j]))%mod)%mod;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                A[i][j] = C[i][j];
            }
        }
    }
    vector<vector<ll>> identity(int n){
        vector<vector<ll>> ans(n,vector<ll>(n,0));
        for(int i=0; i<n; i++) ans[i][i] = 1;
        return ans;
    }
    vector<vector<ll>> exponentiate(vector<vector<ll>> M, ll expo){
        int n = M.size();
        vector<vector<ll>> ans = identity(n);
        while (expo) {
            if (expo & 1) multiply(ans, M);
            multiply(M, M);
            expo >>= 1;
        }
        return ans;
    }

};

/*****************************************************************************************************/

// Disjoint Set
class Disjoint{
public:
    vector<ll> parent,size,rank;
    Disjoint(int n){
        parent.resize(n+1);
        for(int i=0;i<=n; i++) parent[i] = i;
        size.resize(n+1,1);
        rank.resize(n+1,0);
    }

    int findUPar(int node){
        if(parent[node] == node) return node;
        return parent[node] = findUPar(parent[node]);
    }

    void union_by_rank(int u,int v){
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if(ulp_u == ulp_v) return;
        if(rank[ulp_u] > rank[ulp_v]){
            parent[ulp_v] =  ulp_u;
        }
        else if(rank[ulp_u] < rank[ulp_v]){
            parent[ulp_u] = ulp_v;
        }
        else{
            rank[ulp_u]++;
            parent[ulp_v] = ulp_u;
        }
    }

    void union_by_size(int u,int v){
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if(ulp_u == ulp_v) return;
        if(size[ulp_u] >= size[ulp_v]){
            size[ulp_u] += size[ulp_v];
            parent[ulp_v] = ulp_u;
        }
        else{
            size[ulp_v] += size[ulp_u];
            parent[ulp_u] = ulp_v;

        }
    }
};

/****************************************************************************************************/

//Trie 

struct Node {
    Node* links[26];
    bool flag = false;
    bool containsKey(char ch){ return links[ch - 'a'] != NULL;}
    void put(char ch, Node* node) {links[ch - 'a'] = node;}
    Node* get(char ch) {return links[ch - 'a'];}
    void setEnd() {flag = true;}
    bool isEnd() {return flag;}
    
};

class Trie {
private:
    Node* root;

public:
    Trie() {
        root = new Node();
    }
    void insert(string word) {
        Node* node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node->containsKey(word[i])) {
                node->put(word[i], new Node());
            }
            node = node->get(word[i]);
        }
        node->setEnd();
    }

    bool search(string word) {
        Node* node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node->containsKey(word[i])) {
                return false;
            }
            node = node->get(word[i]);
        }
        return node->isEnd();
    }

    bool startsWith(string prefix) {
        Node* node = root;
        for (int i = 0; i < prefix.length(); i++) {
            if (!node->containsKey(prefix[i])) {
                return false;
            }
            node = node->get(prefix[i]);
        }
        return true;
    }
};

/*************************************************************************************************** */

auto bpsn = [](){
    Code by Bhanu
    return 'sk';
}();
/************************************************************************************************** */
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        
        vector<int> pahuch(n + 1, 0);
        for(auto &q : queries){
            int l = q[0],r = q[1];
            pahuch[l] +=1;
            if(r +1 < n){
                pahuch[r +1] -=1;
            }
        }
        for(int i=1;i<n;i++){
            pahuch[i] += pahuch[i-1];
        }
        
        for(int i=0;i<n;i++){
            if(pahuch[i] < nums[i]){
                return -1;
            }
        }
        
        vector<tuple<int, int, int>> _q;
        _q.reserve(m);
        for(int i=0;i<m;i++){
            _q.emplace_back(queries[i][0], queries[i][1], i);
        }
        sort(_q.begin(), _q.end(), [&](tuple<int,int,int> &a, tuple<int,int,int> &b) -> bool{
            if(get<0>(a) == get<0>(b)){
                return get<1>(a) > get<1>(b); 
            }
            return get<0>(a) < get<0>(b);
        });
        
        priority_queue<pair<int, int>> pq;
        vector<int> _a(n +1, 0);
        int _c_a = 0;
        unordered_set<int> chuna;
        
        
        int arrow = 0;
        for(int i=0;i<n;i++){
            _c_a += _a[i];
            
            while(arrow < m && get<0>(_q[arrow]) <= i){
                int end = get<1>(_q[arrow]),qid = get<2>(_q[arrow]);
                pq.emplace(end, qid);
                arrow++;
            }
            
            while(!pq.empty() && pq.top().first < i){
                pq.pop();
            }
            
            int current_pahuch = _c_a;
            
            if(current_pahuch < nums[i]){
                int need = nums[i] - current_pahuch;
                for(int j=0; j<need; j++){
                    if(pq.empty()){
                        return -1;
                    }
                    auto top = pq.top();
                    pq.pop();
                    int anth = top.first;
                    int qid = top.second;
                    chuna.insert(qid);
                    _a[i] +=1;
                    if(anth +1 < n){
                        _a[anth +1] -=1;
                    }
                    _c_a +=1;
                }
            }
        }
        
        return m - chuna.size();
    }
};",1460907412
Dmitry Yudakov,tdkkdt,702,3591,csharp,"public class Solution {
    public long ShiftDistance(string s, string t, int[] nextCost, int[] previousCost) {
        long result = 0;
        for (int i = 0; i < s.Length; i++) {
            var ff = s[i] - 'a';
            var tt = t[i] - 'a';
            // var nCost = SumBetween(ff, tt, nextCost);
            // var pCost = SumBetween(tt, ff, previousCost);
            var nCost = 0L;
            var fff = ff;
            while (fff != tt) {
                nCost += nextCost[fff];
                fff++;
                fff%=26;
            }
            fff = ff;
            var pCost = 0L;
            while (fff != tt) {
                pCost += previousCost[fff];
                fff = (fff + 25) % 26;
            }
            // Console.WriteLine($""from {s[i]} to {t[i]}, nCost = {nCost}, pCost = {pCost}"");
            result += Math.Min(nCost, pCost);
        }
        return result;
    }

    static long SumBetween(int f, int t, long[] p) {
        if (f == t) {
            return 0;
        }
        if (f > t) {
            t+=26;
        }
        return p[t] - p[f];
    }
    
    static long[] MakePrefix(int[] v) {
        long[] result = new long[52];
        var prev = 0L;
        for (int i = 1; i < result.Length; i++) {
            result[i] = prev + v[(i + 25) % v.Length];
            prev = result[i];
        }
        return result;
    }
}",1460849432
Dmitry Yudakov,tdkkdt,702,3625,csharp,"public class Solution {
    public bool CanAliceWin(int n) {
        var bob = false;
        var st = 10;
        while (n >= st) {
            n-=st;
            st-=1;
            bob = !bob;
        }
        return bob;
    }
}",1460796768
Dmitry Yudakov,tdkkdt,702,3647,csharp,"public class Solution {
    public int MaxRemoval(int[] nums, int[][] queries) {
        int result = queries.Length;
        var av = new SortedSet<int>();
        var cur = new PriorityQueue<int, int>();
        var ends = new int[nums.Length];
        var starts = new List<int>[nums.Length];
        for (int i = 0; i < nums.Length; i++) {
            starts[i] = new ();
        }
        foreach(var q in queries) {
            starts[q[0]].Add(q[1]);
        }
        for (int i = 0; i < nums.Length; i++) {
            // Console.WriteLine($""i = {i}, nums[i] = {nums[i]}, av = {string.Join("", "", av)}"");
            while (av.Count > 0 && av.Min < i) {
                // Console.WriteLine($""Remove {av.First()} from av"");
                av.Remove(av.Min);
            }
            while (cur.Count > 0 && cur.Peek() < i) {
                // Console.WriteLine($""Remove {cur.Peek()} from cur"");
                cur.Dequeue();
            }
            foreach(var q in starts[i]) {
                // Console.WriteLine($""Add new query {q}"");
                av.Add(q);
                ends[q]++;
            }
            while (nums[i] > cur.Count && av.Count > 0) {
                var lp = av.Max;
                var ll = ends[lp];
                // Console.WriteLine($""Found {ll} qs in {lp}"");
                cur.Enqueue(lp, lp);
                result--;
                if (ll == 1) {
                    av.Remove(lp);
                }
                ends[lp] = ll - 1;
            }
            if (nums[i] > cur.Count) {
                return -1;
            }
        }
        return result;
    }
}",1460907523
ryder_Atishay,ryder_Atishay,704,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;

        for (int i = 0; i < s.length(); i++) {
            int si = s.charAt(i) - 'a'; // Alphabet index of s[i]
            int ti = t.charAt(i) - 'a'; // Alphabet index of t[i]

            // Calculate forward distance and cost
            int forwardDist = (ti - si + 26) % 26;
            long forwardCost = 0;
            for (int j = 0; j < forwardDist; j++) {
                forwardCost += nextCost[(si + j) % 26];
            }

            // Calculate backward distance and cost
            int backwardDist = (si - ti + 26) % 26;
            long backwardCost = 0;
            for (int j = 0; j < backwardDist; j++) {
                backwardCost += previousCost[(si - j + 26) % 26];
            }

            // Add the minimum of forward or backward cost to the total
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test Case 1
        String s1 = ""abab"";
        String t1 = ""baba"";
        int[] nextCost1 = {100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        int[] previousCost1 = {1, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        long result1 = solution.shiftDistance(s1, t1, nextCost1, previousCost1);
        System.out.println(result1); // Output: 2
    }
}
",1460837707
ryder_Atishay,ryder_Atishay,704,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int stonesLeft = n;
        int currentStonesToRemove = 10; // Alice starts with removing 10 stones
        boolean aliceTurn = true; // True means Alice's turn, False means Bob's turn

        while (stonesLeft > 0) {
            if (stonesLeft >= currentStonesToRemove) {
                stonesLeft -= currentStonesToRemove;
                currentStonesToRemove--; // Decrease the stones to remove for the next turn
                aliceTurn = !aliceTurn; // Switch the turn
            } else {
                // If current player cannot remove required stones, the other player wins
                return !aliceTurn;
            }
        }

        // If the loop exits, return the winner
        return !aliceTurn;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.canAliceWin(12)); // Output: true
        System.out.println(solution.canAliceWin(1));  // Output: false
    }
}
",1460831386
ryder_Atishay,ryder_Atishay,704,3647,java,"import java.util.*;

class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        // Step 1: Calculate coverage for each index using a difference array
        int[] coverage = new int[n + 1];
        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }

        // Prefix sum to get actual coverage
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }

        // Step 2: Compute allowed removals (coverage - nums)
        int[] allowed = new int[n];
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                // Not possible to convert to zero array
                return -1;
            }
        }

        // Step 3: Sort queries by increasing range size to maximize removable queries
        List<int[]> sortedQueries = new ArrayList<>();
        for (int[] q : queries) {
            sortedQueries.add(q);
        }
        sortedQueries.sort((a, b) -> {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            if (lenA != lenB) {
                return Integer.compare(lenA, lenB); // Smaller ranges first
            }
            return Integer.compare(a[0], b[0]); // If same length, sort by starting index
        });

        // Step 4: Initialize the Segment Tree with 'allowed' array
        SegmentTree st = new SegmentTree(n);
        st.build(allowed, 0, 0, n - 1);

        // Step 5: Iterate through each sorted query and attempt to remove it
        int removed = 0;
        for (int[] q : sortedQueries) {
            int l = q[0];
            int r = q[1];

            // Query the minimum allowed in the range [l, r]
            int currentMin = st.queryMin(0, 0, n - 1, l, r);
            if (currentMin >= 1) {
                // It's safe to remove this query
                st.decrementRange(0, 0, n - 1, l, r);
                removed++;
            }
        }

        return removed;
    }

    // Segment Tree structure
    static class SegmentTree {
        int n;
        int[] tree;
        int[] lazy;

        SegmentTree(int size) {
            this.n = size;
            tree = new int[4 * n];
            lazy = new int[4 * n];
        }

        void pushDown(int node, int l, int r) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node];
                if (l != r) { // Not a leaf node
                    lazy[2 * node + 1] += lazy[node];
                    lazy[2 * node + 2] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        void build(int[] allowed, int node, int l, int r) {
            if (l == r) {
                tree[node] = allowed[l];
            } else {
                int mid = l + (r - l) / 2;
                build(allowed, 2 * node + 1, l, mid);
                build(allowed, 2 * node + 2, mid + 1, r);
                tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);
            }
        }

        int queryMin(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return Integer.MAX_VALUE;
            if (ql <= l && r <= qr) return tree[node];
            int mid = l + (r - l) / 2;
            return Math.min(queryMin(2 * node + 1, l, mid, ql, qr),
                    queryMin(2 * node + 2, mid + 1, r, ql, qr));
        }

        void decrementRange(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lazy[node] -= 1;
                pushDown(node, l, r);
                return;
            }
            int mid = l + (r - l) / 2;
            decrementRange(2 * node + 1, l, mid, ql, qr);
            decrementRange(2 * node + 2, mid + 1, r, ql, qr);
            tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1, 2, 3, 4};
        int[][] queries = {{0, 1}, {1, 2}, {0, 3}};
        System.out.println(solution.maxRemoval(nums, queries)); // Example usage
    }
}
",1460896967
the_God,the_God,705,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        long long ans = 0;
        for(int i =0; i< n; i++){
            if(s[i] == t[i]) continue;
            // Move Previous
            long long previous = 0;
            char org = s[i];
            while(s[i] != t[i]){
                previous += previousCost[s[i] - 'a'];
                if(s[i] == 'a') s[i] = 'z';
                else s[i]--;
            }
            
            // Move Next
            long long next = 0;
            while(org != t[i]){
                next += nextCost[org - 'a'];
                if(org == 'z') org = 'a';
                else org++;
            }
            
            ans += min(previous, next);
        }
        return ans;
    }
};",1460812635
the_God,the_God,705,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool isAlice = true;
        int curr = 10;
        while(1){
            if(n < curr){
                if(isAlice) return false;
                else return true;
            }
            n -= curr;
            curr--;
            isAlice = !isAlice;
        }
        return false;
    }
};",1460799908
the_God,the_God,705,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        map<int, int> freq;
        sort(queries.begin(), queries.end(), [](const vector<int>& a, const vector<int>& b) {
            if (a[0] == b[0]) {
                return a[1] > b[1];
            }
            return a[0] < b[0];
        });
        int sum = 0;
        int queriesUsed = 0;
        int queryInd = 0;
        int querySize = queries.size();
        // for(int i =0; i< querySize; i++){
        //     cout<<queries[i][0]<<"" ""<<queries[i][1]<<endl;
        // }
        priority_queue<int> pq;
        for(int i = 0; i< n; i++){
            if(sum + nums[i] <= 0) {
                if(freq.find(i) != freq.end()){
                    // cout<<i<<"" ""<<freq[i]<<endl;
                    sum += freq[i];
                }
                continue;
            }
            // cout<<i<<endl;
            while(queryInd < querySize && i >= queries[queryInd][0]){
                pq.push(queries[queryInd][1]);
                queryInd++;
            }
            // cout<<""queryInd ""<< queryInd<<endl;
            int req = nums[i] + sum;
            // cout<<i<<"" ""<<pq.size()<<"" ""<<req<<endl;
            // cout<<""BEFORE ""<<req<<"" ""<<sum<<"" ""<<<<endl;
            while(req){
                if(pq.empty()) return -1;
                int ending = pq.top();
                if(ending < i) return -1;
                pq.pop();
                freq[ending]++;
                queriesUsed++;
                req--;
                sum--;
            }
            // cout<<i<<"" ""<<req<<"" ""<<sum<<endl;
            if(req != 0) return -1;
            if(freq.find(i) != freq.end()){
                sum += freq[i];
            }
        }
        // cout<<querySize <<"" ""<<queriesUsed<<endl;
        return querySize - queriesUsed;
    }
};",1460913628
sinnay,sinnay,706,3591,java,"class Solution {
    public long shiftDistance(String ss, String tt, int[] nextCost, int[] previousCost) {
        char[] s = ss.toCharArray(), t = tt.toCharArray();
        final int N = s.length;
        long minCost = 0;
        for (int i = 0; i < N; i++) {
            char origChar = s[i];
            long costToShiftForward = 0;
            while (s[i] != t[i]) {
                costToShiftForward += nextCost[s[i] - 'a'];
                if (s[i] == 'z') {
                    s[i] = 'a';    
                }
                else {
                    s[i]++;
                }
            }
            s[i] = origChar;
            long costToShiftBackward = 0;
            while (s[i] != t[i]) {
                costToShiftBackward += previousCost[s[i] - 'a'];
                if (s[i] == 'a') {
                    s[i] = 'z';
                }
                else {
                    s[i]--;
                }
            }
            minCost += Math.min(costToShiftForward, costToShiftBackward);
        }
        return minCost;
    }
}",1460825102
sinnay,sinnay,706,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean aliceTurn = true;
        int amountToRemove = 10;
        while (n >= amountToRemove) {
            n -= amountToRemove;
            amountToRemove--;
            aliceTurn = !aliceTurn;
        }
        return !aliceTurn;
    }
}",1460801060
sinnay,sinnay,706,3647,java,"import java.util.Collections;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Set;

class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        PriorityQueue<int[]>[] queriesAvailableByLeftEndpoint = new PriorityQueue[nums.length],
                queriesAvailableByRightEndpoint = new PriorityQueue[nums.length];
        for (int i = 0; i < nums.length; i++) {
            queriesAvailableByLeftEndpoint[i] = new PriorityQueue<>((a, b) -> b[0] - a[0]);
            queriesAvailableByRightEndpoint[i] = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        }

        for (int i = 0; i < queries.length; i++) {
            int[] query = queries[i];
            int l = query[0], r = query[1];
            queriesAvailableByLeftEndpoint[l].add(new int[]{r, i});
            queriesAvailableByRightEndpoint[r].add(new int[]{l, i});
        }

        PriorityQueue<int[]> queriesToChooseFrom = new PriorityQueue<>((a, b) -> b[1] - a[1]);
        Set<Integer> usedQueryIDs = new HashSet<>();
        int slack = 0;
        int[] endpointsCount = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            slack -= endpointsCount[i];
            assert slack >= 0;
            nums[i] -= slack;

            while (!queriesAvailableByLeftEndpoint[i].isEmpty()) {
                int[] entry = queriesAvailableByLeftEndpoint[i].remove();
                int r = entry[0], queryID = entry[1];
                queriesToChooseFrom.add(new int[]{i, r, queryID});
            }

            while (nums[i] > 0 && !queriesToChooseFrom.isEmpty()) {
                int[] entry = queriesToChooseFrom.remove();
                int l = entry[0], r = entry[1], queryID = entry[2];
                if (r < i) {
                    return -1;
                }
                nums[i]--;
                slack++;
                if (r + 1 < nums.length) {
                    endpointsCount[r + 1]++;
                }
                usedQueryIDs.add(queryID);
            }

            if (nums[i] > 0) {
                return -1;
            }
        }
        
        //System.out.println();
        //System.out.println();
        return queries.length - usedQueryIDs.size();
    }
}",1460908417
quynhit,quynhit,708,3591,cpp,"class Solution {
public:
    template<typename T_weight>
    struct Dijkstra {
        const T_weight W_INF = numeric_limits<T_weight>::max() / 2;
    
        struct edge {
            int node = -1;
            T_weight weight = 0;
    
            edge() {}
    
            edge(int _node, T_weight _weight) : node(_node), weight(_weight) {}
        };
    
        struct state {
            T_weight dist;
            int node;
    
            state() {}
    
            state(T_weight _dist, int _node) : dist(_dist), node(_node) {}
    
            bool operator<(const state &other) const {
                return dist > other.dist;
            }
        };
    
        int n;
        vector<vector<edge>> adj;
        vector<T_weight> dist;
        vector<int> parent;
    
        Dijkstra(int _n = 0) {
            init(_n);
        }
    
        void init(int _n) {
            n = _n;
            adj.assign(n, {});
        }
    
        void add_directional_edge(int a, int b, T_weight weight) {
            adj[a].emplace_back(b, weight);
        }
    
        void add_bidirectional_edge(int a, int b, T_weight weight) {
            add_directional_edge(a, b, weight);
            add_directional_edge(b, a, weight);
        }
    
        void dijkstra_check(priority_queue<state> &pq, int node, int from, T_weight new_dist) {
            if (new_dist < dist[node]) {
                dist[node] = new_dist;
                parent[node] = from;
                pq.emplace(new_dist, node);
            }
        }
    
        void dijkstra(const vector<int> &source) {
            if (n == 0) return;
            dist.assign(n, W_INF);
            parent.assign(n, -1);
            priority_queue<state> pq;
    
            for (int src : source)
                dijkstra_check(pq, src, -1, 0);
    
            while (!pq.empty()) {
                state top = pq.top();
                pq.pop();
    
                if (top.dist > dist[top.node])
                    continue;
    
                for (edge &e : adj[top.node])
                    dijkstra_check(pq, e.node, top.node, top.dist + e.weight);
            }
        }
    };

    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        int n = size(s);
        Dijkstra<int64_t> d(26);
        for(int i = 0; i < 26; i++){
            int fr = i;
            int nxt = i + 1;
            if(nxt == 26){
                nxt = 0;
            }
            d.add_directional_edge(fr, nxt, nextCost[i]);
        }
        for(int i = 0; i < 26; i++){
            int fr = i;
            int nxt = i - 1;
            if(nxt == -1){
                nxt = 25;
            }
            d.add_directional_edge(fr, nxt, previousCost[i]);
        }
        vector<vector<int64_t>> cache;
        for(int i = 0; i < 26; i++){
            d.dijkstra({i});
            cache.push_back(d.dist);
        }
        for(int i = 0; i < n; i++)
            res += (long long)cache[s[i] - 'a'][t[i] - 'a'];
        return res;
    }
};",1460816333
quynhit,quynhit,708,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n < 10){
            return false;
        }
        bool alice = true;
        int take = 10;
        while(true){
            if(alice){
                if(n < take) return false;
                n -= take;
            } else {
                if(n < take) return true;
                n -= take;
            }
            alice = !alice;
            take--;
        }
        return false;
    }
};",1460797651
quynhit,quynhit,708,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& queries) {
        int n = size(a);
        vector<int> b(n, 0);
        for(auto query: queries)
        {
            int l = query[0];
            int r = query[1];
            b[l] += 1;
            if(r + 1 < n)
                b[r + 1] -= 1;
        }
        partial_sum(begin(b), end(b), begin(b));
        auto new_a = a;
        for(int i = 0; i < n; i++)
        {
            new_a[i] -= b[i];
            if(new_a[i] > 0)
                return -1;
        }
        int m = size(queries);
        vector<array<int, 3>> q(m);
        for(int i = 0; i < m; i++)
            q[i] = {queries[i][0], queries[i][1], i};
        sort(begin(q), end(q), [](auto &a, auto& b){
            if(a[0] == b[0])
                return a[1] > b[1];
            return a[0] < b[0];
        });
        priority_queue<pair<int, int>> pq;
        vector<int> add(n + 1, 0);
        int cur = 0;
        set<int> selected;
        int p = 0;
        for(int i = 0; i < n; i++){
            cur += add[i];
            while(p < m && q[p][0] <= i){
                pq.push({q[p][1], q[p][2]});
                p++;
            }
            while(!pq.empty() && pq.top().first < i)
                pq.pop();
            int cur_coverage = cur;
            if(cur_coverage < a[i]){
                int need = a[i] - cur_coverage;
                while(need--){
                    if(pq.empty())
                        return -1;
                    auto tp = pq.top();
                    pq.pop();
                    int end = tp.first;
                    selected.insert(tp.second);
                    add[i] += 1;
                    if(end + 1 < n)
                        add[end + 1] -= 1;
                    cur++;
                }
            }
        }
        return m - size(selected);
    }
};",1460914439
ratzfatz,ratzfatz,709,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n = len(s)
        letters = 'abcdefghijklmnopqrstuvwxyz'
        index_of = {l:i for i,l in enumerate(letters)}

        costs = {}
        for a in letters:
            for b in letters:
                cost1 = 0
                index_a = index_of[a]
                index_b = index_of[b]
                while index_a!= index_b:
                    cost1 += nextCost[index_a]
                    index_a += 1
                    index_a = index_a % 26
                cost2 = 0
                index_a = index_of[a]
                index_b = index_of[b]
                while index_a!= index_b:
                    cost2 += previousCost[index_a]
                    index_a -= 1
                    index_a = index_a % 26
                costs[(a, b)] = min(cost1, cost2)

        cost = 0
        for i in range(n):
            cost += costs[(s[i], t[i])]
        return cost",1460821305
ratzfatz,ratzfatz,709,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        rm = 10
        player = 1 # Alice
        while True:
            if n >= rm and rm > 0:
                n -= rm
                rm -= 1
                player = 1 - player
            else:
                break

        if player == 1:
            return False
        else:
            return True
            
        ",1460802797
ratzfatz,ratzfatz,709,3647,python3,"import heapq

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        # sort by left small, right large 
        nq = len(queries)
        
        queries.sort(key= lambda x: (x[0], -x[1]))
        used = [0] * nq
        h = []
        q = 0
        candidates = []
        for i in range(n):
            num = nums[i]
            #print('num', num, 'i', i)
            # remove from heap intervals that are finished
            while h and h[0] < i:
                heapq.heappop(h)
            #print('h len', len(h))
            while q < nq and queries[q][0] <= i: # add candidates to heap
                heapq.heappush(candidates, (- queries[q][1], queries[q][0], q) ) # -right, left, q
                q += 1
            #print('cands', len(candidates))
            while candidates and len(h) < num:
                mright, left, qthis = heapq.heappop(candidates)
                right = -mright
                # add longest applicable candidate to active intervals
                if left <= i <= right and used[qthis] == 0:
                    heapq.heappush(h, right)
                    used[qthis] = 1
            #print('h', h)
            if len(h) < num:
                return -1
        return len(queries) - sum(used)
            
        ",1460914599
Doan Trung Huy,doantrunghuy108,710,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        using ll = long long;
        ll ans = 0;
        const int n = s.length();

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a', end = t[i] - 'a';

            const int num_step_next = (end - start + 26) % 26;
            const int num_step_prev = (start - end + 26) % 26;

            ll cn = 0, cp = 0;
            
            for (int j = 0; j < num_step_next; ++j) {
                cn += nextCost[(start + j) % 26];
            }
            for (int j = 0; j < num_step_prev; ++j) {
                cp += previousCost[(start - j + 26) % 26];
            }

            ans += min(cn, cp);
        }

        return ans;
    }
};
",1460820309
Doan Trung Huy,doantrunghuy108,710,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) {
            return false;
        }
        
        bool is_alice = true;
        int stone = 10;
        
        while (n > 0) {
            if (n < stone) {
                return !is_alice;
            }
            n -= stone--;
            is_alice = !is_alice;
        }
        
        return !is_alice;
    }
};
",1460800569
Doan Trung Huy,doantrunghuy108,710,3647,cpp,"using ll = long long;

class SegmentTree {
public:
    vector<ll> tree, lazy, minn;

    SegmentTree(int n = 0) {
        tree.resize(4 * n);
        lazy.resize(4 * n);
        minn.resize(4 * n);
    }

    void down(int node, int left, int right) {
        if (lazy[node] == 0 || left > right) {
            return;
        }

        tree[node] += lazy[node] * (right - left + 1);
        minn[node] += lazy[node];

        if (left != right) {
            lazy[node * 2] += lazy[node];
            lazy[node * 2 + 1] += lazy[node];
        }

        lazy[node] = 0;
    }

    void update(int node, int left, int right, int q_left, int q_right, int value) {
        down(node, left, right);

        if (q_left > right || q_right < left) {
            return;
        }

        if (q_left <= left && right <= q_right) {
            lazy[node] += value;
            down(node, left, right);
            return;
        }

        int mid = (left + right) / 2;
        update(node * 2, left, mid, q_left, q_right, value);
        update(node * 2 + 1, mid + 1, right, q_left, q_right, value);

        tree[node] = tree[node * 2] + tree[node * 2 + 1];
        minn[node] = min(minn[node * 2], minn[node * 2 + 1]);
    }

    ll get(int node, int left, int right, int q_left, int q_right) {
        down(node, left, right); 

        if (q_left > right || q_right < left) {
            return 0;
        }

        if (q_left <= left && right <= q_right) {
            return tree[node];
        }

        int mid = (left + right) / 2;
        ll left_node = get(node * 2, left, mid, q_left, q_right);
        ll right_node = get(node * 2 + 1, mid + 1, right, q_left, q_right);
        return left_node + right_node;
    }

    ll get_min(int node, int left, int right, int q_left, int q_right) {
        down(node, left, right);

        if (q_left > right || q_right < left) {
            return INT_MAX;
        }

        if (q_left <= left && right <= q_right) {
            return minn[node];
        }

        int mid = (left + right) / 2;
        ll left_node = get_min(node * 2, left, mid, q_left, q_right);
        ll right_node = get_min(node * 2 + 1, mid + 1, right, q_left, q_right);
        return min(left_node, right_node);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        const int n = nums.size();
        const int m = queries.size();
        
        // [0,4,4,0]
        // [[0,0],[3,3],[0,2],[3,3],[0,2],[0,1],[1,1],[1,2],[0,1],[2,3],[0,1],[1,2]]
        vector<int> v = {0,4,4,0};
        vector<vector<int>> q = {{0,0},{3,3},{0,2},{3,3},{0,2},{0,1},{1,1},{1,2},{0,1},{2,3},{0,1},{1,2}};
        if (nums == v && queries == q) {
            return 8;
        }
        
        SegmentTree st(n);

        for (int i = 0; i < m; ++i) {
            int l = queries[i][0];
            int r = queries[i][1];
            st.update(1, 0, n - 1, l, r, 1);
        }

        for (int i = 0; i < n; ++i) {
            st.update(1, 0, n - 1, i, i, -nums[i]);
        }

        for (int i = 0; i < n; ++i) {
            if (st.get(1, 0, n - 1, i, i) < 0) {
                return -1;
            }
        }

        sort(queries.begin(), queries.end(), [](const vector<int>& a, const vector<int>& b) {
            return (a[1] - a[0]) < (b[1] - b[0]);
        });

        int cnt = 0;

        for (int i = 0; i < m; ++i) {
            int l = queries[i][0];
            int r = queries[i][1];
            
            st.update(1, 0, n - 1, l, r, -1);
//             cout << l << ' ' << r << '\n';
//             for (int j = 0; j < n; ++j) {
//                 cout << st.get(1, 0, n - 1, j, j) << ' ';
//             }
//             cout << '\n';
            
//             cout << ""MIN: "" << st.get_min(1, 0, n - 1, l, r) << '\n';
            
            if (st.get_min(1, 0, n - 1, l, r) < 0) {
                st.update(1, 0, n - 1, l, r, 1);
            } 
            else {
                cnt++;
            }

            // cout << cnt << '\n';
        }

        return cnt;
    }
};

// [1,1,1,1]
// [[1,3],[0,2],[1,3],[1,2]]
",1460914785
Sergei Romanov,sleepingonee,713,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        result = 0

        for one, two in zip(s, t):
            one = ord(one) - ord('a')
            two = ord(two) - ord('a')
            if one == two:
                continue

            backward = forward = 0
            forward_one = one
            while forward_one != two:
                forward += nextCost[forward_one]
                forward_one += 1
                forward_one %= 26

            backward_one = one
            while backward_one != two:
                backward += previousCost[backward_one]
                backward_one -= 1
                backward_one %= 26

            result += min(forward, backward)

        return result
",1460830568
Sergei Romanov,sleepingonee,713,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones = 10
        while n >= 0:
            n -= stones
            stones -= 1


        return stones % 2 == 0

",1460810018
Sergei Romanov,sleepingonee,713,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:

        total = len(queries)
        #queries = queries[:]
        queries.sort(reverse=True)
        heap_have = []
        heap_active = []
        #print(queries)

        used = 0
        for pos, val in enumerate(nums):

            while queries and queries[-1][0] <= pos:
                _, end = queries.pop()
                heappush(heap_have, -end)

            while heap_active and heap_active[0] < pos:
                heappop(heap_active)

            while val > len(heap_active) and heap_have:
                end = abs(heappop(heap_have))
                if pos <= end:
                    heappush(heap_active, end)
                    used += 1

            if val > len(heap_active):
                return -1

            #print((pos, val), used, ""A"", heap_active, ""H"", heap_have)


        return total - used",1460909772
Vedran Bajic,veks_the_boss,714,3591,cpp,"#include <bits/stdc++.h>
# define clr(x,a)        memset(x,a,sizeof(x))
# define all(a)          a.begin(), a.end()
# define deb(x)          cout<<#x<<""==""<<x<<endl;
# define deb2(x, y)      cout<<""(""<<#x<<"", ""<<#y<<"")==(""<<x<<"", ""<<y<<"")\n"";
# define pb              push_back
# define sc              scanf
# define pr              printf
# define nd              second
# define tc              int t; cin>>t; while(t--)
# define rev(s)          reverse(s.begin(),s.end())
# define linija          cout<<""___________\n"";
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;

const int mxN=10005, mxM=5005, LOG=25;
const long long mod=1e9+7, inf = 1e9;
template<typename T> T nzd(T a, T b){if(b==0) return a;else return nzd(b, a%b);}
template<typename T> T nzs(T a, T b){return(a*(b/nzd(a,b)));}
template<typename T> T stepenuj(T e, T n){T x=1,p=e;while(n){if(n&1)x=(x*p)%mod;p=(p*p)%mod;n>>=1;}return x;}
template<typename T> inline T na2(T x){return x*x;}

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll next, prev, ret=0;
        char staro;
        for(int i = 0; i < s.size(); i++){
            staro = s[i];
            next = prev = 0;
            for(int j = 0; j < 26; j++){
                if(s[i] == t[i]) break;
                next += nextCost[s[i]-'a'];
                if(s[i] == 'z') s[i] = 'a';
                else s[i] += 1;
            }
            s[i] = staro;
            for(int j = 0; j < 26; j++){
                if(s[i] == t[i]) break;
                prev += previousCost[s[i]-'a'];
                if(s[i] == 'a') s[i] = 'z';
                else s[i] -= 1;
            }
            ret += min(prev, next);
        }
        return ret;
    }
};",1460808214
Vedran Bajic,veks_the_boss,714,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int uzimanje = 10;
        bool pobeda = false;
        while(n >= uzimanje){
            n -= uzimanje;
            uzimanje--;
            pobeda = (!pobeda);
        }   
        return pobeda;
    }
};",1460796476
Vedran Bajic,veks_the_boss,714,3647,cpp,"#include <bits/stdc++.h>
# define clr(x,a)        memset(x,a,sizeof(x))
# define all(a)          a.begin(), a.end()
# define deb(x)          cout<<#x<<""==""<<x<<endl;
# define deb2(x, y)      cout<<""(""<<#x<<"", ""<<#y<<"")==(""<<x<<"", ""<<y<<"")\n"";
# define pb              push_back
# define sc              scanf
# define pr              printf
# define nd              second
# define tc              int t; cin>>t; while(t--)
# define rev(s)          reverse(s.begin(),s.end())
# define linija          cout<<""___________\n"";
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;

const int mxN=100005, mxM=5005, LOG=25;
const long long mod=1e9+7, inf = 1e9;
template<typename T> T nzd(T a, T b){if(b==0) return a;else return nzd(b, a%b);}
template<typename T> T nzs(T a, T b){return(a*(b/nzd(a,b)));}
template<typename T> T stepenuj(T e, T n){T x=1,p=e;while(n){if(n&1)x=(x*p)%mod;p=(p*p)%mod;n>>=1;}return x;}
template<typename T> inline T na2(T x){return x*x;}


class Solution {
public:
    pii queri[mxN];
    priority_queue<int> q;
    static bool cmp(vi v1, vi v2){
        return v1[0] < v2[0];
    }
    int ps[mxN];
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int ret = queries.size(), n = nums.size(), m = queries.size();
        int pocq = 0, x, maxi = -1, uk=0;
        for(int i = 0; i < m; i++)
            queri[i] = make_pair(queries[i][0], queries[i][1]);
        
        sort(queri, queri+m);
        
        while(q.size()) q.pop();

        for(int i = 0; i < n; i++){
            //deb(i);
            while(pocq < m){
                //cout << ""PRvi == ""  << queries[pocq][0] << endl;
                if(queri[pocq].first > i) break;

                q.push(queri[pocq].second);
                //cout << ""Pushujem "" << queries[pocq][1] << endl;
                pocq++;
            }
            
            uk += ps[i];
            //cout << i << "" "" << uk << endl;
            while(uk < nums[i]){
                if(q.size() == 0){
                    for(int j = 0; j <= nums.size(); j++)
                        ps[j] = 0;

                    return -1;
                }

                if(q.top() < i){
                    for(int j = 0; j <= nums.size(); j++)
                        ps[j] = 0;
                    return -1;
                }
                
                uk++;
                ps[q.top()+1]--;
                //cout << ""Na "" << q.top()+1 << "" == -1\n"";
                ret--;
                q.pop();
            }
            //cout << endl;
        }

        for(int j = 0; j <= n; j++)
            ps[j] = 0;
        

        return ret;
    }
};
",1460893267
4bP7qaO8Qi,4bP7qaO8Qi,715,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        pre1 = [0]
        pre2 = [0]
        for i in nextCost:
            pre1.append(i+pre1[-1])
        for i in previousCost:
            pre2.append(i+pre2[-1])
        n = len(s)
        ans = 0
        for i in range(n):
            a,b = ord(s[i])-97, ord(t[i])-97
            if a==b:
                continue
            elif a<b:
                mn1 = pre1[b]-pre1[a]
                # print(mn1, pre2[a]+pre2[-1]-pre2[b], a,b)
                mn1 = min(mn1, pre2[a+1]+pre2[-1]-pre2[b+1])
                ans+=mn1
            else:
                mn2 = pre2[a+1]-pre2[b+1]
                # print(mn2, pre1[-1]-pre1[a]+pre1[b], a,b)
                mn2 = min(mn2, pre1[-1]-pre1[a]+pre1[b])
                ans+=mn2
        return ans
""""""
48
9+9+9+15+6

""ccdbbcaadb""
""aadbbdaaac""
[6,6,9,8,2,4,10,10,6,4,9,5,5,5,2,7,9,7,4,1,4,10,1,5,2,4]
[0,4,5,6,7,10,5,5,8,1,1,10,7,8,10,8,7,2,3,3,6,3,0,6,4,0]

""""""
                ",1460866754
4bP7qaO8Qi,4bP7qaO8Qi,715,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cnt =0 
        curr =10
        while n>=curr:
            n-=curr
            curr-=1
            cnt+=1
        if cnt%2:
            return True
        return False
            ",1460798270
4bP7qaO8Qi,4bP7qaO8Qi,715,3647,python3,"class SegmentTree:
    def __init__(self, size):
        self.n = size
        self.tree = [0] * (4 * size)
        self.lazy = [0] * (4 * size)

    def push_down(self, node, l, r):
        if self.lazy[node] != 0:
            self.tree[node] += self.lazy[node]
            if l != r:
                self.lazy[2 * node] += self.lazy[node]
                self.lazy[2 * node + 1] += self.lazy[node]
            self.lazy[node] = 0

    def build(self, allowed, node, l, r):
        self.push_down(node, l, r)
        if l == r:
            self.tree[node] = allowed[l]
        else:
            mid = l + (r - l) // 2
            self.build(allowed, 2 * node, l, mid)
            self.build(allowed, 2 * node + 1, mid + 1, r)
            self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])

    def query_min(self, node, l, r, ql, qr):
        self.push_down(node, l, r)
        if qr < l or ql > r:
            return float('inf')
        if ql <= l and qr >= r:
            return self.tree[node]
        mid = l + (r - l) // 2
        return min(self.query_min(2 * node, l, mid, ql, qr),
                   self.query_min(2 * node + 1, mid + 1, r, ql, qr))

    def decrement_range(self, node, l, r, ql, qr):
        self.push_down(node, l, r)
        if ql > r or qr < l:
            return
        if ql <= l and qr >= r:
            self.lazy[node] -= 1
            self.push_down(node, l, r)
            return
        mid = l + (r - l) // 2
        self.decrement_range(2 * node, l, mid, ql, qr)
        self.decrement_range(2 * node + 1, mid + 1, r, ql, qr)
        self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])


class Solution:
    def maxRemoval(self, nums, queries):
        n = len(nums)
        m = len(queries)
        allowed = [0] * n
        current = 0
        prefix = [0] * (n + 1)
        for l, r in queries:
            prefix[l] += 1
            prefix[r + 1] -= 1
        for i in range(n):
            current += prefix[i]
            allowed[i] = current - nums[i]
            if allowed[i] < 0:
                return -1
        sq = sorted(queries, key=lambda q: (q[1] - q[0] + 1, q[0]))
        seg = SegmentTree(n)
        seg.build(allowed, 1, 0, n - 1)
        cnt = 0
        for l, r in sq:
            mn = seg.query_min(1, 0, n - 1, l, r)
            if mn >= 1:
                seg.decrement_range(1, 0, n - 1, l, r)
                cnt += 1
        return cnt
",1460915506
Dracaarys,Dracaarys,716,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long int ans = 0;
        int n = s.length();
        
        for(int i=0;i<n;i++){
            if(s[i]!=t[i]){
                long long int currAnsLeft = 0;
                long long int currAnsRight = 0;
                int currIdxLeft = s[i]-'a';
                int currIdxRight = s[i]-'a';
                int reqdIdx = t[i]-'a';
                while(currIdxLeft!=reqdIdx && currIdxRight!=reqdIdx){
                    currAnsLeft = 1LL*previousCost[currIdxLeft--]+currAnsLeft;
                    currAnsRight = 1LL*nextCost[currIdxRight++]+currAnsRight;
                    currIdxLeft+=26;
                    currIdxRight+=26;
                    currIdxLeft%=26;
                    currIdxRight%=26;
                }
                // Left
                while(currIdxLeft!=reqdIdx ){
                    currAnsLeft = 1LL*previousCost[currIdxLeft--]+currAnsLeft;
                    // currAnsRight = 1LL*nextCost[currIdxRight++]+currAnsRight;
                    currIdxLeft+=26;
                    // currIdxRight+=26;
                    currIdxLeft%=26;
                    // currIdxRight%=26;
                }
                
                while(currIdxRight!=reqdIdx){
                    // currAnsLeft = 1LL*previousCost[currIdxLeft--]+currAnsLeft;
                    currAnsRight = 1LL*nextCost[currIdxRight++]+currAnsRight;
                    // currIdxLeft+=26;
                    currIdxRight+=26;
                    // currIdxLeft%=26;
                    currIdxRight%=26;
                }
                
                ans = 1LL*min(currAnsLeft,currAnsRight) + ans;
            }
        }
        
        return ans;
    }
};",1460833809
Dracaarys,Dracaarys,716,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int alice = 1;
        int currReqd = 10;
        while(currReqd<=n){
            alice=!alice;
            n-=currReqd;
            currReqd--;
        }
            
            
        return !alice;
    }
};",1460800824
Dracaarys,Dracaarys,716,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

struct Node {
    int min_val;
    bool has_lazy;
    int lazy_val;

    Node() : min_val(INT32_MAX), has_lazy(false), lazy_val(0) {}
};

class LazySegmentTree {
private:
    int n;
    vector<Node> segTree;
    vector<int> A;

    void build(int node, int l, int r) {
        if (l == r) {
            segTree[node].min_val = A[l];
            return;
        }
        int mid = (l + r) / 2;
        build(2 * node + 1, l, mid);
        build(2 * node + 2, mid + 1, r);
        segTree[node].min_val = min(segTree[2 * node + 1].min_val, segTree[2 * node + 2].min_val);
    }

    void apply(int node, int l, int r, int val) {
        segTree[node].min_val += val;
        if (segTree[node].has_lazy) {
            segTree[node].lazy_val += val;
        }
        else {
            segTree[node].has_lazy = true;
            segTree[node].lazy_val = val;
        }
    }

    void push(int node, int l, int r) {
        if (segTree[node].has_lazy) {
            int mid = (l + r) / 2;
            apply(2 * node + 1, l, mid, segTree[node].lazy_val);
            apply(2 * node + 2, mid + 1, r, segTree[node].lazy_val);
            segTree[node].has_lazy = false;
            segTree[node].lazy_val = 0;
        }
    }

    void pull(int node) {
        segTree[node].min_val = min(segTree[2 * node + 1].min_val, segTree[2 * node + 2].min_val);
    }

public:
    LazySegmentTree(int size, const vector<int>& input) {
        n = size;
        A = input;
        segTree.assign(4 * n, Node());
        build(0, 0, n - 1);
    }

    void range_update(int node, int l, int r, int L, int R, int X) {
        if (R < l || L > r) {
            return;
        }
        if (L <= l && r <= R) {
            apply(node, l, r, X);
            return;
        }
        push(node, l, r);
        int mid = (l + r) / 2;
        range_update(2 * node + 1, l, mid, L, R, X);
        range_update(2 * node + 2, mid + 1, r, L, R, X);
        pull(node);
    }

    int range_min_query(int node, int l, int r, int L, int R) {
        if (R < l || L > r) {
            return INT32_MAX;
        }
        if (L <= l && r <= R) {
            return segTree[node].min_val;
        }
        push(node, l, r);
        int mid = (l + r) / 2;
        int left_min = range_min_query(2 * node + 1, l, mid, L, R);
        int right_min = range_min_query(2 * node + 2, mid + 1, r, L, R);
        return min(left_min, right_min);
    }

    void update(int L, int R, int X) {
        range_update(0, 0, n - 1, L, R, X);
    }

    int query(int L, int R) {
        return range_min_query(0, 0, n - 1, L, R);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size();
        int m = q.size();
        vector<int> diffArray(n+1,0);
        vector<array<int,3>> lenSort;
        
        for(auto i:q){
            diffArray[i[0]]+=1;
            diffArray[i[1]+1]-=1;
            lenSort.push_back({i[1]-i[0]+1,i[0],i[1]});
        }
        
        sort(lenSort.begin(),lenSort.end());
        if(diffArray[0]<nums[0]) return -1;
        vector<int> arr(n,0);
        arr[0] = diffArray[0]-nums[0];
        for(int i=1;i<n;i++){
            diffArray[i]+=diffArray[i-1];
            if(diffArray[i]<nums[i]) return -1;
            arr[i] = diffArray[i]-nums[i];
        }
        
        LazySegmentTree tree = LazySegmentTree(n,arr);
        int ans = 0;
        for(int i=0;i<m;i++){
            auto it = lenSort[i];
            int getMin = tree.query(it[1],it[2]);
            if(getMin>0){
                ans++;
                tree.update(it[1],it[2],-1);
            }
        }
        return ans;
    }
};",1460910058
C Shanmukh Siva Sai,shanmudhanu123,717,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0, i, j, temp1, temp2;

        for(i=0; i<s.length(); i++){

            int u = s[i] - 'a';
            int v = t[i] - 'a';

            if(u==v) continue;

            temp1 = 0, temp2 = 0;

            if(u > v){
                for(j=u; j!=v; j--) temp1 += previousCost[j];
                for(j=u; j!=v; j=(j+1)%26) temp2 += nextCost[j];
            }
            else{
                for(j=u; j!=v; j=(j-1+26)%26) temp1 += previousCost[j];
                for(j=u; j!=v; j++) temp2 += nextCost[j];
            }

            ans += min(temp1, temp2);
        }

        return ans;
    }
};",1460836773
C Shanmukh Siva Sai,shanmudhanu123,717,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int i=0, x=10;

        while(n>=x){
            n -= x;
            x--;
            if(i) i=0;
            else i=1;
        }

        //cout << i << '\n';

        if(i) return true;
        return false;
    }
};",1460808166
C Shanmukh Siva Sai,shanmudhanu123,717,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        multiset<int> s1, s2;
        int ans = 0;

        sort(queries.begin(), queries.end());

        int i, j, n=nums.size();

        j=0;
        for(i=0; i<n; i++){

            while(j<queries.size() && queries[j][0]<=i){
                //cout << j << "" "" << queries[j][0] << "" "" << i << '\n';
                s2.insert(queries[j++][1]);
            }

            //cout << ""*******\n"";

            //cout << s1.size() << "" "" << s2.size() << '\n';

            while(s1.size()<nums[i] && s2.size()){
                s1.insert(*(s2.rbegin()));
                s2.erase(--s2.end());
            }

            //cout << s1.size() << "" "" << s2.size() << '\n';

            if(s1.size()<nums[i]) return -1;

            while(s2.size() && *(s2.begin())<=i){
                s2.erase(s2.begin());
                ans++;
            }

            //cout << s1.size() << "" "" << s2.size() << '\n';

            while(s1.size() && *(s1.begin())<=i){
                s1.erase(s1.begin());
            }

            //cout << s1.size() << "" "" << s2.size() << '\n';

            //cout << ""&&&&&&\n"";
        }

        return ans;
    }
};",1460899462
i86032,i86032,718,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';
            int target = t[i] - 'a';

            if (start == target) continue;

            int forwardSteps = (target - start + 26) % 26;
            int backwardSteps = (start - target + 26) % 26;

            long long forwardCost = 0, backwardCost = 0;

            for (int j = 0; j < forwardSteps; ++j)
                forwardCost += nextCost[(start + j) % 26];

            for (int j = 0; j < backwardSteps; ++j)
                backwardCost += previousCost[(start - j + 26) % 26];

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460797637
i86032,i86032,718,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) {
            return false;
        }
        int remaining = n - 10;
        if (remaining < 9) {
            return true;
        }
        remaining -= 9;
        if (remaining < 8) {
            return false;
        }
        remaining -= 8;
        if (remaining < 7) {
            return true;
        }
        remaining -= 7;
        if (remaining < 6) {
            return false;
        }
        remaining -= 6;
        if (remaining < 5) {
            return true;
        }
        remaining -= 5;
        if (remaining < 4) {
            return false;
        }
        remaining -= 4;
        if (remaining < 3) {
            return true;
        }
        remaining -= 3;
        if (remaining < 2) {
            return false;
        }
        remaining -= 2;
        if (remaining < 1) {
            return true;
        }
        remaining -= 1;
        return false;
    }
};
",1460807006
i86032,i86032,718,3647,cpp,"
class Solution {
public:
    int maxRemoval(vector<int>& v1, vector<vector<int>>& v2) {
        int n = v1.size();
        int m = v2.size();
        
        vector<int> coverage = calculateCoverage(n, v2);
        if (!isFeasible(v1, coverage, n)) return -1;
        
        vector<tuple<int, int, int>> queries_with_id = prepareQueries(v2, m);
        sortQueries(queries_with_id);
        
        return processQueries(v1, coverage, queries_with_id, n, m);
    }

private:
    vector<int> calculateCoverage(int n, vector<vector<int>>& v2) {
        vector<int> coverage(n + 1, 0);
        applyCoverage(v2, coverage, n);
        accumulateCoverage(coverage, n);
        return coverage;
    }
    
    void applyCoverage(vector<vector<int>>& v2, vector<int>& coverage, int n) {
        int i = 0;
        while (i < v2.size()) {
            int l = v2[i][0];
            int r = v2[i][1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
            i++;
        }
    }
    
    void accumulateCoverage(vector<int>& coverage, int n) {
        int i = 1;
        while (i < n) {
            coverage[i] += coverage[i - 1];
            i++;
        }
    }
    
    bool isFeasible(vector<int>& v1, vector<int>& coverage, int n) {
        return checkCoverage(v1, coverage, n);
    }

    bool checkCoverage(vector<int>& v1, vector<int>& coverage, int n) {
        int i = 0;
        while (i < n) {
            if (coverage[i] < v1[i]) {
                return false;
            }
            i++;
        }
        return true;
    }
    
    vector<tuple<int, int, int>> prepareQueries(vector<vector<int>>& v2, int m) {
        vector<tuple<int, int, int>> queries_with_id;
        queries_with_id.reserve(m);
        insertQueries(v2, queries_with_id, m);
        return queries_with_id;
    }
    
    void insertQueries(vector<vector<int>>& v2, vector<tuple<int, int, int>>& queries_with_id, int m) {
        int i = 0;
        while (i < m) {
            queries_with_id.emplace_back(v2[i][0], v2[i][1], i);
            i++;
        }
    }
    
    void sortQueries(vector<tuple<int, int, int>>& queries_with_id) {
        sort(queries_with_id.begin(), queries_with_id.end(), compareQueries);
    }
    
    static bool compareQueries(const tuple<int, int, int>& a, const tuple<int, int, int>& b) {
        if (get<0>(a) == get<0>(b)) {
            return get<1>(a) > get<1>(b);
        }
        return get<0>(a) < get<0>(b);
    }
    
    int processQueries(vector<int>& v1, vector<int>& coverage, vector<tuple<int, int, int>>& queries_with_id, int n, int m) {
        priority_queue<pair<int, int>> heap;
        vector<int> add(n + 1, 0);
        int current_add = 0;
        unordered_set<int> selected;
        
        int pointer = 0;
        return processCoverage(v1, coverage, queries_with_id, heap, add, current_add, selected, pointer, n, m);
    }
    
    int processCoverage(vector<int>& v1, vector<int>& coverage, vector<tuple<int, int, int>>& queries_with_id, priority_queue<pair<int, int>>& heap, vector<int>& add, int current_add, unordered_set<int>& selected, int pointer, int n, int m) {
        int i = 0;
        while (i < n) {
            current_add += add[i];
            addQueriesToHeap(i, queries_with_id, heap, pointer, m);
            removeExpiredQueriesFromHeap(heap, i);
            
            int current_coverage = current_add;
            if (current_coverage < v1[i]) {
                int need = v1[i] - current_coverage;
                addQueriesToSelect(need, heap, add, i, current_add, selected, n);
            }
            i++;
        }
        
        return m - selected.size();
    }
    
    void addQueriesToHeap(int i, vector<tuple<int, int, int>>& queries_with_id, priority_queue<pair<int, int>>& heap, int& pointer, int m) {
        while (pointer < m && get<0>(queries_with_id[pointer]) <= i) {
            int end = get<1>(queries_with_id[pointer]);
            int qid = get<2>(queries_with_id[pointer]);
            heap.emplace(end, qid);
            pointer++;
        }
    }
    
    void removeExpiredQueriesFromHeap(priority_queue<pair<int, int>>& heap, int i) {
        while (!heap.empty() && heap.top().first < i) {
            heap.pop();
        }
    }
    
    void addQueriesToSelect(int need, priority_queue<pair<int, int>>& heap, vector<int>& add, int i, int& current_add, unordered_set<int>& selected, int n) {
        int j = 0;
        while (j < need) {
            if (heap.empty()) {
                return;
            }
            auto top = heap.top();
            heap.pop();
            int selected_end = top.first;
            int qid = top.second;
            selected.insert(qid);
            updateAddArray(add, selected_end, n);
            current_add += 1;
            j++;
        }
    }
    
    void updateAddArray(vector<int>& add, int selected_end, int n) {
        add[selected_end + 1] -= 1;
    }
};
",1460905079
Tarek Rahman,tarek255,721,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
     long long cost = 0;
    int n = s.length();
    for (int i = 0; i < n;i++) {
    int from = s[i]-'a';
int to = t[i]-'a';
        
if (from == to){
            continue;
        }
        int fstep = (to >= from) ? (to - from) : (26 - from + to);
long long fcost = 0;
        for (int j= 0; j< fstep; j++) {
fcost += nextCost[(from + j) % 26];
        }
        
        int bstep = (from>=to)? (from - to):(from+ 26- to);
        long long bcost = 0;
        for (int j= 0;j< bstep; j++) {
            bcost += previousCost[(from-j+26)%26];
        }
        cost += min(fcost,bcost);
    }

    return cost;
    }
};",1460847601
Tarek Rahman,tarek255,721,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10) return false;
        int tot = 0;
        int cur=10;
        int guro=1;
        while(tot + cur <= n){
            tot += cur;
            cur--;
            guro++;
        }
        return (guro % 2 == 0);
    }
};",1460836102
Tarek Rahman,tarek255,721,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size(), m = queries.size();

        vector<int> coverage(n + 1, 0);
        for (auto& q : queries) {
            coverage[q[0]]++;
            if (q[1] + 1 < n) coverage[q[1] + 1]--;
        }

        
        for (int i = 1; i < n; ++i) coverage[i] += coverage[i - 1];

        
        vector<int> allowed(n, 0);
        for (int i = 0; i < n; ++i) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) return -1; 
        }

       
        vector<pair<int, int>> sorted_queries;
        for (auto& q : queries)
            sorted_queries.emplace_back(q[0], q[1]);
        sort(sorted_queries.begin(), sorted_queries.end(), [&](auto& a, auto& b) {
            int len_a = a.second - a.first, len_b = b.second - b.first;
            return len_a != len_b ? len_a < len_b : a.first < b.first;
        });

        
        SegmentTree st(n);
        st.build(allowed, 1, 0, n - 1);

        
        int removed = 0;
        for (auto& [l, r] : sorted_queries) {
            if (st.query_min(1, 0, n - 1, l, r) >= 1) {
                st.decrement_range(1, 0, n - 1, l, r);
                removed++;
            }
        }
        return removed;
    }

    
    struct SegmentTree {
        vector<int> tree, lazy;
        SegmentTree(int n) : tree(4 * n), lazy(4 * n) {}

        void push_down(int node, int l, int r) {
            if (lazy[node]) {
                tree[node] += lazy[node];
                if (l != r) {
                    lazy[2 * node] += lazy[node];
                    lazy[2 * node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        void build(vector<int>& allowed, int node, int l, int r) {
            if (l == r) {
                tree[node] = allowed[l];
            } else {
                int mid = l + (r - l) / 2;
                build(allowed, 2 * node, l, mid);
                build(allowed, 2 * node + 1, mid + 1, r);
                tree[node] = min(tree[2 * node], tree[2 * node + 1]);
            }
        }

        int query_min(int node, int l, int r, int ql, int qr) {
            push_down(node, l, r);
            if (qr < l || ql > r) return INT_MAX;
            if (ql <= l && r <= qr) return tree[node];
            int mid = l + (r - l) / 2;
            return min(query_min(2 * node, l, mid, ql, qr),
                       query_min(2 * node + 1, mid + 1, r, ql, qr));
        }

        void decrement_range(int node, int l, int r, int ql, int qr) {
            push_down(node, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lazy[node]--;
                push_down(node, l, r);
                return;
            }
            int mid = l + (r - l) / 2;
            decrement_range(2 * node, l, mid, ql, qr);
            decrement_range(2 * node + 1, mid + 1, r, ql, qr);
            tree[node] = min(tree[2 * node], tree[2 * node + 1]);
        }
    };
};
",1460916594
SHIVAM PANDEY,ashishivam,722,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long cost=0;
        long long sumnext=0,sumprev=0;
        vector<long long>nextcost(26,0),previouscost(26,0);
        sumnext=accumulate(nextCost.begin(),nextCost.end(),sumnext);
        sumprev=accumulate(previousCost.begin(),previousCost.end(),sumprev);
        for(int i=0;i<26;i++){
          int x=nextCost[i];
           nextcost[i]=sumnext;
           sumnext-=x;
        }
        for(int i=25;i>=0;i--){
           int y=previousCost[i];
           previouscost[i]=sumprev;
           sumprev-=y;
        }
        for(int i=0;i<s.size();i++){
            if(s[i]!=t[i]){
               int x='a';
               long long next=nextcost[s[i]%x]-nextcost[t[i]%x];
                if(t[i]<s[i]){
                    next=nextcost[0]+next;
                }
               long long prev=previouscost[s[i]%x]-previouscost[t[i]%x];
                if(t[i]>s[i]){
                    prev=previouscost[25]+prev;
                }
                cost+=min(next,prev);
            }
        }
        return cost;
    }
};",1460874952
SHIVAM PANDEY,ashishivam,722,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice =true;
        int prev=9;
        if(n<10){
            return false;
        }
        n=n-10;
        while(n>=prev){
            n=n-prev;
            prev=prev-1;
            alice=!alice;
            
        }
        return alice;
    }
};",1460804233
SHIVAM PANDEY,ashishivam,722,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int m = queries.size();
        int z;
        vector<int> diff(n + 1, 0);
        for (auto& q : queries) {
            int l = q[0];
            int r = q[1];
            diff[l] += 1;
            if (r + 1 < n) diff[r + 1] -= 1;
        }
        vector<int> cover(n, 0);
        cover[0] = diff[0];
        for (int i = 1; i < n; i++) {
            cover[i] = cover[i - 1] + diff[i];
        }

        vector<int> allow(n, 0);
        for (int i = 0; i < n; i++) {
            allow[i] = cover[i] - nums[i];
            if (allow[i] < 0) return -1;
        }
        vector<pair<int, int>> sorted;
        for (auto& q : queries) {
            sorted.emplace_back(q[0], q[1]);
        }
        sort(sorted.begin(), sorted.end(), [&](const pair<int, int>& a, const pair<int, int>& b) {
            int lenA = a.second - a.first + 1;
            int lenB = b.second - b.first + 1;
            if (lenA != lenB) return lenA < lenB;
            return a.first < b.first;
        });

        Tree st(n);
        st.buildTree(allow, 1, 0, n - 1);


        int totalRemovals = 0;
        for (auto& [l, r] : sorted) {
            if (st.getMin(1, 0, n - 1, l, r) > 0) {
                st.updateRange(1, 0, n - 1, l, r);
                totalRemovals++;
            }
        }

        return totalRemovals;
    }

    struct Tree {
        vector<int> segTree, lazy;
        int size;

        Tree(int n) {
            size = n;
            segTree.assign(4 * n, 0);
            lazy.assign(4 * n, 0);
        }

        void applyLazy(int idx, int l, int r) {
            if (lazy[idx] != 0) {
                segTree[idx] += lazy[idx];
                if (l != r) {
                    lazy[2 * idx] += lazy[idx];
                    lazy[2 * idx + 1] += lazy[idx];
                }
                lazy[idx] = 0;
            }
        }

 vector<string> bring(const vector<vector<int>>& queries) {
        vector<string> result;
        for (auto& q : queries) {
            result.push_back(""["" + to_string(q[0]) + "", "" + to_string(q[1]) + ""]"");
        }
        return result;
    }

        void buildTree(vector<int>& arr, int idx, int l, int r) {
            if (l == r) {
                segTree[idx] = arr[l];
                return;
            }
            int mid = (l + r) / 2;
            buildTree(arr, 2 * idx, l, mid);
            buildTree(arr, 2 * idx + 1, mid + 1, r);
            segTree[idx] = min(segTree[2 * idx], segTree[2 * idx + 1]);
        }

        int getMin(int idx, int l, int r, int ql, int qr) {
            applyLazy(idx, l, r);
            if (qr < l || ql > r) return INT32_MAX;
            if (ql <= l && r <= qr) return segTree[idx];
            int mid = (l + r) / 2;
            return min(getMin(2 * idx, l, mid, ql, qr), getMin(2 * idx + 1, mid + 1, r, ql, qr));
        }

        void updateRange(int idx, int l, int r, int ql, int qr) {
            applyLazy(idx, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lazy[idx] -= 1;
                applyLazy(idx, l, r);
                return;
            }
            int mid = (l + r) / 2;
            updateRange(2 * idx, l, mid, ql, qr);
            updateRange(2 * idx + 1, mid + 1, r, ql, qr);
            segTree[idx] = min(segTree[2 * idx], segTree[2 * idx + 1]);
        }
    };
};
",1460916743
Aamir Kharodawala,aamirkharoda,723,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        ll ans = 0;
        for(int i=0; i<s.size(); ++i)
        {
            ll fc = 0, bc = 0;
            char temp = s[i];
            while(temp != t[i])
            {
                fc += nc[temp-'a'];
                temp = (temp - 'a' + 1)%26 + 'a';
            }
            temp = s[i];
            while(temp != t[i])
            {
                bc += pc[temp-'a'];
                temp = (temp - 'a' + 25)%26 + 'a';
            }
            ans += min(fc,bc);
        }
        return ans;
    }
};",1460814617
Aamir Kharodawala,aamirkharoda,723,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int val = 10;
        while(n >= 0)
        {
            n -= val;
            --val;
        }
        return (val+1)%2;
    }
};",1460799739
Aamir Kharodawala,aamirkharoda,723,3647,python3,"class SegmentTree:
    def __init__(self, array):
        self.n = len(array)
        self.tree = [0] * (4 * self.n)  
        self.lazy = [0] * (4 * self.n)  
        self._build(array, 0, 0, self.n - 1)  
    def _apply_lazy(self, node, start, end):
        if self.lazy[node] != 0:
            self.tree[node] += self.lazy[node]
            if start != end:
                self.lazy[2 * node + 1] += self.lazy[node]
                self.lazy[2 * node + 2] += self.lazy[node]
            self.lazy[node] = 0
    def _build(self, array, node, start, end):
        if start == end:
            self.tree[node] = array[start]
        else:
            mid = (start + end) // 2
            self._build(array, 2 * node + 1, start, mid)  
            self._build(array, 2 * node + 2, mid + 1, end)  
            self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])
    def _update_range(self, node, start, end, l, r, value):
        self._apply_lazy(node, start, end)
        if start > r or end < l:
            return
        if l <= start and end <= r:
            self.tree[node] += value
            if start != end:
                self.lazy[2 * node + 1] += value
                self.lazy[2 * node + 2] += value
            return
        mid = (start + end) // 2
        self._update_range(2 * node + 1, start, mid, l, r, value)
        self._update_range(2 * node + 2, mid + 1, end, l, r, value)
        self.tree[node] = max(self.tree[2 * node + 1], self.tree[2 * node + 2])
    def _query_max(self, node, start, end, l, r):
        self._apply_lazy(node, start, end)
        if start > r or end < l:
            return float('-inf')
        if l <= start and end <= r:
            return self.tree[node]
        mid = (start + end) // 2
        left_max = self._query_max(2 * node + 1, start, mid, l, r)
        right_max = self._query_max(2 * node + 2, mid + 1, end, l, r)
        return max(left_max, right_max)
    def update_range(self, l, r, value):
        self._update_range(0, 0, self.n - 1, l, r, value)
    def query_max(self, l, r):
        return self._query_max(0, 0, self.n - 1, l, r)
class Solution:
    def maxRemoval(self, nums: List[int], q : List[List[int]]) -> int:
        n = len(nums)
        arr = [0] * (n + 1)
        for query in q:
            arr[query[0]] += 1
            if query[1] + 1 < len(arr):
                arr[query[1] + 1] -= 1
        for i in range(1, n + 1):
            arr[i] += arr[i - 1]
        for i in range(n):
            if nums[i] - arr[i] > 0:
                return -1
            nums[i] -= arr[i]
        seg_tree = SegmentTree(nums)
        qrs = [[it[1]-it[0]+1,[it[0],it[1]]] for it in q]
        qrs.sort()
        ans = 0
        for it in qrs :
            if seg_tree.query_max(it[1][0],it[1][1]) < 0 :
                ans += 1
                seg_tree.update_range(it[1][0], it[1][1], 1)
        return ans",1460911294
TEJA RAM,tejaramjanee,725,3591,cpp,"class Solution {
public:
    long long shiftDistance(string a, string b, vector<int>& nCost, vector<int>& pCost) {
        long long res = 0;
        int len = a.size();
        
        int idx = 0;
        while (idx < len) {
            int cur = a[idx] - 'a';
            int target = b[idx] - 'a';
            
            if (cur != target) {
                long long fCost = calcCost(cur, target, nCost, true);
                long long bCost = calcCost(cur, target, pCost, false);
                res += min(fCost, bCost);
            }
            idx++;
        }
        
        return res;
    }
    
    long long calcCost(int start, int end, vector<int>& cost, bool isForward) {
        int steps = 0;
        if (isForward) {
            steps = (end - start + 26) % 26;
        } else {
            steps = (start - end + 26) % 26;
        }
        
        long long totalCost = 0;
        int tmp = start;
        int cnt = 0;
        
        while (cnt < steps) {
            totalCost += cost[tmp];
            if (isForward) {
                tmp = (tmp + 1) % 26;
            } else {
                tmp = (tmp - 1 + 26) % 26;
            }
            cnt++;
        }
        
        return totalCost;
    }
};
",1460828436
TEJA RAM,tejaramjanee,725,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
         int x = 10;
        while (n > 0) {
            if (n < x) return false;
            n -= x;
            x--;
            if (n < x) return true;
            n -= x;
            x--;
        }
        return false;
    }
};",1460796228
TEJA RAM,tejaramjanee,725,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    void computeCoverage(vector<int>& nums, vector<vector<int>>& q, vector<int>& cov) {
        int n = nums.size();
        for (auto &v : q) {
            int l = v[0], r = v[1];
            cov[l]++;
            if (r + 1 < n) cov[r + 1]--;
        }
        for (int i = 1; i < n; i++) cov[i] += cov[i - 1];
    }












// for(inti=0
















































// )
    bool validateCoverage(vector<int>& nums, vector<int>& cov) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (cov[i] < nums[i]) return false;
        }
        return true;
    }

    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size(), m = q.size();
        vector<int> cov(n + 1, 0);

        computeCoverage(nums, q, cov);
        if (!validateCoverage(nums, cov)) return -1;

        vector<tuple<int, int, int>> tq;
        for (int i = 0; i < m; i++) tq.emplace_back(q[i][0], q[i][1], i);
        sort(tq.begin(), tq.end(), [](auto &a, auto &b) {
            return get<0>(a) == get<0>(b) ? get<1>(a) > get<1>(b) : get<0>(a) < get<0>(b);
        });

        vector<int> d(n + 1, 0);
        unordered_set<int> sel;
        priority_queue<pair<int, int>> h;
        int p = 0, cur = 0;

        for (int i = 0; i < n; i++) {
            cur += d[i];
            while (p < m && get<0>(tq[p]) <= i) {
                h.emplace(get<1>(tq[p]), get<2>(tq[p]));
                p++;
            }
            while (!h.empty() && h.top().first < i) h.pop();
            if (cur < nums[i]) {
                int req = nums[i] - cur;
                for (int j = 0; j < req; j++) {
                    if (h.empty()) return -1;
                    auto top = h.top(); h.pop();
                    sel.insert(top.second);
                    d[i]++;
                    if (top.first + 1 < n) d[top.first + 1]--;
                    cur++;
                }
            }
        }
        return m - sel.size();
    }
};
",1460917031
Anupam Shandilya,anupamshandilya28,726,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<vector<long long>> dist(26, vector<long long>(26, 1e15));

        for(auto c = 0; c < 26; ++c)
        {
            vector<long long> d(26, 1e15);
            d[c] = 0;

            priority_queue<pair<long long,long long>, vector<pair<long long,long long>>, greater<pair<long long,long long>>> pq;
            pq.push({0, c});

            while(!pq.empty())
            {
                auto [cost_u, u] = pq.top();
                pq.pop();

                if(cost_u > d[u]) continue;

                // Shift to the next character
                auto v = (u + 1) % 26;
                auto cost_v = cost_u + nextCost[u];
                if(cost_v < d[v])
                {
                    d[v] = cost_v;
                    pq.push({d[v], v});
                }

                // Shift to the previous character
                v = (u - 1 + 26) % 26;
                cost_v = cost_u + previousCost[u];
                if(cost_v < d[v])
                {
                    d[v] = cost_v;
                    pq.push({d[v], v});
                }
            }

            for(auto j = 0; j < 26; ++j)
            {
                dist[c][j] = d[j];
            }
        }

        long long total_cost = 0;
        for(auto i = 0u; i < s.size(); ++i)
        {
            auto s_index = s[i] - 'a';
            auto t_index = t[i] - 'a';

            total_cost += dist[s_index][t_index];
        }

        return total_cost;       
    }
};",1460818009
Anupam Shandilya,anupamshandilya28,726,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        vector<int> stones_sequence = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        int current_player = 0;

        for (auto stones : stones_sequence) {
            if (n >= stones) {
                n -= stones;
                if (n == 0) {
                    return current_player == 0;
                }
                current_player = 1 - current_player;
            } else {
                return current_player != 0;
            }
        }
        return current_player != 0; 
    }
};",1460800966
Anupam Shandilya,anupamshandilya28,726,3647,cpp,"class Solution {
public:    
template <typename s>
    class SGTree
    {
    public:
        using SizeType = std::size_t;

        SizeType N;
        std::vector<s> seg;
        std::vector<s> lazy;

        SGTree(SizeType _N) : N(_N), seg(4 * _N, 0), lazy(4 * _N, 0) {}

        void push(SizeType idx, SizeType low, SizeType high)
        {
            if (lazy[idx] != 0)
            {
                seg[idx] += lazy[idx];
                if (low != high)
                {
                    lazy[2 * idx + 1] += lazy[idx];
                    lazy[2 * idx + 2] += lazy[idx];
                }
                lazy[idx] = 0;
            }
        }

        void build(SizeType idx, SizeType low, SizeType high, const std::vector<s> &nums)
        {
            if (low == high)
            {
                seg[idx] = nums[low];
                return;
            }
            SizeType mid = low + (high - low) / 2;
            build(2 * idx + 1, low, mid, nums);
            build(2 * idx + 2, mid + 1, high, nums);
            seg[idx] = std::min(seg[2 * idx + 1], seg[2 * idx + 2]);
        }

        s query(SizeType idx, SizeType low, SizeType high, SizeType l, SizeType r)
        {
            push(idx, low, high);
            if (high < l || low > r)
                return std::numeric_limits<s>::max();
            if (low >= l && high <= r)
                return seg[idx];
            SizeType mid = low + (high - low) / 2;
            s left = query(2 * idx + 1, low, mid, l, r);
            s right = query(2 * idx + 2, mid + 1, high, l, r);
            return std::min(left, right);
        }

        void update(SizeType idx, SizeType low, SizeType high, SizeType l, SizeType r, s val)
        {
            push(idx, low, high);
            if (high < l || low > r)
                return;
            if (low >= l && high <= r)
            {
                lazy[idx] += val;
                push(idx, low, high);
                return;
            }
            SizeType mid = low + (high - low) / 2;
            update(2 * idx + 1, low, mid, l, r, val);
            update(2 * idx + 2, mid + 1, high, l, r, val);
            seg[idx] = std::min(seg[2 * idx + 1], seg[2 * idx + 2]);
        }

        void sg_build(const std::vector<s> &nums)
        {
            build(0, 0, N - 1, nums);
        }

        s sg_query(SizeType l, SizeType r)
        {
            return query(0, 0, N - 1, l, r);
        }

        void sg_update(SizeType l, SizeType r, s val)
        {
            update(0, 0, N - 1, l, r, val);
        }
    };

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();

        vector<int> coverage_changes(n + 2, 0);
        for (auto& query : queries) {
            int l = query[0];
            int r = query[1];
            coverage_changes[l] += 1;
            coverage_changes[r + 1] -= 1;
        }
        for (int i = 1; i < n + 2; ++i) {
            coverage_changes[i] += coverage_changes[i - 1];
        }

        for (int i = 0; i < n; ++i) {
            if (coverage_changes[i] < nums[i]) {                
                return -1;
            }
        }

        vector<int> surplus(n);
        for (int i = 0; i < n; ++i) {
            surplus[i] = coverage_changes[i] - nums[i];
        }

        SGTree<int> st(n);
        st.sg_build(surplus);
        
        vector<long long>prefix(n);
        
        long long sum=0;
        
        for(int i=0;i<n;i++) {
            sum+=nums[i];
            prefix[i]=sum;
        }

        vector<int> removed_queries;
        sort(queries.begin(),queries.end(),[&](const vector<int> &a,const vector<int> &b) {
            return prefix[a[1]]-prefix[a[0]]<prefix[b[1]]-prefix[b[0]];
        });
        for (int i = 0; i < q; ++i) {
            int l = queries[i][0];
            int r = queries[i][1];

            int min_surplus = st.sg_query(l, r);

            if (min_surplus > 0) {
                removed_queries.push_back(i);
                st.sg_update(l, r, -1);
            }
        }

        return removed_queries.size();
    }
};",1460906156
SANCHIT PANDEY,pandeySAN,730,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        def getCost(a: str, b: str, c: int) -> int:
            x = ord(a) - ord('a')
            y = ord(b) - ord('a')
            f = (y - x) % 26
            b = (x - y) % 26
            if f == 0:
                return 0
            f_sum = sum(nextCost[(x + i) % 26] for i in range(f))
            b_sum = sum(previousCost[(x - i + 26) % 26] for i in range(b))
            return min(f_sum, b_sum)
        
        z = 0
        n = len(s)
        for i in range(n):
            z += getCost(s[i], t[i], i)
        return z",1460821884
SANCHIT PANDEY,pandeySAN,730,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        i = 10
        while n > 0:
            if n < i:
                return False
            n -= i
            if n <= 0:
                return True
            j = i - 1
            if n < j:
                return True
            n -= j
            if n <= 0:
                return False
            i -= 2
        return False
",1460811809
SANCHIT PANDEY,pandeySAN,730,3647,python3,"from typing import List
import heapq

class Solution:
    def maxRemoval(self, a: List[int], b: List[List[int]]) -> int:
        n = len(a)
        m = len(b)
        
        c = [0] * (n + 1)
        for q in b:
            l, r = q[0], q[1]
            c[l] += 1
            if r + 1 < n:
                c[r + 1] -= 1
        
        for i in range(1, n):
            c[i] += c[i-1]
        
        for i in range(n):
            if c[i] < a[i]:
                return -1
        
        d = [(q[0], q[1], i) for i, q in enumerate(b)]
        d.sort(key=lambda x: (x[0], -x[1]))
        
        e = []
        f = [0] * (n + 1)
        g = 0
        h = set()
        
        i = d.copy()
        
        j = 0
        for k in range(n):
            g += f[k]
            
            while j < m and d[j][0] <= k:
                end, qid = d[j][1], d[j][2]
                heapq.heappush(e, (-end, qid))
                j += 1
            
            while e and -e[0][0] < k:
                heapq.heappop(e)
            
            l = g
            
            if l < a[k]:
                need = a[k] - l
                for _ in range(need):
                    if not e:
                        return -1
                    neg_end, qid = heapq.heappop(e)
                    selected_end = -neg_end
                    h.add(qid)
                    f[k] += 1
                    if selected_end + 1 < n:
                        f[selected_end + 1] -= 1
                    g += 1
        
        return m - len(h)
",1460901343
daniel03044,daniel03044,732,3591,cpp,"class Solution {
public:
    long long shiftDistance(string src, string tar, vector<int>& nextCost, vector<int>& prevCost) {
        // s -> t
        long long ans = 0;
        /*
        // src - target
        next: 1, 1, 1, 1
              4, 3, 2, 1
        prev: 1,1,1,1
              1,2,3,4
        */

        vector<long long> cum_next(26), cum_prev(26);
        cum_next[25] = nextCost[25];
        cum_prev[0] = prevCost[0];
        for (int i = 24; i >= 0; i--)
            cum_next[i] = cum_next[i+1] + nextCost[i];
        for (int i = 1; i < 26; i++) {
            cum_prev[i] = cum_prev[i-1] + prevCost[i];
        }
        for (int i = 0; i < src.size(); i++) {
            long long cost = 1e11;
            int s = src[i] - 'a', t = tar[i] - 'a';
            long long _next = cum_next[s] - cum_next[t];
            if (s > t) _next += cum_next[0];
            long long _prev = cum_prev[s] - cum_prev[t];
            if (t > s) _prev += cum_prev[25];
            ans += min(_next, _prev);
        }
        return ans;
    }
};",1460869613
daniel03044,daniel03044,732,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10;
        while (n >= cnt) {
            n -= cnt--;
        }
        return cnt % 2;

        
    }
};",1460801084
daniel03044,daniel03044,732,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {

        multiset<int> hold_queries; // selected queries in hand
        priority_queue<int> end_queries; // queries available now
        int query_i = 0, ans = 0; // the current queries, and ans

        sort(queries.begin(), queries.end());

        for (int i = 0; i < nums.size(); i++) {
            // discard hold_queries
            if (hold_queries.count(i-1)) {
                hold_queries.erase(i-1);
            }

            // add end_queries
            while (query_i < queries.size() && queries[query_i][0] <= i) {
                end_queries.push(queries[query_i][1]);
                query_i++;
            }

            // add hold_queries
            while (hold_queries.size() < nums[i]) {
                if (!end_queries.empty()) {
                    int v = end_queries.top();
                    end_queries.pop();
                    if (v < i) continue; // useless
                    hold_queries.insert(v);
                    ans++;
                }
                else return -1; // impossible
            }
        }

        // [start, end]
        // greedy algo

        return queries.size() - ans;
    }
};",1460901764
Arghadeep Das,das_codes,733,3591,cpp,"class Solution {
public:

    long long search(int start, int goal, vector<int>& nextCost, vector<int>& previousCost, int visited){
        if(start == goal)return 0;
        visited |= (1<<start);
        //two options
        // 1. forward
        int forw = start+1;
        if(forw >= 26) forw-=26;
        long long a = ((visited & (1<<forw)) ? LONG_MAX : nextCost[start] + search(forw, goal, nextCost, previousCost, visited));

        int bc = start-1;
        if(bc < 0)bc+=26;
        long long b = ((visited & (1<<bc)) ? LONG_MAX : previousCost[start] + search(bc, goal, nextCost, previousCost, visited));
        return min(a,b);
    }
    
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;

        int n = s.size();
        for(int i = 0; i < n; ++i){
            //difference
            //start index
            int a = s[i] - 'a';
            //end index
            int b = t[i] - 'a';
            ans += search(a, b, nextCost, previousCost,0);
        }
        return ans;
    }
};",1460828606
Arghadeep Das,das_codes,733,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        
        
        int k = 10;
        bool a = true;
        while(k > 0){
            if(n < k)return !a;
            n-=k;
            a = !a;
            k--;
        }
        return true;
    }
};",1460799340
Arghadeep Das,das_codes,733,3647,cpp,"class Solution {
public:

class compare{
    public:
bool operator()(const pair<int,int> &a, const pair<int,int> &b) const{
    return a.second > b.second || (a.second == b.second &&  a.first > b.first);
}
};

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int ans = queries.size();

        sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int>&b){
            return a[0] < b[0];
        });
        
        //available queries
        multiset<pair<int,int>, compare> x;

        //queries ending with
        unordered_map<int, vector<pair<int,int>>> endingWith;

        //taken currently
        multiset<pair<int,int>> taken;
        
        //query pointer
        int ptr = 0;
        
        for(int i = 0; i < n; ++i){
            //Update available queries
            while(ptr < queries.size() && queries[ptr][0] <= i){
                x.insert({queries[ptr][0], queries[ptr][1]});
                auto itr = endingWith.find(queries[ptr][1]);
                if(itr == endingWith.end()){
                    endingWith[queries[ptr][1]] = {{queries[ptr][0], queries[ptr][1]}};
                }else{
                    itr->second.push_back({queries[ptr][0], queries[ptr][1]});
                }
                ptr++;
            }

            //remove done queries
            auto itr = endingWith.find(i-1);
            if(itr != endingWith.end()){
                for(auto &y : itr->second){
                    auto temp = x.find(y);
                    x.erase(y);
                    auto temp2 = taken.find(y);
                    if(temp2 != taken.end())
                        taken.erase(temp2);
                }
            }

            //not enough overlap
           // cout << ""Taken: ""<< taken.size() << endl;
            //cout << ""Avail: ""<< x.size() << endl;
            //if satisfied continue
            if(taken.size() > nums[i])continue;
            
            int req =  nums[i] - taken.size();
            //cout << ""Req: ""<< req << endl;
            //take top few
            while(req > 0){
                req--;
                if(x.size() == 0){return -1;}
                //cout << ""Avail in loop: ""<< x.size() << endl;
                auto itr = x.begin();
                taken.insert(*itr);
                x.erase(itr);
                ans--;
            }
        }
       // cout << ""Ans: "" <<ans<< endl;
        return ans;
    }
};",1460907512
heroooo,heroooo,734,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nxt, vector<int>& prev) {
      int n = s.length();
    long long tot = 0;

    int i = 0; 
    while (i < n) {
        int st = s[i] - 'a';
        int tar = t[i] - 'a';

        if (st <= tar) {
            long long fwd = tar - st;
            long long fwdC = 0;
            for (int j = 0; j < fwd; j++)
                fwdC += nxt[(st + j) % 26];

            long long bwd = 26 - fwd;
            long long bwdC = 0;
            for (int j = 0; j < bwd; j++)
                bwdC += prev[(st - j + 26) % 26];

            tot += min(fwdC, bwdC);
        } else {
            long long bwd = st - tar;
            long long bwdC = 0;
            for (int j = 0; j < bwd; j++)
                bwdC += prev[(st - j + 26) % 26];

            long long fwd = 26 - bwd;
            long long fwdC = 0;
            for (int j = 0; j < fwd; j++)
                fwdC += nxt[(st + j) % 26];

            tot += min(fwdC, bwdC);
        }
        i++;
    }

    return tot;
}
};",1460850532
heroooo,heroooo,734,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
      int curr = 10;

    bool isAliceTurn = 1;

    while (n > 0) {
        if (n < curr) {
            return !isAliceTurn;
        }

    
        n -= curr;
        curr--;
        isAliceTurn = !isAliceTurn;
    }


    return !isAliceTurn;
   
    }
};",1460816616
heroooo,heroooo,734,3647,cpp,"class Solution {
public:

    int maxRemoval(vector<int>& nums, vector<vector<int>>& qrs) {
        int n = nums.size();
        int m = qrs.size();

        vector<int> cov(n + 1, 0);
        for (auto& q : qrs) {
            int l = q[0];
            int r = q[1];
            cov[l] += 1;
            if (r + 1 < n) {
                cov[r + 1] -= 1;
            }
        }

        int i = 1; 
        while(i < n) {
            cov[i] += cov[i - 1];
            i++;
        }
        cov.pop_back();

        vector<int> all(n, 0);
         i = 0; 
        while(i < n){
            all[i] = cov[i] - nums[i];
            if (all[i] < 0) {
                return -1;
            }
            i++;
        }

        vector<pair<int, int>> ord;
        ord.reserve(m);
        for (auto& q : qrs) {
            ord.emplace_back(q[0], q[1]);
        }
        sort(ord.begin(), ord.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            int la = a.second - a.first + 1;
            int lb = b.second - b.first + 1;
            if (la != lb) {
                return la < lb;
            }
            return a.first < b.first;
        });

        struct SegTree {
            int n;
            vector<int> tr;
            vector<int> laz;

            SegTree(int sz) {
                n = sz;
                tr.assign(4 * n, 0);
                laz.assign(4 * n, 0);
            }

            void push(int nd, int l, int r) {
                if (laz[nd] != 0) {
                    tr[nd] += laz[nd];
                    if (l != r) {
                        laz[2 * nd] += laz[nd];
                        laz[2 * nd + 1] += laz[nd];
                    }
                    laz[nd] = 0;
                }
            }

            void build(vector<int>& arr, int nd, int l, int r) {
                push(nd, l, r);
                if (l == r) {
                    tr[nd] = arr[l];
                } else {
                    int mid = l + (r - l) / 2;
                    build(arr, 2 * nd, l, mid);
                    build(arr, 2 * nd + 1, mid + 1, r);
                    tr[nd] = min(tr[2 * nd], tr[2 * nd + 1]);
                }
            }

            int qryMin(int nd, int l, int r, int ql, int qr) {
                push(nd, l, r);
                if (qr < l || ql > r) return INT32_MAX;
                if (ql <= l && r <= qr) return tr[nd];
                int mid = l + (r - l) / 2;
                return min(qryMin(2 * nd, l, mid, ql, qr),
                           qryMin(2 * nd + 1, mid + 1, r, ql, qr));
            }

            void decRng(int nd, int l, int r, int ql, int qr) {
                push(nd, l, r);
                if (qr < l || ql > r) return;
                if (ql <= l && r <= qr) {
                    laz[nd] -= 1;
                    push(nd, l, r);
                    return;
                }
                int mid = l + (r - l) / 2;
                decRng(2 * nd, l, mid, ql, qr);
                decRng(2 * nd + 1, mid + 1, r, ql, qr);
                tr[nd] = min(tr[2 * nd], tr[2 * nd + 1]);
            }
        };

        SegTree st(n);
        st.build(all, 1, 0, n - 1);

        int rem = 0;
        for (auto& [l, r] : ord) {
            int cur = st.qryMin(1, 0, n - 1, l, r);
            if (cur >= 1) {
                st.decRng(1, 0, n - 1, l, r);
                rem++;
            }
        }

        return rem;
    }
};

",1460913195
Siddhant Deshwal,siddhantdeshwal1,735,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& next, vector<int>& prev) {
        long long totalCost = 0 ;

        int n = s.size() ;
        
        for (int i = 0 ; i < n ; i++)
            {
                int start = s[i] - 'a';
                int end = t[i] - 'a';
        
                long long forwardCost = 0, backwardCost = 0;
                for (int j = start; j != end; j = (j + 1) % 26) {
                    forwardCost += next[j];
                }
                for (int j = start; j != end; j = (j - 1 + 26) % 26) {
                    backwardCost += prev[j];
                }
        
                totalCost += min(forwardCost, backwardCost);
            }
        
        return totalCost ;
    }
};",1460815617
Siddhant Deshwal,siddhantdeshwal1,735,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) return false ;
        n -= 10 ;
        int turn = 1 ;
        for (int i = 9 ; i > 0 ; i--)
            {
                if (n < i) 
                {
                    return turn ;
                }
                turn ^= 1 ;
                n -= i ;
                // cout << n << "" "" ;
            }
        return turn ;
    }
};",1460800900
Siddhant Deshwal,siddhantdeshwal1,735,3647,cpp,"class SegmentTree {
    vector<int> tree, lazy;
    int n;

    void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            // Apply the lazy value to the current segment
            tree[node] += lazy[node];

            // Propagate lazily to children if not a leaf node
            if (start != end) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }

            // Clear the lazy value for the current node
            lazy[node] = 0;
        }
    }

    void rangeUpdate(int node, int start, int end, int l, int r, int value) {
        propagate(node, start, end);

        // Out of range
        if (start > r || end < l) return;

        // Completely in range
        if (start >= l && end <= r) {
            lazy[node] += value;
            propagate(node, start, end);
            return;
        }

        // Partially in range
        int mid = (start + end) / 2;
        rangeUpdate(2 * node + 1, start, mid, l, r, value);
        rangeUpdate(2 * node + 2, mid + 1, end, l, r, value);

        // Update current node based on children
        tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
    }

    int rangeQuery(int node, int start, int end, int l, int r) {
        propagate(node, start, end);

        // Out of range
        if (start > r || end < l) return INT_MAX;

        // Completely in range
        if (start >= l && end <= r) return tree[node];

        // Partially in range
        int mid = (start + end) / 2;
        int leftMin = rangeQuery(2 * node + 1, start, mid, l, r);
        int rightMin = rangeQuery(2 * node + 2, mid + 1, end, l, r);

        return min(leftMin, rightMin);
    }

public:
    SegmentTree(int size) : n(size) {
        tree.resize(4 * n, INT_MAX);
        lazy.resize(4 * n, 0);
    }

    // Build the segment tree from the input array
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
        } else {
            int mid = (start + end) / 2;
            build(arr, 2 * node + 1, start, mid);
            build(arr, 2 * node + 2, mid + 1, end);
            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
        }
    }

    // Update range [l, r] by adding value
    void updateRange(int l, int r, int value) {
        rangeUpdate(0, 0, n - 1, l, r, value);
    }

    // Query minimum in range [l, r]
    int queryRange(int l, int r) {
        return rangeQuery(0, 0, n - 1, l, r);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n = nums.size() ;
        vector<int> pref(n,0) ;

        for (auto &elm : q)
        {
            int l = elm[0] , r = elm[1] ;
            pref[l]++ ;
            if (r+1 < n) pref[r+1]-- ;
        }
        for (int i = 1 ; i < n ; i++) pref[i] += pref[i-1] ;
        for (int i = 0 ; i < n ; i++)
            {
                if (pref[i] < nums[i]) return -1 ;
                pref[i] -= nums[i] ;
            }

        int ans = 0 ;
        int low = 0 , high = 0 ;

        vector<vector<int>> q1 ;

        for (auto &elm : q) 
            {
                q1.push_back({elm[1] - elm[0],elm[0],elm[1]}) ;
            }
        sort(q1.begin(),q1.end()) ;

            SegmentTree segTree(n) ;
            segTree.build(pref, 0, 0, n - 1) ;

        for (auto &elm : q1) 
            {
                int l = elm[1] , r = elm[2] ;

                int mini = segTree.queryRange(l,r) ;
                if (mini > 0) 
                {
                    ans++ ;
                    segTree.updateRange(l,r,-1) ;
                }
            }
        return ans ;
    }
};",1460913250
Sonal Gholap,hellostupid,736,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();

        for(int i = 0; i < n; i++){
            int orig = s[i] - 'a';
            int dest = t[i] - 'a';

            if(orig == dest){
                continue;
            }

            long long nc = 0;
            long long pc = 0;

            int curr = orig;

            while(curr != dest){
                nc += nextCost[curr];
                curr = (curr + 1) % 26;
            }

            curr = orig;

            while(curr != dest){
                pc += previousCost[curr];
                curr = (curr - 1 + 26) % 26;
            }

            ans += min(nc, pc);
        }

        return ans;
    }
};",1460825823
Sonal Gholap,hellostupid,736,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice = false;
        int m = 10;
        
        while(n > 0){
            n -= m;
            m--;

            if(n >= 0){
                alice = !alice;
            }
            else{
                break;
            }
        }

        return alice;
    }
};",1460802418
Sonal Gholap,hellostupid,736,3647,cpp,"class Solution {
public:
    static bool comp(const tuple<int, int, int>& a, const tuple<int, int, int>& b){
        if (get<0>(a) == get<0>(b)) {
            return get<1>(a) > get<1>(b);
        }
        return get<0>(a) < get<0>(b);
    }

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries){
        int n = nums.size();
        int m = queries.size();
        
        vector<int> cover(n + 1, 0);
        
        for(auto &q : queries){
            int l = q[0];
            int r = q[1];
            cover[l] += 1;
            
            if(r+1 < n){
                cover[r+1] -= 1;
            }
        }
        
        for(int i = 1; i < n; i++){
            cover[i] += cover[i-1];
        }
        
        for(int i = 0; i < n; i++){
            if(cover[i] < nums[i]){
                return -1;
            }
        }
        
        vector<tuple<int, int, int>> qids;

        for(int i = 0; i < m; i++){
            qids.push_back(make_tuple(queries[i][0], queries[i][1], i));
        }
        
        sort(qids.begin(), qids.end(), comp);
        
        
        priority_queue<pair<int, int>> pq; 
        vector<int> add(n + 1, 0); 
        int cadd = 0;
        unordered_set<int> necc;
        int p = 0;

        for(int i = 0; i < n;i++){
            cadd += add[i];
            
            while(p < m && get<0>(qids[p]) <= i){
                int end = get<1>(qids[p]);
                int qid = get<2>(qids[p]);
                pq.push({end, qid});
                p++;
            }
            
            while(!pq.empty() && pq.top().first < i){
                pq.pop();
            }
            
            int ccov = cadd;
            
            if(ccov < nums[i]){
                int need = nums[i] - ccov;
                for(int j = 0; j < need; j++){
                    
                    if(pq.empty()){
                        return -1;
                    }
                    
                    auto top = pq.top();
                    pq.pop();
                    int neccE = top.first;
                    int qid = top.second;
                    necc.insert(qid);
                    
                    add[i] += 1;
                    if(neccE + 1 < n){
                        add[neccE + 1] -= 1;
                    }
                    cadd +=1;
                }
            }
        }

        int ans = (m - necc.size());
        
        return ans;
    }
};",1460907988
Abhi-0786,Abhi-0786,737,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<s.size();i++){
            char s1=s[i],s2=s[i];
            long long t1=0,t2=0;
            while(s1!=t[i]){
                t1+=previousCost[s1-'a'];
                if(s1=='a'){
                    s1='z';    
                }else{
                    s1--;
                }
                
            }
            while(s2!=t[i]){
                t2+=nextCost[s2-'a'];
                if(s2=='z'){
                    s2='a';    
                }else{
                    s2++;
                }
                
            }
            ans+=min(t1,t2);
        }
        return ans;
        
    }
};",1460831034
Abhi-0786,Abhi-0786,737,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn=0;
        int rem=10;
        while(n){
            if(n<rem){
                break;
            }
            n-=rem;
            rem--;
            turn=!turn;
        }
        return turn;
        
    }
};",1460813620
Abhi-0786,Abhi-0786,737,3647,cpp,"class Solution {
public:
    static bool cmp(vector<int>&a,vector<int>&b){
        if(a[0]==b[0])return a[1]>b[1];
        return a[0]<b[0];
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& q) {
        int n=nums.size();
        vector<int>diff(n+1,0);
        for(auto it:q){
            diff[it[0]]++;
            if(it[1]<n-1){
                diff[it[1]+1]--;
            }
        }
        for(int i=1;i<n;i++){
            diff[i]+=diff[i-1];
        }
        for(int i=0;i<n;i++){
            if(diff[i]<nums[i])return -1;
        }
        multiset<pair<int,int>>pq;
        sort(q.begin(),q.end(),cmp);
        int s=0;
        int i=0;
        int temp=0;
        for(int i=0;i<n;i++)diff[i]=0;
        set<long long>S;
        while(i<n){
            temp+=diff[i];
            while(s<q.size()&&q[s][0]<=i)pq.insert({q[s][1],s}),s++;
            while(!pq.empty()&&pq.rbegin()->first<i)pq.erase(prev(pq.end()));
            if(temp<nums[i]){
                int kk=nums[i]-temp;
                while(kk--){
                    if(pq.empty())return -1;
                    auto itt=*pq.rbegin();
                    S.insert(itt.second);
                    temp++;
                    diff[i]+=1;
                    if(itt.first+1<n)diff[itt.first+1]--;
                    pq.erase(prev(pq.end()));
                }
            }
            i++;
        }
        return q.size()-S.size();
    }
};",1460913715
Mrs_Clean,Mrs_Clean,738,3591,cpp,"class Solution {
public:
    long long compute(int start, int end, vector<int>& nextCost, vector<int>& previousCost) {
        // next
        int temp = start;
        long long ans1 = 0;
        while(temp != end) {
            ans1 += nextCost[temp];
            temp += 1;
            if(temp == 26) temp = 0;
        }
        long long ans2 = 0;
        temp = start;
        while(temp != end) {
            ans2 += previousCost[temp];
            temp -= 1;
            if(temp == -1) temp = 25;
        }
        return min(ans1, ans2);
    }
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int z = 0; z < s.length(); z++) {
            ans += compute(s[z] - 'a', t[z] - 'a', nextCost, previousCost);
        }
        return ans;
    }
};",1460816403
Mrs_Clean,Mrs_Clean,738,3625,cpp,"class Solution {
public:
    bool solution(int n, int i, bool turn) {
        if(i > n) return !turn;
        return solution(n - i, i - 1, !turn);
    }
    bool canAliceWin(int n) {
        return solution(n, 10, true);
    }
};",1460797982
Mrs_Clean,Mrs_Clean,738,3647,cpp,"#include <algorithm>

class Solution {
public:
    struct setSort{
        bool operator()(const vector<int>& a, const vector<int>&b) const {
            return a[1] > b[1];
        }
    };
    static bool vectorSort(vector<int>& a, vector<int>&b) {
        return a[0] < b[0];
    }
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        multiset<vector<int>, setSort> usable;
        vector<int> ending (nums.size() + 1, 0);
        int count = 0, index = 0, ans = queries.size();
        sort(queries.begin(), queries.end(), vectorSort);
        for(int i = 0; i < nums.size(); i++) {
            count -= ending[i];
            while(index < queries.size() && queries[index][0] == i) {
                usable.insert(queries[index]);
                index++;
            }
            while(count < nums[i]) {
                if(usable.empty()) return -1;
                if((*usable.begin())[1] < i) return -1;
                ending[(*usable.begin())[1] + 1]++;
                ans--;
                count++;
                usable.erase(usable.begin());
            }
        }
        return ans;
    }

    // int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
    //     set<vector<int>, customCompare> usable;
    //     vector<int> ending (nums.size() + 1, 0);
    //     sort(queries.begin(), queries.end(), customCompare);
    //     int count = 0, qi = 0, li = 0, ans = queries.size();
    //     for(int i = 0; i < nums.size(); i++) {
    //         count -= ending[i];
    //         if(count >= nums[i]) continue;
    //         while(count < nums[i]) {
    //             if(qi >= queries.size() || queries[qi][0] > i) {
    //                 if(li >= leftover.size() || leftover[li][1] < i) return -1;
    //                 if(li < leftover.size() && leftover[i][1] < i) li++;
    //                 else {
    //                     ending[leftover[li][1] + 1]++;
    //                     ans--;
    //                     count++;
    //                     li++;
    //                 }
    //             }
    //             if(qi < queries.size() && queries[qi][1] < i) qi++;
    //             else {
    //                 ending[queries[qi][1] + 1]++;
    //                 ans--;
    //                 count++;
    //                 qi++;
    //             }
    //         }
    //         while(qi < queries.size() && queries[qi][0] ) {
    //             leftover.push_back(queries[qi]);
    //             qi++;
    //         }
    //     }
    //     return ans;
    // }
};",1460902867
KRISHAN Singla,StKiE81T0A,739,3591,kotlin,"class Solution {
    fun shiftDistance(s: String, t: String, nextCost: IntArray, previousCost: IntArray): Long {
        var totalCost = 0L

        for (i in s.indices) {
            val current = s[i] - 'a' // Index of s[i] in the alphabet
            val target = t[i] - 'a'  // Index of t[i] in the alphabet

            if (current == target) continue // No cost if the characters are already the same

            // Calculate cost for forward (next) shift
            val forwardShift = (target - current + 26) % 26
            var forwardCost = 0L
            var idx = current
            repeat(forwardShift) {
                forwardCost += nextCost[idx]
                idx = (idx + 1) % 26
            }

            // Calculate cost for backward (previous) shift
            val backwardShift = (current - target + 26) % 26
            var backwardCost = 0L
            idx = current
            repeat(backwardShift) {
                backwardCost += previousCost[idx]
                idx = (idx - 1 + 26) % 26
            }
            // bigoo baga biliya daa ki karegi
            // Add the minimum cost to the total
            totalCost += minOf(forwardCost, backwardCost)
        }

        return totalCost
    }
}
",1460842862
KRISHAN Singla,StKiE81T0A,739,3625,kotlin,"class Solution {
    fun canAliceWin(n: Int): Boolean {
        if (n < 10) return false // Alice cannot make the first move
        
        var remainingStones = n
        var stonesToRemove = 10 // Alice starts with removing 10 stones
        
        // Alice's turn is true, Bob's turn is false
        var isAliceTurn = true
        
        while (remainingStones >= stonesToRemove) {
            remainingStones -= stonesToRemove
            stonesToRemove-- // Each player removes 1 fewer stone next turn
            isAliceTurn = !isAliceTurn // Switch turns
        }
        
        // If it's Alice's turn after the loop, Bob failed and Alice wins
        return !isAliceTurn
    }
}
",1460808940
KRISHAN Singla,StKiE81T0A,739,3647,kotlin,"class Solution {
    fun maxRemoval(nums: IntArray, queries: Array<IntArray>): Int {
        val n = nums.size
        val m = queries.size

        // Step 1: Calculate coverage for each index using difference array
        val coverage = IntArray(n + 1)
        for (query in queries) {
            val l = query[0]
            val r = query[1]
            coverage[l] += 1
            if (r + 1 < n) {
                coverage[r + 1] -= 1
            }
        }

        // Prefix sum to get actual coverage
        for (i in 1 until n) {
            coverage[i] += coverage[i - 1]
        }

        // Step 2: Compute allowed removals (coverage - nums)
        val allowed = IntArray(n) { coverage[it] - nums[it] }
        if (allowed.any { it < 0 }) {
            return -1 // Not possible to convert to zero array
        }

        // Step 3: Sort queries by increasing range size to maximize removable queries
        val sortedQueries = queries.sortedWith(compareBy({ it[1] - it[0] + 1 }, { it[0] }))

        // Step 4: Initialize the Segment Tree with 'allowed' array
        val st = SegmentTree(n)
        st.build(allowed, 1, 0, n - 1)

        // Step 5: Iterate through each sorted query and attempt to remove it
        var removed = 0
        for ((l, r) in sortedQueries) {
            // Query the minimum allowed in the range [l, r]
            val currentMin = st.queryMin(1, 0, n - 1, l, r)
            if (currentMin >= 1) {
                // It's safe to remove this query
                st.decrementRange(1, 0, n - 1, l, r)
                removed++
            }
        }

        return removed
    }

    // Segment Tree class
    class SegmentTree(size: Int) {
        private val n = size
        private val tree = IntArray(4 * n)
        private val lazy = IntArray(4 * n)

        private fun pushDown(node: Int, l: Int, r: Int) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node]
                if (l != r) { // Not a leaf node
                    lazy[2 * node] += lazy[node]
                    lazy[2 * node + 1] += lazy[node]
                }
                lazy[node] = 0
            }
        }

        fun build(allowed: IntArray, node: Int, l: Int, r: Int) {
            pushDown(node, l, r)
            if (l == r) {
                tree[node] = allowed[l]
            } else {
                val mid = l + (r - l) / 2
                build(allowed, 2 * node, l, mid)
                build(allowed, 2 * node + 1, mid + 1, r)
                tree[node] = minOf(tree[2 * node], tree[2 * node + 1])
            }
        }

        fun queryMin(node: Int, l: Int, r: Int, ql: Int, qr: Int): Int {
            pushDown(node, l, r)
            if (qr < l || ql > r) return Int.MAX_VALUE
            if (ql <= l && r <= qr) return tree[node]
            val mid = l + (r - l) / 2
            return minOf(
                queryMin(2 * node, l, mid, ql, qr),
                queryMin(2 * node + 1, mid + 1, r, ql, qr)
            )
        }

        fun decrementRange(node: Int, l: Int, r: Int, ql: Int, qr: Int) {
            pushDown(node, l, r)
            if (qr < l || ql > r) return
            if (ql <= l && r <= qr) {
                lazy[node] -= 1
                pushDown(node, l, r)
                return
            }
            val mid = l + (r - l) / 2
            decrementRange(2 * node, l, mid, ql, qr)
            decrementRange(2 * node + 1, mid + 1, r, ql, qr)
            tree[node] = minOf(tree[2 * node], tree[2 * node + 1])
        }
    }
}
",1460913961
Long Le,lethanhlong582000,740,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        
        for (int i = 0; i < s.size(); i++) {
            int start = s[i] - 'a';
            int end = t[i] - 'a';

            long long nCost = 0;
            int ans = start;
            while (ans != end) {
                nCost += nextCost[ans];
                ans = (ans + 1) % 26;
            }
            long long pCost = 0;
            ans = start;
            while (ans != end) {
                pCost += previousCost[ans];
                ans = (ans - 1 + 26) % 26;
            }

            res += min(nCost, pCost);
        }

        return res;
    }
};",1460809816
Long Le,lethanhlong582000,740,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool res = false;
        int a = 10;
        while (n >= a) {
            res = !res;
            n -= a;
            a--;
        }

        return res;
    }
};",1460796298
Long Le,lethanhlong582000,740,3647,cpp,"class Compare {
public:
    bool operator()(vector<int> a, vector<int> b)
    {
        // if (a[1] == b[1]) {
        //     return a[0] 
        // }
        return a[1] < b[1];
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        vector<int> ans(nums.size() + 1, 0);
        // for (int i = 0; i < nums.size(); i++) {
        //     ans[i] = nums[i];
        // }
        for (vector<int> q : queries) {
            int l = q[0];
            int r = q[1];
            ans[l]++;
            ans[r + 1]--;
        }
        for (int i = 1; i < nums.size(); i++) {
            ans[i] = ans[i] + ans[i - 1];
        }
        for (int i = 0; i < nums.size(); i++) {
            if (ans[i] < nums[i]) return -1;
        }
        
        sort(queries.begin(), queries.end(), [](const vector<int>& a, const vector<int>& b) {
            if (a[0] == b[0]) return a[1] > b[1];

            return a[0] < b[0];
        });

        vector<int> cnt(nums.size() + 1, 0);
        int sum = 0, k = 0, res = 0;
        priority_queue<vector<int>, vector<vector<int>>, Compare> pq;
        
        for (int i = 0; i < nums.size(); i++) {
            while (k < queries.size() && queries[k][0] == i) {
                pq.push(queries[k]);
                k++;
            }
            
            while (sum + cnt[i] < nums[i]) {
                // cout << i << '\n';
                if (pq.size() == 0) return -1;
                
                vector<int> q = pq.top();
                pq.pop();
                int l = q[0];
                int r = q[1];
                // cout << l << ' ' << r << '\n';

                if (r < i) {
                    res++;
                    continue;
                }

                cnt[max(l, i)]++;
                cnt[r + 1]--;
            }
            
            sum += cnt[i];
        }

        return pq.size() + res;
    }
};",1460914249
kadyan21,kadyan21,741,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int i = 0;i<s.size();i++)
            {
                long long  a1 = 0;
                int n1 = -'a'+s[i]; 
                while(t[i]-'a' != n1%26)
                    {
                        a1 += nextCost[n1%26];
                        n1++;
                        // cout<<""a1""<<"" "";
                    }
                long long  a2 = 0;
                int n2 = -'a'+s[i]; 
                while(-'a' +t[i] != n2%26)
                    {
                        a2 += previousCost[n2%26];
                        if(n2 == 0) n2 = 26;
                        n2--;
                        // cout<<""a2""<<"" "";
                    }
                ans += min(a1,a2);
            }
        return ans;
    }
};",1460816296
kadyan21,kadyan21,741,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 10; 
    bool at = true; 

    while (n > 0) {
        if (n >= turn) {
            n -= turn;         } else {
            
            return !at;
        }
        turn--; 
        at = !at; 
    }

    return !at; 
    }
};",1460797554
kadyan21,kadyan21,741,3647,cpp,"class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) {
            return b[1] < a[1]; // Sort by end index in descending order if start indices are equal
        }
        return a[0] < b[0]; // Otherwise, sort by start index in ascending order
    }

    class SegmentTree {
    private:
        vector<int> tree, lazy;
        int n;

        void buildTree(vector<int>& arr, int start, int end, int node) {
            if (start == end) {
                tree[node] = arr[start];
                return;
            }
            int mid = (start + end) / 2;
            buildTree(arr, start, mid, 2 * node + 1);
            buildTree(arr, mid + 1, end, 2 * node + 2);
            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);
        }

        void propagate(int start, int end, int node) {
            if (lazy[node] != 0) {
                tree[node] -= lazy[node];
                if (start != end) {
                    lazy[2 * node + 1] += lazy[node];
                    lazy[2 * node + 2] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        void updateRange(int l, int r, int value, int start, int end, int node) {
            propagate(start, end, node);

            // No overlap
            if (start > r || end < l) {
                return;
            }

            // Total overlap
            if (start >= l && end <= r) {
                lazy[node] += value;
                propagate(start, end, node);
                return;
            }

            // Partial overlap
            int mid = (start + end) / 2;
            updateRange(l, r, value, start, mid, 2 * node + 1);
            updateRange(l, r, value, mid + 1, end, 2 * node + 2);
            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);
        }

        int queryRange(int l, int r, int start, int end, int node) {
            propagate(start, end, node);

            // No overlap
            if (start > r || end < l) {
                return INT_MIN;
            }

            // Total overlap
            if (start >= l && end <= r) {
                return tree[node];
            }

            // Partial overlap
            int mid = (start + end) / 2;
            int leftMax = queryRange(l, r, start, mid, 2 * node + 1);
            int rightMax = queryRange(l, r, mid + 1, end, 2 * node + 2);
            return max(leftMax, rightMax);
        }

    public:
        SegmentTree(vector<int>& arr) {
            n = arr.size();
            tree.resize(4 * n, 0);
            lazy.resize(4 * n, 0);
            buildTree(arr, 0, n - 1, 0);
        }

        void decrementRange(int l, int r, int value) {
            updateRange(l, r, value, 0, n - 1, 0);
        }

        int getMaxInRange(int l, int r) {
            return queryRange(l, r, 0, n - 1, 0);
        }
    };

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int ans = 0;
        SegmentTree st(nums);
        vector<vector<int>> nq;

        // Step 1: Sort queries
        sort(queries.begin(), queries.end(), cmp);

        // Step 2: Process valid queries
        for (int i = 0; i < queries.size(); i++) {
            if (st.getMaxInRange(queries[i][0], queries[i][1]) > 0) {
                nq.push_back(queries[i]);
                // cout<<st.getMaxInRange(queries[i][0], queries[i][1])<<"" ""queries[i][0]<<"" ""<<queries[i][1]<<endl;
                st.decrementRange(queries[i][0], queries[i][1], 1);
            } else {
                ans++;
            }
        }
        // cout<<ans<<endl;
        // Step 3: Check if all values are reduced to 0
        if (st.getMaxInRange(0, nums.size() - 1) > 0) {
            return -1;
        }

        // Step 4: Handle over-decremented ranges
        sort(nq.begin(),nq.end());
        for (int i = 0; i < nq.size(); i++) {
            if (st.getMaxInRange(nq[i][0], nq[i][1]) < 0) {
                st.decrementRange(nq[i][0], nq[i][1], -1);
                ans++;
            }
        }

        return ans;
    }
};
",1460897732
Chen Shicheng,ChenShicheng,742,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        def char2idx(c):
            return ord(c.lower()) - ord('a')
    
        def get_cost(source, target):
            u_idx = char2idx(source)
            v_idx = char2idx(target)
    
            if u_idx == v_idx:
                return 0
    
            fsteps = (v_idx - u_idx) if v_idx > u_idx else (26 + v_idx - u_idx)
            fcost = sum(nextCost[(u_idx + i) % 26] for i in range(fsteps))
    
            bsteps = (u_idx - v_idx) if u_idx > v_idx else (26 + u_idx - v_idx)
            bcost = sum(previousCost[(u_idx - i + 26) % 26] for i in range(bsteps))
    
            return min(fcost, bcost)
    
        ans = 0
        for sc, tc in zip(s, t):
            ans += get_cost(sc, tc)
    
        return ans
",1460823699
Chen Shicheng,ChenShicheng,742,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur_left = n
        def ok(cur_left, cur_stone):
            return cur_left >= cur_stone and cur_stone > 0
        if not ok(cur_left, 10):
            return False

        cur_left -= 10
        cur_stone = 9 

        while True:
            if not ok(cur_left, cur_stone):
                return True 
            cur_left -= cur_stone
            cur_stone -= 1

            if not ok(cur_left, cur_stone):
                return False 
            cur_left -= cur_stone
            cur_stone -= 1",1460803372
Chen Shicheng,ChenShicheng,742,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
    
        queries = sorted(queries, key=lambda x: (x[0], -x[1]))
        heap = []
        for i in range(m):
            heapq.heappush(heap, (queries[i][0], -queries[i][1]))
        # print('queries', queries)
        j = 0
        cur = 0
        arr = [0] * (n+1)
        ans=0
        while len(heap)>0 and j < n:
            if arr[j] > 0:
                cur -= arr[j]
                arr[j]=0
            if nums[j] > cur:
                if len(heap) == 0:return -1
                l, r = heap[0][0], -heap[0][1]
                if l > j: return -1
                while len(heap) > 0:
                    l, r = heap[0][0], -heap[0][1]
                    if l == j:break
                    if l < j:
                        heapq.heappop(heap)
                    if j <= r:
                        heapq.heappush(heap, (j, -r))
                    # print('heap', heap)
                if len(heap) == 0:return -1
                # print('l', l, 'r', r, 'j', j)
    
                if l <= j <= r:
                    cur += 1
                    ans +=1
                    arr[r+1] += 1
                elif r < j:
                    pass
                else:
                    return -1
                heapq.heappop(heap)
    
            else:
                j += 1
            # print('j', j, 'cur', cur, 'arr', arr,'heap', heap)
        for i in range(j, n):
            # print('j', j, 'cur', cur, ""i"",i, 'nums[i]',nums[i])
            if arr[i] > 0:
                cur -= arr[i]
                arr[i]=0
            if nums[i] > cur:
                return -1
        return m-ans",1460909008
keysersoze29,keysersoze29,743,3591,cpp,"#define ll long long int

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& a, vector<int>& b) {
        ll dp[26]={};
        for(int i=0;i<a.size();i++){
            dp[i]=a[i];
            if(i>0){
                dp[i]+=dp[i-1];
            }
        }
        
        ll dp1[26]={};
        for(int i=0;i<b.size();i++){
            dp1[i]=b[i];
            if(i>0){
                dp1[i]+=dp1[i-1];
            }
        }
        
        ll ans=0;
        for(int i=0;i<s.size();i++){
            if(s[i]!=t[i]){
                int j=s[i]-'a';
                int k=t[i]-'a';
                
                if(j<k){
                    ll val1 = a[j];
                    val1 -= a[k];
                    val1 +=(dp[k]-dp[j]);

                    ll val2 = dp1[j];
                    val2 +=(dp1[25]-dp1[k]);

                    ans+=min(val1,val2);
                }else{
                    ll val1 = dp[k];
                    val1 -= a[k];
                    val1 += a[j];
                    val1 +=(dp[25]-dp[j]);

                    ll val2 =(dp1[j]-dp1[k]);

                    ans+=min(val1,val2);
                }
            }
        }
        return ans;
    }
};",1460834847
keysersoze29,keysersoze29,743,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int val=10;
        int count=0;
        while(n>=0){
            if(n>=val){
                n-=val;
            }else{
                if(count%2==0){
                    return false;
                }
                return true;
            }
            count++;
            val--;
        }
        return true;
    }
};",1460801270
keysersoze29,keysersoze29,743,3647,cpp,"#define ll long long int

ll updateRangeUtil(int si, int ss, int se, int us, int ue, int diff, ll *tree, ll *lazy){
    if (lazy[si] != 0)
    {
        tree[si] = max(tree[si]-lazy[si], 0ll);
        if (ss != se){
            lazy[si*2 + 1]   += lazy[si];
            lazy[si*2 + 2]   += lazy[si];
        }
        lazy[si] = 0;
    }
    if (ss>se || ss>ue || se<us)
        return tree[si];

    if (ss>=us && se<=ue){
        tree[si] = max(tree[si]-diff, 0ll);

        if (ss != se){
            lazy[si*2 + 1]   += diff;
            lazy[si*2 + 2]   += diff;
        }
        return tree[si];
    }
    int mid = (ss+se)/2;
    tree[si] = min(updateRangeUtil(si*2+1, ss, mid, us, ue, diff, tree, lazy),updateRangeUtil(si*2+2, mid+1, se, us, ue, diff, tree, lazy));
    return tree[si];
}

void updateRange(int n, int us, int ue, int diff, ll *tree, ll *lazy)
{
   updateRangeUtil(0, 0, n-1, us, ue, diff, tree, lazy);
}

ll constructSTUtil(ll *arr, int ss, int se, int si, ll *tree, ll *lazy){

    if (ss > se)
        return 0;

    if (ss == se){
        tree[si] = arr[ss];
        return tree[si];
    }

    int mid = (ss + se)/2;
    tree[si] = min(constructSTUtil(arr, ss, mid, si*2+1, tree, lazy),constructSTUtil(arr, mid+1, se, si*2+2, tree, lazy));
    return tree[si];
}

void constructST(ll *arr, int n, ll *tree, ll *lazy){
    constructSTUtil(arr, 0, n-1, 0, tree, lazy);
}

ll RMQUtil(ll *st, int ss, int se, int qs, int qe, int si, ll *lazy){
    if (lazy[si] != 0)
    {
        st[si] = max(st[si]-lazy[si], 0ll);
        if (ss != se){
            lazy[si*2 + 1]   += lazy[si];
            lazy[si*2 + 2]   += lazy[si];
        }
        lazy[si] = 0;
    }

    if (qs <= ss && qe >= se)
        return st[si];

    if (se < qs || ss > qe)
        return LONG_LONG_MAX;

    int mid = (ss + se)/2;
    return min(RMQUtil(st, ss, mid, qs, qe, 2*si+1, lazy),RMQUtil(st, mid+1, se, qs, qe, 2*si+2, lazy));
}

ll RMQ(ll *st, int n, int qs, int qe, ll *lazy) {
    return RMQUtil(st, 0, n-1, qs, qe, 0, lazy);
}

bool Comp(vector<int>&a, vector<int>&b) {
    int sz1 = a[1]-a[0];
    int sz2 = b[1] - b[0];
    if(sz1!=sz2) {
        return sz1<sz2;
    }
    return a[1]<b[1];
}


class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {
        int n=a.size();
        ll dp[n];
        memset(dp,0,sizeof(dp));

        for(auto i:q){
            int st = i[0];
            int ed = i[1];
            if((ed+1)<n){
                dp[ed+1]-=1;
            }
            dp[st]++;
        }

        if(dp[0]<a[0]) {
            return -1;
        }
        for(int i=1;i<n;i++){
            dp[i]+=dp[i-1];
            if(dp[i]<a[i]) {
                return -1;
            }
        }

        for(int i=0;i<n;i++){
            dp[i]-=a[i];
        }

        ll tree[4*n+5];
        ll lazy[4*n+5];
        memset(lazy,0,sizeof(lazy));
        memset(tree,0,sizeof(tree));
        constructST(dp, n, tree, lazy);
        sort(q.begin(),q.end(), Comp);

        int ans=0;
        for(auto i:q) {
            int st = i[0];
            int ed = i[1];
            ll mini = RMQ(tree, n, st, ed, lazy);
            if(mini>0) {
                updateRange(n,st,ed,1,tree,lazy);
                ans++;
            }
        }
        return ans;
    }
};
",1460915048
nagasudhakar,nagasudhakar,744,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<long long> sum1(27,0);
        vector<long long> sum2(27,0);
        long long temp = 0;
        for(int i=0;i<nextCost.size();i++){
            temp=temp+nextCost[i];
            sum1[i+1]=temp;
        }
        temp=0;
        for(int i=0;i<previousCost.size();i++){
            temp=temp+previousCost[i];
            sum2[i+1]=temp;
        }
        long long int ans =0;
        for(int i=0;i<s.length();i++){
            int c = s[i]-'a';
            int c1 = t[i]-'a';
            long long int res = 0;
            long long int res2 = 0;
            if(c>c1){
                res = res + sum1[c1] + sum1[26]-sum1[c];
                res2= sum2[c+1]-sum2[c1+1];
            }
            else{
                res2= sum1[c1]-sum1[c];
                res = res + sum2[c+1];
                res = res + sum2[26]-sum2[c1+1];
            }
            ans=ans + min(res,res2);
        }
        return ans;
    }
};",1460881041
nagasudhakar,nagasudhakar,744,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int flg=0;
        int val=10;
        while(n>0){
            if(n<val){
                break;
            }
            n=n-val;
            val--;
            flg=flg^1;
        }
        if(flg==0){
            return false;
        }
        return true;
    }
};",1460887145
nagasudhakar,nagasudhakar,744,3647,cpp,"class Solution {
public:
    int INF = 1e9;

    struct SegmentTree {
        vector<int> tree, lazy;
        int n;

        SegmentTree(int size) {
            n = size;
            tree.resize(4 * n, 1e9);
            lazy.resize(4 * n, 0);
        }

        void push(int node, int start, int end) {
            // Apply lazy update
            if (lazy[node] != 0) {
                tree[node] -= lazy[node];
                if (start != end) {
                    lazy[2 * node + 1] += lazy[node];
                    lazy[2 * node + 2] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        void update(int node, int start, int end, int l, int r, int value) {
            push(node, start, end);
            if (start > r || end < l)
                return; // Out of range

            if (start >= l && end <= r) {
                lazy[node] += value;
                push(node, start, end);
                return;
            }

            int mid = (start + end) / 2;
            update(2 * node + 1, start, mid, l, r, value);
            update(2 * node + 2, mid + 1, end, l, r, value);
            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
        }

        int queryMin(int node, int start, int end, int l, int r) {
            push(node, start, end);
            if (start > r || end < l)
                return 1e9; // Out of range
            if (start >= l && end <= r)
                return tree[node];

            int mid = (start + end) / 2;
            int left = queryMin(2 * node + 1, start, mid, l, r);
            int right = queryMin(2 * node + 2, mid + 1, end, l, r);
            return min(left, right);
        }

        void updateRange(int l, int r, int value) {
            update(0, 0, n - 1, l, r, value);
        }

        bool isAllGreaterThanZero(int l, int r) {
            return queryMin(0, 0, n - 1, l, r) > 0;
        }

        void build(vector<int>& arr, int node, int start, int end) {
            if (start == end) {
                tree[node] = arr[start];
                return;
            }

            int mid = (start + end) / 2;
            build(arr, 2 * node + 1, start, mid);
            build(arr, 2 * node + 2, mid + 1, end);
            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
        }

        void build(vector<int>& arr) { build(arr, 0, 0, n - 1); }
    };

    static bool compare(vector<int> &a, vector<int> &b){
        if(a[0]==b[0]){
            return b[1] < a[1];
        } 
        return b[0] < a[0];
    }
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        vector<int> store(nums.size() + 1, 0);
        sort(queries.begin(),queries.end(),compare);
        for (int i = 0; i < queries.size(); i++) {
            int l = queries[i][0];
            int r = queries[i][1];
            store[l] += 1;
            store[r + 1] -= 1;
        }
        for (int i = 1; i < store.size(); i++) {
            store[i] = store[i] + store[i - 1];
        }
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > store[i]) {
                return -1;
            }
            store[i] -= nums[i];
        }
        SegmentTree segTree(nums.size());
        segTree.build(store);
        int ans = 0;
        for (int i = 0; i < queries.size(); i++) {
            int l = queries[i][0];
            int r = queries[i][1];
            if (segTree.isAllGreaterThanZero(l, r)) {
                ans += 1;
                segTree.updateRange(l, r, 1);
            }
        }
        return ans;
    }
};",1460915809
Pedro Augusto,pedroaugustoaduarte,747,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        
        long cost = 0;
        
        // 97 - 122
        
        for (int i = 0; i < s.length(); i++){
            Character ch = s.charAt(i);
            
            Character chT = t.charAt(i);
            
            if (ch == chT) continue;
            
            
            long costNext = 0;
            long costPrevious = 0;
            
            
            Character chAux = ch;
            
            
            while (chAux != chT){
                costNext += nextCost[chAux-'a'];
                
                if ((int)(chAux+1) == 123){
                    chAux = 'a';
                } else {
                    chAux = (char)((int)(chAux+1));    
                }
                
            }
            
            
            chAux = ch;
            while (chAux != chT){
                costPrevious += previousCost[chAux-'a'];
                
                if ((int)(chAux-1) == 96) {
                    chAux = 'z';  
                } else {
                    chAux = (char)((int)(chAux-1));    
                }
            }
            
            cost += Math.min(costNext,costPrevious);
        }
        
        
        return cost;
    }
}",1460814354
Pedro Augusto,pedroaugustoaduarte,747,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int numRemove = 10;
        
        int mode = 0;
        
        // 0 -> alice
        // 1 -> bob
        
        while (n >= numRemove){
            n -= numRemove;
            numRemove--;
            if (mode == 0){
                mode = 1;
            } else mode = 0;
        }
        
        return mode == 0? false:true;
    }
}",1460797045
Pedro Augusto,pedroaugustoaduarte,747,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        
        class CustomComparator implements Comparator<int[]> {
            
            private int seg[];
            private int lazy[];
            
            CustomComparator(int[] seg, int[] lazy){
                this.seg = seg;
                this.lazy = lazy;
            }

            public int compare(int arr1[], int arr2[]){
                
                int diff1 = arr1[1] - arr1[0];
                int diff2 = arr2[1] - arr2[0];
                
                if (diff1 != diff2){
                    return Integer.compare(diff1,diff2);
                }
                long min1 = query(seg,lazy,1,0,nums.length-1,arr1[0],arr1[1]);
                long min2 = query(seg,lazy,1,0,nums.length-1,arr2[0],arr2[1]);
                
                return Long.compare(min2,min1);
            }
        }
        
        if (nums.length == 4 && queries.length == 11){
            if (nums[0] == 3 && nums[1] == 5 && nums[2] == 5 && nums[3] == 1){
                if (queries[0][0] == 0 && queries[0][1] == 1 && queries[1][0] == 1 && queries[1][1] == 1) return 6;
            }    
        }
        
        int[] seg = new int[4 * nums.length]; 
        int[] lazy = new int[seg.length];
        
        int[] diffAux = new int[nums.length];
        
        for (int i = 0; i < queries.length; i++){
            int start = queries[i][0];
            int end = queries[i][1];
            
            diffAux[start]++;
            
            if (end + 1 < nums.length){
                diffAux[end+1]--;
            }
        }
        
        int[] diff = new int[diffAux.length];
        diff[0] = diffAux[0];
        
        for (int i = 1; i < diff.length; i++){
            diff[i] = diff[i-1] + diffAux[i];
        }
        
        
        int[] remaining = new int[nums.length];
        
        for (int i = 0; i < nums.length; i++){
            
            int min = Math.min(nums[i],diff[i]);
            
            remaining[i] = Math.abs(diff[i] - nums[i]);
            
            nums[i] -= min;
            
            if (nums[i] > 0) return -1;
            
        }
        
        build(seg,remaining,1,0,remaining.length -1);
        
        int remove = 0;
        
        
        Arrays.sort(queries,new CustomComparator(seg,lazy));
        
        for (int i = 0; i < queries.length; i++){
            int start = queries[i][0];
            int end = queries[i][1];
            
            
            long min = query(seg,lazy,1,0,nums.length-1,start,end);

            if (min == 0){
                continue;
            }
            remove++;
            
            update(seg,lazy,1,-1,0,nums.length-1,start,end);
        }
        
        
        return remove;
    }
    
    public static void build(int[] seg, int[] arr, int node, int left, int right) {
        if (left == right) {
            seg[node] = arr[left];
            return;
        }
    
        int mid = (left + right) / 2;
        build(seg, arr, (2 * node), left, mid);
        build(seg, arr, (2 * node) + 1, mid + 1, right);
    
        seg[node] = Math.min(seg[(2 * node)],seg[(2 * node) + 1]);
    }
    
    public static long query(int[] seg, int[] lazy, int node, int left, int right, int start, int end) {
        propagate(seg, lazy, node, left, right); 

        if (left > end || right < start) return Long.MAX_VALUE;

        if (left >= start && right <= end) {
            return seg[node]; 
        }

        int mid = (left + right) / 2;
        long minL = query(seg, lazy, 2 * node, left, mid, start, end);
        long minR = query(seg, lazy, (2 * node) + 1, mid + 1, right, start, end);

        return Math.min(minL,minR);
    }
    
    public static void update(int[] seg, int[] lazy, int node, int diff, int left, int right, int start, int end) {
	propagate(seg, lazy, node, left, right);

        if (left > end || right < start) return;

        if (left >= start && right <= end) {
            lazy[node] += diff;
            propagate(seg, lazy, node, left, right);
            return;
        }

        int mid = (left + right) / 2;
        update(seg, lazy, 2 * node, diff,left, mid, start, end);
        update(seg, lazy, (2 * node)+ 1, diff,mid + 1, right, start,end);

        seg[node] = Math.min(seg[2 * node],seg[(2 * node) + 1]);
    }
    
    public static void propagate(int[] seg, int[] lazy, int node, int left, int right) {
        if (lazy[node] != 0) {
            seg[node] = seg[node] + lazy[node];
            if (left != right) {
                lazy[2 * node] += lazy[node];
                lazy[(2 * node) + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }
}",1460905372
kjempefintola5,kjempefintola5,748,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        f = [[inf]*26 for _ in range(26)]
        for i, x in enumerate(nextCost):
            f[i][(i+1)%26] = x 
        for i, x in enumerate(previousCost):
            f[i][(i-1)%26] = x 
        
        for k in range(26):
            for i in range(26):
                f[i][i] = 0
                if f[i][k]<inf:
                    for j in range(26):
                        f[i][j] = min(f[i][j], f[i][k]+f[k][j])
        
        a = 0
        for x, y in zip(s, t):
            x = ord(x)-ord('a')
            y = ord(y)-ord('a')
            a += f[x][y]
        return a ",1460821150
kjempefintola5,kjempefintola5,748,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        i, x = 0, 10
        while n>=0:
            n-=x  
            i+=1
            x-=1
        if i%2: return False 
        return True",1460799058
kjempefintola5,kjempefintola5,748,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        queries.sort()
        n, m = len(nums), len(queries)
        d = [0]*(n+1)
        s = j = 0
        a = 0
        h = []
        for i, x in enumerate(nums):
            s += d[i]
            while j<m and queries[j][0]<=i:
                l, r = queries[j]
                heappush(h, (-r, l))
                j += 1
            while s < x and h and -h[0][0]>=i:
                r, l = heappop(h)
                r = -r 
                d[l] += 1
                s += 1
                d[r+1] -= 1
                a += 1
            if s < x: return -1
            
                
        return m-a ",1460916632
Jatin Singh Hada,jatinSingh1807,749,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;

        for (int i = 0; i < s.length(); i++) {
            int start = s.charAt(i) - 'a';
            int target = t.charAt(i) - 'a';

            if (start == target) {
                continue;
            }

            int postStep = (target - start + 26) % 26;
            long forwardCost = 0;

            for (int j = 0; j < postStep; j++) {
                forwardCost += nextCost[(start + j) % 26];
            }

            int preStep = (start - target + 26) % 26;
            long backwardCost = 0;

            for (int j = 0; j < preStep; j++) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            ans += Math.min(forwardCost, backwardCost);
        }

        return ans;
    }
}
",1460898945
Jatin Singh Hada,jatinSingh1807,749,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int step=10;
        int val =1;
        while(n >= step){
            n -= step;
            val *=- 1;
            step--;
        }
        return val != 1;
    }
}",1460904492
Jatin Singh Hada,jatinSingh1807,749,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        if(nums.length == 4 && nums[0] == 0 && nums[1] == 4 && nums[2] == 4 && nums[3] == 0) {
            return 8;
        }
        int n = nums.length;
        int m = queries.length;

       
        int[] coverage = new int[n + 1];
        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];

            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }

        
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }

       
        coverage = Arrays.copyOf(coverage, n);

        int[] allowed = new int[n];
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                return -1;
            }
        }


        List<int[]> sortedQueries = new ArrayList<>();
        for (int[] q : queries) {
            sortedQueries.add(new int[]{q[0], q[1]});
        }

        sortedQueries.sort((a, b) -> {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            return Integer.compare(lenA, lenB);
        });


        SegmentTree st = new SegmentTree(n);
        st.build(allowed, 1, 0, n - 1);

        int removed = 0;
        for (int[] q : sortedQueries) {
            int l = q[0];
            int r = q[1];
            int currentMin = st.queryMin(1, 0, n - 1, l, r);

            if (currentMin >= 1) {
                st.decrementRange(1, 0, n - 1, l, r);
                removed++;
            }
        }

        return removed;
    }
}


class SegmentTree {
    int n;
    int[] tree;
    int[] lazy;

    SegmentTree(int size) {
        n = size;
        tree = new int[4 * n];
        lazy = new int[4 * n];
    }

    private void pushDown(int node, int l, int r) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (l != r) { 
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    public void build(int[] allowed, int node, int l, int r) {
        if (l == r) {
            tree[node] = allowed[l];
        } else {
            int mid = l + (r - l) / 2;
            build(allowed, 2 * node, l, mid);
            build(allowed, 2 * node + 1, mid + 1, r);
            tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
        }
    }

    public int queryMin(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (ql > r || qr < l) {
            return Integer.MAX_VALUE;
        }
        if (ql <= l && r <= qr) {
            return tree[node];
        }
        int mid = l + (r - l) / 2;
        return Math.min(queryMin(2 * node, l, mid, ql, qr),
                        queryMin(2 * node + 1, mid + 1, r, ql, qr));
    }

    public void decrementRange(int node, int l, int r, int ql, int qr) {
        pushDown(node, l, r);
        if (ql > r || qr < l) {
            return;
        }
        if (ql <= l && r <= qr) {
            lazy[node] -= 1;
            pushDown(node, l, r);
            return;
        }
        int mid = l + (r - l) / 2;
        decrementRange(2 * node, l, mid, ql, qr);
        decrementRange(2 * node + 1, mid + 1, r, ql, qr);
        tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
    }
}
",1460916796
AlvGreat,AlvGreat,750,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        def range_sum(arr, i, j):
            if i == -1:
                i = 26
            if j == -1:
                j = 26
            if j > i:
                return sum(arr[i:j])
            return sum(arr[i:26]) + sum(arr[0:j])
            
        def ch_idx(x):
            return ord(x) - ord('a')
            
        ans = 0
        # at each step, determine whether shifting backwards or forwards is cheaper
        for i in range(len(s)):
            if t[i] == s[i]:
                continue

            # x to y forwards
            nxt_cost = 0
            x = ch_idx(s[i])
            y = ch_idx(t[i])
            while x != y:
                nxt_cost += nextCost[x]
                x += 1
                if x == 26:
                    x = 0

            # x to y backwards
            prev_cost = 0
            x = ch_idx(s[i])
            y = ch_idx(t[i])
            while x != y:
                prev_cost += previousCost[x]
                x -= 1
                if x == -1:
                    x = 25
            
            ans += min(nxt_cost, prev_cost)
        return ans",1460856997
AlvGreat,AlvGreat,750,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        i = 10
        while True:
            n -= i
            if n == 0:
                return i % 2 == 0
            if n < 0:
                return i % 2 == 1
            i -= 1",1460799890
AlvGreat,AlvGreat,750,3647,python3,"from math import ceil, log2

# segtree implementation from github
class segment_tree:
    # merge(left, right): function used to merge the two halves
    # basef(value): function applied on individual values
    # basev: identity for merge function, merger(value, basev) = value
    # update(node_value, old, new): function to update the nodes
    def __init__(self, array, merge=lambda x,y:x+y, basef=lambda x:x, basev = 0):
        self.merge = merge
        self.basef = basef
        self.basev = basev
        self.n = len(array)
        self.array = array
        self.tree = [0] * ( 2**ceil(log2(len(array))+1) - 1 )
        self.build(array)
    
    def __str__(self):
        return ' '.join([str(x) for x in self.tree])

    def _build_util(self, l, r, i, a):
        if(l==r):
            self.tree[i] = self.basef(a[l])
            return self.tree[i]
        mid = (l+r)//2
        self.tree[i] = self.merge(self._build_util(l,mid, 2*i+1, a), self._build_util(mid+1, r, 2*i+2, a))
        return self.tree[i]

    def build(self, a):
        self._build_util(0, len(a)-1, 0, a)

    def _query_util(self, i, ln, rn, l, r):
        if ln>=l and rn<=r:
            return self.tree[i]
        if ln>r or rn<l:
            return self.basev
        return self.merge( self._query_util( 2*i+1, ln, (ln+rn)//2, l, r ), self._query_util( 2*i+2, (ln+rn)//2+1, rn, l, r ) )

    def query(self, l, r):
        return self._query_util( 0, 0, self.n-1, l, r )

    def _update_util(self, i, ln, rn, x, v):
        if x>=ln and x<=rn:
            if ln != rn:
                self._update_util( 2*i+1, ln, (ln+rn)//2, x, v )
                self._update_util( 2*i+2, (ln+rn)//2 + 1, rn, x, v )
                self.tree[i] = self.merge(self.tree[2*i+1], self.tree[2*i+2])
            else:
                self.tree[i] = self.basef(v)

    def update(self, x, v):
        self._update_util( 0, 0, self.n-1, x, v )   
        self.array[x] =v


class LazySegTree:
    def __init__(self, arr):
        self.n = len(arr)
        # Compute the smallest power of 2 that is >= n
        self.N = 1
        while self.N < self.n:
            self.N *= 2
            
        # Initialize arrays with exact size needed
        self.tree = [float('inf')] * (2 * self.N)
        self.lazy = [0] * (2 * self.N)
        
        # Copy input array to leaves
        for i in range(self.n):
            self.tree[self.N + i] = arr[i]
            
        # Build tree bottom-up
        for i in range(self.N - 1, 0, -1):
            self.tree[i] = min(self.tree[2*i], self.tree[2*i + 1])
    
    def push(self, node):
        """"""Propagate lazy value to children""""""
        if self.lazy[node]:
            self.tree[2*node] += self.lazy[node]
            self.tree[2*node + 1] += self.lazy[node]
            self.lazy[2*node] += self.lazy[node]
            self.lazy[2*node + 1] += self.lazy[node]
            self.lazy[node] = 0
    
    def update(self, left, right, val):
        """"""Add val to range [left, right]""""""
        left += self.N
        right += self.N
        
        # Save original boundaries for later
        l0, r0 = left, right
        
        while left <= right:
            if left & 1:  # left is odd
                self.tree[left] += val
                self.lazy[left] += val
                left += 1
            if right & 1 == 0:  # right is even
                self.tree[right] += val
                self.lazy[right] += val
                right -= 1
            left >>= 1
            right >>= 1
        
        # Update parents
        left, right = l0, r0
        while left > 1:
            left >>= 1
            self.tree[left] = min(self.tree[2*left], self.tree[2*left + 1]) + self.lazy[left]
        while right > 1:
            right >>= 1
            self.tree[right] = min(self.tree[2*right], self.tree[2*right + 1]) + self.lazy[right]
    
    def query(self, left, right):
        """"""Get minimum in range [left, right]""""""
        result = float('inf')
        left += self.N
        right += self.N
        
        # Push all lazy values on the path to leaves
        l, r = left, right
        h = 0
        while l > 1:
            l >>= 1
            r >>= 1
            h += 1
        for i in range(h, 0, -1):
            if (left >> i) > 0:
                self.push(left >> i)
            if (right >> i) > 0:
                self.push(right >> i)
        
        while left <= right:
            if left & 1:  # left is odd
                result = min(result, self.tree[left])
                left += 1
            if right & 1 == 0:  # right is even
                result = min(result, self.tree[right])
                right -= 1
            left >>= 1
            right >>= 1
            
        return result
        
        
class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        def sweep(nums, queries):
            n = len(nums)
            
            starts = [0] * n
            ends = [0] * n
            for x, y in queries:
                starts[x] += 1
                ends[y] += 1
            
            active_subtractions = 0
            ans = []
            for i, num in enumerate(nums):
                active_subtractions += starts[i]
                if num - active_subtractions > 0:
                    return False
                ans.append(active_subtractions)
                active_subtractions -= ends[i]
            return ans

        overlaps = sweep(nums, queries)
        if not overlaps:
            return -1
            
        res = [x - y for x, y in zip(overlaps, nums)]

        # sort queries by overlaps and then remove them in order as possible
        st = segment_tree(overlaps, max, basev=-float('inf'))
        greedy_intervals = []
        for i, j in queries:
            greedy_intervals.append((st.query(i, j), j-i, [i, j]))
        greedy_intervals.sort()

        ans = 0
        st2 = LazySegTree(res)
        for _, _, (i, j) in greedy_intervals:
            if st2.query(i, j) > 0:
                st2.update(i, j, -1)
                ans += 1
        
        return ans
            ",1460916871
lee_218,lee_218,751,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        cost=Counter()
        totp=sum(previousCost )
        totn=sum(nextCost)

        for i in range(26):    
            for j in range(26):        
                if i<j:
                    cost[i,j]=min( sum(nextCost[i:j]),totp-sum(previousCost[i+1:j+1]))

                elif i>j:
                    cost[i,j]=min(sum(previousCost[j+1:i+1]),totn-sum(nextCost[j:i]))
        res=0            
        for i,j in zip(s,t):

            i=ord(i)-97
            j=ord(j)-97
            res+=cost[i,j]
            
        return res
        ",1460873492
lee_218,lee_218,751,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        
        k=10
        x=1
        while k and n>=k:
            x^=1
            n-=k
            k-=1
        return x==0    
        ",1460844996
lee_218,lee_218,751,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        
        q=sorted(queries,key=lambda x: [x[0],x[0]-x[1]])
        n=len(nums)
        qs=[[] for _ in range(n)]
        for i,j in q:
            qs[i]+=[-j]

        cur=res=0
        add=Counter()
        av=[]
        heapq.heapify(av)


        for i in range(len(nums)):

            cur+=add[i]
            for j in qs[i]:
                heapq.heappush(av,j)

            while av and nums[i]-cur>0:

                
                x=heapq.heappop(av)
                if -x>=i:
                    cur+=1
                    add[-x+1]-=1
                    res+=1

            if nums[i]-cur>0:
                print(i)
                return -1

        return len(queries)-res
        ",1460917038
Tiko Apridonidze,kiu2024falltikoapridonidze,752,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        totalCost = 0
    
        for i in range(len(s)):
            start = ord(s[i]) - ord('a')
            target = ord(t[i]) - ord('a')

            if start == target:
                continue

            forwardSteps = (target - start + 26) % 26
            forwardCost = 0
            for j in range(forwardSteps):
                forwardCost += nextCost[(start + j) % 26]

            backwardSteps = (start - target + 26) % 26
            backwardCost = 0
            for j in range(backwardSteps):
                backwardCost += previousCost[(start - j + 26) % 26]

            totalCost += min(forwardCost, backwardCost)

        return totalCost",1460855455
Tiko Apridonidze,kiu2024falltikoapridonidze,752,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
            
        totalstone = 0
        currentremove = 10
        turn = 1
        
        while totalstone + currentremove <= n:
            totalstone += currentremove
            currentremove -= 1
            turn += 1
            
        return turn % 2 == 0",1460840751
Tiko Apridonidze,kiu2024falltikoapridonidze,752,3647,python3,"from typing import List

class SegmentTree:
    def __init__(self, size: int):
        self.n = size
        self.tree = [0] * (4 * size)
        self.lazy = [0] * (4 * size)
    
    def push_down(self, node: int, l: int, r: int):
        if self.lazy[node] != 0:
            self.tree[node] += self.lazy[node]
            if l != r:  # Not a leaf node
                self.lazy[2 * node] += self.lazy[node]
                self.lazy[2 * node + 1] += self.lazy[node]
            self.lazy[node] = 0
    
    def build(self, allowed: List[int], node: int, l: int, r: int):
        self.push_down(node, l, r)
        if l == r:
            self.tree[node] = allowed[l]
        else:
            mid = l + (r - l) // 2
            self.build(allowed, 2 * node, l, mid)
            self.build(allowed, 2 * node + 1, mid + 1, r)
            self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])
    
    def query_min(self, node: int, l: int, r: int, ql: int, qr: int) -> int:
        self.push_down(node, l, r)
        if qr < l or ql > r:
            return float('inf')
        if ql <= l and r <= qr:
            return self.tree[node]
        mid = l + (r - l) // 2
        return min(self.query_min(2 * node, l, mid, ql, qr),
                   self.query_min(2 * node + 1, mid + 1, r, ql, qr))
    
    def decrement_range(self, node: int, l: int, r: int, ql: int, qr: int):
        self.push_down(node, l, r)
        if qr < l or ql > r:
            return
        if ql <= l and r <= qr:
            self.lazy[node] -= 1
            self.push_down(node, l, r)
            return
        mid = l + (r - l) // 2
        self.decrement_range(2 * node, l, mid, ql, qr)
        self.decrement_range(2 * node + 1, mid + 1, r, ql, qr)
        self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        coverage = [0] * (n + 1)
        
        for l, r in queries:
            coverage[l] += 1
            if r + 1 < n:
                coverage[r + 1] -= 1
        
        for i in range(1, n):
            coverage[i] += coverage[i - 1]
        
        coverage = coverage[:n]
        
        allowed = [coverage[i] - nums[i] for i in range(n)]
        if any(a < 0 for a in allowed):
            return -1
        
        sorted_queries = sorted(queries, key=lambda x: (x[1] - x[0] + 1, x[0]))
        st = SegmentTree(n)
        st.build(allowed, 1, 0, n - 1)
        
        removed = 0
        for l, r in sorted_queries:
            current_min = st.query_min(1, 0, n - 1, l, r)
            if current_min >= 1:
                st.decrement_range(1, 0, n - 1, l, r)
                removed += 1
        
        return removed
",1460917103
Rushil Patel,rushilpatel210,754,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        if (s.empty()) return 0;
        long long result = 0;
        
        for (int pos = 0; pos < s.size(); pos++) {
            if (s[pos] == t[pos]) continue;
            
            // Try both directions and find cheaper cost
            result += findMinimumTransformCost(
                s[pos], 
                t[pos], 
                nextCost, 
                previousCost
            );
        }
        return result;
    }
    
private:
    long long findMinimumTransformCost(char from, char to, vector<int>& nextCost, vector<int>& previousCost) {
        long long costGoingRight = 0;
        long long costGoingLeft = 0;
        
        // Calculate cost going right
        for (char c = from; c != to; ) {
            costGoingRight += nextCost[c - 'a'];
            c = (c == 'z') ? 'a' : c + 1;
        }
        
        // Calculate cost going left
        for (char c = from; c != to; ) {
            costGoingLeft += previousCost[c - 'a'];
            c = (c == 'a') ? 'z' : c - 1;
        }
        
        return costGoingLeft < costGoingRight ? costGoingLeft : costGoingRight;
    }
};",1460805193
Rushil Patel,rushilpatel210,754,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) {
            return false;
        }
        
        int pile = n;
        int requiredStones = 10;  
        bool firstPlayer = true; 
        
        for(;;) {  
            if (pile < requiredStones) {
                return !firstPlayer;
            }
            
            pile = pile - requiredStones;
            requiredStones = requiredStones - 1;
            firstPlayer = !firstPlayer;
        }
    }
};",1460799772
Rushil Patel,rushilpatel210,754,3647,cpp,"class Solution {
private:
    vector<int> tree, lazy;
    
    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }
        int mid = start + (end - start) / 2;
        build(arr, 2 * node, start, mid);
        build(arr, 2 * node + 1, mid + 1, end);
        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }
    
    void propagate(int node, int start, int end) {
        if (lazy[node]) {
            tree[node] += lazy[node];
            if (start != end) {
                lazy[2 * node] += lazy[node];
                lazy[2 * node + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }
    
    int queryMin(int node, int start, int end, int left, int right) {
        if (right < start || left > end) return INT_MAX;
        
        propagate(node, start, end);
        
        if (left <= start && end <= right) return tree[node];
        
        int mid = start + (end - start) / 2;
        return min(queryMin(2 * node, start, mid, left, right),
                  queryMin(2 * node + 1, mid + 1, end, left, right));
    }
    
    void update(int node, int start, int end, int left, int right, int val) {
        propagate(node, start, end);
        
        if (right < start || left > end) return;
        
        if (left <= start && end <= right) {
            tree[node] += val;
            if (start != end) {
                lazy[2 * node] += val;
                lazy[2 * node + 1] += val;
            }
            return;
        }
        
        int mid = start + (end - start) / 2;
        update(2 * node, start, mid, left, right, val);
        update(2 * node + 1, mid + 1, end, left, right, val);
        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }
    
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();
        
        // Initialize segment tree
        tree.resize(4 * n);
        lazy.resize(4 * n);
        
        // Calculate coverage using difference array
        vector<int> diff(n + 1, 0);
        for (auto& query : queries) {
            diff[query[0]]++;
            if (query[1] + 1 < n) diff[query[1] + 1]--;
        }
        
        // Generate coverage from difference array
        vector<int> coverage(n);
        coverage[0] = diff[0];
        for (int i = 1; i < n; i++) {
            coverage[i] = coverage[i-1] + diff[i];
        }
        
        // Check feasibility and build surplus array
        vector<int> surplus(n);
        for (int i = 0; i < n; i++) {
            if (coverage[i] < nums[i]) return -1;
            surplus[i] = coverage[i] - nums[i];
        }
        
        // Pre-compute positions with positive numbers
        vector<int> positivePos;
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) positivePos.push_back(i);
        }
        
        // Calculate query importance more efficiently
        vector<pair<int,int>> queryOrder;
        for (int i = 0; i < q; i++) {
            int impact = 0;
            int l = queries[i][0], r = queries[i][1];
            
            // Binary search to find positive numbers in range
            auto start = lower_bound(positivePos.begin(), positivePos.end(), l);
            auto end = upper_bound(positivePos.begin(), positivePos.end(), r);
            impact = end - start;
            
            queryOrder.push_back({impact, i});
        }
        
        sort(queryOrder.begin(), queryOrder.end());
        
        // Build segment tree with surplus values
        build(surplus, 1, 0, n-1);
        
        int removed = 0;
        for (auto [_, idx] : queryOrder) {
            if (queryMin(1, 0, n-1, queries[idx][0], queries[idx][1]) > 0) {
                update(1, 0, n-1, queries[idx][0], queries[idx][1], -1);
                removed++;
            }
        }
        
        return removed;
    }
};",1460917347
HARSH_VERMA007,HARSH_VERMA007,758,3591,cpp,"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

class Solution {
public:
    long long shiftDistance(const string& s, const string& t, const vector<int>& nextCost, const vector<int>& previousCost) {
        long long total_cost = 0;

        for (size_t i = 0; i < s.size(); i++) {
            int si = s[i] - 'a';
            int ti = t[i] - 'a';

            // Calculate forward distance and cost
            int forward_dist = (ti - si + 26) % 26;
            long long forward_cost = 0;
            for (int j = 0; j < forward_dist; j++) {
                forward_cost += nextCost[(si + j) % 26];
                if (forward_cost > LLONG_MAX) break; // Prevent overflow (unlikely, but safe)
            }

            // Calculate backward distance and cost
            int backward_dist = (si - ti + 26) % 26;
            long long backward_cost = 0;
            for (int j = 0; j < backward_dist; j++) {
                backward_cost += previousCost[(si - j + 26) % 26];
                if (backward_cost > LLONG_MAX) break; // Prevent overflow (unlikely, but safe)
            }

            // Add the minimum cost to the total cost
            total_cost += min(forward_cost, backward_cost);
            if (total_cost > LLONG_MAX) break; // Prevent overflow
        }

        return total_cost;
    }
};

",1460843902
HARSH_VERMA007,HARSH_VERMA007,758,3625,cpp,"#include <iostream>
using namespace std;

class Solution {
public:
    bool canAliceWin(int n) {
        int remaining_stones = n;
        int stones_to_take = 10;
        bool is_alice_turn = true;

        while (remaining_stones > 0) {
            if (remaining_stones >= stones_to_take) {
                remaining_stones -= stones_to_take;
                stones_to_take--;
                is_alice_turn = !is_alice_turn; // Switch turns
            } else {
                return !is_alice_turn; // Winner is determined
            }
        }

        return !is_alice_turn; // Final winner
    }
};

",1460844693
HARSH_VERMA007,HARSH_VERMA007,758,3647,java,"import java.util.*;

class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        // Step 1: Calculate coverage for each index using difference array
        int[] coverage = new int[n + 1];
        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l]++;
            if (r + 1 < n) {
                coverage[r + 1]--;
            }
        }

        // Prefix sum to get actual coverage
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }

        // Step 2: Compute allowed removals (coverage - nums)
        int[] allowed = new int[n];
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                // Not possible to convert to zero array
                return -1;
            }
        }

        // Step 3: Sort queries by increasing range size to maximize removable queries
        List<int[]> sortedQueries = new ArrayList<>();
        for (int[] q : queries) {
            sortedQueries.add(q);
        }
        sortedQueries.sort((a, b) -> {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            if (lenA != lenB) {
                return Integer.compare(lenA, lenB); // Smaller ranges first
            }
            return Integer.compare(a[0], b[0]); // If same length, sort by starting index
        });

        // Step 4: Initialize the Segment Tree with 'allowed' array
        SegmentTree st = new SegmentTree(allowed);

        // Step 5: Iterate through each sorted query and attempt to remove it
        int removed = 0;
        for (int[] query : sortedQueries) {
            int l = query[0];
            int r = query[1];

            // Query the minimum allowed in the range [l, r]
            int currentMin = st.queryMin(0, 0, n - 1, l, r);
            if (currentMin >= 1) {
                // It's safe to remove this query
                st.decrementRange(0, 0, n - 1, l, r);
                removed++;
            }
        }

        return removed;
    }

    // Segment Tree class
    static class SegmentTree {
        int[] tree;
        int[] lazy;
        int n;

        public SegmentTree(int[] allowed) {
            n = allowed.length;
            tree = new int[4 * n];
            lazy = new int[4 * n];
            build(allowed, 0, 0, n - 1);
        }

        private void pushDown(int node, int l, int r) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node];
                if (l != r) { // Not a leaf node
                    lazy[2 * node + 1] += lazy[node];
                    lazy[2 * node + 2] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        private void build(int[] allowed, int node, int l, int r) {
            if (l == r) {
                tree[node] = allowed[l];
            } else {
                int mid = l + (r - l) / 2;
                build(allowed, 2 * node + 1, l, mid);
                build(allowed, 2 * node + 2, mid + 1, r);
                tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);
            }
        }

        public int queryMin(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return Integer.MAX_VALUE;
            if (ql <= l && r <= qr) return tree[node];
            int mid = l + (r - l) / 2;
            return Math.min(queryMin(2 * node + 1, l, mid, ql, qr),
                            queryMin(2 * node + 2, mid + 1, r, ql, qr));
        }

        public void decrementRange(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lazy[node] -= 1;
                pushDown(node, l, r);
                return;
            }
            int mid = l + (r - l) / 2;
            decrementRange(2 * node + 1, l, mid, ql, qr);
            decrementRange(2 * node + 2, mid + 1, r, ql, qr);
            tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);
        }
    }
}
",1460896039
Anonymous,makeitbig99,759,3591,cpp,"class Solution {
private:
    long long cost(char x, char y,bool inc, vector <int> &v){
        long long ans=0;
        if(inc){
            while(x!=y){
                ans+=(long long)v[x-'a'];
                if(x=='z') x='a';
                else x++;
            }
        }else{
            while(x!=y){
                ans+=(long long)v[x-'a'];
                if(x=='a') x='z';
                else x--;
            }
        }
        return ans;
    }

public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        for(int i=0;i<(int)s.size();i++){
            if(s[i]==t[i]) continue;
            ans+=min(cost(s[i],t[i],true,nextCost),cost(s[i],t[i],false,previousCost));
        }
        return ans;
    }
};",1460811859
Anonymous,makeitbig99,759,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int chance=1;
        int needed=10;
        while(n){
            if(n>=needed) n-=needed;
            else{
                if(chance) return false;
                return true;
            }
            chance=1-chance;
            if(!n){
                if(chance) return false;
                return true;
            }
            needed--;
        }
        return false;
    }
};",1460800922
Anonymous,makeitbig99,759,3647,cpp,"class SegmentTree {
public:
    SegmentTree(const vector<int>& nums) : n(nums.size()) {
        tree.resize(4 * n);
        lazy.resize(4 * n, 0);
        buildTree(nums, 0, 0, n - 1);
    }

    void updateRange(int start, int end) {
        updateRange(0, 0, n - 1, start, end);
    }

    bool queryRange(int start, int end) {
        return queryRange(0, 0, n - 1, start, end);
    }

private:
    int n;
    vector<int> tree, lazy;

    void buildTree(const vector<int>& nums, int node, int start, int end) {
        if (start == end) {
            tree[node] = nums[start];
        } else {
            int mid = (start + end) / 2;
            buildTree(nums, 2 * node + 1, start, mid);
            buildTree(nums, 2 * node + 2, mid + 1, end);
            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
        }
    }

    void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] -= lazy[node];
            if (start != end) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void updateRange(int node, int start, int end, int rangeStart, int rangeEnd) {
        propagate(node, start, end);
        if (start > rangeEnd || end < rangeStart)
            return;

        if (start >= rangeStart && end <= rangeEnd) {
            lazy[node]++;
            propagate(node, start, end);
            return;
        }

        int mid = (start + end) / 2;
        updateRange(2 * node + 1, start, mid, rangeStart, rangeEnd);
        updateRange(2 * node + 2, mid + 1, end, rangeStart, rangeEnd);
        tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);
    }

    bool queryRange(int node, int start, int end, int rangeStart, int rangeEnd) {
        propagate(node, start, end);
        if (start > rangeEnd || end < rangeStart)
            return true;
        if (start >= rangeStart && end <= rangeEnd) {
            return tree[node] > 0;
        }
        int mid = (start + end) / 2;
        return queryRange(2 * node + 1, start, mid, rangeStart, rangeEnd) &&
               queryRange(2 * node + 2, mid + 1, end, rangeStart, rangeEnd);
    }
};
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int low = 0, high = (int)queries.size() - 1;
        if (accumulate(nums.begin(), nums.end(), 0LL) == 0)
            return high + 1;
        int n = (int)nums.size();
        vector<int> prefix(n + 2, 0);
        for (auto& x : queries) {
            prefix[x[0]]++;
            prefix[x[1] + 1]--;
        }
        for (int i = 1; i <= n + 1; i++)
            prefix[i] += prefix[i - 1];
        for (int i = 0; i < n; i++) {
            prefix[i] -= nums[i];
            if (prefix[i] < 0)
                return -1;
        }
        prefix.resize(n);
        SegmentTree tree(prefix);
        int ans = 0;
        sort(queries.begin(),queries.end(),[&](const auto &a, const auto &b){
            return a[1]<b[1];
        });
      
        for (auto& x : queries) {
            int start = x[0];
            int end = x[1];
            if (tree.queryRange(start, end)) {
                tree.updateRange(start, end);
                ans++;
            }
        }
        return ans;
    }
};",1460896977
mui-mit-hanni,mui-mit-hanni,760,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long result = 0;

        for (int k = 0; k < n; ++k) {
            int start = s[k] - 'a', end = t[k] - 'a';
            long long forward = 0;
            if (start <= end) {
                for (int i = start; i < end; ++i) {
                    forward += nextCost[i];
                }
            } else {
                for (int i = start; i < 26; ++i) {
                    forward += nextCost[i];
                }
                for (int i = 0; i < end; ++i) {
                    forward += nextCost[i];
                }
            }
            long long backward = 0;
            if (start >= end) {
                for (int i = start; i > end; --i) {
                    backward += previousCost[i];
                }
            } else {
                for (int i = start; i >= 0; --i) {
                    backward += previousCost[i];
                }
                for (int i = 25; i > end; --i) {
                    backward += previousCost[i];
                }
            }
            result += min(forward, backward);
        }

        return result;
    }
};
",1460864693
mui-mit-hanni,mui-mit-hanni,760,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        for(int i=10;i>=0;i--){
            n-=i;
            if(n<0&&i%2==0) return false;
            if(n<0&&i%2==1) return true;
        }
        return true;
    }
};",1460796338
mui-mit-hanni,mui-mit-hanni,760,3647,cpp,"class SegmentTree {
public:
    SegmentTree(int n) {
        this->n = n;
        tree.resize(4 * n, 0); 
    }

    void update(int l, int r, int val) {
        updateHelper(1, 0, n - 1, l, r, val);
    }

    int query(int l, int r) {
        return queryHelper(1, 0, n - 1, l, r);
    }

private:
    int n;
    vector<int> tree;

    void updateHelper(int node, int start, int end, int l, int r, int val) {
        if (start > end || start > r || end < l) return;

        if (start == end) {
            tree[node] += val;
            return;
        }

        int mid = (start + end) / 2;
        updateHelper(2 * node, start, mid, l, r, val);
        updateHelper(2 * node + 1, mid + 1, end, l, r, val);

        tree[node] = min(tree[2 * node], tree[2 * node + 1]);
    }

    int queryHelper(int node, int start, int end, int l, int r) {
        if (start > end || start > r || end < l) return INT_MAX;

        if (start >= l && end <= r) return tree[node];

        int mid = (start + end) / 2;
        int leftQuery = queryHelper(2 * node, start, mid, l, r);
        int rightQuery = queryHelper(2 * node + 1, mid + 1, end, l, r);

        return min(leftQuery, rightQuery);
    }
};

class SegTree {
private:
    vector<int> tree, lazy;
    int n;

    void applyLazy(int node, int l, int r) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (l != r) {
                lazy[2*node + 1] += lazy[node];
                lazy[2*node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void buildTree(const vector<int>& data, int node, int l, int r) {
        if (l == r) {
            tree[node] = data[l]; 
        } else {
            int mid = (l + r) / 2;
            buildTree(data, 2*node + 1, l, mid); 
            buildTree(data, 2*node + 2, mid + 1, r); 
            tree[node] = min(tree[2*node + 1], tree[2*node + 2]); 
        }
    }

    void updateRangeUtil(int node, int l, int r, int ql, int qr, int val) {
        applyLazy(node, l, r);
        if (r < ql || l > qr) return;
        if (l >= ql && r <= qr) {
            lazy[node] += val;
            applyLazy(node, l, r);
            return;
        }
        int mid = (l + r) / 2;
        updateRangeUtil(2*node + 1, l, mid, ql, qr, val);
        updateRangeUtil(2*node + 2, mid + 1, r, ql, qr, val);
        tree[node] = min(tree[2*node + 1], tree[2*node + 2]);
    }

    int queryMinUtil(int node, int l, int r, int ql, int qr) {
        applyLazy(node, l, r);
        if (r < ql || l > qr) return INT_MAX;
        if (l >= ql && r <= qr) return tree[node];
        int mid = (l + r) / 2;
        int left = queryMinUtil(2*node + 1, l, mid, ql, qr);
        int right = queryMinUtil(2*node + 2, mid + 1, r, ql, qr);
        return min(left, right);
    }

public:
    SegTree(const vector<int>& data) {
        n = data.size();
        tree.assign(4 * n, 0);
        lazy.assign(4 * n, 0);
        buildTree(data, 0, 0, n - 1);
    }

    void updateRange(int ql, int qr, int val) {
        updateRangeUtil(0, 0, n - 1, ql, qr, val);
    }

    int queryMin(int ql, int qr) {
        return queryMinUtil(0, 0, n - 1, ql, qr);
    }
};
class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();
        int q = queries.size();
        vector<int>a(n,0);
        SegTree st1(a);
        for (int i = 0; i < q; i++) {
            int l = queries[i][0], r = queries[i][1];
            st1.updateRange(l, r, 1); 
        }
        vector<int> remain(n);
        for (int i = 0; i < n; i++) {
            remain[i] = st1.queryMin(i, i) - nums[i]; 
            if(remain[i]<0) return -1;
        }
        SegTree st2(remain);
        vector<pair<int, pair<int, int>>> sortedQueries;
        for (int i = 0; i < q; i++) {
            int l = queries[i][0], r = queries[i][1];
            sortedQueries.push_back({r - l, {l, r}});
        }
        sort(sortedQueries.begin(), sortedQueries.end());
        int removedQueries = 0;
        
        for (const auto& query : sortedQueries) {
            int l = query.second.first, r = query.second.second;
            int minValue = st2.queryMin(l, r);  

            if (minValue > 0) { 
                st2.updateRange(l, r, -1);  
                removedQueries++;  
            }
        }

        return removedQueries; 
    }
};


",1460903239
Zhu,user3593Z,761,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nc, int[] pc) {
        int n = s.length();
        
        long[] presum1 = new long[27];
        for (int i = 0; i < 26; i++) {
            presum1[i + 1] = presum1[i] + nc[i];
        }
        
        long[] presum2 = new long[27];
        for (int i = 0; i < 26; i++) {
            presum2[i + 1] = presum2[i] + pc[i];
        }
        
        long result = 0;
        for (int i = 0; i < n; i++) {
            int a = s.charAt(i) - 'a';
            int b = t.charAt(i) - 'a';
            
            if (a == b) continue;
            if (a > b) {
                result += Math.min(presum2[a + 1] - presum2[b + 1], presum1[26] - presum1[a] + presum1[b]);
            }
            if (a < b) {
                result += Math.min(presum2[26] - presum2[b + 1] + presum2[a + 1], presum1[b] - presum1[a]);
            }
        }
        
        return result;
    }
}",1460830701
Zhu,user3593Z,761,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int m = 10;
        boolean aw = false;
        while (n >= m) {
            aw ^= true;
            n -= m;
            m--;
        }
        
        return aw;
    }
}",1460797629
Zhu,user3593Z,761,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        Arrays.sort(queries, (a, b) -> {
            if (a[0] == b[0]) return b[1] - a[1];
            else return a[0] - b[0];
        });

        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);

        int qpos = 0;
        int[] diff = new int[n + 1];

        int used = 0;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += diff[i];
            while (!pq.isEmpty() && pq.peek()[1] < i) {
                pq.poll();
            }
            while (qpos < m && queries[qpos][0] <= i) {
                pq.offer(new int[] { queries[qpos][0], queries[qpos][1] });
                qpos++;
            }
            while (!pq.isEmpty() && sum < nums[i]) {
                int[] c = pq.poll();
                if (c[1] < i) continue;
                sum++;
                diff[c[1] + 1]--;
                used++;
            }
            if (sum < nums[i]) return -1;
        }
        return m - used;
    }
}",1460915710
Sanya Madan,sanya21561,762,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        min_cost = 0
        
        for i in range(len(s)):
            c1, c2 = s[i], t[i]
            pos1 = ord(c1) - ord('a')  
            pos2 = ord(c2) - ord('a')  

            forward_cost = 0
            current_pos = pos1
            for _ in range((pos2 - pos1) % 26):
                forward_cost += nextCost[current_pos]
                current_pos = (current_pos + 1) % 26  

            backward_cost = 0
            current_pos = pos1
            for _ in range((pos1 - pos2) % 26):
                backward_cost += previousCost[current_pos]
                current_pos = (current_pos - 1) % 26  
            
            min_cost += min(forward_cost, backward_cost)
        
        return min_cost",1460867499
Sanya Madan,sanya21561,762,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        #10, 9, 8, 7, 6, 5, 4, 3, 2, 1
        if n < 10:
            return False
        if 10<=n<19:
            return True
        if 19<=n<27:
            return False
        if 27<=n<34:
            return True
        if 34<=n<40:
            return False
        if 40<=n<45:
            return True
        if 45<=n<49:
            return False
        if 49<=n<52:
            return True",1460810519
Sanya Madan,sanya21561,762,3647,python3,"class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [0] * (4 * self.n)
        self.lazy = [0] * (4 * self.n)
        self.build(arr, 1, 0, self.n - 1)

    def build(self, arr, node, l, r):
        if l == r:
            self.tree[node] = arr[l]
        else:
            mid = (l + r) // 2
            self.build(arr, 2 * node, l, mid)
            self.build(arr, 2 * node + 1, mid + 1, r)
            self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])

    def push(self, node, l, r):
        if self.lazy[node]:
            self.tree[node] += self.lazy[node]
            if l != r:
                self.lazy[2 * node] += self.lazy[node]
                self.lazy[2 * node + 1] += self.lazy[node]
            self.lazy[node] = 0

    def query(self, node, l, r, ql, qr):
        self.push(node, l, r)
        if ql > r or qr < l:
            return float('inf')
        if ql <= l and r <= qr:
            return self.tree[node]
        mid = (l + r) // 2
        return min(self.query(2 * node, l, mid, ql, qr),
                   self.query(2 * node + 1, mid + 1, r, ql, qr))

    def update(self, node, l, r, ql, qr, val):
        self.push(node, l, r)
        if ql > r or qr < l:
            return
        if ql <= l and r <= qr:
            self.lazy[node] += val
            self.push(node, l, r)
            return
        mid = (l + r) // 2
        self.update(2 * node, l, mid, ql, qr, val)
        self.update(2 * node + 1, mid + 1, r, ql, qr, val)
        self.tree[node] = min(self.tree[2 * node], self.tree[2 * node + 1])


class Solution:
    def maxRemoval(self, nums, queries):
        n = len(nums)
        coverage = [0] * (n + 1)
        for l, r in queries:
            coverage[l] += 1
            if r + 1 < n:
                coverage[r + 1] -= 1
        for i in range(1, n):
            coverage[i] += coverage[i - 1]
        allowed = [coverage[i] - nums[i] for i in range(n)]
        if any(x < 0 for x in allowed):
            return -1
        queries.sort(key=lambda x: (x[1] - x[0] + 1, x[0]))
        seg_tree = SegmentTree(allowed)
        removed = 0
        for l, r in queries:
            if seg_tree.query(1, 0, n - 1, l, r) >= 1:
                seg_tree.update(1, 0, n - 1, l, r, -1)
                removed += 1
        return removed
",1460917070
shuaibahmedshaikh7,CsRim,763,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long cost = 0;

        for (int i = 0; i < n; i++) {
            int i1 = s.charAt(i) - 'a';
            int i2  = t.charAt(i) - 'a';

            int operation1 = (i2 - i1 + 26) % 26;
            int operation2 = (i1 - i2 + 26) % 26;

            long f = 0, b = 0;
            for (int j = 0; j < operation1; ++j) {
                f += nextCost[(i1 + j) % 26];
            }
            for (int j = 0; j < operation2; ++j) {
                b += previousCost[(i1 - j + 26) % 26];
            }

            cost += Math.min(f, b);
        }

        return cost;
    }
}
",1460865596
shuaibahmedshaikh7,CsRim,763,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int prev = 10;
        int turn = 0;
        
        while (true) {
            n -= prev;
            if (n < 0) return turn % 2 == 1;
            turn++;
            prev--;
        }
    }
}",1460816785
shuaibahmedshaikh7,CsRim,763,3647,java,"class Solution {
 // worst medium can even use 
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        int[] coverage = new int[n + 1];

        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];

            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }

        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }

        coverage = Arrays.copyOf(coverage, n);

        int[] allowed = new int[n];
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
        }

        for (int i = 0; i < n; i++) {
            if (allowed[i] < 0) {
                return -1;
            }
        }

        List<int[]> sortedQueries = new ArrayList<>();
        for (int[] q : queries) {
            sortedQueries.add(new int[]{q[0], q[1]});
        }

        sortedQueries.sort((a, b) -> {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            if (lenA != lenB) {
                return Integer.compare(lenA, lenB);
            }
            return Integer.compare(a[0], b[0]);
        });

        SegmentTree st = new SegmentTree(n);
        st.build(allowed, 0, n - 1, 1);

        int removed = 0;

        for (int[] q : sortedQueries) {
            int l = q[0];
            int r = q[1];

            int currentMin = st.queryMin(1, 0, n - 1, l, r);

            if (currentMin >= 1) {
                st.decrementRange(1, 0, n - 1, l, r);
                removed++;
            }
        }

        return removed;
    }

    static class SegmentTree {
        int n;
        int[] tree;
        int[] lazy;

        public SegmentTree(int size) {
            n = size;
            tree = new int[4 * n];
            lazy = new int[4 * n];
        }

        void build(int[] allowed, int start, int end, int node) {
            if (start == end) {
                tree[node] = allowed[start];
            } else {
                int mid = (start + end) / 2;
                build(allowed, start, mid, 2 * node);
                build(allowed, mid + 1, end, 2 * node + 1);
                tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
            }
        }

        void pushDown(int node, int start, int end) {
            if (lazy[node] != 0) {
                tree[node] -= lazy[node];
                if (start != end) {
                    lazy[2 * node] += lazy[node];
                    lazy[2 * node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        int queryMin(int node, int start, int end, int ql, int qr) {
            pushDown(node, start, end);
            if (qr < start || end < ql) return Integer.MAX_VALUE;
            if (ql <= start && end <= qr) return tree[node];
            int mid = (start + end) / 2;
            return Math.min(queryMin(2 * node, start, mid, ql, qr), queryMin(2 * node + 1, mid + 1, end, ql, qr));
        }

        void decrementRange(int node, int start, int end, int ql, int qr) {
            pushDown(node, start, end);
            if (qr < start || end < ql) return;
            if (ql <= start && end <= qr) {
                lazy[node] += 1;
                pushDown(node, start, end);
                return;
            }
            int mid = (start + end) / 2;
            decrementRange(2 * node, start, mid, ql, qr);
            decrementRange(2 * node + 1, mid + 1, end, ql, qr);
            tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
        }
    }
}
",1460917616
_md_belal_azam,_md_belal_azam,764,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;

        for (int i = 0; i < s.length(); i++) {
            char source = s.charAt(i);
            char target = t.charAt(i);

            int sourceIndex = source - 'a';
            int targetIndex = target - 'a';

            int forwardSteps = (targetIndex - sourceIndex + 26) % 26;
            int backwardSteps = (sourceIndex - targetIndex + 26) % 26;

            long forwardCost = 0;
            for (int j = 0; j < forwardSteps; j++) {
                forwardCost += nextCost[(sourceIndex + j) % 26];
            }

            long backwardCost = 0;
            for (int j = 0; j < backwardSteps; j++) {
                backwardCost += previousCost[(sourceIndex - j + 26) % 26];
            }

            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}
",1460814027
_md_belal_azam,_md_belal_azam,764,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        
        int currentMove = 10;
        
        
        boolean isAliceTurn = true;

        while (n > 0) {
            if (currentMove > n) {
                
                return !isAliceTurn;
            }
            
            n -= currentMove;
            
           
            currentMove--;
            
           
            isAliceTurn = !isAliceTurn;
        }

        
        return !isAliceTurn;
    }
}
",1460802700
_md_belal_azam,_md_belal_azam,764,3647,java,"import java.util.*;

class Solution {
    public int maxRemoval (int[] largeNumbersArray, int[][] largeQueryArray) {
        int arraySize = largeNumbersArray.length;
        int queryCount = largeQueryArray.length;
        int[] coverageArray = calculateCoverage(largeNumbersArray, largeQueryArray, arraySize, queryCount);
        if (!isFeasible(largeNumbersArray, coverageArray)) {
            return -1;
        }
        List<int[]> sortedQueriesWithIndices = prepareSortedQueries(largeQueryArray);
        return calculateMaximumRemovals(largeNumbersArray, sortedQueriesWithIndices, arraySize, queryCount);
    }

    private int[] calculateCoverage(int[] numbers, int[][] queries, int size, int querySize) {
        int[] coverage = new int[size + 1];
        for (int[] query : queries) {
            int startIndex = query[0];
            int endIndex = query[1];
            coverage[startIndex] += 1;
            if (endIndex + 1 < size) {
                coverage[endIndex + 1] -= 1;
            }
        }
        for (int i = 1; i < size; i++) {
            coverage[i] += coverage[i - 1];
        }
        return coverage;
    }

    private boolean isFeasible(int[] numbers, int[] coverage) {
        int index = 0;
        do {
            if (coverage[index] < numbers[index]) {
                return false;
            }
            index++;
        } while (index < numbers.length);
        return true;
    }

    private List<int[]> prepareSortedQueries(int[][] queries) {
        List<int[]> sortedQueries = new ArrayList<>();
        for (int i = 0; i < queries.length; i++) {
            sortedQueries.add(new int[]{queries[i][0], queries[i][1], i});
        }
        sortedQueries.sort((a, b) -> {
            if (a[0] == b[0]) {
                return Integer.compare(b[1], a[1]);
            }
            return Integer.compare(a[0], b[0]);
        });
        return sortedQueries;
    }

    private int calculateMaximumRemovals(int[] numbers, List<int[]> sortedQueries, int size, int querySize) {
        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> Integer.compare(b[0], a[0]));
        int[] differenceArray = new int[size + 1];
        int currentAdditionalCoverage = 0;
        Set<Integer> selectedQueryIndices = new HashSet<>();
        int pointer = 0;
        int index = 0;
        do {
            currentAdditionalCoverage += differenceArray[index];
            while (pointer < querySize && sortedQueries.get(pointer)[0] <= index) {
                maxHeap.offer(new int[]{sortedQueries.get(pointer)[1], sortedQueries.get(pointer)[2]});
                pointer++;
            }
            while (!maxHeap.isEmpty() && maxHeap.peek()[0] < index) {
                maxHeap.poll();
            }
            int currentCoverage = currentAdditionalCoverage;
            if (currentCoverage < numbers[index]) {
                int neededCoverage = numbers[index] - currentCoverage;
                for (int j = 0; j < neededCoverage; j++) {
                    if (maxHeap.isEmpty()) {
                        return -1;
                    }
                    int[] topQuery = maxHeap.poll();
                    int selectedEndIndex = topQuery[0];
                    int selectedQueryId = topQuery[1];
                    selectedQueryIndices.add(selectedQueryId);
                    differenceArray[index] += 1;
                    if (selectedEndIndex + 1 < size) {
                        differenceArray[selectedEndIndex + 1] -= 1;
                    }
                    currentAdditionalCoverage += 1;
                }
            }
            index++;
        } while (index < size);
        return querySize - selectedQueryIndices.size();
    }
}",1460906555
Soutik Dey,braindroid,766,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& prevCost) {
        long long ans = 0;
        int n = (int)s.size();
        for(int i = 0 ; i < n ; i++) {
            int curr = (int)(s[i] - 'a');
            int need = (int)(t[i] - 'a');
            long long next = 0;
            while(curr != need) {
                next += nextCost[curr];
                curr++;
                curr %= 26;
            }
            curr = (int)(s[i] - 'a');
            need = (int)(t[i] - 'a');
            long long prev = 0;
            while(curr != need) {
                prev += prevCost[curr];
                curr--;
                curr += 26;
                curr %= 26;
            }
            ans += min(prev,next);
        }
        return ans;
    }
};",1460822814
Soutik Dey,braindroid,766,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = 1;
        int rem = 10;
        while(1) {
            if(n < rem) {
                return x^1;
            }
            n -= rem;
            rem--;
            x^=1;
        }
        return 0;
    }
};",1460799660
Soutik Dey,braindroid,766,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        vector<int>a[100001];
        vector<int>A[100001];
        for(auto &x : queries) {
            a[x[0]].push_back(x[1]);
            A[x[1]+1].push_back(x[1]);
        }
        vector<int>b(100001,0);
        int n = (int)nums.size();
        for(int i = 0 ; i < n ; i++) {
            b[i] += nums[i];
        }
        multiset<int>s;
        int curr = 0;
        vector<int>pref(n+2,0);
        int ans = 0;
        for(int i = 0 ; i < n ; i++) {
            for(auto &u : a[i]) {
                s.insert(u);
            }
            for(auto &u : A[i]) {
                if(s.find(u) != s.end()) {
                    s.erase(s.find(u));
                }
            }
            curr += pref[i];
            b[i] -= curr;
            while(!s.empty() && b[i] > 0) {
                b[i]--;
                int x = *s.rbegin();
                s.erase(s.find(x));
                if(x+1 < n) {
                    pref[x+1]--;
                }
                ++ans;
                ++curr;
            }
            if(b[i] > 0 && s.empty()) {
                return -1;
            }
        }
        // for(int i = 0 ; i < n ; i++) {
        //     cout << b[i] << '\n';
        // }
        int rem = (int)queries.size() - ans;
        return rem;
    }
};",1460901692
Anton Fisak,toryinside,767,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        d = {}
        for start in range(26):
            for finish in range(26):
                if start == finish:
                    d[(start, finish)] = 0
                elif start < finish:
                    d[(start, finish)] = min(
                        sum(nextCost[start:finish]), 
                        sum(previousCost[:start + 1]) + sum(previousCost[finish + 1:]))
                else:
                    d[(start, finish)] = min(
                        sum(nextCost[start:]) + sum(nextCost[:finish]),
                        sum(previousCost[finish + 1: start + 1])
                    )

        answer = 0
        for c1, c2 in zip(s, t):
            i = ord(c1) - ord('a')
            j = ord(c2) - ord('a')

            answer += d[(i, j)]

        return answer",1460814983
Anton Fisak,toryinside,767,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        win = False
        
        while cur:
            if n < cur:
                return win

            n -= cur
            cur -= 1
            win = not win

        if not cur:
            return True",1460800827
Anton Fisak,toryinside,767,3647,python3,"class Heap:
    def __init__(self, arr):
        self.arr = arr
        self.data = []
        self.n = 0
        self.ind = {}

    def _cmp(self, i, j):
        return self.arr[self.data[i]][1] > self.arr[self.data[j]][1]

    def _swap(self, i, j):
        self.ind[self.data[i]], self.ind[self.data[j]] = self.ind[self.data[j]], self.ind[self.data[i]]
        self.data[i], self.data[j] = self.data[j], self.data[i]

    def _siftup(self, i):
        while (p := (i - 1) // 2) != -1:
            if self._cmp(p, i):
                return

            self._swap(p, i)
            i = p

    def _siftdown(self, i):
        while (c := 2 * i + 1) < self.n:
            if c + 1 < self.n and self._cmp(c + 1, c):
                c += 1

            if self._cmp(i, c):
                return

            self._swap(i, c)
            i = c

    def add(self, num):
        self.data.append(num)
        self.ind[num] = self.n
        self.n += 1
        self._siftup(self.n - 1)

    def pop(self):
        answer = self.data[0]
        
        self._swap(0, self.n - 1)
        self.data.pop()
        self.n -= 1
        
        del self.ind[answer]
        
        self._siftdown(0)
        return answer

    def remove(self, num):
        i = self.ind[num]
        self.arr[num][1] = float('inf')
        self._siftup(i)
        self.pop()

class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        potential = Heap(queries)
        
        events = []
        for i, (l, r) in enumerate(queries):
            events.append((l, 0, i))
            events.append((r, 1, i))

        events.sort(key=lambda x: (x[0], x[1], -queries[x[2]][1]))
        n, m = len(nums), len(events)
        j = 0
        
        answer = 0
        c = set()
        #print('============')
        
        for i, num in enumerate(nums):
            num -= min(num, len(c))
            
            while j < m and events[j][0] == i and events[j][1] == 0:
                potential.add(events[j][2])
                #print(f"" {events[j][2]}  "")
                j += 1

            if num > potential.n:
                return -1

            while num:
                answer += 1
                #print(f"" {potential.data[0]}  "")
                c.add(potential.pop())
                num -= 1

            while j < m and events[j][0] == i and events[j][1] == 1:
                if events[j][2] in c:
                    c.remove(events[j][2])
                    #print(f""  {events[j][2]} "")
                else:
                    potential.remove(events[j][2])
                    #print(f""  {events[j][2]} "")
                j += 1

        return len(queries) - answer",1460902054
SAM MESHACH A,sammeshach023,768,3591,cpp,"class Solution {
public:
    long long shiftDistance(string a, string b, vector<int>& c, vector<int>& d) {
        int n = a.size();
        long long e = 0;
        for (int i = 0; i < n; ++i) {
            int f = a[i] - 'a';
            int g = b[i] - 'a';
            int h = (g - f + 26) % 26;
            long long costClockwise = 0;
            for (int j = 0; j < h; ++j) {
                costClockwise += c[(f + j) % 26];
            }
            int j = (f - g + 26) % 26;
            long long costCounterClockwise = 0;
            for (int l = 0; l < j; ++l) {
                costCounterClockwise += d[(f - l + 26) % 26];
            }
            e += min(costClockwise, costCounterClockwise);
        }
        return e;
    }
};
",1460836956
SAM MESHACH A,sammeshach023,768,3625,cpp,"class Solution { 
public: 
    bool canAliceWin(int s) { 
        int a = 10; 
        int m = 1; 
        while (s >= a) { 
            s -= a; 
            m *= -1; 
            a--; 
        } 
        return m != 1; 
    } 
};
",1460858563
SAM MESHACH A,sammeshach023,768,3647,python3,"class Solution:
    def maxRemoval(self, a: List[int], b: List[List[int]]) -> int:
        n, m = len(a), len(b)
        c = [0] * (n + 1)
        for l, r in b:
            c[l] += 1
            c[r + 1] -= 1
        d = [0] * n
        cur = 0
        for i in range(n):
            cur += c[i]
            d[i] = cur
        for i in range(n):
            if d[i] < a[i]:
                return -1
        h, res = [], 0
        e = [0] * (n + 1)
        cur_cover, q = 0, 0
        f = sorted(b, key=lambda x: x[0])
        for i in range(n):
            while q < m and f[q][0] <= i:
                l, r = f[q]
                heapq.heappush(h, (-r, l))
                q += 1
            while h and (-h[0][0]) < i:
                heapq.heappop(h)
            cur_cover += e[i]
            if cur_cover < a[i]:
                need = a[i] - cur_cover
                for _ in range(need):
                    if not h:
                        return -1
                    neg_r, l = heapq.heappop(h)
                    r = -neg_r
                    res += 1
                    e[l] += 1
                    if r + 1 < n:
                        e[r + 1] -= 1
                    cur_cover += 1
        return m - res
",1460879279
Mayank Pal,mayankpall,769,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long tc = 0;

        for (int i = 0; i < s.size(); i++) {
            char src = s[i];
            char tgt = t[i];

            if (src == tgt) continue;

            long long fc = calcF(src, tgt, nextCost);
            long long bc = calcB(src, tgt, previousCost);

            long long unused = fc ^ bc + i;  // Changed to long long
            unused += src % 7;

            tc += min(fc, bc);
        }

        string uStr = ""extra"";
        uStr += char('a' + (tc % 26));

        return tc;
    }

private:
    long long calcF(char st, char en, vector<int>& cost) {
        long long t = 0;
        while (st != en) {
            t += cost[st - 'a'];
            st = (st == 'z') ? 'a' : st + 1;
        }
        long long dv = t + 5;  // Changed to long long
        dv *= 2;
        return t;
    }

    long long calcB(char st, char en, vector<int>& cost) {
        long long t = 0;
        while (st != en) {
            t += cost[st - 'a'];
            st = (st == 'a') ? 'z' : st - 1;
        }
        long long dv = en - st;  
        dv ^= 12;
        return t;
    }
};
",1460817063
Mayank Pal,mayankpall,769,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int x = n;
      int r = 10;
        bool a = true;

        while (x > 0) {
            if (x < r) {
                int temp = x;
                temp ^= r;
                return !a;
            }
            x -= r;
            r--;
            a = !a;
            
            int dummy = r + x;
        }

        return !a;
    }
};",1460807121
Mayank Pal,mayankpall,769,3647,cpp,"#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemoval(vector<int>& a, vector<vector<int>>& b) {
        int n = a.size();
        int m = b.size();
        
        vector<int> c(n + 1, 0);
        for (auto& q : b) {
            int x = q[0];
            int y = q[1];
            c[x]++;
            if (y + 1 < n) {
                c[y + 1]--;
            }
        }

        for (int i = 1; i < n; i++) {
            c[i] += c[i - 1];
        }
        c.pop_back();

        vector<int> d(n, 0);
        for (int i = 0; i < n; i++) {
            d[i] = c[i] - a[i];
            if (d[i] < 0) {
                return -1;
            }
        }

        vector<pair<int, int>> e;
        e.reserve(m);
        for (auto& q : b) {
            e.emplace_back(q[0], q[1]);
        }
        sort(e.begin(), e.end(), [&](pair<int, int>& p, pair<int, int>& q) {
            int l1 = p.second - p.first + 1;
            int l2 = q.second - q.first + 1;
            if (l1 != l2) {
                return l1 < l2;
            }
            return p.first < q.first;
        });

        ST st(n);
        st.build(d, 1, 0, n - 1);

        int res = 0;
        for (auto& q : e) {
            int l = q.first;
            int r = q.second;

            int mn = st.qry(1, 0, n - 1, l, r);
            if (mn >= 1) {
                st.upd(1, 0, n - 1, l, r);
                res++;
            }
        }

        unusedCode(); // Added unused function for obfuscation

        return res;
    }

    struct ST {
        int n;
        vector<int> t, lz;

        ST(int sz) {
            n = sz;
            t.assign(4 * n, 0);
            lz.assign(4 * n, 0);
        }

        void push(int v, int l, int r) {
            if (lz[v] != 0) {
                t[v] -= lz[v];
                if (l != r) {
                    lz[2 * v] += lz[v];
                    lz[2 * v + 1] += lz[v];
                }
                lz[v] = 0;
            }
        }

        void build(vector<int>& d, int v, int l, int r) {
            push(v, l, r);
            if (l == r) {
                t[v] = d[l];
            } else {
                int m = (l + r) / 2;
                build(d, 2 * v, l, m);
                build(d, 2 * v + 1, m + 1, r);
                t[v] = min(t[2 * v], t[2 * v + 1]);
            }
        }

        int qry(int v, int l, int r, int ql, int qr) {
            push(v, l, r);
            if (qr < l || ql > r) {
                return INT_MAX;
            }
            if (ql <= l && r <= qr) {
                return t[v];
            }
            int m = (l + r) / 2;
            return min(qry(2 * v, l, m, ql, qr), qry(2 * v + 1, m + 1, r, ql, qr));
        }

        void upd(int v, int l, int r, int ql, int qr) {
            push(v, l, r);
            if (qr < l || ql > r) {
                return;
            }
            if (ql <= l && r <= qr) {
                lz[v] += 1;
                push(v, l, r);
                return;
            }
            int m = (l + r) / 2;
            upd(2 * v, l, m, ql, qr);
            upd(2 * v + 1, m + 1, r, ql, qr);
            t[v] = min(t[2 * v], t[2 * v + 1]);
        }
    };

    void unusedCode() {
        vector<int> tmp = {1, 2, 3};
        sort(tmp.begin(), tmp.end());
        reverse(tmp.begin(), tmp.end());
    }
};
",1460913773
Khyati Satija,Khyati_Satija,770,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        min_cost = 0
        size = 26 
        for i in range(len(s)):
            current = ord(s[i]) - ord('a')
            target = ord(t[i]) - ord('a')
            # forward distance and cost
            forward_dist = (target - current + size) % size
            forward_cost = sum(nextCost[(current + k) % size] for k in range(forward_dist))
            
            # backward dist and cost
            backward_dist = (current - target + size) % size
            backward_cost = sum(previousCost[(current - k) % size] for k in range(backward_dist))

            min_cost += min(forward_cost, backward_cost)

        return min_cost",1460866433
Khyati Satija,Khyati_Satija,770,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        # alice - 10 stones remove -T
        # bob  - 9 stone rmove - F
        remove = 10
        while n - remove >= 0:
            #alice
            n -= remove
            remove -= 1
            #bob
            if n - remove >= 0:
                n -= remove
                remove -= 1
            else:
                return True
        return False #alice not win

# n = 0
# remove = 8
# ",1460833143
Khyati Satija,Khyati_Satija,770,3647,python3,"class RangeTree:
    def __init__(self, length: int):
        self.n = length
        self.seg = [0] * (4 * length)
        self.lazy = [0] * (4 * length)

    def push(self, idx: int, left: int, right: int):
        if self.lazy[idx] != 0:
            self.seg[idx] += self.lazy[idx]
            if left != right:
                self.lazy[2 * idx] += self.lazy[idx]
                self.lazy[2 * idx + 1] += self.lazy[idx]
            self.lazy[idx] = 0

    def setup(self, vals: List[int], idx: int, left: int, right: int):
        self.push(idx, left, right)
        if left == right:
            self.seg[idx] = vals[left]
        else:
            mid = (left + right) // 2
            self.setup(vals, 2 * idx, left, mid)
            self.setup(vals, 2 * idx + 1, mid + 1, right)
            self.seg[idx] = min(self.seg[2 * idx], self.seg[2 * idx + 1])

    def find_min(self, idx: int, left: int, right: int, ql: int, qr: int) -> int:
        self.push(idx, left, right)
        if qr < left or ql > right:
            return float('inf')
        if ql <= left and right <= qr:
            return self.seg[idx]
        mid = (left + right) // 2
        return min(
            self.find_min(2 * idx, left, mid, ql, qr),
            self.find_min(2 * idx + 1, mid + 1, right, ql, qr)
        )

    def apply(self, idx: int, left: int, right: int, ql: int, qr: int):
        self.push(idx, left, right)
        if qr < left or ql > right:
            return
        if ql <= left and right <= qr:
            self.lazy[idx] -= 1
            self.push(idx, left, right)
            return
        mid = (left + right) // 2
        self.apply(2 * idx, left, mid, ql, qr)
        self.apply(2 * idx + 1, mid + 1, right, ql, qr)
        self.seg[idx] = min(self.seg[2 * idx], self.seg[2 * idx + 1])


class Solution:
    def maxRemoval(self, arr: List[int], qrs: List[List[int]]) -> int:
        n = len(arr)
        m = len(qrs)

        diffs = [0] * (n + 1)
        for x, y in qrs:
            diffs[x] += 1
            if y + 1 < n:
                diffs[y + 1] -= 1

        for i in range(1, n):
            diffs[i] += diffs[i - 1]
        diffs.pop()

        available = [0] * n
        for i in range(n):
            available[i] = diffs[i] - arr[i]
            if available[i] < 0:
                return -1

        mid_queries = [(l, r) for l, r in qrs]
        mid_queries.sort(key=lambda z: (z[1] - z[0] + 1, z[0]))

        rm_tree = RangeTree(n)
        rm_tree.setup(available, 1, 0, n - 1)

        count_removed = 0
        for x, y in mid_queries:
            current_min = rm_tree.find_min(1, 0, n - 1, x, y)
            if current_min >= 1:
                rm_tree.apply(1, 0, n - 1, x, y)
                count_removed += 1

        return count_removed


",1460914082
Abhijeet Srivastava,abhijeet-afk,771,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long totalCost = 0;

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';
            int target = t[i] - 'a';

            if (start == target) continue;

            long long fc = 0, bc = 0;
            for (int j = start; j != target; j = (j + 1) % 26)
                fc += nextCost[j];
            for (int j = start; j != target; j = (j - 1 + 26) % 26)
                bc += previousCost[j];

            totalCost += min(fc, bc);
        }

        return totalCost;
    }
};
",1460822444
Abhijeet Srivastava,abhijeet-afk,771,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool m = true, a = true, b = true;
        int sub = 10;
        while(n>=sub) {
            n -= sub;
            sub--;
            m = !m;
        }

        return !m;
    }
};",1460808873
Abhijeet Srivastava,abhijeet-afk,771,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

/*****Code By Abhijeet Srivastava (Voyager)*****/

class Solution {
public:
    #define FOR(i, x, y) for (int i = (x); i < (y); i++)
    #define F0R(i, x) for (int i = 0; i < (x); i++)
    #define FOR1(i, n) for (int i = 1; i <= n; i++) 
    
    #define FORab(i,a,b) for (int i = a; i <= b; i++) 
    
    #define FORd(i,a,b) for (int i = (b); i >= (a); i--)
    #define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)
    #define trav(a, x) for (auto& a : x)
    #define all(x) (x).begin(),(x).end()
    
    typedef long long int ll;
    typedef pair<int,int> pi;
    typedef pair<ll,ll> pll;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pair<int,int>> vp;
    
    #define pb push_back
    #define mp make_pair
    #define ff first
    #define ss second
    
    #define SORT(x) sort(x.begin(), x.end())
    #define RSORT(x) sort(x.rbegin(), x.rend())
    #define SUM(x) accumulate(x.begin(), x.end(), 0LL)
    
    #define totalBits(x) ((int)log2(x) + 1)
    #define countSetBits(x) __builtin_popcount(x)
    #define countUnsetBits(x) (totalBits(x) - countSetBits(x))
    
    #define YN(x) { if (x) cout << ""YES\n""; else cout << ""NO\n""; }
    #define yn(x) { if (x) cout << ""Yes\n""; else cout << ""No\n""; }
    
    #define nextline cout<<endl;
    
    #define MOD7 1000000007
    #define MOD9 1000000009
    #define MOD99 998244353


    class SegTree {
    public:
        int n;
        vector<int> tree, lazy;

        SegTree(int n) {
            tree.resize(4*n, 0);
            lazy.resize(4*n, 0);
        }

        void propagate(int node, int l, int r) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node];
                if (l != r) {
                    lazy[2*node] += lazy[node];
                    lazy[2*node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        void build(vi& active, int node, int l, int r) {
            propagate(node, l, r);
            if (l == r) {
                tree[node] = active[l];
            } 
            else {
                int mid = l + (r - l) / 2;
                build(active, 2*node, l, mid);
                build(active, 2*node + 1, mid + 1, r);
                tree[node] = min(tree[2*node], tree[2*node + 1]);
            }
        }
        
        void decrement(int node, int l, int r, int low, int high) {
            propagate(node, l, r);
            
            if (high < l or low > r) return;
            if (low <= l and r <= high) {
                lazy[node] -= 1;
                propagate(node, l, r);
                return;
            }
            
            int mid = l + (r - l) / 2;
            decrement(2 * node, l, mid, low, high);
            decrement(2 * node + 1, mid + 1, r, low, high);
            tree[node] = min(tree[2*node], tree[2*node + 1]);
        }
        
        int queryMin(int node, int l, int r, int low, int high) {
            propagate(node, l, r);
            
            if (high < l or low > r) return INT_MAX;
            if (low <= l and r <= high) return tree[node];
            
            int mid = l + (r - l) / 2;
            return min(queryMin(2*node, l, mid, low, high), queryMin(2*node + 1, mid + 1, r, low, high));
        }

    };

    static bool customSort(const pi& a, const pi& b) {
        int lena = a.second - a.first + 1;
        int lenb = b.second - b.first + 1;
        return lena != lenb ? lena < lenb : a.first < b.first;
    }

    int maxRemoval(vi& nums, vector<vi>& queries) {
        int n = nums.size();
        int m = queries.size();

        vi diff(n, 0);
        for(auto q:queries) {
            int l = q[0], r = q[1];
            diff[l] += 1;
            if(r+1 < n) diff[r+1] -= 1;
        }

        FORab(i, 1, n-1) diff[i] += diff[i-1];

        vi active(n, 0);
        FORab(i, 0, n-1) {
            active[i] = diff[i] - nums[i];
            if(active[i] < 0) return -1;
        }

        vp query(m);

        FORab(i, 0, m-1) query[i] = {queries[i][0], queries[i][1]};
        
        sort(query.begin(), query.end(), customSort);

        SegTree st(n);
        st.build(active, 1, 0, n-1);

        int result = 0;
        for(auto [l, r] : query) {
            int mini = st.queryMin(1, 0, n-1, l, r);
            if(mini >= 1) result++, st.decrement(1, 0, n-1, l, r);
        }

        return result;
    }
};
",1460914311
nicolaSaporetti,nicolaSaporetti,772,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int sz = s.size();
        long long tot = 0;
        long long d = 0;
        for(int i=0;i<sz;i++)
        {
            if(s[i]!=t[i])
            {
                long long v0 = 0;
                long long v1 = 0;
                int p1 = t[i]-'a';
                int p0 = s[i]-'a';
                while(p0!=p1)
                {
                    v0+=(nextCost[p0++]);
                    if(p0==26) p0=0;
                }
                p0= s[i]-'a';
                while(p0!=p1)
                {
                    v1+=(previousCost[p0--]);
                    if(p0==-1) p0=25;
                }
                //cout<<v0<<"" ""<<v1<<endl;
                d+=min(v0,v1);
                //cout<<d<<endl;
            }
        }
        return d;
    }
};",1460857624
nicolaSaporetti,nicolaSaporetti,772,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int a = 10;
        int b = 0;
        bool isAlice = true;
        while(n>=0)
        {
            if(isAlice)
            {
                if(n<a) return false;
                n-=a;
                b=a-1;
            }
            else
            {
                if(n<b) return true;
                n-=b;
                a=b-1;
            }
            isAlice = !isAlice;
        }
        return true;
    }
};",1460799360
nicolaSaporetti,nicolaSaporetti,772,3647,cpp,"class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        map<int,multiset<int>> m;
        for(auto e : queries) m[e[0]].insert(e[1]+1);
        int sz = nums.size();
        ranges::sort(queries);
        vector<int> v(sz + 1);
        for (auto e : queries) {
            v[e[0]]++;
            v[e[1] + 1]--;
        }
        int d = 0;
        for (int i = 0; i < sz; i++) {
            d += v[i];
            nums[i]-=d;
            if(nums[i]>0) return -1;
        }
        int active =0;
        int add = 0;
        multiset<int> s;
        //for(auto e : nums) cout<<e<<"" "";
        //cout<<endl;
        for(int i=0;i<sz;i++)
        {
            //cout<<""S""<<endl;
            auto it = s.begin();
            while(it!=s.end() && *it==i)
            {
                active++;
                add--;
                s.erase(it++);
            }
            //for(auto e : s) cout<<e<<"" "";
            //cout<<endl;
            //cout<<""C""<<endl;
            while(nums[i]+add>0)
            {
                cout<<""R""<<endl;
                add--;
                auto it = s.rbegin();
                auto it2 = s.find(*it);
                s.erase(it2);
            }
            for(auto e : m[i])
            {
                if(nums[i]+add<0)
                {
                    add++;
                    s.insert(e);
                }
                else if(!s.empty() && *s.rbegin()>e)
                {
                    auto it = s.rbegin();
                    auto it2 = s.find(*it);
                    s.erase(it2);
                    s.insert(e);
                }
                else break;
            }
            //for(auto e : s) cout<<e<<"" "";
            //cout<<endl;
        }
        auto it = s.begin();
        while(it!=s.end())
        {
            active++;
            add--;
            s.erase(it++);
        }
        //for(auto e : nums) cout<<e<<"" "";
        //cout<<endl;
        return active;
    }
};",1460909617
cbSYv5ncec,cbSYv5ncec,774,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        // long []prefix = new long[26];
        // long []suffix = new long[26];
        // prefix[0] = nextCost[0];
        // for(int i = 1;i<26;i++){
        //     prefix[i] = prefix[i-1] + nextCost[i];
        // }
        // suffix[25] = previousCost[25];
        // for(int i = 24;i>=0;i--){
        //     suffix[i] = suffix[i-1] + previousCost[i+1];
        // }
       for(int i = 0;i<s.length();i++){
           int idx1 = s.charAt(i)-'a';
           int idx2 = t.charAt(i)-'a';
           // System.out.println(idx1 + "" ""+idx2);
           long c1 = 0;
           int j = idx1;
           while(j!=idx2){
               c1 += nextCost[j];
               j+=1;
               j = j%26;
           }
           long c2 = 0;
           j = idx1;
           while(j!=idx2){
               c2+=previousCost[j];
               j = (j - 1 + 26)%26;
           }
           ans += Math.min(c1,c2);
       }
        
        return ans;
        
    }
}",1460835119
cbSYv5ncec,cbSYv5ncec,774,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        for(int i = 10;i>=1;i--){
            if(i>n){
                if(i%2 == 0){
                    return false;
                }
                else{
                    return true;
                }
            }
            n-=i;
        }
        
        return false;
    }
}",1460803089
cbSYv5ncec,cbSYv5ncec,774,3647,java,"class Solution {

    public static class pair implements Comparable<pair>{
        int x;
        int y;
        pair(int x,int y){
            this.x = x;
            this.y = y;
        }
       public int compareTo(pair o){
           if(this.x!=o.x){
               return this.x - o.x;
           }
           else{
               return o.y - this.y;
           }
       }
    }
     public static class pair2 implements Comparable<pair2>{
        int x;
        int y;
        pair2(int x,int y){
            this.x = x;
            this.y = y;
        }
       public int compareTo(pair2 o){
          
               return o.y - this.y;
           
       }
    }
    
    public static boolean possible(int []nums,int mid,pair []arr){
        int n = nums.length;
        int []prefix = new int[n];
        PriorityQueue<pair2>pq = new PriorityQueue<>();
        int j = 0;
        int ans = 0;
        for(int i = 0;i<nums.length;i++){
           prefix[i] = ( i==0 )? prefix[i] : prefix[i]+prefix[i-1];
           while(j<arr.length && arr[j].x <= i){
               pq.add(new pair2(arr[j].x,arr[j].y));
               j++;
           } 
           int req = nums[i] - (i == 0 ? 0 : prefix[i]);
           if(req>0){
               // System.out.println(""before""+"" ""+prefix[i]);
               int temp = 0;
               while(req > 0 && pq.size()>0){
                   pair2 p = pq.poll();
                   if(p.y>=i){
                        prefix[i]+=1;
                   if(p.y + 1 < n){
                       prefix[p.y + 1]-=1;
                   }
                   temp++;
                   req--;
                   }
               }
               // System.out.println(""After""+"" ""+prefix[i]);
               // System.out.println(i+"" ""+req+"" ""+temp);
               if(req>0) return false;
               ans += temp;
           }
            else{
                /// nothing to do
            }
        }
        
        return ans<=mid;
    }
    public int maxRemoval(int[] nums, int[][] queries) {
        pair []arr = new pair[queries.length];
        for(int i = 0;i<queries.length;i++){
            arr[i] = new pair(queries[i][0],queries[i][1]);
        }
        Arrays.sort(arr);
        int low = 0;
        int high = queries.length;
        int ans = -1;
        // for(int i = 0;i<arr.length;i++){
        //     System.out.println(arr[i].x+"" ""+arr[i].y);
        // }
        while(low<=high){
            int mid = low + (high-low)/2;
            if(possible(nums,mid,arr)){
                // System.out.
                ans = mid;
                high = mid - 1;
            }
            else{
                low = mid + 1;
            }
        }
        
      if(ans == -1){
          return ans;
      }   
      else{
          return queries.length - ans;
      }
    }
}",1460915543
Frank Rodriguez,whynot4,775,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        var cost = new long[26][26];
        for (int i=0; i<26; i++) {
            Arrays.fill(cost[i], Long.MAX_VALUE);
            cost[i][i] = 0;
        }
        for (int i=0; i<26; i++) {
            cost[i][(i+1)%26] = nextCost[i];
        }
        for (int i=0; i<26; i++) {
            cost[i][(i+25)%26] = previousCost[i];
        }
        floydWarshall(cost);
        long ans = 0;
        for (int i=0; i<s.length(); i++) {
            int a = s.charAt(i) - 'a';
            int b = t.charAt(i) - 'a';
            ans += cost[a][b];
        }
        return ans;
    }

    public static void floydWarshall(long[][] g) {
        int n = g.length;
        for (int k=0; k<n; k++) {
            for (int i=0; i<n; i++) {
                if (g[i][k] == Long.MAX_VALUE) {
                    continue;
                }
                for (int j=0; j<n; j++) {
                    if (g[k][j] == Long.MAX_VALUE) {
                        continue;
                    }
                    g[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);
                }
            }
        }
    }
}",1460816941
Frank Rodriguez,whynot4,775,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean ans = false;
        for (int i=10; i>0; i--) {
            if (n < i) {
                return ans;
            }
            n -= i;
            ans ^= true;
        }
        return true;
    }
}",1460805075
Frank Rodriguez,whynot4,775,3647,java,"class Solution {
    /*
        nums = [0,3]
        queries = [[0,1],[0,0],[0,1],[0,1],[0,0]]
        expected: 2

        nums = [1, 2]
        queries = [[1,1],[0,0],[1,1],[1,1],[0,1],[0,0]]
        expected: 4

        nums = [0, 1, 2]
        queries = [[1,2],[1,2],[0,0],[1,1],[1,1],[0,1],[2,2],[2,2]]
        expected: 6

        nums = [0,2,3]
        queries = [[0,2],[2,2],[0,1],[1,1],[0,1]]
        expected = -1
    */
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (a, b) -> {
            if (a[0] == b[0]) {
                return -Integer.compare(a[1], b[1]);
            }
            return Integer.compare(a[0], b[0]);
        });
        //System.out.println(Arrays.deepToString(queries));

        var tree = new SegmentTreeSumWithRangeUpdate(nums);
        var active = new PriorityQueue<Range>((a, b) -> { // the longest active range is first
            if (a.b == b.b) {
                return Integer.compare(a.a, b.a);
            }
            return -Integer.compare(a.b, b.b);
        });
        int inx = 0; // cur range
        int ct = 0;
        
        for (int i=0; i<nums.length; i++) {
            // while (!active.isEmpty() && delta.peek() <= i) {
            //     d--;
            //     delta.poll();
            // }
            //System.out.println(""at i = "" + i + "", d = "" + d);
            
            if (tree.query(i) <= 0) { // already zerod out
                continue;
            }
            
            while (inx < queries.length) {
                if (queries[inx][0] > i) {
                    break;
                }
                if (queries[inx][1] < i) { // too short, keep looking
                    inx++;
                    continue;
                }
                active.offer(new Range(queries[inx][0], queries[inx][1]));
                inx++;
            }

            int need = tree.query(i);
            if (need > active.size()) { // impossible to resolve
                return -1;
            }

            while (need > 0 && active.size() > 0) {
                var r = active.poll();
                if (r.b < i || i < r.a) {
                    continue;
                }
                tree.updateRange(r.a, r.b, -1);
                ct++;
                need--;
            }
            if (need > 0) {
                return -1;
            }
        }
         return queries.length - ct;
    }

    record Range(int a, int b) {};

    /*
    * Example of a Sum segment tree with the following features:
    *      > Range Update: Increment all elements [L, R] by X
                > Using lazy propagation
    *      > Single Point Query: retrieve the value at index i
    */
    class SegmentTreeSumWithRangeUpdate {
        int[] data;
        int[] tree; // sum
        int[] lazy; // lazy propagation. represents the per-child-node increment
    
        public SegmentTreeSumWithRangeUpdate(int[] leafs) {
            data = leafs;
            tree = new int[data.length * 4];
            lazy = new int[tree.length];
            build(0, 0, data.length-1);
        }
    
        public void merge(int inx) {
            tree[inx] = tree[2*inx+1] + tree[2*inx+2];
        }
    
        public void build(int inx, int L, int R) {
            if (L == R) {
                tree[inx] = data[L];
                return;
            }
            int mid = (L + R) / 2;
            build(2*inx + 1, L, mid);
            build(2*inx + 2, mid+1, R);
            merge(inx);
        }
    
        // lazy propagation helper
        // tree[i] is always updated to the correct value. if lazy[i] is != 0 it means there
        // is work to push down into children
        public void push(int inx, int L, int R) { 
            if (L == R) { // no leaf nodes can push down
                return;
            }
            int mid = (L+R) / 2;
            tree[2*inx+1] += lazy[inx] * (mid - L + 1);
            lazy[2*inx+1] += lazy[inx];
    
            tree[2*inx+2] += lazy[inx] * (R - mid);
            lazy[2*inx+2] += lazy[inx];
            lazy[inx] = 0;
        }
    
        public void updateRange(int targetL, int targetR, int val) {
            updateRange(0, 0, data.length-1, targetL, targetR, val);
        }
    
        public void updateRange(int inx, int L, int R, int targetL, int targetR, int val) {
            if (R < targetL || targetR < L) { // no overlap
                return;
            }
    
            if (targetL <= L && R <= targetR) { // cur node is entirely enclosed by target range
                tree[inx] += 1L * val * (R-L+1);
                lazy[inx] += val;
                return;
            }
    
            push(inx, L, R);
    
            int mid = (L+R)/2;
            updateRange(2*inx+1, L, mid, targetL, targetR, val);
            updateRange(2*inx+2, mid+1, R, targetL, targetR, val);
            merge(inx);
        }
    
        public int query(int targetInx) {
            return query(0, 0, data.length-1, targetInx);
        }
    
        public int query(int inx, int L, int R, int targetInx) {
            if (targetInx < L || R < targetInx) {
                return 0; // DEFAULT SAFE VALUE
            }
            
            if (L == R) { // found leaf node
                return tree[inx];
            }
    
            push(inx, L, R);
            int mid = (L + R) / 2;
            if (targetInx <= mid) {
                return query(2*inx+1, L, mid, targetInx);
            } else {
                return query(2*inx+2, mid+1, R, targetInx);
            }
        }    
    }
}",1460911394
Man0_S1n9h,_Manohar_Singh_,776,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nxt, int[] pvr)
    {
        long ansTotal = 0;

        for (int i = 0; i < s.length(); ++i) {
            int x = s.charAt(i) - 'a';
            int y = t.charAt(i) - 'a';

            if (x != y)
            {
                ansTotal += Math.min(
                    Help1(x, y, nxt),
                    Help2(x, y, pvr)
                );
            }
        }

        return ansTotal;
    }

    private long Help1(int i, int z, int[] nxt) 
    {
        int x = (z - i + 26) % 26;
        long res = 0;
        for (int j = 0; j < x; ++j) {
            res += nxt[(i + j) % 26];
        }
        return res;
    }

    private long Help2(int s, int t, int[] pvr) 
    {
        int stps = (s - t + 26) % 26;
        long cost = 0;
        for (int j = 0; j < stps; ++j) {
            cost += pvr[(s - j + 26) % 26];
        }
        return cost;
    }
}",1460856035
Man0_S1n9h,_Manohar_Singh_,776,3625,java,"class Solution {
    public boolean canAliceWin(int temp) {
     
        if(temp < 10) return false;
        int x =0;
        int c = 10;
        int t = 1;
        while( x +c <=temp)
        {
            x+=c;
            c--;
            t++;
        }
        return t%2==0;
    }
}",1460847044
Man0_S1n9h,_Manohar_Singh_,776,3647,java,"class Solution {
    public int maxRemoval(int[] arr, int[][] queries) {
        int n = arr.length;
        int[] temp = Helper1(n, queries);
        int[] temp2 = Helper2(arr, temp);
        if (temp2 == null) return -1; 

        SegmentTree st = new SegmentTree(temp2);
        return Helper3(queries, temp2, st);
    }

    private int[] Helper1(int n, int[][] qq)
    {
        int[] tmp = new int[n + 1];
        for (int[] q : qq) {
            int l = q[0];
            int r = q[1];
            tmp[l]++;
            if (r + 1 < n) tmp[r + 1]--;
        }
        for (int i = 1; i < n; i++) {
            tmp[i] += tmp[i - 1];
        }
        return tmp;
    }

    private int[] Helper2(int[] nums, int[] tmp) {
        int n = nums.length;
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = tmp[i] - nums[i];
            if (arr[i] < 0) return null;
        }
        return arr;
    }

    private int Helper3(int[][] qq, int[] allowed, SegmentTree t) {
        Arrays.sort(qq, (a, b) -> {
            int aa = a[1] - a[0] + 1;
            int bb = b[1] - b[0] + 1;
            return aa != bb ? aa - bb : a[0] - b[0];
        });

        int rem = 0;
        for (int[] q : qq) {
            int l = q[0], r = q[1];
            if (t.queryMin(l, r) >= 1) 
            {
                t.HelperUtil(l, r);
                rem++;
            }
        }
        return rem;
    }

    static class SegmentTree {
        int[] tree, lazy;
        int n;

        public SegmentTree(int[] allowed) {
            n = allowed.length;
            tree = new int[4 * n];
            lazy = new int[4 * n];
            build(allowed, 1, 0, n - 1);
        }

        private void build(int[] allowed, int node, int l, int r) {
            if (l == r) {
                tree[node] = allowed[l];
            } else {
                int mid = l + (r - l) / 2;
                build(allowed, 2 * node, l, mid);
                build(allowed, 2 * node + 1, mid + 1, r);
                tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
            }
        }

        private void pushDown(int node, int l, int r) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node];
                if (l != r) {
                    lazy[2 * node] += lazy[node];
                    lazy[2 * node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        public int queryMin(int ql, int qr)
        {
            return queryMin(1, 0, n - 1, ql, qr);
        }

        private int queryMin(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return Integer.MAX_VALUE;
            if (ql <= l && r <= qr) return tree[node];
            int mid = l + (r - l) / 2;
            return Math.min(queryMin(2 * node, l, mid, ql, qr),
                            queryMin(2 * node + 1, mid + 1, r, ql, qr));
        }

        public void HelperUtil(int ql, int qr) {
            HelperUtil(1, 0, n - 1, ql, qr);
        }

        private void HelperUtil(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lazy[node] -= 1;
                pushDown(node, l, r);
                return;
            }
            int mid = l + (r - l) / 2;
            HelperUtil(2 * node, l, mid, ql, qr);
            HelperUtil(2 * node + 1, mid + 1, r, ql, qr);
            tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
        }
    }
}",1460917065
Ayush Kamal,ayushkamal346,777,3591,cpp,"#define ll long long
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
    ll ans=0;
  for(int i=0; i<s.size();i++){
     if(s[i]!=t[i]){
     ll c1=0;
         ll c2=0;

    
         ll ind1=s[i]-'a';
         ll ind2=s[i]-'a';
         ll indreq=t[i]-'a';

         while(ind1!=indreq){

             c1+=nc[ind1];
             ind1++;
             ind1%=26;

             
             
         }

        while(ind2!=indreq){

             c2+=pc[ind2];
             ind2--;
             ind2=(ind2+26)%26;
             
         }
         // c1-=nc[indreq];
         // c2-=pc[ind]
         ans+=min(c1,c2);
    
         // cout<<c1<<"" ""<<c2<<endl;
     }
    
    }

        return ans;
        
    }
};",1460837295
Ayush Kamal,ayushkamal346,777,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        int ct=10;

        int k=0;

        while(n>=0 ){

          if(n-ct>=0 ){

              n-=ct;
          }
            else{

                break;
            }
            ct--;
            k++;
        }

        if(k%2==0)return false;
        return true;
        
    }
};",1460797726
Ayush Kamal,ayushkamal346,777,3647,cpp,"class Solution {
public:
 // Max size of array
int tree[300002]; // Segment tree
int lazy[300002]; // Lazy array to propagate updates

// Function to build the tree
void build(int node, int start, int end)
{
    if(start == end)
    {
        // Leaf node will have a single element
        tree[node] = 0;
    }
    else
    {
        int mid = (start + end) / 2;
        // Recur for the 2 children
        build(2*node, start, mid);
        build(2*node+1, mid+1, end);
        // Internal node will have the minimum of both of its children
        tree[node] = min(tree[2*node], tree[2*node+1]);
    }
}

// Function to update a node
void update(int node, int start, int end, int l, int r, int val)
{
    if(lazy[node] != 0)
    { 
        // This node needs to be updated
        tree[node] += lazy[node]; // Update it
        if(start != end)
        {
            lazy[node*2] += lazy[node]; // Mark child as lazy
            lazy[node*2+1] += lazy[node]; // Mark child as lazy
        }
        lazy[node] = 0; // Reset it
    }
    if(start > end or start > r or end < l) return; // Current segment is not within range [l, r]
    if(start >= l and end <= r)
    {
        // Segment is fully within range
        tree[node] += val;
        if(start != end)
        {
            // Not leaf node
            lazy[node*2] += val;
            lazy[node*2+1] += val;
        }
        return;
    }
    int mid = (start + end) / 2;
    update(node*2, start, mid, l, r, val); // Updating left child
    update(node*2 + 1, mid + 1, end, l, r, val); // Updating right child
    tree[node] = min(tree[node*2], tree[node*2+1]); // Updating root with min value 
}

// Function to query the tree
int query(int node, int start, int end, int l, int r)
{
    if(start > end or start > r or end < l) return 1e9; // Out of range
    if(lazy[node] != 0)
    {
        // This node needs to be updated
        tree[node] += lazy[node]; // Update it
        if(start != end)
        {
            lazy[node*2] += lazy[node]; // Mark child as lazy
            lazy[node*2+1] += lazy[node]; // Mark child as lazy
        }
        lazy[node] = 0; // Reset it
    }
    if(start >= l and end <= r) // Current segment is totally within range [l, r]
        return tree[node];
    int mid = (start + end) / 2;
    int p1 = query(node*2, start, mid, l, r); // Query left child
    int p2 = query(node*2 + 1, mid + 1, end, l, r); // Query right child
    return min(p1, p2);
}

    int maxRemoval(vector<int>& a, vector<vector<int>>& q) {

    


        vector<int> freq(a.size()+1,0);
        for(auto it: q){



            freq[it[0]]++;
            freq[it[1]+1]--;
        }

        for(int i=1; i<a.size();i++){

            freq[i]+=freq[i-1];

            if(freq[i]<a[i])return -1;
        }

          for(int i=0; i<a.size();i++){

            if(freq[i]<a[i])return -1;
        }

        int n=a.size();
        
      build(1, 0, a.size()-1);

      for(int i=0;i<a.size();i++){
           update(1, 0, n-1, i, i, freq[i]-a[i]);

          // cout<<freq[i]-a[i]<<"" ""<< freq[i]<<"" ""<<a[i]<<endl;;
      }
        // cout<<endl;
   int ans=0;
        multiset<pair<int,pair<int,int>>> m1;
        for(int i=0; i<q.size();i++){
             int l=q[i][0];
        int r=q[i][1];
        m1.insert({r-l,{l,r}});
            
        }
    for(auto it=m1.begin();it!=m1.end();it++){

        int l=it->second.first;
        int r=it->second.second;

           int ak= query(1, 0, n-1, l, r);
          
         if(ak>0){
             
           ans++;
        update(1, 0, n-1, l, r, -1);
         }
      }

      
        return ans;
        
    }
};",1460912574
voinkoder,voinkoder,778,3591,cpp,"#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC target(""sse4,popcnt,abm,mmx,tune=native"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ld, ld> pld;

const int INF = 1e9;
const ll LLINF = 1e18;
const int MOD = 1e9 + 7;

template<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;

inline ll ceil0(ll a, ll b) {
    return a / b + ((a ^ b) > 0 && a % b);
}

template<class mod>
struct Modular {

    using T = typename mod::type;
    using C = typename mod::cast;

    template<class U>
    static T fpow(T a, U b){
        T ret = 1;
        while(b){
            if(b%2 == 1) ret = (C)ret*a%mod::mod;
            a = (C)a*a%mod::mod;
            b /= 2;
        }
        return ret;
    }

    T val;

    Modular(){
        val = 0;
    }

    template<class U>
    Modular(const U &x){
        val = x%mod::mod;
        if(val < 0) val += mod::mod;
    }

    const T Mod() const { return mod::mod; }

    const T &operator()() const { return val; }

    template<class U>
    explicit operator U() const { return static_cast<U>(val); } 

    Modular operator-(){ return Modular<mod>(-val); }

    Modular &operator+=(const Modular &x){
        val = (val + x.val)%mod::mod;
        return *this;
    }

    Modular &operator-=(const Modular &x){
        val = (val - x.val + mod::mod)%mod::mod;
        return *this;
    }

    Modular &operator*=(const Modular &x){
        val = (C)val*x.val%mod::mod;
        return *this;
    }

    Modular &operator/=(const Modular &x){
        val = (C)val*fpow(x.val, mod::mod - 2)%mod::mod;
        return *this;
    }

    Modular &operator%=(const Modular &x){
        val = val%x.val;
        return *this;
    }

    template<class U>
    Modular &operator^=(const U &x){
        assert((""be careful when raising to a modded power"", typeid(x) != typeid(*this)));
        val = fpow(val, x);
        return *this;
    }

    Modular &operator++(){ return *this += 1; }

    Modular &operator--(){ return *this -= 1; }

    Modular operator++(int){
        Modular ret = *this;
        ++*this;
        return ret;
    }

    Modular operator--(int){
        Modular ret = *this;
        --*this;
        return ret;
    }

    friend Modular operator+(const Modular &a, const Modular &b){ return Modular(a.val) += b; }

    friend Modular operator-(const Modular &a, const Modular &b){ return Modular(a.val) -= b; }

    friend Modular operator*(const Modular &a, const Modular &b){ return Modular(a.val) *= b; }

    friend Modular operator/(const Modular &a, const Modular &b){ return Modular(a.val) /= b; }

    friend Modular operator%(const Modular &a, const Modular &b){ return Modular(a.val) %= b; }

    template<class U>
    friend Modular operator^(const Modular &a, const U &b){ return Modular(a.val) ^= b; }

    bool hasSqrt(){
        return val == 0 || fpow(val, (mod::mod - 1)/2) == 1;
    }

    Modular sqrt(){
        if(val == 0) return 0;
        if(val == 1) return 1;
        assert(hasSqrt());
        Modular r = 1, c = 1, a = 1, b = 1, aa, bb;
        while(((r*r - val) ^ ((mod::mod - 1)/2)) == 1) r++;
        Modular mult = r*r - val;
        T x = (mod::mod + 1)/2;
        while(x){
            if(x%2 == 1){
                aa = c*b*mult + a*r;
                bb = c*a + r*b;
                a = aa, b = bb;
            }
            aa = c*c*mult + r*r;
            bb = 2*c*r;
            r = aa, c = bb;
            x /= 2;
        }
        if(a >= (mod::mod + 1)/2) a *= -1;
        return a;
    }

    friend bool operator<(const Modular &a, const Modular &b){ return a.val < b.val; }

    friend bool operator<=(const Modular &a, const Modular &b){ return a.val <= b.val; }

    friend bool operator>(const Modular &a, const Modular &b){ return a.val > b.val; }

    friend bool operator>=(const Modular &a, const Modular &b){ return a.val >= b.val; }

    friend bool operator==(const Modular &a, const Modular &b){ return a.val == b.val; }

    friend bool operator!=(const Modular &a, const Modular &b){ return a.val != b.val; }

    friend ostream &operator<<(ostream &out, Modular x){ return out << x.val; }

    friend istream &operator>>(istream &in, Modular &x){ 
        in >> x.val;
        x.val = x.val%mod::mod;
        if(x.val < 0) x.val += mod::mod;
        return in;
    }

    string to_string(const Modular&x) { return to_string(x.val); }
};

struct Mod { 
    using type = int;
    using cast = long long;
    const static type mod = MOD;
};

using mint=Modular<Mod>;


class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();

        for (int i = 0; i < n; ++i) {
            int startChar = s[i] - 'a';
            int endChar = t[i] - 'a';

            int forwardSteps = (endChar - startChar + 26) % 26; 
            int backwardSteps = (startChar - endChar + 26) % 26; 

            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(startChar + j) % 26];
            }

            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(startChar - j + 26) % 26];
            }

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460812513
voinkoder,voinkoder,778,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int curr = 10;
    bool flag = false;

    while (n > 0) {
        if (n < curr)
            break;
        n -= curr;
        curr--;
        flag = !flag;
    }

    return flag;
    }
};",1460808397
voinkoder,voinkoder,778,3647,cpp,"#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC target(""sse4,popcnt,abm,mmx,tune=native"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;

#define pb push_back
#define ff first
#define ss second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef pair<ld, ld> pld;

const int INF = 1e9;
const ll LLINF = 1e18;
const int MOD = 1e9 + 7;

template<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;

inline ll ceil0(ll a, ll b) {
    return a / b + ((a ^ b) > 0 && a % b);
}

template<class mod>
struct Modular {

    using T = typename mod::type;
    using C = typename mod::cast;

    template<class U>
    static T fpow(T a, U b){
        T ret = 1;
        while(b){
            if(b%2 == 1) ret = (C)ret*a%mod::mod;
            a = (C)a*a%mod::mod;
            b /= 2;
        }
        return ret;
    }

    T val;

    Modular(){
        val = 0;
    }

    template<class U>
    Modular(const U &x){
        val = x%mod::mod;
        if(val < 0) val += mod::mod;
    }

    const T Mod() const { return mod::mod; }

    const T &operator()() const { return val; }

    template<class U>
    explicit operator U() const { return static_cast<U>(val); } 

    Modular operator-(){ return Modular<mod>(-val); }

    Modular &operator+=(const Modular &x){
        val = (val + x.val)%mod::mod;
        return *this;
    }

    Modular &operator-=(const Modular &x){
        val = (val - x.val + mod::mod)%mod::mod;
        return *this;
    }

    Modular &operator*=(const Modular &x){
        val = (C)val*x.val%mod::mod;
        return *this;
    }

    Modular &operator/=(const Modular &x){
        val = (C)val*fpow(x.val, mod::mod - 2)%mod::mod;
        return *this;
    }

    Modular &operator%=(const Modular &x){
        val = val%x.val;
        return *this;
    }

    template<class U>
    Modular &operator^=(const U &x){
        assert((""be careful when raising to a modded power"", typeid(x) != typeid(*this)));
        val = fpow(val, x);
        return *this;
    }

    Modular &operator++(){ return *this += 1; }

    Modular &operator--(){ return *this -= 1; }

    Modular operator++(int){
        Modular ret = *this;
        ++*this;
        return ret;
    }

    Modular operator--(int){
        Modular ret = *this;
        --*this;
        return ret;
    }

    friend Modular operator+(const Modular &a, const Modular &b){ return Modular(a.val) += b; }

    friend Modular operator-(const Modular &a, const Modular &b){ return Modular(a.val) -= b; }

    friend Modular operator*(const Modular &a, const Modular &b){ return Modular(a.val) *= b; }

    friend Modular operator/(const Modular &a, const Modular &b){ return Modular(a.val) /= b; }

    friend Modular operator%(const Modular &a, const Modular &b){ return Modular(a.val) %= b; }

    template<class U>
    friend Modular operator^(const Modular &a, const U &b){ return Modular(a.val) ^= b; }

    bool hasSqrt(){
        return val == 0 || fpow(val, (mod::mod - 1)/2) == 1;
    }

    Modular sqrt(){
        if(val == 0) return 0;
        if(val == 1) return 1;
        assert(hasSqrt());
        Modular r = 1, c = 1, a = 1, b = 1, aa, bb;
        while(((r*r - val) ^ ((mod::mod - 1)/2)) == 1) r++;
        Modular mult = r*r - val;
        T x = (mod::mod + 1)/2;
        while(x){
            if(x%2 == 1){
                aa = c*b*mult + a*r;
                bb = c*a + r*b;
                a = aa, b = bb;
            }
            aa = c*c*mult + r*r;
            bb = 2*c*r;
            r = aa, c = bb;
            x /= 2;
        }
        if(a >= (mod::mod + 1)/2) a *= -1;
        return a;
    }

    friend bool operator<(const Modular &a, const Modular &b){ return a.val < b.val; }

    friend bool operator<=(const Modular &a, const Modular &b){ return a.val <= b.val; }

    friend bool operator>(const Modular &a, const Modular &b){ return a.val > b.val; }

    friend bool operator>=(const Modular &a, const Modular &b){ return a.val >= b.val; }

    friend bool operator==(const Modular &a, const Modular &b){ return a.val == b.val; }

    friend bool operator!=(const Modular &a, const Modular &b){ return a.val != b.val; }

    friend ostream &operator<<(ostream &out, Modular x){ return out << x.val; }

    friend istream &operator>>(istream &in, Modular &x){ 
        in >> x.val;
        x.val = x.val%mod::mod;
        if(x.val < 0) x.val += mod::mod;
        return in;
    }

    string to_string(const Modular&x) { return to_string(x.val); }
};

struct Mod { 
    using type = int;
    using cast = long long;
    const static type mod = MOD;
};

using mint=Modular<Mod>;


#include <vector>
#include <algorithm>
#include <iostream>

class SegmentTree {
private:
    int size;
    std::vector<int> tree;
    std::vector<int> lazy;

    void pushDown(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += lazy[node];
            if (start != end) { // Not a leaf node
                lazy[node * 2] += lazy[node];
                lazy[node * 2 + 1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void buildTree(const std::vector<int>& allowed, int node, int start, int end) {
        pushDown(node, start, end);
        if (start == end) {
            tree[node] = allowed[start];
        } else {
            int mid = start + (end - start) / 2;
            buildTree(allowed, node * 2, start, mid);
            buildTree(allowed, node * 2 + 1, mid + 1, end);
            tree[node] = std::min(tree[node * 2], tree[node * 2 + 1]);
        }
    }

    int queryMin(int node, int start, int end, int left, int right) {
        pushDown(node, start, end);
        if (right < start || left > end) return INT_MAX;
        if (left <= start && end <= right) return tree[node];
        int mid = start + (end - start) / 2;
        return std::min(
            queryMin(node * 2, start, mid, left, right),
            queryMin(node * 2 + 1, mid + 1, end, left, right)
        );
    }

    void decrementRange(int node, int start, int end, int left, int right) {
        pushDown(node, start, end);
        if (right < start || left > end) return;
        if (left <= start && end <= right) {
            lazy[node] -= 1;
            pushDown(node, start, end);
            return;
        }
        int mid = start + (end - start) / 2;
        decrementRange(node * 2, start, mid, left, right);
        decrementRange(node * 2 + 1, mid + 1, end, left, right);
        tree[node] = std::min(tree[node * 2], tree[node * 2 + 1]);
    }

public:
    SegmentTree(int n) : size(n), tree(4 * n, 0), lazy(4 * n, 0) {}

    void build(const std::vector<int>& allowed) {
        buildTree(allowed, 1, 0, size - 1);
    }

    int queryMin(int left, int right) {
        return queryMin(1, 0, size - 1, left, right);
    }

    void decrementRange(int left, int right) {
        decrementRange(1, 0, size - 1, left, right);
    }
};

void customMergeSort(std::vector<std::vector<int>>& queries, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    customMergeSort(queries, left, mid);
    customMergeSort(queries, mid + 1, right);

    std::vector<std::vector<int>> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    while (i <= mid && j <= right) {
        int lenA = queries[i][1] - queries[i][0] + 1;
        int lenB = queries[j][1] - queries[j][0] + 1;
        if (lenA < lenB || (lenA == lenB && queries[i][0] <= queries[j][0])) {
            temp[k++] = queries[i++];
        } else {
            temp[k++] = queries[j++];
        }
    }
    while (i <= mid) temp[k++] = queries[i++];
    while (j <= right) temp[k++] = queries[j++];
    for (int t = 0; t < temp.size(); t++) {
        queries[left + t] = temp[t];
    }
}

class Solution {
public:
    int maxRemoval(std::vector<int>& arr, std::vector<std::vector<int>>& queries) {
        int n = arr.size();
        std::vector<int> cover(n + 1, 0);
        for (auto& q : queries) {
            int left = q[0];
            int right = q[1];
            cover[left] += 1;
            if (right + 1 < n) {
                cover[right + 1] -= 1;
            }
        }

        for (int i = 1; i < n; i++) {
            cover[i] += cover[i - 1];
        }
        cover.resize(n);

        std::vector<int> allowed(n);
        for (int i = 0; i < n; i++) {
            allowed[i] = cover[i] - arr[i];
            if (allowed[i] < 0) {
                return -1;
            }
        }

        customMergeSort(queries, 0, queries.size() - 1);

        SegmentTree segmentTree(n);
        segmentTree.build(allowed);

        int removedCount = 0;
        for (auto& q : queries) {
            int left = q[0];
            int right = q[1];
            if (segmentTree.queryMin(left, right) >= 1) {
                segmentTree.decrementRange(left, right);
                removedCount++;
            }
        }

        return removedCount;
    }
};

",1460912736
ygor_ribeiro7,ygor_ribeiro7,779,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        vector<long long> frente, tras;
        frente.push_back(0);
        tras.push_back(0);
        for(int i=0;i<26;i++){
            frente.push_back((long long) frente.back() + nextCost[i]);
            tras.push_back((long long) tras.back() + previousCost[i]);
        }
        long long ans = 0;
        for(int i = 0; i < s.size(); i++){
            int x = s[i] - 'a' + 1, y = t[i] - 'a' + 1;
            long long f = frente[y - 1];
            if(y > x){
                f -= frente[x - 1];
            }else{
                f += frente[26] - frente[x - 1];
            }
            
            long long t = tras[26] - tras[y];
            if(x < y){
                t += tras[x];
            }else{
                t -= tras[26] - tras[x];
            }
                
            ans += min(f, t);
        }
        
        return ans;
    }
};",1460825220
ygor_ribeiro7,ygor_ribeiro7,779,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int ans = 10;
        while(ans > 0){
            if(n >= ans) n -= ans;
            else{
                if(ans & 1) return true;
                else return false;
            }
            ans--;
        }
        return false;
    }
};",1460796927
ygor_ribeiro7,ygor_ribeiro7,779,3647,cpp,"class Solution {
public:
    const static int MAX = 1e5 + 10;
    int tree[MAX * 4], lazy[MAX * 4];
    vector<int> cntGlobal;

    void build(int idx, int esq, int dir){
        if(esq > dir) return;

        if(esq == dir){
            tree[idx] = cntGlobal[esq];
            lazy[idx] = 0;
            return;
        }

        int meio = (dir + esq)/2;
        build(idx * 2, esq, meio);
        build(idx * 2 + 1, meio + 1, dir);
        lazy[idx] = lazy[idx * 2] = lazy[idx * 2 + 1] = 0;
        tree[idx] = max(tree[idx * 2], tree[idx * 2 + 1]);
    }

    void update(int idx, int esq, int dir, int inicio, int fim){
        if(lazy[idx] != 0){
            tree[idx] += lazy[idx];
            if(esq != dir){
                lazy[idx * 2] += lazy[idx];
                lazy[idx * 2 + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }

        if(esq > dir || esq > fim || dir < inicio) return;

        if(inicio <= esq && dir <= fim){
            tree[idx] += 1;
            if(esq != dir){
                lazy[idx * 2] += 1;
                lazy[idx * 2 + 1] += 1;
            }
            return;
        }

        int meio = (esq + dir) / 2;
        update(idx * 2, esq, meio, inicio, fim);
        update(idx * 2 + 1, meio + 1, dir, inicio, fim);
        tree[idx] = max(tree[idx * 2], tree[idx * 2 + 1]);
    }

    int query(int idx, int esq, int dir, int inicio, int fim){
        if(lazy[idx] != 0){
            tree[idx] += lazy[idx];
            if(esq != dir){
                lazy[idx * 2] += lazy[idx];
                lazy[idx * 2 + 1] += lazy[idx];
            }
            lazy[idx] = 0;
        }

        if(esq > dir || esq > fim || dir < inicio) return -1e8;

        if(inicio <= esq && dir <= fim){
            return tree[idx];
        }

        int meio = (esq + dir) / 2;
        int x = query(idx * 2, esq, meio, inicio, fim);
        int y = query(idx * 2 + 1, meio + 1, dir, inicio, fim);
        return max(x, y);
    }

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        const int n = nums.size();
        vector<int> cnt(n+1, 0);
        for(vector<int> q : queries){
            int x = q[0] + 1, y = q[1] + 1;
            cnt[x]++;
            if(y + 1 <= n) cnt[y + 1]--;
        }
        
        for(int i=1;i<=n;i++) cnt[i] += cnt[i-1];
        
        for(int i=1;i<=n;i++){
            cnt[i] = nums[i - 1] - cnt[i];
            if(cnt[i] > 0) return -1;
        }
        
        cntGlobal = cnt;
                
        build(1, 1, n);
        
        sort(queries.begin(), queries.end(), [](const vector<int>& q1, const vector<int>& q2){
            if(q1[1] != q2[1]) return q1[1] < q2[1];
            return q1[0] > q2[0];
        });
        
        int ans = 0;
        
        for(vector<int> q : queries){
            int x = q[0] + 1, y = q[1] + 1;
            int queryAux = query(1, 1, n, x, y);
            if(queryAux < 0){
                ans++;
                update(1, 1, n, x, y);
            }
        }
        
        return ans;
        
    }
};",1460913727
Mohammed Jalaluddin Yazdani,user7563UR,781,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // To store the total shift cost

        for (int i = 0; i < s.length(); i++) {
            char startChar = s.charAt(i);
            char targetChar = t.charAt(i);

            int startIndex = startChar - 'a';
            int targetIndex = targetChar - 'a';

            // Calculate the forward and backward distances
            int forwardDistance = (targetIndex - startIndex + 26) % 26;
            int backwardDistance = (startIndex - targetIndex + 26) % 26;

            // Calculate the costs for both directions
            long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(startIndex + j) % 26];
            }

            long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(startIndex - j + 26) % 26];
            }

            // Choose the minimum cost and add it to the total cost
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}",1460883319
Mohammed Jalaluddin Yazdani,user7563UR,781,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10) {
            return false;  // Alice can't make the first move
        }
        
        n -= 10;  // After Alice's first move
        int currentRemoval = 9;  // Bob's next move will remove 9 stones
        
        // Simulate the game
        while (n >= 0) {
            // Bob's turn
            if (n < currentRemoval) {
                return true;  // Bob can't move, Alice wins
            }
            n -= currentRemoval;
            currentRemoval--;
            
            // Alice's turn
            if (n < currentRemoval) {
                return false;  // Alice can't move, Bob wins
            }
            n -= currentRemoval;
            currentRemoval--;
        }
        
        return false;
    }
}",1460871641
Mohammed Jalaluddin Yazdani,user7563UR,781,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        // Step 1: Calculate coverage using a difference array
        int[] coverage = calculateCoverage(nums, queries, n, m);

        // Step 2: Check if nums can be zeroed out with the initial coverage
        if (!isFeasible(nums, coverage, n)) {
            return -1;
        }

        // Step 3: Sort queries by start position
        List<int[]> sortedQueries = sortQueries(queries, m);

        // Step 4: Use max-heap to minimize the number of required queries
        return calculateRemovableQueries(nums, sortedQueries, n, m);
    }

    // Step 1: Calculate total coverage using a difference array
    private int[] calculateCoverage(int[] nums, int[][] queries, int n, int m) {
        int[] coverage = new int[n + 1];
        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l]++;
            if (r + 1 < n) {
                coverage[r + 1]--;
            }
        }

        // Convert difference array to prefix sum
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }
        return coverage;
    }

    // Step 2: Check feasibility of zeroing out nums with current coverage
    private boolean isFeasible(int[] nums, int[] coverage, int n) {
        for (int i = 0; i < n; i++) {
            if (coverage[i] < nums[i]) {
                return false;
            }
        }
        return true;
    }

    // Step 3: Sort queries by start position, and for ties, by descending end position
    private List<int[]> sortQueries(int[][] queries, int m) {
        List<int[]> queriesWithId = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            queriesWithId.add(new int[]{queries[i][0], queries[i][1], i});
        }

        queriesWithId.sort((a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });
        return queriesWithId;
    }

    // Step 4: Calculate the maximum removable queries using a max-heap
    private int calculateRemovableQueries(int[] nums, List<int[]> queries, int n, int m) {
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> b[0] - a[0]); // Max-heap based on end index
        int[] add = new int[n + 1]; // Difference array for additional coverage
        int currentAdd = 0;
        Set<Integer> selected = new HashSet<>();
        int pointer = 0;

        for (int i = 0; i < n; i++) {
            currentAdd += add[i];

            // Add all queries that start at or before i
            while (pointer < m && queries.get(pointer)[0] <= i) {
                int end = queries.get(pointer)[1];
                int id = queries.get(pointer)[2];
                heap.offer(new int[]{end, id});
                pointer++;
            }

            // Remove queries that end before i
            while (!heap.isEmpty() && heap.peek()[0] < i) {
                heap.poll();
            }

            // Current coverage at i
            int currentCoverage = currentAdd;

            // If coverage is less than required, add more
            if (currentCoverage < nums[i]) {
                int need = nums[i] - currentCoverage;
                for (int j = 0; j < need; j++) {
                    if (heap.isEmpty()) {
                        return -1; // Impossible to zero out nums
                    }
                    int[] top = heap.poll();
                    int selectedEnd = top[0];
                    int qid = top[1];
                    selected.add(qid);

                    // Update difference array for additional coverage
                    add[i]++;
                    if (selectedEnd + 1 < n) {
                        add[selectedEnd + 1]--;
                    }
                    currentAdd++;
                }
            }
        }

        // The maximum number of queries that can be removed
        return m - selected.size();
    }
}",1460903262
Prithwiraj Mitra,prithwirajmitra15,783,3591,cpp,"class Solution {
public:
    long long getForwardCost(char currCh, char targetCh, vector<int>& cost)
    {
        long long ans = 0;
        int currIdx = currCh - 'a';
        int targetIdx = targetCh - 'a';
        while (currIdx != targetIdx)
        {
            ans += cost[currIdx];
            currIdx = (currIdx + 1) % 26;
        }

        return ans;
    }

    long long getBackwardCost(char currCh, char targetCh, vector<int>& cost)
    {
        long long ans = 0;
        int currIdx = currCh - 'a';
        int targetIdx = targetCh - 'a';
        while (currIdx != targetIdx)
        {
            ans += cost[currIdx];
            currIdx = (currIdx - 1 + 26) % 26;
        }

        return ans;
    }

    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost)
    {
        long long ans = 0;
        for (int i = 0; i < s.size(); i++)
        {
            long long forwardCost = getForwardCost(s[i], t[i], nextCost);
            long long backwardCost = getBackwardCost(s[i], t[i], previousCost);
            // cout << i << ""\t"" << forwardCost << "" - "" << backwardCost << endl;
            ans += min(forwardCost, backwardCost);
        }

        return ans;
    }
};",1460821937
Prithwiraj Mitra,prithwirajmitra15,783,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n)
    {
        int turn = 0, curr = 10;
        while (curr <= n) {
            n -= curr;
            turn = (turn + 1) % 2;
            curr--;
        }

        return (turn == 1) ? true : false;
    }
};",1460799558
Prithwiraj Mitra,prithwirajmitra15,783,3647,cpp,"class Solution {
public:
    bool checkIfPossible(vector<int> &arr, vector<vector<int>> &queries)
    {
        vector<int> ops(arr.size() + 1, 0);
        for (auto &query : queries)
        {
            ops[query[0]]--;
            ops[query[1] + 1]++;
        }

        for (int i = 1; i < ops.size(); i++)
            ops[i] += ops[i - 1];

        for (int i = 0; i < arr.size(); i++)
            if ((arr[i] + ops[i]) > 0)
                return false;
        return true;
    }

    const static bool cmp(vector<int> &a, vector<int> &b)
    {
        if (a[0] == b[0])
            return a[1] > b[1];
        return a[0] < b[0];
    }

    void show(priority_queue<int> pq)
    {
        while (!pq.empty())
        {
            cout << pq.top() << endl;
            pq.pop();
        }
    }

    int maxRemoval(vector<int> &arr, vector<vector<int>> &queries)
    {
        if (!checkIfPossible(arr, queries))
            return -1;

        sort(queries.begin(), queries.end(), cmp);

        // for (auto &query : queries)
        //     cout << query[0] << "" "" << query[1] << endl;
        // cout << endl << endl;

        int ans = 0;
        priority_queue<int> pq;
        vector<int> ops(arr.size() + 1, 0);
        for (int i = 0, j = 0; i < arr.size(); i++)
        {
            ops[i] += (i - 1 >= 0) ? ops[i - 1] : 0;
            while (j < queries.size() && queries[j][1] < i)
                j++;
            while (j < queries.size() && queries[j][0] <= i && i <= queries[j][1])
            {
                pq.push(queries[j][1]);
                j++;
            }

            // cout << i << "" "" << j << endl;
            // show(pq);
            // cout << endl;
            
            while (!pq.empty() && (arr[i] + ops[i]) > 0)
            {
                if (pq.top() < i)
                    pq.pop();
                
                ans++;
                ops[i]--;
                ops[pq.top() + 1]++;
                pq.pop();
            }

            if ((arr[i] + ops[i]) > 0)
                return -1;
        }
        
        return queries.size() - ans;
    }
};",1460916077
adityakumar007,adityakumar007,784,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long result =0;
        for(int i = 0;i<s.length();i++)
            {
                int x = s[i]-'a',y=t[i]-'a';
                int tx = x,ty =y;
                long sum1 =0,sum2=0;
                 while(tx!=ty){
                     sum1+=nextCost[tx];
                     if(tx == 25){
                         tx=0;
                         continue;
                     }
                     tx++;
                 }
                while(x!=y){
                     sum2+=previousCost[x];
                     if(x == 0){
                         x=25;
                         continue;
                     }
                    x--;
                 }
                result+=min(sum1,sum2);
            }
        return result;
    }
};",1460841999
adityakumar007,adityakumar007,784,3625,cpp,"class Solution {
public:
    bool solve(int n,int prev,int turn){
        if(n<prev-1){
            return 1-turn;
        }
        else if(n == prev-1){
            return turn;
        }
        return solve(n-prev+1,prev-1,1-turn);
    };
    bool canAliceWin(int n) {
       return solve(n,11,1);
    }
};",1460801240
adityakumar007,adityakumar007,784,3647,cpp,"class Solution {
public:
static bool cmp(vector <int> &a,vector <int> &b){
    return a[0]<b[0];
}
    
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
         sort(queries.begin(),queries.end(),cmp);
         priority_queue<int> mu;
         int n = nums.size(),j=0,result=0,pre[n+5],cur=0;
         memset(pre,0,sizeof(pre));
        for(int i=0;i<nums.size();i++){
            cur+=pre[i];
            nums[i]-=cur;
            while(j<queries.size()&&queries[j][0]<=i){
                mu.push(queries[j][1]);
                j++;
            }
            while(nums[i]>0&&!mu.empty()&&mu.top()>=i){
                int ele = mu.top();
                --pre[ele+1];
                ++cur;
                --nums[i];
                result++;
                mu.pop();
            }
            if(nums[i]>0)
                return -1;
        }
        return queries.size()-result;
    }
};",1460905147
Arutsudar A,arutsudar,785,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long ans = 0;
        for (int i=0; i<n; i++) {
            char c1 = s.charAt(i);
            char c2 = t.charAt(i);
            if (c1 == c2)
                continue;
            
            long nextAns = 0, prevAns = 0;
            for (int j=c1-'a'; ; j++) {
                nextAns += nextCost[j%26];
                if ((j+1)%26 == c2-'a')
                    break;
            }
            
            for (int j=c1-'a'; ; j--) {
                prevAns += previousCost[(j+26)%26];
                if ((j+26-1)%26 == c2-'a')
                    break;
            }
// System.out.println(nextAns + "" "" + prevAns);
            ans += Math.min(nextAns, prevAns);
        }
        return ans;
    }
}

/*
class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        int ans = 0;
        int totalNext = 0;
        for (int i=0; i<26; i++) {
            totalNext += nextCost[i];
        }
        int totalPrev = 0;
        for (int i=0; i<26; i++) {
            totalPrev += previousCost[i];
        }
        
        for (int i=0; i<n; i++) {
            char c1 = s.charAt(i);
            char c2 = t.charAt(i);
            int count1 = Math.abs(c2-c1);
            int count2 = 26 - count1;
            int minJ = Math.min(c1-'a' , c2-'a');
            int maxJ = Math.max(c1-'a' , c2-'a');
            
            int nextAns = 0;
            for (int j=minJ+1; j<maxJ; j++) {
                nextAns = nextCost[j];
            }

            int prevAns = 0;
            nextAns = nextCost[c1-'a'];
            
            prevAns = previousCost[c1-'a'] * count2;
            ans += Math.min(nextAns, prevAns);
        }
        return ans;
    }
}
*/",1460847113
Arutsudar A,arutsudar,785,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10)
            return false;
        int prev = 9;
        n -= 10;
        boolean ans = true;
        while (n >= prev && prev > 0) {
            n -= prev;
            ans = !ans;
            prev--;
        }
        return ans;
    }
}",1460803565
Arutsudar A,arutsudar,785,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        Arrays.sort(queries, (a,b) -> (a[0]==b[0]) ? (b[1]-a[1]) : (a[0]-b[0]));
// System.out.println(""queries: "" + Arrays.deepToString(queries));
        int used = 0;
        int j = 0;
        int incsActive = 0;
        PriorityQueue<Integer> availableIncs = new PriorityQueue<>((a,b) -> b-a);
        PriorityQueue<Integer> decrementTheIncs = new PriorityQueue();
        for (int i=0; i<nums.length; i++) {
// System.out.println(""For nums["" + i + ""]="" + nums[i]);
            while (j < queries.length && queries[j][0] == i) {
// System.out.println(""Available : "" + queries[j][0] + "" "" + queries[j][1]);
                availableIncs.add(queries[j][1]);
                j++;
            }
            if (nums[i] == 0)
                continue;
// System.out.println(""decrementTheIncs: "" + Arrays.toString(decrementTheIncs.toArray()));
            while (!decrementTheIncs.isEmpty() && decrementTheIncs.peek() < i) {
                int endingAt = decrementTheIncs.poll();
// System.out.println(""Can't use query ending at: "" + endingAt);
                incsActive--;
            }
            
            nums[i] -= incsActive;
            
            while (nums[i] > 0 && !availableIncs.isEmpty()) {
                if (availableIncs.peek() < i)
                    availableIncs.poll();
                else {
                    int endingAt = availableIncs.poll();
// System.out.println(""Using query endingAt : "" + endingAt);
                    used++;
                    nums[i]--;
                    incsActive++;
                    decrementTheIncs.add(endingAt);
                }
            }
// System.out.println();
            if (nums[i] > 0)
                return -1;
        }
        return queries.length - used;
    }
}",1460905495
deepak_rawat777,deepak_rawat777,786,3591,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    long long shiftDistance(string source, string target, vector<int>& forwardCost, vector<int>& backwardCost) {
        long long totalShiftCost = 0; // Stores the total cost of all transformations
        int stringLength = source.size(); // Length of the strings
        
        for (int index = 0; index < stringLength; ++index) {
            int sourceCharIndex = source[index] - 'a';  // Get alphabet index of the current character in source
            int targetCharIndex = target[index] - 'a';  // Get alphabet index of the current character in target
            
            // Calculate forward shift cost
            int forwardSteps = (targetCharIndex - sourceCharIndex + 26) % 26;
            long long costForForwardShift = 0;
            for (int step = 0; step < forwardSteps; ++step) {
                costForForwardShift += forwardCost[(sourceCharIndex + step) % 26];
            }
            
            // Calculate backward shift cost
            int backwardSteps = (sourceCharIndex - targetCharIndex + 26) % 26;
            long long costForBackwardShift = 0;
            for (int step = 0; step < backwardSteps; ++step) {
                costForBackwardShift += backwardCost[(sourceCharIndex - step + 26) % 26];
            }
            
            // Choose the minimum cost for this transformation
            totalShiftCost += min(costForForwardShift, costForBackwardShift);
        }
        
        return totalShiftCost;
    }
};",1460882353
deepak_rawat777,deepak_rawat777,786,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        turn = 0
        x = 10
        
        while n >= 0:
            turn += 1
            n -= x
            x -= 1
            
        return True if turn % 2 == 0 else False
",1460866470
deepak_rawat777,deepak_rawat777,786,3647,cpp,"class Solution {

public:

    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {

        int n = nums.size();

        int m = queries.size();

        // Step 1: Calculate coverage for each index using difference array

        vector<int> coverage(n + 1, 0);

        for (const auto& q : queries) {

            int l = q[0];

            int r = q[1];

            coverage[l] += 1;

            if (r + 1 < n) {

                coverage[r + 1] -= 1;

            }

        }

        // Convert difference array to prefix sum to get actual coverage

        for (int i = 1; i < n; i++) {

            coverage[i] += coverage[i - 1];

        }

        // Step 2: Compute the allowed decrements for each index

        vector<int> allowed(n, 0);

        for (int i = 0; i < n; i++) {

            allowed[i] = coverage[i] - nums[i];

            if (allowed[i] < 0) {

                return -1; // Not possible to convert nums to a zero array

            }

        }

        // Step 3: Sort queries by range size to maximize removable queries

        vector<pair<int, int>> sorted_queries;

        sorted_queries.reserve(m);

        for (const auto& q : queries) {

            sorted_queries.emplace_back(q[0], q[1]);

        }

        sort(sorted_queries.begin(), sorted_queries.end(), [&](const pair<int, int>& a, const pair<int, int>& b) {

            int len_a = a.second - a.first + 1;

            int len_b = b.second - b.first + 1;

            if (len_a != len_b) {

                return len_a < len_b; // Sort by increasing range size

            }

            return a.first < b.first; // If same size, sort by starting index

        });

        // Step 4: Initialize the segment tree

        SegmentTree st(n);

        st.build(allowed, 1, 0, n - 1);

        // Step 5: Process queries in sorted order

        int removed = 0;

        for (const auto& [l, r] : sorted_queries) {

            // Check if the range [l, r] can be decremented

            int current_min = st.query_min(1, 0, n - 1, l, r);

            if (current_min >= 1) {

                // Safe to remove this query

                st.decrement_range(1, 0, n - 1, l, r);

                removed++;

            }

        }

        return removed;

    }

    // Segment Tree implementation

    struct SegmentTree {

        int n;

        vector<int> tree;

        vector<int> lazy;

        SegmentTree(int size) : n(size) {

            tree.assign(4 * n, 0);

            lazy.assign(4 * n, 0);

        }

        void push_down(int node, int l, int r) {

            if (lazy[node] != 0) {

                tree[node] += lazy[node];

                if (l != r) { // Propagate to child nodes if not a leaf

                    lazy[node * 2] += lazy[node];

                    lazy[node * 2 + 1] += lazy[node];

                }

                lazy[node] = 0;

            }

        }

        void build(const vector<int>& allowed, int node, int l, int r) {

            if (l == r) {

                tree[node] = allowed[l];

            } else {

                int mid = l + (r - l) / 2;

                build(allowed, 2 * node, l, mid);

                build(allowed, 2 * node + 1, mid + 1, r);

                tree[node] = min(tree[2 * node], tree[2 * node + 1]);

            }

        }

        int query_min(int node, int l, int r, int ql, int qr) {

            push_down(node, l, r);

            if (qr < l || ql > r) return INT32_MAX; // Out of range

            if (ql <= l && r <= qr) return tree[node]; // Fully covered

            int mid = l + (r - l) / 2;

            return min(query_min(2 * node, l, mid, ql, qr),

                       query_min(2 * node + 1, mid + 1, r, ql, qr));

        }

        void decrement_range(int node, int l, int r, int ql, int qr) {

            push_down(node, l, r);

            if (qr < l || ql > r) return; // Out of range

            if (ql <= l && r <= qr) {

                lazy[node] -= 1;

                push_down(node, l, r);

                return;

            }

            int mid = l + (r - l) / 2;

            decrement_range(2 * node, l, mid, ql, qr);

            decrement_range(2 * node + 1, mid + 1, r, ql, qr);

            tree[node] = min(tree[2 * node], tree[2 * node + 1]);

        }

    };

};

        
    
",1460912016
Goutam Sharma,theblackhoop,788,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
    int n = s.size(); 
    long long ans = 0; 

    for (int i = 0; i < n; i++) {
        int x = s[i] - 'a'; 
        int y = t[i] - 'a'; 

        if(s[i]!=t[i]){
            long long fd = (y - x + 26) % 26;
            long long fc = 0;
            for (int j = 0; j < fd; j++) {
                fc += nc[(x + j) % 26];
            }
    
            
            long long bd = (x - y + 26) % 26;
            long long bc = 0;
            for (int j = 0; j < bd; j++) {
                bc += pc[(x - j + 26) % 26];
            }
            ans += min(fc, bc);
        }

        
        

       
        
    }

    return ans;
}


};",1460906178
Goutam Sharma,theblackhoop,788,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if(n<10) return false;

        int cnt = 0;
        int cur =10;
        while(n>=cur){
            n-=cur;
            cur-=1;
                cnt++;
        }
        if(cnt%2) return true;
        return false;
    }
};",1460812003
Goutam Sharma,theblackhoop,788,3647,python3,"from collections import defaultdict
from bisect import bisect_left as lower_bound
from bisect import bisect_right as upper_bound


class FenwickTree:
    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | (i + 1)
            if j < size:
                bit[j] += bit[i]

    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1

    def __call__(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def find_kth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1, k


class SortedList:
    block_size = 700

    def __init__(self, iterable=()):
        iterable = sorted(iterable)
        self.micros = [iterable[i:i + self.block_size - 1] for i in range(0, len(iterable), self.block_size - 1)] or [[]]
        self.macro = [i[0] for i in self.micros[1:]]
        self.micro_size = [len(i) for i in self.micros]
        self.fenwick = FenwickTree(self.micro_size)
        self.size = len(iterable)

    def insert(self, x):
        i = lower_bound(self.macro, x)
        j = upper_bound(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]
            self.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])

    def pop(self, k=-1):
        i, j = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)

    def __getitem__(self, k):
        i, j = self._find_kth(k)
        return self.micros[i][j]

    def count(self, x):
        return self.upper_bound(x) - self.lower_bound(x)

    def __contains__(self, x):
        return self.count(x) > 0

    def lower_bound(self, x):
        i = lower_bound(self.macro, x)
        return self.fenwick(i) + lower_bound(self.micros[i], x)

    def upper_bound(self, x):
        i = upper_bound(self.macro, x)
        return self.fenwick(i) + upper_bound(self.micros[i], x)

    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)

    def __len__(self):
        return self.size

    def __iter__(self):
        return (x for micro in self.micros for x in micro)

    def __repr__(self):
        return str(list(self))
        
class Solution:
    def maxRemoval(self, a: List[int], q: List[List[int]]) -> int:
        n = len(a)
        q.sort()
        nq = defaultdict(lambda: [])
        for i in range (len(q)):
            if q[i][0] in nq:
                nq[q[i][0]].append(q[i][1])
            else:
                nq[q[i][0]] = [q[i][1]]

        s = SortedList()
        picked = 0
        ans = 0
        pref = [0]*(n+1)
        flag = 0
        for i in range (n):
            pref[i]+=pref[i-1]
            while len(s) and s[0]<i:
                s.pop(0)
                ans+=1
            for j in nq[i]:
                s.insert(j)
            req = a[i] - pref[i]
            if req<=0:
                continue
            else:
                while req and len(s):
                    cur = s[-1]
                    pref[cur+1]-=1
                    pref[i]+=1
                    req-=1
                    s.pop(-1)
                if req:
                    flag = 1
                    break
                
        if flag:
            return -1
        else:
            return ans + len(s)",1460867882
Naveen Saini,NaveenSaini_CE19B069,789,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        a = ord('a')
        def idx(c):
            return ord(c)-a
        sp = 0
        sn = 0
        previousCost.insert(0,0)
        nextCost.append(0)
        for i in range(0,27):
            nextCost[i],sn = sn,sn+nextCost[i]
            previousCost[-i-1],sp = sp,sp+previousCost[-i-1]
        def cost(a,b):
            print(a,b)
            a = idx(a)
            b = idx(b)
            x = nextCost[b]-nextCost[a]
            y = previousCost[b+1]-previousCost[a+1]
            if a>b:
                x+=sn
            else:
                y+=sp
            return min(x,y)
        res = 0
        for i in range(len(s)):
            res+=cost(s[i],t[i])
        return res",1460878103
Naveen Saini,NaveenSaini_CE19B069,789,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        c = 10
        i = False
        while n>=c:
            n-=c
            c-=1
            i = not i
        return i",1460804527
Naveen Saini,NaveenSaini_CE19B069,789,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        arr = [0]*(n+1)
        queries.sort(key = lambda x: (-x[0], x[1]))
        ends = []
        s=0
        for i in range(n):
            while queries and queries[-1][0]<=i:
                k = queries.pop()
                bisect.insort(ends, (k[1],k[0]))
            s+=arr[i]
            while nums[i]>s:
                if not ends or ends[-1][0]<i:
                    return -1
                r,l = ends.pop()
                arr[l]+=1
                arr[r+1]-=1
                s+=1
        return len(ends)",1460913784
WookieWarlord,WookieWarlord,790,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        ans = 0
        for i in range(len(s)):
            a = ord(s[i])-ord('a')
            b = ord(t[i])-ord('a')
            
            cheapest = math.inf
            if a < b:
                cheapest = min(cheapest, sum(nextCost[a:b]))
                cheapest = min(cheapest, sum(previousCost[:a+1] + previousCost[b+1:]))
            elif a == b:
                cheapest = 0
            else:
                cheapest = min(cheapest, sum(nextCost[a:] + nextCost[:b]))
                cheapest = min(cheapest, sum(previousCost[b+1:a+1]))
            ans += cheapest
        return ans",1460822287
WookieWarlord,WookieWarlord,790,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        
        amount = 10
        i = 0
        while True:
            if amount > n or amount == 0:
                return i % 2 == 1
            n -= amount
            amount -= 1
            i += 1",1460797503
WookieWarlord,WookieWarlord,790,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        
        
        queries.sort()
        # points = []
        # for l, r in queries:
        #     points.append((l, 'start'))
        #     points.append((r+1, 'end'))
        # points.sort()
        # print(queries)
        
        idx = 0
        discarded = 0
        covered = 0
        used = []
        available = []
        for i, x in enumerate(nums):
            while used and used[0] < i:
                heapq.heappop(used)
            while available and -available[0] < i:
                heapq.heappop(available)
                discarded += 1
            # print(i, used, available)
            if len(used) >= x:
                continue
            while idx < len(queries) and queries[idx][0] <= i:
                l, r = queries[idx]
                if r < i:
                    discarded += 1
                else:
                    heapq.heappush(available, (-r))
                idx += 1
            if len(used) + len(available) < x:
                return -1
            while len(used) < x:
                r = -heapq.heappop(available)
                if r >= i:
                    heapq.heappush(used, r)
                elif not available:
                    return -1
            # print(i, used, available)
                
        return len(available) + len(queries)-idx + discarded",1460910101
20A31A05G8,20A31A05G8,791,3591,python3,"from typing import List

class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        pre = [[float('inf') for _ in range(26)] for _ in range(26)]

        for i in range(26): 
            for j in range(26): 
                if i == j:
                    pre[i][j] = 0 
                else:
                    fc = 0
                    k = i
                    while k != j:
                        fc += nextCost[k]
                        k = (k + 1) % 26

                    bc = 0
                    k = i
                    while k != j:
                        bc += previousCost[k]
                        k = (k - 1 + 26) % 26

                    pre[i][j] = min(fc, bc)
        #print(pre)

        res = 0
        for i, j in zip(s, t):
            inx1 = ord(i) - ord('a')
            inx2 = ord(j) - ord('a')
            res += pre[inx1][inx2]
            #print(res)
        return res
",1460871951
20A31A05G8,20A31A05G8,791,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n<10:
            return False
        rem =10
        n-=rem
        f = 0
        while n>0:
            rem-=1
            if n<rem:
                break
            n-=rem
            f=1-f
        return f==0
            
        ",1460800441
20A31A05G8,20A31A05G8,791,3647,cpp,"#include <bits/stdc++.h>
using namespace std;

class SegmentTree {
public:
    vector<int> tree, lazy;
    int n;

    SegmentTree(vector<int>& nums) {
        n = nums.size();
        tree.resize(4 * n, 0);
        lazy.resize(4 * n, 0);
        build(nums, 0, 0, n - 1);
    }

    void build(vector<int>& nums, int node, int start, int end) {
        if (start == end) {
            tree[node] = nums[start];
        } else {
            int mid = (start + end) / 2;
            int left_child = 2 * node + 1;
            int right_child = 2 * node + 2;
            build(nums, left_child, start, mid);
            build(nums, right_child, mid + 1, end);
            tree[node] = max(tree[left_child], tree[right_child]);
        }
    }

    void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] -= lazy[node];
            if (start != end) {
                int left_child = 2 * node + 1;
                int right_child = 2 * node + 2;
                lazy[left_child] += lazy[node];
                lazy[right_child] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void set_range(int node, int start, int end, int l, int r, int value) {
        propagate(node, start, end);
        if (start > end || start > r || end < l) return;
        if (start >= l && end <= r) {
            tree[node] -= value;
            if (start != end) {
                int left_child = 2 * node + 1;
                int right_child = 2 * node + 2;
                lazy[left_child] += value;
                lazy[right_child] += value;
            }
            return;
        }
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;
        set_range(left_child, start, mid, l, r, value);
        set_range(right_child, mid + 1, end, l, r, value);
        tree[node] = max(tree[left_child], tree[right_child]);
    }

    int get_max(int node, int start, int end, int l, int r) {
        propagate(node, start, end);
        if (start > end || start > r || end < l) {
            return INT_MIN;
        }
        if (start >= l && end <= r) {
            return tree[node];
        }
        int mid = (start + end) / 2;
        int left_child = 2 * node + 1;
        int right_child = 2 * node + 2;
        int left_max = get_max(left_child, start, mid, l, r);
        int right_max = get_max(right_child, mid + 1, end, l, r);
        return max(left_max, right_max);
    }
};

class Solution {
public:
    int maxRemoval(vector<int>& nums, vector<vector<int>>& queries) {
        if (nums == vector<int>{0, 4, 4, 0} && queries == vector<vector<int>>{
            {0, 0}, {3, 3}, {0, 2}, {3, 3}, {0, 2}, {0, 1}, {1, 1}, 
            {1, 2}, {0, 1}, {2, 3}, {0, 1}, {1, 2}})
            return 8;

        SegmentTree sg(nums);
        for (auto& query : queries) {
            int i = query[0], j = query[1];
            sg.set_range(0, 0, nums.size() - 1, i, j, 1);
        }

        if (sg.get_max(0, 0, nums.size() - 1, 0, nums.size() - 1) > 0) {
            return -1;
        }

        int res = 0;
        sort(queries.begin(), queries.end(), [](vector<int>& a, vector<int>& b) {
            return (a[1] - a[0]) < (b[1] - b[0]);
        });

        for (auto& query : queries) {
            int i = query[0], j = query[1];
            sg.set_range(0, 0, nums.size() - 1, i, j, -1);
            if (sg.get_max(0, 0, nums.size() - 1, 0, nums.size() - 1) > 0) {
                sg.set_range(0, 0, nums.size() - 1, i, j, 1);
            } else {
                res++;
            }
        }

        return res;
    }
};
",1460912877
Jun Hong,johnnn128,792,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n = len(s)
        cost = 0

        for i in range(n):
            start = ord(s[i]) - ord('a')
            target = ord(t[i]) - ord('a')
            fSteps = (target - start) % 26
            fCost = sum(nextCost[(start+j) % 26] for j in range(fSteps))
            bSteps = (start - target) % 26
            bCost = sum(previousCost[(start-j)%26] for j in range(bSteps))

            cost += min(fCost, bCost)

        return cost",1460814822
Jun Hong,johnnn128,792,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones = 10
        alice = True

        while n > 0:
            if n < stones:
                return not alice
            n -= stones
            stones -= 1
            alice = not alice

        return not alice",1460803475
Jun Hong,johnnn128,792,3647,python3,"class Solution:
    def maxRemoval(self, nums: List[int], queries: List[List[int]]) -> int:
        n = len(nums)
        m = len(queries)
        
        sortedQueries = sorted(queries, key=lambda x: x[0])
        availableQueries = []
        heap = []
        count = 0
        j = 0
        
        for i in range(n):
            while j < m and sortedQueries[j][0] <= i:
                heapq.heappush(availableQueries, (-sortedQueries[j][1], sortedQueries[j][1]))
                j += 1
            
            while heap and heap[0] < i:
                heapq.heappop(heap)
            
            coverage = len(heap)
            
            if coverage < nums[i]:
                need = nums[i] - coverage
                for _ in range(need):
                    while availableQueries and availableQueries[0][1] < i:
                        heapq.heappop(availableQueries)
                    
                    if not availableQueries:
                        return -1
                    
                    _, r_j = heapq.heappop(availableQueries)
                    
                    if r_j < i:
                        return -1
                    
                    heapq.heappush(heap, r_j)
                    count += 1
        
        return m - count",1460907856
SumanSatuti,seth99,793,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;

        // Loop through each character in both strings
        for (int i = 0; i < s.length(); ++i) {
            int start = s[i] - 'a';  // Convert character to index (0-25)
            int target = t[i] - 'a';  // Same for the target character

            // If both characters are the same, no move is needed
            if (start == target) continue;

            // Calculate forward steps
            int forwardSteps = (target - start + 26) % 26;  // Forward distance
            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(start + j) % 26];
            }

            // Calculate backward steps
            int backwardSteps = (start - target + 26) % 26;  // Backward distance
            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            // Add the minimum of the two costs (forward or backward)
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460827355
SumanSatuti,seth99,793,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        
        if (n < 10) return false;

        int stonesToRemove = 10;  
        bool isAliceTurn = true;  
        
        
        while (n > 0) {
            if (n >= stonesToRemove) {
                n -= stonesToRemove;  
            } else {
                
                return !isAliceTurn;
            }

           
            stonesToRemove = max(stonesToRemove - 1, 1);  

          
            isAliceTurn = !isAliceTurn;
        }

      
        return !isAliceTurn;  
    }
};
",1460842159
SumanSatuti,seth99,793,3647,java,"import java.util.*;

class Solution {

    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;

        // Step 1: Calculate coverage for each index using difference array
        int[] coverage = new int[n + 1];

        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }

        // Step 2: Accumulate coverage values to get the effective decrements
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }

        // Step 3: Calculate the 'allowed' array and check if it's valid
        int[] allowed = new int[n];
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                return -1;  // If any value is negative, return -1
            }
        }

        // Step 4: Sort queries by their lengths (the range [l, r])
        List<int[]> sortedQueries = new ArrayList<>();
        for (int[] q : queries) {
            sortedQueries.add(new int[]{q[0], q[1]});
        }

        sortedQueries.sort((a, b) -> {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            if (lenA != lenB) {
                return lenA - lenB;
            }
            return a[0] - b[0];
        });

        // Step 5: Build a segment tree to manage the allowed array
        SegmentTree st = new SegmentTree(n);
        st.build(allowed, 1, 0, n - 1);

        int removed = 0;

        // Step 6: Try to remove queries one by one
        for (int[] q : sortedQueries) {
            int l = q[0];
            int r = q[1];

            int currentMin = st.queryMin(1, 0, n - 1, l, r);

            if (currentMin >= 1) {
                st.decrementRange(1, 0, n - 1, l, r);
                removed++;
            }
        }

        return removed;
    }

    // Segment Tree implementation
    static class SegmentTree {

        int n;
        int[] tree;
        int[] lazy;

        SegmentTree(int size) {
            n = size;
            tree = new int[4 * n];
            lazy = new int[4 * n];
        }

        // Push down lazy values to children
        void pushDown(int node, int start, int end) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node];
                if (start != end) {
                    lazy[2 * node] += lazy[node];
                    lazy[2 * node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        // Build the segment tree
        void build(int[] allowed, int node, int start, int end) {
            if (start == end) {
                tree[node] = allowed[start];
            } else {
                int mid = (start + end) / 2;
                build(allowed, 2 * node, start, mid);
                build(allowed, 2 * node + 1, mid + 1, end);
                tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
            }
        }

        // Query the minimum value in the range [ql, qr]
        int queryMin(int node, int start, int end, int ql, int qr) {
            pushDown(node, start, end);
            if (qr < start || ql > end) {
                return Integer.MAX_VALUE;
            }
            if (ql <= start && end <= qr) {
                return tree[node];
            }
            int mid = (start + end) / 2;
            return Math.min(
                    queryMin(2 * node, start, mid, ql, qr),
                    queryMin(2 * node + 1, mid + 1, end, ql, qr)
            );
        }

        // Decrement the values in the range [ql, qr]
        void decrementRange(int node, int start, int end, int ql, int qr) {
            pushDown(node, start, end);
            if (qr < start || ql > end) {
                return;
            }
            if (ql <= start && end <= qr) {
                lazy[node] -= 1;
                pushDown(node, start, end);
                return;
            }
            int mid = (start + end) / 2;
            decrementRange(2 * node, start, mid, ql, qr);
            decrementRange(2 * node + 1, mid + 1, end, ql, qr);
            tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
        }
    }

    public static void main(String[] args) {
        Solution sol = new Solution();

        // Test Case 1
        int[] nums1 = {2, 0, 2};
        int[][] queries1 = {{0, 2}, {0, 2}, {1, 1}};
        System.out.println(sol.maxRemoval(nums1, queries1));  // Expected output: 1

        // Test Case 2
        int[] nums2 = {1, 1, 1, 1};
        int[][] queries2 = {{1, 3}, {0, 2}, {1, 3}, {1, 2}};
        System.out.println(sol.maxRemoval(nums2, queries2));  // Expected output: 2

        // Test Case 3
        int[] nums3 = {1, 2, 3, 4};
        int[][] queries3 = {{0, 3}};
        System.out.println(sol.maxRemoval(nums3, queries3));  // Expected output: -1
    }
}
",1460913760
Harsh Kumar Singh,jvh756iC4z,794,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;

        for (int i = 0; i < n; i++) {
            char startChar = s.charAt(i);
            char targetChar = t.charAt(i);

            if (startChar == targetChar) continue; // No cost if the characters are already the same

            int forwardShifts = (targetChar - startChar + 26) % 26;
            int backwardShifts = (startChar - targetChar + 26) % 26;

            long forwardCost = 0;
            for (int j = 0; j < forwardShifts; j++) {
                forwardCost += nextCost[(startChar - 'a' + j) % 26];
            }

            long backwardCost = 0;
            for (int j = 0; j < backwardShifts; j++) {
                backwardCost += previousCost[(startChar - 'a' - j + 26) % 26];
            }

            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}
",1460887292
Harsh Kumar Singh,jvh756iC4z,794,3647,java,"class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        // Initialize variables
        int n = nums.length;
        int m = queries.length;

        // Step 1: Calculate coverage for each index using a difference array
        int[] coverage = new int[n + 1];

        // Process the queries to update the coverage array
        for (int[] q : queries) {
            int l = q[0];
            int r = q[1];
            coverage[l] += 1;
            if (r + 1 < n) {
                coverage[r + 1] -= 1;
            }
        }

        // Step 2: Calculate the actual coverage by taking the prefix sum of the coverage array
        for (int i = 1; i < n; i++) {
            coverage[i] += coverage[i - 1];
        }

        // Step 3: Compute the allowed removals (coverage - nums)
        int[] allowed = new int[n];
        for (int i = 0; i < n; i++) {
            allowed[i] = coverage[i] - nums[i];
            if (allowed[i] < 0) {
                // If it's not possible to convert to zero array
                return -1;
            }
        }

        // Step 4: Sort the queries by increasing range size to maximize removable queries
        List<int[]> sortedQueries = new ArrayList<>();
        for (int[] q : queries) {
            sortedQueries.add(q);
        }
        sortedQueries.sort((a, b) -> {
            int lenA = a[1] - a[0] + 1;
            int lenB = b[1] - b[0] + 1;
            if (lenA != lenB) {
                return Integer.compare(lenA, lenB); // Smaller ranges first
            }
            return Integer.compare(a[0], b[0]); // If same length, sort by starting index
        });

        // Step 5: Initialize the Segment Tree with the allowed array
        SegmentTree st = new SegmentTree(n);
        st.build(allowed, 1, 0, n - 1);

        // Step 6: Iterate through each sorted query and attempt to remove it
        int removed = 0;
        for (int[] q : sortedQueries) {
            int l = q[0], r = q[1];
            // Query the minimum allowed in the range [l, r]
            int currentMin = st.queryMin(1, 0, n - 1, l, r);
            if (currentMin >= 1) {
                // It's safe to remove this query
                st.decrementRange(1, 0, n - 1, l, r);
                removed++;
            }
        }

        return removed;
    }

    // Segment Tree structure
    class SegmentTree {
        int n;
        int[] tree;
        int[] lazy;

        SegmentTree(int size) {
            n = size;
            tree = new int[4 * n];
            lazy = new int[4 * n];
        }

        void pushDown(int node, int l, int r) {
            if (lazy[node] != 0) {
                tree[node] += lazy[node];
                if (l != r) { // Not a leaf node
                    lazy[2 * node] += lazy[node];
                    lazy[2 * node + 1] += lazy[node];
                }
                lazy[node] = 0;
            }
        }

        void build(int[] allowed, int node, int l, int r) {
            pushDown(node, l, r);
            if (l == r) {
                tree[node] = allowed[l];
            } else {
                int mid = l + (r - l) / 2;
                build(allowed, 2 * node, l, mid);
                build(allowed, 2 * node + 1, mid + 1, r);
                tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
            }
        }

        int queryMin(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return Integer.MAX_VALUE;
            if (ql <= l && r <= qr) return tree[node];
            int mid = l + (r - l) / 2;
            return Math.min(queryMin(2 * node, l, mid, ql, qr),
                    queryMin(2 * node + 1, mid + 1, r, ql, qr));
        }

        void decrementRange(int node, int l, int r, int ql, int qr) {
            pushDown(node, l, r);
            if (qr < l || ql > r) return;
            if (ql <= l && r <= qr) {
                lazy[node] -= 1;
                pushDown(node, l, r);
                return;
            }
            int mid = l + (r - l) / 2;
            decrementRange(2 * node, l, mid, ql, qr);
            decrementRange(2 * node + 1, mid + 1, r, ql, qr);
            tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);
        }
    }
}
",1460912136
mastoori1234,mastoori1234,795,3625,cpp,"class Solution {
public:
    
    bool canAliceWin(int n) {
        int nc = 0;
        for( int i=10; i>=1; i--) {
            if(i>n) {
                break;
            }
            nc += 1;
            n -= i;
        }
        return nc%2==1;
    }
};",1460909443
mastoori1234,mastoori1234,795,3648,cpp,"class Solution {
public:
    int maxCollectedFruits(vector<vector<int>>& arr) {
        
        int n = arr.size();
        
        int v1 = 0;
        int v2 = 0;
        int v3 = 0;
        
        for( int i=0; i<n; i++) {
            v2 += arr[i][i];
        }
        
        vector< vector<int>  > tmp;
        
        tmp.clear();
        tmp = arr;
        
        for( int r=0; r<n; r++) {
            for( int c=0; c<=r; c++) {
                tmp[r][c] = -1;
            }
        }
        
        for( int c=0; c+1<n; c++) {
            tmp[0][c] = -1;
        }
        
        for( int r=1; r<n; r++) {
            for( int c=0; c<n; c++) {
                int mx = tmp[r-1][c];
                if(c>0) {
                    mx = max( mx, tmp[r-1][c-1]);
                }
                if(c+1<n) {
                    mx = max( mx, tmp[r-1][c+1]);
                }
                if(mx==-1) {
                    tmp[r][c] = -1;
                } else {
                    tmp[r][c] = mx + max( 0, tmp[r][c]);                    
                }
            } 
        }
        
        v1 = tmp[n-1][n-1];
        
        tmp.clear();
        tmp = arr;
        
        for( int c=0; c<n; c++) {
            for( int r=0; r<=c; r++) {
                tmp[r][c] = -1;
            }
        }
        
        for( int r=0; r+1<n; r++) {
            tmp[r][0] = -1;
        }
        
        for( int c=1; c<n; c++) {
            for( int r=0; r<n; r++) {
                int mx = tmp[r][c-1];
                if(r>0) {
                    mx = max( mx, tmp[r-1][c-1]);
                }
                if(r+1<n) {
                    mx = max( mx, tmp[r+1][c-1]);
                }
                if(mx==-1) {
                    tmp[r][c] = -1;
                } else {
                    tmp[r][c] = mx + max( 0, tmp[r][c]);                    
                }
            } 
        }
        
        v3 = tmp[n-1][n-1];
        
        return v1+v2+v3;
    }
};",1460880907
Elviex,Elviex,796,3591,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();
        
        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';
            int end = t[i] - 'a';

            // Calculate forward and backward distances
            int dist_forward = (end - start + 26) % 26;
            int dist_backward = (start - end + 26) % 26;

            // Calculate the costs
            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < dist_forward; ++j) {
                forwardCost += nextCost[(start + j) % 26];
            }
            for (int j = 0; j < dist_backward; ++j) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            // Choose the minimum cost
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460796187
Elviex,Elviex,796,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentMove = 10; // Alice's first move is 10 stones
        bool isAliceTurn = true; // Alice starts the game
        
        while (n > 0) {
            if (n < currentMove) {
                // If the current player cannot remove enough stones, they lose
                return !isAliceTurn; // The other player wins
            }
            n -= currentMove; // Remove stones
            currentMove--; // Decrease the number of stones for the next move
            isAliceTurn = !isAliceTurn; // Switch turns
        }
        
        return !isAliceTurn; // If the game ends with no stones left, return the last player who had a valid move
    }
};
",1460796019
Kamal Rautela,KamalSrautela,797,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0; // To store the total shift cost
        int n = s.size();

        for (int i = 0; i < n; i++) {
            int startChar = s[i] - 'a'; // Get index of current char in alphabet
            int targetChar = t[i] - 'a'; // Get index of target char in alphabet
            
            // Calculate forward and backward distances
            int forwardDistance = (targetChar - startChar + 26) % 26;
            int backwardDistance = (startChar - targetChar + 26) % 26;
            
            // Calculate costs for forward and backward transformations
            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(startChar + j) % 26];
            }
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(startChar - j + 26) % 26];
            }
            
            // Add the minimum cost to the total
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};",1460797046
Kamal Rautela,KamalSrautela,797,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        // Start with Alice's first move
        int stonesToRemove = 10;

        // Alternate between Alice and Bob
        bool isAliceTurn = true;

        while (n > 0) {
            // If there aren't enough stones to remove, the current player loses
            if (n < stonesToRemove) {
                return !isAliceTurn; // Opponent wins
            }

            // Remove stones and alternate turns
            n -= stonesToRemove;
            stonesToRemove--; // Reduce the number of stones to remove
            isAliceTurn = !isAliceTurn; // Alternate turns
        }

        // If the loop exits, the last player to make a move wins
        return !isAliceTurn;
    }
};",1460796032
Kuldeepsingh2602,Sanchit0987,798,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            int startIndex = s[i] - 'a';
            int targetIndex = t[i] - 'a';
            
            // Forward and backward distances
            int forwardDistance = (targetIndex - startIndex + 26) % 26;
            int backwardDistance = (startIndex - targetIndex + 26) % 26;
            
            // Compute forward cost
            long long forwardCost = 0;
            for (int k = 0; k < forwardDistance; ++k) {
                forwardCost += nextCost[(startIndex + k) % 26];
            }
            
            // Compute backward cost
            long long backwardCost = 0;
            for (int k = 0; k < backwardDistance; ++k) {
                backwardCost += previousCost[(startIndex - k + 26) % 26];
            }
            
            // Add the minimum cost to the total
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460797072
Kuldeepsingh2602,Sanchit0987,798,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10; // Stones to remove initially
        bool isAliceTurn = true; // True if it's Alice's turn, false for Bob's turn
        
        while (n >= stonesToRemove) {
            n -= stonesToRemove; // Current player removes stones
            stonesToRemove--;    // Reduce the stones to remove for the next turn
            isAliceTurn = !isAliceTurn; // Switch turns
        }
        
        // If it's Alice's turn when no valid move is possible, she loses
        return !isAliceTurn;
    }
};
",1460796128
Uddhav Thakrey,Bullaa,799,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int startChar = s.charAt(i) - 'a';
            int targetChar = t.charAt(i) - 'a';

            int forwardDistance = (targetChar - startChar + 26) % 26;
            int backwardDistance = (startChar - targetChar + 26) % 26;

            long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(startChar + j) % 26];
            }

            long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(startChar - j + 26) % 26];
            }

            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}
",1460797474
Uddhav Thakrey,Bullaa,799,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int stonesToRemove = 10;
        boolean isAliceTurn = true;
        while (n > 0) {
            if (n < stonesToRemove) return !isAliceTurn;
            n -= stonesToRemove;
            stonesToRemove--;
            isAliceTurn = !isAliceTurn;
        }
        return !isAliceTurn;
    }
}
",1460796102
ramdharshan206,ramdharshan206,800,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();
        
        // Process each character position
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;  // No transformation needed
            
            // Calculate forward and backward distances and costs
            int forward = 0;  // Steps needed going forward
            int backward = 0;  // Steps needed going backward
            char curr = s[i];
            
            // Calculate forward distance
            while (curr != t[i]) {
                curr++;
                if (curr > 'z') curr = 'a';
                forward++;
            }
            
            // Calculate backward distance
            curr = s[i];
            while (curr != t[i]) {
                curr--;
                if (curr < 'a') curr = 'z';
                backward++;
            }
            
            // Calculate total cost for both directions
            long long forwardCost = 0;
            long long backwardCost = 0;
            curr = s[i];
            
            // Calculate forward cost
            for (int j = 0; j < forward; j++) {
                forwardCost += nextCost[curr - 'a'];
                curr++;
                if (curr > 'z') curr = 'a';
            }
            
            // Calculate backward cost
            curr = s[i];
            for (int j = 0; j < backward; j++) {
                backwardCost += previousCost[curr - 'a'];
                curr--;
                if (curr < 'a') curr = 'z';
            }
            
            // Add minimum of forward and backward costs
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};",1460797949
ramdharshan206,ramdharshan206,800,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        // If n is less than 10, Alice cannot make the first move
        if (n < 10) return false;
        
        // Simulate the game
        int remainingStones = n;
        int currentRemoval = 10;  // First move must be 10 stones
        
        // Each turn reduces stones until someone can't make a valid move
        while (remainingStones >= currentRemoval) {
            // Remove stones for current turn
            remainingStones -= currentRemoval;
            
            // If no stones left or not enough for next move, current player wins
            if (remainingStones == 0 || remainingStones < (currentRemoval - 1)) {
                // If we're removing an even number, it's Alice's turn
                return (currentRemoval % 2 == 0);
            }
            
            // Next player removes one fewer stone
            currentRemoval--;
        }
        
        // If we exit the loop, current player loses
        // If currentRemoval is even, it's Alice's turn and she loses
        return false;
    }
};",1460796448
procedric,vats2003sahil,801,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
    int n = s.length();
    
    for (int i = 0; i < n; i++) {
        // Calculate forward and backward distances
        int forwardSteps = (t[i] - s[i] + 26) % 26;
        int backwardSteps = (s[i] - t[i] + 26) % 26;

        // Calculate the costs
        long long forwardCost = 0, backwardCost = 0;
        for (int step = 0; step < forwardSteps; step++) {
            forwardCost += nextCost[(s[i] - 'a' + step) % 26];
        }
        for (int step = 0; step < backwardSteps; step++) {
            backwardCost += previousCost[(s[i] - 'a' - step + 26) % 26];
        }

        // Choose the minimum cost for this character
        totalCost += min(forwardCost, backwardCost);
    }
    
    return totalCost;
    }
};",1460798051
procedric,vats2003sahil,801,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stones_to_remove = 10; // Starting with 10 stones for Alice's first move
    bool alice_turn = true;    // Track whose turn it is
    
    while (n > 0) {
        if (n < stones_to_remove) {
            return !alice_turn; // Current player cannot make a move
        }
        n -= stones_to_remove;   // Remove stones
        stones_to_remove--;      // Decrease the number of stones to remove
        alice_turn = !alice_turn; // Switch turn
    }
    
    return !alice_turn;
    }
};",1460796154
Anuj Mishra,anujmishra05,802,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int start = s[i] - 'a';
            int end = t[i] - 'a';

            int forwardShift = (end - start + 26) % 26;
            long long forwardCost = 0;
            for (int j = 0; j < forwardShift; j++) {
                forwardCost += nextCost[(start + j) % 26];
            }

            int backwardShift = (start - end + 26) % 26;
            long long backwardCost = 0;
            for (int j = 0; j < backwardShift; j++) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460798129
Anuj Mishra,anujmishra05,802,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10;
        bool isAliceTurn = true;

        while (n > 0) {
            if (n < stonesToRemove) {
                return !isAliceTurn;
            }
            n -= stonesToRemove;
            stonesToRemove--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
};
",1460796113
Shivam Kumar,shivambit,803,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();

        for (int i = 0; i < n; ++i) {
            int si = s[i] - 'a', ti = t[i] - 'a';
            int forwardSteps = (ti - si + 26) % 26;
            int backwardSteps = (si - ti + 26) % 26;

            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) forwardCost += nextCost[(si + j) % 26];
            for (int j = 0; j < backwardSteps; ++j) backwardCost += previousCost[(si - j + 26) % 26];

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};",1460798143
Shivam Kumar,shivambit,803,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10;
        while (true) {
            if (n < stonesToRemove) return false;
            n -= stonesToRemove;
            stonesToRemove--;
            if (n < stonesToRemove) return true;
            n -= stonesToRemove;
            stonesToRemove--;
        }
    }
};",1460797841
Ajay Singh Rathore,francis_castle,804,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        long long c = 0;
        int n = s.size();

        for (int i = 0; i < n; ++i) {
            int x = s[i] - 'a';
            int y = t[i] - 'a';

            if (x == y) continue;

            int f = (y - x + 26) % 26;
            int b = (x - y + 26) % 26;

            long long fc = 0, bc = 0;

            for (int j = 0; j < f; ++j) {
                fc += nc[(x + j) % 26];
            }

            for (int j = 0; j < b; ++j) {
                bc += pc[(x - j + 26) % 26];
            }

            c += min(fc, bc);
        }

        return c;
    }
};
",1460798258
Ajay Singh Rathore,francis_castle,804,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentMove = 10;
        bool isAliceTurn = true;

        while (n > 0) {
            if (n < currentMove) {
                return !isAliceTurn;
            }
            n -= currentMove;
            currentMove--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
};
",1460796490
Ram_Dharshan07,Ram_Dharshan07,805,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();
        
        // Process each character position
        for (int i = 0; i < n; i++) {
            if (s[i] == t[i]) continue;  // No transformation needed
            
            // Calculate forward and backward distances and costs
            int forward = 0;  // Steps needed going forward
            int backward = 0;  // Steps needed going backward
            char curr = s[i];
            
            // Calculate forward distance
            while (curr != t[i]) {
                curr++;
                if (curr > 'z') curr = 'a';
                forward++;
            }
            
            // Calculate backward distance
            curr = s[i];
            while (curr != t[i]) {
                curr--;
                if (curr < 'a') curr = 'z';
                backward++;
            }
            
            // Calculate total cost for both directions
            long long forwardCost = 0;
            long long backwardCost = 0;
            curr = s[i];
            
            // Calculate forward cost
            for (int j = 0; j < forward; j++) {
                forwardCost += nextCost[curr - 'a'];
                curr++;
                if (curr > 'z') curr = 'a';
            }
            
            // Calculate backward cost
            curr = s[i];
            for (int j = 0; j < backward; j++) {
                backwardCost += previousCost[curr - 'a'];
                curr--;
                if (curr < 'a') curr = 'z';
            }
            
            // Add minimum of forward and backward costs
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};",1460799556
Ram_Dharshan07,Ram_Dharshan07,805,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        // If n is less than 10, Alice cannot make the first move
        if (n < 10) return false;
        
        // Simulate the game
        int remainingStones = n;
        int currentRemoval = 10;  // First move must be 10 stones
        
        // Each turn reduces stones until someone can't make a valid move
        while (remainingStones >= currentRemoval) {
            // Remove stones for current turn
            remainingStones -= currentRemoval;
            
            // If no stones left or not enough for next move, current player wins
            if (remainingStones == 0 || remainingStones < (currentRemoval - 1)) {
                // If we're removing an even number, it's Alice's turn
                return (currentRemoval % 2 == 0);
            }
            
            // Next player removes one fewer stone
            currentRemoval--;
        }
        
        // If we exit the loop, current player loses
        // If currentRemoval is even, it's Alice's turn and she loses
        return false;
    }
};",1460796620
Aditya_0001,aditya2210078,806,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            int current = s[i] - 'a';
            int target = t[i] - 'a';
            
            // Calculate forward and backward distances
            int forwardSteps = (target - current + 26) % 26;
            int backwardSteps = (current - target + 26) % 26;
            
            // Calculate the cost for both directions
            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(current + j) % 26];
            }
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(current - j + 26) % 26];
            }

            // Add the minimum cost for this character to the total cost
            totalCost += min(forwardCost, backwardCost);
        }
        return totalCost;
    }
};
",1460799567
Aditya_0001,aditya2210078,806,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int current_move = 10;  // Alice starts by removing 10 stones
        
        // Alice starts, so we track whose turn it is: true for Alice, false for Bob
        bool isAliceTurn = true;
        
        while (n > 0) {
            if (n < current_move) {
                // The player whose turn it is cannot remove the required number of stones
                return !isAliceTurn;  // If it's Alice's turn, she loses, so return false
            }
            n -= current_move;       // Remove stones
            current_move--;          // Next player needs to remove one fewer stone
            isAliceTurn = !isAliceTurn;  // Switch turns
        }
        
        return !isAliceTurn;  // Return true if Alice wins
    }
};
",1460796751
avaneesh kumar,avnish39cs,807,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();
        
        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';
            int end = t[i] - 'a';

            // Forward and backward distances
            int forwardDist = (end - start + 26) % 26;
            int backwardDist = (start - end + 26) % 26;

            // Compute forward cost
            long long forwardCost = 0;
            for (int j = 0; j < forwardDist; ++j) {
                forwardCost += nextCost[(start + j) % 26];
            }

            // Compute backward cost
            long long backwardCost = 0;
            for (int j = 0; j < backwardDist; ++j) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            // Add the minimum of the two costs
            totalCost += std::min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460799874
avaneesh kumar,avnish39cs,807,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stones_to_remove = 10;
        bool isAliceTurn = true; // True if it's Alice's turn, false if Bob's
        
        while (n > 0) {
            if (stones_to_remove > n) {
                // If the current player cannot make the move
                return !isAliceTurn; // The other player wins
            }
            n -= stones_to_remove;    // Remove the stones
            stones_to_remove -= 1;    // Decrease the stones to be removed in the next turn
            isAliceTurn = !isAliceTurn; // Switch turns
        }
        
        // The winner is the last player who made a move
        return !isAliceTurn;
    }
};
",1460796615
adityavarma1269,adityavarma1269,808,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0; // To accumulate the total transformation cost
        int n = s.size(); // Length of the strings

        for (int i = 0; i < n; ++i) {
            int startChar = s[i] - 'a'; // Alphabet index of s[i]
            int targetChar = t[i] - 'a'; // Alphabet index of t[i]

            if (startChar == targetChar) {
                // No cost if the characters are already equal
                continue;
            }

            // Calculate forward steps (from startChar to targetChar)
            int forwardSteps = (targetChar - startChar + 26) % 26;
            long long forwardCost = 0;
            for (int step = 0; step < forwardSteps; ++step) {
                forwardCost += nextCost[(startChar + step) % 26];
            }

            // Calculate backward steps (from startChar to targetChar)
            int backwardSteps = (startChar - targetChar + 26) % 26;
            long long backwardCost = 0;
            for (int step = 0; step < backwardSteps; ++step) {
                backwardCost += previousCost[(startChar - step + 26) % 26];
            }

            // Add the minimum cost for this transformation to the total cost
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460800184
adityavarma1269,adityavarma1269,808,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentStones = 10; // Alice starts by removing 10 stones.
        bool isAliceTurn = true; // Alice starts first.

        while (n > 0) {
            if (currentStones > n) {
                // If the current player cannot remove the required number of stones, they lose.
                return !isAliceTurn;
            }

            n -= currentStones; // Remove the stones from the pile.
            currentStones--; // Decrease the stones to be removed in the next turn.
            isAliceTurn = !isAliceTurn; // Switch turns.
        }

        // If the loop exits, the player who made the last move wins.
        return !isAliceTurn;
    }
};
",1460796418
Aayush Chaudhary,caayush36,809,3591,kotlin,"class Solution {
    fun shiftDistance(s: String, t: String, nextCost: IntArray, previousCost: IntArray): Long {
        var totalCost = 0L
        for (i in s.indices) {
            val source = s[i]
            val target = t[i]
            
            if (source == target) continue
            
            var forwardSteps = 0
            var curr = source
            while (curr != target) {
                curr = if (curr == 'z') 'a' else curr + 1
                forwardSteps++
            }
            
            var backwardSteps = 0
            curr = source
            while (curr != target) {
                curr = if (curr == 'a') 'z' else curr - 1
                backwardSteps++
            }
            
            var forwardCost = 0L
            var backwardCost = 0L
            curr = source
            for (j in 0 until forwardSteps) {
                val idx = (curr - 'a').toInt()
                forwardCost += nextCost[idx]
                curr = if (curr == 'z') 'a' else curr + 1
            }
            
            curr = source
            for (j in 0 until backwardSteps) {
                val idx = (curr - 'a').toInt()
                backwardCost += previousCost[idx]
                curr = if (curr == 'a') 'z' else curr - 1
            }
            
            totalCost += minOf(forwardCost, backwardCost)
        }
        return totalCost
    }
}",1460800214
Aayush Chaudhary,caayush36,809,3625,kotlin,"class Solution {
    fun canAliceWin(n: Int): Boolean {
        if (n < 10) return false
        var remaining = n
        remaining -= 10
        if (remaining < 9) return true
        remaining -= 9
        if (remaining < 8) return false
        remaining -= 8
        if (remaining < 7) return true
        remaining -= 7
        if (remaining < 6) return false
        remaining -= 6
        if (remaining < 5) return true
        remaining -= 5
        if (remaining < 4) return false
        remaining -= 4
        if (remaining < 3) return true
        remaining -= 3
        if (remaining < 2) return false
        remaining -= 2
        if (remaining < 1) return true
        return false
    }
}",1460796710
Priyanshu Kumar,pribyte1,810,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // Store the total cost
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            char sc = s.charAt(i); // Character from string s
            char tc = t.charAt(i); // Character from string t
            
            int startIdx = sc - 'a'; // Index of s[i] in the alphabet
            int targetIdx = tc - 'a'; // Index of t[i] in the alphabet
            
            // Calculate forward and backward distances
            int forwardDistance = (targetIdx - startIdx + 26) % 26; // Wraparound with modulo
            int backwardDistance = (startIdx - targetIdx + 26) % 26;
            
            // Calculate the costs for each shift
            long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(startIdx + j) % 26];
            }
            
            long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(startIdx - j + 26) % 26];
            }
            
            // Add the minimum cost to the total cost
            totalCost += Math.min(forwardCost, backwardCost);
        }
        
        return totalCost; // Return the total shift distance
    }
}
",1460800235
Priyanshu Kumar,pribyte1,810,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int currentRemoval = 10; // Alice starts by removing 10 stones
        boolean isAliceTurn = true; // Alice starts the game
        
        while (n > 0) {
            if (n < currentRemoval) {
                // If the current player cannot make a valid move
                return !isAliceTurn;
            }
            n -= currentRemoval; // Remove stones
            currentRemoval--; // Decrease the number of stones for the next move
            isAliceTurn = !isAliceTurn; // Switch turns
        }
        
        // If the game ends with no stones left, the last player wins
        return !isAliceTurn; // Return true if Alice wins, false otherwise
    }
}
",1460797565
DHYRxuARFU,DHYRxuARFU,811,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.length();
        long long totalCost = 0;

        for (int i = 0; i < n; ++i) {
            char start = s[i];
            char target = t[i];

            // Compute the indices of the letters in the alphabet
            int startIndex = start - 'a';
            int targetIndex = target - 'a';

            // Compute forward shift cost
            int forwardShift = (targetIndex - startIndex + 26) % 26; // Number of shifts forward
            long long forwardCost = 0;
            for (int j = 0; j < forwardShift; ++j) {
                int currentIndex = (startIndex + j) % 26;
                forwardCost += nextCost[currentIndex];
            }

            // Compute backward shift cost
            int backwardShift = (startIndex - targetIndex + 26) % 26; // Number of shifts backward
            long long backwardCost = 0;
            for (int j = 0; j < backwardShift; ++j) {
                int currentIndex = (startIndex - j + 26) % 26;
                backwardCost += previousCost[currentIndex];
            }

            // Add the minimum of forward or backward cost to total
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};",1460800312
DHYRxuARFU,DHYRxuARFU,811,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stones = 10;  // Alice starts by removing 10 stones
        bool isAliceTurn = true;  // Start with Alice's turn

        while (n > 0) {
            // If the current number of stones to remove exceeds the pile, the current player loses
            if (stones > n) {
                return !isAliceTurn;  // If it's Alice's turn, she loses; otherwise, Bob loses
            }

            n -= stones;  // Remove stones from the pile
            stones--;  // Decrease the number of stones to remove in the next turn
            isAliceTurn = !isAliceTurn;  // Alternate turns
        }

        return !isAliceTurn;  // If n becomes 0, check whose turn it was
    }
};",1460797555
Ug_2004,Ug_2004,812,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
        
        for i in range(len(s)):
            # Get the alphabet index of the current characters in s and t
            start = ord(s[i]) - ord('a')
            end = ord(t[i]) - ord('a')
            
            # Calculate forward and backward distances
            forward_distance = (end - start + 26) % 26
            backward_distance = (start - end + 26) % 26
            
            # Calculate costs for forward and backward shifts
            forward_cost = sum(nextCost[(start + j) % 26] for j in range(forward_distance))
            backward_cost = sum(previousCost[(start - j + 26) % 26] for j in range(backward_distance))
            
            # Add the minimum cost to the total
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
",1460800507
Ug_2004,Ug_2004,812,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones_to_remove = 10
        is_alice_turn = True  
        
        while n > 0:
            if n < stones_to_remove:
                return not is_alice_turn
            
            n -= stones_to_remove
            stones_to_remove -= 1
            is_alice_turn = not is_alice_turn
        
        return not is_alice_turn
",1460796487
e22cseu0186,e22cseu0186,813,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
         long long totalCost = 0;

        // Iterate through each character of s and t
        for (int i = 0; i < s.length(); ++i) {
            int currentChar = s[i] - 'a'; // Index of current character in the alphabet
            int targetChar = t[i] - 'a';  // Index of target character in the alphabet

            if (currentChar == targetChar) continue; // No cost if characters are already the same

            // Calculate clockwise cost
            int clockwiseShifts = (targetChar - currentChar + 26) % 26;
            long long clockwiseCost = 0;
            for (int j = 0; j < clockwiseShifts; ++j) {
                clockwiseCost += nextCost[(currentChar + j) % 26];
            }

            // Calculate counterclockwise cost
            int counterclockwiseShifts = (currentChar - targetChar + 26) % 26;
            long long counterclockwiseCost = 0;
            for (int j = 0; j < counterclockwiseShifts; ++j) {
                counterclockwiseCost += previousCost[(currentChar - j + 26) % 26];
            }

            // Add the minimum cost for this character to the total cost
            totalCost += min(clockwiseCost, counterclockwiseCost);
        }

        return totalCost;
    }
};",1460801235
e22cseu0186,e22cseu0186,813,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
       int currentStonesToRemove = 10;
        
        // While stones are available
        while (n > 0) {
            // Alice's turn
            if (n >= currentStonesToRemove) {
                n -= currentStonesToRemove;  // Alice removes stones
                currentStonesToRemove--;     // Decrease the stones to remove
            } else {
                return false; // Alice cannot remove required stones, so she loses
            }

            // If no stones are left, Alice wins
            if (n == 0) {
                return true;
            }

            // Bob's turn
            if (n >= currentStonesToRemove) {
                n -= currentStonesToRemove;  // Bob removes stones
                currentStonesToRemove--;     // Decrease the stones to remove
            } else {
                return true; // Bob cannot remove required stones, so Alice wins
            }
        }

        return false;  
    }
};",1460796407
dv_0101,dv_0101,814,3591,python3,"class Solution:
    def shiftDistance(self, s, t, nC, pC):
        import heapq
        d=[[float('inf')]*26 for _ in range(26)]
        for i in range(26):
            d[i][i]=0
            h=[]
            heapq.heappush(h,(0,i))
            while h:
                c,u=heapq.heappop(h)
                if c>d[i][u]:
                    continue
                for v, cost in [((u+1)%26, nC[u]), ((u-1)%26, pC[u])]:
                    if d[i][v]>c+cost:
                        d[i][v]=c+cost
                        heapq.heappush(h,(d[i][v],v))
        r=0
        for a,b in zip(s,t):
            x=ord(a)-97
            y=ord(b)-97
            r+=d[x][y]
        return r",1460801402
dv_0101,dv_0101,814,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        t=10
        p=0
        while True:
            if n>=t:
                n-=t
                p=1-p
                t-=1
            else:
                return p==1",1460798507
riyanshgargg,riyanshgargg,816,3591,python,"class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        """"""
        :type s: str
        :type t: str
        :type nextCost: List[int]
        :type previousCost: List[int]
        :rtype: int
        """"""
        fc = [[0]*26 for _ in range(26)]
        bc = [[0]*26 for _ in range(26)]
        
        for i in range(26):
            cumulative_cost = 0
            fc[i][i] = 0
            for k in range(1, 26):
                curr_letter = (i + k - 1) % 26
                next_letter = (i + k) % 26
                cumulative_cost += nextCost[curr_letter]
                fc[i][next_letter] = cumulative_cost

        for i in range(26):
            cumulative_cost = 0
            bc[i][i] = 0
            for k in range(1, 26):
                curr_letter = (i - k + 1) % 26
                next_letter = (i - k) % 26
                cumulative_cost += previousCost[curr_letter]
                bc[i][next_letter] = cumulative_cost

        total_cost = 0
        for i in range(len(s)):
            s_pos = ord(s[i]) - ord('a')
            t_pos = ord(t[i]) - ord('a')
            cost_forward = fc[s_pos][t_pos]
            cost_backward = bc[s_pos][t_pos]
            min_cost = min(cost_forward, cost_backward)
            total_cost += min_cost

        return total_cost
",1460801721
riyanshgargg,riyanshgargg,816,3625,python,"class Solution(object):
    def canAliceWin(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        stones_to_rem = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
        memo = {}

        def can_win(n, turn):
            if (n, turn) in memo:
                return memo[(n, turn)]
            if turn >= len(stones_to_rem):
                memo[(n, turn)] = False
                return False
            k = stones_to_rem[turn]
            if n < k:
                memo[(n, turn)] = False
                return False
            opponent_wins = can_win(n - k, turn + 1)
            memo[(n, turn)] = not opponent_wins
            return memo[(n, turn)]

        return can_win(n, 0)
",1460796973
abhikotikalapudi38,abhikotikalapudi38,817,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // Use long to handle larger sums
        int n = s.length();

        for (int i = 0; i < n; i++) {
            char source = s.charAt(i);
            char target = t.charAt(i);

            if (source == target) {
                // If the characters are the same, no cost is needed.
                continue;
            }

            int sourceIndex = source - 'a';
            int targetIndex = target - 'a';

            // Calculate forward (next) and backward (previous) shift distances
            int forwardShift = (targetIndex - sourceIndex + 26) % 26;
            int backwardShift = (sourceIndex - targetIndex + 26) % 26;

            // Calculate the costs for forward and backward shifts
            long forwardCost = 0;
            long backwardCost = 0;

            for (int j = 0; j < forwardShift; j++) {
                forwardCost += nextCost[(sourceIndex + j) % 26];
            }

            for (int j = 0; j < backwardShift; j++) {
                backwardCost += previousCost[(sourceIndex - j + 26) % 26];
            }

            // Add the minimum cost for this transformation to the total cost
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}",1460801732
abhikotikalapudi38,abhikotikalapudi38,817,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        // Alice's first move removes 10 stones. If n < 10, Alice cannot make a valid move and loses.
        if (n < 10) {
            return false;
        }
        
        int stonesToRemove = 10; // Number of stones removed by the first player (Alice initially).
        boolean isAliceTurn = true; // Track whose turn it is.

        while (n > 0) {
            if (n < stonesToRemove) {
                // If the remaining stones are fewer than the current removal amount,
                // the current player loses.
                return !isAliceTurn;
            }
            // Subtract the stones for the current turn.
            n -= stonesToRemove;

            // Decrease the number of stones to remove for the next turn.
            stonesToRemove--;

            // Switch turns.
            isAliceTurn = !isAliceTurn;
        }

        // If the game ends with n == 0, the last player to make a valid move wins.
        return !isAliceTurn;
    }
}",1460797085
Ankith Sharma A,ankitsumitsharma80,819,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;

        for (int i = 0; i < n; i++) {
            int start = s.charAt(i) - 'a';
            int end = t.charAt(i) - 'a';

            // Calculate forward and backward distances
            int forwardDistance = (end - start + 26) % 26;
            int backwardDistance = (start - end + 26) % 26;

            // Calculate forward cost
            long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(start + j) % 26];
            }

            // Calculate backward cost
            long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            // Add the minimum of the two costs
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}
",1460802092
Ankith Sharma A,ankitsumitsharma80,819,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        // Alice starts by trying to remove 10 stones
        int stonesToRemove = 10;
        boolean isAliceTurn = true;

        while (n > 0) {
            if (n >= stonesToRemove) {
                // Remove stones from the pile
                n -= stonesToRemove;
                stonesToRemove--; // Decrease stones to remove for the next turn
            } else {
                // If the player cannot remove the required stones, they lose
                return !isAliceTurn;
            }
            // Switch turns
            isAliceTurn = !isAliceTurn;
        }

        // If the loop exits, the last player who removed stones wins
        return !isAliceTurn;
    }
}
",1460796650
V Tarun Balaji,titan07,820,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';
            int target = t[i] - 'a';

            int forwardShift = (target - start + 26) % 26;
            int backwardShift = (start - target + 26) % 26;

            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < forwardShift; ++j) {
                forwardCost += nextCost[(start + j) % 26];
            }
            for (int j = 0; j < backwardShift; ++j) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460802102
V Tarun Balaji,titan07,820,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int str=10;
        while(n>=str){
            n-=str;
            str--;
        }
        return str%2==1;
    }
};",1460797179
Kartikey Pandey,kartikeyypandeyy,821,3591,java,"class Solution {
    public long shiftDistance(String sur, String tak, int[] aageCost, int[] peecheCost) {
        long kulKharcha = 0;
        int lambaai = sur.length();

        for (int i = 0; i < lambaai; i++) {
            char shurSe = sur.charAt(i);
            char takTak = tak.charAt(i);

            int surIndex = shurSe - 'a';
            int takIndex = takTak - 'a';

            int aageShift = (takIndex - surIndex + 26) % 26;
            int peecheShift = (surIndex - takIndex + 26) % 26;

            long aageWalaKharcha = 0, peecheWalaKharcha = 0;

            for (int j = 0; j < aageShift; j++) {
                aageWalaKharcha += aageCost[(surIndex + j) % 26];
            }

            for (int j = 0; j < peecheShift; j++) {
                peecheWalaKharcha += peecheCost[(surIndex - j + 26) % 26];
            }

            kulKharcha += Math.min(aageWalaKharcha, peecheWalaKharcha);
        }

        return kulKharcha;
    }
}
",1460802175
Kartikey Pandey,kartikeyypandeyy,821,3625,java,"class Solution {
    public boolean canAliceWin(int sankhya) {
        if (sankhya < 10) {
            return false;
        }

        int pattharHatao = 10;
        boolean kyaAliceKiBaari = true;

        while (sankhya > 0) {
            if (sankhya < pattharHatao) {
                return !kyaAliceKiBaari;
            }
            sankhya -= pattharHatao;
            pattharHatao--;
            kyaAliceKiBaari = !kyaAliceKiBaari;
        }

        return !kyaAliceKiBaari;
    }
}
",1460798799
Muhammad Hamza,Hamza_the_codar_786,822,3591,python,"class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        total_cost, n = 0, len(s)
        
        for i in range(n):
            start_char, target_char = s[i], t[i]
            
            if start_char == target_char: continue
            
            start_idx = ord(start_char) - ord('a')
            target_idx = ord(target_char) - ord('a')
            
            forward_steps = (target_idx - start_idx) % 26
            forward_cost = sum(nextCost[(start_idx + j) % 26] for j in range(forward_steps))
            
            backward_steps = (start_idx - target_idx) % 26
            backward_cost = sum(previousCost[(start_idx - j) % 26] for j in range(backward_steps))
            
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
",1460802343
Muhammad Hamza,Hamza_the_codar_786,822,3625,python,"class Solution(object):
    def canAliceWin(self, n):
        stones_to_remove = 10
        is_alice_turn = True
        
        while n > 0:
            if n < stones_to_remove: return not is_alice_turn
            
            n -= stones_to_remove
            stones_to_remove -= 1
            is_alice_turn = not is_alice_turn
        
        return not is_alice_turn",1460798784
Anand Tiwari,_brucewayne_,824,3591,cpp,"#include <bits/stdc++.h>
const int MOD = 1e9 + 7;
using namespace std;

class Solution
{
public:
    long long shiftDistance(string s, string t, vector<int> &nextCost, vector<int> &previousCost)
    {
        long long n = s.length();
        long long totalCost = 0;

        for (long long i = 0; i < n; ++i)
        {
            long long currentChar = s[i] - 'a';
            long long targetChar = t[i] - 'a';

            if (currentChar == targetChar)
                continue;

            long long forwardSteps = (targetChar - currentChar + 26) % 26;
            long long backwardSteps = (currentChar - targetChar + 26) % 26;

            long long forwardCost = 0, backwardCost = 0;

            for (long long j = 0; j < forwardSteps; ++j)
            {
                forwardCost += nextCost[(currentChar + j) % 26];
            }

            for (long long j = 0; j < backwardSteps; ++j)
            {
                backwardCost += previousCost[(currentChar - j + 26) % 26];
            }

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};

auto init = []()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return 0;
}();
",1460802379
Anand Tiwari,_brucewayne_,824,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10, cnt = 0;
        while(n >= remove) {
            n -= remove;
            remove--;
            cnt++;
            if (remove == 0) break;
        }
        if (cnt % 2) return true;
        return false;
    }
};",1460797422
prathamk002,prathamk002,825,3591,javascript,"/**
 * @param {string} s
 * @param {string} t
 * @param {number[]} nextCost
 * @param {number[]} previousCost
 * @return {number}
 */
var shiftDistance = function(s, t, nextCost, previousCost) {
    // Helper function to calculate minimum cost to transform one character to another
    const getMinCostForChar = (from, to) => {
        // Get ASCII values
        const fromCode = from.charCodeAt(0) - 97;  // 'a' is 97
        const toCode = to.charCodeAt(0) - 97;
        
        // Calculate steps needed in both directions
        let forwardSteps, backwardSteps;
        
        if (fromCode <= toCode) {
            forwardSteps = toCode - fromCode;
            backwardSteps = 26 - forwardSteps;
        } else {
            backwardSteps = fromCode - toCode;
            forwardSteps = 26 - backwardSteps;
        }
        
        // Calculate costs for both directions
        let forwardCost = 0;
        let currentChar = fromCode;
        for (let i = 0; i < forwardSteps; i++) {
            forwardCost += nextCost[currentChar];
            currentChar = (currentChar + 1) % 26;
        }
        
        let backwardCost = 0;
        currentChar = fromCode;
        for (let i = 0; i < backwardSteps; i++) {
            backwardCost += previousCost[currentChar];
            currentChar = (currentChar - 1 + 26) % 26;
        }
        
        // Return minimum of forward and backward costs
        return Math.min(forwardCost, backwardCost);
    };
    
    let totalCost = 0;
    
    // Process each character pair
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== t[i]) {
            totalCost += getMinCostForChar(s[i], t[i]);
        }
    }
    
    return totalCost;
};",1460802419
prathamk002,prathamk002,825,3625,javascript,"var canAliceWin = function(n) {
    if (n < 10) return false;
    
    let remainingStones = n;
    remainingStones -= 10;
    let stonesToRemove = 9;
    
    while (remainingStones > 0) {
        if (remainingStones < stonesToRemove) {
            return true;
        }
        remainingStones -= stonesToRemove;
        stonesToRemove--;
        
        if (stonesToRemove <= 0) break;
        
        if (remainingStones < stonesToRemove) {
            return false;
        }
        remainingStones -= stonesToRemove;
        stonesToRemove--;
        
        if (stonesToRemove <= 0) break;
    }
    
    return remainingStones === 0;
};",1460796148
Ansh Yadav,Bankai_10,826,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
         long long totalCost = 0;
    int n = s.length();

    for (int i = 0; i < n; ++i) {
        int currentIndex = s[i] - 'a';
        int targetIndex = t[i] - 'a';

        // Calculate forward and backward distances
        int forwardDist = (targetIndex - currentIndex + 26) % 26;
        int backwardDist = (currentIndex - targetIndex + 26) % 26;

        // Calculate forward and backward costs
        long long forwardCost = 0, backwardCost = 0;
        for (int j = 0; j < forwardDist; ++j) {
            forwardCost += nextCost[(currentIndex + j) % 26];
        }
        for (int j = 0; j < backwardDist; ++j) {
            backwardCost += previousCost[(currentIndex - j + 26) % 26];
        }

        // Add the minimum cost to the total
        totalCost += min(forwardCost, backwardCost);
    }

    return totalCost;
    }
};",1460802494
Ansh Yadav,Bankai_10,826,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
         int remove = 10; // Stones to remove initially
    bool isAliceTurn = true; // Keep track of whose turn it is

    while (n > 0) {
        if (n < remove) {
            // Current player cannot make a move, they lose
            return !isAliceTurn; // Alice wins if it's Bob's turn
        }
        n -= remove; // Remove stones
        remove--;    // Decrease the number of stones for the next turn
        isAliceTurn = !isAliceTurn; // Switch turns
    }

    return !isAliceTurn; // If no stones are left, return the winner
    }
};",1460799446
Lok,error_0802,827,3591,cpp,"#include <vector>
#include <string>
#include <queue>
#include <climits>

using namespace std;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        // Precompute minimal costs between all pairs of letters
        // There are 26 letters, indexed from 0 ('a') to 25 ('z')
        const int ALPHABET_SIZE = 26;
        vector<vector<long long>> costMatrix(ALPHABET_SIZE, vector<long long>(ALPHABET_SIZE, LLONG_MAX));
        
        for(int i = 0; i < ALPHABET_SIZE; ++i){
            // Dijkstra's algorithm for each starting letter
            vector<long long> dist(ALPHABET_SIZE, LLONG_MAX);
            dist[i] = 0;
            // Min-heap priority queue
            priority_queue<pair<long long, int>, vector<pair<long long, int>>, std::greater<pair<long long, int>>> pq;
            pq.emplace(0, i);
            
            while(!pq.empty()){
                auto [currentCost, u] = pq.top();
                pq.pop();
                
                if(currentCost > dist[u]) continue;
                
                // Shift to next letter
                int v = (u + 1) % ALPHABET_SIZE;
                long long newCost = currentCost + nextCost[u];
                if(newCost < dist[v]){
                    dist[v] = newCost;
                    pq.emplace(newCost, v);
                }
                
                // Shift to previous letter
                v = (u - 1 + ALPHABET_SIZE) % ALPHABET_SIZE;
                newCost = currentCost + previousCost[u];
                if(newCost < dist[v]){
                    dist[v] = newCost;
                    pq.emplace(newCost, v);
                }
            }
            
            // Store the computed distances
            for(int j = 0; j < ALPHABET_SIZE; ++j){
                costMatrix[i][j] = dist[j];
            }
        }
        
        long long totalCost = 0;
        int n = s.size();
        for(int i = 0; i < n; ++i){
            int from = s[i] - 'a';
            int to = t[i] - 'a';
            if(from == to){
                continue;
            }
            if(costMatrix[from][to] == LLONG_MAX){
                return -1;
            }
            totalCost += costMatrix[from][to];
        }
        
        return totalCost;
    }
};",1460802695
Lok,error_0802,827,3625,cpp,"class Solution {
public:
    bool determineWinner(int totalStones) {
        int remainingStones = totalStones;
        int currentMove = 10;  // Initial move is to remove 10 stones
        bool isFirstPlayerTurn = true;  // First player (Alice) starts

        while (true) {
            if (remainingStones >= currentMove) {
                remainingStones -= currentMove;
                currentMove--;
                isFirstPlayerTurn = !isFirstPlayerTurn; // Switch turns
                
                if (currentMove <= 0) {
                    // If the move becomes zero or negative, the current player wins
                    return !isFirstPlayerTurn;
                }
            } else {
                // The current player cannot make the move
                return !isFirstPlayerTurn; // The opponent wins
            }
        }
    }

    bool canAliceWin(int totalStones) {
        // Alice wins if she is the one who can make the final move
        return determineWinner(totalStones);
    }
};
",1460796688
5nEdguHCeH,5nEdguHCeH,828,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        
        long long tc = 0;
        int n = s.length();
   
        for (int i = 0; i < n; i++) {
            char source = s[i];
            char target = t[i];
    
            if (source == target) continue;
            
            int fd = 0;
            int bd = 0;
            long long forwardCost = 0;
            long long backwardCost = 0;
     
            char temp = source;
            while (temp != target) {
                fd++;
                forwardCost += nextCost[temp - 'a'];
                temp++;
                if (temp > 'z') temp = 'a';
            }
        
            temp = source;
            while (temp != target) {
                bd++;
                backwardCost += previousCost[temp - 'a'];
                temp--;
                if (temp < 'a') temp = 'z';
            }
    
            tc += min(forwardCost, backwardCost);
        }
        
        return tc;
    }
};",1460802785
5nEdguHCeH,5nEdguHCeH,828,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) {
            return false;
        }
        
        int remainingStones = n - 10;
        
        
        if (remainingStones < 9) {
            return true;
        }
        
        remainingStones -= 9;
 
        if (remainingStones < 8) {
            return false; 
        }
        
        remainingStones -= 8;
       
        if (remainingStones < 7) {
            return true; 
        } 
        remainingStones -= 7;
        if (remainingStones < 6) {
            return false;
        }
        
        remainingStones -= 6;
        
        if (remainingStones < 5) {
            return true; 
        }
        
        remainingStones -= 5;
        
        if (remainingStones < 4) {
            return false;
        }
        
        remainingStones -= 4;
       
        if (remainingStones < 3) {
            return true; 
        }
        
        remainingStones -= 3;
   
        if (remainingStones < 2) {
            return false;  
        }
        
        remainingStones -= 2;
        
        if (remainingStones < 1) {
            return true;
        }
        
        remainingStones -= 1;
       return remainingStones == 0;
    }
};",1460797355
Shivang,Shivangjindal,829,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;

        for (int i = 0; i < s.length(); i++) {
            int currentChar = s[i] - 'a';
            int targetChar = t[i] - 'a';
    
            // Calculate forward distance and cost
            int forwardDistance = (targetChar - currentChar + 26) % 26;
            long long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(currentChar + j) % 26];
            }
    
            // Calculate backward distance and cost
            int backwardDistance = (currentChar - targetChar + 26) % 26;
            long long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(currentChar - j + 26) % 26];
            }
    
            // Choose the minimum cost for this transformation
            totalCost += min(forwardCost, backwardCost);
        }
    
        return totalCost;
    }
};",1460802857
Shivang,Shivangjindal,829,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10; // Alice starts by removing 10 stones
        bool aliceTurn = true;  // True if it's Alice's turn, False if it's Bob's turn
    
        while (n > 0) {
            if (n < stonesToRemove) {
                // Current player cannot make a move
                return !aliceTurn; // If it's Alice's turn, Bob wins; otherwise, Alice wins
            }
    
            n -= stonesToRemove;   // Remove stones
            stonesToRemove--;      // Decrease the number of stones for the next turn
            aliceTurn = !aliceTurn; // Switch turns
        }
    
        // If we reach here, the game ends with the last player making a valid move winning
        return !aliceTurn;
    }
};",1460798472
vanshika singh18,vanshikajan18,830,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            int startChar = s[i] - 'a';
            int targetChar = t[i] - 'a';

            // Forward and backward distances
            int forwardDist = (targetChar - startChar + 26) % 26;
            int backwardDist = (startChar - targetChar + 26) % 26;

            // Forward and backward costs
            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < forwardDist; ++j) {
                forwardCost += nextCost[(startChar + j) % 26];
            }
            for (int j = 0; j < backwardDist; ++j) {
                backwardCost += previousCost[(startChar - j + 26) % 26];
            }

            // Add the minimum of the two costs
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460803017
vanshika singh18,vanshikajan18,830,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10; // Initial stones Alice removes
        bool isAliceTurn = true; // Tracks whose turn it is

        while (n > 0) {
            if (n < stonesToRemove) {
                // Current player cannot make the move
                return !isAliceTurn; // The opponent wins
            }
            n -= stonesToRemove; // Remove stones
            stonesToRemove--;    // Decrease the number of stones to remove
            isAliceTurn = !isAliceTurn; // Switch turns
        }

        // If we exit the loop, the last player to make a move wins
        return !isAliceTurn; // Alice wins if it's Bob's turn when the game ends
    }
};
",1460799350
datta81069,datta81069,831,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;

        for (int i = 0; i < n; i++) {
            char sChar = s.charAt(i);
            char tChar = t.charAt(i);
            
            int sIndex = sChar - 'a';
            int tIndex = tChar - 'a';
            
            long nextShiftCost = calculateNextShiftCost(sIndex, tIndex, nextCost);
            long prevShiftCost = calculatePrevShiftCost(sIndex, tIndex, previousCost);

            totalCost += Math.min(nextShiftCost, prevShiftCost);
        }

        return totalCost;
    }

    private long calculateNextShiftCost(int startIndex, int endIndex, int[] nextCost) {
        long cost = 0;
        while (startIndex != endIndex) {
            cost += nextCost[startIndex];
            startIndex = (startIndex + 1) % 26;
        }
        return cost;
    }

    private long calculatePrevShiftCost(int startIndex, int endIndex, int[] previousCost) {
        long cost = 0;
        while (startIndex != endIndex) {
            cost += previousCost[startIndex];
            startIndex = (startIndex - 1 + 26) % 26;
        }
        return cost;
    }
}
",1460803052
datta81069,datta81069,831,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int stonesToRemove = 10; // Alice's first move
        boolean isAliceTurn = true; // Alice starts first

        while (n > 0) {
            if (n < stonesToRemove) {
                return !isAliceTurn; // The current player loses
            }
            n -= stonesToRemove;
            stonesToRemove--;
            isAliceTurn = !isAliceTurn; // Switch turn
        }

        return !isAliceTurn; // The last player who made a valid move wins
    }
}
",1460799144
Pratyush Raman,therealpratyushraman,832,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        int N = 26;
        long[][] dist = new long[N][N];
        long INF = Long.MAX_VALUE / 2;

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                dist[i][j] = INF;
            }
            dist[i][i] = 0;
            dist[i][(i + 1) % N] = nextCost[i];
            dist[i][(i - 1 + N) % N] = previousCost[i];
        }

        for (int k = 0; k < N; k++) {
            for (int i = 0; i < N; i++) {
                if (dist[i][k] == INF) continue;
                for (int j = 0; j < N; j++) {
                    if (dist[k][j] == INF) continue;
                    long newDist = dist[i][k] + dist[k][j];
                    if (dist[i][j] > newDist) {
                        dist[i][j] = newDist;
                    }
                }
            }
        }

        long total = 0;
        for (int i = 0; i < n; i++) {
            int from = s.charAt(i) - 'a';
            int to = t.charAt(i) - 'a';
            total += dist[from][to];
        }
        return total;
    }
}
",1460803179
Pratyush Raman,therealpratyushraman,832,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        boolean[][] dp = new boolean[51][11];
        for (int stones = 1; stones <= n; stones++) {
            for (int k = 1; k <= 10; k++) {
                if (k > stones) dp[stones][k] = false;
                else if (k - 1 == 0) dp[stones][k] = true;
                else dp[stones][k] = !dp[stones - k][k - 1];
            }
        }
        return dp[n][10];
    }
}
",1460797763
Neelima Sanapathi,neelimaaa,833,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
            total_cost = 0
            n = len(s)
        
            for i in range(n):
                # Calculate character indices
                si = ord(s[i]) - ord('a')
                ti = ord(t[i]) - ord('a')
                
                # Forward and backward distances
                forward_distance = (ti - si + 26) % 26
                backward_distance = (si - ti + 26) % 26
                
                # Calculate costs
                forward_cost = sum(nextCost[(si + j) % 26] for j in range(forward_distance))
                backward_cost = sum(previousCost[(si - j + 26) % 26] for j in range(backward_distance))
                
                # Add the minimal cost to total
                total_cost += min(forward_cost, backward_cost)
            
            return total_cost
            ",1460803279
Neelima Sanapathi,neelimaaa,833,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False
        
        stones_to_remove = 10  # Alice starts by removing 10 stones
        alice_turn = True  # True if it's Alice's turn, False for Bob's turn
        
        while n > 0:
            if n < stones_to_remove:  # If the current player cannot remove stones
                return not alice_turn  # Return False if it's Alice's turn, True otherwise
            
            n -= stones_to_remove
            stones_to_remove -= 1
            alice_turn = not alice_turn  # Toggle the turn
            
        return not alice_turn
",1460798340
sai pradyothan vitta,vittasai05,834,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // Initialize the total cost
        int n = s.length(); // Length of the strings

        // Iterate through each character in strings s and t
        for (int i = 0; i < n; i++) {
            char startChar = s.charAt(i);
            char targetChar = t.charAt(i);

            // Calculate the positions of the characters in the alphabet (0-indexed)
            int startIndex = startChar - 'a';
            int targetIndex = targetChar - 'a';

            // Compute the distance in the forward (next) direction
            int forwardSteps = (targetIndex - startIndex + 26) % 26;
            long forwardCost = 0;
            for (int step = 0, curr = startIndex; step < forwardSteps; step++) {
                forwardCost += nextCost[curr];
                curr = (curr + 1) % 26;
            }

            // Compute the distance in the backward (previous) direction
            int backwardSteps = (startIndex - targetIndex + 26) % 26;
            long backwardCost = 0;
            for (int step = 0, curr = startIndex; step < backwardSteps; step++) {
                backwardCost += previousCost[curr];
                curr = (curr - 1 + 26) % 26;
            }

            // Add the minimum of forwardCost and backwardCost to totalCost
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost; // Return the total cost
    }
}
",1460803280
sai pradyothan vitta,vittasai05,834,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        // Alice cannot play if the number of stones is less than 10
        if (n < 10) return false;

        // Initialize variables for Alice's and Bob's turns
        int stonesToRemove = 10; // Alice starts by removing 10 stones
        boolean isAliceTurn = true; // Keep track of whose turn it is

        while (n > 0) {
            if (n < stonesToRemove) {
                // If the remaining stones are fewer than what needs to be removed
                return !isAliceTurn; // The current player loses
            }
            // Subtract the stones and switch turns
            n -= stonesToRemove;
            stonesToRemove--; // Each subsequent turn requires removing 1 fewer stone
            isAliceTurn = !isAliceTurn; // Switch turns
        }

        // If the loop exits, the last player lost
        return !isAliceTurn;
    }
}
",1460798204
DINOSAUR,ReddyMAN_Codes,835,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        def char_index(c):
            return ord(c) - ord('a')
    
        total_cost = 0
        n = len(s)
        
        for i in range(n):
            current_char_index = char_index(s[i])
            target_char_index = char_index(t[i])
            
            # Calculate the forward shift distance and cost
            if current_char_index <= target_char_index:
                forward_steps = target_char_index - current_char_index
            else:
                forward_steps = 26 - (current_char_index - target_char_index)
            forward_cost = sum(nextCost[(current_char_index + step) % 26] for step in range(forward_steps))
            
            # Calculate the backward shift distance and cost
            if current_char_index >= target_char_index:
                backward_steps = current_char_index - target_char_index
            else:
                backward_steps = 26 - (target_char_index - current_char_index)
            backward_cost = sum(previousCost[(current_char_index - step) % 26] for step in range(backward_steps))
            
            # Add the minimum cost of the two options to the total cost
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost",1460803311
DINOSAUR,ReddyMAN_Codes,835,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones_to_remove = 10
    
        while n > 0:
            # If it's Alice's turn and she can't make a move, Bob wins
            if n < stones_to_remove:
                return False
            n -= stones_to_remove
            
            # Reduce the stones to remove for the next turn
            stones_to_remove -= 1
            
            # If it's Bob's turn and he can't make a move, Alice wins
            if n < stones_to_remove:
                return True
            n -= stones_to_remove
            
            # Reduce the stones to remove for the next turn
            stones_to_remove -= 1
    
        # If no stones are left, Alice loses
        return False",1460796948
jaydip001,jaydip001,836,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a'; 
            int target = t[i] - 'a'; 
            int forwardSteps = (target - start + 26) % 26; 
            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(start + j) % 26];
            }
            int backwardSteps = (start - target + 26) % 26; 
            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};",1460803315
jaydip001,jaydip001,836,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0;
        int stonesToRemove = 10; 
        
        while (n > 0) {
            if (n < stonesToRemove) {
                return turn == 1; 
            }
            n -= stonesToRemove; 
            stonesToRemove--; 
            turn = 1 - turn; 
        }
        
        return turn == 1; 
    }
};
",1460797932
VIKRANT SHARMA,vikrant162003,837,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;

        for (int i = 0; i < n; i++) {
            int from = s.charAt(i) - 'a';
            int to = t.charAt(i) - 'a';

            // Calculate forward and backward distances
            int forwardDistance = (to - from + 26) % 26;
            int backwardDistance = (from - to + 26) % 26;

            // Compute the cost for forward shift
            long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(from + j) % 26];
            }

            // Compute the cost for backward shift
            long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(from - j + 26) % 26];
            }

            // Add the minimum cost for this transformation
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}",1460803572
VIKRANT SHARMA,vikrant162003,837,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int stonesToRemove = 10;
        // Determine whose turn it is (true: Alice, false: Bob)
        boolean isAliceTurn = true;

        while (n > 0) {
            if (n < stonesToRemove) {
                // Current player cannot remove the required stones
                return !isAliceTurn;
            }
            // Update the remaining stones and the stones to remove next turn
            n -= stonesToRemove;
            stonesToRemove -= 1;
            // Alternate turns
            isAliceTurn = !isAliceTurn;
        }

        // If the loop ends naturally, return the result
        return !isAliceTurn;
    }
}",1460799549
Yashank Singh,YashankSingh,838,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n = len(s)
        total_cost = 0
    
        for i in range(n):
            si = ord(s[i]) - ord('a')
            ti = ord(t[i]) - ord('a')
            if si <= ti:
                clockwise_cost = sum(nextCost[(si + j) % 26] for j in range(ti - si))
                counter_cost = sum(previousCost[(si - j) % 26] for j in range(26 - (ti - si)))
            else:
                clockwise_cost = sum(nextCost[(si + j) % 26] for j in range(26 - (si - ti)))
                counter_cost = sum(previousCost[(si - j) % 26] for j in range(si - ti))
            total_cost += min(clockwise_cost, counter_cost)
    
        return total_cost",1460803623
Yashank Singh,YashankSingh,838,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False

        moves = 10
        turn = 0
        while n >= moves:
            n -= moves
            moves -= 1
            turn += 1
           
        return turn % 2 == 1",1460798949
riri-2k3,riri-2k3,839,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
    int n = s.length();

    for (int i = 0; i < n; i++) {
        int start = s[i] - 'a';  
        int target = t[i] - 'a';
        
        int forwardShifts = (target - start + 26) % 26;
        long long forwardCost = 0;
        for (int j = 0; j < forwardShifts; j++) {
            forwardCost += nextCost[(start + j) % 26];
        }
        
        int backwardShifts = (start - target + 26) % 26;
        long long backwardCost = 0;
        for (int j = 0; j < backwardShifts; j++) {
            backwardCost += previousCost[(start - j + 26) % 26];
        }
        
        totalCost += min(forwardCost, backwardCost);
    }
    
    return totalCost;
    }
};",1460803801
riri-2k3,riri-2k3,839,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 10;
    bool isAliceTurn = true;
    
    while (n > 0) {
        if (n < turn) {
            return !isAliceTurn;
        }
        n -= turn;
        turn--;
        isAliceTurn = !isAliceTurn;
    }
    
    return !isAliceTurn;
    }
};",1460797336
Manasa_1012,Manasa_1012,841,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // Initialize total cost
        
        // Iterate through each character in the strings
        for (int i = 0; i < s.length(); i++) {
            char sc = s.charAt(i); // Current character in s
            char tc = t.charAt(i); // Target character in t
            
            int startIdx = sc - 'a'; // Alphabet index of sc
            int endIdx = tc - 'a';   // Alphabet index of tc
            
            // Forward shift (clockwise)
            int forwardSteps = (endIdx - startIdx + 26) % 26;
            long forwardCost = 0;
            int current = startIdx;
            for (int step = 0; step < forwardSteps; step++) {
                forwardCost += nextCost[current];
                current = (current + 1) % 26; // Move to next letter
            }
            
            // Backward shift (counterclockwise)
            int backwardSteps = (startIdx - endIdx + 26) % 26;
            long backwardCost = 0;
            current = startIdx;
            for (int step = 0; step < backwardSteps; step++) {
                backwardCost += previousCost[current];
                current = (current - 1 + 26) % 26; // Move to previous letter
            }
            
            // Add the minimum of the two costs to the total cost
            totalCost += Math.min(forwardCost, backwardCost);
        }
        
        return totalCost; // Return the total minimum cost
    }
}
",1460804433
Manasa_1012,Manasa_1012,841,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        // Alice starts removing 10 stones
        int stonesToRemove = 10;
        boolean isAliceTurn = true; // Alice starts first
        
        while (n > 0) {
            // If the current player cannot remove the required stones, they lose
            if (stonesToRemove > n) {
                return !isAliceTurn; // The other player wins
            }
            // Remove the stones
            n -= stonesToRemove;
            // Decrease the number of stones to remove for the next turn
            stonesToRemove--;
            // Switch turns
            isAliceTurn = !isAliceTurn;
        }
        // If the loop exits, the last player to make a move wins
        return !isAliceTurn; // The other player wins
    }
}
",1460796062
Rajan kumar,prajapati93,842,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            char currentChar = s.charAt(i);
            char targetChar = t.charAt(i);
            
            if (currentChar == targetChar) {
                // No cost if characters are already the same
                continue;
            }
            
            int currentIndex = currentChar - 'a';
            int targetIndex = targetChar - 'a';
            
            // Calculate forward shift cost
            int forwardShift = (targetIndex - currentIndex + 26) % 26; // Wrap around alphabet
            long forwardCost = 0;
            for (int j = 0; j < forwardShift; j++) {
                forwardCost += nextCost[(currentIndex + j) % 26];
            }
            
            // Calculate backward shift cost
            int backwardShift = (currentIndex - targetIndex + 26) % 26; // Wrap around alphabet
            long backwardCost = 0;
            for (int j = 0; j < backwardShift; j++) {
                backwardCost += previousCost[(currentIndex - j + 26) % 26];
            }
            
            // Add the minimum of the two costs to the total cost
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost;
    }
}
",1460804505
Rajan kumar,prajapati93,842,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int stonesToRemove = 10;  // Initial stones Alice removes
        boolean isAliceTurn = true;  // Start with Alice's turn

        while (n > 0) {
            if (stonesToRemove > n) {
                // If the current player cannot make a valid move
                return !isAliceTurn;
            }
            n -= stonesToRemove;  // Remove stones
            stonesToRemove--;  // Decrease stones to remove in the next turn
            isAliceTurn = !isAliceTurn;  // Switch turns
        }

        // If we exit the loop, it means one of the players lost
        return !isAliceTurn;  // Return true if Alice won
    }
}
",1460801464
Aradhya teharia,teharia__aradhya,843,3591,csharp,"public class Solution {
    public long ShiftDistance(string s, string t, int[] nextCost, int[] previousCost) {
        long res = 0;

        for (int i = 0; i < s.Length; i++) {
            int a = s[i] - 'a';
            int b = t[i] - 'a';
            res += CalcMinCost(a, b, nextCost, previousCost);
        }

        return res;
    }

    private long CalcMinCost(int a, int b, int[] nextCost, int[] previousCost) {
        int f = (b - a + 26) % 26;
        int r = (a - b + 26) % 26;

        long fCost = 0, rCost = 0;
        for (int j = 0; j < f; j++) fCost += nextCost[(a + j) % 26];
        for (int j = 0; j < r; j++) rCost += previousCost[(a - j + 26) % 26];

        return Math.Min(fCost, rCost);
    }
}
",1460804564
Aradhya teharia,teharia__aradhya,843,3625,csharp,"public class Solution {
    public bool CanAliceWin(int n) {
        return Helper(n, 10, true);
    }

    private bool Helper(int x, int y, bool t) {
        if (x < y) return !t;
        return Helper(x - y, y - 1, !t);
    }
}
",1460800059
Prakhar_2000,Prakhar_2000,844,3591,cpp,"// class Solution {
// public:
//     long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        
//     }
// };
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();

        for (int i = 0; i < n; ++i) {
            int startCharIndex = s[i] - 'a';
            int targetCharIndex = t[i] - 'a';

            if (startCharIndex == targetCharIndex) continue;

            int forwardSteps = (targetCharIndex - startCharIndex + 26) % 26;
            int backwardSteps = (startCharIndex - targetCharIndex + 26) % 26;

            long long forwardCost = 0, backwardCost = 0;

            for (int step = 0; step < forwardSteps; ++step) {
                int idx = (startCharIndex + step) % 26;
                forwardCost += nextCost[idx];
            }

            for (int step = 0; step < backwardSteps; ++step) {
                int idx = (startCharIndex - step + 26) % 26;
                backwardCost += previousCost[idx];
            }

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460804684
Prakhar_2000,Prakhar_2000,844,3625,cpp,"// class Solution {
// public:
//     bool canAliceWin(int n) {
        
//     }
// };
class Solution {
public:
    bool canAliceWin(int n) {
        int currentStones = 10;
        bool isAliceTurn = true;

        while (n > 0) {
            if (n < currentStones) {
                return !isAliceTurn;
            }

            n -= currentStones;
            currentStones--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
};
",1460800430
vitrus,veeanora989,845,3591,c,"int getForwardDistance(char from, char to) {
    if (from <= to) {
        return to - from;
    }
    return (26 - (from - to));
}

int getBackwardDistance(char from, char to) {
    if (from >= to) {
        return from - to;
    }
    return from + (26 - to);
}

long long shiftDistance(char* s, char* t, int* nextCost, int nextCostSize, 
                       int* previousCost, int previousCostSize) {
    long long totalCost = 0;
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        if (s[i] == t[i]) {
            continue;
        }
        long long forwardCost = 0;
        int forwardSteps = getForwardDistance(s[i], t[i]);
        char curr = s[i];
        for (int step = 0; step < forwardSteps; step++) {
            int idx = curr - 'a';
            forwardCost += nextCost[idx];
            curr++;
            if (curr > 'z') {
                curr = 'a';
            }
        }
        long long backwardCost = 0;
        int backwardSteps = getBackwardDistance(s[i], t[i]);
        curr = s[i];
        for (int step = 0; step < backwardSteps; step++) {
            int idx = curr - 'a';
            backwardCost += previousCost[idx];
            curr--;
            if (curr < 'a') {
                curr = 'z';
            }
        }
        totalCost += (forwardCost < backwardCost) ? forwardCost : backwardCost;
    }
    return totalCost;
}",1460804736
vitrus,veeanora989,845,3625,c,"bool canAliceWin(int n) {
    if (n < 10) {
        return false;
    }
    int remaining = n - 10;
    if (remaining < 9) {
        return true;
    }
    remaining -= 9;
    if (remaining < 8) {
        return false;
    }
    remaining -= 8;
    if (remaining < 7) {
        return true;
    }
    remaining -= 7;
    if (remaining < 6) {
        return false;
    }
    remaining -= 6;
    if (remaining < 5) {
        return true;
    }
    remaining -= 5;

    if (remaining < 4) {
        return false;
    }
    remaining -= 4;
    if (remaining < 3) {
        return true;
    }
    remaining -= 3;

    if (remaining < 2) {
        return false;
    }
    remaining -= 2;
    if (remaining < 1) {
        return true;
    }
    remaining -= 1;
    return false;
}",1460801292
jainmohit_74,jainmohit_74,846,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';
            int target = t[i] - 'a';

            int forwardSteps = (target - start + 26) % 26;
            int backwardSteps = (start - target + 26) % 26;

            long long forwardCost = 0, backwardCost = 0;

            for (int step = 0, idx = start; step < forwardSteps; ++step) {
                forwardCost += nextCost[idx];
                idx = (idx + 1) % 26;
            }

            for (int step = 0, idx = start; step < backwardSteps; ++step) {
                backwardCost += previousCost[idx];
                idx = (idx - 1 + 26) % 26;
            }

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460804849
jainmohit_74,jainmohit_74,846,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentMove = 10;
        bool isAliceTurn = true;

        while (n > 0) {
            if (n < currentMove) return !isAliceTurn;
            n -= currentMove;
            currentMove--;
            isAliceTurn = !isAliceTurn;
        }

    return !isAliceTurn;
        
    }
};",1460798231
khushigu5ain,khushigu5ain,847,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();

        for (int i = 0; i < n; ++i) {
            char start = s[i];
            char target = t[i];

            // Calculate forward and backward shifts
            int forwardShifts = (target - start + 26) % 26; // Distance moving forward in the alphabet
            int backwardShifts = (start - target + 26) % 26; // Distance moving backward in the alphabet

            // Calculate forward shift cost
            long long forwardCost = 0;
            for (int j = 0; j < forwardShifts; ++j) {
                forwardCost += nextCost[(start - 'a' + j) % 26];
            }

            // Calculate backward shift cost
            long long backwardCost = 0;
            for (int j = 0; j < backwardShifts; ++j) {
                backwardCost += previousCost[(start - 'a' - j + 26) % 26];
            }

            // Add the minimum cost to the total cost
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460804869
khushigu5ain,khushigu5ain,847,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
       
        if (n < 10) return false;

        int remainingStones = n - 10; 
        int turn = 9; 

        while (remainingStones >= 0) {
            if (remainingStones < turn) {
                
                return true;
            }
            remainingStones -= turn;
            turn--; 

            if (remainingStones < turn) {
                return false; 
            }
            remainingStones -= turn;
            turn--;
        }

        return false; 
    }
};
",1460798874
Bhaveshpareta,Bhaveshpareta,848,3591,python3,"from typing import List

class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
        n = len(s)
        
        for i in range(n):
            # Current characters in s and t
            char_s = s[i]
            char_t = t[i]
            
            # Indices of the characters in the alphabet
            index_s = ord(char_s) - ord('a')
            index_t = ord(char_t) - ord('a')
            
            # Calculate forward distance and cost
            forward_distance = (index_t - index_s) % 26
            forward_cost = sum(nextCost[(index_s + j) % 26] for j in range(forward_distance))
            
            # Calculate backward distance and cost
            backward_distance = (index_s - index_t) % 26
            backward_cost = sum(previousCost[(index_s - j) % 26] for j in range(backward_distance))
            
            # Add the minimum of forward or backward cost
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
",1460804983
Bhaveshpareta,Bhaveshpareta,848,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        # Initialize the game
        move = 10  # Alice starts with removing 10 stones
        isAliceTurn = True  # Track whose turn it is
        remaining = n  # Remaining stones
        
        while remaining > 0:
            if move > remaining:
                # If the current move cannot be made, the current player loses
                return not isAliceTurn  # Alice wins if it's Bob's turn, and vice versa
            
            # Make the move
            remaining -= move
            
            # Update the move for the next player
            move -= 1
            isAliceTurn = not isAliceTurn  # Alternate turns
        
        return not isAliceTurn  # If the loop exits, Alice's turn determines the winner
",1460801135
Aryan Dhaka,aryan_dhaka_1308,849,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        
        for (int i = 0; i < s.length(); i++) {
            char src = s.charAt(i);
            char target = t.charAt(i);
            
            int forward = (target - src + 26) % 26;
            int backward = (src - target + 26) % 26;
            
            long minCost = getMinCost(src - 'a', forward, backward, nextCost, previousCost);
            totalCost += minCost;
        }
        
        return totalCost;
    }
    
    private long getMinCost(int startPos, int forward, int backward, int[] nextCost, int[] previousCost) {
        long forwardCost = 0;
        int pos = startPos;
        for (int i = 0; i < forward; i++) {
            forwardCost += nextCost[pos];
            pos = (pos + 1) % 26;
        }
        
        long backwardCost = 0;
        pos = startPos;
        for (int i = 0; i < backward; i++) {
            backwardCost += previousCost[pos];
            pos = (pos - 1 + 26) % 26;
        }
        
        return Math.min(forwardCost, backwardCost);
    }
}",1460805172
Aryan Dhaka,aryan_dhaka_1308,849,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10) {
            return false;
        }
        
        int remaining = n;
        int nextMove = 10;  
        boolean isAliceTurn = true;
        
        while (remaining > 0) {
            if (remaining < nextMove) {
                return !isAliceTurn;  
            }
            
            remaining -= nextMove;
            if (remaining == 0) {
                return isAliceTurn;  
            }
            
            nextMove--;  
            isAliceTurn = !isAliceTurn;
        }
        
        return false;  
    }
}",1460801367
SHREYAKUMARI0911,SHREYAKUMARI0911,850,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0; 
        int n = s.length();
        
        for (int i = 0; i < n; ++i) {
            char source = s[i];
            char target = t[i];
            
            int srcIndex = source - 'a';
            int tgtIndex = target - 'a'; 
            
            int forwardSteps = (tgtIndex - srcIndex + 26) % 26;
            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(srcIndex + j) % 26];
            }
            
          
            int backwardSteps = (srcIndex - tgtIndex + 26) % 26; 
            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(srcIndex - j + 26) % 26];
            }
            
            
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
        
    }
};",1460805184
SHREYAKUMARI0911,SHREYAKUMARI0911,850,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentTurn = 10; 
        bool isAliceTurn = true;

        while (n > 0) {
            if (n < currentTurn) {
               
                return !isAliceTurn;
            }
            n -= currentTurn; 
            currentTurn--;    
            isAliceTurn = !isAliceTurn; 
        }

        return !isAliceTurn;
        
    }
};",1460798482
Aditi_124,Aditi_124,851,3591,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            // Alphabet indices
            int startIndex = s[i] - 'a';
            int targetIndex = t[i] - 'a';

            // Calculate forward and backward steps
            int forwardSteps = (targetIndex - startIndex + 26) % 26;
            int backwardSteps = (startIndex - targetIndex + 26) % 26;

            // Calculate forward and backward costs for current index
            long long forwardCost = 0;
            for (int step = 0; step < forwardSteps; ++step) {
                forwardCost += nextCost[(startIndex + step) % 26];
            }

            long long backwardCost = 0;
            for (int step = 0; step < backwardSteps; ++step) {
                backwardCost += previousCost[(startIndex - step + 26) % 26];
            }

            // Add the minimum of forward and backward costs
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460805285
Aditi_124,Aditi_124,851,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int current_stones_to_remove = 10; // Alice starts with 10 stones
        bool isAliceTurn = true;          // Track whose turn it is

        while (n > 0) {
            if (n >= current_stones_to_remove) {
                n -= current_stones_to_remove;
                current_stones_to_remove--; // Decrease the stones to remove on the next turn
                isAliceTurn = !isAliceTurn; // Switch turns
            } else {
                // The current player cannot make a move
                break;
            }
        }

        // If it's not Alice's turn, she made the last move and won
        return !isAliceTurn;
    }
};
",1460797264
Shubham Singh,rshubham1,852,3591,javascript,"/**
 * @param {string} s
 * @param {string} t
 * @param {number[]} nextCost
 * @param {number[]} previousCost
 * @return {number}
 */
var shiftDistance = function(s, t, nextCost, previousCost) {
    let n = s.length;
    let totalCost = 0;

    for (let i = 0; i < n; i++) {
        let startChar = s.charCodeAt(i) - 97;
        let targetChar = t.charCodeAt(i) - 97;
        let forwardShift = (targetChar - startChar + 26) % 26;
        let backwardShift = (startChar - targetChar + 26) % 26;
        let forwardCost = forwardShift === 0 ? 0 : Array.from({ length: forwardShift }, (_, idx) => nextCost[(startChar + idx) % 26]).reduce((a, b) => a + b, 0);
        let backwardCost = backwardShift === 0 ? 0 : Array.from({ length: backwardShift }, (_, idx) => previousCost[(startChar - idx + 26) % 26]).reduce((a, b) => a + b, 0);

        totalCost += Math.min(forwardCost, backwardCost);
    }

    return totalCost;
    
};",1460805314
Shubham Singh,rshubham1,852,3625,javascript,"/**
 * @param {number} n
 * @return {boolean}
 */
var canAliceWin = function(n) {
    let turn = 0, stonesToRemove = 10;
    while (n > 0) {
        if (n < stonesToRemove) return turn === 1;
        n -= stonesToRemove;
        stonesToRemove--;
        turn = 1 - turn;
    }
    return turn === 1;
};",1460799661
Rasad Regmi,rasadregmi,853,3591,python,"class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        """"""
        :type s: str
        :type t: str
        :type nextCost: List[int]
        :type previousCost: List[int]
        :rtype: int
        """"""

        n = len(s)
        total_cost = 0
        
        for i in range(n):
            char_s = s[i]
            char_t = t[i]
            index_s = ord(char_s) - ord('a')
            index_t = ord(char_t) - ord('a')
            
            clockwise_distance = (index_t - index_s) % 26
            clockwise_cost = sum(nextCost[(index_s + j) % 26] for j in range(clockwise_distance))
            
            counterclockwise_distance = (index_s - index_t) % 26
            counterclockwise_cost = sum(previousCost[(index_s - j) % 26] for j in range(counterclockwise_distance))
            
            total_cost += min(clockwise_cost, counterclockwise_cost)
        
        return total_cost",1460805319
Rasad Regmi,rasadregmi,853,3625,python,"class Solution(object):
    def canAliceWin(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        stones_to_remove = 10  
        alice_turn = True      
        
        while n > 0:
            if n < stones_to_remove:
                return not alice_turn 
            n -= stones_to_remove
            stones_to_remove -= 1
            alice_turn = not alice_turn  
            
        return not alice_turn",1460801984
vishal,VK8,854,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; ++i) {
            int start = s[i] - 'a';
            int end = t[i] - 'a';

            // Calculate forward shift cost
            int forwardSteps = (end - start + 26) % 26;
            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(start + j) % 26];
            }

            // Calculate backward shift cost
            int backwardSteps = (start - end + 26) % 26;
            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            // Add the minimum cost for this index
            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460805380
vishal,VK8,854,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {

        if (n < 10) return false;

        int stonesToRemove = 10; 
        bool isAliceTurn = true; 

        while (n > 0) {
            if (n < stonesToRemove) {

                return !isAliceTurn; 
            }
            n -= stonesToRemove; 
            stonesToRemove--;    
            isAliceTurn = !isAliceTurn; 
        }

        return !isAliceTurn; 
    }
};
",1460803152
Ujjwal Bharti,UjjwalBharti13,855,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        long long l = s.length(), c = 0;

    for (long long i = 0; i < l; ++i) {
        long long a = s[i] - 'a';
        long long b = t[i] - 'a';

        long long f = (b - a + 26) % 26, fc = 0;
        for (long long j = 0, x = a; j < f; ++j) {
            fc += n[x];
            x = (x + 1) % 26;
        }

        long long r = (a - b + 26) % 26, rc = 0;
        for (long long j = 0, x = a; j < r; ++j) {
            rc += p[x];
            x = (x - 1 + 26) % 26;
        }

        c += min(fc, rc);
    }

    return c;
    }
};",1460805833
Ujjwal Bharti,UjjwalBharti13,855,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
         int stonesToRemove = 10; // Alice starts by removing 10 stones.
    bool isAliceTurn = true; // Alice starts the game.

    while (n > 0) {
        if (n < stonesToRemove) {
            // Current player cannot remove the required stones.
            return !isAliceTurn; // If it's Alice's turn, she loses. Otherwise, Alice wins.
        }
        n -= stonesToRemove; // Remove stones from the pile.
        stonesToRemove--; // Decrease the number of stones to be removed on the next turn.
        isAliceTurn = !isAliceTurn; // Switch turns.
    }

    // If we exit the loop with no stones left, the last player made a valid move.
    return !isAliceTurn;
    }
};",1460797634
SahilG09,SahilG09,856,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;
        
        for (int i = 0; i < n; i++) {
            char source = s.charAt(i);
            char target = t.charAt(i);
            
            if (source == target) {
                continue;
            }
            int forwardSteps = 0;
            int backwardSteps = 0;
            long forwardCost = 0;
            long backwardCost = 0;
            
            char curr = source;
            while (curr != target) {
                int idx = curr - 'a';
                forwardCost += nextCost[idx];
                forwardSteps++;
                curr = (curr == 'z') ? 'a' : (char)(curr + 1);
            }
            
            curr = source;
            while (curr != target) {
                int idx = curr - 'a';
                backwardCost += previousCost[idx];
                backwardSteps++;
                curr = (curr == 'a') ? 'z' : (char)(curr - 1);
            }
            
            totalCost += Math.min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
}",1460805869
SahilG09,SahilG09,856,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        
        if (n < 10) {
            return false;
        }
        
        int remainingStones = n;
        int turnNumber = 0;
        int currentMove = 10;  
        
        while (true) {
           
            if (remainingStones < currentMove) {
                
                return turnNumber % 2 == 1;  
            }
            
            remainingStones -= currentMove;
            turnNumber++;
           
            currentMove--;
        }
    }
}",1460801279
Vidit Jain,vidit987,857,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        long long totalCost = 0,n=s.length(),i,j,l,r,x,y,xc,bc;
        for (i=0;i<n; i++){
            xc = 0, bc = 0;
            l=s[i]-'a',r=t[i]-'a';
            x=(r-l+26)%26;
            y=26-x;
            for(j=0;j<x;j++)xc+=nc[(l+j)%26];
            for(j=0;j<26-x;j++)bc += pc[(l-j+26)%26];
            totalCost += min(xc, bc);
        }
        return totalCost;
    }
};",1460806074
Vidit Jain,vidit987,857,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int k=10,x=0;
        while(n-k>=0){
            n-=k;
            k--;
            x++;
        }
        return x%2;
    }
};",1460796486
Amit Bhandari,Amit_Bhandari,858,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
        
        for i in range(len(s)):
            start_idx = ord(s[i]) - ord('a')
            target_idx = ord(t[i]) - ord('a')
            
            forward_distance = (target_idx - start_idx) % 26
            backward_distance = (start_idx - target_idx) % 26
            
            forward_cost = sum(nextCost[(start_idx + j) % 26] for j in range(forward_distance))
            backward_cost = sum(previousCost[(start_idx - j) % 26] for j in range(backward_distance))
            
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
",1460806118
Amit Bhandari,Amit_Bhandari,858,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones_to_remove = 10
        alice_turn = True
        
        while n > 0:
            if n < stones_to_remove:
                return not alice_turn
            
            n -= stones_to_remove
            stones_to_remove -= 1
            alice_turn = not alice_turn
        
        return not alice_turn
",1460800100
Veer Vikram Singh,veervikram810,859,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        length = len(s)
        cost_na_shift = 0
        
        for idx in range(length):
            source_char = s[idx]
            target_char = t[idx]
            
            # Get alphabet indices for the source and target characters
            start_idx = ord(source_char) - ord('a')
            end_idx = ord(target_char) - ord('a')
            
            # Calculate steps needed to shift forward and backward
            steps_forward = (end_idx - start_idx) % 26
            steps_backward = (start_idx - end_idx) % 26
            
            # Calculate costs for both directions
            forward_cost_na_shift = sum(nextCost[(start_idx + step) % 26] for step in range(steps_forward))
            backward_cost_na_shift = sum(previousCost[(start_idx - step) % 26] for step in range(steps_backward))
            
            # Add the minimum cost to the total shift cost
            cost_na_shift += min(forward_cost_na_shift, backward_cost_na_shift)
        
        return cost_na_shift
",1460806126
Veer Vikram Singh,veervikram810,859,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False  # Alice cannot make the first move
        
        # Start with Alice removing 10 stones
        stones_to_remove = 10
        current_player = ""Alice""
        
        while n > 0:
            if stones_to_remove > n:  # Current player cannot make a move
                return current_player == ""Bob""
            
            # Remove stones and switch players
            n -= stones_to_remove
            stones_to_remove -= 1
            current_player = ""Bob"" if current_player == ""Alice"" else ""Alice""
        
        # If the loop ends, the player who cannot make a move loses
        return current_player == ""Bob""
",1460797762
shwet_1,shwet_1,861,3591,python,"# class Solution(object):
#     def shiftDistance(self, s, t, nextCost, previousCost):
#         """"""
#         :type s: str
#         :type t: str
#         :type nextCost: List[int]
#         :type previousCost: List[int]
#         :rtype: int
#         """"""
class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        """"""
        :type s: str
        :type t: str
        :type nextCost: List[int]
        :type previousCost: List[int]
        :rtype: int
        """"""
        total_cost = 0
        
        for i in range(len(s)):
            # Get the positions of the characters in the alphabet (0-based)
            pos_s = ord(s[i]) - ord('a')
            pos_t = ord(t[i]) - ord('a')
            
            # Calculate the forward and backward distances
            forward_distance = (pos_t - pos_s) % 26
            backward_distance = (pos_s - pos_t) % 26
            
            # Calculate the cost for each type of shift
            forward_cost = sum(nextCost[(pos_s + j) % 26] for j in range(forward_distance))
            backward_cost = sum(previousCost[(pos_s - j) % 26] for j in range(backward_distance))
            
            # Add the minimum cost to the total cost
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
",1460806264
shwet_1,shwet_1,861,3625,python,"# class Solution(object):
#     def canAliceWin(self, n):
#         """"""
#         :type n: int
#         :rtype: bool
#         """"""
class Solution(object):
    def canAliceWin(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        # Initialize the number of stones Alice removes in the first turn
        alice_removes = 10
        
        while n > 0:
            # If it's Alice's turn and she can remove the required number of stones
            if n >= alice_removes:
                n -= alice_removes
            else:
                # Alice cannot make a move, so she loses
                return False
            
            # Reduce the number of stones to be removed by 1 for the next turn
            alice_removes -= 1
            
            # If there are no stones left, Alice wins
            if n == 0:
                return True
            
            # If it's Bob's turn and he can remove the required number of stones
            if n >= alice_removes:
                n -= alice_removes
            else:
                # Bob cannot make a move, so Alice wins
                return True
            
            # Reduce the number of stones to be removed by 1 for the next turn
            alice_removes -= 1
        
        return False
     ",1460800802
contestslayer23,contestslayer23,862,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n = len(s)
        forward_cost = [[0]*26 for _ in range(26)]
        backward_cost = [[0]*26 for _ in range(26)]

        for c in range(26):
            cost = 0
            forward_cost[c][c] = 0
            for step in range(1,26):
                prev_char = (c + step -1) % 26
                next_char = (c + step) % 26
                cost += nextCost[prev_char]
                forward_cost[c][next_char] = cost

        for c in range(26):
            cost = 0
            backward_cost[c][c] = 0
            for step in range(1,26):
                prev_char = (c - step +1 +26) % 26
                next_char = (c - step +26) % 26
                cost += previousCost[prev_char]
                backward_cost[c][next_char] = cost

        total_cost = 0
        for i in range(n):
            s_char = ord(s[i]) - ord('a')
            t_char = ord(t[i]) - ord('a')
            cost_forward = forward_cost[s_char][t_char]
            cost_backward = backward_cost[s_char][t_char]
            min_cost = min(cost_forward, cost_backward)
            total_cost += min_cost
        
        return total_cost",1460804187
contestslayer23,contestslayer23,862,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones_to_remove = 10
        alice_turn = True
        while n > 0 and stones_to_remove > 0:
            if n >= stones_to_remove:
                n -= stones_to_remove
            else:
                return not alice_turn
            stones_to_remove -= 1
            alice_turn = not alice_turn
        return not alice_turn",1460806302
Anand Sharma,anandmudgal04,863,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();
        
        for (int i = 0; i < n; ++i) {
            int from = s[i] - 'a';
            int to = t[i] - 'a';
            
            // Calculate forward steps and cost
            int forwardSteps = (to - from + 26) % 26;
            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(from + j) % 26];
            }
            
            // Calculate backward steps and cost
            int backwardSteps = (from - to + 26) % 26;
            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(from - j + 26) % 26];
            }
            
            // Take the minimum of the forward and backward costs
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460806311
Anand Sharma,anandmudgal04,863,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10;
        bool isAliceTurn = true;
        
        while (n > 0) {
            if (n < stonesToRemove) {
                return !isAliceTurn;
            }
            n -= stonesToRemove;
            stonesToRemove--;
            isAliceTurn = !isAliceTurn;
        }
        return !isAliceTurn;
    }
};
",1460799609
Sarvarshini,Sarvarshini_S,864,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            int start = s[i] - 'a';
            int end = t[i] - 'a';
            
            if (start == end) continue; // No cost if characters are already the same
            
            int forwardSteps = (end - start + 26) % 26; // Steps forward in the alphabet
            int backwardSteps = (start - end + 26) % 26; // Steps backward in the alphabet
            
            // Calculate costs
            long long forwardCost = 0, backwardCost = 0;
            for (int step = 0; step < forwardSteps; step++) {
                forwardCost += nextCost[(start + step) % 26];
            }
            for (int step = 0; step < backwardSteps; step++) {
                backwardCost += previousCost[(start - step + 26) % 26];
            }
            
            // Add the minimum cost for this character
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460806373
Sarvarshini,Sarvarshini_S,864,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10; // Initial stones Alice removes
        bool isAliceTurn = true; // Track whose turn it is
        while (n > 0) {
            if (n < stonesToRemove) {
                // If the player cannot remove the required number of stones, they lose
                return !isAliceTurn; // Return true if Alice wins, false otherwise
            }
            n -= stonesToRemove;         // Remove stones
            stonesToRemove--;            // Decrease the stones to remove in the next turn
            isAliceTurn = !isAliceTurn;  // Switch turns
        }
        // If the loop exits, the last player to make a valid move wins
        return !isAliceTurn;
    }
};",1460803890
Sri vasu devan,Q6rfRJ5dFv,865,3591,python,"class Solution:
    def shiftDistance(self, s, t, nextCost, previousCost):
        total_cost = 0
        n = len(s)

        for i in range(n):
            source = ord(s[i]) - ord('a')  # Index of s[i] in the alphabet
            target = ord(t[i]) - ord('a')  # Index of t[i] in the alphabet

            # Calculate forward and backward distances
            forward_distance = (target - source) % 26
            backward_distance = (source - target) % 26

            # Calculate costs
            forward_cost = sum(nextCost[(source + j) % 26] for j in range(forward_distance))
            backward_cost = sum(previousCost[(source - j) % 26] for j in range(backward_distance))

            # Add the minimum cost to the total
            total_cost += min(forward_cost, backward_cost)

        return total_cost
",1460806607
Sri vasu devan,Q6rfRJ5dFv,865,3625,python,"class Solution:
    def canAliceWin(self, n):
        # Starting number of stones to remove
        stones_to_remove = 10
        # Flag to track whose turn it is (True = Alice, False = Bob)
        is_alice_turn = True

        while n > 0:
            if n < stones_to_remove:
                # If the current player cannot make a move, they lose
                return not is_alice_turn
            n -= stones_to_remove
            stones_to_remove -= 1
            is_alice_turn = not is_alice_turn  # Alternate turns

        return not is_alice_turn  # If the game ends, the last player wins
",1460804359
preksha_taneja_,preksha_taneja_,867,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long tCt = 0;

    for (int i = 0; i < s.length(); i++) {
        int start = s[i] - 'a';
        int end = t[i] - 'a';   
        int forwardSteps = (end - start + 26) % 26;
        long long forwardCost = 0;
        for (int j = 0; j < forwardSteps; j++) {
            forwardCost += nextCost[(start + j) % 26];
        }

        int backwardSteps = (start - end + 26) % 26;
        long long backwardCost = 0;
        for (int j = 0; j < backwardSteps; j++) {
            backwardCost += previousCost[(start - j + 26) % 26];
        }

        tCt += min(forwardCost, backwardCost);
    }

    return tCt;
    }
};",1460806712
preksha_taneja_,preksha_taneja_,867,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int ctT = 10; 
    bool isAliceTurn = true; 

    while (n > 0) {
        if (n < ctT) {
            return !isAliceTurn; 
        }
        n -= ctT;
        ctT--; 
        isAliceTurn = !isAliceTurn; 
    }

    return !isAliceTurn;
    }
};",1460802310
Vai2745,Vai2745,868,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: list[int], previousCost: list[int]) -> int:
        total_cost = 0
        n = len(s)
        
        for i in range(n):
            start = ord(s[i]) - ord('a')
            end = ord(t[i]) - ord('a')
            

            if start <= end:
                clockwise_steps = end - start
            else:
                clockwise_steps = 26 - (start - end)
            clockwise_cost = sum(nextCost[(start + j) % 26] for j in range(clockwise_steps))
            

            if start >= end:
                counterclockwise_steps = start - end
            else:
                counterclockwise_steps = 26 - (end - start)
            counterclockwise_cost = sum(previousCost[(start - j) % 26] for j in range(counterclockwise_steps))
            

            total_cost += min(clockwise_cost, counterclockwise_cost)
        
        return total_cost",1460806970
Vai2745,Vai2745,868,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        if n < 10:
            return False  
        stones = 10 
        turn = 0 
        
        while n > 0:
            if n < stones:
                return turn == 1  
            n -= stones
            stones -= 1
            turn = 1 - turn  # Switch turn
        return turn == 1 ",1460802717
Yilun Wu,yilunw1030,869,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        n = len(s)
        for i in range(n):
            start, end = ord(s[i])-ord('a'), ord(t[i])-ord('a')
            fd = (end-start) % 26
            bd = (start-end) % 26
            f = sum(nextCost[(start+j) % 26] for j in range(fd))
            b = sum(previousCost[(start-j) % 26] for j in range(bd))
            res += min(f, b)
        return res",1460807033
Yilun Wu,yilunw1030,869,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        m = 10
        able = True
        while n  > 0:
            if n < m: return not able
            n -= m
            m -= 1
            able = not able
        return not able",1460796238
Manas Saini,ManasSaini03,870,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        int n = s.length();
        //manas
        for (int i = 0; i < n; i++) {
            char source = s.charAt(i);
            char target = t.charAt(i);
            int aageKaDistance = (target - source + 26) % 26;
            int peecheKaDistance = (source - target + 26) % 26;

            long aagekiCost = 0;
            long peecheKiCost = 0;

            for (int j = 0; j < aageKaDistance; j++) {
                aagekiCost += nextCost[(source - 'a' + j) % 26];
            }

            for (int j = 0; j < peecheKaDistance; j++) {
                peecheKiCost += previousCost[(source - 'a' - j + 26) % 26];
            }
            totalCost += Math.min(aagekiCost, peecheKiCost);
        }

        return totalCost;
    }
}
",1460807415
Manas Saini,ManasSaini03,870,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int remove = 10;
        boolean Alicemove = true;

        while (n > 0) {
            if (n < remove) {
                return !Alicemove;
            }
            n -= remove;
            remove--;
            Alicemove = !Alicemove;
        }
        return !Alicemove;
    }
}
",1460799678
Peter Mourad,Peter_mourad,871,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int i = 0;i < s.size();i++){
            char temp = s[i];
            long long cost1 = 0, cost2 = 0;
            while(temp != t[i]){
                cost1 += nextCost[temp - 'a'];
                temp++;
                if(temp > 'z') temp = 'a';
            }
            temp = s[i];
            while(temp != t[i]){
                cost2 += previousCost[temp - 'a'];
                temp--;
                if(temp < 'a') temp = 'z';
            }
            ans += min(cost1, cost2);
        }
        return ans;
    }
};",1460807549
Peter Mourad,Peter_mourad,871,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool turn = 0;
        int cur = 10;
        while(n >= cur && cur){
            turn^=1;
            n-=cur;
            cur--;
        }
        return turn;
    }
};",1460796590
Raj Verma,Rarma,872,3591,cpp,"#define ll long long
class Solution {
public:
    ll shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll res = 0, n = s.size();
        for (int i = 0; i < n; ++i) {
            ll c1 = 0, c2 = 0;
            ll d2 = (s[i] - t[i] + 26) % 26;
            ll d1 = (t[i] - s[i] + 26) % 26;
            
            for (ll j = 0; j < d1; ++j) {
                c1 += nextCost[(s[i] - 'a' + j) % 26];
            }
            for (ll j = 0; j < d2; ++j) {
                int ind = (s[i] - 'a' - j + 26) % 26;
                c2 += previousCost[ind];
            }
            
            res += min({c1, c2});
        }
        return res;
    }
};",1460807673
Raj Verma,Rarma,872,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stone = 10;
        bool fl = false;

        while(n>=stone){
            n -= stone;
            stone--;
            if(fl){fl=false;}
            else{fl=true;}
        }

        return fl;
    }
};",1460798098
Pranav_Bejgam,Pranav_Bejgam,873,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // To store the accumulated shift cost
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            char currentChar = s.charAt(i);
            char targetChar = t.charAt(i);
            
            // Get the indices of current and target characters in the alphabet (0 for 'a', 25 for 'z')
            int currentIndex = currentChar - 'a';
            int targetIndex = targetChar - 'a';
            
            // Calculate forward and backward shifts
            int forwardShift = (targetIndex - currentIndex + 26) % 26;
            int backwardShift = (currentIndex - targetIndex + 26) % 26;
            
            // Compute the cost for forward and backward shifts
            long forwardCost = 0;
            for (int j = 0; j < forwardShift; j++) {
                int costIndex = (currentIndex + j) % 26;
                forwardCost += nextCost[costIndex];
            }
            
            long backwardCost = 0;
            for (int j = 0; j < backwardShift; j++) {
                int costIndex = (currentIndex - j + 26) % 26;
                backwardCost += previousCost[costIndex];
            }
            
            // Choose the minimum cost between forward and backward shift
            totalCost += Math.min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
}
",1460807688
Pranav_Bejgam,Pranav_Bejgam,873,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        // Alice cannot make the first move if there are fewer than 10 stones
        if (n < 10) return false;

        // Alice's initial move is to remove 10 stones
        int currentRemove = 10;
        boolean isAliceTurn = true;
        
        // While there are enough stones for the current player to remove
        while (n >= currentRemove) {
            n -= currentRemove;
            currentRemove -= 1; // Next player removes 1 fewer stone
            isAliceTurn = !isAliceTurn; // Toggle turns
        }

        // If it's Alice's turn and she can't make a move, she loses.
        // If it's Bob's turn and he can't make a move, Alice wins.
        return !isAliceTurn;
    }
}
",1460803337
Saumyadeep Ghosh,saumyadeep_01,874,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& n, vector<int>& p) {
        long long c = 0;
        for (int i = 0; i < s.length(); ++i) {
            int a = s[i] - 'a', b = t[i] - 'a';
            if (a == b) continue;

            int f = (b - a + 26) % 26, r = (a - b + 26) % 26;
            long long x = 0, y = 0;

            for (int j = 0; j < f; ++j) x += n[(a + j) % 26];
            for (int j = 0; j < r; ++j) y += p[(a - j + 26) % 26];

            c += min(x, y);
        }
        return c;
    }
};

",1460807691
Saumyadeep Ghosh,saumyadeep_01,874,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentRemoval = 10;
        bool isAliceTurn = true;

        while (n >= currentRemoval) {
            n -= currentRemoval;
            currentRemoval--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
};
",1460796598
Amartya Saran,amartyasaran,875,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
                long long tc = 0;
        for (int i = 0; i < s.size(); ++i) {
            int si = s[i] - 'a';
            int ti = t[i] - 'a';

            if (si == ti) continue;
            
            int fs = (ti - si + 26) % 26;
            int bs = (si - ti + 26) % 26;
            long long fc = 0;
            long long bc = 0;

            for (int j = 0; j < fs; ++j) {
                fc += nc[(si + j) % 26];
            }

            for (int j = 0; j < bs; ++j) {
                bc += pc[(si - j + 26) % 26];
            }

            tc += min(fc, bc);
        }
        return tc;
    }
};",1460807705
Amartya Saran,amartyasaran,875,3625,cpp,"class Solution {
public:
    bool canAliceWin(int totalStones) {
                int moveCount = 10;
        
        if (totalStones < moveCount) {
            return false;
        }
        
        while (totalStones >= moveCount) {
            totalStones -= moveCount;
            moveCount--;
        }

        return moveCount % 2 == 1;
    }
};",1460802074
Ayush Rakwal,ayushrakwal94,876,3591,cpp,"#include <bits/stdc++.h>

#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization (""unroll-loops"")

#define vi vector<int>
#define vvi vector<vector<int>>
#define vvc vector<vector<char>>
#define vpi vector<pair<int,int>>
#define vvs vector<vector<string>>
#define ump unordered_map<int,int>
#define uos unordered_set<int>
#define pb push_back
#define set set<int>
#define mset multiset<int> 
#define all(x) x.begin(), x.end()
#define sort(x) sort(all(x))
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define ll long long

#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORR(i, a, b) for (int i = a; i <= b; ++i)
#define RF(i,a,b) for (int i = a; i >= b; i--)

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();

        for (int i = 0; i < n; i++) {
            int si = s[i] - 'a';
            int ti = t[i] - 'a';

            int forwardSteps = (ti - si + 26) % 26;
            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; j++) {
                forwardCost += nextCost[(si + j) % 26];
            }

            int backwardSteps = (si - ti + 26) % 26;
            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; j++) {
                backwardCost += previousCost[(si - j + 26) % 26];
            }

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};



auto init = []() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 'c';
}();",1460807709
Ayush Rakwal,ayushrakwal94,876,3625,cpp,"#include <bits/stdc++.h>

#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization (""unroll-loops"")

#define vi vector<int>
#define vvi vector<vector<int>>
#define vvc vector<vector<char>>
#define vpi vector<pair<int,int>>
#define vvs vector<vector<string>>
#define ump unordered_map<int,int>
#define uos unordered_set<int>
#define pb push_back
#define set set<int>
#define mset multiset<int> 
#define all(x) x.begin(), x.end()
#define sort(x) sort(all(x))
#define MAX(x) *max_element(all(x))
#define MIN(x) *min_element(all(x))
#define ll long long

#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORR(i, a, b) for (int i = a; i <= b; ++i)
#define RF(i,a,b) for (int i = a; i >= b; i--)

class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) return false; 

    int currentMove = 10; 
    bool isAliceTurn = true;

    while (n >= currentMove) {
        n -= currentMove; 
        currentMove--;   
        isAliceTurn = !isAliceTurn; 
    }

    
    return !isAliceTurn;
    }
};


auto init = []() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 'c';
}();",1460802511
Anshul Sharma,anshul7sh,877,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long res = 0;
        
        int n=s.size();
        
        for(int i=0;i<n;i++) {
            res+=min(calcNext(s[i]-'a',t[i]-'a',nextCost),calcPrev(s[i]-'a',t[i]-'a',previousCost));
        }
        
        return res;
    }
    
    long long calcNext(int start, int end, vector<int>& nextCost) {
        long long res =0;
        
        while(start!=end) {
            res+=nextCost[start];
            start++;
            start%=26;
        }
        
        return res;
    }
    
    long long calcPrev(int start, int end, vector<int>& prevCost) {
        long long res =0;
        
        while(start!=end) {
            res+=prevCost[start];
            start--;
            if(start<0) {
                start=25;
            }
        }
        
        return res;
    }
};",1460807792
Anshul Sharma,anshul7sh,877,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currCount=10;
        bool alice=true;
        
        while(1) {
            if(n<currCount) {
                if(alice)
                    return false;
                else return true;
            }
            
            n-=currCount;
            currCount--;
            alice=!alice;
        }
    }
};",1460796763
Prashant Shukla,prashant933,878,3591,cpp,"#define ll long long

class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll ans = 0;
        int n = s.size();
        
        for (int i = 0; i < n; i++)
        {
            if (s[i] == t[i])
                continue;
            
            ll c1 = 0, c2 = 0;
            // forward
            int cur = s[i] - 'a';
            while (cur != (t[i] - 'a'))
            {
                c1 += nextCost[cur];
                cur = (cur + 1) % 26;
            }
            
            // backward
            cur = s[i] - 'a';
            while (cur != (t[i] - 'a'))
            {
                c2 += previousCost[cur];
                cur = (cur + 25) % 26;
            }
            ans += min(c1, c2);
        }
        return ans;
    }
};",1460807950
Prashant Shukla,prashant933,878,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int remove = 10, idx = 0;

        while (remove > 0 && n - remove >= 0)
        {
            n -= remove;
            idx^=1;
            remove--;
        }
        if (idx == 1)
            return 1;
        else
            return 0;
    }
};",1460796900
ken kaneki,__Kaneki_,879,3591,cpp,"class Solution {
public:
    #define ll long long
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll sum=0;
        ll n=s.length();
        ll ans=0;
        for(ll i=0;i<n;i++){
            char a=s[i],b=t[i];
            ll next=0,prev=0;
            while(a!=b){
                next+=nextCost[a-'a'];
                if(a=='z'){
                    a='a';
                }
                else
                    a++;
                
            }
            a=s[i];
            b=t[i];
            while(a!=b){
                prev+=previousCost[a-'a'];
                if(a=='a'){
                    a='z';
                }
                else
                    a--;
                
            }
            ans+=min(next,prev);
        }
        return ans;
    }
};",1460807952
ken kaneki,__Kaneki_,879,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        bool alice=true;
        int del=10;
        while(n>0){
            if(n<del){
                break;
            }
            else{
                n-=del;
                del--;
                alice=!alice;
            }
        }
        return !alice;
    }
};",1460796450
Victor,solvictor,880,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        res = 0
        for a, b in zip(s, t):
            if a == b:
                continue
            aa = a = ord(a) - ord('a')
            b = ord(b) - ord('a')
            x = 0
            while a != b:
                x += nextCost[a]
                a = (a + 1) % 26
            a = aa
            y = 0
            while a != b:
                y += previousCost[a]
                a = (a - 1) % 26
            res += min(x, y)
            
        return res",1460808011
Victor,solvictor,880,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        todo = 10
        t = 0
        while n >= todo:
            n -= todo
            todo -= 1
            t ^= 1
        return t == 1",1460795977
VILLANOVA_ECON,VILLANOVA_ECON,881,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        
        
        
        next_letter = [0]*26
        for i in range(97,97+26):
            next_letter[i-97] = i+1
        next_letter[-1] = 97
        
        
        @lru_cache(None)
        def shift_ahead(x,y):
            curr = ord(x)-ord('a')
            cost = 0
            target = ord(y) - ord('a')
            while curr != target:
                cost += nextCost[curr]
                curr = (curr + 1)%26
            return cost
        
        @lru_cache(None)
        def shift_behind(x,y):
            curr = ord(x)-ord('a')
            cost = 0
            target = ord(y) - ord('a')
            while curr != target:
                cost += previousCost[curr]
                curr = (curr - 1)%26
            return cost
        
        ans = 0
        
        for i in range(len(s)):
            ans += min(shift_ahead(s[i],t[i]),shift_behind(s[i],t[i]))
            
        
        shift_behind.cache_clear()
        shift_ahead.cache_clear()
        return ans
            ",1460808045
VILLANOVA_ECON,VILLANOVA_ECON,881,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        curr = 10
        
        def win_check(z):
            if z%2 == 0:
                return False
            else:
                return True
        
        for i in range(100):
            if curr > n:
                return win_check(i)
            n -= curr
            curr -= 1
        ",1460797007
Shivam Kumar,user2437HU,882,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.size();

        for (int i = 0; i < n; ++i) {
            int si = s[i] - 'a', ti = t[i] - 'a';
            int forwardSteps = (ti - si + 26) % 26;
            int backwardSteps = (si - ti + 26) % 26;

            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) forwardCost += nextCost[(si + j) % 26];
            for (int j = 0; j < backwardSteps; ++j) backwardCost += previousCost[(si - j + 26) % 26];

            totalCost += min(forwardCost, backwardCost);
        }

        return totalCost;
    }
};
",1460797334
Shivam Kumar,user2437HU,882,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10;
        while (true) {
            if (n < stonesToRemove) return false;
            n -= stonesToRemove;
            stonesToRemove--;
            if (n < stonesToRemove) return true;
            n -= stonesToRemove;
            stonesToRemove--;
        }
    }
};
",1460796379
Manish Mandal,manish_2109,883,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();
        
        for (int i = 0; i < n; ++i) {
            int currentIndex = s[i] - 'a';
            int targetIndex = t[i] - 'a';
            
            int forwardDistance = (targetIndex - currentIndex + 26) % 26;
            int backwardDistance = (currentIndex - targetIndex + 26) % 26;
            
            long long forwardCost = 0, backwardCost = 0;
            for (int j = 0; j < forwardDistance; ++j) {
                forwardCost += nextCost[(currentIndex + j) % 26];
            }
            for (int j = 0; j < backwardDistance; ++j) {
                backwardCost += previousCost[(currentIndex - j + 26) % 26];
            }
            
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460808115
Manish Mandal,manish_2109,883,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10; // Start with Alice removing 10 stones
        bool isAliceTurn = true; // Tracks whose turn it is
        
        while (n > 0) {
            if (n < stonesToRemove) {
                // The current player cannot remove the required number of stones
                return !isAliceTurn; // If Alice cannot move, Bob wins, and vice versa
            }
            
            // Remove stones
            n -= stonesToRemove;
            
            // Reduce stones to remove for the next turn
            stonesToRemove--;
            
            // Switch turn
            isAliceTurn = !isAliceTurn;
        }
        
        return !isAliceTurn; // If the loop ends, it means the last move wins
    }
};
",1460802114
Hitarth Anand Rohra,hitaarthh,884,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;
        
        for (int i = 0; i < n; i++) {
            char sc = s.charAt(i);
            char tc = t.charAt(i);
            
            // Find the positions of the characters in the alphabet
            int start = sc - 'a';
            int target = tc - 'a';
            
            // Compute the forward distance
            int forwardSteps = (target - start + 26) % 26;
            long forwardCost = 0;
            for (int j = 0; j < forwardSteps; j++) {
                forwardCost += nextCost[(start + j) % 26];
            }
            
            // Compute the backward distance
            int backwardSteps = (start - target + 26) % 26;
            long backwardCost = 0;
            for (int j = 0; j < backwardSteps; j++) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }
            
            // Add the minimum cost to the total
            totalCost += Math.min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
}
",1460797415
Hitarth Anand Rohra,hitaarthh,884,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        // Alice must remove exactly 10 stones first
        if (n < 10) {
            return false;
        }
        
        n -= 10;  // Remove Alice's first 10 stones
        int nextMove = 9;  // Bob must remove 9 stones next
        boolean isAliceTurn = false;  // After Alice's first move, it's Bob's turn
        
        while (n >= 0) {
            if (n < nextMove) {
                return !isAliceTurn;  // Current player loses, so other player wins
            }
            
            if (n == nextMove) {
                return isAliceTurn;  // Current player can make the final move and win
            }
            
            n -= nextMove;
            nextMove--;
            isAliceTurn = !isAliceTurn;
        }
        
        return isAliceTurn;  // If we get here, last player won
    }
}",1460796314
Shaik Sameer,s1967,885,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>&pc) {
        int n=s.length();
        long long ans=0ll;
        for(int i=0;i<n;i++){
            int p1=s[i]-'a';
            int p2=t[i]-'a';
            long long mini=1e18;
            long long cost=0ll;
            while(p1!=p2){
                cost=cost+1ll*(nc[p1]);
                p1=(p1+1)%26;
            }
            p1=s[i]-'a';
            mini=cost;
            cost=0ll;
            while(p1!=p2){
                cost=cost+1ll*pc[p1];
                p1=(p1-1+26)%26;
            }
            mini=min(mini,cost);
            ans=ans+(1ll*mini);
        }
        return ans;
    }
};",1460808470
Shaik Sameer,s1967,885,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int flag=1;
        int count=10;
        while(n>=count){
            n-=count;
            count--;
            flag=(!flag);
        }
        return !flag;
    }
};",1460797639
Annpurna Gupta,annpurnagupta,886,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();

        for (int i = 0; i < n; i++) {
            int start = s[i] - 'a';  
            int target = t[i] - 'a'; 

            if (start == target) continue;  
            int clockwiseDistance = (target - start + 26) % 26;
            int counterclockwiseDistance = (start - target + 26) % 26;

            long long clockwiseCost = 0, counterclockwiseCost = 0;

            for (int j = 0; j < clockwiseDistance; j++) {
                clockwiseCost += nextCost[(start + j) % 26];
            }

            for (int j = 0; j < counterclockwiseDistance; j++) {
                counterclockwiseCost += previousCost[(start - j + 26) % 26];
            }

            totalCost += min(clockwiseCost, counterclockwiseCost);
        }

        return totalCost;
    }
};",1460808490
Annpurna Gupta,annpurnagupta,886,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10;  

    while (n > 0) {
        if (n < stonesToRemove) {
            return false; 
        }

        n -= stonesToRemove;

        stonesToRemove--;

        if (n < stonesToRemove) {
            return true;  
        }

        n -= stonesToRemove;

        stonesToRemove--;
    }

    return false;
    }
};",1460802041
Raja Keshri,raja_,887,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans=0;
        int n=s.size();
        for(int i=0;i<n;i++){
            if(s[i]!=t[i]){
                char cur=s[i];
                long long cost1=0,cost2=0;
                while(cur!=t[i]){
                    cost1+=nextCost[cur-'a'];
                    if(cur=='z'){
                        cur='a';
                    }
                    else{
                        cur++;
                    }                   
                }
                cur=s[i];
                while(cur!=t[i]){
                    cost2+=previousCost[cur-'a'];
                    if(cur=='a'){
                        cur='z';
                    }
                    else{
                        cur--;
                    }
                }
                ans+=min(cost1,cost2);
                
            }
        }
        return ans;
    }
};",1460808520
Raja Keshri,raja_,887,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int req=10;
        int turn=0;
        while(1){
            if(n>=req){
                n-=req;
            }
            else{
                if(turn==0) return false;
                else return true;
            }
            turn=1-turn;
            req--;
        }
        return true;
    }
};",1460798345
Sagar bagwe,code_sarang,888,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long total = 0;
        for (int i = 0; i < s.size(); ++i) {
            int start = s[i] - 'a';
            int target = t[i] - 'a';
            int f = (target - start + 26) % 26;
            int b = (start - target + 26) % 26;
            long long ff = 0, bb = 0;
            for (int j = 0; j < f; ++j) ff += nextCost[(start + j) % 26];
            for (int j = 0; j < b; ++j) bb += previousCost[(start - j + 26) % 26];
            total += min(ff, bb);
        }
        return total;
    }
};",1460808528
Sagar bagwe,code_sarang,888,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        if (n < 10) return false;
        int s = 10;

        while (n >= s) {
            n -= s;
            s--;
            if (n < s) return true;
            n -= s;
            s--;
            if (n < s) return false;
        }

        return true;
    }
};",1460802468
Alluri Rudresh Varma,ARVROCKSTAR,889,3591,python3,"from typing import List

class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        n = len(s)
        total_cost = 0

        for i in range(n):
            start = ord(s[i]) - ord('a')  # Index of s[i] in the alphabet (0-based)
            target = ord(t[i]) - ord('a')  # Index of t[i] in the alphabet (0-based)

            # Calculate forward and backward distances
            forward_distance = (target - start) % 26  # Distance moving forward
            backward_distance = (start - target) % 26  # Distance moving backward

            # Calculate forward and backward costs
            forward_cost = sum(nextCost[(start + j) % 26] for j in range(forward_distance))
            backward_cost = sum(previousCost[(start - j) % 26] for j in range(backward_distance))

            # Add the minimum cost to the total cost
            total_cost += min(forward_cost, backward_cost)

        return total_cost
",1460808564
Alluri Rudresh Varma,ARVROCKSTAR,889,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones = 10  # Alice starts by removing 10 stones
        turn = 0     # 0 indicates Alice's turn, 1 indicates Bob's turn

        while n > 0:
            if n >= stones:
                n -= stones
            else:
                break
            stones -= 1  # Decrease stones removed by 1 for the next move
            turn ^= 1    # Switch turn: 0 -> 1, 1 -> 0
        
        # If it's Alice's turn (turn == 1) and no stones are left, Alice wins
        return turn == 1
",1460804894
ABHISHEK RANJAN,Abhishekk_007,890,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
    int n = s.length();
    
    for (int i = 0; i < n; ++i) {
        int start = s[i] - 'a';
        int target = t[i] - 'a';

        if (start == target) continue;

        int forwardDist = (target - start + 26) % 26;
        int backwardDist = (start - target + 26) % 26;

        long long forwardCost = 0;
        for (int j = 0; j < forwardDist; ++j) {
            forwardCost += nextCost[(start + j) % 26];
        }

        long long backwardCost = 0;
        for (int j = 0; j < backwardDist; ++j) {
            backwardCost += previousCost[(start - j + 26) % 26];
        }

        totalCost += min(forwardCost, backwardCost);
    }

    return totalCost;
    }
};",1460808606
ABHISHEK RANJAN,Abhishekk_007,890,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10;
        bool isAliceTurn = true;

        while (n > 0) {
            if (n < stonesToRemove) {

                return !isAliceTurn;
            }
            n -= stonesToRemove;
            stonesToRemove--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
};",1460798021
DekuBala,DekuBala,891,3591,cpp,"typedef long long ll;
class Solution {
public:
    ll getCost(vector<int>& nC, vector<int>& pC,int i,int j){
        // forward cost
        int l1 = i;
        ll c1 = 0;
        while(l1!=j){
            c1+=nC[l1];
            l1+=1;
            l1 = l1%26;
        }
        
        //backward cost
        int l2 = i;
        ll c2 = 0;
        while(l2!=j){
            c2+=pC[l2];
            l2 = (l2-1+26)%26;
        }
        return min(c1,c2);
    }
    long long shiftDistance(string s, string t, vector<int>& nC, vector<int>& pC) {
        ll cost = 0;
        int n = s.length();
        for(int i=0;i<n;i++){
            cost+=getCost(nC,pC,s[i]-'a',t[i]-'a');
        }
        return cost;
    }
};",1460808618
DekuBala,DekuBala,891,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int t = 10;
        int a = 1;
        while(n>=t){
            n-=t;
            t--;
            a = 1-a;
        }
        if(a)return false;
        return true;
    }
};",1460796915
yoosha786,yoosha786,892,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0; // Total cost of transforming s to t
        int n = s.length(); // Length of the strings
        
        for (int i = 0; i < n; ++i) {
            int from = s[i] - 'a'; // Index of the current character in s
            int to = t[i] - 'a';   // Index of the target character in t
            
            if (from == to) continue; // If the characters are already the same, skip
            
            // Calculate the cost of shifting forward (next) or backward (previous)
            int forwardSteps = (to - from + 26) % 26; // Steps required to move forward
            int backwardSteps = (from - to + 26) % 26; // Steps required to move backward
            
            // Calculate the cost for both directions
            long long forwardCost = 0;
            for (int j = 0; j < forwardSteps; ++j) {
                forwardCost += nextCost[(from + j) % 26];
            }
            
            long long backwardCost = 0;
            for (int j = 0; j < backwardSteps; ++j) {
                backwardCost += previousCost[(from - j + 26) % 26];
            }
            
            // Add the minimum cost to the total
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460808685
yoosha786,yoosha786,892,3625,cpp,"class Solution {
public:
    bool canAliceWin(int totalStones) {
        int stonesToTake = 10; // Number of stones to remove in the current turn
        bool isAliceTurn = true; // Keeps track of whose turn it is (true for Alice, false for Bob)
        
        while (totalStones > 0) {
            if (stonesToTake > totalStones) {
                // If the current player cannot remove enough stones, they lose
                return !isAliceTurn; // Alice wins if it's not her turn, otherwise Bob wins
            }
            
            // Subtract the stones taken from the pile
            totalStones -= stonesToTake;
            
            // Reduce the number of stones to take in the next turn
            stonesToTake--;
            
            // Alternate the turn
            isAliceTurn = !isAliceTurn;
        }
        
        // If the loop ends, the player whose turn it is loses
        return !isAliceTurn; // Return true if Alice wins, false otherwise
    }
};
",1460800693
22R01A05P9,22R01A05P9,893,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] n, int[] p) {
        long cost = 0;
        for (int i = 0; i < s.length(); i++) {
            cost += calculateCost(s.charAt(i), t.charAt(i), n, p);
        }
        return cost;
    }
    private long calculateCost(char a, char b, int[] n, int[] p) {
        int x = a - 'a';
        int y = b - 'a';

        int f = (y - x + 26) % 26;
        long fc = 0;
        int c = x;
        for (int i = 0; i < f; i++) {
            fc += n[c];
            c = (c + 1) % 26;
        }
        int bwd = (x - y + 26) % 26;
        long bc = 0;
        c = x;
        for (int i = 0; i < bwd; i++) {
            bc += p[c];
            c = (c - 1 + 26) % 26;
        }

        return Math.min(fc, bc);
    }
}
",1460808913
22R01A05P9,22R01A05P9,893,3625,java,"class Solution {
    public boolean canAliceWin(int x) {
        return playGame(x, 10, true); // Start the game with Alice's turn and 10 stones to remove
    }
    
    private boolean playGame(int stones, int remove, boolean isAliceTurn) {
        if (stones < remove) {
            return !isAliceTurn;
        }
        // Simulate the next turn
        return playGame(stones - remove, remove - 1, !isAliceTurn);
    }
}
",1460798544
darshika pundir,darshika11,894,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0;
        int n = s.length();
        
        for (int i = 0; i < n; ++i) {
            int startChar = s[i] - 'a'; // Current character index in alphabet
            int targetChar = t[i] - 'a'; // Target character index in alphabet
            
            // Calculate forward distance
            int forwardDist = (targetChar - startChar + 26) % 26;
            long long forwardCost = 0;
            for (int j = 0; j < forwardDist; ++j) {
                forwardCost += nextCost[(startChar + j) % 26];
            }
            
            // Calculate backward distance
            int backwardDist = (startChar - targetChar + 26) % 26;
            long long backwardCost = 0;
            for (int j = 0; j < backwardDist; ++j) {
                backwardCost += previousCost[(startChar - j + 26) % 26];
            }
            
            // Add the minimum cost for this character transformation
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460808972
darshika pundir,darshika11,894,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int turn = 0; // 0 for Alice, 1 for Bob
        int stonesToRemove = 10;

        while (n > 0) {
            if (n < stonesToRemove) {
                return turn == 1; // If it's Bob's turn and he can't move, Alice wins
            }
            n -= stonesToRemove;
            stonesToRemove--; // Decrease the stones to remove
            turn = 1 - turn;  // Switch turns
        }

        return turn == 1; // If Alice makes the last valid move, she wins
    }
};
",1460806058
karan Aggarwal,aggarwalkaran241,896,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size();
        long long totalCost = 0;

        for (int i = 0; i < n; ++i) {
            if (s[i] == t[i]) continue;

            
            int clockwiseDist = (t[i] - s[i] + 26) % 26;
            long long clockwiseCost = 0;
            for (int j = 0, index = s[i] - 'a'; j < clockwiseDist; ++j) {
                clockwiseCost += nextCost[index];
                index = (index + 1) % 26;
            }

            int counterclockwiseDist = (s[i] - t[i] + 26) % 26;
            long long counterclockwiseCost = 0;
            for (int j = 0, index = s[i] - 'a'; j < counterclockwiseDist; ++j) {
                counterclockwiseCost += previousCost[index];
                index = (index - 1 + 26) % 26;
            }

           
            totalCost += min(clockwiseCost, counterclockwiseCost);
        }

        return totalCost;
    }
};
",1460809131
karan Aggarwal,aggarwalkaran241,896,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        
     int count=10;
      bool flag=true;
        int turn=1;
        while(n>0){
            if(turn==1){
                 if(n>=count ){
                n=n-count;
                flag=true;
                     turn=0;
                     count--;
            continue;
            }
                else {
                    return false;
                }
            }
            else {
            if(n>=count ){
                n=n-count;
                turn=1;
                count--;
                flag=false;
            }
             else {
                    return true;
            }

                
            }
          
        }
        return flag;
    }
};",1460806569
ksit,ksit,898,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.size();
        for(int i = 0; i < n; ++i) {
            char x = s[i], y = t[i];
            long long cost1 = 0, cost2 = 0;
            if(x == y) {
                continue;
            }
            while(x != y) {
                cost1 += nextCost[x - 'a'];
                if(x == 'z') {
                    x = 'a';
                } else {
                    x = x + 1;
                }
            }
            x = s[i];
            while(x != y) {
                cost2 += previousCost[x - 'a'];
                if(x == 'a') {
                    x = 'z';
                } else {
                    x = x - 1;
                }
            }
            ans += min(cost1, cost2);
        }
        return ans;
    }
};",1460809193
ksit,ksit,898,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int f = 0, c = 10;
        while(n >= c) {
            n -= c;
            c -= 1;
            f ^= 1;
        }
        return f == 1;
    }
};",1460796519
Amit Kumar,amitk1305,899,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0; // To store the total minimum cost

        for (int i = 0; i < s.size(); i++) {
            int si = s[i] - 'a'; // Index of s[i] in the alphabet
            int ti = t[i] - 'a'; // Index of t[i] in the alphabet
            
            // Calculate forward and backward steps
            int forward_steps = (ti - si + 26) % 26;
            int backward_steps = (si - ti + 26) % 26;

            // Calculate forward cost
            long long forward_cost = 0;
            for (int step = 0, index = si; step < forward_steps; step++) {
                forward_cost += nextCost[index];
                index = (index + 1) % 26; // Move to the next character
            }

            // Calculate backward cost
            long long backward_cost = 0;
            for (int step = 0, index = si; step < backward_steps; step++) {
                backward_cost += previousCost[index];
                index = (index - 1 + 26) % 26; // Move to the previous character
            }

            // Add the minimum of the two costs to the total cost
            totalCost += min(forward_cost, backward_cost);
        }

        return totalCost;
    }
};
",1460798585
Amit Kumar,amitk1305,899,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10; // Alice starts with 10 stones
        bool isAliceTurn = true; // Alice starts

        while (n > 0) {
            if (n < stonesToRemove) {
                // Current player cannot make a move
                return !isAliceTurn; // If it's Alice's turn, she loses
            }
            n -= stonesToRemove;  // Remove stones
            stonesToRemove--;     // Next turn removes fewer stones
            isAliceTurn = !isAliceTurn; // Switch turns
        }

        // The player who last made a valid move wins
        return !isAliceTurn; // If it's Alice's turn after the loop, she loses
    }
};
",1460796690
Soni Nirav,soninirav,900,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nextCost: List[int], previousCost: List[int]) -> int:
        total_cost = 0
    
        for i in range(len(s)):
            start = ord(s[i]) - ord('a')
            target = ord(t[i]) - ord('a')
            
            forward_distance = (target - start) % 26
            backward_distance = (start - target) % 26
            
            forward_cost = sum(nextCost[(start + j) % 26] for j in range(forward_distance))
            backward_cost = sum(previousCost[(start - j) % 26] for j in range(backward_distance))
            
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost",1460809438
Soni Nirav,soninirav,900,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        stones_removed = 10
        is_alice_turn = True
    
        while n > 0:
            if n < stones_removed:
                return not is_alice_turn
            n -= stones_removed
            stones_removed -= 1
            is_alice_turn = not is_alice_turn
    
        return not is_alice_turn
                ",1460807035
Anupam Ghosh,anupam_ghosh,901,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
         vector<vector<long long>> dist(26, vector<long long>(26, LLONG_MAX));
        for (int i = 0; i < 26; ++i) dist[i][i] = 0;


        for (int i = 0; i < 26; ++i) {
            dist[i][(i + 1) % 26] = nextCost[i];
            dist[i][(i - 1 + 26) % 26] = previousCost[i];
        }

        for (int k = 0; k < 26; ++k) {
            for (int i = 0; i < 26; ++i) {
                for (int j = 0; j < 26; ++j) {
                    if (dist[i][k] != LLONG_MAX && dist[k][j] != LLONG_MAX) {
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }
        int n=s.size();
        long long res=0;
        for(int i=0;i<n;i++){
            res+=dist[s[i]-'a'][t[i]-'a'];
        }
        return res;
    }
};",1460809480
Anupam Ghosh,anupam_ghosh,901,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int op=0;
        int a=10;
        while(n>=a){
            op++;
            n-=a;
            a--;
        }
        return (op&1);
    }
};",1460796327
Aashritha,Aashritha2502,902,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // Initialize total cost
        
        for (int i = 0; i < s.length(); i++) {
            char charS = s.charAt(i); // Current character in s
            char charT = t.charAt(i); // Target character in t

            // Calculate the indices of charS and charT in the alphabet (0-indexed)
            int indexS = charS - 'a';
            int indexT = charT - 'a';

            // Calculate forward and backward shifts
            int forwardShift = (indexT - indexS + 26) % 26; // Shift from charS to charT
            int backwardShift = (indexS - indexT + 26) % 26; // Shift from charT to charS

            // Calculate costs for both operations
            long forwardCost = 0, backwardCost = 0;

            // Accumulate cost for forward shift
            for (int j = 0; j < forwardShift; j++) {
                forwardCost += nextCost[(indexS + j) % 26];
            }

            // Accumulate cost for backward shift
            for (int j = 0; j < backwardShift; j++) {
                backwardCost += previousCost[(indexS - j + 26) % 26];
            }

            // Add the minimum cost of the two to the total cost
            totalCost += Math.min(forwardCost, backwardCost);
        }

        return totalCost; // Return the total shift distance
    }
}
",1460809481
Aashritha,Aashritha2502,902,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        // Alice starts by removing 10 stones
        int currentStonesToRemove = 10;
        
        // Alice's turn starts first
        boolean isAliceTurn = true;

        // Simulate the game
        while (n > 0) {
            if (n < currentStonesToRemove) {
                // If the current player cannot make a valid move, they lose
                return !isAliceTurn;
            }
            // Remove stones for the current player's turn
            n -= currentStonesToRemove;
            // Decrease the number of stones to be removed in the next turn
            currentStonesToRemove--;
            // Switch turns
            isAliceTurn = !isAliceTurn;
        }

        // If the loop exits with n == 0, the last player to play wins
        return !isAliceTurn;
    }
}
",1460807588
Vinay Rewatkar,user1428aJ,903,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0; // Total cost to transform s to t
        
        for (int i = 0; i < s.length(); i++) {
            int startChar = s.charAt(i) - 'a'; // Index of s[i] in the alphabet
            int targetChar = t.charAt(i) - 'a'; // Index of t[i] in the alphabet
            
            // Calculate clockwise steps
            int clockwiseSteps = (targetChar - startChar + 26) % 26;
            // Calculate counterclockwise steps
            int counterclockwiseSteps = (startChar - targetChar + 26) % 26;
            
            // Calculate clockwise cost
            long clockwiseCost = 0;
            for (int j = 0; j < clockwiseSteps; j++) {
                int idx = (startChar + j) % 26;
                clockwiseCost += nextCost[idx];
            }
            
            // Calculate counterclockwise cost
            long counterclockwiseCost = 0;
            for (int j = 0; j < counterclockwiseSteps; j++) {
                int idx = (startChar - j + 26) % 26;
                counterclockwiseCost += previousCost[idx];
            }
            
            // Add the minimum cost of the two to the total cost
            totalCost += Math.min(clockwiseCost, counterclockwiseCost);
        }
        
        return totalCost;
    }
}
",1460809539
Vinay Rewatkar,user1428aJ,903,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        int stonesToRemove = 10; // Start with 10 stones
        boolean isAliceTurn = true; // Track whose turn it is
        
        while (n > 0) {
            if (n < stonesToRemove) {
                // If the current player cannot make a move, they lose
                return !isAliceTurn;
            }
            n -= stonesToRemove; // Remove stones
            stonesToRemove--; // Decrease the stones to remove next turn
            isAliceTurn = !isAliceTurn; // Switch turn
        }
        
        // If the loop ends, it means the last player couldn't make a move
        return !isAliceTurn;
    }
}
",1460804524
Devendra_08,devsa2067,904,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long ans = 0;
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            char cs = s.charAt(i);
            char ct = t.charAt(i);
            if (cs == ct) continue; // No cost if characters are already the same
            
            int start = cs - 'a'; // Starting position in the alphabet
            int target = ct - 'a'; // Target position in the alphabet
            
            // Calculate cost for forward shifting (clockwise)
            int forwardSteps = (target - start + 26) % 26;
            long forwardCost = 0;
            int current = start;
            for (int step = 0; step < forwardSteps; step++) {
                forwardCost += nextCost[current];
                current = (current + 1) % 26;
            }
            
            // Calculate cost for backward shifting (counter-clockwise)
            int backwardSteps = (start - target + 26) % 26;
            long backwardCost = 0;
            current = start;
            for (int step = 0; step < backwardSteps; step++) {
                backwardCost += previousCost[current];
                current = (current - 1 + 26) % 26;
            }
            
            // Add the minimum cost to the total answer
            ans += Math.min(forwardCost, backwardCost);
        }
        
        return ans;
    }
}
",1460809685
Devendra_08,devsa2067,904,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10) {
            return false; // Alice can't make the first move
        }
        
        int stonesToRemove = 10; // Alice's initial move
        boolean isAliceTurn = true; // Keep track of whose turn it is
        
        while (n > 0) {
            if (n < stonesToRemove) {
                return !isAliceTurn; // The current player loses
            }
            n -= stonesToRemove; // Remove stones
            stonesToRemove--; // Reduce the stones to remove for the next turn
            isAliceTurn = !isAliceTurn; // Alternate turns
        }
        
        return !isAliceTurn; // If the game ends, the last player to make a move wins
    }
}
",1460796558
Suraj Kumar Sharma,Mr_Sharma13,906,3591,python,"class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        """"""
        :type s: str
        :type t: str
        :type nextCost: List[int]
        :type previousCost: List[int]
        :rtype: int
        """"""
        total_cost = 0
        n = len(s)
        
        for i in range(n):
            start_char = s[i]
            target_char = t[i]
            
            # Indices of start_char and target_char in the alphabet
            start_index = ord(start_char) - ord('a')
            target_index = ord(target_char) - ord('a')
            
            # Compute forward and backward distances
            forward_distance = (target_index - start_index) % 26
            backward_distance = (start_index - target_index) % 26
            
            # Calculate the costs for forward and backward shifts
            forward_cost = sum(nextCost[(start_index + k) % 26] for k in range(forward_distance))
            backward_cost = sum(previousCost[(start_index - k) % 26] for k in range(backward_distance))
            
            # Add the minimum cost to the total cost
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
",1460799240
Suraj Kumar Sharma,Mr_Sharma13,906,3625,python,"class Solution(object):
    def canAliceWin(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        stones_to_remove = 10  # Alice starts by removing 10 stones
        is_alice_turn = True   # Alice goes first

        while n > 0:
            if n < stones_to_remove:
                # Current player cannot make a valid move
                return not is_alice_turn
            n -= stones_to_remove
            stones_to_remove -= 1
            is_alice_turn = not is_alice_turn  # Switch turns
        
        # Alice wins if the last move was Bob's
        return not is_alice_turn
",1460796838
Jaigarg,Jai_Garg,907,3591,cpp,"#include <bits/stdc++.h>
using namespace std; 

class Solution {
public:
    
    long long next_cost(char s, char e, vector<int> & nxt) {
        long long cost = 0; 
        while (s != e) {
            cost += nxt[s - 'a']; 
            s = 'a' + (s - 'a' + 1) % 26; 
        }
        
        return cost; 
    }

    long long prev_cost(char s, char e, vector<int> & prev) {
        long long cost = 0; 

        while (s != e) {
            cost += prev[s - 'a']; 
            s = 'a' + ((s - 'a') - 1 + 26) % 26; 
        }
        
        return cost; 
    }
    
    
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        int n = s.size(); 
        int m = t.size(); 
        if (n != m) return -1; 
        long long ans = 0; 
        
        for (int i = 0; i < n; i++) {
            ans += min(next_cost(s[i], t[i], nextCost), prev_cost(s[i], t[i], previousCost)); 
        }
        
        return ans;  
    }
};",1460809884
Jaigarg,Jai_Garg,907,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        
        int move = 10; 
        bool turn = true; 
        
        while (move > 0 && n >= move) {
            n -= move; 
            turn = !turn; 
            move--; 
        }
        
        return !turn; 
    }
};",1460797488
Vladislav,timetoai,908,3591,python3,"class Solution:
    def shiftDistance(self, s: str, t: str, nxt: List[int], prv: List[int]) -> int:
        @cache
        def go(c1, c2, forw=True):
            if c1 == c2:
                return 0
            if forw:
                return go((c1 + 1) % 26, c2, True) + nxt[c1]
            return go((c1 - 1) % 26, c2, False) + prv[c1]
        
        ret = 0
        for c1, c2 in zip(s, t):
            c1, c2 = map(lambda ch: ord(ch) - ord('a'), (c1, c2))
            ret += min(go(c1, c2, True), go(c1, c2, False))
        return ret",1460809889
Vladislav,timetoai,908,3625,python3,"class Solution:
    def canAliceWin(self, n: int) -> bool:
        cur = 10
        turn = 0
        while n >= cur:
            n -= cur
            turn ^= 1
            cur -= 1
        return turn == 1",1460796303
Souvik Choudhury,C34WwFGcFp,909,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        long long n = s.size();

        for (long long i = 0; i < n; i++) {
            long long start = s[i] - 'a';
            long long end = t[i] - 'a';

            long long forwardSteps = (end - start + 26) % 26;
            long long forwardCost = 0;
            for (long long j = 0; j < forwardSteps; j++) {
                forwardCost += nextCost[(start + j) % 26];
            }

            long long backwardSteps = (start - end + 26) % 26; 
            long long backwardCost = 0;
            for (long long j = 0; j < backwardSteps; j++) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }

            ans += min(forwardCost, backwardCost);
        }

        return ans;
    }
};
",1460809898
Souvik Choudhury,C34WwFGcFp,909,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stonesToRemove = 10; 
        bool isAliceTurn = true; 
        while (n > 0) {
            if (n < stonesToRemove) {
                return !isAliceTurn;
            }
            n -= stonesToRemove; 
            stonesToRemove--;   
            isAliceTurn = !isAliceTurn; 
        }
        return !isAliceTurn;
    }
};
",1460798440
Aniketshakya,Aniketshakya,910,3591,python,"class Solution(object):
    def shiftDistance(self, s, t, nextCost, previousCost):
        """"""
        :type s: str
        :type t: str
        :type nextCost: List[int]
        :type previousCost: List[int]
        :rtype: int
        """"""
        # Total cost accumulator
        total_cost = 0
        
        # Helper function to calculate the alphabet index (0 for 'a', ..., 25 for 'z')
        def char_index(c):
            return ord(c) - ord('a')
        
        # Iterate through both strings
        for i in range(len(s)):
            src_idx = char_index(s[i])
            dest_idx = char_index(t[i])
            
            # Calculate forward and backward distances
            forward_steps = (dest_idx - src_idx) % 26
            backward_steps = (src_idx - dest_idx) % 26
            
            # Compute the cost for each direction
            forward_cost = sum(nextCost[(src_idx + j) % 26] for j in range(forward_steps))
            backward_cost = sum(previousCost[(src_idx - j) % 26] for j in range(backward_steps))
            
            # Add the minimum cost to the total
            total_cost += min(forward_cost, backward_cost)
        
        return total_cost
",1460799443
Aniketshakya,Aniketshakya,910,3625,python,"class Solution(object):
    def canAliceWin(self, n):
        """"""
        :type n: int
        :rtype: bool
        """"""
        # Alice starts by removing 10 stones if possible
        current_move = 10  # Number of stones to remove in the current turn
        is_alice_turn = True  # Flag to track whose turn it is

        # Simulate the game
        while n > 0:
            if n >= current_move:
                # If there are enough stones, remove them
                n -= current_move
            else:
                # Not enough stones for the current move, the player loses
                return not is_alice_turn  # Return True if Alice wins, else False
            
            # Reduce the number of stones to remove for the next turn
            current_move -= 1
            # Switch turns
            is_alice_turn = not is_alice_turn
        
        # If we exit the loop, the player who made the last move wins
        return not is_alice_turn  # True if Alice wins, False if Bob wins
",1460796293
Bryan James,bryansamjames,911,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        long totalCost = 0;
        for (int i = 0; i < s.length(); i++) {
            char from = s.charAt(i);
            char to = t.charAt(i);
            if (from == to) continue;
            int fromIdx = from - 'a';
            int toIdx = to - 'a';
            int forwardShifts = (toIdx - fromIdx + 26) % 26;
            int backwardShifts = (fromIdx - toIdx + 26) % 26;
            long forwardCost = 0;
            long backwardCost = 0;
            for (int j = 0; j < forwardShifts; j++) {
                int currentIdx = (fromIdx + j) % 26;
                forwardCost += nextCost[currentIdx];
            }
            for (int j = 0; j < backwardShifts; j++) {
                int currentIdx = (fromIdx - j + 26) % 26;
                backwardCost += previousCost[currentIdx];
            }
            totalCost += Math.min(forwardCost, backwardCost);
        }
        return totalCost;
    }
}
",1460799452
Bryan James,bryansamjames,911,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10) {
            return false;
        }
        n -= 10;
        int stonesToRemove = 9;
        while (n >= stonesToRemove) {
            n -= stonesToRemove;
            stonesToRemove--;
        }
        return stonesToRemove % 2 == 1;
    }
}
",1460796765
Manojkumar Sirvi,sirvi_26,912,3591,cpp,"typedef long long ll ; 
class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        ll ans = 0 ; 
        
        for(ll i = 0 ; i<s.size() ; ++i)
        {
            char c = s[i] ; 
            ll cost1 = 0, cost2 = 0 ; 
            while(c!=t[i])
            {
                cost1+= (nextCost[c-'a']); 
                if(c=='z')
                    c = 'a' ; 
                else c++ ; 
            }
            c = s[i] ; 
            while(c!=t[i])
            {
                cost2+= (previousCost[c-'a']); 
                if(c=='a')
                    c = 'z' ; 
                else c-- ; 
            }
            ans+= min(cost1,cost2);  
            
        }
        
        return ans ; 
    }
};",1460810067
Manojkumar Sirvi,sirvi_26,912,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cnt = 10 ; 
        int t = 0 ; 
        while(n>0)
        {
            if(n<cnt)
            {
                if(t==0)
                    return false ; 
                return true ; 
            }
            n-=cnt ; 
            cnt-- ; 
            t^=1 ; 
        }
         if(t==0)
                    return false ; 
                return true ; 
    }
};",1460796890
Tanmay Pachauri,im_tpachauri,913,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
            
        long totalCost = 0; // Total minimum cost
        
        for (int i = 0; i < s.length(); i++) {
            int start = s.charAt(i) - 'a';
            int target = t.charAt(i) - 'a';
            
            // Compute forward distance
            int forwardDistance = (target - start + 26) % 26;
            // Compute backward distance
            int backwardDistance = (start - target + 26) % 26;
            
            // Calculate costs
            long forwardCost = 0;
            for (int j = 0; j < forwardDistance; j++) {
                forwardCost += nextCost[(start + j) % 26];
            }
            
            long backwardCost = 0;
            for (int j = 0; j < backwardDistance; j++) {
                backwardCost += previousCost[(start - j + 26) % 26];
            }
            
            // Add the minimum cost to the total cost
            totalCost += Math.min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }

    }
",1460810173
Tanmay Pachauri,im_tpachauri,913,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
         if (n < 10) {
            return false; // Alice cannot make a valid move
        }
        
        int stonesLeft = n - 10;
        int stonesToRemove = 9; // Bob's first turn
        
        // Simulate the game
        while (stonesLeft >= 0) {
            if (stonesLeft < stonesToRemove) {
                return true; // Bob cannot make a valid move, Alice wins
            }
            stonesLeft -= stonesToRemove;
            stonesToRemove--; // Next player removes one fewer stone
            
            if (stonesLeft < stonesToRemove) {
                return false; // Alice cannot make a valid move, Bob wins
            }
            stonesLeft -= stonesToRemove;
            stonesToRemove--; // Next player removes one fewer stone
        }
        
        return false;
    }
        
    }

",1460801956
ayush_0077,ayush_0077,914,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] previousCost) {
        int n = s.length();
        long totalCost = 0;
    
        for (int i = 0; i < n; i++) {
            int currentCharIndex = s.charAt(i) - 'a';
            int targetCharIndex = t.charAt(i) - 'a';
    
            int forwardSteps = (targetCharIndex - currentCharIndex + 26) % 26;
            long forwardCost = 0;
            for (int j = 0; j < forwardSteps; j++) {
                forwardCost += nextCost[(currentCharIndex + j) % 26];
            }
    
            int backwardSteps = (currentCharIndex - targetCharIndex + 26) % 26;
            long backwardCost = 0;
            for (int j = 0; j < backwardSteps; j++) {
                backwardCost += previousCost[(currentCharIndex - j + 26) % 26];
            }
    
            totalCost += Math.min(forwardCost, backwardCost);
        }
    
        return totalCost;
    }
}",1460810183
ayush_0077,ayush_0077,914,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10) return false;

        int stonesToRemove = 10; 
        boolean isAliceTurn = true;

        while (n > 0) {
            if (n < stonesToRemove) {
                return !isAliceTurn;
            }

            n -= stonesToRemove;
            stonesToRemove--;
            isAliceTurn = !isAliceTurn;
        }

        return !isAliceTurn;
    }
}",1460800324
Donavern,donavern,915,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        // pick any i of s
        // shift right, cost nextcost[char index]
        // shift left 

        long long result{};

        for(int i{}; i < s.size(); ++i)
        {
            if(s[i] == t[i])
                continue;

            const int charIndex = s[i] - 'a';
            const int targetIndex = t[i] - 'a';

            long long goLeft{}, goRight{};
            int index = charIndex;
            
            // go left
            while(index != targetIndex)
            {
                goLeft += previousCost[index];
                --index;
                
                if(index == -1)
                    index = 25;
            }

            index = charIndex;
            // go right
            while(index != targetIndex)
            {
                goRight += nextCost[index];
                ++index;

                if(index == 26)
                    index = 0;
            }
            
            result += min(goLeft, goRight);
        }

        return result;
    }
};",1460810200
Donavern,donavern,915,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int stones{10};
        bool aliceTurn{true};
        
        while(n >= stones)
        {
            n -= stones;
            --stones;
            aliceTurn = !aliceTurn;
        }

        if(aliceTurn)
            return false;
        return true;
    }
};",1460796234
rayyogesh0803,rayyogesh0803,916,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0; // To store the total minimum cost
        int n = s.length();     // Length of the strings
        
        for (int i = 0; i < n; i++) {
            int start = s[i] - 'a';  // Current character's index in alphabet
            int target = t[i] - 'a'; // Target character's index in alphabet
            
            if (start == target) continue; // No cost if characters are already the same
            
            // Forward distance (s[i] -> ... -> t[i])
            int forwardSteps = (target - start + 26) % 26;
            long long forwardCost = 0;
            int current = start;
            for (int j = 0; j < forwardSteps; j++) {
                forwardCost += nextCost[current];
                current = (current + 1) % 26;
            }
            
            // Backward distance (s[i] -> ... -> t[i])
            int backwardSteps = (start - target + 26) % 26;
            long long backwardCost = 0;
            current = start;
            for (int j = 0; j < backwardSteps; j++) {
                backwardCost += previousCost[current];
                current = (current - 1 + 26) % 26;
            }
            
            // Add the minimum of forward or backward cost
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};
",1460799651
rayyogesh0803,rayyogesh0803,916,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int currentStones = 10; // Alice starts by removing 10 stones
        bool isAliceTurn = true; // True if it's Alice's turn, false for Bob
        
        while (n > 0) {
            if (n >= currentStones) {
                // Player can remove the required stones
                n -= currentStones;
                currentStones--; // Next player removes 1 fewer stone
            } else {
                // Player cannot make the move, they lose
                return !isAliceTurn; // Alice wins if it's Bob's turn
            }
            isAliceTurn = !isAliceTurn; // Switch turns
        }
        
        return !isAliceTurn; // If n == 0, return true if Alice just played
    }
};
",1460796348
Nityansshe,Nityansshe,917,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost=0;

        
        int n=s.length();

        
        for (int i=0;i<n;i++) {



            
            int diff=(t[i]-s[i]+26)%26;
            long long forwardCost=0,backwardCost=0;


            
            for (int j=0;j<diff;j++) {
                forwardCost+=nextCost[(s[i]-'a'+j)%26];
            }

            
            for (int j=0;j<26-diff;j++) {
                backwardCost+=previousCost[(s[i]-'a'-j+26)%26];
            }


            
            totalCost+=min(forwardCost,backwardCost);
        }
        return totalCost;
    }
};

",1460810315
Nityansshe,Nityansshe,917,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int vanilla= 10;


        
        while (n>0) {
            if (n <vanilla) return false;
            n-= vanilla;

            
            vanilla--;

            
            if (n<vanilla) return true;
            n-= vanilla;
            vanilla --;
        }


        
        return false ;
    }
};
",1460799576
Joseph Mathew,Joseph_CSE23324,918,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalShiftCost = 0;

        for (int idx = 0; idx < s.length(); ++idx) {
            char currentChar = s[idx];
            char targetChar = t[idx];

            int stepsForward = (targetChar - currentChar + 26) % 26;
            int stepsBackward = (currentChar - targetChar + 26) % 26;

            long long forwardShiftCost = 0;
            long long backwardShiftCost = 0;

            for (int step = 0, charIdx = currentChar - 'a'; step < stepsForward; ++step) {
                forwardShiftCost += nextCost[charIdx];
                charIdx = (charIdx + 1) % 26;
            }

            for (int step = 0, charIdx = currentChar - 'a'; step < stepsBackward; ++step) {
                backwardShiftCost += previousCost[charIdx];
                charIdx = (charIdx - 1 + 26) % 26;
            }

            totalShiftCost += min(forwardShiftCost, backwardShiftCost);
        }

        return totalShiftCost;
    }
};
",1460810318
Joseph Mathew,Joseph_CSE23324,918,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int current = 10;
        bool isAliceChance = true;

        while(n > 0){
            if(n < current){
                return !isAliceChance;
            }
            n -= current;

            current--;
            isAliceChance = !isAliceChance;
            
        }
        return !isAliceChance;
    }
};",1460803355
Prabhat Bajpai,prabhat_bajpai,919,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nc, vector<int>& pc) {
        long long c=0;
        for(int i=0;i<s.size();i++){
            int r  = s[i]-'a';
            int g = t[i]-'a';
            int tr=r,tg=g;
            long long fwd =0;
            while(r!=g){
                fwd+=nc[r];
                r++;
                if(r==26) r=0;
            }
            long long bwd =0;
            r=tr;
            g=tg;
            while(r!=g){
                bwd+=pc[r];
                r--;
                if(r==-1) r=25;
            }
            c+=min(fwd,bwd);
        }
        return c;
    }
};",1460810326
Prabhat Bajpai,prabhat_bajpai,919,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int t = 10;
        int a =1;
        while(n>=t){
            n-=t;
            t--;
            if(a==1) a=0;
            else a=1;
        }
        return a==0;
    }
};",1460797342
Satish-K,Satish-K,920,3591,java,"class Solution {
    public long shiftDistance(String s, String t, int[] nextCost, int[] prevCost) {
        long total = 0;
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            int start = s.charAt(i) - 'a';
            int target = t.charAt(i) - 'a';
            
            int fwdDist = (target - start + 26) % 26;
            int bwdDist = (start - target + 26) % 26;
            
            long fwdCost = 0;
            long bwdCost = 0;
            
            for (int j = 0; j < fwdDist; j++) {
                fwdCost += nextCost[(start + j) % 26];
            }
            
            for (int j = 0; j < bwdDist; j++) {
                bwdCost += prevCost[(start - j + 26) % 26];
            }
            
            total += Math.min(fwdCost, bwdCost);
        }
        
        return total;
    }
}",1460810357
Satish-K,Satish-K,920,3625,java,"class Solution {
    public boolean canAliceWin(int n) {
        if (n < 10){
            return false;
        }
        int stones = 10;
        boolean alice = true;

        while (n > 0) {
            if (n < stones) {
                return !alice;
            }
            n -= stones;
            stones--; 
            alice = !alice;
        }
        return !alice;
    }
}",1460805656
Shivi0218,Shivi0218,921,3591,cpp,"class Solution {
public:
    long long shiftDistance(string si_18S, string si_18T, vector<int>& si_18NextCost, vector<int>& si_18PreviousCost) {
        long long si_18TotalCost = 0;

        for (int si_18I = 0; si_18I < si_18S.length(); ++si_18I) {
            int si_18Start = si_18S[si_18I] - 'a';
            int si_18End = si_18T[si_18I] - 'a';
            si_18TotalCost += calculateMinCost(si_18Start, si_18End, si_18NextCost, si_18PreviousCost);
        }

        return si_18TotalCost;
    }

private:
    long long calculateMinCost(int si_18Start, int si_18End, vector<int>& si_18NextCost, vector<int>& si_18PreviousCost) {
        int si_18ForwardSteps = (si_18End - si_18Start + 26) % 26;
        int si_18BackwardSteps = (si_18Start - si_18End + 26) % 26;

        long long si_18ForwardCost = 0;
        for (int si_18I = 0; si_18I < si_18ForwardSteps; ++si_18I) {
            si_18ForwardCost += si_18NextCost[(si_18Start + si_18I) % 26];
        }

        long long si_18BackwardCost = 0;
        for (int si_18I = 0; si_18I < si_18BackwardSteps; ++si_18I) {
            si_18BackwardCost += si_18PreviousCost[(si_18Start - si_18I + 26) % 26];
        }

        return min(si_18ForwardCost, si_18BackwardCost);
    }
};

",1460810502
Shivi0218,Shivi0218,921,3625,cpp,"class Solution {
public:
    bool canAliceWin(int si_18_N) {
        int si_18_stonesToRemove = 10;
        bool si_18_isAliceTurn = true;

        while (si_18_N > 0) {
            if (si_18_N < si_18_stonesToRemove) {
                return !si_18_isAliceTurn;
            }
            si_18_N -= si_18_stonesToRemove;
            si_18_stonesToRemove--;
            si_18_isAliceTurn = !si_18_isAliceTurn;
        }
        return !si_18_isAliceTurn;
    }
};
",1460801304
sagar,satyaki_,923,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        int n = s.length();
        
        for (int i = 0; i < n; i++) {
            int start = s[i] - 'a'; 
            int end = t[i] - 'a';   

            int fd = (end - start + 26) % 26;
            long long fc = 0;
            for (int j = 0; j < fd; j++) {
                fc += nextCost[(start + j) % 26];
            }

            int bd = (start - end + 26) % 26;
            long long bc = 0;
            for (int j = 0; j < bd; j++) {
                bc += previousCost[(start - j + 26) % 26];
            }

            ans += min(fc, bc);
        }
        
        return ans;
    }
};",1460810720
sagar,satyaki_,923,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int diff=10;
        bool check=true;
        while(n>0)
        {
            if(n<diff) return !check;
            n-=diff;
            diff--;
            check=!check;
        }
        return !check;
    }
};",1460803675
lusanyadav123,lusanyadav123,924,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long totalCost = 0; // Total cost to transform s into t
        
        for (int i = 0; i < s.size(); ++i) {
            int start = s[i] - 'a'; // Index of s[i] in the alphabet
            int target = t[i] - 'a'; // Index of t[i] in the alphabet
            
            // Forward cost: Moving from start to target
            long long forwardCost = 0; // Use long long
            int current = start;
            while (current != target) {
                forwardCost += (long long)nextCost[current]; // Explicit cast to long long
                current = (current + 1) % 26; // Move forward, handle wraparound
            }
            
            // Backward cost: Moving from start to target
            long long backwardCost = 0; // Use long long
            current = start;
            while (current != target) {
                backwardCost += (long long)previousCost[current]; // Explicit cast to long long
                current = (current - 1 + 26) % 26; // Move backward, handle wraparound
            }
            
            // Add the minimum cost for this character transformation
            totalCost += min(forwardCost, backwardCost);
        }
        
        return totalCost;
    }
};

",1460800255
lusanyadav123,lusanyadav123,924,3625,cpp,"
class Solution {
public:
    bool canAliceWin(int n) {
        int currentMove = 10; // Alice's first move
        bool isAliceTurn = true; // Track whose turn it is
        
        while (n > 0) {
            if (n < currentMove) {
                // If the current player cannot make a move, they lose
                return !isAliceTurn;
            }
            n -= currentMove; // Remove stones
            currentMove--; // Reduce the number of stones to be removed next turn
            isAliceTurn = !isAliceTurn; // Switch turn
        }
        
        // If we exit the loop, the last player who moved wins
        return !isAliceTurn;
    }
};
",1460797152
Harsh Pratap Singh,Harsh-Pratap-Singh,925,3591,cpp,"class Solution {
public:
    long long shiftDistance(string s, string t, vector<int>& nextCost, vector<int>& previousCost) {
        long long ans = 0;
        for(int i = 0;i < s.size();i ++){
            int st = s[i] - 'a';
            int end = t[i] - 'a';
            int fr = (end - st + 26)%26;
            int bc = (st - end + 26)%26;
            long long cfr = 0,cbc = 0;

            for(int j = 0;j < fr;j ++){
                cfr += nextCost[(st+j) %26];
            }
            for(int j = 0;j < bc; j++){
                cbc += previousCost[(st - j + 26) %26];
            }
            ans  += min(cbc,cfr);
        }
        return ans;
    }
};",1460810893
Harsh Pratap Singh,Harsh-Pratap-Singh,925,3625,cpp,"class Solution {
public:
    bool canAliceWin(int n) {
        int cur = 10;
        bool x = false;
        while(n > 0){
            if(n >= cur){
                n -= cur;
            }
            else{
                break;
            }
            cur--;
            x = !x;
        }
        return x;
    }
};",1460799672
