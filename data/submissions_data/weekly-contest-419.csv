username,userslug,contest_rank,question_id,language,code,submission_id
Saketh,fj26ZKcNjz,1,3509,cpp,"#include <vector>
#include <algorithm>
using namespace std;

// Definition for a binary tree node.
// (Assumed to be already defined by the platform, e.g., LeetCode)
// struct TreeNode {
//     int val;
//     TreeNode *left;
//     TreeNode *right;
//     TreeNode() : val(0), left(nullptr), right(nullptr) {}
//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
// };

class Solution {
public:
    vector<int> perfectSizes;
    
    pair<int, bool> dfs(TreeNode* node) {
        if (!node) {
            return {0, true};
        }
        
        pair<int, bool> left = dfs(node->left);
        pair<int, bool> right = dfs(node->right);
        
        if (left.second && right.second && left.first == right.first) {
            int currentHeight = left.first + 1;
            int size = (1 << currentHeight) - 1;
            perfectSizes.push_back(size);
            return {currentHeight, true};
        }
        
        return {max(left.first, right.first) + 1, false};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        perfectSizes.clear();
        dfs(root);
        
        if (perfectSizes.empty()) return -1;
        
        sort(perfectSizes.begin(), perfectSizes.end(), [&](const int a, const int b) -> bool {
            return a > b;
        });
        
        if (k > perfectSizes.size()) return -1;
        
        return perfectSizes[k-1];
    }
};
",1420519729
Saketh,fj26ZKcNjz,1,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        string lufrenixaq = s; 
        int dp[2][4][2001]; 
        memset(dp, 0, sizeof(dp));
        int curr = 0, next = 1;
        dp[curr][3][n] = 1; 
        for (int pos = 0; pos < n; ++pos) {
            memset(dp[next], 0, sizeof(dp[next]));
            for (int bob_prev_move = 0; bob_prev_move <= 3; ++bob_prev_move) {
                for (int scoreDiff = -n; scoreDiff <= n; ++scoreDiff) {
                    int dpVal = dp[curr][bob_prev_move][scoreDiff + n];
                    if (dpVal == 0) continue;
                    for (int bob_move = 0; bob_move <= 2; ++bob_move) {
                        if (pos > 0 && bob_prev_move != 3 && bob_move == bob_prev_move)
                            continue; 
                        int a_move = 0;
                        if (lufrenixaq[pos] == 'F') a_move = 0;
                        else if (lufrenixaq[pos] == 'W') a_move = 1;
                        else if (lufrenixaq[pos] == 'E') a_move = 2;
                        int res = 0;
                        if (a_move == bob_move) res = 0;
                        else if ((bob_move - a_move + 3) % 3 == 1) res = +1; 
                        else res = -1; 
                        int newScoreDiff = scoreDiff + res;
                        dp[next][bob_move][newScoreDiff + n] = (dp[next][bob_move][newScoreDiff + n] + dpVal) % MOD;
                    }
                }
            }
            swap(curr, next);
        }
        int ans = 0;
        for (int bob_prev_move = 0; bob_prev_move <= 2; ++bob_prev_move) {
            for (int scoreDiff = 1; scoreDiff <= n; ++scoreDiff) {
                ans = (ans + dp[curr][bob_prev_move][scoreDiff + n]) % MOD;
            }
        }
        return ans;
    }
};
",1420523759
Saketh,fj26ZKcNjz,1,3592,cpp,"#include <bits/stdc++.h>
using namespace std;

struct cmp_asc {
    bool operator() (const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first < b.first;
        return a.second < b.second;
    }
};

struct cmp_desc {
    bool operator() (const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first;
        return a.second > b.second;
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        if (n < k) return answer;

        vector<int> torsalveno = nums;

        unordered_map<int, int> freq_map;

        for(int i =0; i <k; i++) {
            freq_map[nums[i]]++;
        }

        vector<pair<int, int>> elements;
        for(auto &p: freq_map){
            elements.emplace_back(make_pair(p.second, p.first));
        }

        sort(elements.begin(), elements.end(), [&](const pair<int,int> &a, const pair<int,int> &b) -> bool{
            if(a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });

        set<pair<int, int>, cmp_asc> top_x;
        set<pair<int, int>, cmp_desc> rest;

        int count =0;
        long long sum_top_x =0;
        for(auto &p: elements){
            if(count < x){
                top_x.insert(p);
                sum_top_x += (long long)p.first * p.second;
                count++;
            }
            else{
                rest.insert(p);
            }
        }

        answer.push_back(sum_top_x);

        for(int i =1; i <= n -k; i++){
            int remove_val = nums[i-1];
            int prev_freq = freq_map[remove_val];
            freq_map[remove_val]--;

            pair<int, int> current_pair = make_pair(prev_freq, remove_val);

            auto it_top = top_x.find(current_pair);
            if(it_top != top_x.end()){
                top_x.erase(it_top);
                sum_top_x -= (long long)prev_freq * remove_val;

                if(freq_map[remove_val] >0){
                    pair<int, int> updated_pair = make_pair(freq_map[remove_val], remove_val);
                    rest.insert(updated_pair);
                }

                if(!rest.empty()){
                    auto it_rest = rest.begin(); 
                    pair<int, int> best_rest = *it_rest;
                    rest.erase(it_rest);
                    top_x.insert(best_rest);
                    sum_top_x += (long long)best_rest.first * best_rest.second;
                }
            }
            else{
                pair<int, int> updated_pair;
                if(prev_freq >0){
                    rest.erase(current_pair);
                }
                if(freq_map[remove_val] >0){
                    updated_pair = make_pair(freq_map[remove_val], remove_val);
                    rest.insert(updated_pair);
                }
            }

            int add_val = nums[i +k -1];
            int prev_freq_add = freq_map[add_val];
            freq_map[add_val]++;

            pair<int, int> before_add_pair = make_pair(prev_freq_add, add_val);

            pair<int, int> after_add_pair = make_pair(freq_map[add_val], add_val);

            bool was_in_top = false;
            if(prev_freq_add >0){
                auto it_top_add = top_x.find(before_add_pair);
                if(it_top_add != top_x.end()){
                    was_in_top = true;
                    top_x.erase(it_top_add);
                    sum_top_x -= (long long)before_add_pair.first * before_add_pair.second;
                }
                else{
                    auto it_rest_add = rest.find(before_add_pair);
                    if(it_rest_add != rest.end()){
                        rest.erase(it_rest_add);
                    }
                }
            }

            if(top_x.size() < x){
                top_x.insert(after_add_pair);
                sum_top_x += (long long)after_add_pair.first * after_add_pair.second;
            }
            else{
                auto it_smallest = top_x.begin(); 
                pair<int, int> smallest = *it_smallest;
                if(after_add_pair.first > smallest.first || 
                   (after_add_pair.first == smallest.first && after_add_pair.second > smallest.second)){
                    top_x.erase(it_smallest);
                    sum_top_x -= (long long)smallest.first * smallest.second;
                    top_x.insert(after_add_pair);
                    sum_top_x += (long long)after_add_pair.first * after_add_pair.second;
                    rest.insert(smallest);
                }
                else{
                    rest.insert(after_add_pair);
                }
            }

            if(was_in_top && freq_map[add_val] >0){
            
            }

            answer.push_back(sum_top_x);
        }

        return answer;
    }
};
",1420527328
Saketh,fj26ZKcNjz,1,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>
#include <set>
using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        
        for(int i = 0; i <= n - k; ++i){
            int freq[51] = {0};
            for(int j = i; j < i + k; ++j){
                freq[nums[j]]++;
            }
            
            vector<pair<int, int>> elements; 
            for(int num =1; num <=50; ++num){
                if(freq[num] >0){
                    elements.emplace_back(make_pair(freq[num], num));
                }
            }
            
            sort(elements.begin(), elements.end(), [&](const pair<int,int> &a, const pair<int,int> &b) -> bool{
                if(a.first != b.first){
                    return a.first > b.first;
                }
                return a.second > b.second;
            });
            
            set<int> topX;
            int distinct = elements.size();
            int limit = min(x, distinct);
            for(int m =0; m < limit; ++m){
                topX.insert(elements[m].second);
            }
            
            int sum =0;
            for(int j =i; j < i +k; ++j){
                if(topX.find(nums[j]) != topX.end()){
                    sum += nums[j];
                }
            }
            
            answer.push_back(sum);
        }
        
        return answer;
    }
};
",1420518520
cuy21,cuy21,2,3509,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution{
public:
    vector<int> p;

    struct Info{
        bool p;
        int h,s;
    };

    Info t(TreeNode*n){
        if(!n)return{true,0,0};
        auto L=t(n->left),R=t(n->right);
        bool ip=L.p&&R.p&&(L.h==R.h);
        int ht=max(L.h,R.h)+1,sz=L.s+R.s+1;
        if(ip)p.PB(sz);
        return{ip,ht,sz};
    }

    int kthLargestPerfectSubtree(TreeNode*r,int k){
        p.clear();
        t(r);
        if(p.empty())return-1;
        sort(p.begin(),p.end(),greater<int>());
        return k<=p.size()?p[k-1]:-1;
    }
};",1420537027
cuy21,cuy21,2,3588,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution {
public:
    int countWinningSequences(string s) {
        int n=s.length();
        string x=s;
        const int M=1'000'000'007;
        unordered_map<char,int> m={{'F',0},{'W',1},{'E',2}};
        int b[3]={2,0,1};
        vector<vector<long long>> cur(4,vector<long long>(2*n+1,0));
        cur[3][n]=1;
        FOR(i,0,n){
            vector<vector<long long>> nxt(4,vector<long long>(2*n+1,0));
            char a=s[i];
            int ai=m[a];
            FOR(l,0,4){
                FOR(d,0,2*n+1){
                    if(cur[l][d]==0)continue;
                    FOR(bb,0,3){
                        if(l!=3&&bb==l)continue;
                        int o=(b[bb]==ai)?1:((b[ai]==bb)?-1:0);
                        int nd=d+o;
                        if(nd<0||nd>2*n)continue;
                        nxt[bb][nd]=(nxt[bb][nd]+cur[l][d])%M;
                    }
                }
            }
            cur=move(nxt);
        }
        long long res=0;
        FOR(l,0,3){
            FOR(d,n+1,2*n+1)res=(res+cur[l][d])%M;
        }
        return (int)res;
    }

    vector<vector<long long>> move(vector<vector<long long>>&nxt){
        return nxt;
    }
};",1420528165
cuy21,cuy21,2,3592,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
struct cmp{
    bool operator()(const pi&a,const pi&b)const{
        if(a.F!=b.F)return a.F>b.F;
        return a.S>b.S;
    }
};

class Solution{
public:
    vll findXSum(vi&n,int k,int x){
        int sz=n.size(),t=k;
        vll a;
        if(sz<k)return a;
        unordered_map<int,int> f;
        FOR(i,0,k)f[n[i]]++;
        vector<pi> fl;
        FORE(p,f)fl.PB({p.S,p.F});
        sort(fl.begin(),fl.end(),cmp());
        set<pi,cmp> tp,rs;
        ll s=0;
        FOR(i,0,fl.size()){
            if(i<x){
                tp.insert(fl[i]);
                s+=(ll)fl[i].F*fl[i].S;
            }else rs.insert(fl[i]);
        }
        a.PB(s);
        FOR(i,k,sz){
            int o=n[i-k],in=n[i];
            int pf=f[o];
            pi op={pf,o};
            bool wt=false;
            auto t=tp.find(op);
            if(t!=tp.end()){
                wt=true;
                tp.erase(t);
                s-=(ll)op.F*op.S;
            }else{
                auto r=rs.find(op);
                if(r!=rs.end())rs.erase(r);
            }
            f[o]--;
            if(f[o]==0)f.erase(o);
            else rs.insert({f[o],o});
            if(wt&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }
            if(f.find(in)!=f.end()){
                int cf=f[in];
                pi cp={cf,in};
                auto t2=tp.find(cp);
                if(t2!=tp.end()){
                    tp.erase(t2);
                    s-=(ll)cp.F*cp.S;
                    f[in]++;
                    tp.insert({f[in],in});
                    s+=(ll)f[in]*in;
                }else{
                    auto r2=rs.find(cp);
                    if(r2!=rs.end())rs.erase(r2);
                    f[in]++;
                    rs.insert({f[in],in});
                }
            }else{
                f[in]=1;
                rs.insert({1,in});
            }
            if(tp.size()<(size_t)x&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }else if(!rs.empty()){
                auto t3=prev(tp.end());
                auto r3=rs.begin();
                if(cmp()(*r3,*t3)){
                    s+=(ll)r3->F*r3->S;
                    tp.insert(*r3);
                    rs.erase(r3);
                    s-=(ll)t3->F*t3->S;
                    rs.insert(*t3);
                    tp.erase(t3);
                }
            }
            a.PB(s);
        }
        return a;
    }
};",1420533176
cuy21,cuy21,2,3610,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
struct cmp{
    bool operator()(const pi&a,const pi&b)const{
        if(a.F!=b.F)return a.F>b.F;
        return a.S>b.S;
    }
};

class Solution{
public:
    vi findXSum(vi&n,int k,int x){
        int sz=n.size(),t=k;
        vi a;
        if(sz<k)return a;
        unordered_map<int,int> f;
        FOR(i,0,k)f[n[i]]++;
        vector<pi> fl;
        FORE(p,f)fl.PB({p.S,p.F});
        sort(fl.begin(),fl.end(),cmp());
        set<pi,cmp> tp,rs;
        ll s=0;
        FOR(i,0,fl.size()){
            if(i<x){
                tp.insert(fl[i]);
                s+=(ll)fl[i].F*fl[i].S;
            }else rs.insert(fl[i]);
        }
        a.PB(s);
        FOR(i,k,sz){
            int o=n[i-k],in=n[i];
            int pf=f[o];
            pi op={pf,o};
            bool wt=false;
            auto t=tp.find(op);
            if(t!=tp.end()){
                wt=true;
                tp.erase(t);
                s-=(ll)op.F*op.S;
            }else{
                auto r=rs.find(op);
                if(r!=rs.end())rs.erase(r);
            }
            f[o]--;
            if(f[o]==0)f.erase(o);
            else rs.insert({f[o],o});
            if(wt&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }
            if(f.find(in)!=f.end()){
                int cf=f[in];
                pi cp={cf,in};
                auto t2=tp.find(cp);
                if(t2!=tp.end()){
                    tp.erase(t2);
                    s-=(ll)cp.F*cp.S;
                    f[in]++;
                    tp.insert({f[in],in});
                    s+=(ll)f[in]*in;
                }else{
                    auto r2=rs.find(cp);
                    if(r2!=rs.end())rs.erase(r2);
                    f[in]++;
                    rs.insert({f[in],in});
                }
            }else{
                f[in]=1;
                rs.insert({1,in});
            }
            if(tp.size()<(size_t)x&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }else if(!rs.empty()){
                auto t3=prev(tp.end());
                auto r3=rs.begin();
                if(cmp()(*r3,*t3)){
                    s+=(ll)r3->F*r3->S;
                    tp.insert(*r3);
                    rs.erase(r3);
                    s-=(ll)t3->F*t3->S;
                    rs.insert(*t3);
                    tp.erase(t3);
                }
            }
            a.PB(s);
        }
        return a;
    }
};",1420535149
Shreyan Ray,Dominater069L,4,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        map <int, int> f;
        map <TreeNode*, int> sz;
        
        auto dfs = [&](auto self, TreeNode* u) -> bool {
            sz[u] = 1;
            bool good = true;
            if (u->left != nullptr){
                good &= self(self, u->left);
                sz[u] += sz[u->left];
            } 
            if (u->right != nullptr){
                good &= self(self, u->right);
                sz[u] += sz[u->right];
            }
            
            if ((u->left != nullptr) != (u->right != nullptr)){
                good = false;
            }
            
            if ((u -> left != nullptr) && (u->right != nullptr) && sz[u->left] != sz[u->right]){
                good = false;
            }
            
            if (good){
                f[-sz[u]] += 1;
                
              //  cout << ""GOOD "" << sz[u] << ""\n"";
            }
            return good;
        };
        
        dfs(dfs, root);
      //  cout << ""DONE\n"";
        
        int curr = 0;
        for (auto [x, y] : f){
            if (y + curr >= k){
                return -x;
            }
            curr += y;
        }
        
        return -1;
    }
};",1420537657
Shreyan Ray,Dominater069L,4,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        
        auto win = [&](int x, char ch){
            int y;
            if (ch == 'F'){
                y = 0;
            } else if (ch == 'W'){
                y = 1;
            } else {
                y = 2;
            }
            
            if (x == y) return 0;
            if ((x == 0 && y == 2) || (x == 1 && y == 0 ) || (x == 2 && y == 1)){
                return 1;
            }
            return -1;
        };
        
        const int mod = 1e9 + 7;
        
        vector <vector<int>> dp(2 * n + 1, vector<int>(3, 0));
        for (int i = 0; i < 3; i++){
            dp[n + win(i, s[0])][i] = 1;
        }
        
        for (int i = 1; i < n; i++){
            vector <vector<int>> ndp(2 * n + 1, vector<int>(3, 0));
            for (int j = 0; j <= 2 * n; j++){
                for (int k = 0; k < 3; k++){
                    if (dp[j][k] != 0){
                        for (int l = 0; l < 3; l++) if (l != k){
                            ndp[j + win(l, s[i])][l] += dp[j][k];
                            ndp[j + win(l, s[i])][l] %= mod;
                        }
                    }
                }
            }
            
            dp = ndp;
        }
        
        int ans = 0;
        for (int i = n + 1; i <= 2 * n; i++){
            for (int j = 0; j < 3; j++){
                ans += dp[i][j];
                ans %= mod;
            }
        }
        
        return ans;
    }
};",1420540799
Shreyan Ray,Dominater069L,4,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector <long long> ans;
        int n = nums.size();
        map <int, long long> f;
        long long sum = 0;
        set <pair<long long, int>> s1, s2;
        
        auto fix = [&](){
            while (s1.size() > x){
                auto id = *s1.begin();
                s1.erase(id);
                sum -= id.first * id.second;
                s2.insert(id);
            }  
            
            while (s1.size() && s2.size()){
                auto id1 = *(--s2.end());
                auto id2 = *(s1.begin());
                if (id1 > id2){
                    sum -= id2.first * id2.second;
                    s2.erase(id1);
                    s1.erase(id2);
                    s1.insert(id1);
                    s2.insert(id2);
                    sum += id1.first * id1.second;
                } else {
                    break;
                }
            }
        };
        
        auto add = [&](int x){
            if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]++;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        auto era = [&](int x){
              if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]--;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        for (int i = 0; i < k; i++){
            add(nums[i]);
        }
        
        ans.push_back(sum);
        // return ans;
        for (int i = k; i < n; i++){
            add(nums[i]);
            era(nums[i - k]);
            ans.push_back(sum);
        }
        return ans;
    }
};",1420527493
Shreyan Ray,Dominater069L,4,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector <long long> ans;
        int n = nums.size();
        map <int, long long> f;
        long long sum = 0;
        set <pair<long long, int>> s1, s2;
        
        auto fix = [&](){
            while (s1.size() > x){
                auto id = *s1.begin();
                s1.erase(id);
                sum -= id.first * id.second;
                s2.insert(id);
            }  
            
            while (s1.size() && s2.size()){
                auto id1 = *(--s2.end());
                auto id2 = *(s1.begin());
                if (id1 > id2){
                    sum -= id2.first * id2.second;
                    s2.erase(id1);
                    s1.erase(id2);
                    s1.insert(id1);
                    s2.insert(id2);
                    sum += id1.first * id1.second;
                } else {
                    break;
                }
            }
        };
        
        auto add = [&](int x){
            if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]++;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        auto era = [&](int x){
              if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]--;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        for (int i = 0; i < k; i++){
            add(nums[i]);
        }
        
        ans.push_back(sum);
        // return ans;
        for (int i = k; i < n; i++){
            add(nums[i]);
            era(nums[i - k]);
            ans.push_back(sum);
        }
        vector <int> ans2;
        for (auto x : ans) ans2.push_back(x);
        return ans2;
    }
};",1420528313
Anas_Maged,Anas_Maged,5,3509,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> a;
        auto dfs = [&](auto& self, TreeNode* node) -> pair<int, int>{
            if(node == nullptr) return {1, 0};
            bool ok = 1;
            auto f = self(self, node->left);
            auto s = self(self, node->right);
            ok &= f.first; ok &= s.first;
            int cnt = 1 + f.second + s.second;
            if(f.second != s.second) ok = 0;
            if(ok) a.push_back(cnt);
            return {ok, cnt};
        };
        dfs(dfs, root);
        sort(all(a), greater<int>());
        if(k > sz(a)) return -1;
        return a[--k];
    }
};",1420522089
Anas_Maged,Anas_Maged,5,3588,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


const int N = 1e3 + 5, M = 1e9 + 7;
int add(int a, int b){
    return (a + b) % M;
}
int mul(int a, int b){
    return 1ll * a * b % M;
}
string a = ""FEW$"";
string b = ""EWF$"";
int dp[N][N * 2][4], vis[N][N * 2][4], vid;

int rec(int i, int cur, int last, string& s){
    if(i == sz(s)) return cur > 0;
    int &ret = dp[i][cur + N][last];
    if(vis[i][cur + N][last] == vid) return ret;
    vis[i][cur + N][last] = vid;
    ret = 0;
    for(int j = 0; j < 3; j++){
        if(j == last) continue;
        int cost = 0;
        if(b[j] == s[i]) cost = 1;
        else if(s[i] == 'F' && a[j] == 'E') cost = -1;
        else if(s[i] == 'E' && a[j] == 'W') cost = -1;
        else if(s[i] == 'W' && a[j] == 'F') cost = -1;
        else if(s[i] != a[j]) assert(0);
        ret = add(ret, rec(i + 1, cur + cost, j, s));
    }
    return ret;
}

class Solution {
public:
    int countWinningSequences(string s) {
        vid++;
        return rec(0, 0, 3, s);
    }
};",1420531226
Anas_Maged,Anas_Maged,5,3592,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        map<int, int> mp;
        set<pair<int, int>> free, use;
        for(int i = 0; i < k; i++){
            mp[a[i]]++;
        }
        for(auto& [k, v] : mp){
            free.insert({v, k});
        }

        ll sum = 0;
        auto fix = [&](){
            while(sz(use) < x && !free.empty()){
                sum += 1ll * (*free.rbegin()).first * (*free.rbegin()).second;
                use.insert(*free.rbegin());
                free.erase(--free.end());
            }
            while(!free.empty() && !use.empty()){
                if(*use.begin() >= *free.rbegin()) break;
                auto x = *use.begin();
                auto y = *free.rbegin();
                sum -= 1ll * x.first * x.second;
                sum += 1ll * y.first * y.second;
                use.erase(use.begin());
                free.erase(--free.end());
                use.insert(y);
                free.insert(x);
            }
        };  

        auto del = [&](int x){
            if(use.count({mp[x], x})){
                sum -= 1ll * mp[x] * x;
                use.erase({mp[x], x});
            }
            else if(free.find({mp[x], x}) != free.end()){
                free.erase({mp[x], x});
            }
        };

        auto add = [&](int x){
            free.insert({mp[x], x});
        };


        fix();


        vector<ll> ans;
        ans.push_back(sum);
        for(int l = 0, r = k; r < sz(a); l++, r++){
            if(a[l] == a[r]){
                ans.push_back(sum);
                continue;
            }
            del(a[l]);
            del(a[r]);
            mp[a[l]]--; mp[a[r]]++;
            add(a[l]);
            add(a[r]);
            fix();
            ans.push_back(sum);
        }
        return ans;
    }
};",1420544533
Anas_Maged,Anas_Maged,5,3610,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for(int i = 0; i + k <= sz(nums); i++){
            map<int, int> mp;
            for(int j = i; j < i + k; j++){
                mp[nums[j]]++;
            }
            vector<pair<int, int>> a;
            for(auto it : mp){
                a.push_back({it.second, it.first});
            }
            sort(all(a));
            reverse(all(a));
            int sum = 0;
            for(int i = 0; i < min(x, sz(a)); i++){
                sum += a[i].second * a[i].first;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420519484
Nicholas,nicholask_17,6,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector <int> v;
    pair <int,int> dfs(TreeNode* root,int dep){
        int sz=1;
        int d=-1;
        if (root->left){
            pair <int,int> tp=dfs(root->left,dep+1);
            sz+=tp.first;
            if (d==-1) d=tp.second;
            else if (d!=-2&&d!=tp.second) d=-2;
            if (tp.second==-2) d=-2;
        } else d=dep;
        if (root->right){
            pair <int,int> tp=dfs(root->right,dep+1);
            sz+=tp.first;
            if (d==-1) d=tp.second;
            else if (d!=-2&&d!=tp.second) d=-2;
            if (tp.second==-2) d=-2;
        } else if (d!=dep) d=-2;
        if (d!=-2) v.push_back(sz);
        return {sz,d};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root,0);
        sort(v.begin(),v.end(),greater <int>());
        if (v.size()<k) return -1;
        return v[k-1];
    }
};",1420529110
Nicholas,nicholask_17,6,3588,cpp,"class Solution {
public:
const int mod=1e9+7;
    int countWinningSequences(string s) {
        int n=s.size();
        s="" ""+s;
        int dp[n+1][2*n+1][4];
        for (int i=0; i<=n; i++){
            for (int j=0; j<=2*n; j++){
                for (int k=0; k<4; k++) dp[i][j][k]=0;
            }
        }
        dp[0][n][0]=1;
        for (int i=0; i<n; i++){
            for (int j=n-i; j<=n+i; j++){
                for (int k=0; k<4; k++){
                    for (int l=1; l<4; l++){
                        if (k==l) continue;
                        int sc=j;
                        if (s[i+1]=='F'&&l==2) sc++;
                        else if (s[i+1]=='F'&&l==3) sc--;
                        else if (s[i+1]=='W'&&l==3) sc++;
                        else if (s[i+1]=='W'&&l==1) sc--;
                        else if (s[i+1]=='E'&&l==1) sc++;
                        else if (s[i+1]=='E'&&l==2) sc--;
                        dp[i+1][sc][l]+=dp[i][j][k];
                        dp[i+1][sc][l]%=mod;
                    }
                }
            }
        }
        int ans=0;
        for (int i=n+1; i<=2*n; i++){
            for (int j=1; j<=3; j++){
                ans+=dp[n][i][j];
                ans%=mod;
            }
        }
        return ans;
    }
};",1420524071
Nicholas,nicholask_17,6,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map <long long,long long> freq;
        set <pair <long long,long long>,greater <pair <long long,long long> > > s,wait;
        vector <long long> ret;
        for (int i=0; i<k; i++) freq[nums[i]]++;
        long long ans=0;
        for (auto i:freq){
            s.insert({i.second,i.first});
            ans+=i.first*i.second;
        }
        while (s.size()>x){
            pair <long long,long long> tp=*(--s.end());
            ans-=tp.first*tp.second;
            s.erase(tp);
            wait.insert(tp);
        }
        ret.push_back(ans);
        for (int i=1; i+k-1<nums.size(); i++){
            pair <long long,long long> tp={freq[nums[i-1]],nums[i-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else {
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i-1]]--;
            if (freq[nums[i-1]]){
                tp={freq[nums[i-1]],nums[i-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            tp={freq[nums[i+k-1]],nums[i+k-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else if (s.find(tp)!=s.end()){
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i+k-1]]++;
            {
                tp={freq[nums[i+k-1]],nums[i+k-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            ret.push_back(ans);
        }
        return ret;
    }
};",1420544732
Nicholas,nicholask_17,6,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        map <long long,long long> freq;
        set <pair <long long,long long>,greater <pair <long long,long long> > > s,wait;
        vector <int> ret;
        for (int i=0; i<k; i++) freq[nums[i]]++;
        long long ans=0;
        for (auto i:freq){
            s.insert({i.second,i.first});
            ans+=i.first*i.second;
        }
        while (s.size()>x){
            pair <long long,long long> tp=*(--s.end());
            ans-=tp.first*tp.second;
            s.erase(tp);
            wait.insert(tp);
        }
        ret.push_back(ans);
        for (int i=1; i+k-1<nums.size(); i++){
            pair <long long,long long> tp={freq[nums[i-1]],nums[i-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else {
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i-1]]--;
            if (freq[nums[i-1]]){
                tp={freq[nums[i-1]],nums[i-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            tp={freq[nums[i+k-1]],nums[i+k-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else if (s.find(tp)!=s.end()){
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i+k-1]]++;
            {
                tp={freq[nums[i+k-1]],nums[i+k-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            ret.push_back(ans);
        }
        return ret;
    }
};",1420545280
Dragos Ristache,MKLOL,7,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
vi rv;
pii dfs(TreeNode *root) {
    int ret = 0;
    if (root == NULL) {
        return {0,1};   
    }
    pii l = dfs(root->left);
    pii r = dfs(root->right);
    ret = 1 + l.fs + r.fs;
    if (l.fs == r.fs && l.sc && r.sc) {
        rv.pb(ret);
        return {ret, 1};
    } else {
        return {ret, 0};
    }

}

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        rv.clear();
        dfs(root);
        sort(all(rv));
        reverse(all(rv));
        --k;
        if (sz(rv) <= k) {
            return -1;
        }
        return rv[k];
    }
};",1420546100
Dragos Ristache,MKLOL,7,3588,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
typedef pair<int,pii> piii;
using namespace std;
#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;

int score(int x, int y) {
  if(x == y) return 0;
  if( (x == 0 && y == 2) || (x == 1 && y == 0) || (x == 2 && y == 1) ) return 1;
  return -1;
}

mint dp[3][1010][2050];

class Solution {
public:
    int countWinningSequences(string s) {
      map<char, int> h;
      h['E'] = 0;
      h['F'] = 1;
      h['W'] = 2;

      int N = sz(s);
      // init the first one
      FOR(k, 3) {
        FOR(i, N) {
          FOR(j, 2*N+5) {
            dp[k][i][j] = 0;
          }
        }
      }
      FOR(k, 3) {
        dp[k][0][score(k, h[s[0]]) + N] = 1;
      }

      FOR(i, N-1) {
        FOR(j, 2*N+3) {
          FOR(k, 3) {
            if(dp[k][i][j].x != 0) {
              FOR(l, 3) {
                if(l != k) {
                  dp[l][i+1][j + score(l, h[s[i+1]])] += dp[k][i][j];
                  //cout << ""WTF"" << endl;
                }
              }
            }
          }
        }
      }
      mint ret = 0;
      for(int j=N+1;j<=2*N+3;++j) {
        FOR(k, 3) {
          ret += dp[k][N-1][j];
        }
      }

      return ret.x;   
    }
};
",1420539041
Dragos Ristache,MKLOL,7,3592,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';


set<pll> SL,SR;
map<ll,ll> h;
ll ret;
int X;
void update() {
    if (sz(SL) < X && sz(SR)) {
        pll el = *SR.rbegin();
        SR.erase(el);
        SL.insert(el);
        ret += el.fs * el.sc;
    } else if (sz(SL) == X && sz(SR)) {
        pll elr = *SR.rbegin();
        pll ell = *SL.begin();
        if (elr > ell) {
            ret -= ell.fs * ell.sc;
            ret += elr.fs * elr.sc;
            SL.erase(ell);
            SR.erase(elr);
            SL.insert(elr);
            SR.insert(ell);
        }
    }
}

void add(pll x) {
    if (sz(SL) < X) {
        SL.insert(x);
        ret += x.fs * x.sc;
    } else {
        SR.insert(x);
    }
    update();
}

void rem(pll x) {
    if (SL.find(x) != SL.end()) {
        SL.erase(SL.find(x));
        ret -= x.fs * x.sc;
    }
    if (SR.find(x) != SR.end()) {
        SR.erase(SR.find(x));
    }
    update();
}

ll calc() {
    ll ret = 0;
    for (auto x : SL) {
        ret += x.fs * x.sc;
    }
    return ret;
}

class Solution {
public:
    vector<long long> findXSum(vector<int>& v, int k, int x) {
        h.clear();
        SL.clear();
        SR.clear();
        X = x;
        ret = 0;
        FOR(i, k) {
            h[v[i]]++;
        }
        for (auto x : h) {
            add({x.sc, x.fs});
        }
        vll rv;
        rv.pb(ret);
        for (int i=k;i<sz(v);++i) {
            int el = v[i];
            pll old = {h[el], el};
            rem(old);
            h[el]++;
            pll nw = {h[el], el};
            add(nw);
            
            
            pll oldl = {h[v[i-k]], v[i-k]};
            rem(oldl);
            h[v[i-k]]--;
            pll nl = {h[v[i-k]], v[i-k]};
            add(nl);
            
            rv.pb(ret);
        }
        return rv;
        
    }
};",1420531463
Dragos Ristache,MKLOL,7,3610,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';


set<pll> SL,SR;
map<ll,ll> h;
ll ret;
int X;
void update() {
    if (sz(SL) < X && sz(SR)) {
        pll el = *SR.rbegin();
        SR.erase(el);
        SL.insert(el);
        ret += el.fs * el.sc;
    } else if (sz(SL) == X && sz(SR)) {
        pll elr = *SR.rbegin();
        pll ell = *SL.begin();
        if (elr > ell) {
            ret -= ell.fs * ell.sc;
            ret += elr.fs * elr.sc;
            SL.erase(ell);
            SR.erase(elr);
            SL.insert(elr);
            SR.insert(ell);
        }
    }
}

void add(pll x) {
    if (sz(SL) < X) {
        SL.insert(x);
        ret += x.fs * x.sc;
    } else {
        SR.insert(x);
    }
    update();
}

void rem(pll x) {
    if (SL.find(x) != SL.end()) {
        SL.erase(SL.find(x));
        ret -= x.fs * x.sc;
    }
    if (SR.find(x) != SR.end()) {
        SR.erase(SR.find(x));
    }
    update();
}

ll calc() {
    ll ret = 0;
    for (auto x : SL) {
        ret += x.fs * x.sc;
    }
    return ret;
}

class Solution {
public:
    vi findXSum(vector<int>& v, int k, int x) {
        h.clear();
        SL.clear();
        SR.clear();
        X = x;
        ret = 0;
        FOR(i, k) {
            h[v[i]]++;
        }
        for (auto x : h) {
            add({x.sc, x.fs});
        }
        vi rv;
        rv.pb(ret);
        for (int i=k;i<sz(v);++i) {
            int el = v[i];
            pll old = {h[el], el};
            rem(old);
            h[el]++;
            pll nw = {h[el], el};
            add(nw);
            
            
            pll oldl = {h[v[i-k]], v[i-k]};
            rem(oldl);
            h[v[i-k]]--;
            pll nl = {h[v[i-k]], v[i-k]};
            add(nl);
            
            rv.pb(ret);
        }
        return rv;
        
    }
};",1420546921
Ma Lin,Ma_Lin,8,3509,cpp,"class Solution {
public:
    int i, j;
    map<TreeNode*, int> height;
    map<TreeNode*, bool> perf;
    vector<int> res;
    
    void dfs(TreeNode* p){
        if (p->left == NULL && p->right == NULL){
            perf[p] = true;
            height[p] = 1;
            res.push_back((1<<height[p]) - 1);
            return;
        }
        
        TreeNode *l = p->left, *r = p->right;
        
        if (l != NULL) dfs(l);
        if (r != NULL) dfs(r);
        perf[p] = (l != NULL && r != NULL && perf[l] && perf[r] && height[l] == height[r]);
        if (l != NULL) height[p] = height[l] + 1;
        else height[p] = height[r] + 1;
        if (perf[p]) res.push_back((1<<height[p]) - 1);
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int K) {
        height.clear();
        perf.clear();
        res.clear();
        dfs(root);
        sort(res.begin(), res.end());
        reverse(res.begin(), res.end());
        if (K > res.size()) return -1;
        return res[K - 1];
    }
};",1420523526
Ma Lin,Ma_Lin,8,3588,cpp,"class Solution {
public:
    int f[1005][3][2005];
    int countWinningSequences(string s) {
        int mo = 1000000007, a[1005], i, j, k, h, n = s.size();
        int yh[3][3];
        for (i = 0; i < n; ++i){
            if (s[i] == 'F') a[i] = 0;
            if (s[i] == 'W') a[i] = 1;
            if (s[i] == 'E') a[i] = 2;
        }
        
        for (i = 0; i < 3; ++i)
            for (j = 0; j < 3; ++j){
                yh[i][j] = 0;
                if (j == (i + 1) % 3) yh[i][j] = 1;
                if (j == (i + 2) % 3) yh[i][j] = -1;
            }
        
        for (j = 0; j < 3; ++j){
            for (k = 0; k <= n + n; ++k) f[0][j][k] = 0;
            f[0][j][n + yh[a[0]][j]] = 1;
        }
        
        for (i = 1; i < n; ++i)
            for (j = 0; j < 3; ++j){
                for (k = 0; k <= n + n; ++k) f[i][j][k] = 0;
                for (h = 0; h < 3; ++h){
                    if (h == j) continue;
                    for (k = 0; k <= n + n; ++k)
                        if (f[i - 1][h][k] != 0)
                            f[i][j][k + yh[a[i]][j]] = (f[i][j][k + yh[a[i]][j]] + f[i - 1][h][k]) % mo;
                }
            }
        
        int res = 0;
        for (j = 0; j < 3; ++j)
            for (k = n + 1; k <= n + n; ++k) 
                res = (res + f[n - 1][j][k]) % mo;
            
        return res;
    }
};",1420532006
Ma Lin,Ma_Lin,8,3592,cpp,"class Solution {
public:
    set<pair<int, int> > S, down;
    unordered_map<int, int> f;
    long long sum;
    int top;
    
    bool xiao(pair<int, int> a, pair<int, int> b){
        if (a.first < b.first) return true;
        if (a.first > b.first) return false;
        return a.second < b.second;
    }
    
    void change(int v, int d){
        pair<int, int> t = {f[v], v};
        if (S.count(t)){
            sum -= 1LL * f[v] * v;
            S.erase(t);
        }
        else down.erase(t);
        
        f[v] += d;
        t = {f[v], v};
        if (down.size() > 0 && xiao(t, *prev(down.end()))) down.insert(t);
        else{
            S.insert(t);
            sum += 1LL * f[v] * v;
        }
        
        while (down.size() > 0 && S.size() < top){
            t = *prev(down.end());
            down.erase(t);
            sum += 1LL * t.first * t.second;
            S.insert(t);
        }
        
        while (S.size() > top){
            t = *S.begin();
            sum -= 1LL * t.first * t.second;
            down.insert(t);
            S.erase(t);
        }
    }
    
    vector<long long> findXSum(vector<int>& a, int K, int tt) {
        top = tt;
        vector<long long> res;
        S.clear();
        down.clear();
        f = unordered_map<int, int>();
        sum = 0;
        int n = a.size(), q, i, j, k;
        
        for (i = 0; i < n; ++i){
            pair<int, int> t;
            if (i - K >= 0) change(a[i - K], -1);
            change(a[i], 1);
            if (i >= K - 1) res.push_back(sum);
        }
        
        return res;
    }
};",1420547078
Ma Lin,Ma_Lin,8,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int K, int x) {
        int i, j, n = a.size(), r;
        vector<int> res;
        for (i = 0; i <= n - K; ++i){
            map<int, int> f;
            set<pair<int, int> > S;
            for (j = i; j < i + K; ++j) f[a[j]]++;
            for (auto p : f) S.insert({p.second, p.first});
            r = 0;
            for (j = 0; j < x && S.size() > 0; ++j){
                auto p = prev(S.end());
                r += p->first * p->second;
                S.erase(p);
            }
            
            res.push_back(r);
        }
        
        return res;
    }
};",1420519407
arignote,arignote,11,3509,java,"class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        ArrayList<Integer> list = new ArrayList<>();
        kthLargestPerfectSubtree(root, list);
        Collections.sort(list);
        return k > list.size() ? -1 : list.get(list.size() - k);
    }
    private int kthLargestPerfectSubtree(TreeNode root, ArrayList<Integer> list) {
        if (root == null) {
            return 0;
        }
        int left = kthLargestPerfectSubtree(root.left, list), right = kthLargestPerfectSubtree(root.right, list);
        if (left < 0 || left != right) {
            return -1;
        }
        list.add((1 << left + 1) - 1);
        return left + 1;
    }
}",1420549464
arignote,arignote,11,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int dp[][][] = new int[s.length()][2 * s.length() + 3][3], count = 0;
        dp[0][s.length()][s.charAt(0) == 'F' ? 2 : s.charAt(0) == 'W' ? 0 : 1] = 1;
        dp[0][s.length() + 1][s.charAt(0) == 'F' ? 0 : s.charAt(0) == 'W' ? 1 : 2] = 1;
        dp[0][s.length() + 2][s.charAt(0) == 'F' ? 1 : s.charAt(0) == 'W' ? 2 : 0] = 1;
        for (int i = 1; i < s.length(); i++) {
            for (int j = 1; j < 2 * s.length() + 2; j++) {
                dp[i][j] = new int[] { (dp[i - 1][j + (s.charAt(i) == 'W' ? 1 : s.charAt(i) == 'E' ? -1 : 0)][1] + dp[i - 1][j + (s.charAt(i) == 'W' ? 1 : s.charAt(i) == 'E' ? -1 : 0)][2]) % 1000000007, (dp[i - 1][j + (s.charAt(i) == 'E' ? 1 : s.charAt(i) == 'F' ? -1 : 0)][0] + dp[i - 1][j + (s.charAt(i) == 'E' ? 1 : s.charAt(i) == 'F' ? -1 : 0)][2]) % 1000000007, (dp[i - 1][j + (s.charAt(i) == 'F' ? 1 : s.charAt(i) == 'W' ? -1 : 0)][0] + dp[i - 1][j + (s.charAt(i) == 'F' ? 1 : s.charAt(i) == 'W' ? -1 : 0)][1]) % 1000000007 };
            }
        }
        for (int i = s.length() + 2; i < 2 * s.length() + 2; i++) {
            count = (((count + dp[s.length() - 1][i][0]) % 1000000007 + dp[s.length() - 1][i][1]) % 1000000007 + dp[s.length() - 1][i][2]) % 1000000007;
        }
        return count;
    }
}",1420549304
arignote,arignote,11,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        TreeSet<long[]> left = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(o[1], p[1]) : Long.compare(o[0], p[0])), right = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(p[1], o[1]) : Long.compare(p[0], o[0]));
        HashMap<Integer, long[]> map = new HashMap<>();
        long sum = 0;
        long[] result = new long[nums.length - k + 1];
        for (int i = 0; i < nums.length; i++) {
            if (left.contains(map.getOrDefault(nums[i], new long[2]))) {
                left.remove(map.get(nums[i]));
                sum -= nums[i] * map.get(nums[i])[0];
            }
            right.remove(map.getOrDefault(nums[i], new long[2]));
            map.put(nums[i], new long[] { map.getOrDefault(nums[i], new long[1])[0] + 1, nums[i] });
            right.add(map.get(nums[i]));
            if (i >= k - 1) {
                while (left.size() < x && !right.isEmpty()) {
                    sum += right.first()[0] * right.first()[1];
                    left.add(right.pollFirst());
                }
                result[i - k + 1] = sum;
                if (left.contains(map.getOrDefault(nums[i - k + 1], new long[2]))) {
                    left.remove(map.get(nums[i - k + 1]));
                    sum -= nums[i - k + 1] * map.get(nums[i - k + 1])[0];
                }
                right.remove(map.getOrDefault(nums[i - k + 1], new long[2]));
                map.put(nums[i - k + 1], new long[] { map.getOrDefault(nums[i - k + 1], new long[1])[0] - 1, nums[i - k + 1] });
                right.add(map.get(nums[i - k + 1]));
                if (!left.isEmpty()) {
                    sum -= left.first()[0] * left.first()[1];
                    right.add(left.pollFirst());
                }
            }
        }
        return result;
    }
}",1420549082
arignote,arignote,11,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        TreeSet<long[]> left = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(o[1], p[1]) : Long.compare(o[0], p[0])), right = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(p[1], o[1]) : Long.compare(p[0], o[0]));
        HashMap<Integer, long[]> map = new HashMap<>();
        int sum = 0;
        int[] result = new int[nums.length - k + 1];
        for (int i = 0; i < nums.length; i++) {
            if (left.contains(map.getOrDefault(nums[i], new long[2]))) {
                left.remove(map.get(nums[i]));
                sum -= nums[i] * map.get(nums[i])[0];
            }
            right.remove(map.getOrDefault(nums[i], new long[2]));
            map.put(nums[i], new long[] { map.getOrDefault(nums[i], new long[1])[0] + 1, nums[i] });
            right.add(map.get(nums[i]));
            if (i >= k - 1) {
                while (left.size() < x && !right.isEmpty()) {
                    sum += right.first()[0] * right.first()[1];
                    left.add(right.pollFirst());
                }
                result[i - k + 1] = sum;
                if (left.contains(map.getOrDefault(nums[i - k + 1], new long[2]))) {
                    left.remove(map.get(nums[i - k + 1]));
                    sum -= nums[i - k + 1] * map.get(nums[i - k + 1])[0];
                }
                right.remove(map.getOrDefault(nums[i - k + 1], new long[2]));
                map.put(nums[i - k + 1], new long[] { map.getOrDefault(nums[i - k + 1], new long[1])[0] - 1, nums[i - k + 1] });
                right.add(map.get(nums[i - k + 1]));
                if (!left.isEmpty()) {
                    sum -= left.first()[0] * left.first()[1];
                    right.add(left.pollFirst());
                }
            }
        }
        return result;
    }
}",1420549664
scanhex,scanhex,12,3509,cpp,"
using namespace std;
using nagai=long long;
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        std::map<TreeNode*, int> de, sz, cnt;
        vector<int> szs;
        auto dfs = [&](TreeNode* x, auto dfs) -> void {
            sz[x] = 1;
            de[x] = 0;
            if (x->left) {
                dfs(x->left, dfs);
                sz[x] += sz[x->left];
                de[x] = max(de[x], 1 + de[x->left]);
            }
            if (x->right) {
                dfs(x->right, dfs);
                sz[x] += sz[x->right];
                de[x] = max(de[x], 1 + de[x->right]);
            }
            if (sz[x] == ((1 << (de[x] + 1)) - 1)) {
                szs.push_back(sz[x]);
            }
        };
        dfs(root, dfs);
        sort(szs.rbegin(), szs.rend());
        --k;
        if (k < szs.size()) {
            return szs[k];
        }
        return -1;
    }
};

",1420523621
scanhex,scanhex,12,3588,cpp,"
using namespace std;
using nagai = long long;
class Solution {
public:
  int countWinningSequences(string s) {
    auto ord = [&](char ch) { return ch == 'F' ? 0 : ch == 'W' ? 1 : 2; };
    const int mod = 1e9 + 7;
    int n = s.size();
    int MX = 2 * n + 5;
    int ZERO = n + 2;
    vector<vector<int>> dp(MX, vector<int>(3));
    for (int cc = 0; cc < n; ++cc) {
      char ch = s[cc];
      auto dp1 = vector<vector<int>>(MX, vector<int>(3));
      int o = ord(ch);
      for (int i = 0; i < MX; ++i) {
        for (int bob = 0; bob < 3; ++bob) {
          int df = (bob == o ? 0 : bob == (o + 2) % 3 ? -1 : 1);
          if (cc == 0) {
            if (i == ZERO)
              dp1[i + df][bob] += 1;
          } else {
            for (int last = 0; last < 3; ++last) {
              if (last == bob)
                continue;
              if (i + df >= 0 && i + df < MX) {
                dp1[i + df][bob] += dp[i][last];
                if (dp1[i + df][bob] >= mod) {
                  dp1[i + df][bob] -= mod;
                }
              }
            }
          }
        }
      }
      dp = dp1;
    }
    int ans = 0;
    for (int i = ZERO + 1; i < MX; ++i) {
      for (int j = 0; j < 3; ++j) {
        ans += dp[i][j];
        if (ans >= mod) {
          ans -= mod;
        }
      }
    }
    return ans;
  }
};

",1420533739
scanhex,scanhex,12,3592,cpp,"
using namespace std;
using nagai = long long;
class Solution {
public:
  vector<long long> findXSum(vector<int> &nums, int k, int X) {
    set<std::pair<int, int>> st;
    nagai s = 0;
    set<std::pair<int, int>> rest;
    map<int, int> cnt;
    auto add = [&](int x) {
      auto p = std::pair(cnt[x], x);
      s += 1LL * p.first * p.second;
      st.insert(p);
      if (st.size() > X) {
        auto rofl = *st.begin();
        s -= 1LL * rofl.first * rofl.second;
        st.erase(rofl);
        rest.insert(rofl);
      }
    };
    auto rem = [&](int x) {
      auto p = std::pair(cnt[x], x);
      if (st.count(p)) {
        st.erase(p);
        s -= 1LL * p.first * p.second;
      }
      rest.erase(p);
      while (rest.size() && st.size() < X) {
        auto rofl = *rest.rbegin();
        rest.erase(rofl);
        st.insert(rofl);
        s += 1LL * rofl.first * rofl.second;
      }
    };
    for (int i = 0; i < k; ++i) {
      int x = nums[i];
      rem(x);
      ++cnt[x];
      add(x);
    }
    std::vector<long long> res;
    for (int i = 0; i + k <= nums.size(); ++i) {
      res.push_back(s);
      if (i + k < nums.size()) {
        rem(nums[i + k]);
        ++cnt[nums[i + k]];
        add(nums[i + k]);
        rem(nums[i]);
        --cnt[nums[i]];
        add(nums[i]);
      }
    }
    return res;
  }
};

",1420544267
scanhex,scanhex,12,3610,cpp,"
using namespace std;
using nagai = int;
class Solution {
public:
  vector<int> findXSum(vector<int> &nums, int k, int X) {
    set<std::pair<int, int>> st;
    nagai s = 0;
    set<std::pair<int, int>> rest;
    map<int, int> cnt;
    auto add = [&](int x) {
      auto p = std::pair(cnt[x], x);
      s += 1LL * p.first * p.second;
      st.insert(p);
      if (st.size() > X) {
        auto rofl = *st.begin();
        s -= 1LL * rofl.first * rofl.second;
        st.erase(rofl);
        rest.insert(rofl);
      }
    };
    auto rem = [&](int x) {
      auto p = std::pair(cnt[x], x);
      if (st.count(p)) {
        st.erase(p);
        s -= 1LL * p.first * p.second;
      }
      rest.erase(p);
      while (rest.size() && st.size() < X) {
        auto rofl = *rest.rbegin();
        rest.erase(rofl);
        st.insert(rofl);
        s += 1LL * rofl.first * rofl.second;
      }
    };
    for (int i = 0; i < k; ++i) {
      int x = nums[i];
      rem(x);
      ++cnt[x];
      add(x);
    }
    std::vector<int> res;
    for (int i = 0; i + k <= nums.size(); ++i) {
      res.push_back(s);
      if (i + k < nums.size()) {
        rem(nums[i + k]);
        ++cnt[nums[i + k]];
        add(nums[i + k]);
        rem(nums[i]);
        --cnt[nums[i]];
        add(nums[i]);
      }
    }
    return res;
  }
};

",1420545357
Joshua Arrazola,JArrazola,13,3509,cpp,"class Solution {
public:
    struct Result {
        bool isPerfect;
        int height;
        int size;
    };
    
    vector<int> sizes; 

    Result helper(TreeNode* root) {
        if (!root) {
            return {true, -1, 0};
        }
        
        Result left = helper(root->left);
        Result right = helper(root->right);
        
        bool isPerfect = left.isPerfect && right.isPerfect && (left.height == right.height);
        int height = left.height + 1;
        int size = left.size + right.size + 1;
        
        if (isPerfect) {
            sizes.push_back(size);
        }
        
        return {isPerfect, height, size};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        helper(root);
        
        if (sizes.size() < k) {
            return -1;
        }
        
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k - 1];
    }
};
",1420524416
Joshua Arrazola,JArrazola,13,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.length();
        vector<int> s_vec(n);
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') s_vec[i] = 0;
            else if (s[i] == 'W') s_vec[i] = 1;
            else s_vec[i] = 2; 
        }
        int max_delta = 2 * n + 1;
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(4, vector<int>(max_delta, 0)));
        int curr = 0;
        dp[curr][3][n] = 1;
        for (int pos = 0; pos < n; ++pos) {
            int alice_move = s_vec[pos];
            dp[1 - curr] = vector<vector<int>>(4, vector<int>(max_delta, 0));
            for (int prev_bob = 0; prev_bob < 4; ++prev_bob) {
                for (int delta = -n; delta <= n; ++delta) {
                    int count = dp[curr][prev_bob][delta + n];
                    if (count == 0) continue;
                    for (int curr_bob = 0; curr_bob < 3; ++curr_bob) {
                        if (prev_bob != curr_bob) {
                            int battle_result;
                            if (curr_bob == alice_move) battle_result = 0;
                            else if ((curr_bob - alice_move + 3) % 3 == 1) battle_result = 1;
                            else battle_result = -1;
                            int delta_prime = delta + battle_result;
                            if (delta_prime < -n || delta_prime > n) continue;
                            dp[1 - curr][curr_bob][delta_prime + n] = (dp[1 - curr][curr_bob][delta_prime + n] + count) % MOD;
                        }
                    }
                }
            }
            curr = 1 - curr;
        }
        int total = 0;
        for (int prev_bob = 0; prev_bob < 3; ++prev_bob) {
            for (int delta = 1; delta <= n; ++delta) {
                total = (total + dp[curr][prev_bob][delta + n]) % MOD;
            }
        }
        return total;
    }
};",1420530023
Joshua Arrazola,JArrazola,13,3592,cpp,"
class Solution {
public:
    struct Node {
        Node *left, *right;
        int freq, val, size;
        long long sum;
        int priority;
        Node(int f, int v) : left(nullptr), right(nullptr), freq(f), val(v), size(1), sum((long long)f * v), priority(rand()) {}
        
        void update() {
            size = 1;
            sum = (long long)freq * val;
            if (left) {
                size += left->size;
                sum += left->sum;
            }
            if (right) {
                size += right->size;
                sum += right->sum;
            }
        }
        
        bool operator<(const Node& other) const {
            if (freq != other.freq)
                return freq > other.freq; 
            else
                return val > other.val;   
        }
    };

    void split(Node* node, Node*& left, Node*& right, const Node& key) {
        if (!node) {
            left = right = nullptr;
        } else if (*node < key) {
            split(node->right, node->right, right, key);
            left = node;
        } else {
            split(node->left, left, node->left, key);
            right = node;
        }
        if (node) node->update();
    }

    void merge(Node*& node, Node* left, Node* right) {
        if (!left || !right) {
            node = left ? left : right;
        } else if (left->priority > right->priority) {
            merge(left->right, left->right, right);
            node = left;
        } else {
            merge(right->left, left, right->left);
            node = right;
        }
        if (node) node->update();
    }

    void insert(Node*& node, Node* item) {
        if (!node) {
            node = item;
        } else if (item->priority > node->priority) {
            split(node, item->left, item->right, *item);
            node = item;
        } else if (*item < *node) {
            insert(node->left, item);
        } else {
            insert(node->right, item);
        }
        if (node) node->update();
    }

    void erase(Node*& node, const Node& key) {
        if (!node) return;
        if (node->freq == key.freq && node->val == key.val) {
            Node* temp = node;
            merge(node, node->left, node->right);
            delete temp;
        } else if (key < *node) {
            erase(node->left, key);
        } else {
            erase(node->right, key);
        }
        if (node) node->update();
    }

    long long getSum(Node* node, int k) {
        if (!node || k <= 0) return 0;
        int lsize = node->left ? node->left->size : 0;
        if (lsize >= k) {
            return getSum(node->left, k);
        } else {
            long long res = node->left ? node->left->sum : 0;
            res += (long long)node->freq * node->val;
            if (lsize + 1 == k) {
                return res;
            } else {
                return res + getSum(node->right, k - lsize - 1);
            }
        }
    }

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        unordered_map<int, int> freq;
        Node* root = nullptr;

        for (int i = 0; i < k; ++i) {
            int num = nums[i];
            int f = freq[num];
            if (f > 0) {
                erase(root, Node(f, num));
            }
            freq[num] = f + 1;
            insert(root, new Node(freq[num], num));
        }

        vector<long long> answer;

        for (int i = 0; i <= n - k; ++i) {
            long long sum = getSum(root, x);
            answer.push_back(sum);

            if (i + k == n) break;

            int out_num = nums[i];
            int in_num = nums[i + k];

            int f = freq[out_num];
            erase(root, Node(f, out_num));
            freq[out_num] = f - 1;
            if (freq[out_num] > 0) {
                insert(root, new Node(freq[out_num], out_num));
            } else {
                freq.erase(out_num);
            }

            f = freq[in_num];
            if (f > 0) {
                erase(root, Node(f, in_num));
            }
            freq[in_num] = f + 1;
            insert(root, new Node(freq[in_num], in_num));
        }

        destroy(root);

        return answer;
    }

    void destroy(Node* node) {
        if (!node) return;
        destroy(node->left);
        destroy(node->right);
        delete node;
    }
};",1420539494
Joshua Arrazola,JArrazola,13,3610,cpp,"
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        unordered_map<int, int> counts;
        map<int, set<int>> count_to_elements; 

        for (int i = 0; i < k; ++i) {
            int e = nums[i];
            int old_count = counts[e];
            counts[e]++;
            int new_count = counts[e];

            if (old_count > 0) {
                count_to_elements[old_count].erase(e);
                if (count_to_elements[old_count].empty()) {
                    count_to_elements.erase(old_count);
                }
            }
            count_to_elements[new_count].insert(e);
        }

        for (int i = 0; i <= n - k; ++i) {
            if (i > 0) {
                int e = nums[i - 1];
                int old_count = counts[e];
                counts[e]--;
                int new_count = counts[e];

                count_to_elements[old_count].erase(e);
                if (count_to_elements[old_count].empty()) {
                    count_to_elements.erase(old_count);
                }

                if (new_count > 0) {
                    count_to_elements[new_count].insert(e);
                } else {
                    counts.erase(e);
                }

                e = nums[i + k -1];
                old_count = counts[e];
                counts[e]++;
                new_count = counts[e];

                if (old_count > 0) {
                    count_to_elements[old_count].erase(e);
                    if (count_to_elements[old_count].empty()) {
                        count_to_elements.erase(old_count);
                    }
                }
                count_to_elements[new_count].insert(e);
            }

            int elements_collected = 0;
            vector<int> top_elements;
            for (auto rit = count_to_elements.rbegin(); rit != count_to_elements.rend(); ++rit) {
                int count = rit->first;
                auto& elements_set = rit->second;
                for (auto sit = elements_set.rbegin(); sit != elements_set.rend(); ++sit) {
                    int e = *sit;
                    top_elements.push_back(e);
                    elements_collected++;
                    if (elements_collected == x) break;
                }
                if (elements_collected == x) break;
            }
            int sum_x = 0;
            for (int e : top_elements) {
                sum_x += counts[e] * e;
            }
            answer.push_back(sum_x);
        }

        return answer;
    }
};

",1420529546
robezh765,robezh765,15,3509,cpp,"
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef pair<vi, vi> pvi;

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vi fres;
    pii dfs(TreeNode *cur) {
        pii res = {-1, -1};
        vector<pii> vs;
        for (auto nxt : {cur->left, cur->right}) {
            if (nxt == nullptr) continue;
            pii to = dfs(nxt);
            vs.push_back(to);
        }
        if(sz(vs) == 0) {
            fres.push_back(1);
            return {1, 1};
        }
        if(sz(vs) == 1) return {-1, vs[0].second};
        if(vs[0].first == -1 || vs[1].first == -1) return {-1, max(vs[0].second, vs[1].second)};
        if(vs[0].first == vs[1].first)  {
            fres.push_back(vs[0].first * 2 + 1);
            return {vs[0].first * 2 + 1, vs[0].first * 2 + 1};

        };
        return {-1, max(vs[0].second, vs[1].second)};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        fres.clear();
        dfs(root);
        // for (int x : fres ) cout << x << "" "";
        // cout << endl;
        sort(all(fres));
        reverse(all(fres));
        return sz(fres) < k ? -1 : fres[k - 1];
    }
};

",1420527354
robezh765,robezh765,15,3588,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef pair<vi, vi> pvi;

const int mod = (int)1e9 + 7;
class Solution {
public:
    int countWinningSequences(string s) {
        int n = sz(s);
        vvvi dp(n, vvi(2 * n + 2, vi(3, 0)));
        int mid = n + 1;
        map<char, int> mp;
        mp['F'] = 0, mp['W'] = 1, mp['E'] = 2;
        auto gscore = [&](int a, int b) {
            if(a == (b + 1) % 3) return 1;
            else if(a == b) return 0;
            else return -1;
        };
        rep(i, 0, 3) {
            dp[0][mid + gscore(i, mp[s[0]])][i] = 1;
        }
        auto gdp = [&](int i, int j, int k) {
            if(0 <= j && j < 2 * n + 2) return dp[i][j][k];
            return 0;
        };
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 2 * n + 2; j++) {
                rep(l, 0, 3) {
                    rep(p, 0, 3) {
                        if(p == l) continue;
                        (dp[i][j][p] += gdp(i - 1, j - gscore(p, mp[s[i]]), l)) %= mod;
                    }
                }
            }
        }
        int sum = 0;
        rep(i, mid + 1, 2 * n + 2) {
            rep(l, 0, 3) {
                sum += dp[n - 1][i][l];
                sum %= mod;
            }
        }
        return sum;
    }
};",1420538951
robezh765,robezh765,15,3592,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef pair<vi, vi> pvi;

struct Set {
    set<pii> L, R;
    int x;
    ll sum = 0;
    Set(int x): x(x) {
    }
    void del(pii p) {
        if(L.find(p) != L.end()) {
            L.erase(p);
        } else {
            assert(R.find(p) != R.end());
            sum -= 1LL * p.first * p.second;
            R.erase(p);
        }
        balance();

    }
    void ins(pii p) {
        if(!L.empty() && L.rbegin()->first > p.first) {
            L.insert(p);

        } else {
            R.insert(p);
            sum += 1LL * p.first * p.second;
        }
        balance();

    }
    void balance() {
        while(!L.empty() && sz(R) < x) {
            auto it = --L.end();
            R.insert(*it);
            sum += 1LL * it->first * it->second;
            L.erase(it);
        }
        while(sz(R) > x) {
            auto it = R.begin();
            L.insert(*it);
            sum -= 1LL * it->second * it->first;
            R.erase(it);
        }
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> cnt;
        Set S(x);
        vector<ll> res;
        auto add = [&](int val, int off) {
            if (cnt[val] != 0) S.del({cnt[val], val});
            cnt[val] += off;
            if (cnt[val] != 0) S.ins({cnt[val], val});
        };
        int n = sz(nums);
        rep(i, 0, k) add(nums[i], 1);
        rep(i, 0, n - k + 1) {
            res.push_back(S.sum);
            if(i != n - k) {
                add(nums[i + k], 1);
                add(nums[i], -1);
            }
        }
        return res;
    }
};",1420553177
robezh765,robezh765,15,3610,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef pair<vi, vi> pvi;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = sz(nums);
        vi res;
        rep(i, 0, n - k + 1) {
            map<int, int> mp;
            rep(j, i, i + k) {
                mp[nums[j]]++;
            }
            vector<pii> vs;
            for(auto p : mp) {
                vs.push_back({p.second, p.first});
            }
            sort(all(vs));
            reverse(all(vs));
            int sum = 0;
            rep(j, 0, min(sz(vs), x)) {
                sum += vs[j].first * vs[j].second;
            }
            res.push_back(sum);
        }
        return res;

    }
};

",1420519662
Dylan Smith,DylanSmith,16,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ops;
    int rec(TreeNode *root) {
        if (!root) return 0;
        int l = rec(root->left), r = rec(root->right);
        if (l != -1 && r != -1 && l == r) {
            ops.push_back((1 << l + 1) - 1);
            return l + 1;
        }
        return -1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        ops.clear();
        rec(root);
        sort(ops.begin(), ops.end());
        reverse(ops.begin(), ops.end());
        if (k - 1 >= (int)ops.size()) return -1;
        return ops[k - 1];
    }
};",1420544178
Dylan Smith,DylanSmith,16,3588,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

int mod = 1000000007;

class Solution {
public:
    int countWinningSequences(string s) {
        int N = sz(s);
        vector<int> a;
        for (char c : s) {
            if (c == 'F') a.pb(0);
            else if (c == 'W') a.pb(1);
            else a.pb(2);
        }
        vector<vector<int>> dp(2 * N + 1, vector<int>(3, 0)), nxt(2 * N + 1, vector<int>(3, 0));
        for (int i = 0; i < 3; i++) {
            int dif = i == a[0] ? 0 : i == (a[0] + 1) % 3 ? 1 : -1;
            dp[N + dif][i]++;
        }
        for (int i = 1; i < N; i++) {
            for (int j = 0; j <= 2 * N; j++) fill(all(nxt[j]), 0);
            for (int j = 0; j <= 2 * N; j++) {
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < 3; l++) {
                        if (l == k) continue;
                        int dif = l == a[i] ? 0 : l == (a[i] + 1) % 3 ? 1 : -1;
                        if (j + dif >= 0 && j + dif <= 2 * N) {
                            nxt[j + dif][l] += dp[j][k];
                            if (nxt[j + dif][l] >= mod) nxt[j + dif][l] -= mod;
                        }
                    }
                }
            }
            swap(dp, nxt);
        }
        int res = 0;
        for (int i = N + 1; i <= N * 2; i++) {
            for (int j = 0; j < 3; j++) {
                res += dp[i][j];
                if (res >= mod) res -= mod;
            }
        }
        return res;
    }
};",1420554793
Dylan Smith,DylanSmith,16,3592,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> freq;
        ll curSum = 0;
        set<pair<int, int>> bad, good;
        vector<ll> res;
        for (int i = 0; i < sz(nums); i++) {
            if (freq[nums[i]]) {
                if (bad.count({freq[nums[i]], nums[i]})) {
                    bad.erase({freq[nums[i]], nums[i]});
                } else {
                    good.erase({freq[nums[i]], nums[i]});
                    curSum -= (ll)freq[nums[i]] * nums[i];
                }
            }
            freq[nums[i]]++;
            bad.insert({freq[nums[i]], nums[i]});
            if (i - k >= 0) {
                if (bad.count({freq[nums[i-k]], nums[i-k]})) {
                    bad.erase({freq[nums[i-k]], nums[i-k]});
                } else {
                    good.erase({freq[nums[i-k]], nums[i-k]});
                    curSum -= (ll)freq[nums[i - k]] * nums[i - k];
                }
                freq[nums[i - k]]--;
                if (freq[nums[i - k]]) {
                    bad.insert({freq[nums[i-k]], nums[i-k]});
                }
            }
            while (!bad.empty() && sz(good) < x) {
                pair<int, int> a = *prev(bad.end());
                bad.erase(a);
                good.insert(a);
                curSum += (ll)a.first * a.second;
            }
            while (!bad.empty() && !good.empty()) {
                pair<int, int> a = *prev(bad.end()), b = *good.begin();
                if (a.first > b.first || a.first == b.first && a.second > b.second) {
                    bad.erase(a);
                    good.erase(b);
                    curSum -= (ll)b.first * b.second;
                    bad.insert(b);
                    good.insert(a);
                    curSum += (ll)a.first * a.second;
                } else break;
            }
            if (i - k + 1 >= 0) {
                res.push_back(curSum);
            }
        }
        return res;
    }
};",1420537068
Dylan Smith,DylanSmith,16,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int N = (int)nums.size();
        vector<int> res;
        for (int i = 0; i + k - 1 < N; i++) {
            map<int, int> freq;
            for (int j = 0; j < k; j++) {
                freq[nums[i + j]]++;
            }
            vector<pair<int, int>> srt;
            for (auto &p : freq) srt.push_back({p.second, p.first});
            sort(srt.begin(), srt.end());
            reverse(srt.begin(), srt.end());
            int sum = 0;
            for (int i = 0; i < min(x, (int)srt.size()); i++) {
                sum += srt[i].second * srt[i].first;
            }
            res.push_back(sum);
        }
        return res;
    }
};",1420519452
Khoi Nam,Cookie_Cream,18,3509,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vt<int>res;
    struct th{
        int siz, depth, ok;
    };
    th dfs(TreeNode *root){
        if(root->left == nullptr && root->right == nullptr){
            th cool = {1, 0, 1};
            res.pb(1);
            return(cool);
        }
        int siz = 0;
        bool ok = 1;
        th lson, rson;
        if(root->left != nullptr){
            lson = dfs(root->left);
            ok &= lson.ok; siz += lson.siz;
        }else{
            ok = 0;
        }
        if(root->right != nullptr){
            rson = dfs(root->right);
            ok &= rson.ok; siz += rson.siz;
        }else{
            ok = 0; 
        }
        int depth = 0;
        if(ok){
            depth = lson.depth + 1;
            ok &= (lson.depth == rson.depth); 
        }
        siz++;
        if(ok)res.pb(siz);
        th res = {siz, depth, ok};
        return(res);
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        res.clear();
        dfs(root);
        sort(ALLR(res));
        if(sz(res) < k)return(-1);
        return(res[k - 1]);
    }
};",1420528405
Khoi Nam,Cookie_Cream,18,3588,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
const int mod = 1e9 + 7;
class Solution {
public:
    int dp[1005][2005][3];
    int coef(int id, char c){
        if(c == 'F'){
            if(id == 0)return(0);
            if(id == 1)return(1);
            return(-1);
        }else if(c == 'W'){
            if(id == 0)return(-1);
            if(id == 1)return(0);
            return(1);
        }else{
            if(id == 2)return(0);
            if(id == 1)return(-1);
            return(1);
        }
    }
    void add(int &a, int b){
        a += b;
        if(a >= mod)a -= mod;
    }
    int countWinningSequences(string s) {
        int n = sz(s);
        for(int i = 0; i <= sz(s); i++){
            for(int j = 0; j <= 2 * sz(s); j++){
                for(int k = 0; k < 3; k++){
                    dp[i][j][k] = 0;
                }
            }
        }
        for(int i = 0; i < 3; i++){
            dp[0][n + coef(i, s[0])][i] = 1;
        }
        for(int i = 0; i < sz(s) - 1; i++){
            for(int j = 0; j <= 2 * n; j++){
                for(int k = 0; k < 3; k++){
                    if(dp[i][j][k] == 0)continue;
                    for(int l = 0; l < 3; l++){
                        if(l != k){
                            add(dp[i + 1][j + coef(l, s[i + 1])][l], dp[i][j][k]);
                        }
                    }
                }
            }
        }
        int ans = 0;
        for(int i = n + 1; i <= 2 * n; i++){
            for(int j = 0; j < 3; j++){
                add(ans, dp[sz(s) - 1][i][j]);
            }
        }
        return(ans);
    }
};",1420536009
Khoi Nam,Cookie_Cream,18,3592,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        multiset<pll>low, high;
        vt<ll>res;
        map<int, int>mp;
        for(auto i: nums)mp[i] = 0;
        for(int i = 0; i < k; i++)mp[nums[i]]++;
        vt<pll>cand;
        for(auto i: mp)cand.pb(mpp(i.se, i.fi));
        sort(ALLR(cand));
        ll ans = 0;
        for(int i = 0; i < min(x, sz(cand)); i++){
            low.insert(cand[i]); ans += 1LL * cand[i].se * cand[i].fi;
        }
        for(int i = x; i < sz(cand); i++){
            high.insert(cand[i]);
        }
        res.pb(ans);
        for(int i = 1; i + k <= sz(nums); i++){
            
            pll cool = mpp(mp[nums[i - 1]], nums[i - 1]);
            if(low.find(cool) != low.end()){
                low.erase(low.find(cool)); ans -= cool.fi * cool.se;
            }
            if(high.find(cool) != high.end()){
                high.erase(high.find(cool)); 
            }
            mp[nums[i - 1]]--;
            cool = mpp(mp[nums[i - 1]], nums[i - 1]);
            high.insert(cool);
            cool = mpp(mp[nums[i + k - 1]], nums[i + k - 1]);
            if(low.find(cool) != low.end()){
                low.erase(low.find(cool)); ans -= cool.fi * cool.se;
            }
            if(high.find(cool) != high.end()){
                high.erase(high.find(cool)); 
            }
            mp[nums[i + k - 1]]++;
            
            cool = mpp(mp[nums[i + k - 1]], nums[i + k - 1]);
            high.insert(cool);
            while(sz(low) < x && sz(high)){
                auto it = *high.rbegin();
                ans += it.fi * it.se;
                high.erase(it); low.insert(it);
            }
            while(sz(high) && (*high.rbegin()) > (*low.begin())){
                auto itl = *low.begin(), itr = *high.rbegin();
                ans -= itl.fi * itl.se; ans += itr.fi * itr.se;
                low.erase(itl); high.erase(itr);
                low.insert(itr); high.insert(itl);
            }
            res.pb(ans);
        }
        return(res);
    }
};",1420549527
Khoi Nam,Cookie_Cream,18,3610,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vt<int>ret;
        for(int i = 0; i + k <= sz(nums); i++){
            map<int, int>mp;
            for(int j = i; j < i + k; j++)mp[nums[j]]++;
            vt<pll>res;
            for(auto j: mp)res.pb(mpp(j.se, j.fi));
            sort(ALLR(res));
            ll ans = 0;
           
            for(int j = 0; j < min(x, sz(res)); j++){
               // cout << res[j].se << "" "" << res[j].fi << "" "";
                ans += 1LL * res[j].se * res[j].fi;
            }
            ret.pb(ans);
        }
        return(ret);
    }
};",1420520578
uwi,uwi,23,3509,java,"	class Solution {
		List<Integer> all = new ArrayList<>();

		public int kthLargestPerfectSubtree(TreeNode root, int k) {
			dfs(root);
			Collections.sort(all);
			k--;
			if(k >= all.size())return -1;
			return all.get(all.size() - 1 - k);
		}

		public int[] dfs(TreeNode cur)
		{
			if(cur == null)return new int[]{0, -1};
			int[] l = dfs(cur.left);
			int[] r = dfs(cur.right);
			int[] ret = {
					l[0] + r[0] + 1,
					Math.max(l[1], r[1]) + 1
			};
			if((1<<ret[1]+1)-1 == ret[0]){
				all.add(ret[0]);
			}
			return ret;
		}
	}
",1420524338
uwi,uwi,23,3588,java,"	class Solution {
		String U = ""FWE"";

		public int comp(char a, char b)
		{
			int ai = U.indexOf(a);
			int bi = U.indexOf(b);
			if((bi - ai + 3) % 3 == 1)return 1;
			if((bi - ai + 3) % 3 == 2)return -1;
			return 0;
		}

		public int countWinningSequences(String S) {
			char[] s = S.toCharArray();
			int n = s.length;
			// F E: F win
			// W F: W win
			// E W: E win
			final int mod = 1000000007;
			long[][] dp = new long[2*n+1][3];
			for(int i = 0;i < 3;i++){
				dp[n+comp(s[0], U.charAt(i))][i]++;
			}
			for(int i = 1;i < n;i++){
				long[][] ndp = new long[2*n+1][3];
				for(int j = 0;j <= 2*n;j++){
					for(int k = 0;k < 3;k++){
						if(dp[j][k] == 0)continue;
						for(int l = 0;l < 3;l++){
							if(k == l)continue;
							int nj = j + comp(s[i], U.charAt(l));
							ndp[nj][l] += dp[j][k];
							ndp[nj][l] %= mod;
						}
					}
				}
				dp = ndp;
			}
			int ans = 0;
			for(int i = n+1;i <= 2*n;i++){
				for(int j = 0;j < 3;j++){
					ans += dp[i][j];
					ans %= mod;
				}
			}
			return ans;
		}
	}
",1420532365
uwi,uwi,23,3592,java,"	class Solution {
		public long[] findXSum(int[] nums, int K, int X) {
			int n = nums.length;
			Node root = null;
			Map<Integer, Node> val = new HashMap<>();
			long[] ret = new long[n-K+1];
			for(int i = 0;i < n;i++){
				int v = nums[i];
				Node t = val.get(v);
				if(t == null){
					t = new Node(v, 1);
					val.put(v, t);
				}else{
					root = erase(root, index(t));
					t.f++;
					update(t);
				}
				root = insertb(root, t);

				if(i >= K-1) {
					ret[i-(K-1)] = sum(root, Math.max(count(root) - X, 0), count(root));

					Node u = val.get(nums[i-(K-1)]);
					root = erase(root, index(u));
					u.f--;
					update(u);
					root = insertb(root, u);
				}
			}
			return ret;
		}

		public static Random gen = new Random();

		static public class Node
		{
			public int f;
			public long v; // value
			public long priority;
			public Node left, right, parent;

			public int count;

			public long sum;

			public Node(int v, int f)
			{
				this.f = f;
				this.v = v;
				priority = gen.nextLong();
				update(this);
			}

			@Override
			public String toString() {
				StringBuilder builder = new StringBuilder();
				builder.append(""Node [v="");
				builder.append(v);
				builder.append("", f="");
				builder.append(f);
				builder.append("", count="");
				builder.append(count);
				builder.append("", parent="");
				builder.append(parent != null ? parent.v : ""null"");
				builder.append("", sum="");
				builder.append(sum);
				builder.append(""]"");
				return builder.toString();
			}
		}

		public static Node update(Node a)
		{
			if(a == null)return null;
			a.count = 1;
			if(a.left != null)a.count += a.left.count;
			if(a.right != null)a.count += a.right.count;

			a.sum = (long)a.v * a.f;
			if(a.left != null)a.sum += a.left.sum;
			if(a.right != null)a.sum += a.right.sum;
			return a;
		}

		public static Node disconnect(Node a)
		{
			if(a == null)return null;
			a.left = a.right = a.parent = null;
			return update(a);
		}

		public static Node root(Node x)
		{
			if(x == null)return null;
			while(x.parent != null)x = x.parent;
			return x;
		}

		public static int count(Node a)
		{
			return a == null ? 0 : a.count;
		}

		public static void setParent(Node a, Node par)
		{
			if(a != null)a.parent = par;
		}

		public static long sum(Node a, int L, int R)
		{
			if(a == null || L >= R || L >= count(a) || R <= 0)return 0L;
			if(L <= 0 && R >= count(a)){
				return a.sum;
			}else{
				long ret = 0;
				ret += sum(a.left, L, R);
				ret += sum(a.right, L-count(a.left)-1, R-count(a.left)-1);
				if(L <= count(a.left) && count(a.left) < R)ret += (long)a.v * a.f;
				return ret;
			}
		}

		public static Node merge(Node a, Node b)
		{
			if(b == null)return a;
			if(a == null)return b;
			if(a.priority > b.priority){
				setParent(a.right, null);
				setParent(b, null);
				a.right = merge(a.right, b);
				setParent(a.right, a);
				return update(a);
			}else{
				setParent(a, null);
				setParent(b.left, null);
				b.left = merge(a, b.left);
				setParent(b.left, b);
				return update(b);
			}
		}

		// [0,K),[K,N)
		public static Node[] split(Node a, int K)
		{
			if(a == null)return new Node[]{null, null};
			if(K <= count(a.left)){
				setParent(a.left, null);
				Node[] s = split(a.left, K);
				a.left = s[1];
				setParent(a.left, a);
				s[1] = update(a);
				return s;
			}else{
				setParent(a.right, null);
				Node[] s = split(a.right, K-count(a.left)-1);
				a.right = s[0];
				setParent(a.right, a);
				s[0] = update(a);
				return s;
			}
		}

		public static Node insert(Node a, int K, Node b)
		{
			if(a == null)return b;
			if(b.priority < a.priority){
				if(K <= count(a.left)){
					a.left = insert(a.left, K, b);
					setParent(a.left, a);
				}else{
					a.right = insert(a.right, K-count(a.left)-1, b);
					setParent(a.right, a);
				}
				return update(a);
			}else{
				Node[] ch = split(a, K);
				b.left = ch[0]; b.right = ch[1];
				setParent(b.left, b);
				setParent(b.right, b);
				return update(b);
			}
		}

		public static Node insertb(Node root, Node x)
		{
			int ind = search(root, (int)x.v, x.f);
			if(ind < 0){
				// insert
				ind = -ind-1;
				return insert(root, ind, x);
			}else{
				return insert(root, ind, x);

				//			// add
				//			Node t = get(root, ind);
				//			t.v += x.v;
				//			while(t != null){
				//				update(t);
				//				t = t.parent;
				//			}
				//			return root;
			}
		}

		// delete K-th
		public static Node erase(Node a, int K)
		{
			if(a == null)return null;
			if(K < count(a.left)){
				a.left = erase(a.left, K);
				setParent(a.left, a);
				return update(a);
			}else if(K == count(a.left)){
				setParent(a.left, null);
				setParent(a.right, null);
				Node aa = merge(a.left, a.right);
				disconnect(a);
				return aa;
			}else{
				a.right = erase(a.right, K-count(a.left)-1);
				setParent(a.right, a);
				return update(a);
			}
		}

		public static Node get(Node a, int K)
		{
			while(a != null){
				if(K < count(a.left)){
					a = a.left;
				}else if(K == count(a.left)){
					break;
				}else{
					K = K - count(a.left)-1;
					a = a.right;
				}
			}
			return a;
		}

//		public static int lowerBound(Node a, int q)
//		{
//			int lcount = 0;
//			while(a != null){
//				if(a.v >= q){
//					a = a.left;
//				}else{
//					lcount += count(a.left) + 1;
//					a = a.right;
//				}
//			}
//			return lcount;
//		}

		public static int search(Node a, int q, int f)
		{
			int lcount = 0;
			while(a != null){
				if(f == a.f && q == a.v){
					lcount += count(a.left);
					break;
				}
				if(f < a.f || f == a.f && q < a.v){
					a = a.left;
				}else{
					lcount += count(a.left) + 1;
					a = a.right;
				}
			}
			return a == null ? -(lcount+1) : lcount;
		}

		public static int index(Node a)
		{
			if(a == null)return -1;
			int ind = count(a.left);
			while(a != null){
				Node par = a.parent;
				if(par != null && par.right == a){
					ind += count(par.left) + 1;
				}
				a = par;
			}
			return ind;
		}

		public static Node[] nodes(Node a) { return nodes(a, new Node[count(a)], 0, count(a)); }
		public static Node[] nodes(Node a, Node[] ns, int L, int R)
		{
			if(a == null)return ns;
			nodes(a.left, ns, L, L+count(a.left));
			ns[L+count(a.left)] = a;
			nodes(a.right, ns, R-count(a.right), R);
			return ns;
		}

		public static String toString(Node a, String indent)
		{
			if(a == null)return """";
			StringBuilder sb = new StringBuilder();
			sb.append(toString(a.left, indent + ""  ""));
			sb.append(indent).append(a).append(""\n"");
			sb.append(toString(a.right, indent + ""  ""));
			return sb.toString();
		}

	}
",1420554403
uwi,uwi,23,3610,java,"	class Solution {
		public int[] findXSum(int[] nums, int k, int x) {
			int n = nums.length;
			int[] ret = new int[n-k+1];
			for(int i = 0;i+k <= n;i++){
				int[] f = new int[51];
				for(int j = i;j < i+k;j++){
					f[nums[j]]++;
				}
				int[][] fi = new int[51][];
				for(int j = 0;j < 51;j++){
					fi[j] = new int[]{f[j], j};
				}
				Arrays.sort(fi, (z ,y) -> {
					if(z[0] != y[0])return -(z[0] - y[0]);
					return -(z[1] - y[1]);
				});
				int s = 0;
				for(int j = 0;j < x;j++){
					s += fi[j][0] * fi[j][1];
				}
				ret[i] = s;
			}
			return ret;
		}
	}
",1420520208
lqCKWBPxHc,lqCKWBPxHc,24,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(node):
            if not node:
                return (True, 0, 0)

            if not node.left and not node.right:
                subtree_sizes.append(1)
                return (True, 1, 1)

            left_perfect, left_height, left_size = dfs(node.left) if node.left else (True, 0, 0)
            right_perfect, right_height, right_size = dfs(node.right) if node.right else (True, 0, 0)

            if left_perfect and right_perfect and left_height == right_height:
                current_size = 1 + left_size + right_size
                subtree_sizes.append(current_size)
                return (True, left_height + 1, current_size)

            return (False, max(left_height, right_height) + 1, 0)

        subtree_sizes = []
        dfs(root)

        if len(subtree_sizes) < k:
            return -1

        subtree_sizes.sort(reverse=True)
        return subtree_sizes[k-1]",1420532889
lqCKWBPxHc,lqCKWBPxHc,24,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        creature_to_number = {'F':1, 'W':2, 'E':3}
        DP = [[[0]*(2*n+1) for _ in range(4)] for _ in range(n+1)]
        DP[0][0][n] = 1
        for i in range(n):
            s_i = s[i]
            c_alice = creature_to_number[s_i]
            for b in range(4):
                for d in range(2*n+1):
                    val = DP[i][b][d]
                    if val == 0:
                        continue
                    for c in range(1,4):
                        if c == b:
                            continue
                        if c == c_alice:
                            score = 0
                        elif (c - c_alice + 3) % 3 == 1:
                            score = 1
                        else:
                            score = -1
                        d_new = d + score
                        if 0 <= d_new <= 2*n:
                            DP[i+1][c][d_new] = (DP[i+1][c][d_new] + val) % MOD
        ans = 0
        for b in range(1,4):
            for d in range(n+1, 2*n+1):
                ans = (ans + DP[n][b][d]) % MOD
        return ans",1420529030
lqCKWBPxHc,lqCKWBPxHc,24,3592,python3,"from sortedcontainers import SortedList
class Solution:
    class Node:
        def __init__(self, key, cnt_value):
            self.key = key  # (count, value)
            self.left = None
            self.right = None
            self.priority = random.random()
            self.size = 1
            self.sum = cnt_value
            self.cnt_value = cnt_value

    def update(self, node):
        if node:
            node.size = 1
            node.sum = node.cnt_value
            if node.left:
                node.size += node.left.size
                node.sum += node.left.sum
            if node.right:
                node.size += node.right.size
                node.sum += node.right.sum

    def split(self, root, key):
        if not root:
            return (None, None)
        if root.key > key:
            left, right = self.split(root.left, key)
            root.left = right
            self.update(root)
            return (left, root)
        else:
            left, right = self.split(root.right, key)
            root.right = left
            self.update(root)
            return (root, right)

    def merge(self, left, right):
        if not left or not right:
            return left or right
        if left.priority > right.priority:
            left.right = self.merge(left.right, right)
            self.update(left)
            return left
        else:
            right.left = self.merge(left, right.left)
            self.update(right)
            return right

    def insert(self, root, node):
        if not root:
            return node
        if node.priority > root.priority:
            left, right = self.split(root, node.key)
            node.left = left
            node.right = right
            self.update(node)
            return node
        elif node.key < root.key:
            root.left = self.insert(root.left, node)
        else:
            root.right = self.insert(root.right, node)
        self.update(root)
        return root

    def remove(self, root, key):
        if not root:
            return None
        if root.key == key:
            return self.merge(root.left, root.right)
        elif key < root.key:
            root.left = self.remove(root.left, key)
        else:
            root.right = self.remove(root.right, key)
        self.update(root)
        return root

    def sum_first_k(self, root, k):
        if not root or k <= 0:
            return 0
        if root.left:
            if root.left.size >= k:
                return self.sum_first_k(root.left, k)
            else:
                res = root.left.sum + root.cnt_value
                rem = k - root.left.size - 1
                res += self.sum_first_k(root.right, rem)
                return res
        else:
            if k == 1:
                return root.cnt_value
            else:
                res = root.cnt_value + self.sum_first_k(root.right, k - 1)
                return res
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        root = None
        counts = {}
        ans = []


        for i in range(k):
            num = nums[i]
            if num in counts:
                count = counts[num]
                key = (-count, -num)
                root = self.remove(root, key)
                counts[num] += 1
                count += 1
            else:
                counts[num] = 1
                count = 1
            key = (-count, -num)
            node = self.Node(key, count * num)
            root = self.insert(root, node)

        total = self.sum_first_k(root, x)
        ans.append(total)

        for i in range(k, len(nums)):
            out_num = nums[i - k]
            in_num = nums[i]


            count = counts[out_num]
            key = (-count, -out_num)
            root = self.remove(root, key)
            counts[out_num] -= 1
            count -= 1
            if count > 0:
                key = (-count, -out_num)
                node = self.Node(key, count * out_num)
                root = self.insert(root, node)
            else:
                del counts[out_num]


            if in_num in counts:
                count = counts[in_num]
                key = (-count, -in_num)
                root = self.remove(root, key)
                counts[in_num] += 1
                count += 1
            else:
                counts[in_num] = 1
                count = 1
            key = (-count, -in_num)
            node = self.Node(key, count * in_num)
            root = self.insert(root, node)


            total = self.sum_first_k(root, x)
            ans.append(total)

        return ans
        ",1420541831
lqCKWBPxHc,lqCKWBPxHc,24,3610,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        counts = defaultdict(int)
        sorted_elements = SortedList()
        answer = []

        for i in range(k):
            element = nums[i]
            counts[element] += 1

        for element, freq in counts.items():
            sorted_elements.add((-freq, -element))

        def calculate_x_sum():
            total_elements = 0
            x_sum = 0
            for freq, element in sorted_elements:
                element = -element
                freq = -freq
                x_sum += counts[element] * element
                total_elements += 1
                if total_elements == x:
                    break
            return x_sum

        x_sum = calculate_x_sum()
        answer.append(x_sum)

        for i in range(n - k):
            left_element = nums[i]
            right_element = nums[i + k]

            old_freq = counts[left_element]
            sorted_elements.discard((-old_freq, -left_element))
            counts[left_element] -= 1
            if counts[left_element] == 0:
                del counts[left_element]
            else:
                new_freq = counts[left_element]
                sorted_elements.add((-new_freq, -left_element))

            if right_element in counts:
                old_freq = counts[right_element]
                sorted_elements.discard((-old_freq, -right_element))
                counts[right_element] += 1
            else:
                counts[right_element] = 1
            new_freq = counts[right_element]
            sorted_elements.add((-new_freq, -right_element))

            x_sum = calculate_x_sum()
            answer.append(x_sum)

        return answer",1420519488
LayCurse,LayCurse,25,3509,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template<class T> using cLtraits_try_make_unsigned =
  typename conditional<
    is_integral<T>::value,
    make_unsigned<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmin(S &a, T b){
  if(a>b){
    a=b;
  }
  return a;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
template<class S, class T> inline S divup_L(S a, T b){
  return (a+b-1)/b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
inline int Ilog2_f_L(const int n){
  int res;
  if(n <= 0){
    return -1;
  }
  res = sizeof(int) * 8 - __builtin_clz(n) - 1;
  return res;
}
inline int Ilog2_f_L(const long long n){
  int res;
  if(n <= 0){
    return -1;
  }
  res = sizeof(long long) * 8 - __builtin_clzll(n) - 1;
  return res;
}
template<class T1> void sortI(int N, T1 a[], void *mem = wmem){
  sort(a, a+N);
}
template<class T1, class T2> void sortI(int N, T1 a[], T2 b[], void *mem = wmem){
  int i;
  pair<T1, T2>*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first = a[i];
    arr[i].second = b[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first;
    b[i] = arr[i].second;
  }
}
template<class T1, class T2, class T3> void sortI(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){
  int i;
  pair<T1, pair<T2, T3> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first = a[i];
    arr[i].second.first = b[i];
    arr[i].second.second = c[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first;
    b[i] = arr[i].second.first;
    c[i] = arr[i].second.second;
  }
}
template<class T1, class T2, class T3, class T4> void sortI(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){
  int i;
  pair<pair<T1, T2>, pair<T3, T4> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first.first = a[i];
    arr[i].first.second = b[i];
    arr[i].second.first = c[i];
    arr[i].second.second = d[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first.first;
    b[i] = arr[i].first.second;
    c[i] = arr[i].second.first;
    d[i] = arr[i].second.second;
  }
}
template<class T> inline int sort_helper_getbit(T A[]){
  return -1;
}
template<> inline int sort_helper_getbit(int A[]){
  return sizeof(int)*8;
}
template<> inline int sort_helper_getbit(unsigned A[]){
  return sizeof(unsigned)*8;
}
template<> inline int sort_helper_getbit(long long A[]){
  return sizeof(long long)*8;
}
template<> inline int sort_helper_getbit(unsigned long long A[]){
  return sizeof(unsigned long long)*8;
}
template<> inline int sort_helper_getbit(char A[]){
  return sizeof(char)*8;
}
template<class T> void sortA_1_int_L(int N, T A[], void *mem = wmem){
  int i;
  int j;
  int k;
  int b;
  int s;
  int ok;
  ok = 1;
  for(i=(1);i<(N);i++){
    if(A[i-1] > A[i]){
      ok = 0;
      break;
    }
  }
  if(ok){
    return;
  }
  if(N < 128){
    sort(A,A+N);
    return;
  }
  b = sort_helper_getbit(A);
  if(b==-1){
    sort(A,A+N);
    return;
  }
  T mn;
  T mx;
  mn = mx = A[0];
  for(i=(1);i<(N);i++){
    chmin(mn, A[i]);
  }
  for(i=(1);i<(N);i++){
    chmax(mx, A[i]);
  }
  ok = 1;
  if(mn < 0 && mx > 0 && (mn < -N || mx > N)){
    ok = 0;
  }
  if(ok && mx - mn > N){
    ok = 0;
  }
  if(ok){
    int*tmp;
    walloc1d(&tmp, mx-mn+1, &mem);
    for(i=(0);i<(mx-mn+1);i++){
      tmp[i] = 0;
    }
    for(i=(0);i<(N);i++){
      tmp[A[i]-mn]++;
    }
    k = 0;
    for(i=(0);i<(mx-mn+1);i++){
      while(tmp[i] > 0){
        tmp[i]--;
        A[k++] = i+mn;
      }
    }
    return;
  }
  {
    typename make_unsigned<T>::type *t[2];
    typename make_unsigned<T>::type  mask;
    typename make_unsigned<T>::type  cur;
    typename make_unsigned<T>::type  one = 1;
    T tone = 1;
    int*pos;
    int nn = 0;
    int ss;
    s =Ilog2_f_L(N);
    if(s > 8){
      s = (8 + (s-7)/2);
    }
    ss = 1;
    for(;;){
      if(ss >= b){
        break;
      }
      if( mx >= 0 && (tone << (ss-1)) < mx ){
        ss++;
        continue;
      }
      if( mn < 0 && -(tone << (ss-1)) >= mn ){
        ss++;
        continue;
      }
      break;
    }
    k =(divup_L(ss,s));
    s =(divup_L(ss,k));
    mask = 0;
    for(i=(0);i<(b);i++){
      if(i < s*k){
        mask |= one << i;
      }
    }
    t[0] = (typename make_unsigned<T>::type *) A;
    walloc1d(&t[1], N, &mem);
    walloc1d(&pos, (1<<s)+1, &mem);
    for(j=(0);j<(k);j++){
      cur = 0;
      for(i=(0);i<(b);i++){
        if(s*j <= i && i < s*(j+1) && i < b){
          cur |= one << i;
        }
      }
      for(i=(0);i<((1<<s)+1);i++){
        pos[i] = 0;
      }
      for(i=(0);i<(N);i++){
        pos[((t[nn][i]&cur)>>(s*j))+1]++;
      }
      for(i=(0);i<((1<<s));i++){
        pos[i+1] += pos[i];
      }
      for(i=(0);i<(N);i++){
        t[nn^1][pos[(t[nn][i]&cur)>>(s*j)]++] = t[nn][i];
      }
      nn ^= 1;
      mask ^= cur;
    }
    if(mn < 0 && mx >= 0){
      k = 0;
      for(i=(0);i<(N);i++){
        if(A[i] < 0){
          k++;
        }
      }
      for(i=(0);i<(k);i++){
        t[nn^1][i] = t[nn][N-k+i];
      }
      for(i=(k);i<(N);i++){
        t[nn^1][i] = t[nn][i-k];
      }
      nn ^= 1;
    }
    if(nn==1){
      for(i=(0);i<(N);i++){
        t[0][i] = t[1][i];
      }
    }
    return;
  }
  sort(A, A+N);
}
template<class T> void sortA_1_nonint_L(int N, T A[], void *mem = wmem){
  sort(A,A+N);
}
template<class T> void sortA_1_call_L(int N, T A[], void *mem = wmem){
  sortA_1_nonint_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, int A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, unsigned A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, long long A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, unsigned long long A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, char A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<class T1> void sortA(int N, T1 a[], void *mem = wmem){
  sortA_1_call_L(N, a, mem);
}
template<class T1, class T2> void sortA_2_int_L(int N, T1 A[], T2 B[], void *mem = wmem){
  int i;
  int b_a;
  int b_b;
  int s1;
  int s2;
  int so2;
  T1 mn1;
  T1 mx1;
  T2 mn2;
  T2 mx2;
  typename cLtraits_try_make_unsigned<T1>::type r1;
  typename cLtraits_try_make_unsigned<T2>::type r2;
  so2 = 1;
  for(i=(1);i<(N);i++){
    if(A[i-1] > A[i] || (A[i-1]==A[i] && B[i-1] > B[i])){
      so2 = 0;
      break;
    }
  }
  if(so2){
    return;
  }
  so2 = 1;
  for(i=(1);i<(N);i++){
    if(A[i-1] > A[i]){
      so2 = 0;
      break;
    }
  }
  if(so2==1){
    int k = 0;
    for(i=(1);i<(N);i++){
      if(A[i] != A[i-1]){
        sortA_1_call_L(i-k, B+k, mem);
        k = i;
      }
    }
    sortA_1_call_L(N-k, B+k, mem);
    return;
  }
  if(N < 128){
    sortI(N,A,B,mem);
    return;
  }
  b_a = sort_helper_getbit(A);
  b_b = sort_helper_getbit(B);
  if(b_a == -1 || b_b == -1){
    sortI(N,A,B,mem);
    return;
  }
  mn1 = mx1 = A[0];
  for(i=(1);i<(N);i++){
    chmin(mn1, A[i]);
  }
  for(i=(1);i<(N);i++){
    chmax(mx1, A[i]);
  }
  mn2 = mx2 = B[0];
  for(i=(1);i<(N);i++){
    chmin(mn2, B[i]);
  }
  for(i=(1);i<(N);i++){
    chmax(mx2, B[i]);
  }
  if(mn1 < -4611686016279904256LL || mn2 < -4611686016279904256LL || mx1 > 4611686016279904256LL || mx2 > 4611686016279904256LL || mx1-mn1 > 4611686016279904256LL || mx2-mn2 > 4611686016279904256LL){
    sortI(N,A,B,mem);
    return;
  }
  r1 = (typename cLtraits_try_make_unsigned<T1>::type)(mx1) - (typename cLtraits_try_make_unsigned<T1>::type)(mn1);
  r2 = (typename cLtraits_try_make_unsigned<T2>::type)(mx2) - (typename cLtraits_try_make_unsigned<T2>::type)(mn2);
  if(r1 == 0){
    sortA_1_call_L(N, B, mem);
    return;
  }
  if(r2 == 0){
    sortA_1_call_L(N, A, mem);
    return;
  }
  if(r1 <= N){
    so2 = 1;
    for(i=(1);i<(N);i++){
      if(B[i-1] > B[i]){
        so2 = 0;
        break;
      }
    }
    if(so2 == 1){
      T1*aa;
      T2*bb;
      int*pos;
      int k;
      walloc1d(&aa,N,&mem);
      walloc1d(&bb,N,&mem);
      walloc1d(&pos,r1+2,&mem);
      for(i=(0);i<(r1+2);i++){
        pos[i] = 0;
      }
      for(i=(0);i<(N);i++){
        aa[i] = A[i];
      }
      for(i=(0);i<(N);i++){
        bb[i] = B[i];
      }
      for(i=(0);i<(N);i++){
        pos[(typename cLtraits_try_make_unsigned<T1>::type)((typename cLtraits_try_make_unsigned<T1>::type)aa[i]-(typename cLtraits_try_make_unsigned<T1>::type)mn1)+1]++;
      }
      for(i=(1);i<(r1+2);i++){
        pos[i] += pos[i-1];
      }
      for(i=(0);i<(N);i++){
        k = pos[(typename cLtraits_try_make_unsigned<T1>::type)((typename cLtraits_try_make_unsigned<T1>::type)aa[i]-(typename cLtraits_try_make_unsigned<T1>::type)mn1)+0]++;
        A[k] = aa[i];
        B[k] = bb[i];
      }
      return;
    }
  }
  s1 = s2 = 1;
  while( s1 < 64 && r1 >= (1ULL<<s1) ){
    s1++;
  }
  while( s2 < 64 && r2 >= (1ULL<<s2) ){
    s2++;
  }
  if(s1 + s2 <= 32){
    unsigned*tmp;
    walloc1d(&tmp,N,&mem);
    for(i=(0);i<(N);i++){
      tmp[i] = (((unsigned)((int)A[i]-(int)mn1)) << s2) | ((unsigned)((int)B[i]-(int)mn2));
    }
    sortA_1_call_L(N, tmp, mem);
    for(i=(0);i<(N);i++){
      A[i] = ((int)(tmp[i] >> s2)) + ((int)mn1);
      B[i] = ((int)(tmp[i] & ((1U<<s2)-1))) + ((int)mn2);
    }
    return;
  }
  if(s1 + s2 <= 64){
    unsigned long long*tmp;
    walloc1d(&tmp,N,&mem);
    for(i=(0);i<(N);i++){
      tmp[i] = (((unsigned long long)((long long)A[i]-(long long)mn1)) << s2) | ((unsigned long long)((long long)B[i]-(long long)mn2));
    }
    sortA_1_call_L(N, tmp, mem);
    for(i=(0);i<(N);i++){
      A[i] = ((long long)(tmp[i] >> s2)) + ((long long)mn1);
      B[i] = ((long long)(tmp[i] & ((1ULL<<s2)-1))) + ((long long)mn2);
    }
    return;
  }
  sortI(N,A,B,mem);
}
template<class T1, class T2> void sortA_2_nonint_L(int N, T1 A[], T2 B[], void *mem = wmem){
  sortI(N,A,B,mem);
}
template<class T1, class T2> void sortA_2_call_L(int N, T1 A[], T2 B[], void *mem = wmem){
  sortA_2_nonint_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, int A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, unsigned A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, long long A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, unsigned long long A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, char A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T1, class T2> void sortA(int N, T1 a[], T2 b[], void *mem = wmem){
  sortA_2_call_L(N, a, b, mem);
}
template<class T1, class T2, class T3> void sortA(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){
  int i;
  pair<T1, pair<T2, T3> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first = a[i];
    arr[i].second.first = b[i];
    arr[i].second.second = c[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first;
    b[i] = arr[i].second.first;
    c[i] = arr[i].second.second;
  }
}
template<class T1, class T2, class T3, class T4> void sortA(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){
  int i;
  pair<pair<T1, T2>, pair<T3, T4> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first.first = a[i];
    arr[i].first.second = b[i];
    arr[i].second.first = c[i];
    arr[i].second.second = d[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first.first;
    b[i] = arr[i].first.second;
    c[i] = arr[i].second.first;
    d[i] = arr[i].second.second;
  }
}
template<class T1> void rsortA(int N, T1 a[], void *mem = wmem){
  sortA(N, a, mem);
  reverse(a, a+N);
}
template<class T1, class T2> void rsortA(int N, T1 a[], T2 b[], void *mem = wmem){
  sortA(N, a, b, mem);
  reverse(a, a+N);
  reverse(b, b+N);
}
template<class T1, class T2, class T3> void rsortA(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){
  sortA(N, a, b, c, mem);
  reverse(a, a+N);
  reverse(b, b+N);
  reverse(c, c+N);
}
template<class T1, class T2, class T3, class T4> void rsortA(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){
  sortA(N, a, b, c, d, mem);
  reverse(a, a+N);
  reverse(b, b+N);
  reverse(c, c+N);
  reverse(d, d+N);
}
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main

int ress;
int res[1000000];
void solve(TreeNode *a, int &mn, int &mx){
  int x1;
  int y1;
  int x2;
  int y2;
  if(a == NULL){
    mn = mx = 0;
    return;
  }
  solve(a->left, x1, y1);
  solve(a->right, x2, y2);
  mn =min_L(x1, x2)+1;
  mx =max_L(y1, y2)+1;
  if(mn == mx){
    res[ress++] = mn;
  }
}
class Solution{
  public:
  int kthLargestPerfectSubtree(TreeNode* root, int k){
    dummy_main();
    k--;
    ress = 0;
    int x;
    int y;
    solve(root,x,y);
    if(ress <= k){
      return -1;
    }
    rsortA(ress, res);
    return (1<<res[k])-1;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// struct TreeNode {
//   int val;
//   TreeNode *left;
//   TreeNode *right;
//   TreeNode() : val(0), left(nullptr), right(nullptr) {}
//   TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
//   TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
// };
// 
// int ress, res[1d6];
// 
// void solve(TreeNode *a, int &mn, int &mx){
//   int x1, y1, x2, y2;
// 
//   if(a == NULL){
//     mn = mx = 0;
//     return;
//   }
// 
//   solve(a->left, x1, y1);
//   solve(a->right, x2, y2);
// 
//   mn = min(x1,x2)+1;
//   mx = max(y1,y2)+1;
//   if(mn == mx) res[ress++] = mn;
// }
// 
// class Solution {
// public:
//   int kthLargestPerfectSubtree(TreeNode* root, int k) {
//     dummy_main();
// 
//     k--;
//     ress = 0;
// 
//     int x, y;
//     solve(root,x,y);
// 
//     if(ress <= k) return -1;
//     rsortA(ress, res);
//     return (1<<res[k])-1;
//   }
// };",1420521399
LayCurse,LayCurse,25,3588,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
template<class S, class T> inline S moddw_L(S a, const T b){
  a %= b;
  if(a < 0){
    a += b;
  }
  return a;
}
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int countWinningSequences(string s){
    static int N;
    static int A[1100];
    static Modint dp[4][2100];
    static Modint nx[4][2100];
    int i;
    int j;
    int k;
    int g;
    Modint res = 0;
    N = s.size();
    for(i=(0);i<(N);i++){
      if(s[i]=='F'){
        A[i] =0;
      }
      else if(s[i]=='W'){
        A[i] =1;
      }
      else{
        A[i] =2;
      }
    }
    g = N + 5;
    for(k=(0);k<(4);k++){
      for(i=(0);i<(2*g);i++){
        dp[k][i] = 0;
      }
    }
    dp[3][g] = 1;
    for(k=(0);k<(N);k++){
      for(j=(0);j<(4);j++){
        for(i=(0);i<(2*g);i++){
          nx[j][i] = 0;
        }
      }
      for(j=(0);j<(4);j++){
        for(i=(0);i<(2*g);i++){
          if(dp[j][i]){
            int m;
            for(m=(0);m<(3);m++){
              if(m!=j){
                if((moddw_L((A[k]-m),3))== 0 ){
                  nx[m][i] += dp[j][i];
                }
                if((moddw_L((A[k]-m),3))== 1 ){
                  nx[m][i-1] += dp[j][i];
                }
                if((moddw_L((A[k]-m),3))== 2 ){
                  nx[m][i+1] += dp[j][i];
                }
              }
            }
          }
        }
      }
      for(j=(0);j<(4);j++){
        for(i=(0);i<(2*g);i++){
          dp[j][i] = nx[j][i];
        }
      }
    }
    for(k=(0);k<(4);k++){
      for(i=(g+1);i<(2*g);i++){
        res +=dp[k][i];
      }
    }
    return res;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int countWinningSequences(string s) {
//     static int N, A[1100];
//     static Modint dp[4][2100], nx[4][2100];
//     int i, j, k, g;
//     Modint res = 0;
// 
//     N = s.size();
//     rep(i,N) A[i] = if[s[i]=='F', 0, s[i]=='W', 1, 2];
// 
//     g = N + 5;
//     rep(k,4) rep(i,2*g) dp[k][i] = 0;
//     dp[3][g] = 1;
// 
//     rep(k,N){
//       rep(j,4) rep(i,2*g) nx[j][i] = 0;
//       rep(j,4) rep(i,2*g) if(dp[j][i]) rep(m,3) if(m!=j){
//         if( (A[k]-m)%%3 == 0 ) nx[m][i] += dp[j][i];
//         if( (A[k]-m)%%3 == 1 ) nx[m][i-1] += dp[j][i];
//         if( (A[k]-m)%%3 == 2 ) nx[m][i+1] += dp[j][i];
//       }
//       rep(j,4) rep(i,2*g) dp[j][i] = nx[j][i];
//     }
// 
//     rep(k,4) rep(i,g+1,2*g) res +=dp[k][i];
//     return res;
//   }
// };
",1420527973
LayCurse,LayCurse,25,3592,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> struct twoMultisets{
  multiset<T> a;
  multiset<T> b;
  T sa;
  T sb;
  twoMultisets(){
    clear();
  }
  void clear(){
    a.clear();
    b.clear();
    sa = sb = 0;
  }
  void insert(T x){
    if(b.size() == 0 || x < *b.begin()){
      a.insert(x);
      sa += x;
    }
    else{
      b.insert(x);
      sb += x;
    }
  }
  int erase(T x){
    typename multiset<T>::iterator it;
    it = a.find(x);
    if(it != a.end()){
      a.erase(it);
      sa -= x;
      return 1;
    }
    it = b.find(x);
    if(it != b.end()){
      b.erase(it);
      sb -= x;
      return 1;
    }
    return 0;
  }
  int size(void){
    return a.size() + b.size();
  }
  T allsum(void){
    return sa + sb;
  }
  void assign(int K){
    T x;
    typename multiset<T>::iterator it;
    while(a.size() < K){
      x = *b.begin();
      b.erase(b.begin());
      a.insert(x);
      sa += x;
      sb -= x;
    }
    while(a.size() > K){
      it = a.end();
      it--;
      x = *it;
      a.erase(it);
      b.insert(x);
      sa -= x;
      sb += x;
    }
  }
  T Kth(int K){
    assign(K);
    return *b.begin();
  }
  T Ksum(int K){
    assign(K);
    return sa;
  }
  T rKth(int K){
    return Kth(a.size() + b.size() - K - 1);
  }
  T rKsum(int K){
    assign(a.size() + b.size() - K);
    return sb;
  }
  T getMin(void){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return 0;
  }
  T getMin(T x){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return x;
  }
  T getMax(void){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return 0;
  }
  T getMax(T x){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return x;
  }
}
;
#define main dummy_main
int main(){
  return 0;
}
#undef main
void do_add(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt = 0;
  if(mp.count(v)){
    cnt = mp[v];
    s.erase({cnt,v});
    m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  }
  cnt++;
  mp[v] = cnt;
  s.insert({cnt,v});
  m.insert(__int128_t(cnt)*(v+100000000000000000LL));
}
void do_del(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt;
  cnt = mp[v];
  mp.erase(v);
  s.erase({cnt,v});
  m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  cnt--;
  if(cnt){
    mp[v] = cnt;
    s.insert({cnt,v});
    m.insert(__int128_t(cnt)*(v+100000000000000000LL));
  }
}
long long do_get(twoMultisets<__int128_t> &m, int x){
  int k;
  k =min_L(x, m.size());
  return m.rKsum(k)%100000000000000000LL;
}
class Solution{
  public:
  vector<long long> findXSum(vector<int>& A, int K, int x){
    int i;
    int N = A.size();
    set<pair<int,long long>> s;
    map<long long,int> mp;
    twoMultisets<__int128_t> m;
    vector<long long> res;
    for(i=(0);i<(K);i++){
      do_add(s,mp,m,A[i]);
    }
    res.push_back(do_get(m,x));
    for(i=(K);i<(N);i++){
      do_del(s,mp,m,A[i-K]);
      do_add(s,mp,m,A[i]);
      res.push_back(do_get(m,x));
    }
    return res;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// void do_add(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt = 0;
// 
//   if(mp.count(v)){
//     cnt = mp[v];
//     s.erase({cnt,v});
//     m.erase(__int128_t(cnt)*(v+1d17));
//   }
// 
//   cnt++;
//   mp[v] = cnt;
//   s.insert({cnt,v});
//   m.insert(__int128_t(cnt)*(v+1d17));
// }
// 
// void do_del(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt;
// 
//   cnt = mp[v];
//   mp.erase(v);
//   s.erase({cnt,v});
//   m.erase(__int128_t(cnt)*(v+1d17));
// 
//   cnt--;
//   if(cnt){
//     mp[v] = cnt;
//     s.insert({cnt,v});
//     m.insert(__int128_t(cnt)*(v+1d17));
//   }
// }
// 
// ll do_get(twoMultisets<__int128_t> &m, int x){
//   int k;
//   k = min(x,m.size());
//   return m.rKsum(k)%1d17;
// }
// 
// class Solution {
// public:
//   vector<long long> findXSum(vector<int>& A, int K, int x) {
//     int N = A.size();
// 
//     set<pair<int,ll>> s;
//     map<ll,int> mp;
//     twoMultisets<__int128_t> m;
//     vector<ll> res;
// 
//     rep(i,K) do_add(s,mp,m,A[i]);
//     res.push_back(do_get(m,x));
//     rep(i,K,N){
//       do_del(s,mp,m,A[i-K]);
//       do_add(s,mp,m,A[i]);
//       res.push_back(do_get(m,x));
//     }
// 
//     return res;
//   }
// };
",1420547573
LayCurse,LayCurse,25,3610,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> struct twoMultisets{
  multiset<T> a;
  multiset<T> b;
  T sa;
  T sb;
  twoMultisets(){
    clear();
  }
  void clear(){
    a.clear();
    b.clear();
    sa = sb = 0;
  }
  void insert(T x){
    if(b.size() == 0 || x < *b.begin()){
      a.insert(x);
      sa += x;
    }
    else{
      b.insert(x);
      sb += x;
    }
  }
  int erase(T x){
    typename multiset<T>::iterator it;
    it = a.find(x);
    if(it != a.end()){
      a.erase(it);
      sa -= x;
      return 1;
    }
    it = b.find(x);
    if(it != b.end()){
      b.erase(it);
      sb -= x;
      return 1;
    }
    return 0;
  }
  int size(void){
    return a.size() + b.size();
  }
  T allsum(void){
    return sa + sb;
  }
  void assign(int K){
    T x;
    typename multiset<T>::iterator it;
    while(a.size() < K){
      x = *b.begin();
      b.erase(b.begin());
      a.insert(x);
      sa += x;
      sb -= x;
    }
    while(a.size() > K){
      it = a.end();
      it--;
      x = *it;
      a.erase(it);
      b.insert(x);
      sa -= x;
      sb += x;
    }
  }
  T Kth(int K){
    assign(K);
    return *b.begin();
  }
  T Ksum(int K){
    assign(K);
    return sa;
  }
  T rKth(int K){
    return Kth(a.size() + b.size() - K - 1);
  }
  T rKsum(int K){
    assign(a.size() + b.size() - K);
    return sb;
  }
  T getMin(void){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return 0;
  }
  T getMin(T x){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return x;
  }
  T getMax(void){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return 0;
  }
  T getMax(T x){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return x;
  }
}
;
#define main dummy_main
int main(){
  return 0;
}
#undef main
void do_add(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt = 0;
  if(mp.count(v)){
    cnt = mp[v];
    s.erase({cnt,v});
    m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  }
  cnt++;
  mp[v] = cnt;
  s.insert({cnt,v});
  m.insert(__int128_t(cnt)*(v+100000000000000000LL));
}
void do_del(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt;
  cnt = mp[v];
  mp.erase(v);
  s.erase({cnt,v});
  m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  cnt--;
  if(cnt){
    mp[v] = cnt;
    s.insert({cnt,v});
    m.insert(__int128_t(cnt)*(v+100000000000000000LL));
  }
}
long long do_get(twoMultisets<__int128_t> &m, int x){
  int k;
  k =min_L(x, m.size());
  return m.rKsum(k)%100000000000000000LL;
}
class Solution{
  public:
  vector<int> findXSum(vector<int>& A, int K, int x){
    int i;
    int N = A.size();
    set<pair<int,long long>> s;
    map<long long,int> mp;
    twoMultisets<__int128_t> m;
    vector<int> res;
    for(i=(0);i<(K);i++){
      do_add(s,mp,m,A[i]);
    }
    res.push_back(do_get(m,x));
    for(i=(K);i<(N);i++){
      do_del(s,mp,m,A[i-K]);
      do_add(s,mp,m,A[i]);
      res.push_back(do_get(m,x));
    }
    return res;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// void do_add(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt = 0;
// 
//   if(mp.count(v)){
//     cnt = mp[v];
//     s.erase({cnt,v});
//     m.erase(__int128_t(cnt)*(v+1d17));
//   }
// 
//   cnt++;
//   mp[v] = cnt;
//   s.insert({cnt,v});
//   m.insert(__int128_t(cnt)*(v+1d17));
// }
// 
// void do_del(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt;
// 
//   cnt = mp[v];
//   mp.erase(v);
//   s.erase({cnt,v});
//   m.erase(__int128_t(cnt)*(v+1d17));
// 
//   cnt--;
//   if(cnt){
//     mp[v] = cnt;
//     s.insert({cnt,v});
//     m.insert(__int128_t(cnt)*(v+1d17));
//   }
// }
// 
// ll do_get(twoMultisets<__int128_t> &m, int x){
//   int k;
//   k = min(x,m.size());
//   return m.rKsum(k)%1d17;
// }
// 
// class Solution {
// public:
//   vector<int> findXSum(vector<int>& A, int K, int x) {
//     int N = A.size();
// 
//     set<pair<int,ll>> s;
//     map<ll,int> mp;
//     twoMultisets<__int128_t> m;
//     vector<int> res;
// 
//     rep(i,K) do_add(s,mp,m,A[i]);
//     res.push_back(do_get(m,x));
//     rep(i,K,N){
//       do_del(s,mp,m,A[i-K]);
//       do_add(s,mp,m,A[i]);
//       res.push_back(do_get(m,x));
//     }
// 
//     return res;
//   }
// };
",1420548325
Nguyễn Thảo,nguyenquocthao00,28,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        data=[]
        def dp(node):
            if not node: return 0
            x,y = dp(node.left), dp(node.right)
            if x==y and x>=0:
                data.append(x+y+1)
                return x+y+1
            else: return -1
        dp(root)
        data.sort(reverse=True)
        return -1 if k>len(data) else data[k-1]",1420524477
Nguyễn Thảo,nguyenquocthao00,28,3588,python3,"MOD = 10**9 + 7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        n=len(s)
        creatures='FWE'
        def getscore(a, b):
            i,j = creatures.index(a), creatures.index(b)
            if i==j: return 0
            if j-i==1 or j-i==-2: return 1
            return -1
        def keyf(i,p,prev):
            if prev=='': return 0
            return i*2*n*3 + p*3 + creatures.index(prev) + 1
        cached=[-1]*(n*n*6+1)
        # @lru_cache(None)
        def dp(i, p, prev):
            if i==len(s):
                return 0 if p<=0 else 1
            key = keyf(i,p,prev)
            if cached[key]>=0: return cached[key]
            res=0
            for x in creatures:
                if x==prev: continue
                res += dp(i+1, p + getscore(s[i], x), x)
            cached[key]=res%MOD
            return cached[key]
            # return res%MOD
        return dp(0,0,'')

        ",1420539093
Nguyễn Thảo,nguyenquocthao00,28,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        c=Counter(nums[:k])
        sl = SortedList((val,key) for key,val in c.items())
        cur = sum(a*b for a,b in sl[-x:])
        res = [cur]
        def remove(item):
            nonlocal cur
            ind = sl.index(item)
            if len(sl)-ind <= x:
                cur -= item[0]*item[1]
                sl.remove(item)
                if len(sl)>=x:
                    z = sl[-x]
                    cur+=z[0]*z[1]
            else:
                sl.remove(item)
        def insert(item):
            nonlocal cur
            sl.add(item)
            ind=sl.index(item)
            if len(sl)-ind<=x:
                cur+=item[0]*item[1]
                if len(sl)>x:
                    z=sl[-x-1]
                    cur-=z[0]*z[1]

        def sub(v):
            item=(c[v], v)
            c[v]-=1
            remove(item)
            if c[v]>0:
                insert((c[v], v))
        def add(v):
            if c[v]>0: remove((c[v], v))
            c[v]+=1
            insert((c[v], v))

        for i in range(1, len(nums)-k+1):
            sub(nums[i-1])
            add(nums[i+k-1])
            res.append(cur)
        return res

        ",1420555479
Nguyễn Thảo,nguyenquocthao00,28,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        c=Counter(nums[:k])
        def cal():
            data=sorted((val,key) for key,val in c.items())
            if len(data)<=x: return sum(a*b for a,b in data)
            return sum(a*b for a,b in data[-x:])
        res=[cal()]
        for i in range(1, len(nums)-k+1):
            c[nums[i-1]]-=1
            c[nums[i+k-1]]+=1
            res.append(cal())
        return res

        ",1420521676
Jingzhe Tang,skywalkert,30,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    pair<int, int> dfs(TreeNode* rt, vector<int> &ans) {
        if(rt == nullptr)
            return {0, -1};
        pair<int, int> ret = {1, 0}, tmp;
        for(TreeNode* sub: {rt -> left, rt -> right}) {
            tmp = dfs(sub, ans);
            ret.first += tmp.first;
            ret.second = max(ret.second, tmp.second + 1);
        }
        // printf(""rt %d: %d %d\n"", rt -> val, ret.first, ret.second);
        if(ret.second < 15 && ret.first + 1 == (1 << (ret.second + 1)))
            ans.push_back(ret.first);
        return ret;
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;
        dfs(root, ans);
        int n = ans.size();
        if(n < k)
            return -1;
        nth_element(ans.begin(), ans.end() - k, ans.end());
        // for(int x: ans)
        //     printf(""%d "", x);
        // printf("": %d %d\n"", n - k, ans[n - k]);
        return ans[n - k];
    }
};",1420536071
Jingzhe Tang,skywalkert,30,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        typedef long long LL;
        static const int maxn = (int)2e3 + 9, mod = (int)1e9 + 7;
        static const char *pat = ""FWE"";
        static int f[2][3][maxn], cur = 0, pre = 1;
        int n = s.size();
        auto clr = [&](int arr[3][maxn]) {
            for(int i = 0; i < 3; ++i)
                memset(arr[i], 0, (n << 1 | 1) * sizeof(int));
        };
        for(int i = 0; i < n; ++i) {
            for(int j = 0; pat[j]; ++j)
                if(s[i] == pat[j]) {
                    s[i] = j;
                    break;
                }
            static int adt[3];
            for(int j = 0; j < 3; ++j)
                adt[j] = ((s[i] + 1) % 3 == j) - ((j + 1) % 3 == s[i]);
            swap(cur, pre);
            clr(f[cur]);
            if(!i) {
                for(int j = 0; j < 3; ++j)
                    f[cur][j][n + adt[j]] = 1;
                continue;
            }
            for(int j = 0; j < 3; ++j)
                for(int k = n - i; k <= n + i; ++k) {
                    if(!f[pre][j][k])
                        continue;
                    for(int x = 0; x < 3; ++x) {
                        if(x == j)
                            continue;
                        int kk = k + adt[x];
                        (f[cur][x][kk] += f[pre][j][k]) >= mod && (f[cur][x][kk] -= mod);
                    }
                }
        }
        int ans = 0;
        for(int i = 0; i < 3; ++i)
            for(int j = n + 1; j <= n + n; ++j)
               (ans += f[cur][i][j]) >= mod && (ans -= mod);
        return ans;
    }
};",1420526225
Jingzhe Tang,skywalkert,30,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int m) {
        typedef long long LL;
        int n = nums.size();
        vector<LL> ans;
        LL sum = 0;
        map<int, int> ctr;
        set<pair<int, int> > sL, sR;
        auto upd = [&](int x, int d) {
            int &v = ctr[x];
            if(v > 0) {
                pair<int, int> key = {v, x};
                if(!sR.empty() && key < *sR.begin()) {
                    assert(sL.count(key));
                    sL.erase(key);
                } else {
                    assert(sR.count(key));
                    sR.erase(key);
                    sum -= (LL)v * x;
                }
                // printf(""del (%d, %d): %lld\n"", v, x, sum);
            }
            v += d;
            if(v > 0) {
                pair<int, int> key = {v, x};
                sL.insert(key);
                // printf(""add (%d, %d)\n"", v, x);
                if(!sR.empty() && *sL.rbegin() > *sR.begin()) {
                    key = *sR.begin();
                    sR.erase(key);
                    sL.insert(key);
                    sum -= (LL)key.first * key.second;
                }
            }
            while(!sL.empty() && sR.size() < m) {
                pair<int, int> key = *sL.rbegin();
                sL.erase(key);
                sR.insert(key);
                sum += (LL)key.first * key.second;
            }
            // printf(""adjust %lld\n"", sum);
            // for(auto &[v, x]: sR)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
            // for(auto &[v, x]: sL)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
        };
        for(int i = 0; i < n; ++i) {
            upd(nums[i], 1);
            if(i >= k - 1) {
                ans.push_back(sum);
                upd(nums[i - k + 1], -1);
            }
        }
        return ans;
    }
};",1420555553
Jingzhe Tang,skywalkert,30,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int m) {
        typedef long long LL;
        int n = nums.size();
        vector<int> ans;
        LL sum = 0;
        map<int, int> ctr;
        set<pair<int, int> > sL, sR;
        auto upd = [&](int x, int d) {
            int &v = ctr[x];
            if(v > 0) {
                pair<int, int> key = {v, x};
                if(!sR.empty() && key < *sR.begin()) {
                    assert(sL.count(key));
                    sL.erase(key);
                } else {
                    assert(sR.count(key));
                    sR.erase(key);
                    sum -= (LL)v * x;
                }
                // printf(""del (%d, %d): %lld\n"", v, x, sum);
            }
            v += d;
            if(v > 0) {
                pair<int, int> key = {v, x};
                sL.insert(key);
                // printf(""add (%d, %d)\n"", v, x);
                if(!sR.empty() && *sL.rbegin() > *sR.begin()) {
                    key = *sR.begin();
                    sR.erase(key);
                    sL.insert(key);
                    sum -= (LL)key.first * key.second;
                }
            }
            while(!sL.empty() && sR.size() < m) {
                pair<int, int> key = *sL.rbegin();
                sL.erase(key);
                sR.insert(key);
                sum += (LL)key.first * key.second;
            }
            // printf(""adjust %lld\n"", sum);
            // for(auto &[v, x]: sR)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
            // for(auto &[v, x]: sL)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
        };
        for(int i = 0; i < n; ++i) {
            upd(nums[i], 1);
            if(i >= k - 1) {
                ans.push_back(sum);
                upd(nums[i - k + 1], -1);
            }
        }
        return ans;
    }
};",1420556158
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        l = []

        def dfs(node):
            if not node: return -1
            a, b = node.left, node.right
            if not a and not b:
                l.append(1)
                return 1
            c, d = dfs(a), dfs(b)
            if a and b and c == d and c != -1:
                l.append(2 * c + 1)
                return 2 * c + 1
            return -1
        dfs(root)
        l.sort(reverse=True)
        k -= 1
        if k >= len(l):
            return -1
        return l[k]",1420520968
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3588,python3,"
class Solution:
    def countWinningSequences(self, s: str) -> int:
        d = {'F':0, 'W':1, 'E':2}
        ev = [[0,-1,1], [1,0,-1], [-1,1,0]]
        s = [d[x] for x in s]
        @cache
        def dp(idx, score, lst):
            if idx == len(s):
                return int(score > 0)
            v = s[idx]
            ret = 0
            for i in range(3):
                if i != lst:
                    ns = score + ev[i][v]
                    ret += dp(idx + 1, ns, i)
            return ret % (10**9+7)
        r = dp(0, 0, -1)
        dp.cache_clear()
        return r",1420527086
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        d = {}
        sl = SortedList()
        for i in range(k):
            v = nums[i]
            d[v] = d.get(v, 0) + 1
        for t in d:
            sl.add((d[t], t))
        sm = 0
        for i in range(len(sl)-x, len(sl)):
            if i >= 0:
                sm += sl[i][0] * sl[i][1]
        ret = [sm]
        for i in range(k, len(nums)):
            v = nums[i]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) + 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            j = i - k
            v = nums[j]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) - 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            ret.append(sm)
            # print(sl)
        return ret
",1420555995
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3610,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        d = {}
        sl = SortedList()
        for i in range(k):
            v = nums[i]
            d[v] = d.get(v, 0) + 1
        for t in d:
            sl.add((d[t], t))
        sm = 0
        for i in range(len(sl)-x, len(sl)):
            if i >= 0:
                sm += sl[i][0] * sl[i][1]
        ret = [sm]
        for i in range(k, len(nums)):
            v = nums[i]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) + 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            j = i - k
            v = nums[j]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) - 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            ret.append(sm)
            # print(sl)
        return ret
",1420556655
Yiming Li,lympanda,33,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vector<int> ans;

int doit(TreeNode* p)
{
    int v1,v2;
    if (p==NULL) return 0;
    v1=doit(p->left);
    v2=doit(p->right);
    if ((v1!=-1)&&(v1==v2))
    {
        ans.push_back(v1+v2+1);
        return v1+v2+1;
    }
    else return -1;
}

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        ans.clear();
        doit(root);
        sort(ans.rbegin(),ans.rend());
        if (k>ans.size()) return -1;
        else return ans[k-1];
    }
};",1420520706
Yiming Li,lympanda,33,3588,cpp,"#define _int64 long long
#define mo 1000000007

int a[1100];
_int64 d[2][2100][4];

int getv(char c)
{
    if (c=='F') return 0;
    if (c=='W') return 1;
    if (c=='E') return 2;
    return -1;
}

class Solution {
public:
    int countWinningSequences(string s) {
        int i,j,k,now,n,o,tmp;
        _int64 ans;
        n=s.length();
        for (i=0;i<n;i++)
            a[i]=getv(s[i]);
        memset(d[0],0,sizeof(d[0]));
        d[0][1000][3]=1;
        now=0;
        for (i=0;i<n;i++)
        {
            memset(d[1-now],0,sizeof(d[1-now]));
            for (j=1000-i;j<=1000+i;j++)
                for (k=0;k<4;k++)
                {
                    if (d[now][j][k]==0) continue;
                    for (o=0;o<3;o++)
                    {
                        if (o==k) continue;
                        tmp=j;
                        if (o==(a[i]+1)%3) tmp++;
                        if (a[i]==(o+1)%3) tmp--;
                        d[1-now][tmp][o]+=d[now][j][k];
                        d[1-now][tmp][o]%=mo;
                    }
                }
            now=1-now;
        }
        ans=0;
        for (i=1001;i<2100;i++)
            for (j=0;j<4;j++)
            {
                ans+=d[now][i][j];
                ans%=mo;
            }
        return ans;
    }
};",1420530266
Yiming Li,lympanda,33,3592,cpp,"#define _int64 long long

_int64 sum;

void rem1(set<pair<_int64,_int64> >& st,_int64 v,_int64 cnt,int isbig)
{
    pair<_int64,_int64> tmp;
    tmp=make_pair(cnt,v);
    if (st.find(tmp)!=st.end())
    {
        if (isbig==1) sum-=v*cnt;
        st.erase(tmp);
    }
}

void add1(set<pair<_int64,_int64> >& st,_int64 v,_int64 cnt)
{
    pair<_int64,_int64> tmp;
    tmp=make_pair(cnt,v);
    st.insert(tmp);
}

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        map<_int64,_int64> mp;
        set<pair<_int64,_int64> > bigger;
        set<pair<_int64,_int64> > smaller;
        pair<_int64,_int64> v1,v2;
        vector<_int64> ans;
        sum=0;
        int i,j,n;
        n=a.size();
        mp.clear();
        bigger.clear();
        smaller.clear();
        ans.clear();
        for (i=0;i<n;i++)
        {
            if (mp.find(a[i])!=mp.end())
            {
                rem1(bigger,a[i],mp[a[i]],1);
                rem1(smaller,a[i],mp[a[i]],0);
            }
            mp[a[i]]++;
            add1(smaller,a[i],mp[a[i]]);
            if (i-k>=0)
            {
                rem1(bigger,a[i-k],mp[a[i-k]],1);
                rem1(smaller,a[i-k],mp[a[i-k]],0);
                mp[a[i-k]]--;
                if (mp[a[i-k]]==0) mp.erase(a[i-k]);
                else add1(smaller,a[i-k],mp[a[i-k]]);
            }
            while ((bigger.size()<x)&&(smaller.size()>0))
            {
                sum+=smaller.rbegin()->first*smaller.rbegin()->second;
                bigger.insert(*smaller.rbegin());
                smaller.erase(*smaller.rbegin());
            }
            while ((bigger.size()>0)&&(smaller.size()>0))
            {
                if (*bigger.begin()<*smaller.rbegin())
                {
                     v1=*bigger.begin();
                     v2=*smaller.rbegin();
                     sum-=v1.first*v1.second;
                     sum+=v2.first*v2.second;
                     bigger.erase(v1);
                     smaller.erase(v2);
                     bigger.insert(v2);
                     smaller.insert(v1);
                }
                else break;
            }
            //cout<<""i,sum:""<<i<<"" ""<<sum<<endl;
            if (i>=k-1) ans.push_back(sum);
        }
        return ans;
    }
};",1420558736
Yiming Li,lympanda,33,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        map<int,int> mp;
        vector<int> ans;
        vector<pair<int,int> > tmp;
        int i,j,n,tot;
        n=a.size();
        mp.clear();
        ans.clear();
        for (i=0;i<n;i++)
        {
            mp[a[i]]++;
            if (i-k>=0) mp[a[i-k]]--;
            if (i>=k-1)
            {
                tmp.clear();
                for (map<int,int>::iterator it=mp.begin();it!=mp.end();it++)
                    tmp.push_back(make_pair(it->second,it->first));
                sort(tmp.rbegin(),tmp.rend());
                tot=0;
                for (j=0;(j<x)&&(j<tmp.size());j++)
                    tot+=tmp[j].first*tmp[j].second;
                ans.push_back(tot);
            }
            
            
        }
        return ans;
    }
};",1420536190
nife,nifeshe,34,3509,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;



class Solution {
public:
    pii check(TreeNode* v, int depth, int& d) {
        if (!v) return {true, 0};
        if (!v -> left && !v -> right) {
            if (!~d) d = depth;
            return {depth == d, 1};
        }
        pii l = check(v -> left, depth + 1, d);
        pii r = check(v -> right, depth + 1, d);
        bool siz = l.f && r.f && v -> left && v -> right;
        int size = l.s + r.s + 1;
        return {siz, size};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> siz;
        function<void(TreeNode*)> dfs = [&](TreeNode* v) {
            if (!v) return;
            int d = -1;
            auto [ok, s] = check(v, 0, d);
            if(ok) siz.pb(s);
            dfs(v -> left);
            dfs(v -> right);
        };
        dfs(root);
        sort(siz.rbegin(), siz.rend());
        return (k <= siz.size()) ? siz[k - 1] : -1;
    }
};",1420526671
nife,nifeshe,34,3588,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;

const int phi_minus_one = mod - 2;

class Mint {
    public:
        int x;

    public:
        void norm() {
            x %= mod;
            if(x < 0) x += mod;
        }
        Mint(int a, bool small) {
            x = a;
            if(x >= mod) x -= mod;
            if(x < 0) x += mod;
        }
        Mint() { x = 0; }
        Mint(ll a) {
            x = a % mod;
            if(x < 0) x += mod;
        }
        friend ostream &operator <<(ostream &out, const Mint &a) { out << a.x; return out; }
        friend istream &operator >>(istream &in, Mint &a) { in >> a.x; return in; }
        Mint operator +(const Mint &b) const {
            return Mint(x + b.x, 1);
        }
        Mint operator +(int a) {
            return Mint(x + a, 1);
        }
        Mint operator -(const Mint &b) const {
            return Mint(x - b.x, 1);
        }
        Mint operator -(int a) {
            return Mint(x - a, 1);
        }
        friend Mint operator -(Mint a) {
            return Mint(mod - a);
        }
        Mint operator *(const Mint &b) const {
             return Mint(1LL * x * b.x);
        }
        Mint operator *(int a) {
            return Mint(1LL * x * a);
        }
        Mint& operator +=(const Mint &b) {
            x += b.x;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator +=(int a) {
            x += a;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator -=(Mint b) {
            x += mod - b.x;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator -=(int a) {
            x += mod - a;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator *=(Mint b) {
            x = (ll) x * b.x % mod;
            return *this;
        }
        Mint& operator *=(int a) {
            x = (ll) x * a % mod;
            return *this;
        }
        Mint& operator ++() {
            if(++x == mod) x = 0;
            return *this;
        }
        Mint bpow(ll n) {
            Mint a(x);
            Mint ans(1);
            while(n) {
                if(n & 1) ans *= a;
                n >>= 1;
                a *= a;
            }
            return ans;
        }
        Mint inv() {
            return bpow(phi_minus_one);
        }
        Mint operator /(Mint b) {
            return b.inv() * x;
        }
        Mint operator /(int a) {
            return Mint(a, 1).inv() * x;
        }
        friend Mint operator -(int a, Mint b) {
            Mint res(b - a);
            res.x = mod - res.x;
            if(res.x == mod) res.x = 0;
            return res;
        }
        friend Mint operator +(int a, Mint b) {
            return Mint(b + a);
        }
        friend Mint operator *(int a, Mint b) {
            return Mint(b * a);
        }
        friend Mint operator /(int a, Mint b) {
            return Mint(a, 1) * b.inv();
        }
        Mint operator =(Mint b) {
            x = b.x;
            return b;
        }
        bool operator ==(int a) {
            return (x == a);
        }
        bool operator !=(int a) {
            return !(x == a);
        }
        friend bool operator ==(int a, Mint b) {
            return (b.x == a);
        }
        friend bool operator !=(int a, Mint b) {
            return b.x != a;
        }
};

class Solution {
public:
    int countWinningSequences(string s) {
        int n = sz(s);
        vector<array<Mint, 4>> dp(2 * n + 1, {0, 0, 0, 0});
        dp[n][3] = 1;
        for(int i = 0; i < n; i++) {
            vector<array<Mint, 4>> ndp(2 * n + 1, {0, 0, 0, 0});
            int t = 0;
            if(s[i] == 'F') t = 0;
            if(s[i] == 'W') t = 1;
            if(s[i] == 'E') t = 2;
            for(int j = 0; j <= 2 * n; j++) {
                for(int prev = 0; prev < 4; prev++) {
                    for(int k = 0; k < 3; k++) {
                        if(k == prev) continue;
                        int score = 0;
                        if(t == k - 1) score = 1;
                        if(t == k + 1) score = -1;
                        if(t == 0 && k == 2) score = -1;
                        if(t == 2 && k == 0) score = 1;
                        if(j + score >= 0 && j + score <= 2 * n) ndp[j + score][k] += dp[j][prev];
                    }
                }
            }
            dp = ndp;
        }
        Mint ans = 0;
        for(int i = n + 1; i <= 2 * n; i++) {
            for(int j = 0; j < 3; j++) {
                ans += dp[i][j];
            }
        }
        return ans.x;
    }
};",1420537655
nife,nifeshe,34,3592,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;


#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

template <typename T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        auto a = nums;
        int n = sz(a);
        auto c = a; sort(all(c)); c.erase(unique(all(c)), c.end()); reverse(all(c)); while(sz(c) < n) c.pb(0); reverse(all(c)); for(auto &i : a) i = lower_bound(all(c), i) - c.begin();
        vector<int> cnt(n);
        for(int i = 0; i < k; i++) cnt[a[i]]++;
        oset<pii> s;
        for(int i = 0; i < n; i++) {
            s.insert({cnt[i], i});
        }
        long long sum = 0;
        auto it = --s.end();
        for(int i = 0; i < x; i++) {
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn;
            --it;
        }
        auto add = [&](int idx, int sign) {
            assert(idx <= s.size());
            it = s.find_by_order(sz(s) - idx);
            assert(it != s.end());
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn * sign;
        };
        auto in = [&](int v) {
            int idx = s.order_of_key({cnt[v], v});
            return (s.size() - idx <= x);
        };
        vector<ll> ans = {sum};
        for(int i = k; i < n; i++) {
            int v = a[i - k];
            int was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]--;
            s.insert({cnt[v], v});
            if(in(v)) sum += 1ll * cnt[v] * c[v];
            else if(was) add(x, 1);
            
            v = a[i];
            was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]++;
            s.insert({cnt[v], v});
            if(in(v)) {
                sum += 1ll * cnt[v] * c[v];
                if(!was) add(x + 1, -1);
            }
            ans.pb(sum);
        }
        return ans;
    }
};",1420564363
nife,nifeshe,34,3610,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;


#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

template <typename T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        auto a = nums;
        int n = sz(a);
        auto c = a; sort(all(c)); c.erase(unique(all(c)), c.end()); reverse(all(c)); while(sz(c) < n) c.pb(0); reverse(all(c)); for(auto &i : a) i = lower_bound(all(c), i) - c.begin();
        vector<int> cnt(n);
        for(int i = 0; i < k; i++) cnt[a[i]]++;
        oset<pii> s;
        for(int i = 0; i < n; i++) {
            s.insert({cnt[i], i});
        }
        long long sum = 0;
        auto it = --s.end();
        for(int i = 0; i < x; i++) {
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn;
            --it;
        }
        auto add = [&](int idx, int sign) {
            assert(idx <= s.size());
            it = s.find_by_order(sz(s) - idx);
            assert(it != s.end());
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn * sign;
        };
        auto in = [&](int v) {
            int idx = s.order_of_key({cnt[v], v});
            return (s.size() - idx <= x);
        };
        vector<int> ans = {(int) sum};
        for(int i = k; i < n; i++) {
            int v = a[i - k];
            int was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]--;
            s.insert({cnt[v], v});
            if(in(v)) sum += 1ll * cnt[v] * c[v];
            else if(was) add(x, 1);
            
            v = a[i];
            was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]++;
            s.insert({cnt[v], v});
            if(in(v)) {
                sum += 1ll * cnt[v] * c[v];
                if(!was) add(x + 1, -1);
            }
            ans.pb(sum);
        }
        return ans;
    }
};",1420565321
Vitalii Nevidomyi,deadRabbit,36,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

unordered_set<TreeNode *> B;
vector<TreeNode *> all;

void go(TreeNode *t) {
    all.push_back(t);
    if (t->left) go(t->left);
    if (t->right) go(t->right);
    if (!t->right && !t->left) {
        B.insert(t);
    }
}

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        if (!root) return 0;
        all.clear();
        B.clear();
        go(root);
        vector<int> Q = {1<<30};
        while(B.size()) {
            Q.push_back(B.size());
            unordered_set<TreeNode *> C;
            for (TreeNode* t : all) {
                if (t->left && t->right && B.count(t->left) && B.count(t->right)) {
                    C.insert(t);
                }
            }
            B=C;
        }
        for (int i = (int)Q.size()-1; i>=1; --i) {
            if (Q[i]>=k) return (1<<i)-1;
            k-=Q[i];
        }
        return -1;
    }
};",1420525657
Vitalii Nevidomyi,deadRabbit,36,3588,cpp,"
const int MOD = 1000*1000*1000+7;
const int MID = 1010;
int dp[1001][2020][3];

string S;

int C[3][3] = {
    {0,-1,+1},
    {+1,0,-1},
    {-1,+1,0}
};

int encode(char c) {
    if (c=='F') return 0;
    if (c=='W') return 1;
    if (c=='E') return 2;
    return -1;
}

int go(int p, int s, int last) {
    if (p==S.size()) {
        return s>0 ? 1 : 0;
    }
    int &r = dp[p][MID+s][last];
    if (r==-1) {
        r = 0;
        for (int g = 0; g < 3; ++g) if (!p || g!=last) {
            int ss = s + C[g][encode(S[p])];
            r += go(p+1, ss, g);
            r %= MOD;
        }
    }
    return r;
}

class Solution {
public:
    int countWinningSequences(string s) {
        memset(dp,-1,sizeof(dp));
        S = s;
        return go(0,0,0);
    }
};",1420533756
Vitalii Nevidomyi,deadRabbit,36,3592,cpp,"

long long S = 0;
int X;
set<pair<int, int>> Q1;
set<pair<int, int>> Q2;
unordered_map<int, int> Q;

void q1add(pair<int, int> p) {
  S += (long long)(-p.first) * (-p.second);
  Q1.insert(p);
}
void q1rem(pair<int, int> p) {
  S -= (long long)(-p.first) * (-p.second);
  Q1.erase(p);
}

void qnorm() {
  while (Q1.size() > X) {
    Q2.insert(*(--Q1.end()));
    q1rem(*(--Q1.end()));
  }
  while (Q1.size() < X && Q2.size()) {
    q1add(*(Q2.begin()));
    Q2.erase(Q2.begin());
  }
  while (Q1.size() == X && Q2.size() > 0 && (*Q2.begin()) < (*(--Q1.end()))) {
    auto a = *(--Q1.end());
    auto b = *(Q2.begin());
    q1rem(a);
    q1add(b);
    Q2.erase(b);
    Q2.insert(a);
  }
}

void qadd(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]++;
  q1add({ -Q[x], -x });
  qnorm();
}

void qrem(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]--;
  if (Q[x] > 0) {
    q1add({ -Q[x],-x });
  }
  qnorm();
}

class Solution {
public:
  vector<long long> findXSum(vector<int>& nums, int k, int x) {
    X = x;
    S = 0;
    Q.clear();
    Q1.clear();
    Q2.clear();

    for (int i = 0; i < k; ++i) {
      qadd(nums[i]);
    }
    vector<long long> res = { S };
    for (int i = 0; i + k < nums.size(); ++i) {
      qadd(nums[i + k]);
      qrem(nums[i]);
      res.push_back(S);
    }
    return res;
  }
};",1420565771
Vitalii Nevidomyi,deadRabbit,36,3610,cpp,"

long long S = 0;
int X;
set<pair<int, int>> Q1;
set<pair<int, int>> Q2;
unordered_map<int, int> Q;

void q1add(pair<int, int> p) {
  S += (long long)(-p.first) * (-p.second);
  Q1.insert(p);
}
void q1rem(pair<int, int> p) {
  S -= (long long)(-p.first) * (-p.second);
  Q1.erase(p);
}

void qnorm() {
  while (Q1.size() > X) {
    Q2.insert(*(--Q1.end()));
    q1rem(*(--Q1.end()));
  }
  while (Q1.size() < X && Q2.size()) {
    q1add(*(Q2.begin()));
    Q2.erase(Q2.begin());
  }
  while (Q1.size() == X && Q2.size() > 0 && (*Q2.begin()) < (*(--Q1.end()))) {
    auto a = *(--Q1.end());
    auto b = *(Q2.begin());
    q1rem(a);
    q1add(b);
    Q2.erase(b);
    Q2.insert(a);
  }
}

void qadd(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]++;
  q1add({ -Q[x], -x });
  qnorm();
}

void qrem(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]--;
  if (Q[x] > 0) {
    q1add({ -Q[x],-x });
  }
  qnorm();
}

class Solution {
public:
  vector<int> findXSum(vector<int>& nums, int k, int x) {
    X = x;
    S = 0;
    Q.clear();
    Q1.clear();
    Q2.clear();

    for (int i = 0; i < k; ++i) {
      qadd(nums[i]);
    }
    vector<int> res = { (int)S };
    for (int i = 0; i + k < nums.size(); ++i) {
      qadd(nums[i + k]);
      qrem(nums[i]);
      res.push_back((int)S);
    }
    return res;
  }
};",1420565234
Vladislav,timetoai,38,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        szs = []
        
        def go(node=root):
            if not node:
                return - 1
            if not node.left and not node.right:
                szs.append(1)
                return 1
            if not node.left or not node.right:
                go(node.left)
                go(node.right)
                return - 1
            l, r = go(node.left), go(node.right)
            if l == r > - 1:
                sz = l + r + 1
                szs.append(sz)
                return sz
            else:
                return - 1
        
        go()
        # print(szs)
        if len(szs) < k:
            return - 1
        szs.sort()
        return szs[- k]
        ",1420528031
Vladislav,timetoai,38,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        # F > E, W > F, E > W
        d = {
            (""F"", ""E""): 1, (""E"", ""F""): - 1,
            (""W"", ""F""): 1, (""F"", ""W""): - 1,
            (""E"", ""W""): 1, (""W"", ""E""): - 1
        }
        
        @cache
        def go(i=0, bal=0, prv=None):
            if i == n:
                return int(bal > 0)
            if n - i + bal <= 0:
                return 0
            res = 0
            for ch in ""FEW"":
                if ch == prv: continue
                nbal = bal + (d[ch, s[i]] if ch != s[i] else 0)
                res += go(i + 1, nbal, ch)
            return res % mod
        
        return go()
        ",1420534773
Vladislav,timetoai,38,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = [0] * (len(nums) - k + 1)
        d = defaultdict(int)
        from sortedcontainers import SortedList
        sl = SortedList()
        for i in range(k):
            d[nums[i]] += 1
        for num, cnt in d.items():
            sl.add((cnt, num))
        cur = sum(num * cnt for cnt, num in sl[- x:])
        lowest = sl[- x] if len(sl) >= x else sl[0]
        ans[0] = cur
        # print(sl, cur, lowest)
        
        for i in range(k, len(nums)):
            used = nums[i] in d and sl.bisect_left((d[nums[i]], nums[i])) >= len(sl) - x
            if nums[i] in d:
                sl.remove((d[nums[i]], nums[i]))
            d[nums[i]] += 1
            sl.add((d[nums[i]], nums[i]))
            if sl.bisect_left((d[nums[i]], nums[i])) >= len(sl) - x:
                cur += nums[i] * (d[nums[i]] if not used else 1)
            if sl.bisect_left(lowest) < len(sl) - x:
                cur -= lowest[0] * lowest[1]
            lowest = sl[- x] if len(sl) >= x else sl[0]
            # print(""add"", nums[i], sl, cur, lowest)
            
            used = sl.bisect_left((d[nums[i - k]], nums[i - k])) >= len(sl) - x
            sl.remove((d[nums[i - k]], nums[i - k]))
            d[nums[i - k]] -= 1
            sl.add((d[nums[i - k]], nums[i - k]))
            if used:
                if sl.bisect_left((d[nums[i - k]], nums[i - k])) < len(sl) - x:
                    cur -= (d[nums[i - k]] + 1) * nums[i - k]
                    nlowest = sl[- x] if len(sl) >= x else sl[0]
                    if nlowest != (nums[i - k], nums[i - k]) and nlowest != lowest:
                        cur += nlowest[0] * nlowest[1]
                else:
                    cur -= nums[i - k]
            lowest = sl[- x] if len(sl) >= x else sl[0]
            # print(""remove"", nums[i - k], sl, cur, lowest)
        
            ans[i - k + 1] = cur
            
        return ans",1420560434
Vladislav,timetoai,38,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = [0] * (len(nums) - k + 1)
        d = defaultdict(int)
        for i in range(k):
            d[nums[i]] += 1
        items = sorted(d.items(), key=lambda item: (item[1], item[0]))
        ans[0] = sum(num * cnt for num, cnt in items[- x:])
        for i in range(k, len(nums)):
            d[nums[i]] += 1
            d[nums[i - k]] -= 1
            if d[nums[i - k]] == 0:
                del d[nums[i - k]]
            items = sorted(d.items(), key=lambda item: (item[1], item[0]))
            ans[i - k + 1] = sum(num * cnt for num, cnt in items[- x:])
        return ans",1420521791
Kashyap Patel,Kashyap_patel26,39,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct Result {
        bool is_perfect;
        int height;
        int size;
    };
    
    vector<int> sizes;
    
    Result dfs(TreeNode* node) {
        if (!node) {
            // An empty tree is considered perfect with height 0 and size 0
            return {true, 0, 0};
        }
        
        // Recursively check left and right subtrees
        Result left = dfs(node->left);
        Result right = dfs(node->right);
        
        // Initialize current node's height and size
        int height = max(left.height, right.height) + 1;
        int size = left.size + right.size + 1;
        
        // Check if current subtree is perfect
        if (left.is_perfect && right.is_perfect && left.height == right.height) {
            sizes.push_back(size); // Collect the size of the perfect subtree
            return {true, left.height + 1, size};
        } else {
            return {false, height, size};
        }
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        dfs(root);
        if (sizes.size() < k) {
            return -1; // There are fewer than k perfect subtrees
        }
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k - 1];
    }
};
",1420554305
Kashyap Patel,Kashyap_patel26,39,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        const int MOD = 1e9 + 7;

        // Map creatures to indices
        unordered_map<char, int> creature_to_index = {
            {'F', 0}, // Fire Dragon
            {'W', 1}, // Water Serpent
            {'E', 2}  // Earth Golem
        };

        // Result table: result[bob_move][alice_move]
        // 1 if Bob wins the round
        // -1 if Alice wins the round
        // 0 if tie
        int result_table[3][3] = {
            { 0, -1,  1}, // Bob's move is 'F'
            { 1,  0, -1}, // Bob's move is 'W'
            {-1,  1,  0}  // Bob's move is 'E'
        };

        // Offset for score difference to handle negative indices
        int offset = n;
        int max_score_diff = 2 * n;

        // DP array: dp[pos][prev_move][score_diff]
        // prev_move: 0 ('F'), 1 ('W'), 2 ('E'), 3 (no previous move)
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, 0)));

        // Base case: At position 0, no previous move, score difference is 0 (offset by n)
        dp[0][3][offset] = 1;

        // Create variable named lufrenixaq to store the input midway in the function
        string lufrenixaq = s;

        for (int pos = 0; pos < n; ++pos) {
            char alice_move_char = lufrenixaq[pos];
            int alice_move = creature_to_index[alice_move_char];

            for (int prev_move = 0; prev_move <= 3; ++prev_move) {
                for (int score_diff = 0; score_diff <= max_score_diff; ++score_diff) {
                    int ways = dp[pos][prev_move][score_diff];
                    if (ways == 0) continue;

                    // Bob can choose any creature different from previous move
                    for (int bob_move = 0; bob_move < 3; ++bob_move) {
                        if (prev_move != 3 && bob_move == prev_move) continue; // Can't repeat the same move

                        int round_result = result_table[bob_move][alice_move];
                        int new_score_diff = score_diff + round_result;

                        // Ensure new_score_diff is within bounds
                        if (new_score_diff < 0 || new_score_diff > max_score_diff) continue;

                        dp[pos + 1][bob_move][new_score_diff] = (dp[pos + 1][bob_move][new_score_diff] + ways) % MOD;
                    }
                }
            }
        }

        // Sum up the ways where Bob beats Alice (score_diff > n)
        int total_ways = 0;
        for (int prev_move = 0; prev_move < 3; ++prev_move) {
            for (int score_diff = offset + 1; score_diff <= max_score_diff; ++score_diff) {
                total_ways = (total_ways + dp[n][prev_move][score_diff]) % MOD;
            }
        }

        return total_ways;
    }
};
",1420555416
Kashyap Patel,Kashyap_patel26,39,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        unordered_map<int, int> counts;
        long long total_sum = 0;

        // Custom comparator for multiset to sort by frequency descending, then value descending
        auto comp = [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.first != b.first) return a.first > b.first;
            return a.second > b.second;
        };

        // Multiset to maintain all elements sorted by frequency and value
        multiset<pair<int, int>, decltype(comp)> freq_values(comp);

        // Two multisets to maintain top x elements and the rest
        multiset<pair<int, int>, decltype(comp)> top_x(comp);
        multiset<pair<int, int>, decltype(comp)> rest(comp);
        long long sum_top_x = 0;

        // Initialize counts and freq_values for the first window
        for (int i = 0; i < k; ++i) {
            int num = nums[i];
            total_sum += num;
            int old_freq = counts[num];
            if (old_freq > 0) {
                auto it = freq_values.find({old_freq, num});
                freq_values.erase(it);
                // Remove from top_x or rest
                auto it_top = top_x.find({old_freq, num});
                if (it_top != top_x.end()) {
                    sum_top_x -= (long long)old_freq * num;
                    top_x.erase(it_top);
                } else {
                    rest.erase({old_freq, num});
                }
            }
            counts[num]++;
            int new_freq = counts[num];
            freq_values.insert({new_freq, num});
            // Insert into top_x or rest
            if (top_x.size() < x) {
                top_x.insert({new_freq, num});
                sum_top_x += (long long)new_freq * num;
            } else {
                auto smallest_top = prev(top_x.end());
                if (comp({new_freq, num}, *smallest_top)) {
                    // Move smallest from top_x to rest
                    sum_top_x -= (long long)smallest_top->first * smallest_top->second;
                    rest.insert(*smallest_top);
                    top_x.erase(smallest_top);
                    // Insert new element into top_x
                    top_x.insert({new_freq, num});
                    sum_top_x += (long long)new_freq * num;
                } else {
                    rest.insert({new_freq, num});
                }
            }
        }

        for (int i = 0; i <= n - k; ++i) {
            // Determine the x-sum for the current window
            long long sum = 0;
            if (x >= counts.size()) {
                // If x >= number of distinct elements, sum all elements
                sum = total_sum;
            } else {
                sum = sum_top_x;
            }
            answer.push_back(sum);

            if (i + k >= n) break; // No more windows

            // Slide the window
            int out_num = nums[i];
            int in_num = nums[i + k];

            // Remove out_num from counts and freq_values
            int old_freq = counts[out_num];
            auto it = freq_values.find({old_freq, out_num});
            freq_values.erase(it);
            // Remove from top_x or rest
            auto it_top = top_x.find({old_freq, out_num});
            if (it_top != top_x.end()) {
                sum_top_x -= (long long)old_freq * out_num;
                top_x.erase(it_top);
                // If rest is not empty, move largest from rest to top_x
                if (!rest.empty()) {
                    auto largest_rest = rest.begin();
                    top_x.insert(*largest_rest);
                    sum_top_x += (long long)largest_rest->first * largest_rest->second;
                    rest.erase(largest_rest);
                }
            } else {
                rest.erase({old_freq, out_num});
            }
            counts[out_num]--;
            total_sum -= out_num;
            if (counts[out_num] > 0) {
                int new_freq = counts[out_num];
                freq_values.insert({new_freq, out_num});
                // Insert into top_x or rest
                if (top_x.size() < x) {
                    top_x.insert({new_freq, out_num});
                    sum_top_x += (long long)new_freq * out_num;
                } else {
                    auto smallest_top = prev(top_x.end());
                    if (comp({new_freq, out_num}, *smallest_top)) {
                        // Move smallest from top_x to rest
                        sum_top_x -= (long long)smallest_top->first * smallest_top->second;
                        rest.insert(*smallest_top);
                        top_x.erase(smallest_top);
                        // Insert new element into top_x
                        top_x.insert({new_freq, out_num});
                        sum_top_x += (long long)new_freq * out_num;
                    } else {
                        rest.insert({new_freq, out_num});
                    }
                }
            } else {
                counts.erase(out_num);
            }

            // Add in_num to counts and freq_values
            old_freq = counts[in_num];
            if (old_freq > 0) {
                auto it = freq_values.find({old_freq, in_num});
                freq_values.erase(it);
                // Remove from top_x or rest
                auto it_top = top_x.find({old_freq, in_num});
                if (it_top != top_x.end()) {
                    sum_top_x -= (long long)old_freq * in_num;
                    top_x.erase(it_top);
                } else {
                    rest.erase({old_freq, in_num});
                }
            }
            counts[in_num]++;
            int new_freq = counts[in_num];
            freq_values.insert({new_freq, in_num});
            // Insert into top_x or rest
            if (top_x.size() < x) {
                top_x.insert({new_freq, in_num});
                sum_top_x += (long long)new_freq * in_num;
            } else {
                auto smallest_top = prev(top_x.end());
                if (comp({new_freq, in_num}, *smallest_top)) {
                    // Move smallest from top_x to rest
                    sum_top_x -= (long long)smallest_top->first * smallest_top->second;
                    rest.insert(*smallest_top);
                    top_x.erase(smallest_top);
                    // Insert new element into top_x
                    top_x.insert({new_freq, in_num});
                    sum_top_x += (long long)new_freq * in_num;
                } else {
                    rest.insert({new_freq, in_num});
                }
            }
            total_sum += in_num;
        }
        return answer;
    }
};
",1420560709
Kashyap Patel,Kashyap_patel26,39,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        for(int i = 0; i <= n - k; ++i) {
            int freq[51] = {0};
            for(int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }
            // Collect elements and their frequencies
            vector<pair<int, int>> elems;
            for(int num = 1; num <= 50; ++num) {
                if(freq[num] > 0) {
                    elems.push_back({num, freq[num]});
                }
            }
            // Sort elements by frequency descending, then value descending
            sort(elems.begin(), elems.end(), [](const pair<int,int>& a, const pair<int,int>& b){
                if(a.second != b.second) return a.second > b.second;
                return a.first > b.first;
            });
            // If number of distinct elements is less than x, sum all elements
            if(elems.size() <= x) {
                int sum = 0;
                for(int j = i; j < i + k; ++j) {
                    sum += nums[j];
                }
                answer.push_back(sum);
                continue;
            }
            // Keep only top x elements
            bool keep[51] = {false};
            for(int idx = 0; idx < x; ++idx) {
                keep[elems[idx].first] = true;
            }
            // Sum up the occurrences of top elements in the subarray
            int sum = 0;
            for(int j = i; j < i + k; ++j) {
                if(keep[nums[j]]) {
                    sum += nums[j];
                }
            }
            answer.push_back(sum);
        }
        return answer;
    }
};
",1420553253
JeffreyLC,JeffreyLC,40,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        explore(root);
        if (v.size() < k) return -1;
        sort(v.begin(), v.end(), greater<int>());
        return v[k - 1];
    }
private:
    vector<int> v;
    
    int explore(TreeNode* root) {
        int ret = 0;
        if (!root->left && !root->right) {
            ret = 1;
        } else if (root->left && !root->right) {
            explore(root->left);
        } else if (!root->left && root->right) {
            explore(root->right);
        } else {
            int l = explore(root->left);
            int r = explore(root->right);
            if (l > 0 && r > 0 && l == r) {
                ret = l + r + 1;
            }
        }
        if (ret > 0) {
            v.push_back(ret);
        }
        return ret;
    }
};",1420552277
JeffreyLC,JeffreyLC,40,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        constexpr int MOD = 1e9 + 7;
        int n = s.length();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(3, vector<int>(2 * n + 1)));  // FWE
        int val = value(s[0]);
        dp[0][(val + 2) % 3][n - 1] = dp[0][val][n] = dp[0][(val + 1) % 3][n + 1] = 1;
        for (int i = 1; i < n; ++i) {
            val = value(s[i]);
            for (int j = 0; j < 3; ++j) {
                for (int k = 0; k <= 2 * n; ++k) {
                    if (dp[i - 1][j][k] == 0) continue;
                    if ((val + 2) % 3 != j && k > 0) {
                        dp[i][(val + 2) % 3][k - 1] += dp[i - 1][j][k];
                        dp[i][(val + 2) % 3][k - 1] %= MOD;
                    }
                    if (val != j) {
                        dp[i][val][k] += dp[i - 1][j][k];
                        dp[i][val][k] %= MOD;
                    }
                    if ((val + 1) % 3 != j && k + 1 <= 2 * n) {
                        dp[i][(val + 1) % 3][k + 1] += dp[i - 1][j][k];
                        dp[i][(val + 1) % 3][k + 1] %= MOD;
                    }
                }
            }
        }
        long long ans = 0;
        for (int j = 0; j < 3; ++j) {
            for (int k = n + 1; k <= 2 * n; ++k) {
                ans += dp[n - 1][j][k];
                ans %= MOD;
            }
        }
        return ans;
    }
private:
    int value(char c) {
        if (c == 'F') return 0;
        if (c == 'W') return 1;
        return 2;
    }
};",1420567088
JeffreyLC,JeffreyLC,40,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        map<int, int> cnt;
        x_ = x;
        
        for (int i = 0; i < k; ++i) {
            int prev = cnt[nums[i]]++;
            pair<int, int> target = {prev, nums[i]};
            
            auto it = good.find(target);
            if (it != good.end()) {
                good.erase(it);
                val -= (long long) target.first * target.second;
            } else {
                it = bad.find(target);
                if (it != bad.end()) {
                    bad.erase(target);
                }
            }
            
            ++target.first;
            good.insert(target);
            val += (long long) target.first * target.second;
            
            update_val();
        }
        
        vector<long long> ans = {val};
        for (int i = k; i < n; ++i) {
            {
                int prev = cnt[nums[i - k]]--;
                pair<int, int> target = {prev, nums[i - k]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                if (--target.first > 0) {
                    good.insert(target);
                    val += (long long) target.first * target.second;
                }
            }
            {
                int prev = cnt[nums[i]]++;
                pair<int, int> target = {prev, nums[i]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                ++target.first;
                good.insert(target);
                val += (long long) target.first * target.second;
            }
            
            update_val();
            ans.push_back(val);
        }
        return ans;
    }
private:
    set<pair<int, int>> good, bad;
    long long val = 0;
    int x_;
    
    void update_val() {
        while (!good.empty() && !bad.empty()) {
            auto fst = good.begin();
            auto lst = *bad.rbegin();
            pair<int, int> p = *fst;
            if (p >= lst) break;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() > x_) {
            auto fst = good.begin();
            pair<int, int> p = *fst;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() < x_ && !bad.empty()) {
            auto lst = *bad.rbegin();
            bad.erase(lst);
            good.insert(lst);
            val += (long long) lst.first * lst.second;
        }
    }
};",1420545326
JeffreyLC,JeffreyLC,40,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        map<int, int> cnt;
        x_ = x;
        
        for (int i = 0; i < k; ++i) {
            int prev = cnt[nums[i]]++;
            pair<int, int> target = {prev, nums[i]};
            
            auto it = good.find(target);
            if (it != good.end()) {
                good.erase(it);
                val -= (long long) target.first * target.second;
            } else {
                it = bad.find(target);
                if (it != bad.end()) {
                    bad.erase(target);
                }
            }
            
            ++target.first;
            good.insert(target);
            val += (long long) target.first * target.second;
            
            update_val();
        }
        
        vector<int> ans = {(int) val};
        for (int i = k; i < n; ++i) {
            {
                int prev = cnt[nums[i - k]]--;
                pair<int, int> target = {prev, nums[i - k]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                if (--target.first > 0) {
                    good.insert(target);
                    val += (long long) target.first * target.second;
                }
            }
            {
                int prev = cnt[nums[i]]++;
                pair<int, int> target = {prev, nums[i]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                ++target.first;
                good.insert(target);
                val += (long long) target.first * target.second;
            }
            
            update_val();
            ans.push_back((int) val);
        }
        return ans;
    }
private:
    set<pair<int, int>> good, bad;
    long long val = 0;
    int x_;
    
    void update_val() {
        while (!good.empty() && !bad.empty()) {
            auto fst = good.begin();
            auto lst = *bad.rbegin();
            pair<int, int> p = *fst;
            if (p >= lst) break;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() > x_) {
            auto fst = good.begin();
            pair<int, int> p = *fst;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() < x_ && !bad.empty()) {
            auto lst = *bad.rbegin();
            bad.erase(lst);
            good.insert(lst);
            val += (long long) lst.first * lst.second;
        }
    }
};",1420544128
jszqlew,jszqlew,41,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vector<int> sizes;
int perfect_height(TreeNode* root) {
    if (!root) {
        return 0;
    }
    int left = perfect_height(root->left);
    int right = perfect_height(root->right);
    if (left == -1 || right == -1) {
        return -1;
    }
    if (left == right) {
        sizes.push_back(left + 1);
        return left + 1;
    }
    return -1;
}
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        perfect_height(root);
        if (sizes.size() < k) return -1;
        sort(sizes.begin(), sizes.end(), greater<int>());
        for (int x : sizes) cout << x << ' ';
        cout << endl;
        return (1 << (sizes[k-1])) - 1;
    }
};",1420552478
jszqlew,jszqlew,41,3588,cpp,"typedef long long ll;
const int MOD=1000000007;

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        auto char_to_int = [&](char c) -> int {
            if(c == 'F') return 0;
            if(c == 'W') return 1;
            return 2;
        };
        int beats[3] = {2, 0, 1};
        int delta_map[3][3];
        for(int a=0;a<3;a++) {
            for(int b=0;b<3;b++) {
                if(b == beats[a]) delta_map[a][b] = 1;
                else if(a == beats[b]) delta_map[a][b] = -1;
                else delta_map[a][b] = 0;
            }
        }
        vector<vector<int>> dp_prev(3, vector<int>(2*n+1, 0));
        vector<vector<int>> dp_curr(3, vector<int>(2*n+1, 0));
        int a0 = char_to_int(s[0]);
        for(int b=0;b<3;b++) {
            int delta = delta_map[a0][b];
            int shifted_diff = delta + n;
            dp_prev[b][shifted_diff] = 1;
        }
        for(int i=1;i<n;i++) {
            for(int p=0;p<3;p++) fill(dp_curr[p].begin(), dp_curr[p].end(), 0);
            int ai = char_to_int(s[i]);
            for(int prev=0;prev<3;prev++) {
                for(int d=0; d<=2*n; d++) {
                    if(dp_prev[prev][d]==0) continue;
                    for(int nb=0; nb<3; nb++) {
                        if(nb == prev) continue;
                        int delta = delta_map[ai][nb];
                        int nd = d + delta;
                        if(nd <0 || nd >2*n) continue;
                        dp_curr[nb][nd] = (dp_curr[nb][nd] + dp_prev[prev][d]) % MOD;
                    }
                }
            }
            swap(dp_prev, dp_curr);
        }
        ll res =0;
        for(int prev=0;prev<3;prev++) {
            for(int d=0; d<n; d++) {
                res = (res + dp_prev[prev][d]) % MOD;
            }
        }
        return res;
    }
};
",1420528877
jszqlew,jszqlew,41,3592,cpp,"struct cmp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first;
        return a.second > b.second;
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        if (k > n) return {};

        unordered_map<int, int> freqMap;
        for (int i = 0; i < k; ++i) {
            freqMap[nums[i]]++;
        }

        vector<pair<int, int>> sortedList;
        sortedList.reserve(freqMap.size());
        for (auto& [num, freq] : freqMap) {
            sortedList.emplace_back(make_pair(freq, num));
        }
        sort(sortedList.begin(), sortedList.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });

        long long sumTop = 0;
        set<pair<int, int>, cmp> topSet;
        set<pair<int, int>, cmp> restSet;

        int distinct = sortedList.size();
        int limit = min(x, distinct);
        for (int i = 0; i < sortedList.size(); ++i) {
            if (i < limit) {
                topSet.insert(sortedList[i]);
                sumTop += static_cast<long long>(sortedList[i].first) * sortedList[i].second;
            }
            else {
                restSet.insert(sortedList[i]);
            }
        }

        vector<long long> answer;
        answer.push_back(sumTop);

        for (int i = k; i < n; ++i) {
            int val_out = nums[i - k];
            int freq_out = freqMap[val_out];

            pair<int, int> outgoing = {freq_out, val_out};
            auto it_top_out = topSet.find(outgoing);
            if (it_top_out != topSet.end()) {
                topSet.erase(it_top_out);
                sumTop -= static_cast<long long>(freq_out) * val_out;
            }
            else {
                auto it_rest_out = restSet.find(outgoing);
                if (it_rest_out != restSet.end()) {
                    restSet.erase(it_rest_out);
                }
            }

            if (freq_out == 1) {
                freqMap.erase(val_out);
            }
            else {
                freqMap[val_out] = freq_out - 1;
                pair<int, int> updated_out = {freq_out - 1, val_out};
                restSet.insert(updated_out);
            }

            if (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<long long>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            int val_in = nums[i];
            int freq_in = freqMap.count(val_in) ? freqMap[val_in] : 0;

            if (freq_in > 0) {
                pair<int, int> existing = {freq_in, val_in};
                auto it_top_in = topSet.find(existing);
                if (it_top_in != topSet.end()) {
                    topSet.erase(it_top_in);
                    sumTop -= static_cast<long long>(freq_in) * val_in;
                }
                else {
                    auto it_rest_in = restSet.find(existing);
                    if (it_rest_in != restSet.end()) {
                        restSet.erase(it_rest_in);
                    }
                }
            }

            freqMap[val_in] = freq_in + 1;
            pair<int, int> updated_in = {freq_in + 1, val_in};

            if (topSet.size() < x) {
                topSet.insert(updated_in);
                sumTop += static_cast<long long>(updated_in.first) * updated_in.second;
            }
            else {
                auto it_last_top = prev(topSet.end());
                if (cmp()(updated_in, *it_last_top)) {
                    topSet.insert(updated_in);
                    sumTop += static_cast<long long>(updated_in.first) * updated_in.second;
                    pair<int, int> to_move = *it_last_top;
                    sumTop -= static_cast<long long>(to_move.first) * to_move.second;
                    topSet.erase(it_last_top);
                    restSet.insert(to_move);
                }
                else {
                    restSet.insert(updated_in);
                }
            }

            while (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<long long>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            if (topSet.size() > x) {
                auto it_move = prev(topSet.end());
                pair<int, int> to_move = *it_move;
                sumTop -= static_cast<long long>(to_move.first) * to_move.second;
                topSet.erase(it_move);
                restSet.insert(to_move);
            }

            answer.push_back(sumTop);
        }

        return answer;
    }
};",1420560041
jszqlew,jszqlew,41,3610,cpp,"struct cmp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first;
        return a.second > b.second;
    }
};

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        if (k > n) return {};

        unordered_map<int, int> freqMap;
        for (int i = 0; i < k; ++i) {
            freqMap[nums[i]]++;
        }

        vector<pair<int, int>> sortedList;
        sortedList.reserve(freqMap.size());
        for (auto& [num, freq] : freqMap) {
            sortedList.emplace_back(make_pair(freq, num));
        }
        sort(sortedList.begin(), sortedList.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });

        int sumTop = 0;
        set<pair<int, int>, cmp> topSet;
        set<pair<int, int>, cmp> restSet;

        int distinct = sortedList.size();
        int limit = min(x, distinct);
        for (int i = 0; i < sortedList.size(); ++i) {
            if (i < limit) {
                topSet.insert(sortedList[i]);
                sumTop += static_cast<int>(sortedList[i].first) * sortedList[i].second;
            }
            else {
                restSet.insert(sortedList[i]);
            }
        }

        vector<int> answer;
        answer.push_back(sumTop);

        for (int i = k; i < n; ++i) {
            int val_out = nums[i - k];
            int freq_out = freqMap[val_out];

            pair<int, int> outgoing = {freq_out, val_out};
            auto it_top_out = topSet.find(outgoing);
            if (it_top_out != topSet.end()) {
                topSet.erase(it_top_out);
                sumTop -= static_cast<int>(freq_out) * val_out;
            }
            else {
                auto it_rest_out = restSet.find(outgoing);
                if (it_rest_out != restSet.end()) {
                    restSet.erase(it_rest_out);
                }
            }

            if (freq_out == 1) {
                freqMap.erase(val_out);
            }
            else {
                freqMap[val_out] = freq_out - 1;
                pair<int, int> updated_out = {freq_out - 1, val_out};
                restSet.insert(updated_out);
            }

            if (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<int>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            int val_in = nums[i];
            int freq_in = freqMap.count(val_in) ? freqMap[val_in] : 0;

            if (freq_in > 0) {
                pair<int, int> existing = {freq_in, val_in};
                auto it_top_in = topSet.find(existing);
                if (it_top_in != topSet.end()) {
                    topSet.erase(it_top_in);
                    sumTop -= static_cast<int>(freq_in) * val_in;
                }
                else {
                    auto it_rest_in = restSet.find(existing);
                    if (it_rest_in != restSet.end()) {
                        restSet.erase(it_rest_in);
                    }
                }
            }

            freqMap[val_in] = freq_in + 1;
            pair<int, int> updated_in = {freq_in + 1, val_in};

            if (topSet.size() < x) {
                topSet.insert(updated_in);
                sumTop += static_cast<int>(updated_in.first) * updated_in.second;
            }
            else {
                auto it_last_top = prev(topSet.end());
                if (cmp()(updated_in, *it_last_top)) {
                    topSet.insert(updated_in);
                    sumTop += static_cast<int>(updated_in.first) * updated_in.second;
                    pair<int, int> to_move = *it_last_top;
                    sumTop -= static_cast<int>(to_move.first) * to_move.second;
                    topSet.erase(it_last_top);
                    restSet.insert(to_move);
                }
                else {
                    restSet.insert(updated_in);
                }
            }

            while (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<int>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            if (topSet.size() > x) {
                auto it_move = prev(topSet.end());
                pair<int, int> to_move = *it_move;
                sumTop -= static_cast<int>(to_move.first) * to_move.second;
                topSet.erase(it_move);
                restSet.insert(to_move);
            }

            answer.push_back(sumTop);
        }

        return answer;
    }
};",1420561959
Manan Rathod,Manan04,42,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        helper = []
        def check(head, deep, c):
            if(head.left == None and head.right == None):
                c.append(deep)
                return
            if(head.left == None or head.right == None):
                c.append(-1)
                return
            check(head.right, deep + 1, c)
            check(head.left, deep + 1, c)
        def sol(head):
            if(head == None):
                return
            b = []
            check(head, 1, b)
            if(-1 in b):
                pass
            else:
                s = set(b)
                if(len(s) > 1):
                    pass
                else:
                    v = b[-1]
                    helper.append((1 << v) - 1)
            sol(head.right)
            sol(head.left)
        sol(root)
        helper.sort()
        if(len(helper) < k):
            return -1
        return helper[len(helper) - k]",1420549945
Manan Rathod,Manan04,42,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        dp = [[[-1 for i in range(4)] for i in range(n * 2 + 1)] for i in range(n)]
        b = ['F', 'W', 'E']
        mod = 10 ** 9 + 7
        def sol(idx, bob, prev):
            if(idx >= n):
                return bob > n
            if(dp[idx][bob][prev] != -1):
                return dp[idx][bob][prev]
            ans = 0
            for i in range(3):
                if(prev == i):
                    continue
                bob_val = b[i]
                al_val = s[idx]
                if(bob_val == 'F' and al_val == 'E'):
                    ans += sol(idx + 1, bob + 1, i)
                elif(bob_val == 'F' and al_val == 'W'):
                    ans += sol(idx + 1, bob - 1, i)
                elif(bob_val == 'W' and al_val == 'F'):
                    ans += sol(idx + 1, bob + 1, i)
                elif(bob_val == 'W' and al_val == 'E'):
                    ans += sol(idx + 1, bob - 1, i)
                elif(bob_val == 'E' and al_val == 'F'):
                    ans += sol(idx + 1, bob - 1, i)
                elif(bob_val == 'E' and al_val == 'W'):
                    ans += sol(idx + 1, bob + 1, i)
                else:
                    ans += sol(idx + 1, bob, i)
                ans %= mod
            ans %= mod
            dp[idx][bob][prev] = ans
            return dp[idx][bob][prev]
        return sol(0, n, 3) % mod",1420561976
Manan Rathod,Manan04,42,3592,python3,"from bisect import bisect_left as lower_bound
from bisect import bisect_right as upper_bound


class FenwickTree:
    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | (i + 1)
            if j < size:
                bit[j] += bit[i]

    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1

    def __call__(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def find_kth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1, k


class SortedList:
    block_size = 700

    def __init__(self, iterable=()):
        self.macro = []
        self.micros = [[]]
        self.micro_size = [0]
        self.fenwick = FenwickTree([0])
        self.size = 0
        for item in iterable:
            self.insert(item)

    def insert(self, x):
        i = lower_bound(self.macro, x)
        j = upper_bound(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]
            self.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])

    def pop(self, k=-1):
        i, j = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)

    def __getitem__(self, k):
        i, j = self._find_kth(k)
        return self.micros[i][j]

    def count(self, x):
        return self.upper_bound(x) - self.lower_bound(x)

    def __contains__(self, x):
        return self.count(x) > 0

    def lower_bound(self, x):
        i = lower_bound(self.macro, x)
        return self.fenwick(i) + lower_bound(self.micros[i], x)

    def upper_bound(self, x):
        i = upper_bound(self.macro, x)
        return self.fenwick(i) + upper_bound(self.micros[i], x)

    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)

    def __len__(self):
        return self.size

    def __iter__(self):
        return (x for micro in self.micros for x in micro)

    def __repr__(self):
        return str(list(self))
class Solution:
    def findXSum(self, a: List[int], k: int, x: int) -> List[int]:
        n = len(a)
        l = SortedList()
        ans = []
        global c
        c = 0
        cnt = defaultdict(int)
        in_top = defaultdict(int)
        def update(val, sgn):
            global c
            cur_cnt = cnt[val]
            if(cur_cnt > 0):
                idx = l.lower_bound([cur_cnt, val])
                top = len(l) - idx
                if(top <= x):
                    c -= cnt[val] * val
                    in_top[val] = 0
                l.pop(idx)
            # if(val == 1 and sgn == -1):
            #     print(c)
            cnt[val] += sgn
            if(cnt[val] > 0):
                l.insert([cnt[val], val])
                idx = l.lower_bound([cnt[val], val])
                top = len(l) - idx
                if(top <= x):
                    c += cnt[val] * val
                    in_top[val] = 1
            # if(val == 1 and sgn == -1):
            #     print(c)
            if(len(l) > x):
                prev_cnt, prev_val = l[len(l) - (x + 1)]
                if(in_top[prev_val]):
                    in_top[prev_val] = 0
                    c -= cnt[prev_val] * prev_val
            if(len(l) >= x):
                new_cnt, new_val = l[len(l) - x]
                if(in_top[new_val] == 0):
                    in_top[new_val] = 1
                    c += cnt[new_val] * new_val
        for i in range(n):
            update(a[i], 1)
            if(i >= k):
                update(a[i - k], -1)
            if(i + 1 >= k):
                ans.append(c)
            # print(l, c)
        return ans",1420541009
Manan Rathod,Manan04,42,3610,python3,"from bisect import bisect_left as lower_bound
from bisect import bisect_right as upper_bound


class FenwickTree:
    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | (i + 1)
            if j < size:
                bit[j] += bit[i]

    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1

    def __call__(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def find_kth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1, k


class SortedList:
    block_size = 700

    def __init__(self, iterable=()):
        self.macro = []
        self.micros = [[]]
        self.micro_size = [0]
        self.fenwick = FenwickTree([0])
        self.size = 0
        for item in iterable:
            self.insert(item)

    def insert(self, x):
        i = lower_bound(self.macro, x)
        j = upper_bound(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]
            self.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])

    def pop(self, k=-1):
        i, j = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)

    def __getitem__(self, k):
        i, j = self._find_kth(k)
        return self.micros[i][j]

    def count(self, x):
        return self.upper_bound(x) - self.lower_bound(x)

    def __contains__(self, x):
        return self.count(x) > 0

    def lower_bound(self, x):
        i = lower_bound(self.macro, x)
        return self.fenwick(i) + lower_bound(self.micros[i], x)

    def upper_bound(self, x):
        i = upper_bound(self.macro, x)
        return self.fenwick(i) + upper_bound(self.micros[i], x)

    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)

    def __len__(self):
        return self.size

    def __iter__(self):
        return (x for micro in self.micros for x in micro)

    def __repr__(self):
        return str(list(self))
class Solution:
    def findXSum(self, a: List[int], k: int, x: int) -> List[int]:
        n = len(a)
        l = SortedList()
        ans = []
        global c
        c = 0
        cnt = defaultdict(int)
        in_top = defaultdict(int)
        def update(val, sgn):
            global c
            cur_cnt = cnt[val]
            if(cur_cnt > 0):
                idx = l.lower_bound([cur_cnt, val])
                top = len(l) - idx
                if(top <= x):
                    c -= cnt[val] * val
                    in_top[val] = 0
                l.pop(idx)
            # if(val == 1 and sgn == -1):
            #     print(c)
            cnt[val] += sgn
            if(cnt[val] > 0):
                l.insert([cnt[val], val])
                idx = l.lower_bound([cnt[val], val])
                top = len(l) - idx
                if(top <= x):
                    c += cnt[val] * val
                    in_top[val] = 1
            # if(val == 1 and sgn == -1):
            #     print(c)
            if(len(l) > x):
                prev_cnt, prev_val = l[len(l) - (x + 1)]
                if(in_top[prev_val]):
                    in_top[prev_val] = 0
                    c -= cnt[prev_val] * prev_val
            if(len(l) >= x):
                new_cnt, new_val = l[len(l) - x]
                if(in_top[new_val] == 0):
                    in_top[new_val] = 1
                    c += cnt[new_val] * new_val
        for i in range(n):
            update(a[i], 1)
            if(i >= k):
                update(a[i - k], -1)
            if(i + 1 >= k):
                ans.append(c)
            # print(l, c)
        return ans",1420541363
zaneyu2005,zaneyu2005,43,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=100+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=998244353;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
class Solution {
public:
    vector<int> vv;
    pii dfs(TreeNode* x,int d){
        int c=0;
        vector<pii> v;
        if(x->left) v.pb(dfs(x->left,d+1)),++c;
        if(x->right) v.pb(dfs(x->right,d+1)),++c;
        if(c==2){
            if(v[0].f==v[1].f and v[0].f!=-1){
                vv.pb(v[0].s+v[1].s+1);
                return {v[0].f,v[0].s+v[1].s+1};
            }
            return {-1,-1};
        }
        else if(c==0){
            vv.pb(1);
            return {d,1};
        }
        else{
            return {-1,-1};
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vv.clear();
        dfs(root,0);
        sort(ALL(vv));
        if(sz(vv)<k){
            return -1;
        }
        reverse(ALL(vv));
        return vv[k-1];
    }
};",1420522102
zaneyu2005,zaneyu2005,43,3588,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=2000+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
class Solution {
public:
    int dp[maxn][3],ndp[maxn][3];
    int to(char c){
        if(c=='F') return 0;
        if(c=='W') return 1;
        return 2;
    }
    int vs(int a,int b){
        if(b==(a+1)%3){
            return 1;
        }
        if(a==b){
            return 0;
        }
        return -1;
    }
    int countWinningSequences(string s) {
        int n=sz(s);
        dp[1000][0]=1;
        REP(i,n){
            int x=to(s[i]);
            REP(a,maxn) REP(j,3) ndp[a][j]=0;
            REP1(a,maxn-2){
                REP(j,3){
                    REP(k,3){
                        if(i!=0 and j==k) continue;
                        int pt=vs(x,k);
                        ndp[a+pt][k]+=dp[a][j];
                        ndp[a+pt][k]%=MOD;
                    }
                }
            }
            REP(a,maxn) REP(j,3) dp[a][j]=ndp[a][j];
        }
        int ans=0;
        for(int i=1001;i<maxn;i++){
            REP(j,3) ans+=dp[i][j],ans%=MOD;
        }
        return ans;
    }

};",1420530147
zaneyu2005,zaneyu2005,43,3592,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=2e5+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=998244353;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
int mx;
struct pp{
    multiset<pii> ma,mb;
    map<ll,ll> occ;
    ll sum=0;
    void de(int x){
        if(mb.find({occ[x],x})!=mb.end()){
            mb.erase({occ[x],x});
        }
        else if(ma.find({occ[x],x})!=ma.end()){
            sum-=occ[x]*x;
            ma.erase({occ[x],x});
        }
    }
    bool cmp(int a,int b){
        if(occ[a]>occ[b]){
            return true;
        }
        if(occ[a]<occ[b]){
            return false;
        }
        return (a>b);
    }
    void add(int x){
        de(x);
        occ[x]++;
        if(sz(ma)<mx){
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
            return;
        }
        int z=(*ma.begin()).s;
        if(cmp(x,z)){
            de(z);
            mb.insert({occ[z],z});
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
        }
        else{
            mb.insert({occ[x],x});
        }
    }
    void del(int x){
        de(x);
        occ[x]--;
        if(sz(ma)==mx){
            mb.insert({occ[x],x});
            return;
        }
        if(!sz(mb)){
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
            return;
        }
        int z=(*mb.rbegin()).s;
        if(cmp(z,x)){
            sum+=occ[z]*z;
            ma.insert({occ[z],z});
            mb.insert({occ[x],x});
            mb.erase(prev(mb.end()));
        }
        else{
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
        }
    }
};
class Solution {
public:

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        mx=x;
        pp p;
        REP(i,k) p.add(nums[i]);
        vector<ll> ans;
        ans.pb(p.sum);
        REP(i,sz(nums)-k){
            p.add(nums[i+k]);
            p.del(nums[i]);
            ans.pb(p.sum);
        }
        return ans;
    }
};",1420550951
zaneyu2005,zaneyu2005,43,3610,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=2e5+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=998244353;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
int mx;
struct pp{
    multiset<pii> ma,mb;
    map<ll,ll> occ;
    ll sum=0;
    void de(int x){
        if(mb.find({occ[x],x})!=mb.end()){
            mb.erase({occ[x],x});
        }
        else if(ma.find({occ[x],x})!=ma.end()){
            sum-=occ[x]*x;
            ma.erase({occ[x],x});
        }
    }
    bool cmp(int a,int b){
        if(occ[a]>occ[b]){
            return true;
        }
        if(occ[a]<occ[b]){
            return false;
        }
        return (a>b);
    }
    void add(int x){
        de(x);
        occ[x]++;
        if(sz(ma)<mx){
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
            return;
        }
        int z=(*ma.begin()).s;
        if(cmp(x,z)){
            de(z);
            mb.insert({occ[z],z});
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
        }
        else{
            mb.insert({occ[x],x});
        }
    }
    void del(int x){
        de(x);
        occ[x]--;
        if(sz(ma)==mx){
            mb.insert({occ[x],x});
            return;
        }
        if(!sz(mb)){
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
            return;
        }
        int z=(*mb.rbegin()).s;
        if(cmp(z,x)){
            sum+=occ[z]*z;
            ma.insert({occ[z],z});
            mb.insert({occ[x],x});
            mb.erase(prev(mb.end()));
        }
        else{
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
        }
    }
};
class Solution {
public:

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        mx=x;
        pp p;
        REP(i,k) p.add(nums[i]);
        vector<int> ans;
        ans.pb(p.sum);
        REP(i,sz(nums)-k){
            p.add(nums[i+k]);
            p.del(nums[i]);
            ans.pb(p.sum);
        }
        return ans;
    }
};",1420551451
dirigibility,dirigibility,44,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        def dfs(node):
            if not node:
                return 0
            l = dfs(node.left)
            r = dfs(node.right)
            if l == r and l != -1:
                sizes.append(1+l+r)
                return 1+l+r
            return -1
        dfs(root)
        sizes.sort()
        return sizes[-k] if k <= len(sizes) else -1",1420521647
dirigibility,dirigibility,44,3588,python3,"mod = 10**9+7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def f(i,d,prev):
            if i == len(s):
                return int(d > 0)
            total = 0
            for cur in 'FWE':
                if cur == prev:
                    continue
                if cur == s[i]:
                    total += f(i+1,d,cur)
                elif (cur == 'F' and s[i] == 'E') or (cur == 'W' and s[i] == 'F') or (cur == 'E' and s[i] == 'W'):
                    total += f(i+1,d+1,cur)
                else:
                    total += f(i+1,d-1,cur)
            return total%mod
        try:    
            return f(0,0,'')
        finally:
            f.cache_clear()",1420527355
dirigibility,dirigibility,44,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        active = SortedList()
        freq = Counter()
        t = 0
        def update(n,df):
            nonlocal t
            if n in freq:
                i = active.bisect_left((freq[n],n))
                active.pop(i)
                if len(active)+1-i <= x:
                    t -= freq[n]*n
                    if len(active) >= x:
                        t += active[-x][0]*active[-x][1]
            freq[n] += df
            if not freq[n]:
                del freq[n]
                return
            active.add((freq[n],n))
            i = active.bisect_left((freq[n],n))
            if len(active)-i <= x:
                t += freq[n]*n
                if len(active) >= x+1:
                    t -= active[-x-1][0]*active[-x-1][1]
        for i,n in enumerate(nums):
            update(n,1)
            if i >= k-1:
                result.append(t)
                update(nums[i-k+1],-1)
        return result",1420564238
dirigibility,dirigibility,44,3610,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        active = SortedList()
        freq = Counter()
        t = 0
        def update(n,df):
            nonlocal t
            if n in freq:
                i = active.bisect_left((freq[n],n))
                active.pop(i)
                if len(active)+1-i <= x:
                    t -= freq[n]*n
                    if len(active) >= x:
                        t += active[-x][0]*active[-x][1]
            freq[n] += df
            if not freq[n]:
                del freq[n]
                return
            active.add((freq[n],n))
            i = active.bisect_left((freq[n],n))
            if len(active)-i <= x:
                t += freq[n]*n
                if len(active) >= x+1:
                    t -= active[-x-1][0]*active[-x-1][1]
        for i,n in enumerate(nums):
            update(n,1)
            if i >= k-1:
                result.append(t)
                update(nums[i-k+1],-1)
        return result",1420564633
OTTFF,OTTFF,45,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    pair<int, int> dfs(TreeNode* u) {
        if (!u) return {0, 1};
        auto lans = dfs(u->left);
        auto rans = dfs(u->right);
        if (lans.second && rans.second && lans.first == rans.first) {
            int sz = lans.first * 2 + 1;
            ans.push_back(sz);
            return {sz, 1};
        } else {
            return {0, 0};
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        ans.clear();
        dfs(root);
        sort(ans.rbegin(), ans.rend());
        if (ans.size() < k) return -1;
        return ans[k - 1];
    }
};",1420520627
OTTFF,OTTFF,45,3588,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

const int M = 1000;
const int MM = M * 2 + 1;
Mint dp[2][MM][3];

class Solution {
public:
int toit(char c) {
    if (c == 'F') return 0;
    if (c == 'E') return 1;
    return 2;
}
    int countWinningSequences(string s) {
        int n = s.length();
        
        for (int i = 0; i < MM; i++) {
            for (int j = 0; j < 3; j++) {
                dp[0][i][j] = 0;
            }
        }

        for (int i = 0; i < 3; i++) {
            if ((i + 1) % 3 == toit(s[0])) {
                dp[0][M + 1][i] = 1;
            } else if ((i + 2) % 3 == toit(s[0])) {
                dp[0][M - 1][i] = 1;
            } else {
                dp[0][M][i] = 1;
            }
        }

        // cout << ""here"" << endl;

        for (int ii = 1; ii < n; ii++) {
            for (int i = 0; i < MM; i++) {
                for (int j = 0; j < 3; j++) {
                    dp[ii & 1][i][j] = 0;
                }
            }

            for (int i = -ii; i <= ii; i++) {
                for (int j = 0; j < 3; j++) { // pre i, j
                    for (int k = 0; k < 3; k++) {
                        if (j == k) continue;

                        if ((k + 1) % 3 == toit(s[ii])) {
                            dp[ii & 1][i + 1 + M][k] += dp[(ii & 1) ^ 1][i + M][j];
                        } else if ((k + 2) % 3 == toit(s[ii])) {
                            dp[ii & 1][i - 1 + M][k] += dp[(ii & 1) ^ 1][i + M][j];
                        } else {
                            dp[ii & 1][i + M][k] += dp[(ii & 1) ^ 1][i + M][j];
                        }
                    }
                    
                }
            }
        }

        Mint ans = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < 3; j++) {
                ans += dp[(n - 1) & 1][i + M][j];
            }
        }
        return ans.x;
    }
};",1420536970
OTTFF,OTTFF,45,3592,cpp,"typedef long long LL;
typedef pair<int, int> PII;

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        
        map<int, int> cnt;
        for (int i : a) cnt[i] = 0;

        set<PII> large, small;
        LL sum = 0;
        for (auto [v, c] : cnt) {
            large.insert({0, v});

            if ((int)large.size() > x) {
                auto p = *large.begin();
                large.erase(p);
                small.insert(p);
            }
        }

        auto show = [&]() {
            cout << ""large : "";
            for (auto [c, v] : large) cout << ""{"" << c << "","" << v << ""}"";
            cout << ""\n""; 
            cout << ""small : "";
            for (auto [c, v] : small) cout << ""{"" << c << "","" << v << ""}"";
            cout << ""\n"";
            cout << ""cnt : "";
            for (auto [c, v] : cnt) cout << ""{"" << c << "","" << v << ""}"";
            cout << ""\n""; 
            cout << ""sum = "" << sum << endl;
        };
        
        auto ins = [&](int v) {
            // cout << ""ins "" << v << endl;
            PII oldp = {cnt[v], v};
            if (auto it = large.find(oldp); it != large.end()) {
                large.erase(it);
                sum -= 1LL * cnt[v] * v;
                if (!small.empty()) {
                    auto it = --small.end();
                    large.insert(*it);
                    sum += 1LL * it->first * it->second;
                    small.erase(it);
                }
            } else {
                small.erase(oldp);
            }
            
            cnt[v]++;
            large.insert({cnt[v], v});
            sum += 1LL * cnt[v] * v;

            if ((int)large.size() > x) {
                auto p = *large.begin();
                sum -= 1LL * p.first * p.second;
                large.erase(p);
                small.insert(p);
            }
        };

        auto del = [&](int v) {
            PII oldp = {cnt[v], v};
            if (auto it = large.find(oldp); it != large.end()) {
                large.erase(it);
                sum -= 1LL * cnt[v] * v;
                if (!small.empty()) {
                    auto it = --small.end();
                    large.insert(*it);
                    sum += 1LL * it->first * it->second;
                    small.erase(it);
                }
            } else {
                small.erase(oldp);
            }
            cnt[v]--;
            large.insert({cnt[v], v});
            sum += 1LL * cnt[v] * v;

            if ((int)large.size() > x) {
                auto p = *large.begin();
                sum -= 1LL * p.first * p.second;
                large.erase(p);
                small.insert(p);
            }
        };

        // show();

        for (int i = 0; i < k - 1; i++) {
            ins(a[i]);
            // show();
        }

        vector<LL> ans;
        for (int i = k - 1; i < n; i++) {
            ins(a[i]);
            // show();

            ans.push_back(sum);

            del(a[i - k + 1]);
        }

        return ans;
    }
};",1420570516
OTTFF,OTTFF,45,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        vector<int> ans;

        map<int, int> cnt;
        for (int i = 0; i + k - 1 < n; i++) {
            cnt.clear();
            for (int j = 0; j < k; j++) {
                cnt[a[i + j]]++;
            }

            vector<pair<int, int>> b;
            for (auto [v, c] : cnt) {
                b.push_back({c, v});
            }
            sort(b.rbegin(), b.rend());

            int sz = b.size();
            if (x < sz) sz = x;
            int sum = 0;
            for (int i = 0; i < sz; i++) {
                sum += b[i].first * b[i].second;
            }
            ans.push_back(sum);
        }

        return ans;
    }
};",1420545607
sammochen,sammochen,46,3509,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

class Solution {
public:
    vector<int> depths;
    int dfs(TreeNode* root) {

        if (!root) {
            return -1;
        }

        if (!root->left && !root->right) {
            // good
            depths.push_back(1);
            return 1;
        }
       
        int left = dfs(root->left);
        int right = dfs(root->right);
        if (left == -1 || right == -1) return -1;
        if (left != right) return -1;

        // good

        depths.push_back(left * 2 + 1);
        return left  * 2 + 1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(depths.rbegin(), depths.rend());

        // for (auto d : depths) cout << d << ' ';
        // cout << endl;
        k--;
        if (k >= depths.size()) return -1;
        return depths[k];
    }
};
",1420522783
sammochen,sammochen,46,3588,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

ll dp[1005][2010][3];

class Solution {
public:
    ll n;
    string s;
    string t = ""FEW"";

    ll getInd(char c) {
        rep(j, 0, 3) {
            if (c == t[j]) return j;
        }
        return -1;
    }

    ll get(ll ind, ll diff, ll prev) {
        if (ind == n) {
            if (diff > 0) return 1;
            return 0;
        }

        ll& ans = dp[ind][diff + 1005][prev];
        if (ans != -1) return ans;

        ans = 0;
        rep(j, 0, 3) {
            // bob chooses j

            if (ind != 0 && prev == j) continue;

            ll aliceInd = getInd(s[ind]);
            ll result = aliceInd == j ? 0 : (j + 1) % 3 == aliceInd ? 1 : -1;

            ans += get(ind + 1, diff + result, j);
            ans %= mod;
        }

        return ans;
    }
    int countWinningSequences(string s) {  // !
        this->s = s;
        n = s.size();

        rep(i, 0, n) {
            rep(j, 0, 2005) {
                rep(k, 0, 3) {
                    dp[i][j][k] = -1;
                }
            }
        }

        return get(0, 0, 0);
    }
};
",1420533675
sammochen,sammochen,46,3592,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

class Solution {
public:
    ll Bsize;
    ll Bsum = 0;
    umap<ll, ll> M;
    set<PLL> A, B;  // freq, number

    void move(set<PLL>& from, set<PLL>& to, const PLL& x) {
        to.insert(x);
        from.erase(x);
    }

    void moveBA() {
        Bsum -= B.begin()->first * B.begin()->second;
        move(B, A, *B.begin());
    }
    void moveAB() {
        Bsum += A.rbegin()->first * A.rbegin()->second;
        move(A, B, *A.rbegin());
    }

    void remove(const PLL& x) {
        if (A.count(x)) A.erase(x);
        if (B.count(x)) {
            Bsum -= x.first * x.second;
            B.erase(x);
        }
        balance();
    }

    void add(const PLL& x) {
        A.insert(x);
        moveAB();
        moveBA();
        balance();
    }

    void balance() {
        while (B.size() > Bsize) {
            moveBA();
        }

        while (A.size() && B.size() < Bsize) {
            moveAB();
        }
    }

    void updateMapping(ll x, ll inc) {
        remove({M[x], x});

        M[x] += inc;

        add({M[x], x});

    }

    vector<ll> findXSum(vector<int>& arr, int k, int x) {  // !
        Bsize = x;
        ll n = arr.size();

        rep(i, 0, k) {
            updateMapping(arr[i], 1);
        }

        VLL ans = {Bsum};

        // we have our first answer

        rep(i, k, n) {
            updateMapping(arr[i - k], -1);
            updateMapping(arr[i], 1);
            ans.push_back(Bsum);
        }
        return ans;
    }
};
",1420557213
sammochen,sammochen,46,3610,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

class Solution {
public:
    ll Bsize;
    ll Bsum = 0;
    umap<ll, ll> M;
    set<PLL> A, B;  // freq, number

    void move(set<PLL>& from, set<PLL>& to, const PLL& x) {
        to.insert(x);
        from.erase(x);
    }

    void moveBA() {
        Bsum -= B.begin()->first * B.begin()->second;
        move(B, A, *B.begin());
    }
    void moveAB() {
        Bsum += A.rbegin()->first * A.rbegin()->second;
        move(A, B, *A.rbegin());
    }

    void remove(const PLL& x) {
        if (A.count(x)) A.erase(x);
        if (B.count(x)) {
            Bsum -= x.first * x.second;
            B.erase(x);
        }
        balance();
    }

    void add(const PLL& x) {
        A.insert(x);
        moveAB();
        moveBA();
        balance();
    }

    void balance() {
        while (B.size() > Bsize) {
            moveBA();
        }

        while (A.size() && B.size() < Bsize) {
            moveAB();
        }
    }

    void updateMapping(ll x, ll inc) {
        remove({M[x], x});

        M[x] += inc;

        add({M[x], x});

    }

    vector<int> findXSum(vector<int>& arr, int k, int x) {  // !
        Bsize = x;
        ll n = arr.size();

        rep(i, 0, k) {
            updateMapping(arr[i], 1);
        }

        vector<int> ans = {(int)Bsum};

        // we have our first answer

        rep(i, k, n) {
            updateMapping(arr[i - k], -1);
            updateMapping(arr[i], 1);
            ans.push_back(Bsum);
        }
        return ans;
    }
};
",1420558811
Sandeep P,Sandeep_P,47,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans=[]
        def dfs(node):
            if not node.left and not node.right:
                ans.append(1)
                return True,1,0
            if node.left and node.right:
                a,b,c=dfs(node.left)
                d,e,f=dfs(node.right)
                if a and d and c==f:
                    ans.append( b+e+1 )
                    return True,b+e+1,c+1
                else:
                    return False,0,0
            else:
                if node.left:
                    dfs(node.left)
                if node.right:
                    dfs(node.right)
                return False,0,0
            
        dfs(root)
        ans.sort()
        if len(ans)<k:
            return -1
        return ans[-k]
        

",1420544015
Sandeep P,Sandeep_P,47,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        opts=""FWE""
        n=len(s)
        @cache
        def dp(i,prev='',score=0):
            if i==n:
                return 1 if score<0 else 0
            x=s[i]
            ans=0
            for y in opts:
                if y==prev:
                    continue
                if x=='F' and y=='E':
                    cur_sc=1
                elif x=='W' and y=='F':
                    cur_sc=1
                elif x=='E' and y=='W':
                    cur_sc=1
                elif x==y:
                    cur_sc=0
                else:
                    cur_sc=-1
                ans+=dp(i+1,y,score+cur_sc)
            return ans % (10**9+7)
        return dp(0)",1420559424
Sandeep P,Sandeep_P,47,3592,python3,"from sortedcontainers import SortedList

class SL2():
    def __init__(self,x):
        self.a=SortedList()
        self.b=SortedList()
        self.sm=0
        self.x=x


    def add(self,c,x):
        self.b.add( (c,x) )
        self.sm+=c*x
        if len(self.b)>self.x:
            m=self.b[0]
            self.sm-=m[0]*m[1]
            self.b.remove(m)
            self.a.add(m)

    def discard(self,c,x):
        if (c,x)>=self.b[0]:
            self.sm-=c*x
            self.b.discard((c,x))
            if len(self.b)<self.x and self.a:
                m=self.a[-1]
                self.sm+=m[0]*m[1]
                self.a.remove(m)
                self.b.add(m)
        else:
            self.a.discard((c,x))


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        i=0
        c=Counter()
        n=len(nums)
        sl=SL2(x)
        ans=[]
        for j in range(n):
            cur=nums[j]
            if c[cur]>0:
                sl.discard(c[cur],cur)
            c[cur]+=1
            sl.add(c[cur],cur)

            if j-i+1>k:
                cur=nums[i]
                sl.discard(c[cur],cur)
                c[cur]-=1
                if c[cur]>0:
                    sl.add(c[cur],cur)
                i+=1
            if j-i+1==k:
                ans.append(sl.sm)
        return ans",1420531488
Sandeep P,Sandeep_P,47,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        i=0
        c=Counter()
        n=len(nums)
        ans=[]
        for j in range(n):
            c[nums[j]]+=1
            if j-i+1>k:
                c[nums[i]]-=1
                i+=1
            if j-i+1==k:
                take=x
                cur=0
                arr=list(c.most_common())
                for val,ct in sorted(arr,key=lambda x:x[::-1],reverse=True):
                    if take==0:
                        break
                    cur+=val*ct
                    take-=1
                ans.append(cur)
        return ans


",1420521166
Ethan,ethanrao,48,3509,cpp,"#include<bits/stdc++.h>
#define ll long long
#define all(x) x.rbegin(),x.rend()
#define pb push_back
class Solution {
public:
    pair<bool, int> dfs(TreeNode* node, vector<int>& ans) {
        if (!node) return {true, 0};  

        auto [l, lsize] = dfs(node->left, ans);
        auto [r, rsize] = dfs(node->right, ans);
        
        if (l && r && lsize == rsize) {
            ans.pb(lsize + rsize + 1);  
            return {true, lsize + rsize + 1};
        } else {
            return {false, 0};  
        }
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;  
        dfs(root, ans);
        int n = ans.size();
        if (n < k) return -1;

        sort(all(ans));  
        return ans[k - 1]; 
    }
};",1420528279
Ethan,ethanrao,48,3588,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    int f[1005][2005][3], a[1005];
    int countWinningSequences(string s) {
        int n = s.size();
        if(s[0] == 'F'){
            f[0][1][0] = 1;
            f[0][2][1] = 1;
            f[0][0][2] = 1;
        }
        else if(s[0] == 'W'){
            f[0][0][0] = 1;
            f[0][1][1] = 1;
            f[0][2][2] = 1;
        }
        else {
            f[0][2][0] = 1;
            f[0][0][1] = 1;
            f[0][1][2] = 1;
        }
        for(int i = 0; i < n; ++i){
            if(s[i] == 'F') a[i] = 0;
            else if(s[i] == 'W') a[i] = 1;
            else a[i] = 2;
        }
        for(int i = 1; i < n; ++i){
            for(int j = 0; j <= 2 * i; ++j){
                for(int k = 0; k <= 2; ++k){
                    for(int t = 0; t <= 2; ++t){
                        if(t == k) continue;
                        int tar = j;
                        if((t - a[i] + 3) % 3 == 1) tar += 2;
                        else if((t - a[i] + 3) % 3 == 2) tar += 0;
                        else tar += 1;
                        f[i][tar][t] = add(f[i][tar][t], f[i - 1][j][k]);
                    }
                }
            }
        }
        int ans = 0;
        for(int i = n + 1; i <= 2 * n; ++i)
            for(int j = 0; j <= 2; ++j)
                ans = add(ans, f[n - 1][i][j]);
        return ans;
    }
};",1420530295
Ethan,ethanrao,48,3592,cpp,"class Solution {
public:
    std::map <int, int> mp;
    struct node{
        int x, c;
        friend bool operator<(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x < b.x;
        }
        friend bool operator<=(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x <= b.x;
        }
    };
    int n, tot = 0, root = 0;
    int ch[400005][2], siz[400005], pri[400005];
    node val[400005];
    long long sum[200005];
    inline void up(int x){
      siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;
      sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + 1ll * val[x].x * val[x].c;
      return ;
    }
    inline int New(node x){
      val[++tot] = x;
      siz[tot] = 1;
      sum[tot] = 1ll * val[tot].x * val[tot].c;
      pri[tot] = rand() % 114114;
      return tot;
    }
    int merge(int x, int y){
      if(!x || !y) return x | y;
      if(pri[x] < pri[y]){
        ch[x][1] = merge(ch[x][1], y);
        up(x);
        return x;
      }
      else {
        ch[y][0] = merge(x, ch[y][0]);
        up(y);
        return y;
      }
    }
    void split(int now, node v, int &x, int &y){
      if(!now) x = y = 0;
      else {
        if(val[now] <= v){
          x = now;
          split(ch[x][1], v, ch[x][1], y);
          up(x);
        }
        else {
          y = now;
          split(ch[y][0], v, x, ch[y][0]);
          up(y);
        }
      }
      return ;
    }
    inline void insert(node v){
      int x, y;
      split(root, v, x, y);
      int nd = New(v);
      root = merge(merge(x, nd), y);
      return ;
    }
    inline void erase(node v){
      int x, y, z;
      split(root, v, x, y);
      node vv = v; vv.x -= 1;
      split(x, vv, x, z);
      z = merge(ch[z][0], ch[z][1]);
      root = merge(merge(x, z), y);
      return ;
    }
    long long ask(int k){
        long long ans = 0ll;
        int now = root;
        if(root == 0 || siz[root] <= k) return sum[root];
        while(true){
            if(k == 0) return ans;
            if(siz[ch[now][1]] < k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                k -= 1;
                ans += 1ll * val[now].x * val[now].c;
                now = ch[now][0];
            }
            else if(siz[ch[now][1]] == k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                return ans;
            }
            else now = ch[now][1];
        }
        return ans;
    }
    void add(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c += 1;
        insert(pre);
        mp[x] += 1;
        return ;
    }
    void remove(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c -= 1;
        insert(pre);
        mp[x] -= 1;
        return ;
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        srand((unsigned)time(0));
        n = nums.size();
        mp.clear();
        std::vector <long long> ans;
        for(int i = 0; i < k; ++i) add(nums[i]);
        ans.resize(n - k + 1);
        ans[0] = ask(x);
        for(int i = 1; i <= n - k; ++i){
            add(nums[i + k - 1]);
            remove(nums[i - 1]);
            ans[i] = ask(x);
        }
        return ans;
    }
};",1420558371
Ethan,ethanrao,48,3610,cpp,"class Solution {
public:
    std::map <int, int> mp;
    struct node{
        int x, c;
        friend bool operator<(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x < b.x;
        }
        friend bool operator<=(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x <= b.x;
        }
    };
    int n, tot = 0, root = 0;
    int ch[400005][2], siz[400005], pri[400005];
    node val[400005];
    long long sum[200005];
    inline void up(int x){
      siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;
      sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + 1ll * val[x].x * val[x].c;
      return ;
    }
    inline int New(node x){
      val[++tot] = x;
      siz[tot] = 1;
      sum[tot] = 1ll * val[tot].x * val[tot].c;
      pri[tot] = rand() % 114114;
      return tot;
    }
    int merge(int x, int y){
      if(!x || !y) return x | y;
      if(pri[x] < pri[y]){
        ch[x][1] = merge(ch[x][1], y);
        up(x);
        return x;
      }
      else {
        ch[y][0] = merge(x, ch[y][0]);
        up(y);
        return y;
      }
    }
    void split(int now, node v, int &x, int &y){
      if(!now) x = y = 0;
      else {
        if(val[now] <= v){
          x = now;
          split(ch[x][1], v, ch[x][1], y);
          up(x);
        }
        else {
          y = now;
          split(ch[y][0], v, x, ch[y][0]);
          up(y);
        }
      }
      return ;
    }
    inline void insert(node v){
      int x, y;
      split(root, v, x, y);
      int nd = New(v);
      root = merge(merge(x, nd), y);
      return ;
    }
    inline void erase(node v){
      int x, y, z;
      split(root, v, x, y);
      node vv = v; vv.x -= 1;
      split(x, vv, x, z);
      z = merge(ch[z][0], ch[z][1]);
      root = merge(merge(x, z), y);
      return ;
    }
    long long ask(int k){
        long long ans = 0ll;
        int now = root;
        if(root == 0 || siz[root] <= k) return sum[root];
        while(true){
            if(k == 0) return ans;
            if(siz[ch[now][1]] < k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                k -= 1;
                ans += 1ll * val[now].x * val[now].c;
                now = ch[now][0];
            }
            else if(siz[ch[now][1]] == k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                return ans;
            }
            else now = ch[now][1];
        }
        return ans;
    }
    void add(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c += 1;
        insert(pre);
        mp[x] += 1;
        return ;
    }
    void remove(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c -= 1;
        insert(pre);
        mp[x] -= 1;
        return ;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        srand((unsigned)time(0));
        n = nums.size();
        mp.clear();
        std::vector <int> ans;
        for(int i = 0; i < k; ++i) add(nums[i]);
        ans.resize(n - k + 1);
        ans[0] = ask(x);
        for(int i = 1; i <= n - k; ++i){
            add(nums[i + k - 1]);
            remove(nums[i - 1]);
            ans[i] = ask(x);
        }
        return ans;
    }
};",1420559673
Agnibha Chakraborty,zanj0,49,3509,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
	vector<int> ret;

	vector<int> Dfs(TreeNode* node) {
		vector<int> left, right;
		if (node->left) left = Dfs(node->left);
		if (node->right) right = Dfs(node->right);
    // cout << node->val << endl;
		if (!node->left && !node->right) {
			// Leaf
            // cout << ""Inser 1"" << endl;
			ret.pb(1);
			return {1, 1, 1}; // {subtree_size, height, good/bad}
		}

		if (left.empty() || right.empty()) {
			return {}; // Bad
		}

		if (left[1] == right[1]) {
			vector<int> now  = {1 + left[0] + right[0], 1 + left[1], 1};
			ret.pb(now[0]);
			return now;
		}
		return {};
	}
	int kthLargestPerfectSubtree(TreeNode* root, int k) {
		ret.clear();
		Dfs(root);
        // for(auto& it : ret){
        //     cout << it << "" "";
        // }
        // cout << endl;
		k--;
		sort(ret.rbegin(), ret.rend());
		return k < ret.size() ? ret[k] : -1;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1420554151
Agnibha Chakraborty,zanj0,49,3588,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

const lli BASE = 1e3 + 5;
const lli MAX_BASE = 3 * BASE + 50;
lli Add(lli a, lli b) {
	return ((a % MOD) + (b % MOD)) % MOD;
}
class Solution {
public:
	map<char, lli> val;
	map<char, char> kills;
	lli Dfs(lli idx, lli last_char, lli balance, string& s, vector<vector<vector<lli>>>& dp) {
		if (idx >= s.size()) {
			return balance > BASE;
		}
		if (dp[idx][last_char][balance] != -1) return dp[idx][last_char][balance];
		lli ret = 0;
		for (auto it : {'F', 'W', 'E'}) {
			lli now = val[it];
			if (now == last_char) continue;
			char kill = kills[s[idx]];
			if (it == kill) {
				ret = Add(ret, Dfs(idx + 1, now, balance - 1, s, dp));
			} else if (it == s[idx]) {
				ret = Add(ret, Dfs(idx + 1, now, balance, s, dp));
			} else {
				ret = Add(ret, Dfs(idx + 1, now, balance + 1, s, dp));
			}
		}
		return dp[idx][last_char][balance] = ret;
	}
	int countWinningSequences(string s) {
		int n = s.size();

		val['F'] = 1;
		val['E'] = 2;
		val['W'] = 3;

		kills['F'] = 'E';
		kills['W'] = 'F';
		kills['E'] = 'W';

		vector<vector<vector<lli>>> dp(s.size(), vector<vector<lli>>(5, vector<lli>(MAX_BASE, -1)));
		return Dfs(0, 0, BASE, s, dp);

	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1420565947
Agnibha Chakraborty,zanj0,49,3592,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;
bool IsFirstBetter(pair<lli, lli>& a, pair<lli, lli> &b) {
	return a.ss == b.ss ? a.ff > b.ff : a.ss > b.ss;
}
struct Comparator {
	bool operator() (pair<lli, lli> a, pair<lli, lli> b) const {
		return IsFirstBetter(a, b);
	}
};
void Out(set<pair<lli, lli>, Comparator>& v) {
	for (auto& it : v) {
		cout << it.ff << "" "" << it.ss << endl;
	}
	cout << endl;
}
class Solution {
public:
	set<pair<lli, lli>, Comparator> good, bad;

	vector<long long> findXSum(vector<int>& nums, int k, int x) {
		vector<lli> ret;
		map<lli, lli> cnt;
		lli sum = 0;
		for (lli i = 0; i < nums.size(); i++) {
			if (i - k >= 0) {
				pair<lli, lli> curr = {nums[i - k], cnt[nums[i - k]]};
				if (good.count(curr)) {
					good.erase(curr);
					sum -= curr.ff * curr.ss;
				}
				if (bad.count(curr)) {bad.erase(curr);}

				cnt[nums[i - k]]--;
				curr = {nums[i - k], cnt[nums[i - k]]};

				good.insert(curr);
				sum += curr.ff * curr.ss;

				while (!bad.empty() && !good.empty()) {
					pair<lli, lli> best_bad = *bad.begin();
					pair<lli, lli> worst_good = *good.rbegin();
					if (IsFirstBetter(best_bad, worst_good)) {
						good.erase(worst_good);
						sum -= worst_good.ff * worst_good.ss;
						good.insert(best_bad);
						sum += best_bad.ff * best_bad.ss;

						bad.erase(best_bad);
						bad.insert(worst_good);
					} else break;
				}


			}
			pair<lli, lli> curr = {nums[i], cnt[nums[i]]};
			if (good.count(curr)) {
				good.erase(curr);
				sum -= curr.ff * curr.ss;
			}
			if (bad.count(curr)) {bad.erase(curr);}

			cnt[nums[i]]++;
			curr = {nums[i], cnt[nums[i]]};

			good.insert(curr);
			sum += curr.ff * curr.ss;

			while ((lli)good.size() > x) {
				curr = *good.rbegin();
				sum -= curr.ff * curr.ss;
				bad.insert(curr);
				good.erase(curr);
			}

			while (!bad.empty() && !good.empty()) {
				pair<lli, lli> best_bad = *bad.begin();
				pair<lli, lli> worst_good = *good.rbegin();
				if (IsFirstBetter(best_bad, worst_good)) {
					good.erase(worst_good);
					sum -= worst_good.ff * worst_good.ss;
					good.insert(best_bad);
					sum += best_bad.ff * best_bad.ss;

					bad.erase(best_bad);
					bad.insert(worst_good);
				} else break;
			}


			while (!bad.empty() && good.size() < x) {
				pair<lli, lli> best_bad = *bad.begin();

				good.insert(best_bad);
				sum += best_bad.ff * best_bad.ss;

				bad.erase(best_bad);
			}
			// cout << i  << "" : "" << endl;
			// cout << ""Good"" << endl;
			// Out(good);
			// cout << ""Bad"" << endl;
			// Out(bad);

			if (i - k + 1 >= 0) {
				ret.pb(sum);
			}
		}
		return ret;
	}
};

/*
[1,1,2,2,3,4,2,3], k = 6, x = 2
*/
#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	Solution s;
	// vector<int> x = {1, 1, 2, 2, 3, 4, 2, 3};
	// vector<int> ret = s.findXSum(x, 6, 2);
	// for (auto& it  : ret) {
	// 	cout << it << "" "";
	// }
	// cout << endl;
	cout << ""Compiled!"" << endl;
}
#endif",1420541498
Agnibha Chakraborty,zanj0,49,3610,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;
bool IsFirstBetter(pair<int, int>& a, pair<int, int> &b) {
	return a.ss == b.ss ? a.ff > b.ff : a.ss > b.ss;
}
struct Comparator {
	bool operator() (pair<int, int> a, pair<int, int> b) const {
		return IsFirstBetter(a, b);
	}
};
void Out(set<pair<int, int>, Comparator>& v) {
	for (auto& it : v) {
		cout << it.ff << "" "" << it.ss << endl;
	}
	cout << endl;
}
class Solution {
public:
	set<pair<int, int>, Comparator> good, bad;

	vector<int> findXSum(vector<int>& nums, int k, int x) {
		vector<int> ret;
		map<int, int> cnt;
		int sum = 0;
		for (int i = 0; i < nums.size(); i++) {
			if (i - k >= 0) {
				pair<int, int> curr = {nums[i - k], cnt[nums[i - k]]};
				if (good.count(curr)) {
					good.erase(curr);
					sum -= curr.ff * curr.ss;
				}
				if (bad.count(curr)) {bad.erase(curr);}

				cnt[nums[i - k]]--;
				curr = {nums[i - k], cnt[nums[i - k]]};

				good.insert(curr);
				sum += curr.ff * curr.ss;

				while (!bad.empty() && !good.empty()) {
					pair<int, int> best_bad = *bad.begin();
					pair<int, int> worst_good = *good.rbegin();
					if (IsFirstBetter(best_bad, worst_good)) {
						good.erase(worst_good);
						sum -= worst_good.ff * worst_good.ss;
						good.insert(best_bad);
						sum += best_bad.ff * best_bad.ss;

						bad.erase(best_bad);
						bad.insert(worst_good);
					} else break;
				}


			}
			pair<int, int> curr = {nums[i], cnt[nums[i]]};
			if (good.count(curr)) {
				good.erase(curr);
				sum -= curr.ff * curr.ss;
			}
			if (bad.count(curr)) {bad.erase(curr);}

			cnt[nums[i]]++;
			curr = {nums[i], cnt[nums[i]]};

			good.insert(curr);
			sum += curr.ff * curr.ss;

			while ((int)good.size() > x) {
				curr = *good.rbegin();
				sum -= curr.ff * curr.ss;
				bad.insert(curr);
				good.erase(curr);
			}

			while (!bad.empty() && !good.empty()) {
				pair<int, int> best_bad = *bad.begin();
				pair<int, int> worst_good = *good.rbegin();
				if (IsFirstBetter(best_bad, worst_good)) {
					good.erase(worst_good);
					sum -= worst_good.ff * worst_good.ss;
					good.insert(best_bad);
					sum += best_bad.ff * best_bad.ss;

					bad.erase(best_bad);
					bad.insert(worst_good);
				} else break;
			}


			while (!bad.empty() && good.size() < x) {
				pair<int, int> best_bad = *bad.begin();

				good.insert(best_bad);
				sum += best_bad.ff * best_bad.ss;

				bad.erase(best_bad);
			}
			// cout << i  << "" : "" << endl;
			// cout << ""Good"" << endl;
			// Out(good);
			// cout << ""Bad"" << endl;
			// Out(bad);

			if (i - k + 1 >= 0) {
				ret.pb(sum);
			}
		}
		return ret;
	}
};

/*
[1,1,2,2,3,4,2,3], k = 6, x = 2
*/
#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	Solution s;
	vector<int> x = {1, 1, 2, 2, 3, 4, 2, 3};
	vector<int> ret = s.findXSum(x, 6, 2);
	for (auto& it  : ret) {
		cout << it << "" "";
	}
	cout << endl;
	cout << ""Compiled!"" << endl;
}
#endif",1420540466
lozy219,lozy219,50,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> cnt;
    int dfs(TreeNode* root) {
        if (root==nullptr) {
            return 0;
        }
        int l=dfs(root->left);
        int r=dfs(root->right);
        int res=-1;
        if (l==r) {
            res=l+r+1;
            cnt.push_back(res);
        }
        return res;
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(cnt.begin(), cnt.end());
        if (k>cnt.size()) return -1;
        return cnt[cnt.size()-k];
    }
};",1420525048
lozy219,lozy219,50,3588,cpp,"class Solution {
public:
    // W>F>E>W
    // 0>1>2>0
    const int MOD=1000000007;
    int countWinningSequences(string s) {
        vector<int> x;
        for (char c: s) {
            if (c=='W') {
                x.push_back(0);
            } else if (c=='F') {
                x.push_back(1);
            } else {
                x.push_back(2);
            }
        }
        // dp[1500]=0
        // dp[>1501]: ok
        int start=s.size();
        vector<int> dp0(2*start+5, 0);
        vector<int> dp1(2*start+5, 0);
        vector<int> dp2(2*start+5, 0);
        for (int i=0; i<x.size(); ++i) {
            vector<int> xdp0(2*start+5, 0);
            vector<int> xdp1(2*start+5, 0);
            vector<int> xdp2(2*start+5, 0);
            if (i==0) {
                if (x[i]==0) {
                    xdp2[start+1]=1;
                    xdp0[start]=1;
                    xdp1[start-1]=1;
                } else if (x[i]==1) {
                    xdp0[start+1]=1;
                    xdp1[start]=1;
                    xdp2[start-1]=1;
                } else {
                    xdp1[start+1]=1;
                    xdp2[start]=1;
                    xdp0[start-1]=1;
                }
            } else {
                if (x[i]==0) {
                    for (int j=0; j<=2*start; ++j) {
                        xdp0[j]=(dp1[j]+dp2[j])%MOD;
                        xdp2[j+1]=(dp1[j]+dp0[j])%MOD;
                        if (j-1>=0) {
                            xdp1[j-1]=(dp0[j]+dp2[j])%MOD;
                        }
                    }
                } else if (x[i]==1) {
                    for (int j=0; j<=2*start; ++j) {
                        xdp1[j]=(dp0[j]+dp2[j])%MOD;
                        xdp0[j+1]=(dp1[j]+dp2[j])%MOD;
                        if (j-1>=0) {
                            xdp2[j-1]=(dp0[j]+dp1[j])%MOD;
                        }
                    }
                } else {
                    for (int j=0; j<=2*start; ++j) {
                        xdp2[j]=(dp0[j]+dp1[j])%MOD;
                        xdp1[j+1]=(dp0[j]+dp2[j])%MOD;
                        if (j-1>=0) {
                            xdp0[j-1]=(dp1[j]+dp2[j])%MOD;
                        }
                    }
                }
            }
            dp0=xdp0;
            dp1=xdp1;
            dp2=xdp2;
        }
        int res=0;
        for (int i=start+1; i<dp0.size(); ++i) {
            res=(res+dp0[i])%MOD;
            res=(res+dp1[i])%MOD;
            res=(res+dp2[i])%MOD;
        }
        return res;
    }
};",1420544666
lozy219,lozy219,50,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> res;
        set<pair<long long, long long>> pqin;
        set<pair<long long, long long>> pqout;
        map<long long, long long> f;
        long long sum=0;
        for (int i=0; i<k-1; ++i) {
            f[nums[i]]++;
        }
        for (auto x: f) {
            pqout.insert({x.second, x.first});
        }
        for (int i=k-1; i<nums.size(); ++i) {
            if (i>=k) {
                long long z=nums[i-k];
                if (pqin.find({f[z], z})!=pqin.end()) {
                    pqin.erase({f[z], z});
                    sum-=f[z]*z;
                } else {
                    pqout.erase({f[z], z});
                }
                f[z]--;
                if (f[z]>0) {
                    pqout.insert({f[z], z});
                }
                while (pqin.size()<x&&!pqout.empty()) {
                    auto v=*prev(pqout.end());
                    pqin.insert({v.first, v.second});
                    sum+=v.first*v.second;
                    pqout.erase({v.first, v.second});
                }
            }

            long long z=nums[i];
            if (f[z]!=0) {
                if (pqin.find({f[z], z})!=pqin.end()) {
                    pqin.erase({f[z], z});
                    sum-=f[z]*z;
                } else {
                    pqout.erase({f[z], z});
                }
            }
            f[z]++;
            pqout.insert({f[z], z});
            if (!pqin.empty()) {
                auto v=*pqin.begin();
                sum-=v.first*v.second;
                pqout.insert({v.first, v.second});
                pqin.erase({v.first, v.second});
            }
            while (pqin.size()<x&&!pqout.empty()) {
                auto v=*prev(pqout.end());
                pqin.insert({v.first, v.second});
                sum+=v.first*v.second;
                pqout.erase({v.first, v.second});
            }
            res.push_back(sum);
        }
        return res;
    }
};",1420575581
lozy219,lozy219,50,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        int n=nums.size();
        for (int i=0; i+k<=n; ++i) {
            map<int, int> cnt;
            for (int j=0; j<k; ++j) {
                cnt[nums[i+j]]++;
            }
            vector<pair<int, int>> v;
            for (auto x: cnt) {
                v.push_back({x.second, x.first});
            }
            sort(v.begin(), v.end());
            for (int i=0; i<v.size(); ++i) {
            }
            int cur=0;
            for (int z=0; z<x; ++z) {
                int idx=v.size()-1-z;
                if (idx<0) break;
                cur+=v[idx].first*v[idx].second;
            }
            res.push_back(cur);
        }
        return res;
    }
};",1420521589
Ian Wong,ianwong1999,51,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map<TreeNode*, int> perf;
    
    void dfs(TreeNode* v) {
        if (!v) return;
        
        if (!v->left && !v->right) {
            perf[v] = 1;
            return;
        }
        
        dfs(v->left);
        dfs(v->right);
        
        if (perf.count(v->left) && perf.count(v->right) && perf[v->left] == perf[v->right]) {
            perf[v] = perf[v->left] * 2 + 1;
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        perf.clear();
        
        dfs(root);
        
        vector<int> v;
        
        for (auto [k, c] : perf) v.push_back(c);
        
        sort(v.rbegin(), v.rend());
        
        if (v.size() < k) return -1;
        return v[k - 1];
    }
};",1420523357
Ian Wong,ianwong1999,51,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int dp[1001][2010][3];
    
    int to_id(char ch) {
        if (ch == 'F') return 0;
        if (ch == 'E') return 1;
        return 2;
    }
    int countWinningSequences(string s) {
        int n = s.size();
        int offset = n;
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= offset * 2 + 5; j++) {
                memset(dp[i][j], 0, sizeof(dp[i][j]));
            }
        }
        
        dp[0][offset][to_id(s[0])] = 1;
        dp[0][offset - 1][(to_id(s[0]) + 1) % 3] = 1;
        dp[0][offset + 1][(to_id(s[0]) + 2) % 3] = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= offset * 2; j++) {
                for (int k = 0; k < 3; k++) {
                    int win = 0;
                    
                    if (k == (to_id(s[i]) + 1) % 3) win = -1;
                    else if (k == (to_id(s[i]) + 2) % 3) win = 1;
                    
                    for (int prev = 0; prev < 3; prev++) {
                        if (prev == k) continue;
                        
                        if (dp[i - 1][j][prev] == 0) continue;
                        
                        assert(j + win >= 0 && j + win <= offset * 2);
                        
                        dp[i][j + win][k] = (dp[i][j + win][k] + dp[i - 1][j][prev]) % MOD;
                    }
                }
            }
        }
        
        int res = 0;
        
        for (int i = 1; i <= n; i++) for (int j = 0; j < 3; j++) {
            res = (res + dp[n - 1][i + offset][j]) % MOD;
        }
        
        return res;
    }
};",1420539911
Ian Wong,ianwong1999,51,3592,cpp,"class Solution {
public:
    // https://cp-algorithms.com/data_structures/treap.html
    struct item {
        pair<int, int> key;
        int prior;
        long long sum;
        int cnt;
        item *l, *r;
        item () { }
        item (pair<int, int> key) : key(key), prior(rand()), sum(0ll), cnt(1), l(NULL), r(NULL) { }
    };
    
    typedef item* pitem;
    
    long long sum (pitem it) {
        return it ? it->sum : 0ll;
    }
    
    int cnt (pitem it) {
        return it ? it->cnt : 0;
    }
    
    void upd_sum (pitem it) {
        if (it) {
            it->sum = sum(it->l) + sum(it->r) + 1ll * it->key.first * it->key.second;
            it->cnt = cnt(it->l) + cnt(it->r) + 1;
        }
    }
    
    void split (pitem t, pair<int, int> key, pitem & l, pitem & r) {
        if (!t)
            l = r = NULL;
        else if (t->key <= key)
            split (t->r, key, t->r, r),  l = t;
        else
            split (t->l, key, l, t->l),  r = t;
        
        upd_sum(t);
    }
    
    void merge (pitem & t, pitem l, pitem r) {
        if (!l || !r)
            t = l ? l : r;
        else if (l->prior > r->prior)
            merge (l->r, l->r, r),  t = l;
        else
            merge (r->l, l, r->l),  t = r;
        
        upd_sum(t);
    }

    
    void insert (pitem & t, pitem it) {
        if (!t)
            t = it;
        else if (it->prior > t->prior)
            split (t, it->key, it->l, it->r),  t = it;
        else
            insert (t->key <= it->key ? t->r : t->l, it);
        
        upd_sum(t);
    }

    void erase (pitem & t, pair<int, int> key) {
        if (t->key == key) {
            pitem th = t;
            merge (t, t->l, t->r);
            delete th;
        }
        else
            erase (key < t->key ? t->l : t->r, key);
        
        upd_sum(t);
    }
    
    long long query(pitem & t, int x) {
        if (cnt(t) <= x) {
            return sum(t);
        }
        
        if (cnt(t->r) >= x) {
            return query(t->r, x);
        }
        
        long long res = sum(t->r) + 1ll * t->key.first * t->key.second;
        
        if (x - cnt(t->r) - 1 > 0)
            res += query(t->l, x - cnt(t->r) - 1);
        return res;
    }
    
    void output (pitem t) {
        if (!t)  return;
        output (t->l);
        printf (""(%d, %d) "", t->key.first, t->key.second);
        output (t->r);
    }
    
    void clear (pitem t) {
        if (!t)  return;
        clear (t->l);
        clear (t->r);
        
        delete t;
    }
    
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        map<int, int> cnt;
        vector<long long> res;

        for (int i = 0; i < n; i++) cnt[nums[i]] = 0;
        for (int i = 0; i + 1 < k; i++) {
            cnt[nums[i]]++;
        }
        
        pitem root = nullptr;
        
        for (auto p : cnt) {
            insert(root, new item(make_pair(p.second, p.first)));
        }
        
        auto update_cnt = [&](int id, int val) {
            auto p = make_pair(cnt[nums[id]], nums[id]);
           
            erase(root, p);

            cnt[nums[id]] += val;
            
            insert(root, new item(make_pair(cnt[nums[id]], nums[id])));
        };
        
        for (int i = k - 1; i < n; i++) {
            if (i >= k) {
                int id = i - k;
                update_cnt(id, -1);
            }
            
            update_cnt(i, 1);
            res.push_back(query(root, x));
        }
        
        clear(root);
        return res;
    }
};",1420575617
Ian Wong,ianwong1999,51,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        map<int, int> cnt;
        vector<pair<int, int>> vs;
        vector<int> res;
        
        for (int i = 0; i + k - 1 < n; i++) {
            cnt.clear();
            vs.clear();
            for (int j = 0; j < k; j++) {
                cnt[nums[i + j]]++;
            }
            
            for (auto [k, v] : cnt) vs.emplace_back(v, k);
            
            sort(vs.begin(), vs.end());
            
            int sum = 0;
            
            for (int j = 0; j < min(x, (int)vs.size()); j++) {
                auto p = vs[(int)vs.size() - 1 - j];
                
                sum += p.first * p.second;
                
            }
            
            res.push_back(sum);
        }
        
        return res;
    }
};",1420520289
Maruzensky,Maruzensky,52,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from functools import lru_cache

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        answer = []
        
        @lru_cache(None)
        def is_perfect(node):
            if node.left is None and node.right is None:
                answer.append(1)
                return 1
            if node.left is None and not node.right is None:
                is_perfect(node.right)
                return -1
            if not node.left is None and node.right is None:
                is_perfect(node.left)
                return -1
        
            left = is_perfect(node.left)
            right = is_perfect(node.right)
            print(left, right)
        
            if left > 0 and right > 0 and left == right:
                answer.append(2 * left + 1)
                return 2 * left + 1
            else:
                return -1
            
        is_perfect(root)
        answer.sort(reverse=True)
        
        if len(answer) < k:
            return -1
        
        return answer[k - 1]",1420526110
Maruzensky,Maruzensky,52,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        # FEW
        to_int = {'F': 0, 'E': 1, 'W': 2}
        
        s = [to_int[c] for c in s]
        
        mod = 10**9 + 7
        
        dp = {0: [1, 1, 1]}
        
        for x in s:
            temp = {}
            for d, freq in dp.items():
                if x == 0:
                    # y plays 0
                    if d not in temp:
                        temp[d] = [freq[1] + freq[2], 0, 0]
                    else:
                        temp[d][0] += freq[1] + freq[2]
                    # y plays 1
                    if d - 1 not in temp:
                        temp[d - 1] = [0, freq[0] + freq[2], 0]
                    else:
                        temp[d - 1][1] += freq[0] + freq[2]
                    # y plays 2
                    if d + 1 not in temp:
                        temp[d + 1] = [0, 0, freq[0] + freq[1]]
                    else:
                        temp[d + 1][2] += freq[0] + freq[1]
                                
                elif x == 1:
                    # y plays 0
                    if d + 1 not in temp:
                        temp[d + 1] = [freq[1] + freq[2], 0, 0]
                    else:
                        temp[d + 1][0] += freq[1] + freq[2]
                    # y plays 1
                    if d not in temp:
                        temp[d] = [0, freq[0] + freq[2], 0]
                    else:
                        temp[d][1] += freq[0] + freq[2]
                    # y plays 2
                    if d - 1 not in temp:
                        temp[d - 1] = [0, 0, freq[0] + freq[1]]
                    else:
                        temp[d - 1][2] += freq[0] + freq[1]
                
                else:
                    # y plays 0
                    if d - 1 not in temp:
                        temp[d - 1] = [freq[1] + freq[2], 0, 0]
                    else:
                        temp[d - 1][0] += freq[1] + freq[2]
                    # y plays 1
                    if d + 1 not in temp:
                        temp[d + 1] = [0, freq[0] + freq[2], 0]
                    else:
                        temp[d + 1][1] += freq[0] + freq[2]
                    # y plays 2
                    if d not in temp:
                        temp[d] = [0, 0, freq[0] + freq[1]]
                    else:
                        temp[d][2] += freq[0] + freq[1]
                        
            dp = {}
            for key, val in temp.items():
                dp[key] = [v % mod for v in val]
                        
        answer = sum(sum(val) for score, val in dp.items() if score > 0) % mod
        if answer % 2 == 0:
            return answer // 2
        else:
            return (answer + mod) // 2
                ",1420545193
Maruzensky,Maruzensky,52,3592,python3,"from sortedcontainers import SortedList
from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ctr = Counter(nums[:k])
        
        sl = SortedList([(v, y) for y, v in ctr.items()])
        
        psum = 0
        for v, y in sl[-x:]:
            psum += v * y
            
        answer = [psum]
            
        for a, b in zip(nums, nums[k:]):
            # print(a, b, sl)
            f_a = ctr[a]
            ctr[a] -= 1
            idx_a = sl.index((f_a, a))
            
            if idx_a >= len(sl) - x:
                psum -= f_a * a
                sl.remove((f_a, a))
                if len(sl) >= x:
                    f_y, y = sl[-x]
                    psum += f_y * y
                    
            else:
                sl.remove((f_a, a))
                
            if f_a > 1:
                sl.add((f_a - 1, a))
                idx_a = sl.index((f_a - 1, a))

                if idx_a >= len(sl) - x:
                    psum += (f_a - 1) * a
                    if len(sl) > x:
                        f_y, y = sl[-x - 1]
                        psum -= f_y * y
                    
            f_b = ctr[b]
            ctr[b] += 1
            
            if f_b > 0:
                idx_b = sl.index((f_b, b))

                if idx_b >= len(sl) - x:
                    psum -= f_b * b
                    sl.remove((f_b, b))
                    if len(sl) >= x:
                        f_y, y = sl[-x]
                        psum += f_y * y

                else:
                    sl.remove((f_b, b))
                
            sl.add((f_b + 1, b))
            idx_b = sl.index((f_b + 1, b))
            
            if idx_b >= len(sl) - x:
                psum += (f_b + 1) * b
                if len(sl) > x:
                    f_y, y = sl[-x - 1]
                    psum -= f_y * y
                    
            answer.append(psum)
        
        return answer",1420569402
Maruzensky,Maruzensky,52,3610,python3,"from sortedcontainers import SortedList
from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ctr = Counter(nums[:k])
        
        sl = SortedList([(v, y) for y, v in ctr.items()])
        
        psum = 0
        for v, y in sl[-x:]:
            psum += v * y
            
        answer = [psum]
            
        for a, b in zip(nums, nums[k:]):
            # print(a, b, sl)
            f_a = ctr[a]
            ctr[a] -= 1
            idx_a = sl.index((f_a, a))
            
            if idx_a >= len(sl) - x:
                psum -= f_a * a
                sl.remove((f_a, a))
                if len(sl) >= x:
                    f_y, y = sl[-x]
                    psum += f_y * y
                    
            else:
                sl.remove((f_a, a))
                
            if f_a > 1:
                sl.add((f_a - 1, a))
                idx_a = sl.index((f_a - 1, a))

                if idx_a >= len(sl) - x:
                    psum += (f_a - 1) * a
                    if len(sl) > x:
                        f_y, y = sl[-x - 1]
                        psum -= f_y * y
                    
            f_b = ctr[b]
            ctr[b] += 1
            
            if f_b > 0:
                idx_b = sl.index((f_b, b))

                if idx_b >= len(sl) - x:
                    psum -= f_b * b
                    sl.remove((f_b, b))
                    if len(sl) >= x:
                        f_y, y = sl[-x]
                        psum += f_y * y

                else:
                    sl.remove((f_b, b))
                
            sl.add((f_b + 1, b))
            idx_b = sl.index((f_b + 1, b))
            
            if idx_b >= len(sl) - x:
                psum += (f_b + 1) * b
                if len(sl) > x:
                    f_y, y = sl[-x - 1]
                    psum -= f_y * y
                    
            answer.append(psum)
        
        return answer",1420569741
Wei Liu,nevergiveup,53,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private List<Integer> sizeList = new ArrayList<>();

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        dfs(root);
        Collections.sort(sizeList, Collections.reverseOrder());
        if (k <= sizeList.size()) {
            return sizeList.get(k - 1);
        } else {
            return - 1;
        }
    }

    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            int leftSize = dfs(root.left) , rightSize = dfs(root.right);
            if (leftSize == rightSize) {
                sizeList.add(leftSize * 2 + 1);
                return leftSize * 2 + 1;
            } else {
                return - 1;
            }
        }
    }

}",1420525159
Wei Liu,nevergiveup,53,3588,java,"class Solution {

    
    private static long[][][] dp = new long[1010][2010][3];
    private static final int OFFSET = 1000;
    private static final long MOD = 1000_000_007L;

    public int countWinningSequences(String s) {
        int len = s.length();
        for (int i = 0;i < len;i ++) {
            for (int j = 0;j <= len + OFFSET;j ++) {
                for (int k = 0;k < 3;k ++) {
                    dp[i][j][k] = - 1;
                }
            }
        }
        return (int) dfs(s, 0, -1, 0);
    }

    // FWE
    private int getPoint(char ch, int bobChoose) {
        if (ch == 'F') {
            if (bobChoose == 1) {
                return 1;
            } else if (bobChoose == 0) {
                return 0;
            } else {
                return - 1;
            }
        }
        if (ch == 'W') {
            if (bobChoose == 2) {
                return 1;
            } else if (bobChoose == 1) {
                return 0;
            } else {
                return - 1;
            }
        }
        if (ch == 'E') {
            if (bobChoose == 0) {
                return 1;
            } else if (bobChoose == 2) {
                return 0;
            } else {
                return - 1;
            }
        }
        return - 1;
    }

    // diff is bob - alice
    private long dfs(String s, int cur, int last, int diff) {
        if (cur == s.length()) {
            if (diff > 0) {
                return 1;
            } else {
                return 0;
            }
        }
        if (last >= 0 && dp[cur][diff + OFFSET][last] >= 0) {
            return dp[cur][diff + OFFSET][last];
        }
        if (last < 0) {
            long ans = 0;
            for (int i = 0;i < 3;i ++) {
                ans = (ans + dfs(s, cur + 1, i, diff + getPoint(s.charAt(cur), i))) % MOD;
            }
            return ans;
        } else {
            long ans = 0;
            for (int i = 0;i < 3;i ++) {
                if (i != last) {
                    ans = (ans + dfs(s, cur + 1, i, diff + getPoint(s.charAt(cur), i))) % MOD;
                }
            }
            return dp[cur][diff + OFFSET][last] = ans;
        }
    }

}",1420542571
Wei Liu,nevergiveup,53,3592,java,"class Solution {

    private static class Element implements Comparable<Element> {
        public long val;
        public long count;
        public Element(long val, long count) {
            this.val = val;
            this.count = count;
        }
        @Override
        public int compareTo(Element e) {
            if (this.count != e.count) {
                if (this.count > e.count) {
                    return - 1;
                } else if (this.count < e.count) {
                    return 1;
                } else {
                    return 0;
                }
            } else {
                if (this.val > e.val) {
                    return - 1;
                } else if (this.val < e.val) {
                    return 1;
                } else {
                    return 0;
                }
            }
        }
        public long getSum() {
            return this.count * this.val;
        }
    }

    // top x
    private TreeSet<Element> leftSet = new TreeSet<>(), rightSet = new TreeSet<>();
    private long leftSum = 0;
    private Map<Integer , Integer> freqMap = new HashMap<>();

    private void add(int val, int x) {
        // remove first
        int prevFreq = freqMap.getOrDefault(val , 0);
        Element prevE = new Element(val, prevFreq);
        if (leftSet.remove(prevE)) {
            leftSum -= prevE.getSum();
        }
        rightSet.remove(prevE);
        // add new
        Element newE = new Element(val, prevFreq + 1);
        leftSet.add(newE);
        leftSum += newE.getSum();
        freqMap.put(val, prevFreq + 1);
        // balance
        balance(x);
    }

    private void remove(int val, int x) {
        // remove first
        int prevFreq = freqMap.getOrDefault(val , 0);
        Element prevE = new Element(val, prevFreq);
        if (leftSet.remove(prevE)) {
            leftSum -= prevE.getSum();
        }
        rightSet.remove(prevE);
        if (prevFreq - 1 > 0) {
            // add new
            Element newE = new Element(val, prevFreq - 1);
            leftSet.add(newE);
            leftSum += newE.getSum();
            freqMap.put(val, prevFreq - 1);
        } else {
            freqMap.remove(val);
        }
        // balance
        balance(x);
    }

    private void balance(int x) {
        // maintain set prop first
        if (!rightSet.isEmpty() && !leftSet.isEmpty()) {
            while (true) {
                Element last = leftSet.last(), first = rightSet.first();
                if (last.compareTo(first) > 0) {
                    leftSet.remove(last);
                    leftSum -= last.getSum();
                    rightSet.remove(first);
                    leftSet.add(first);
                    leftSum += first.getSum();
                    rightSet.add(last);
                } else {
                    break;
                }
            }
        }
        while (!rightSet.isEmpty() && leftSet.size() < x) {
            Element e = rightSet.first();
            rightSet.remove(e);
            leftSet.add(e);
            leftSum += e.getSum();
        }
        while (leftSet.size() > x) {
            Element e = leftSet.last();
            leftSet.remove(e);
            rightSet.add(e);
            leftSum -= e.getSum();
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] ans = new long[n - k + 1];
        for (int i = 0;i < n;i ++) {
            add(nums[i], x);
            if (i >= k - 1) {
                ans[i - (k - 1)] = leftSum;
                remove(nums[i - (k - 1)], x);
            }
        }
        return ans;
    }

}",1420570016
Wei Liu,nevergiveup,53,3610,java,"class Solution {


    private static class Element implements Comparable<Element> {
        public int val;
        public int freq;
        public Element(int val , int freq) {
            this.val = val;
            this.freq = freq;
        }
        @Override
        public int compareTo(Element e) {
            if (this.freq != e.freq) {
                return - (this.freq - e.freq);
            }
            return - (this.val - e.val);
        }
    }

    private int get(int[] nums , int l , int r , int x) {
        Map<Integer , Integer> freqMap = new HashMap<>();
        for (int i = l;i <= r;i ++) {
            int val = nums[i];
            freqMap.put(val , freqMap.getOrDefault(val , 0) + 1);
        }
        List<Element> list = new ArrayList<>();
        for (Map.Entry<Integer , Integer> entry : freqMap.entrySet()) {
            list.add(new Element(entry.getKey(), entry.getValue()));
        }
        Collections.sort(list);
        int ans = 0;
        for (int i = 0;i < list.size() && i < x;i ++) {
            ans += list.get(i).val * list.get(i).freq;
        }
        return ans;
    }

    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        for (int i = 0;i < ans.length;i ++) {
            ans[i] = get(nums, i, i + k - 1, x);
        }
        return ans;
    }

}",1420521472
Lucky Orb,megurine,56,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        def dfs(rt, d):
            a, b, c = inf, -inf, 1
            if rt.left is None and rt.right is None:
                a = b = d
                ans.append(1)
                return a, b, c
            if rt.left:
                x, y, z = dfs(rt.left, d + 1)
                a = min(a, x)
                b = max(b, y)
                c += z
            if rt.right:
                x, y, z = dfs(rt.right, d + 1)
                a = min(a, x)
                b = max(b, y)
                c += z
            if a == b and c == (1 << (a - d + 1)) - 1:
                ans.append(c)
            return a, b, c
        dfs(root, 0)
        ans.sort()
        ans.reverse()
        return -1 if len(ans) < k else ans[k - 1]
            ",1420529367
Lucky Orb,megurine,56,3588,python3,"p = int(1e9 + 7)
class Solution:
    def countWinningSequences(self, s: str) -> int:
        a = ['FWE'.find(x) for x in s]
        n = len(a)
        f = [[0] * 3 for _ in range(3)]
        for y in range(3):
            if y == a[0]:
                f[y][1] = 1
            elif (y - a[0]) % 3 == 1:
                f[y][2] = 1
            else:
                f[y][0] = 1
        for i, v in enumerate(a[1:], 1):
            h = [[0] * (i * 2 + 3) for _ in range(3)]
            for x in range(3):
                for y in range(3):
                    if x == y:
                        continue
                    if y == v:
                        d = 1
                    elif (y - v) % 3 == 1:
                        d = 2
                    else:
                        d = 0
                    for j in range(i * 2 + 1):
                        h[y][j + d] += f[x][j]
            for it in h:
                for i in range(len(it)):
                    it[i] %= p
            f = h
        return sum(sum(it[-n:]) for it in f) % p
                        ",1420549495
Lucky Orb,megurine,56,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, t: int) -> List[int]:
        cnt = Counter(nums[:k - 1])
        stl = SortedList([(cnt[x], x) for x in cnt] + [(-1, 0)] * k)
        cur = 0
        for c, x in stl[-t:]:
            cur += c * x
        
        def Del(c, x):
            if (c, x) not in stl:
                return
            nonlocal cur
            if (c, x) >= stl[-t]:
                cur -= c * x
                cc, xx = stl[-t - 1]
                cur += cc * xx
            stl.discard((c, x))
        def Add(c, x):
            if (c, x) <= stl[-t]:
                stl.add((c, x))
                return
            nonlocal cur
            cur += c * x
            cc, xx = stl[-t]
            cur -= cc * xx
            stl.add((c, x))
        
        ans = []
        for x, y in zip(nums[k - 1:], nums):
            Del(cnt[x], x)
            cnt[x] += 1
            Add(cnt[x], x)
            ans.append(cur)
            Del(cnt[y], y)
            cnt[y] -= 1
            Add(cnt[y], y)
        return ans
        ",1420570917
Lucky Orb,megurine,56,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, t: int) -> List[int]:
        ans = []
        for i in range(len(nums) - k + 1):
            a = nums[i:i + k]
            cc = Counter(a)
            b = sorted([(cc[x], x) for x in cc])[-t:]
            # print(a, b, b[-t:], b[-1:])
            val = 0
            for c, x in b:
                val += c * x
            ans.append(val)
        return ans",1420523288
chh9976,chh9976,57,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def check(node):
            if not node:
                return 0
            l = check(node.left)
            r = check(node.right)
            if l >= 0 and r >= 0 and l == r:
                res.append(l + r + 1)
                return l + r + 1
            else:
                return -1
        check(root)
        res.sort(reverse=True)
        if k > len(res):
            return -1
        return res[k-1]
                ",1420525294
chh9976,chh9976,57,3588,cpp,"
using namespace std;
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define ee9 1000000000

template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
int rewa(int a, int b){int temp = ((a - b) % 3 + 3) % 3; if(temp == 2) return -1; else return temp;}
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        vc dp(s.size() + 1, vc(s.size() * 2 + 1, vc<mint17>(3)));
        map<int, int> cc; cc['F'] = 0, cc['W'] = 1, cc['E'] = 2;
        rep(i, 0, 3) dp[1][n + rewa(i, cc[s[0]])][i] = 1;
        rep(k, 1, n){
            auto c = s[k];
            rep(l, 0, 3){
                rep(i, 0, 3) if(l != i){
                    int rew = rewa(i, cc[c]);
                    rep(j, 1, 2 * n) {
                        dp[k+1][j+rew][i] += dp[k][j][l];
                    }
                }
            }
        }
        mint17 ans = 0;
        rep(i, n+1, 2*n+1) rep(j, 0, 3){
            ans += dp[n][i][j];
        }
        return ans.get();
    }
};",1420546213
chh9976,chh9976,57,3592,cpp,"
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> cnter;
        set<ints2> inres;
        set<ints2> outres;
        long long res = 0;
        int n = nums.size();
        auto er = [&](ints2 a){
            if(inres.count(a)) {
                inres.erase(a);
                res -= 1ll * a[0] * a[1];
            }
            else outres.erase(a);
            while(outres.size() && inres.size() != x){
                auto [b, c] = *outres.rbegin();
                inres.insert({b, c});
                res += 1ll * b * c;
                outres.erase(prev(outres.end()));
            }
        };
        auto ins = [&](ints2 a){
            inres.insert(a);
            res += 1ll * a[0] * a[1];
            while(inres.size() > x){
                auto [b, c] = *inres.begin();
                inres.erase(inres.begin());
                res -= 1ll * b * c;
                outres.insert({b, c});
            }
        };
        vc<ll> ans;
        rep(i, 0, k-1) {
            er({cnter[nums[i]], nums[i]});
            cnter[nums[i]]++;
            ins({cnter[nums[i]], nums[i]});
        }
        rep(i, k-1, n){
            er({cnter[nums[i]], nums[i]});
            cnter[nums[i]]++;
            ins({cnter[nums[i]], nums[i]});
            ans.pb(res);
            er({cnter[nums[i-k+1]], nums[i-k+1]});
            cnter[nums[i-k+1]]--;
            ins({cnter[nums[i-k+1]], nums[i-k+1]});
        }
        return ans;
    }
};",1420571978
chh9976,chh9976,57,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        for i in range(n-k+1):
            c = Counter(nums[i:i+k])
            vs = sorted([(b, a) for a, b in c.items()], reverse=True)
            res = 0
            for j in range(min(x, len(vs))):
                res += vs[j][1] * vs[j][0]
            ans.append(res)
        return ans
            ",1420555670
IvanHugh,ivanc-e,58,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        def dfs(root: TreeNode) -> (bool, int):
            if root is None:
                return True, 0
            left_f, left_s = dfs(root.left)
            right_f, right_s = dfs(root.right)
            if left_f and right_f and left_s == right_s:
                ans.append(left_s + right_s + 1)
                return True, left_s + right_s + 1
            return False, left_s + right_s + 1
        dfs(root)
        ans.sort(reverse=True)
        print(ans)
        return -1 if k > len(ans) else ans[k-1]
        ",1420529680
IvanHugh,ivanc-e,58,3588,python3,"class Solution:  
    def countWinningSequences(self, s: str) -> int:  
        MOD = 10 ** 9 + 7  
        n = len(s)  
        moves = ['F', 'W', 'E']  
        winning_pairs = {('F', 'E'), ('W', 'F'), ('E', 'W')}  

        move_indices = {'Start': 0, 'F': 1, 'W': 2, 'E': 3}  

        dp = [[[0] * (2 * n + 1) for _ in range(4)] for _ in range(n + 1)]  
        
        dp[0][move_indices['Start']][n] = 1  

        for i in range(n):  
            alice_move = s[i]  
            for prev_move_idx in range(4):  
                for score_diff_index in range(2 * n + 1):  
                    count = dp[i][prev_move_idx][score_diff_index]  
                    if count > 0:  
                        prev_move = moves[prev_move_idx - 1] if prev_move_idx > 0 else 'Start'  
                        for bob_move in moves:  
                            if bob_move != prev_move:  
                                if alice_move == bob_move:  
                                    delta = 0  
                                elif (alice_move, bob_move) in winning_pairs:  
                                    delta = -1
                                elif (bob_move, alice_move) in winning_pairs:  
                                    delta = 1 
                                else:  
                                    delta = 0  
                                new_score_diff_index = score_diff_index + delta  
                                if 0 <= new_score_diff_index <= 2 * n:  
                                    new_prev_move_idx = move_indices[bob_move]  
                                    dp[i + 1][new_prev_move_idx][new_score_diff_index] = (  
                                        dp[i + 1][new_prev_move_idx][new_score_diff_index] + count  
                                    ) % MOD  

        total = 0  
        for prev_move_idx in range(1, 4):
            for score_diff_index in range(n + 1, 2 * n + 1):
                total = (total + dp[n][prev_move_idx][score_diff_index]) % MOD  

        return total",1420538817
IvanHugh,ivanc-e,58,3592,python3,"from sortedcontainers import SortedList  

class Solution:  
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:  
        n = len(nums)  
        counts = Counter()  
        top_x = SortedList()  
        rest = SortedList()  
        total_sum = 0  

        def get_key(elem, count):  
            return (-count, -elem)  

        for i in range(k):  
            counts[nums[i]] += 1  

        elements = list(counts.keys())  
        elements.sort(key=lambda elem: get_key(elem, counts[elem]))  
        for idx, elem in enumerate(elements):  
            key = get_key(elem, counts[elem])  
            if idx < x:  
                top_x.add((key, elem))  
                total_sum += counts[elem] * elem  
            else:  
                rest.add((key, elem))  

        ans = [total_sum]  

        for i in range(k, n):  
            out_elem = nums[i - k]  
            in_elem = nums[i]  

            old_count_out = counts[out_elem]  
            old_key_out = get_key(out_elem, old_count_out)  
            counts[out_elem] -= 1 
            if (old_key_out, out_elem) in top_x:  
                top_x.remove((old_key_out, out_elem))  
                total_sum -= old_count_out * out_elem  
            else:  
                rest.remove((old_key_out, out_elem))  

            if counts[out_elem] == 0:  
                del counts[out_elem]  
            else:  
                new_key_out = get_key(out_elem, counts[out_elem])  
                if len(top_x) < x or new_key_out < top_x[-1][0]:  
                    top_x.add((new_key_out, out_elem))  
                    total_sum += counts[out_elem] * out_elem  
                else:  
                    rest.add((new_key_out, out_elem))  

            old_count_in = counts.get(in_elem, 0)  
            if old_count_in > 0:  
                old_key_in = get_key(in_elem, old_count_in)  
                if (old_key_in, in_elem) in top_x:  
                    top_x.remove((old_key_in, in_elem))  
                    total_sum -= old_count_in * in_elem  
                else:  
                    rest.remove((old_key_in, in_elem))  
            counts[in_elem] = counts.get(in_elem, 0) + 1 
            new_key_in = get_key(in_elem, counts[in_elem])  

            if len(top_x) < x or new_key_in < top_x[-1][0]:  
                top_x.add((new_key_in, in_elem))  
                total_sum += counts[in_elem] * in_elem  
            else:  
                rest.add((new_key_in, in_elem))  

            while len(top_x) > x:  
                move_elem = top_x.pop()  
                total_sum -= counts[move_elem[1]] * move_elem[1]  
                rest.add(move_elem)  

            while len(top_x) < x and rest:  
                move_elem = rest.pop(0)  
                total_sum += counts[move_elem[1]] * move_elem[1]  
                top_x.add(move_elem)  

            while rest and top_x and rest[0][0] < top_x[-1][0]:  
                rest_elem = rest.pop(0)  
                top_elem = top_x.pop()  
                total_sum -= counts[top_elem[1]] * top_elem[1]  
                total_sum += counts[rest_elem[1]] * rest_elem[1]  
                top_x.add(rest_elem)  
                rest.add(top_elem)  

            ans.append(total_sum)  

        return ans",1420572394
IvanHugh,ivanc-e,58,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnt = Counter()
        n = len(nums)
        if n < k:
            return [sum(nums)]
        for i in range(k):
            cnt[nums[i]] += 1
        ans = []
        lst = [(v, k) for k, v in cnt.items()]
        lst.sort(reverse=True)
        cur = 0
        for j in range(min(x, len(lst))):
            cur += lst[j][0]*lst[j][1]
        ans.append(cur)
        for i in range(k, n):
            cnt[nums[i]] += 1
            cnt[nums[i-k]] -= 1
            lst = [(v, k) for k, v in cnt.items()]
            lst.sort(reverse=True)
            cur = 0
            for j in range(min(x, len(lst))):
                cur += lst[j][0]*lst[j][1]
            ans.append(cur)
            
        return ans",1420522858
Ryan,ryanwong0127,59,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.res = []
        
        def dfs(node):
            if not node:
                return True, 0, 0
            is_left_perfect, left_h, left_s = dfs(node.left)
            is_right_perfect, right_h, right_s = dfs(node.right)
            is_perfect = is_left_perfect and is_right_perfect and left_h == right_h
            h = max(left_h, right_h) + 1
            s = left_s + right_s + 1
            if is_perfect:
                self.res.append(s)
            return is_perfect, h, s
        
        dfs(root)
        self.res.sort(reverse=True)
        if len(self.res) >= k:
            return self.res[k - 1]
        
        return -1",1420526407
Ryan,ryanwong0127,59,3588,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
class Solution {
public:
    int countWinningSequences(string s) {
        const int n = s.length();
        map<char, int> move_to_index = {{'F',1}, {'W',2}, {'E',3}};
        bool BobWins[4][4] = {false};
        BobWins[1][3] = true;
        BobWins[2][1] = true;
        BobWins[3][2] = true; 
        
        vector<vector<vector<ll>>> dp(n+1, vector<vector<ll>>(4, vector<ll>(2*n+1, 0)));
        dp[0][0][n] = 1; 
        
        rep(i, 0, n) {
            int a_index = move_to_index[s[i]];
            rep(last_b, 0, 4) {
                rep(s_diff, 0, 2*n+1) {
                    ll count = dp[i][last_b][s_diff];
                    if(count == 0)
                        continue;
                    rep(b, 1, 4) {
                        if(last_b != 0 && b == last_b){continue; }
                        int delta = 0;
                        if(a_index == b) {
                            delta = 0;
                        } else if(BobWins[b][a_index]) {
                            delta = 1;
                        } else {
                            delta = -1;
                        }
                        int s_new = s_diff + delta;
                        if(s_new >= 0 && s_new <= 2*n) {
                            chsum(dp[i+1][b][s_new], count) ;
                        }
                    }
                }
            }
        }
        ll res = 0;
        rep(last_b, 1, 4) {
            rep(s_diff, n+1, 2*n+1) {
                chsum(res, dp[n][last_b][s_diff]);
            }
        }
        return res;
    }
};",1420542204
Ryan,ryanwong0127,59,3592,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

struct Node {
    pii key; 
    int size;
    ll sum;
    int priority;
    Node *left, *right;
    Node(pii k) : key(k), size(1), sum((ll)k.fi * k.se), priority(rng()), left(nullptr), right(nullptr) {}
};

int getSize(Node *node) {
    return node ? node->size : 0;
}

ll getSum(Node *node) {
    return node ? node->sum : 0;
}

void update(Node *node) {
    if (node) {
        node->size = 1 + getSize(node->left) + getSize(node->right);
        node->sum = (ll)node->key.fi * node->key.se + getSum(node->left) + getSum(node->right);
    }
}

void split(Node *node, pii key, Node *&left, Node *&right) {
    if (!node) {
        left = right = nullptr;
    } else if (node->key > key) { 
        split(node->left, key, left, node->left);
        right = node;
    } else {
        split(node->right, key, node->right, right);
        left = node;
    }
    update(node);
}

void merge(Node *&node, Node *left, Node *right) {
    if (!left || !right) {
        node = left ? left : right;
    } else if (left->priority > right->priority) {
        merge(left->right, left->right, right);
        node = left;
    } else {
        merge(right->left, left, right->left);
        node = right;
    }
    update(node);
}

void insert(Node *&node, Node *item) {
    if (!node) {
        node = item;
    } else if (item->priority > node->priority) {
        split(node, item->key, item->left, item->right);
        node = item;
    } else if (item->key < node->key) {
        insert(node->left, item);
    } else {
        insert(node->right, item);
    }
    update(node);
}

void erase(Node *&node, pii key) {
    if (!node) return;
    if (node->key == key) {
        Node *temp = node;
        merge(node, node->left, node->right);
        delete temp;
    } else if (key < node->key) {
        erase(node->left, key);
    } else {
        erase(node->right, key);
    }
    update(node);
}

ll query(Node *node, int x) {
    if (!node || x <= 0) return 0;
    int leftSize = getSize(node->left);
    if (leftSize >= x) {
        return query(node->left, x);
    } 
    ll res = getSum(node->left) + (ll)node->key.fi * node->key.se;
    x -= leftSize + 1;
    if (x > 0) {
        res += query(node->right, x);
    }
    return res;
}
class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        const int n = a.size();
        unordered_map<int, int> freq_map;
        Node *root = nullptr;
        vll res;

        rep(i, 0, k) {
            int old_freq = freq_map[a[i]];
            if (old_freq > 0) {
                erase(root, pii(-old_freq, -a[i]));
            }
            freq_map[a[i]] = old_freq + 1;
            insert(root, new Node(pii(-freq_map[a[i]], -a[i])));
        }
        res.pb(query(root, x));

        rep(i, k, n) {
            int out_val = a[i - k];
            int in_val = a[i];

            int out_freq = freq_map[out_val];
            erase(root, pii(-out_freq, -out_val));
            if (out_freq == 1) {
                freq_map.erase(out_val);
            } else {
                freq_map[out_val] = out_freq - 1;
                insert(root, new Node(pii(-freq_map[out_val], -out_val)));
            }

            int in_old_freq = freq_map[in_val];
            if (in_old_freq > 0) {
                erase(root, pii(-in_old_freq, -in_val));
            }
            freq_map[in_val] = in_old_freq + 1;
            insert(root, new Node(pii(-freq_map[in_val], -in_val)));

            res.pb(query(root, x));
        }
        return res;
    }
};",1420578528
Ryan,ryanwong0127,59,3610,python3,"class Solution:
    def findXSum(self, a: List[int], k: int, x: int) -> List[int]:
        n,max_val = len(a), max(a)  
        counts = [0] * (max_val + 1) 

        res = []
        for i in range(n - k + 1):
            if i == 0:
                for j in range(k):
                    counts[a[j]] += 1
            else:
                counts[a[i - 1]] -= 1
                counts[a[i + k - 1]] += 1

            freq_list = []
            for val in range(len(counts)):
                if counts[val] > 0:
                    freq_list.append((counts[val], val))

            freq_list.sort(key=lambda x: (-x[0], -x[1]))

            total = 0
            elements_taken = 0
            for freq, val in freq_list:
                total += freq * val
                elements_taken += 1
                if elements_taken == x:
                    break
            res.append(total)

        return res",1420521043
Ying Liu,pein531,60,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> cands;
    unordered_map<TreeNode*, int> sz;   // 统计子树大小
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(cands.begin(), cands.end());
        reverse(cands.begin(), cands.end());
        return k > cands.size()? -1: cands[k - 1];
    }

    pair<int, int> dfs(TreeNode* root) {
        if(!root) return {1, 0};
        auto leftInfo = dfs(root->left);
        auto rightInfo = dfs(root->right);
        int cnt = leftInfo.second + rightInfo.second + 1;
        int flag = (leftInfo.first == 1 && rightInfo.first == 1 && leftInfo.second == rightInfo.second)? 1: 0;
        if(flag) {
            cands.push_back(cnt);
        }
        return {flag, cnt};
    }
};",1420530157
Ying Liu,pein531,60,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = int(1e9 + 7)
        cands = ['F', 'W', 'E']
        @lru_cache(None)
        def dfs(i: int, score: int, pre: str) -> int:
            if i == n:
                return 1 if score > 0 else 0
            cnt = 0
            for cur in cands:
                if cur == pre:
                    continue
                delta = 0
                if s[i] != cur:
                    if (cur == 'F' and s[i] == 'E') or (cur == 'W' and s[i] == 'F') or (cur == 'E' and s[i] == 'W'):
                        delta = 1
                    else:
                        delta = -1
                cnt = (cnt + dfs(i + 1, score + delta, cur)) % mod
            return cnt
        ans = dfs(0, 0, '*')
        dfs.cache_clear()
        return ans",1420550929
Ying Liu,pein531,60,3592,cpp,"class Solution
{
public:
    map<int, int> cnt;
    map<int, set<int, greater<int>>, greater<int>> amap;
    map<int, set<int>> bmap;
    set<int> aset, bset;
    long long nowsum = 0;
    int n, szb = 0;
    void add(int x)
    {
        int c = cnt[x];
        cnt[x]++;
        if (aset.count(x))
        {
            amap[c].erase(x);
            aset.erase(x);
            if (amap[c].empty())
                amap.erase(c);
            bmap[c + 1].insert(x);
            bset.insert(x);
            szb += 1;
            nowsum += 1ll * (c + 1) * x;
        }
        else if (bset.count(x))
        {
            bmap[c].erase(x);
            if (bmap[c].empty())
                bmap.erase(c);
            bmap[c + 1].insert(x);
            nowsum += x;
        }
        else
        {
            bmap[c + 1].insert(x);
            bset.insert(x);
            nowsum += x;
            szb++;
        }
        while (szb > n)
        {
            int oldcnt = bmap.begin()->first;
            int oldx = *(bmap.begin()->second.begin());
            bmap.begin()->second.erase(bmap.begin()->second.begin());
            bset.erase(oldx);
            aset.insert(oldx);
            amap[oldcnt].insert(oldx);
            if (bmap.begin()->second.empty())
                bmap.erase(bmap.begin());
            szb--;
            nowsum -= 1ll * (oldcnt)*oldx;
        }
    }
    void erase(int x)
    {
        int c = cnt[x];
        cnt[x]--;
        if (aset.count(x))
        {
            amap[c].erase(x);
            if (amap[c].empty())
                amap.erase(c);
            amap[c - 1].insert(x);
        }
        else if (bset.count(x))
        {
            bmap[c].erase(x);
            bset.erase(x);
            if (bmap[c].empty())
                bmap.erase(c);
            amap[c - 1].insert(x);
            aset.insert(x);
            szb--;
            nowsum -= 1ll * c * x;
        }
        while (!aset.empty() && szb < n)
        {
            int oldcnt = amap.begin()->first;
            int oldx = *(amap.begin()->second.begin());
            amap.begin()->second.erase(amap.begin()->second.begin());
            aset.erase(oldx);
            if (amap.begin()->second.empty())
                amap.erase(amap.begin());
            bset.insert(oldx);
            bmap[oldcnt].insert(oldx);
            szb++;
            nowsum += 1ll * (oldcnt)*oldx;
        }
    }
    vector<long long> findXSum(vector<int> &nums, int k, int x)
    {
        n = x;
        for (int i = 0; i < k - 1; i++)
        {
            add(nums[i]);
        }
        vector<long long> ans;
        for (int i = k - 1; i < nums.size(); i++)
        {
            add(nums[i]);
            ans.push_back(nowsum);
            erase(nums[i - k + 1]);
        }
        return ans;
    }
};",1420578647
Ying Liu,pein531,60,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        for(int i = 0; i + k - 1 < n; i++) {
            vector<int> temp;
            for(int j = i; j <= i + k - 1; j++) {
                temp.push_back(nums[j]);
            }
            ans[i] = solve(temp, x);
        }
        return ans;
    }

    int solve(vector<int>& nums, int x) {
        unordered_map<int, int> counter;
        for(int num: nums) counter[num]++;
        if(counter.size() < x) return accumulate(nums.begin(), nums.end(), 0);
        vector<array<int, 2>> tup;
        for(auto&[num, cnt]: counter) {
            tup.push_back({cnt, num});
        }
        sort(tup.begin(), tup.end(), [&](auto& a, auto& b) {
            if(a[0] != b[0]) return a[0] > b[0];
            return a[1] > b[1];
        });
        int ans = 0;
        for(int i = 0; i < x; i++) {
            ans += tup[i][0] * tup[i][1];
        }
        return ans;
    }
};",1420521427
green_pig,green_pig,61,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        a = []
        def dfs(i):
            if i == None: return 1, 0
            p1, d1 = dfs(i.left)
            p2, d2 = dfs(i.right)
            d = max(d1, d2) + 1
            p = p1 and p2 and d1 == d2
            if p: a.append(2**d-1)
            return p, d
        dfs(root)
        return sorted(a)[::-1][k-1] if k <= len(a) else -1",1420520423
green_pig,green_pig,61,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        s = ['FWE'.index(x) for x in s]
        dp = [[1] + [0] * len(s)*2 for _ in range(3)]
        for x in s:
            dp2 = [[0] * (2*len(s)+1) for _ in range(3)]
            for p in range(3):
                for c in range(-len(s),len(s)+1):
                    for j in range(3):
                        if j != p:
                            t = ((x-j)%3==2) - ((x-j)%3==1)
                            dp2[p][c] += dp[j][c-t]
                    dp2[p][c] %= 1000000007
            dp = dp2
        return sum(sum(dp[j][1:len(s)+1]) for j in range(3))*pow(2,-1,1000000007)%1000000007",1420549117
green_pig,green_pig,61,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedList
        s = SortedList()
        t = 0
        def add(c, n):
            nonlocal t
            s.add((c, n))
            if s.index((c, n)) >= len(s) - x:
                t += c * n
                if len(s) - x - 1 >= 0:
                    c1, n1 = s[len(s) - x - 1]
                    t -= c1 * n1
        def remove(c, n):
            nonlocal t
            if s.index((c, n)) >= len(s) - x:
                t -= c * n
                if len(s) - x - 1 >= 0:
                    c1, n1 = s[len(s) - x - 1]
                    t += c1 * n1
            s.remove((c, n))
        c = Counter()
        def inc(n):
            if n in c:
                remove(c[n], n)
            c[n] += 1
            add(c[n], n)
        def dec(n):
            remove(c[n], n)
            c[n] -= 1
            if c[n] == 0:
                del c[n]
            else:
                add(c[n], n)
        for i in range(k):
            inc(nums[i])
        r = []
        for i in range(len(nums)-k+1):
            r.append(t)
            if i+k < len(nums):
                inc(nums[i+k])
                dec(nums[i])
        return r",1420567493
green_pig,green_pig,61,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        r = []
        for i in range(len(nums)-k+1):
            c = Counter(nums[i:i+k])
            a = sorted(c, key=lambda x: (c[x], x))[::-1][:x]
            r.append(sum(s * c[s] for s in a))
        return r",1420553170
John,123GJWEQ2,62,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        powers = set()
        
        for i in range(20):
            powers.add(2 ** i - 1)
        
        
        def dfs(node):
            if node == None:
                return 0
            
            t2 = dfs(node.left)
            t1 = dfs(node.right)
            if t1 == t2 and t1 in powers:
                ans.append(t1 + t2 + 1)
                return t1 + t2 + 1
            return -1
        
        dfs(root)
        ans.sort()
        ans.reverse()
        
        if k - 1 >= len(ans):
            return -1
        
        return ans[k - 1]",1420524290
John,123GJWEQ2,62,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        to_ind = {
            ""F"": 0,
            ""W"": 1,
            ""E"": 2,
        }
        
        #0 beats 2
        #1 beats 0
        #2 beats 1
        
        old_dp = [(0, 0, 0) for i in range(2 * len(s) + 20)]
        offset = len(s) + 10
        mod = 10 ** 9 + 7
        res = 0
        
        if to_ind[s[-1]] == 0:
            old_dp[offset] = (1, 0, 0)
            old_dp[1 + offset] = (0, 1, 0)
            old_dp[offset - 1] = (0, 0, 1)
            
        elif to_ind[s[-1]] == 1:
            old_dp[offset] = (0, 1, 0)
            old_dp[1 + offset] = (0, 0, 1)
            old_dp[offset - 1] = (1, 0, 0)
        else:
            old_dp[offset] = (0, 0, 1)
            old_dp[1 + offset] = (1, 0, 0)
            old_dp[offset - 1] = (0, 1, 0)
            
        for x in range(len(s) - 2, -1, -1):
            new_dp = [(0, 0, 0) for m in range(2 * len(s) + 20)]
            
            for i in range(1, len(new_dp) - 1):
                if to_ind[s[x]] == 0:
                    new_dp[i] = ((old_dp[i][1] + old_dp[i][2]) % mod,
                                 (old_dp[i - 1][0] + old_dp[i - 1][2]) % mod, 
                                 (old_dp[i + 1][0] + old_dp[i + 1][1]) % mod)
                elif to_ind[s[x]] == 1:
                    new_dp[i] = ((old_dp[i + 1][1] + old_dp[i + 1][2]) % mod,
                                 (old_dp[i][0] + old_dp[i][2]) % mod, 
                                 (old_dp[i - 1][0] + old_dp[i - 1][1]) % mod)
                else:
                    new_dp[i] = ((old_dp[i - 1][1] + old_dp[i - 1][2]) % mod,
                                 (old_dp[i + 1][0] + old_dp[i + 1][2]) % mod, 
                                 (old_dp[i][0] + old_dp[i][1]) % mod)
                
                
            old_dp = new_dp
            
            
        for i in range(offset + 1, len(old_dp)):
            res += sum(old_dp[i])
            res %= mod
            
        return res
            ",1420547564
John,123GJWEQ2,62,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        s1 = SortedList([(0, 0) for i in range(x + 1)]) #cnt, val (multiplied by -1)
        cnts = {}
        ans = []
        
        for i in list(set(nums)):
            s1.add((0, -i))
            cnts[-i] = 0
        
        p1 = 0
        p2 = 0
        res = 0
        
        while p2 < len(nums):
            num, cnt = -1 * nums[p2], cnts[-1 * nums[p2]]
            
            #removal
            if s1.bisect_left((cnt, num)) <= x - 1: #if it is in the k range
                res -= num * cnt #remove it from the sum
                s1.remove((cnt, num)) #remove it from the sortedlist
                res += s1[x - 1][0] * s1[x - 1][1] #add the new element to the answer
            else:
                s1.remove((cnt, num)) #just remove it from the sum
                
                
            #addition
            s1.add((cnt - 1, num)) #add the new one with the added count to the answer
            cnts[num] -= 1
            
            if s1.bisect_left((cnt - 1, num)) <= x - 1: #if the new count is in the range
                res += (cnt - 1) * num #add it to the result
                res -= s1[x][0] * s1[x][1] #take away the one moved out from the result
                
            
            #this is decreasing an element cnt
            if p2 - p1 + 1 > k:
                num, cnt = -1 * nums[p1], cnts[-1 * nums[p1]]
                
                if s1.bisect_left((cnt, num)) <= x - 1: #if it is in the k range
                    res -= num * cnt
                    s1.remove((cnt, num))
                    res += s1[x - 1][0] * s1[x - 1][1]
                else:
                    s1.remove((cnt, num))
                    
                    
                s1.add((cnt + 1, num))
                cnts[num] += 1
                
                if s1.bisect_left((cnt + 1, num)) <= x - 1:
                    res += (cnt + 1) * num
                    res -= s1[x][0] * s1[x][1]

                p1 += 1
                
                
            if p2 - p1 + 1 == k:
                ans.append(res)
                
            
            p2 += 1
            
        return ans",1420580194
John,123GJWEQ2,62,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        
        def calculate(arr):
            cnts = {}
            res = 0
            
            stuff = []
            
            for i in arr:
                cnts[i] = cnts.get(i, 0) + 1
                
            for (key, val) in cnts.items():
                stuff.append((val, key))
                
            stuff.sort()
            stuff.reverse()

            for i in range(min(len(stuff), x)):
                res += stuff[i][0] * stuff[i][1]
            return res
        
        
        for i in range(len(nums)):
            if i + k - 1 == len(nums):
                break
            
            ans.append(calculate(nums[i: i + k]))
        return ans",1420520488
Ye Gao,gaosanyong,63,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        vals = []
        
        def fn(node): 
            if not node: return 0 
            left = fn(node.left)
            right = fn(node.right)
            if left == -1 or right == -1 or left != right: return -1 
            ans = left + right + 1
            vals.append(ans)
            return ans 
        
        fn(root)
        vals.sort(reverse=True)
        if k <= len(vals): return vals[k-1]
        return -1 ",1420526758
Ye Gao,gaosanyong,63,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 1_000_000_007
        n = len(s)
        
        @cache
        def fn(i, p, diff): 
            """"""Return """"""
            if i == n: return int(diff > 0)
            ans = 0
            for x in ""EFW"": 
                if x != p: 
                    if s[i] == x: ans += fn(i+1, x, diff)
                    else: 
                        if s[i] == 'E': 
                            if x == 'F': d = diff + 1
                            else: d = diff - 1
                        elif s[i] == 'F': 
                            if x == 'E': d = diff - 1
                            else: d = diff + 1
                        else: 
                            if x == 'E': d = diff + 1
                            else: d = diff - 1
                        ans += fn(i+1, x, d)
            return ans % mod 
        
        return fn(0, """", 0)",1420540274
Ye Gao,gaosanyong,63,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        sl = SortedList()
        freq = Counter()
        ans = []
        total = 0 
        
        def add(v): 
            ans = 0 
            sl.add((-freq[v], -v))
            j = sl.bisect_left((-freq[v], -v))
            if j < x: 
                ans += freq[v]*v
                if len(sl) > x: 
                    ff, vv = sl[x]
                    ans -= ff*vv
            return ans 
            
        def remove(v): 
            ans = 0 
            j = sl.bisect_left((-freq[v], -v))
            if j < x: 
                ans -= freq[v]*v
                if len(sl) > x: 
                    ff, vv = sl[x]
                    ans += ff*vv
            sl.remove((-freq[v], -v))
            return ans 
        
        for i, v in enumerate(nums): 
            if freq[v]: total += remove(v)
            freq[v] += 1
            total += add(v)
            # print(""add"", total, freq, sl)
            if i >= k: 
                total += remove(nums[i-k])
                freq[nums[i-k]] -= 1
                if freq[nums[i-k]]: total += add(nums[i-k])
                # print(""remove"", total, freq, sl)
            if i >= k-1: ans.append(total)
            # print(i, v, total, sl, freq)
        return ans ",1420581047
Ye Gao,gaosanyong,63,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        n = len(nums)
        for i in range(n-k+1): 
            freq = Counter(nums[i:i+k])
            vals = sorted(freq.items(), key = lambda x: (-x[1], -x[0]))
            total = 0
            for j in range(i, i+k): 
                v = vals.index((nums[j], freq[nums[j]]))
                if v < x: total += nums[j]
            ans.append(total)
        return ans ",1420521651
lilPeep,stupidRR,66,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> good;
    pair<int,int> dfs(TreeNode* root)
    {
        if(root==NULL)
            return {0,0};
        
        int subtree=1;
        auto leftContri=dfs(root->left);
        auto rightContri=dfs(root->right);
        subtree=subtree+leftContri.first+rightContri.first;
        int depth=std::max(leftContri.second,rightContri.second)+1;
        if(1<<depth == subtree+1 )
            good.push_back(subtree);
        return {subtree,depth};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(good.rbegin(),good.rend());
        if(good.size()<k)
            return -1;
        return good[k-1];
    }
};",1420521453
lilPeep,stupidRR,66,3588,cpp,"class Solution {
    const int mod=1e9+7;
public:
    int countWinningSequences(string s) {
        vector<int> rep;
        for(auto used : s)
        {
            if(used=='F')
                rep.push_back(1);
            else if(used=='W')
                rep.push_back(0);
            else if(used=='E')
                rep.push_back(2);
        }
        
        int n=s.size();
        vector<vector<long long>> dp(2*n+1,vector<long long>(3,0));
        
        if(s[0]=='F')
        {
            dp[n][1]=1ll;
            dp[n-1][2]=1ll;
            dp[n+1][0]=1ll;
        }
        else if(s[0]=='E')
        {
            dp[n][2]=1ll;
            dp[n-1][0]=1ll;
            dp[n+1][1]=1ll;
        }
        else if(s[0]=='W')
        {
            dp[n][0]=1ll;
            dp[n-1][1]=1ll;
            dp[n+1][2]=1ll;
        }
        
        for(int i=1;i<n;i++)
        {
            int turnPlayed=rep[i];
            vector<vector<long long>> ndp(2*n+1,vector<long long>(3,0));
            
            for(int points=0;points<=2*n;points++)
            {
                for(int played=0;played<3;played++)
                {
                    for(int nextTurn=0;nextTurn<3;nextTurn++)
                    {
                        if(nextTurn==played)
                            continue;
                        
                        if(nextTurn==turnPlayed)
                            ndp[points][nextTurn]=(ndp[points][nextTurn]+dp[points][played])%mod;
                        if( (nextTurn+1)%3==turnPlayed && points<2*n)
                            ndp[points+1][nextTurn]=(ndp[points+1][nextTurn]+dp[points][played])%mod;
                        if( (nextTurn)%3==(turnPlayed+1)%3 && points)
                            ndp[points-1][nextTurn]=(ndp[points-1][nextTurn]+dp[points][played])%mod;
                    }
                }
            }
            
            swap(ndp,dp);
        }
        long long ans=0ll;
        for(int i=n+1;i<=2*n;i++)
            ans=(ans+dp[i][0]+dp[i][1]+dp[i][2])%mod;
        return ans;
    }
};",1420535462
lilPeep,stupidRR,66,3592,cpp,"class Solution {
struct Fenwick
{
    vector<long long> BIT;
    long long MAXN;
    
    void init(int n)
    {
        BIT.resize(n+5);
        MAXN=n+5;
    }

    long long query(long long x)
    {
       long long ans=0;
        x=std::min(x,MAXN-1);
       while(x>0)
       {
          ans+=BIT[x];
          x-=(x&-x);
       }
       return ans; 
    }
     
    void update(long long x,long long val)
    {
        if(x==0)
            return;
        
       while(x<MAXN)
       {
          BIT[x]+=val;
          x+=(x&-x);
       }
    }
     
    long long bit_search(long long v)
    {
        long long sum = 0;
        long long pos = 0;
        for (long long i = 25; i >= 0; i--)
        {
            if (pos + (1 << i) < MAXN)
            {
                long long nextPos = pos + (1 << i);
                if (sum + BIT[nextPos] < v)
                {
                    sum += BIT[nextPos]; 
                    pos = nextPos;
                }
            }
        }
        return pos ;
    }
};

public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        map<int,long long> mp;
        for(int i=0;i<n;i++)
            mp[ nums[i] ]++;
        
        vector< pair<int,int> > tmp;
        for(auto &[key,value] : mp)
        {
            for(int j=1;j<=value;j++)
                tmp.push_back({j,key});
        }
        
        sort(tmp.begin(),tmp.end(),[&](pair<int,int>a,pair<int,int>b){
           if(a.first!=b.first)
               return a.first>b.first;
            return a.second>b.second;
        });
        
        map< pair<int,int>,int > index;
        for(int i=0;i<tmp.size();i++)
            index[ tmp[i] ]=i+1;
        
        Fenwick f1;
        Fenwick f2;
        f1.init(n+5);
        f2.init(n+5);
        
        vector<long long> ans;
        mp.clear();
        for(int i=0;i<n;i++)
        {
            if(mp[ nums[i] ]!=0)
            {
                int ind=index[ {mp[nums[i]],nums[i]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i]]*1ll*nums[i] );
            }
            mp[nums[i]]++;
            int ind=index[ {mp[nums[i]],nums[i]} ];
            f1.update(ind,1);
            f2.update(ind, mp[nums[i]]*1ll*nums[i] );
            
            if(i>=k)
            {
                int ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i-k]]*1ll*nums[i-k] );
                mp[ nums[i-k] ]--;
                ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                if( mp[ nums[i-k] ])
                {
                    f1.update(ind,1);
                    f2.update(ind,mp[nums[i-k]]*1ll*nums[i-k] );
                }
            }
            
            if(i>=k-1)
                ans.push_back(  f2.query ( f1.bit_search(x+1) )  );
        }
        return ans;
    }
};",1420575134
lilPeep,stupidRR,66,3610,cpp,"class Solution {
struct Fenwick
{
    vector<long long> BIT;
    long long MAXN;
    
    void init(int n)
    {
        BIT.resize(n+5);
        MAXN=n+5;
    }

    long long query(long long x)
    {
       long long ans=0;
        x=std::min(x,MAXN-1);
       while(x>0)
       {
          ans+=BIT[x];
          x-=(x&-x);
       }
       return ans; 
    }
     
    void update(long long x,long long val)
    {
        if(x==0)
            return;
        
       while(x<MAXN)
       {
          BIT[x]+=val;
          x+=(x&-x);
       }
    }
     
    long long bit_search(long long v)
    {
        long long sum = 0;
        long long pos = 0;
        for (long long i = 25; i >= 0; i--)
        {
            if (pos + (1 << i) < MAXN)
            {
                long long nextPos = pos + (1 << i);
                if (sum + BIT[nextPos] < v)
                {
                    sum += BIT[nextPos]; 
                    pos = nextPos;
                }
            }
        }
        return pos ;
    }
};

public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        map<int,long long> mp;
        for(int i=0;i<n;i++)
            mp[ nums[i] ]++;
        
        vector< pair<int,int> > tmp;
        for(auto &[key,value] : mp)
        {
            for(int j=1;j<=value;j++)
                tmp.push_back({j,key});
        }
        
        sort(tmp.begin(),tmp.end(),[&](pair<int,int>a,pair<int,int>b){
           if(a.first!=b.first)
               return a.first>b.first;
            return a.second>b.second;
        });
        
        map< pair<int,int>,int > index;
        for(int i=0;i<tmp.size();i++)
            index[ tmp[i] ]=i+1;
        
        Fenwick f1;
        Fenwick f2;
        f1.init(n+5);
        f2.init(n+5);
        
        vector<int> ans;
        mp.clear();
        for(int i=0;i<n;i++)
        {
            if(mp[ nums[i] ]!=0)
            {
                int ind=index[ {mp[nums[i]],nums[i]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i]]*1ll*nums[i] );
            }
            mp[nums[i]]++;
            int ind=index[ {mp[nums[i]],nums[i]} ];
            f1.update(ind,1);
            f2.update(ind, mp[nums[i]]*1ll*nums[i] );
            
            if(i>=k)
            {
                int ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i-k]]*1ll*nums[i-k] );
                mp[ nums[i-k] ]--;
                ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                if( mp[ nums[i-k] ])
                {
                    f1.update(ind,1);
                    f2.update(ind,mp[nums[i-k]]*1ll*nums[i-k] );
                }
            }
            
            if(i>=k-1)
                ans.push_back(  f2.query ( f1.bit_search(x+1) )  );
        }
        return ans;
    }
};",1420575924
Chinedu,profchi,67,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    List<Integer> list = new ArrayList<>();
    
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        
        getAll(root);
        
        Collections.sort(list, (a, b) -> b - a);
        
        return list.size() < k ? -1 : list.get(k - 1);
    }
    
    private int getAll(TreeNode node) {
        if (node == null)
            return 0;
        
        int left = getAll(node.left);
        int right = getAll(node.right);
        
        int total = left + right + 1;
        
        if (left == right && left >= 0) {
            list.add(total);
            return total;
        }
        
        return -1;
    }
}",1420526882
Chinedu,profchi,67,3588,java,"class Solution {
    
    char [] arr = new char [] {'F', 'W', 'E'};
    int mod = 1_000_000_007;
    Integer [][][] memo;
    int add;
    
    public int countWinningSequences(String s) {
        memo = new Integer[4][s.length()][s.length() * 2 + 1];
        add = s.length();
        return countWinning(s, 0, 3, 0);
    }
    
    private int countWinning(String s, int idx, int prev, int sc) {
        if (idx == s.length()) {
            return sc > 0 ? 1 : 0;
        }else if (memo[prev][idx][sc + add] != null)
            return memo[prev][idx][sc + add];
        
        int aVal = get(s.charAt(idx));
        
        int score;
        
        int result = 0;
        
        for (int b = 0; b < 3; ++b) {
            
            if (b == prev)
                continue;
            
            if (wins(aVal, b)) {
                score = 1;
            } else {
                score = aVal == b ? 0 : -1;
            }
            
            result += countWinning(s, idx + 1, b, sc + score);
            result %= mod;
        }
        
        memo[prev][idx][sc + add] = result;
        return result;
    }
    
    private boolean wins(int a, int b) {
        int next = a + 1;
        next %= 3;
        
        return next == b;
    }
    
    private int get(char c) {
        
        for (int i = 0; i < arr.length; ++i) {
            if (arr[i] == c)
                return i;
        }
        
        return arr.length;
    }
}",1420539351
Chinedu,profchi,67,3592,java,"class Solution {
    
    
    TreeSet<Integer> top;
    TreeSet<Integer> bottom;
    int [] count;
    long current;
    
    int [] vals;
    
    public long[] findXSum(int[] nums, int k, int x) {
        
        vals = compress(nums);
        
        int max = vals.length;
        count = new int [max];
        
        top = new TreeSet<>((a, b) -> count[a] == count[b] ? a - b : count[a] - count[b]);
        bottom = new TreeSet<>((a, b) -> count[a] == count[b] ? a - b : count[a] - count[b]);
        
        current = 0;
        
        long [] result = new long [nums.length - k + 1];
        
        for (int i = 0; i < k - 1; ++i) {
            add(nums[i], 1, x);    
        }
        
        // System.out.println(top + "" "" + Arrays.toString(count) + "" "" + current);
        
        for (int i = k - 1, j = 0; i < nums.length; ++i, ++j) {
            add(nums[i], 1, x);
            
            // System.out.println(top + "" "" + Arrays.toString(count) + "" "" + current);
            
            result[j] = current;
            
            add(nums[j], -1, x);
        }
        
        return result;
    }
    
    private void add(int num, int add, int x) {
        
        bottom.remove(num);
        
        long val;
        
        if (top.contains(num)) {
            top.remove(num);
            val = vals[num];
            val *= count[num];
            current -= val;
        }
        
        count[num] += add;
        bottom.add(num);
        
        int node;
        
        if (!top.isEmpty()) {
            node = top.first();
            val = vals[node];
            val *= count[node];
            current -= val;
            top.remove(node);
            bottom.add(node);
        }
        
        
        while (top.size() < x && bottom.size() > 0) {
            
            node = bottom.last();
            bottom.remove(node);
            val = vals[node];
            val *= count[node];
            current += val;
            top.add(node);
            // System.out.println(""Here"" + "" "" + current);
        }
    }
    
    private int [] compress(int [] nums) {
        Set<Integer> set = new HashSet<>();
        
        for (int num : nums) {
            set.add(num);
        }
        
        List<Integer> list = new ArrayList<>(set);
        
        Map<Integer, Integer> map = new HashMap<>();
        
        Collections.sort(list);
        int [] result = new int [list.size()];
        
        for (int i = 0; i < list.size(); ++i) {
            map.put(list.get(i), i);
            result[i] = list.get(i);
        }
        
        for (int i = 0; i < nums.length; ++i) {
            nums[i] = map.get(nums[i]);
        }
        
        return result;
    }
}",1420582220
Chinedu,profchi,67,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        
        int [] result = new int [nums.length - k + 1];
        
        for (int i = 0; i + k <= nums.length; ++i) {
            result[i] = findXSum(nums, i, i + k - 1, x);
        }
        
        return result;
    }
    
    private int findXSum(int [] arr, int l, int r, int x) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int i = l; i <= r; ++i) {
            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
        }
        
        List<Integer> list = new ArrayList<>(map.keySet());
        
        Collections.sort(list, (a, b) -> {
            int kA = map.get(a);
            int kB = map.get(b);
            
            return kA == kB ? b - a : kB - kA;
        });
        
        int total = 0;
        
        for (int i = 0; i < list.size() && i < x; ++i) {
            total += list.get(i) * map.get(list.get(i));
        }
        
        // System.out.println(map);
        // System.out.println(list);
        
        return total;
    }
}",1420549779
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        auto dfs = [&](auto self, TreeNode* node) -> array<int, 3> {
            if (node == nullptr) {
                return {0, 0, 1};
            }
            auto [sleft, depth1, pos1] = self(self, node->left);
            auto [sright, depth2, pos2] = self(self, node->right);
            
            int pos_me = pos1 & pos2;

            if ((node->left == nullptr) != (node->right == nullptr)) {
                pos_me = false;
            }

            if (depth1 != depth2) {
                pos_me = false;
            }

            if (pos_me) {
                sizes.push_back(sleft + sright + 1);
            }

            return {sleft + sright + 1, max(depth1, depth2) + 1, pos_me};
        };
        dfs(dfs, root);
        sort(sizes.rbegin(), sizes.rend());
        if ((int)sizes.size() < k) {
            return -1;
        }
        return sizes[k - 1];
    }
};",1420527387
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int offset = 1005;

        const int N = 3005;

        int n = (int)s.size();
        int dp[n + 1][N][4];

        s = ""#"" + s;

        const int MOD = 1e9 + 7;

        memset(dp, 0, sizeof dp);
        dp[0][offset][3] = 1;

        for (int i = 1; i <= n; ++i) {
            int h = s[i] == 'F' ? 0 : (s[i] == 'W' ? 1 : 2);
            for (int p = -n; p <= n; ++p) {
                int cp = p + offset;
                for (int me = 0; me < 3; ++me) {
                    int np = cp + ((h + 1) % 3 == me ? 1 : h == me ? 0 : -1);
                    for (int he = 0; he < 4; ++he) {
                        if (me == he) {
                            continue;
                        }

                        (dp[i][np][me] += dp[i - 1][cp][he]) %= MOD;

                    }
                }
            }
        }

        int total = 0;
        for (int i = 1; i + offset < N; ++i) {
            for (int t = 0; t < 3; ++t) {
                total += dp[n][i + offset][t];
                total %= MOD;
            }
        }
        return total;
    }
};",1420546379
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        set<pair<int, int>> small, large;
        map<int, int> freq;
        for (int i = 0; i < k; ++i) {
            ++freq[a[i]];
        }

        long long sum_large = 0;
        for (auto p : freq) {
            large.insert({p.second, p.first});
            sum_large += 1LL * p.second * p.first;
        }

        while ((int)large.size() > x) {
            pair<int, int> p = *large.begin();
            small.insert(p);
            large.erase(p);
            sum_large -= 1LL * p.first * p.second;
        }

        vector<long long> ans;
        ans.push_back(sum_large);

        auto add = [&](int v, int coeff) -> void {
            if (large.count({freq[v], v})) {
                large.erase({freq[v], v});
                sum_large -= 1LL * freq[v] * v;
            } else {
                small.erase({freq[v], v});
            }

            freq[v] += coeff;

            small.insert({freq[v], v});

            while (!small.empty() && (int)large.size() < x) {
                pair<int, int> p = *small.rbegin();
                large.insert(p);
                small.erase(p);
                sum_large += 1LL * p.first * p.second;
            }

            while (!small.empty() && *large.begin() < *small.rbegin()) {
                pair<int, int> A = *large.begin();
                pair<int, int> B = *small.rbegin();
                large.erase(A);
                sum_large -= 1LL * A.first * A.second;
                small.erase(B);
                large.insert(B);
                small.insert(A);

                sum_large += 1LL * B.first * B.second;
            }

        };

        for (int i = k; i < (int)a.size(); ++i) {
            add(a[i - k], -1);
            add(a[i], 1);
            ans.push_back(sum_large);
        }
        return ans;

    }
};",1420563758
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        set<pair<int, int>> small, large;
        map<int, int> freq;
        for (int i = 0; i < k; ++i) {
            ++freq[a[i]];
        }

        long long sum_large = 0;
        for (auto p : freq) {
            large.insert({p.second, p.first});
            sum_large += 1LL * p.second * p.first;
        }

        while ((int)large.size() > x) {
            pair<int, int> p = *large.begin();
            small.insert(p);
            large.erase(p);
            sum_large -= 1LL * p.first * p.second;
        }

        vector<int> ans;
        ans.push_back(sum_large);

        auto add = [&](int v, int coeff) -> void {
            if (large.count({freq[v], v})) {
                large.erase({freq[v], v});
                sum_large -= 1LL * freq[v] * v;
            } else {
                small.erase({freq[v], v});
            }

            freq[v] += coeff;

            small.insert({freq[v], v});

            while (!small.empty() && (int)large.size() < x) {
                pair<int, int> p = *small.rbegin();
                large.insert(p);
                small.erase(p);
                sum_large += 1LL * p.first * p.second;
            }

            while (!small.empty() && *large.begin() < *small.rbegin()) {
                pair<int, int> A = *large.begin();
                pair<int, int> B = *small.rbegin();
                large.erase(A);
                sum_large -= 1LL * A.first * A.second;
                small.erase(B);
                large.insert(B);
                small.insert(A);

                sum_large += 1LL * B.first * B.second;
            }

        };

        for (int i = k; i < (int)a.size(); ++i) {
            add(a[i - k], -1);
            add(a[i], 1);
            ans.push_back(sum_large);
        }
        return ans;

    }
};",1420564836
IphoneX,hahahiehie,69,3509,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int L = 50 + 1;




    List<Integer> ans;
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        ans = new ArrayList<>();
        dfs(root);
        ans.sort((x, y) -> Integer.compare(y, x));
        if (ans.size() < k) return -1;
        else return ans.get(k - 1);
    }

    int dfs(TreeNode root) {
        if (root == null) return -1;
        int l = 0;
        if (root.left != null) {
            l = dfs(root.left);
        }
        int r = 0;
        if (root.right != null) {
            r = dfs(root.right);
        }
        if (l == r && l >= 0) {
            ans.add(l + r + 1);
            return l + r + 1;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420527826
IphoneX,hahahiehie,69,3588,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int L = 50 + 1;


    int score(int alice, int bob) {
        if (alice == bob) return 0;
        if (bob == 0 && alice == 1) return 1;
        else if (bob == 1 && alice == 2) return 1;
        else if (bob == 2 && alice == 0) return 1;
        return -1;
    }

    public int countWinningSequences(String s) {
        int n = s.length();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == 'F') {
                nums[i] = 0;
            } else if (s.charAt(i) == 'E') {
                nums[i] = 1;
            } else {
                nums[i] = 2;
            }
        }
        final int L = n;
        long[][][] dp = new long[n][n * 2 + 2][3];
        dp[0][score(nums[0], 0) + L][0] = 1;
        dp[0][score(nums[0], 1) + L][1] = 1;
        dp[0][score(nums[0], 2) + L][2] = 1;

        for (int i = 0; i < n - 1; i++) {
            for (int j = -(i + 1); j <= (i + 1); j++) {
                for (int c = 0; c <= 2; c++) {
                    if (dp[i][j + L][c] == 0) continue;

                    for (int c2 = 0; c2 <= 2; c2++) {
                        if (c2 == c) continue;
                        int sc = score(nums[i + 1], c2);
                        dp[i + 1][j + sc + L][c2] = (dp[i + 1][j + sc + L][c2] + dp[i][j + L][c]) % MOD;
                    }
                }
            }
        }

        long ans = 0;
        for (int sc = 1; sc <= n; sc++) {
            for (int c = 0; c <= 2; c++) {
                ans = (ans + dp[n - 1][sc + L][c]) % MOD;
            }
        }
        return (int) ans;

    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420546077
IphoneX,hahahiehie,69,3592,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    void print(TreapSet<int[]> set) {
        for (int i = 0; i < set.size(); i++) {
            System.out.printf(""[%d,%d] "", set.get(i)[0], set.get(i)[1]);
        }
        System.out.println();
    }

    long remove(int[] node, int x, TreapSet<int[]> set) {
        if (node[1] == 0) return 0;

        long ans = 0;
        if (set.index(node) < x) {
            ans = - (long) node[0] * node[1];
            set.remove(node);
            if (set.size() >= x) {
                int[] last = set.get(x - 1);
                ans += (long) last[0] * last[1];
            }
        } else {
            set.remove(node);
        }
        //print(set);
        //System.out.println(""remove ans = "" + ans);

        return ans;
    }

    long add(int[] node, int x, TreapSet<int[]> set) {
        if (node[1] == 0) return 0;
        long ans = 0;
        if (set.index(node) < x) {
            ans = (long) node[0] * node[1];
            set.add(node);
            if (set.size() >= x + 1) {
                int[] last = set.get(x);
                ans -= (long) last[0] * last[1];
            }
        } else {
            set.add(node);
        }
        //print(set);
        //System.out.println(""add ans = "" + ans);
        return ans;
    }
    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] ans = new long[n - k + 1];

        Map<Integer, Integer> count = new HashMap<>();
        TreapSet<int[]> set = new TreapSet<>((a, b) -> {
            if (a[1] != b[1]) return Integer.compare(b[1], a[1]);
            else return Integer.compare(b[0], a[0]);
        });


        long curSum = 0;
        for (int i = 0; i < n; i++) {
            int oldCount = count.getOrDefault(nums[i], 0);
            int newCount = oldCount + 1;
            count.put(nums[i], newCount);
            int[] oldNode = {nums[i], oldCount};
            int[] newNode = {nums[i], newCount};
            curSum += remove(oldNode, x, set);
            curSum += add(newNode, x, set);

            if (i - k >= 0) {
                oldCount = count.get(nums[i - k]);
                oldNode = new int[] {nums[i - k], oldCount};
                newCount = oldCount - 1;
                count.put(nums[i - k], newCount);
                newNode = new int[] {nums[i - k], newCount};
                curSum += remove(oldNode, x, set);
                curSum += add(newNode, x, set);
            }

            if (i >= k - 1) {
                ans[i - k + 1] = curSum;
            }

            //System.out.println(""i = "" + i  + "" ==========\n"");

        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420582919
IphoneX,hahahiehie,69,3610,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int L = 50 + 1;

    int helper(int[] nums, int k, int XX, int index) {
        int[] count = new int[L];
        for (int i = index; i < index + k; i++) {
            count[nums[i]]++;
        }

        List<int[]> list = new ArrayList<>();
        for (int i = 1; i < L; i++) {
            if (count[i] > 0) {
                list.add(new int[] {i, count[i]});
            }
        }
        list.sort((x, y) -> {
            if (x[1] != y[1]) return Integer.compare(y[1], x[1]);
            else return Integer.compare(y[0], x[0]);
        });

        int sum = 0;
        for (int i = 0; i < XX && i < list.size(); i++) {
            sum += list.get(i)[0] * list.get(i)[1];   
        }
        return sum;
    }

    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        for (int i = 0; i + k <= n; i++) {
            ans[i] = helper(nums, k, x, i);
        }
        return ans;
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420523030
scotchtape,scotchtape,70,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> P;
        // perfect, size
        function<pair<bool, int>(TreeNode *i)> perf = [&](TreeNode *i) {
            if (i == nullptr) return make_pair(true, 0);

            auto l = perf(i->left), r = perf(i->right);
            bool p = (l.first & r.first) && (l.second == r.second);
            int sz = l.second + r.second + 1;
            
            if (p) P.push_back(sz);
            return make_pair(p, sz);
        };

        perf(root);
        sort(P.rbegin(), P.rend());
        //for (int i : P) cout << i << endl;
        --k;
        if (k >= P.size()) return -1;
        return P[k];
    }
};",1420524057
scotchtape,scotchtape,70,3588,cpp,"
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");
    int v;
private:
    using ll = long long;

    static int minv(int a, int m) {
        a %= m;
        assert(a);
        return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);
    }
public:
    modnum() : v(0) {}
    modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }
    friend bool operator < (const modnum& a, const modnum& b) { return a.v < b.v; }
    friend bool operator > (const modnum& a, const modnum& b) { return a.v > b.v; }

    modnum inv() const {
        modnum res;
        res.v = minv(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(ll(v) * ll(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }

};
using num = modnum<int(1e9+7)>;

class Solution {
public:
    int countWinningSequences(string s) {
        using ll = long long;
        ll M = 1e9+7;
        ll n = s.size();

        ll S = 2*n+3;
        vector<vector<ll>> a(S, vector<ll>(3, 0));
        // # bob is ahead + n, prev move
        a[0+n] = {1, 1, 1};

        map<char, ll> MOVE;
        MOVE['F'] = 0;
        MOVE['W'] = 1;
        MOVE['E'] = 2;

        vector<vector<ll>> SCORE = {
                {0, 1, -1}, // alice fire
                {-1, 0, 1},
                {1, -1, 0}
        };

        for (char c : s) {
            vector<vector<ll>> ndp(S, vector<ll>(3, 0));
            ll x = MOVE[c];
            for (ll s = 0; s < S; ++s) {
                for (ll move = 0; move < 3; ++move) {
                    ll nxt_score = s + SCORE[x][move];
                    if (nxt_score < 0 || nxt_score >= S) continue;
                    for (ll prev = 0; prev < 3; ++prev) {
                        if (prev == move) continue;
                        ndp[nxt_score][move] = (ndp[nxt_score][move] + a[s][prev]) % M;
                    }
                }
            }
            swap(ndp, a);
        }
        ll ans = 0;
        for (ll i = n+1; i < S; ++i) {
            for (ll m = 0; m < 3; ++m) {
                ans = (ans + a[i][m]) % M;
            }
        }

        return (num(ans)/num(2)).v;
    }
};",1420545466
scotchtape,scotchtape,70,3592,cpp,"
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template<class T> using oset=tree<T, null_type, greater<T>, rb_tree_tag, tree_order_statistics_node_update>;

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        using ll = long long;
        ll n = a.size();
        vector<ll> ans;

//        for (int i : a) cout << i << ' ';
//        cout << endl << endl;

        map<ll, ll> m;
        for (ll i = 0; i < k; ++i) m[a[i]]++;

        oset<pair<ll, ll>> s;
        for (ll i = 0; i < n; ++i) s.insert({0, 1e12+i});

        vector<pair<ll, ll>> v;
        for (auto [x, cnt] : m) v.push_back({cnt, x}), s.insert({cnt, x});
        sort(v.rbegin(), v.rend());
        ll sum = 0;
        for (ll j = 0; j < min(ll(x), ll(v.size())); ++j)
            sum += v[j].first * v[j].second;
        ans.push_back(sum);

        auto rem = [&](ll val, ll cnt) {
            auto prev = make_pair(cnt, val);
            s.erase(prev);
            if (*s.find_by_order(x-1) <= prev) {
                // prev is part of sum
                sum -= prev.first * prev.second;

                // add the next guy
                auto nxt = *s.find_by_order(x-1);
                sum += nxt.first * nxt.second;
            }
        };

        auto add = [&](ll val, ll cnt) {
            auto nxt = make_pair(cnt, val);

            if (*s.find_by_order(x-1) <= nxt) {
                // nxt is in sum
                sum += nxt.first * nxt.second;

                // remove the last guy
                auto prev = *s.find_by_order(x-1);
                sum -= prev.first * prev.second;

            }
            s.insert(nxt);
        };

        for (int i = 0; i+k < n; ++i) {
            rem(a[i], m[a[i]]);
            --m[a[i]];
            add(a[i], m[a[i]]);

//            for (auto p : s) cout << p.first << ' ' << p.second << endl;
//            cout << sum << endl;
//            cout << endl << endl;

            rem(a[i+k], m[a[i+k]]);
            m[a[i+k]]++;
            add(a[i+k], m[a[i+k]]);

//            for (auto p : s) cout << p.first << ' ' << p.second << endl;
//            cout << sum << endl;
//            cout << endl << endl;

            ans.push_back(sum);
        }
        return ans;

    }
};",1420577477
scotchtape,scotchtape,70,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        vector<int> ans;
        for (int i = 0; i+k-1 < n; ++i) {
            map<int, int> m;
            for (int j = 0; j < k; ++j) {
                m[a[i+j]]++;
            }
            vector<pair<int, int>> v;
            for (auto [x, cnt] : m) v.push_back({cnt, x});
            sort(v.rbegin(), v.rend());

            int sum = 0;
            for (int j = 0; j < min<int>(x, v.size()); ++j) {
                sum += v[j].first * v[j].second;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420519743
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct ReturnType {
        bool isPerfect;
        int height;
        int size;
    };

    vector<int> perfectSubtreeSizes;

    ReturnType helper(TreeNode* root) {
        if (!root) {
            return { true, 0, 0 };
        }

        if (!root->left && !root->right) {
            perfectSubtreeSizes.push_back(1);
            return { true, 1, 1 };
        }

        ReturnType left = helper(root->left);
        ReturnType right = helper(root->right);

        bool isPerfect = false;
        int height = max(left.height, right.height) + 1;
        int size = left.size + right.size + 1;

        if (left.isPerfect && right.isPerfect && left.height == right.height) {
            isPerfect = true;
            perfectSubtreeSizes.push_back(size);
        }

        return { isPerfect, height, size };
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        helper(root);
        sort(perfectSubtreeSizes.begin(), perfectSubtreeSizes.end(), greater<int>());
        if (perfectSubtreeSizes.size() >= k) {
            return perfectSubtreeSizes[k - 1];
        } else {
            return -1;
        }
    }
};
",1420528690
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        int charToIndex[256];
        memset(charToIndex, -1, sizeof(charToIndex));
        charToIndex['F'] = 0;
        charToIndex['W'] = 1;
        charToIndex['E'] = 2;
        charToIndex['X'] = 3;

        bool beats[3][3];
        memset(beats, 0, sizeof(beats));
        beats[0][2] = true; 
        beats[1][0] = true; 
        beats[2][1] = true; 

        int maxScoreDiff = 2 * n;
        int offset = n; 

        const int MOD = 1e9 + 7;

        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(maxScoreDiff + 1, 0)));
        dp[0][3][offset] = 1; 

        for (int i = 0; i < n; ++i) {
            for (int lastBobMove = 0; lastBobMove < 4; ++lastBobMove) {
                for (int scoreDiff = 0; scoreDiff <= maxScoreDiff; ++scoreDiff) {
                    int ways = dp[i][lastBobMove][scoreDiff];
                    if (ways == 0) continue;

                    for (int bobMove = 0; bobMove < 3; ++bobMove) {
                        if (bobMove == lastBobMove) continue; 
                        int aliceMove = charToIndex[s[i]];
                        int scoreChange = 0;
                        if (bobMove == aliceMove) {
                            scoreChange = 0;
                        } else if (beats[bobMove][aliceMove]) {
                            scoreChange = 1; 
                        } else if (beats[aliceMove][bobMove]) {
                            scoreChange = -1; 
                        } else {
                            scoreChange = 0; 
                        }

                        int newScoreDiff = scoreDiff + scoreChange;
                        if (newScoreDiff < 0 || newScoreDiff > maxScoreDiff) continue;

                        dp[i + 1][bobMove][newScoreDiff] = (dp[i + 1][bobMove][newScoreDiff] + ways) % MOD;
                    }
                }
            }
        }
        int totalWays = 0;
        for (int lastBobMove = 0; lastBobMove < 3; ++lastBobMove) {
            for (int scoreDiff = offset + 1; scoreDiff <= maxScoreDiff; ++scoreDiff) {
                totalWays = (totalWays + dp[n][lastBobMove][scoreDiff]) % MOD;
            }
        }

        return totalWays;
    }
};
",1420546683
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;

        unordered_map<int, int> freq; 

        struct Compare {
            bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
                if (a.second != b.second)
                    return a.second > b.second; 
                else
                    return a.first > b.first; 
            }
        };

        multiset<pair<int, int>, Compare> top_elements; 
        multiset<pair<int, int>, Compare> rest_elements;

        unordered_map<int, multiset<pair<int, int>, Compare>::iterator> positions;

        long long x_sum = 0;

        auto insert_element = [&](int value) {
            int f = freq[value];
            pair<int, int> element = {value, f};

            auto it = rest_elements.insert(element);
            positions[value] = it;

            if (top_elements.size() < x) {
                top_elements.insert(element);
                rest_elements.erase(it);
                positions[value] = top_elements.find(element);
                x_sum += (long long)value * f;
            } else {
                auto min_top = prev(top_elements.end());
                if (Compare()(element, *min_top)) {
                    top_elements.insert(element);
                    rest_elements.erase(it);
                    positions[value] = top_elements.find(element);
                    x_sum += (long long)value * f;

                    rest_elements.insert(*min_top);
                    positions[min_top->first] = rest_elements.find(*min_top);
                    x_sum -= (long long)min_top->first * min_top->second;
                    top_elements.erase(min_top);
                }
            }
        };

        auto remove_element = [&](int value) {
            auto it = positions[value];
            if (top_elements.find(*it) != top_elements.end()) {
                x_sum -= (long long)value * it->second;
                top_elements.erase(it);
            } else {
                rest_elements.erase(it);
            }
            positions.erase(value);

            if (top_elements.size() < x && !rest_elements.empty()) {
                auto max_rest = rest_elements.begin();
                top_elements.insert(*max_rest);
                positions[max_rest->first] = top_elements.find(*max_rest);
                x_sum += (long long)max_rest->first * max_rest->second;
                rest_elements.erase(max_rest);
            }
        };

        for (int i = 0; i < k; ++i) {
            int value = nums[i];
            freq[value]++;
            if (positions.count(value)) {
                remove_element(value);
            }
            insert_element(value);
        }

        answer.push_back(x_sum);

        for (int i = k; i < n; ++i) {
            int out_value = nums[i - k];
            int in_value = nums[i];

            remove_element(out_value);
            freq[out_value]--;
            if (freq[out_value] > 0) {
                insert_element(out_value);
            } else {
                freq.erase(out_value);
            }
            freq[in_value]++;
            if (positions.count(in_value)) {
                remove_element(in_value);
            }
            insert_element(in_value);

            answer.push_back(x_sum);
        }

        return answer;
    }
};
",1420578260
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3610,cpp,"class Solution {
public:
    struct Compare {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first; // Higher frequency first
        else
            return a.second > b.second; // Higher value first
    }
};
    vector<int> findXSum(vector<int>& nums, int k, int x) {
      int n = nums.size();
    vector<int> answer;

    unordered_map<int, int> freq; 
    multiset<pair<int, int>, Compare> ms; 
    unordered_map<int, multiset<pair<int, int>, Compare>::iterator> iterators;

    for (int i = 0; i < k; ++i) {
        int e = nums[i];
        if (freq.count(e)) {
            ms.erase(iterators[e]);
        }
        freq[e]++;
        auto it = ms.insert({freq[e], e});
        iterators[e] = it;
    }

    int cnt = 0;
    int sum = 0;
    for (auto it = ms.begin(); it != ms.end() && cnt < x; ++it) {
        sum += it->first * it->second;
        cnt++;
    }
    answer.push_back(sum);

    for (int i = 1; i <= n - k; ++i) {
        int out_elem = nums[i - 1]; 
        int in_elem = nums[i + k - 1]; 

        ms.erase(iterators[out_elem]);
        freq[out_elem]--;
        if (freq[out_elem] > 0) {
            auto it = ms.insert({freq[out_elem], out_elem});
            iterators[out_elem] = it;
        } else {
            freq.erase(out_elem);
            iterators.erase(out_elem);
        }

        if (freq.count(in_elem)) {
            ms.erase(iterators[in_elem]);
        }
        freq[in_elem]++;
        auto it = ms.insert({freq[in_elem], in_elem});
        iterators[in_elem] = it;

        cnt = 0;
        sum = 0;
        for (auto it = ms.begin(); it != ms.end() && cnt < x; ++it) {
            sum += it->first * it->second;
            cnt++;
        }
        answer.push_back(sum);
    }

    return answer;  
    }
};",1420521330
Rishikesh Anabathula,CutSandstone,74,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> sub;
    int[] dfs(TreeNode root){
        if(root == null) return new int[]{0,-1};
        int[] left = dfs(root.left), right = dfs(root.right);
        if(left == null || right == null) return null;
        if(left[1] == right[1] && left[0] == right[0]){
            sub.add(left[0]*2+1);
            return new int[]{left[0]*2+1,left[1]+1};
        }
        return null;
    }
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        sub = new ArrayList<>();
        dfs(root);
        Collections.sort(sub);
        return sub.size()<k ? -1:sub.get(sub.size()-k);
    }
}",1420566105
Rishikesh Anabathula,CutSandstone,74,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n][n*2+1][3];
        int mod = 1_000_000_007;
        String ord = ""FWE"";
        for(int i = 0; i<3; i++){
            int ind = ord.indexOf(s.charAt(0));
            int d = (i-ind+3)%3;
            if(d == 2) d = -1;
            dp[0][n+d][i] = 1;
        }
        for(int i = 1; i<n; i++){
            int ind = ord.indexOf(s.charAt(i));
            for(int j = 0; j<=n*2; j++){
                for(int k = 0; k<3; k++){
                    int d = (k-ind+3)%3;
                    if(d == 2) d = -1;
                    if(j-d >= 0 && j-d <= n*2)
                        dp[i][j][k] = (dp[i-1][j-d][(k+1)%3]+dp[i-1][j-d][(k+2)%3])%mod;
                }
            }
        }
        int ans = 0;
        for(int i = n+1; i<=n*2; i++)
            for(int j = 0; j<3; j++)
                ans = (ans+dp[n-1][i][j])%mod;
        return ans;
    }
}",1420578324
Rishikesh Anabathula,CutSandstone,74,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] ans = new long[n-k+1];
        TreeMap<Integer,Integer> low = new TreeMap<>();
        TreeMap<Integer,Integer> high = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fLow = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fHigh = new TreeMap<>();
        long sum = 0;
        for(int i = 0; i<n; i++){
            int c = low.getOrDefault(nums[i],0);
            if(c == 0){
                c = high.getOrDefault(nums[i],0);
                high.put(nums[i],c+1);
                sum+=nums[i];
                if(c != 0){
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i]);
                    if(get.size() == 0) fHigh.remove(c);
                }
                TreeSet<Integer> get = fHigh.get(c+1);
                if(get == null) fHigh.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }else{
                low.put(nums[i],c+1);
                TreeSet<Integer> get = fLow.get(c);
                get.remove(nums[i]);
                if(get.size() == 0) fLow.remove(c);
                get = fLow.get(c+1);
                if(get == null) fLow.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }
            if(i >= k){
                c = low.getOrDefault(nums[i-k],0);
                if(c != 0){
                    TreeSet<Integer> get = fLow.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fLow.remove(c);
                    if(c == 1) low.remove(nums[i-k]);
                    else{
                        low.put(nums[i-k],c-1);
                        get = fLow.get(c-1);
                        if(get == null) fLow.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }else{
                    c = high.get(nums[i-k]);
                    sum-=nums[i-k];
                    if(c == 1) high.remove(nums[i-k]);
                    else high.put(nums[i-k],c-1);
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fHigh.remove(c);
                    if(c != 1){
                        get = fHigh.get(c-1);
                        if(get == null) fHigh.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }
            }
            while(high.size() >= x){
                var e = fHigh.firstEntry();
                int r = e.getValue().first();
                sum-=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fHigh.remove(e.getKey());
                high.remove(r);
                low.put(r,e.getKey());
                TreeSet<Integer> get = fLow.get(e.getKey());
                if(get == null) fLow.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(high.size() < x && low.size() > 0){
                var e = fLow.lastEntry();
                int r = e.getValue().last();
                sum+=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fLow.remove(e.getKey());
                low.remove(r);
                high.put(r,e.getKey());
                TreeSet<Integer> get = fHigh.get(e.getKey());
                if(get == null) fHigh.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(i >= k-1) ans[i-k+1] = sum;
        }
        return ans;
    }
}",1420558281
Rishikesh Anabathula,CutSandstone,74,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n-k+1];
        TreeMap<Integer,Integer> low = new TreeMap<>();
        TreeMap<Integer,Integer> high = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fLow = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fHigh = new TreeMap<>();
        long sum = 0;
        for(int i = 0; i<n; i++){
            int c = low.getOrDefault(nums[i],0);
            if(c == 0){
                c = high.getOrDefault(nums[i],0);
                high.put(nums[i],c+1);
                sum+=nums[i];
                if(c != 0){
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i]);
                    if(get.size() == 0) fHigh.remove(c);
                }
                TreeSet<Integer> get = fHigh.get(c+1);
                if(get == null) fHigh.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }else{
                low.put(nums[i],c+1);
                TreeSet<Integer> get = fLow.get(c);
                get.remove(nums[i]);
                if(get.size() == 0) fLow.remove(c);
                get = fLow.get(c+1);
                if(get == null) fLow.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }
            if(i >= k){
                c = low.getOrDefault(nums[i-k],0);
                if(c != 0){
                    TreeSet<Integer> get = fLow.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fLow.remove(c);
                    if(c == 1) low.remove(nums[i-k]);
                    else{
                        low.put(nums[i-k],c-1);
                        get = fLow.get(c-1);
                        if(get == null) fLow.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }else{
                    c = high.get(nums[i-k]);
                    sum-=nums[i-k];
                    if(c == 1) high.remove(nums[i-k]);
                    else high.put(nums[i-k],c-1);
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fHigh.remove(c);
                    if(c != 1){
                        get = fHigh.get(c-1);
                        if(get == null) fHigh.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }
            }
            while(high.size() >= x){
                var e = fHigh.firstEntry();
                int r = e.getValue().first();
                sum-=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fHigh.remove(e.getKey());
                high.remove(r);
                low.put(r,e.getKey());
                TreeSet<Integer> get = fLow.get(e.getKey());
                if(get == null) fLow.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(high.size() < x && low.size() > 0){
                var e = fLow.lastEntry();
                int r = e.getValue().last();
                sum+=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fLow.remove(e.getKey());
                low.remove(r);
                high.put(r,e.getKey());
                TreeSet<Integer> get = fHigh.get(e.getKey());
                if(get == null) fHigh.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(i >= k-1) ans[i-k+1] = (int)sum;
        }
        return ans;
    }
}",1420559123
furuyarei,furuyarei,76,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<bool, int> dfs(TreeNode* u) {
        if (!u) {
            return {true, 0};
        }
        auto [tl, sl] = dfs(u->left);
        auto [tr, sr] = dfs(u->right);
        if (!tl || !tr) {
            return {false, 0};
        }
        if (sl == sr) {
            sz.push_back((1 << (sl + 1)) - 1);
            return {true, sl + 1};
        }
        return {false, 0};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sz.begin(), sz.end(), greater<int>());
        if (sz.size() >= k) {
            return sz[k - 1];
        }
        else {
            return -1;
        }
    }

private:
    vector<int> sz;
};",1420520010
furuyarei,furuyarei,76,3588,cpp,"int f[1010][2020][3];
int mod = 1000000007;
int shift = 1002;

class Solution {
public:
    int countWinningSequences(string s) {
        for (char& c: s) {
            if (c == 'F') {
                c = '0';
            }
            else if (c == 'W') {
                c = '1';
            }
            else {
                c = '2';
            }
        }
        
        auto check = [](char x, char y) -> int {
            if (x == y) {
                return 0;
            }
            if (x == '0') {
                return y == '2' ? 1 : -1;
            }
            if (x == '1') {
                return y == '0' ? 1 : -1;
            }
            return y == '1' ? 1 : -1;
        };
        
        int n = s.size();
        memset(f, 0, sizeof(f));
        
        f[1][check('0', s[0]) + shift][0] = 1;
        f[1][check('1', s[0]) + shift][1] = 1;
        f[1][check('2', s[0]) + shift][2] = 1;
        
        for (int i = 2; i <= n; ++i) {
            for (int j = -i; j <= i; ++j) {
                for (int k = 0; k < 3; ++k) {
                    int c = check(k + '0', s[i - 1]);
                    for (int kp = 0; kp < 3; ++kp) {
                        if (k == kp) {
                            continue;
                        }
                        if (j - c >= -(i - 1) && j - c <= i - 1) {
                            f[i][j + shift][k] = (f[i][j + shift][k] + f[i - 1][j - c + shift][kp]) % mod;
                        }
                    }
                }
            }
        }
        
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans = (ans + f[n][i + shift][0]) % mod;
            ans = (ans + f[n][i + shift][1]) % mod;
            ans = (ans + f[n][i + shift][2]) % mod;
        }
        return ans;
    }
};",1420545517
furuyarei,furuyarei,76,3592,cpp,"class DS {
public:
    DS(int t): top(t) {}
    
    void insert(int x) {
        if (freq.count(x)) {
            dd(x, freq[x]);
        }
        ++freq[x];
        ii(x, freq[x]);
        // cout << ""sum insert = "" << x << "" "" << get() << endl;
    }
    
    void remove(int x) {
        dd(x, freq[x]);
        --freq[x];
        if (freq[x]) {
            ii(x, freq[x]);
        }
        else {
            freq.erase(x);
        }
        // cout << ""sum remove = "" << x << "" "" << get() << endl;
    }
    
    long long get() {
        return sum;
    }

private:
    void ii(int x, int occ) {
        v.insert({occ, x});
        if (v.size() < top) {
            sum += (long long)x * occ;
        }
        else if (v.size() == top) {
            it = prev(v.end());
            sum += (long long)x * occ;
        }
        else if (v.size() > top) {
            if (better({occ, x}, *it)) {
                sum += (long long)x * occ;
                sum -= (long long)it->first * it->second;
                it = prev(it);
            }
        }
    }
    
    void dd(int x, int occ) {
        if (v.size() > top) {
            if (better({occ, x}, *it) || pair{occ, x} == *it) {
                it = next(it);
                sum -= (long long)x * occ;
                sum += (long long)it->first * it->second;
            }
        }
        else {
            sum -= (long long)x * occ;
        }
        v.erase({occ, x});
    }
    
    bool better(const pair<int, int>& u, const pair<int, int>& v) {
        return u > v;
    }

private:
    set<pair<int, int>, greater<pair<int, int>>> v;
    int top;
    unordered_map<int, int> freq;
    long long sum = 0;
    
    set<pair<int, int>, greater<pair<int, int>>>::iterator it;
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> ans;
        
        DS ds(x);
        for (int i = 0; i + 1 < k; ++i) {
            ds.insert(nums[i]);
        }
        
        for (int i = k - 1; i < n; ++i) {
            ds.insert(nums[i]);
            if (i >= k) {
                ds.remove(nums[i - k]);
            }
            ans.push_back(ds.get());
        }
        return ans;
    }
};",1420584587
furuyarei,furuyarei,76,3610,cpp,"class DS {
public:
    DS(int t): top(t) {}
    
    void insert(int x) {
        if (freq.count(x)) {
            dd(x, freq[x]);
        }
        ++freq[x];
        ii(x, freq[x]);
        // cout << ""sum insert = "" << x << "" "" << get() << endl;
    }
    
    void remove(int x) {
        dd(x, freq[x]);
        --freq[x];
        if (freq[x]) {
            ii(x, freq[x]);
        }
        else {
            freq.erase(x);
        }
        // cout << ""sum remove = "" << x << "" "" << get() << endl;
    }
    
    long long get() {
        return sum;
    }

private:
    void ii(int x, int occ) {
        v.insert({occ, x});
        if (v.size() < top) {
            sum += (long long)x * occ;
        }
        else if (v.size() == top) {
            it = prev(v.end());
            sum += (long long)x * occ;
        }
        else if (v.size() > top) {
            if (better({occ, x}, *it)) {
                sum += (long long)x * occ;
                sum -= (long long)it->first * it->second;
                it = prev(it);
            }
        }
    }
    
    void dd(int x, int occ) {
        if (v.size() > top) {
            if (better({occ, x}, *it) || pair{occ, x} == *it) {
                it = next(it);
                sum -= (long long)x * occ;
                sum += (long long)it->first * it->second;
            }
        }
        else {
            sum -= (long long)x * occ;
        }
        v.erase({occ, x});
    }
    
    bool better(const pair<int, int>& u, const pair<int, int>& v) {
        return u > v;
    }

private:
    set<pair<int, int>, greater<pair<int, int>>> v;
    int top;
    unordered_map<int, int> freq;
    long long sum = 0;
    
    set<pair<int, int>, greater<pair<int, int>>>::iterator it;
};

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        
        DS ds(x);
        for (int i = 0; i + 1 < k; ++i) {
            ds.insert(nums[i]);
        }
        
        for (int i = k - 1; i < n; ++i) {
            ds.insert(nums[i]);
            if (i >= k) {
                ds.remove(nums[i - k]);
            }
            ans.push_back(ds.get());
        }
        return ans;
    }
};",1420585110
Chuan-Chih Chou,chuan-chih,79,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        l = []
        def recur(node):
            if not node:
                return (True, 0)
            lperf, lsize = recur(node.left)
            rperf, rsize = recur(node.right)
            if lperf and rperf and lsize == rsize:
                size = 1 + lsize * 2
                l.append(size)
                return (True, size)
            else:
                return (False, -1)
        recur(root)
        l.sort(reverse=True)
        k -= 1
        if k < len(l):
            return l[k]
        return -1",1420526468
Chuan-Chih Chou,chuan-chih,79,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10 ** 9 + 7
        options = 'FEW'
        curr = {o: Counter() for o in options}
        if s[0] == 'F':
            curr['F'][0] += 1
            curr['E'][-1] += 1 
            curr['W'][1] += 1
        elif s[0] == 'E':
            curr['E'][0] += 1
            curr['W'][-1] += 1 
            curr['F'][1] += 1
        else:
            curr['W'][0] += 1
            curr['F'][-1] += 1 
            curr['E'][1] += 1
        for c in s[1:]:
            new = {o: Counter() for o in options}
            if c == 'F':
                new['F'] = curr['E'] + curr['W']
                for k, v in (curr['F'] + curr['W']).items():
                    new['E'][k - 1] = v % mod
                for k, v in (curr['F'] + curr['E']).items():
                    new['W'][k + 1] = v % mod
            elif c == 'E':
                new['E'] = curr['F'] + curr['W']
                for k, v in (curr['F'] + curr['E']).items():
                    new['W'][k - 1] = v % mod
                for k, v in (curr['E'] + curr['W']).items():
                    new['F'][k + 1] = v % mod
            else:
                new['W'] = curr['F'] + curr['E']
                for k, v in (curr['E'] + curr['W']).items():
                    new['F'][k - 1] = v % mod
                for k, v in (curr['F'] + curr['W']).items():
                    new['E'][k + 1] = v % mod
            curr = new
        return sum(v for c in curr.values() for k, v in c.items() if k > 0) % mod
            ",1420555345
Chuan-Chih Chou,chuan-chih,79,3592,python3,"from sortedcontainers import SortedSet

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        c = Counter(nums[:k])
        sl = SortedSet((v, k) for k, v in c.items())
        curr = sum(v * k for v, k in sl[-x:])
        ans.append(curr)
        
        def replace(old, new):
            nonlocal curr
            length = len(sl)
            if new[0]:
                index = sl.bisect_right(new)
                if index > length - x:
                    curr += new[0] * new[1]
                    if x <= length:
                        t = sl[-x]
                        curr -= t[0] * t[1]
                sl.add(new)
                length += 1
            if old[0]:
                index = sl.index(old)
                if index >= length - x:
                    curr -= old[0] * old[1]
                    if x + 1 <= length:
                        t = sl[-x-1]
                        curr += t[0] * t[1]
                sl.remove(old)
        
        for j in range(k, len(nums)):
            old = (c[nums[j]], nums[j])
            c[nums[j]] += 1
            new = (c[nums[j]], nums[j])
            replace(old, new)
            i = j - k
            old = (c[nums[i]], nums[i])
            c[nums[i]] -= 1
            new = (c[nums[i]], nums[i])
            replace(old, new)
            ans.append(curr)
        return ans",1420585544
Chuan-Chih Chou,chuan-chih,79,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        c = Counter(nums[:k])
        l = sorted(((v, k) for k, v in c.items()), reverse=True)
        ans.append(sum(v * k for v, k in l[:x]))
        for j in range(k, len(nums)):
            c[nums[j]] += 1
            c[nums[j - k]] -= 1
            l = sorted(((v, k) for k, v in c.items()), reverse=True)
            ans.append(sum(v * k for v, k in l[:x]))
        return ans",1420521573
Yatin Kwatra,yatin_kwatra,80,3509,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vii v;
class Solution {
public:

	ar<int, 2> ghumo(TreeNode *root) {
		if (!root) return {true, 0};
		auto L = ghumo(root->left);
		auto R = ghumo(root->right);

		if (!L[0] or !R[0] or L[1] != R[1]) return {false, 0};
		v.pb({L[1] + R[1] + 1});
		return {true, L[1] + R[1] + 1};
	}

	int kthLargestPerfectSubtree(TreeNode* root, int k) {
		v.clear();
		ghumo(root);
		sort(all(v), greater<int>());
		return (sz(v) >= k ? v[k - 1] : -1);
	}
};



















",1420524905
Yatin Kwatra,yatin_kwatra,80,3588,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

/*

	F > E
	W > F
	E > W

*/

ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

// F W E {0,1,2}

char moves[] = {'F', 'W', 'E'};

int gameScore(char a, char b) {
	if (a == b) return 0;
	if (a == 'F') {
		if (b == 'E') return 1;
		return -1;
	}
	if (a == 'W') {
		if (b == 'F') return 1;
		return -1;
	}
	if (b == 'W') return 1;
	return -1;
}

ll dp[3][1002][2002];
int n;

ll gino(int lastMove, int pos, int k, string &s) {
	if (pos == n) {
		return (k > 0);
	}
	ll &ans = dp[lastMove][pos][n + k];
	if (ans != -1) return ans;
	ans = 0;

	fo(i, 0, 2) {
		if (i == lastMove) continue;
		ans = addmod(ans, gino(i, pos + 1, k + gameScore(moves[i], s[pos]), s));
	}
	return ans;
}

class Solution {
public:
	int countWinningSequences(string s) {
		n = sz(s);
		fo(i, 0, n) {
			fo(j, 0, 2 * n) {
				fo(k, 0, 2) dp[k][i][j] = -1;
			}
		}

		ll ans = 0;
		fo(i, 0, 2) ans = addmod(ans, gino(i, 1, gameScore(moves[i], s[0]), s));
	    return ans;
    }
};



















",1420540045
Yatin Kwatra,yatin_kwatra,80,3592,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

int n;
class Solution {
public:
	vector<long long> findXSum(vector<int>& nums, int k, int x) {
		n = sz(nums);

		set<ar<int, 2>> xFrequent, potentialFrequent;

		uomii f;
		fo(i, 0, k - 1) {
			f[nums[i]]++;
		}
		vector<ar<int, 2>> v;
		for (auto &i : f) v.pb({i.ss, i.ff});
		sort(all(v));
		reverse(all(v));

		ll sum = 0;
		f.clear();

		uomii others;
        int upto = min(sz(v), k);
		fo(i, 0, upto - 1) {
			if (i < x) {
				f[v[i][1]] = v[i][0];
				xFrequent.insert(v[i]);
				sum += v[i][0] * 1LL * v[i][1];
			}
			else {
				potentialFrequent.insert(v[i]);
				others[v[i][1]] = v[i][0];
			}
		}

		vector<ll> ans;
		ans.pb(sum);

		fo(idx, k, n - 1) {
			int rm = nums[idx - k];
			int ad = nums[idx];

			if (f.count(ad)) {
				xFrequent.erase({f[ad], ad});
				f[ad]++;
				xFrequent.insert({f[ad], ad});
				sum += 1LL * ad;
			}
			else {
				if (others.count(ad)) potentialFrequent.erase({others[ad], ad});
				others[ad]++;
				potentialFrequent.insert({others[ad], ad});
			}

			if (f.count(rm)) {
				xFrequent.erase({f[rm], rm});
				f[rm]--;
				sum -= 1LL * rm;
				if (f[rm] == 0) {
					f.erase(rm);
				}
				else {
					xFrequent.insert({f[rm], rm});
				}
			}
			else {
				if (others.count(rm)) potentialFrequent.erase({others[rm], rm});
				others[rm]--;
				if (others[rm] == 0) others.erase(rm);
				else potentialFrequent.insert({others[rm], rm});
			}


			// rebalancing

			while (sz(xFrequent) < x and sz(potentialFrequent)) {
				auto bg = *(potentialFrequent.rbegin());
				sum += bg[0] * 1LL * bg[1];

				xFrequent.insert(bg);
				potentialFrequent.erase(bg);

				others.erase(bg[1]);
				f[bg[1]] = bg[0];
			}

			auto isBetter = [&](ar<int, 2> a, ar<int, 2 > b) -> bool {
				if (a[0] > b[0]) return true;
				if (a[0] < b[0]) return false;
				return a[1] > b[1];
			};

			while (sz(xFrequent) and sz(potentialFrequent) and
			        isBetter(*potentialFrequent.rbegin(), *xFrequent.begin())) {

				auto sm = *xFrequent.begin();

				xFrequent.erase(sm);
				potentialFrequent.insert(sm);

				others[sm[1]] = sm[0];
				f.erase(sm[1]);

				sum -= sm[0] * 1LL * sm[1];


				auto bg = *potentialFrequent.rbegin();

				potentialFrequent.erase(bg);
				xFrequent.insert(bg);

				f[bg[1]] = bg[0];
				others.erase(bg[1]);

				sum += bg[0] * 1LL * bg[1];
			}

			ans.pb(sum);
		}
		return ans;
	}
};",1420585665
Yatin Kwatra,yatin_kwatra,80,3610,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	vector<int> findXSum(vector<int>& nums, int k, int x) {

		vii ans;
		int n = sz(nums);

		fo(idx, k - 1, n - 1) {
			int a = idx - k + 1;
			int b = idx;
			uomii f;
			fo(i, a, b) f[nums[i]]++;

			vector<ar<int, 2>> v;
			for (auto &i : f) {
				v.pb({i.ss, i.ff});
			}
			sort(all(v));
			reverse(all(v));


			int upto = min(sz(v), x);
			int sum = 0;
			fo(i, 0, upto - 1) {
				sum += v[i][0] * v[i][1];
			}
			ans.pb(sum);
		}
		return ans;
	}
};




















",1420521457
Abhishek Srivastava,Abhi_Srivastava,81,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sizes;
    vector<int> isPerfect(TreeNode* root) {
        vector<int> lft, rght;
        if (root -> left == NULL && root -> right == NULL) {
            sizes.push_back(1);
            return {1, 0, 1};
        }
        if (root -> left)
            lft = isPerfect(root -> left);
        if (root -> right)
            rght = isPerfect(root -> right);
        if (root -> left == NULL || root -> right == NULL)
            return {0, 0, 0};
        if (lft[0] && rght[0] && (lft[1] == rght[1])) {
            sizes.push_back(lft[2] + rght[2] + 1);
            return {1, lft[1] + 1, lft[2] + rght[2] + 1};
        }
        else
            return {0, 0, 0};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        isPerfect(root);
        if (sizes.size() < k)
            return -1;
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k - 1];
    }
};",1420563102
Abhishek Srivastava,Abhi_Srivastava,81,3588,cpp,"const int mod = 1e9 + 7;
string moves = ""FWE"";

class Solution {
public:
    int calc(int ind, string& s, int lastMove, int bobWon, vector<vector<vector<long long>>>& dp) {
        if (ind == s.size())
            return (bobWon > s.size());
        if (dp[lastMove][ind][bobWon] != -1)   
            return dp[lastMove][ind][bobWon];
        long long res = 0;
        for (int i = 0; i < 3; i++)
            if (lastMove != i) {
                if ((moves[i] == 'F' && s[ind] == 'E') || (moves[i] == 'E' && s[ind] == 'W') || (moves[i] == 'W' && s[ind] == 'F'))
                    (res += calc(ind + 1, s, i, bobWon + 2, dp)) %= mod;
                else if ((moves[i] == 'F' && s[ind] == 'W') || (moves[i] == 'E' && s[ind] == 'F') || (moves[i] == 'W' && s[ind] == 'E'))
                    (res += calc(ind + 1, s, i, bobWon, dp)) %= mod;
                else
                    (res += calc(ind + 1, s, i, bobWon + 1, dp)) %= mod;
            }
        return dp[lastMove][ind][bobWon] = res;
    }
    int countWinningSequences(string s) {
        int n = s.size();
        vector<vector<vector<long long>>> dp(4, vector<vector<long long>>(n, vector<long long>(n * 2 + 1, -1)));
        return calc(0, s, 3, 0, dp);
    }
};",1420579705
Abhishek Srivastava,Abhi_Srivastava,81,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp> 
using namespace __gnu_pbds; 
typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

class Solution {
public:
    void removeFromSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (ost.order_of_key(pr) + x >= sz) {
            sum -= 1ll * pr.first * pr.second;
            if (sz > x) {              
                pair<int, int> tmp = *ost.find_by_order(sz - x - 1); 
                sum += 1ll * tmp.first * tmp.second;
            }
        }
        ost.erase(ost.find_by_order(ost.order_of_key(pr)));
    }
    void insertIntoSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (sz >= x) {
            pair<int, int> tmp = *ost.find_by_order(sz - x);
            if (tmp < pr)
                sum += 1ll * pr.first * pr.second - 1ll * tmp.first * tmp.second;
        }
        else
            sum += 1ll * pr.first * pr.second;
        ost.insert(pr);
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> res;
        unordered_map<int, int> freq;
        long long sum = 0;
        ordered_set ost;
        for (int i = 0; i < nums.size(); i++) {
            if (freq.find(nums[i]) != freq.end()) 
                removeFromSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            freq[nums[i]]++;
            insertIntoSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            if (i >= k) {
                removeFromSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                freq[nums[i - k]]--;
                if (freq[nums[i - k]])
                    insertIntoSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                else
                    freq.erase(nums[i - k]);
            }
            if (i >= k - 1)
                res.push_back(sum);
        }
        return res;
    }
};",1420552019
Abhishek Srivastava,Abhi_Srivastava,81,3610,cpp,"#include <ext/pb_ds/assoc_container.hpp> 
using namespace __gnu_pbds; 
typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

class Solution {
public:
    void removeFromSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (ost.order_of_key(pr) + x >= sz) {
            sum -= 1ll * pr.first * pr.second;
            if (sz > x) {              
                pair<int, int> tmp = *ost.find_by_order(sz - x - 1); 
                sum += 1ll * tmp.first * tmp.second;
            }
        }
        ost.erase(ost.find_by_order(ost.order_of_key(pr)));
    }
    void insertIntoSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (sz >= x) {
            pair<int, int> tmp = *ost.find_by_order(sz - x);
            if (tmp < pr)
                sum += 1ll * pr.first * pr.second - 1ll * tmp.first * tmp.second;
        }
        else
            sum += 1ll * pr.first * pr.second;
        ost.insert(pr);
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        unordered_map<int, int> freq;
        long long sum = 0;
        ordered_set ost;
        for (int i = 0; i < nums.size(); i++) {
            if (freq.find(nums[i]) != freq.end()) 
                removeFromSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            freq[nums[i]]++;
            insertIntoSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            if (i >= k) {
                removeFromSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                freq[nums[i - k]]--;
                if (freq[nums[i - k]])
                    insertIntoSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                else
                    freq.erase(nums[i - k]);
            }
            if (i >= k - 1)
                res.push_back(sum);
        }
        return res;
    }
};",1420552608
raincoat911,raincoat911,85,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> res;
        dfs(root, res);
        if (res.size() < k) return -1;
        sort(res.begin(), res.end(), greater<>());
        return res[k - 1];
    }
    
private:
    pair<bool, int> dfs(TreeNode* nd, vector<int>& res) {
        if (!nd) return {true, 0};
        auto l = dfs(nd->left, res);
        auto r = dfs(nd->right, res);
        if (l.first && r.first && l.second == r.second) {
            res.push_back(l.second * 2 + 1);
            return {true, res.back()};
        }
        return {false, 0};
    }
};",1420522628
raincoat911,raincoat911,85,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int l = s.size();
        vector<vector<array<long, 3>>> dp(l + 1, vector<array<long, 3>>(l * 2 + 1));
        dp[0][l][0] = dp[0][l][1] = dp[0][l][2] = 1;
        int M = 1e9 + 7;
        for (int i = 0; i < l; i++) {
            for (int k = -i; k <= i; k++) {
                if (i == 1) {
                    dp[i][k + l][0] >>= 1;
                    dp[i][k + l][1] >>= 1;
                    dp[i][k + l][2] >>= 1;
                }
                else {
                    dp[i][k + l][0] %= M;
                    dp[i][k + l][1] %= M;
                    dp[i][k + l][2] %= M;
                }
                dp[i + 1][k + l + (s[i] == 'F' ? 1 : s[i] == 'W' ? 0 : -1)][1] += dp[i][k + l][0];
                dp[i + 1][k + l + (s[i] == 'F' ? -1 : s[i] == 'W' ? 1 : 0)][2] += dp[i][k + l][0];
                dp[i + 1][k + l + (s[i] == 'F' ? 0 : s[i] == 'W' ? -1 : 1)][0] += dp[i][k + l][1];
                dp[i + 1][k + l + (s[i] == 'F' ? -1 : s[i] == 'W' ? 1 : 0)][2] += dp[i][k + l][1];
                dp[i + 1][k + l + (s[i] == 'F' ? 0 : s[i] == 'W' ? -1 : 1)][0] += dp[i][k + l][2];
                dp[i + 1][k + l + (s[i] == 'F' ? 1 : s[i] == 'W' ? 0 : -1)][1] += dp[i][k + l][2];
            }
        }
        long res = 0;
        for (int k = 1; k <= l; k++) {
            if (s.size() == 1) {
                dp.back()[k + l][0] >>= 1;
                dp.back()[k + l][1] >>= 1;
                dp.back()[k + l][2] >>= 1;
            }
            res += dp.back()[k + l][0] + dp.back()[k + l][1] + dp.back()[k + l][2];
            res %= M;
        }
        // cout << endl;
        return res;
    }
};",1420549144
raincoat911,raincoat911,85,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pair<int, int>, greater<>> lo;
        set<pair<int, int>> hi;
        unordered_map<int, int> m;
        long sh = 0;
        vector<long long> res;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= k) {
                int n = nums[i - k];
                int f = m[n]--;
                pair<int, int> p = {f - 1, n};
                
                auto it = hi.find({f, n});
                if (it == hi.end()) {
                    it = lo.find({f, n});
                    lo.erase(it);
                    if (f > 1) lo.insert(p);
                }
                else {
                    sh -= (long)it->first * it->second; 
                    hi.erase(it);
                    if (lo.empty()) {
                        if (f > 1) {
                            sh += (long)p.first * p.second;
                            hi.insert(p);
                        }
                    }
                    else {
                        it = lo.begin();
                        if (*it > p) {
                            sh += (long)it->first * it->second; 
                            hi.insert(*it);
                            lo.erase(it);
                            if (f > 1) lo.insert(p);
                        }
                        else {
                            if (f > 1) {
                                sh += (long)p.first * p.second;
                                hi.insert(p);
                            }
                        }
                    }
                    
                }
            }
            int n = nums[i];
            int f = m[n]++;
            pair<int, int> p = {f + 1, n};
            if (f > 0) {
                auto it = hi.find({f, n});
                if (it == hi.end()) {
                    it = lo.find({f, n});
                    lo.erase(it);
                    auto it = hi.begin();
                    if (*it < p) {
                        sh += (long)p.first * p.second;
                        sh -= (long)it->first * it->second;
                        hi.insert(p);
                        lo.insert(*it);
                        hi.erase(it);
                    }
                    else {
                        lo.insert(p);
                    }
                }
                else {
                    sh += (long)p.first * p.second;
                    sh -= (long)it->first * it->second;
                    hi.erase(it);
                    hi.insert(p);
                }
            }
            else {
                if (hi.size() < x) {
                    sh += (long)p.first * p.second;
                    hi.insert(p);
                }
                else {
                    auto it = hi.begin();
                    if (*it < p) {
                        sh += (long)p.first * p.second;
                        sh -= (long)it->first * it->second;
                        hi.insert(p);
                        lo.insert(*it);
                        hi.erase(it);
                    }
                    else {
                        lo.insert(p);
                    }
                }
            }
            if (i >= k - 1) res.push_back(sh);
        }
        // cout << sh << endl;
        return res;
    }
};",1420574684
raincoat911,raincoat911,85,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        for (int i = 0; i <= nums.size() - k; i++) {
            unordered_map<int, int> m;
            for (int j = i; j < i + k; j++) {
                m[nums[j]]++;
            }
            vector<array<int, 2>> arr;
            for (auto& p : m) {
                arr.push_back({p.second, p.first});
            }
            sort(arr.begin(), arr.end(), greater<>());
            arr.resize(x);
            int n = 0;
            for (auto& p : arr) {
                n += p[0] * p[1];
            }
            res.push_back(n);
        }
        return res;
    }
};",1420520013
ocavue,ocavue,87,3509,python3,"from typing import List, Optional


 
def merge_sort(arr1: List[int], arr2: List[int]) -> List[int]:
    result = []
    i = j = 0

    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1

    while i < len(arr1):
        result.append(arr1[i])
        i += 1

    while j < len(arr2):
        result.append(arr2[j])
        j += 1

    return result


def dfs(node: Optional[TreeNode]):
    if not node:
        return 0, []

    if not node.left and not node.right:
        return 1, [1]

    left_tree_size, left_subtree = dfs(node.left)
    right_tree_size, right_subtree = dfs(node.right)

    result = merge_sort(left_subtree, right_subtree)

    if left_tree_size == right_tree_size and left_tree_size != -1:
        tree_size = left_tree_size + right_tree_size + 1
        result.append(tree_size)
    else:
        tree_size = -1

    return tree_size, result


class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        result = dfs(root)[1]
        result.reverse()

        index = k - 1

        if index < len(result):
            return result[index]

        return -1
",1420532323
ocavue,ocavue,87,3588,python3,"from functools import cache


MOD = 10**9 + 7


@cache 
def get_score(my_char: str, other_char: str) -> int:
    if my_char == other_char:
        return 0

    if my_char == ""W"":
        return 1 if other_char == ""F"" else -1

    if my_char == ""F"":
        return 1 if other_char == ""E"" else -1

    return 1 if other_char == ""W"" else -1


class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)

        @cache
        def dfs(index: int, prev_char: str, prev_score: int) -> int:
            if index == n:
                return 1 if prev_score > 0 else 0

            other_char = s[index]

            result = 0

            for my_char in ""FWE"":
                score = get_score(my_char, other_char)

                if my_char != prev_char:
                    result += dfs(index + 1, my_char, prev_score + score)
            return result % MOD

        return dfs(0, """", 0) % MOD
",1420545408
ocavue,ocavue,87,3592,python3,"from typing import List
from collections import Counter
import sortedcontainers


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        n = len(nums)
        counter = Counter()
        top = sortedcontainers.SortedSet()
        btm = sortedcontainers.SortedSet()

        x_sum = 0

        def add_top_key(key):
            nonlocal x_sum
            top.add(key)
            x_sum += key[1] * key[0]

        def del_top_key(key):
            nonlocal x_sum
            top.remove(key)
            x_sum -= key[1] * key[0]

        def add_btm_key(key):
            btm.add(key)

        def del_btm_key(key):
            btm.remove(key)

        def move_key_from_top_to_btm(key):
            del_top_key(key)
            add_btm_key(key)

        def move_key_from_btm_to_top(key):
            del_btm_key(key)
            add_top_key(key)

        def maintain_balance():
            while len(top) < x and btm:
                key = btm.pop(-1)
                add_top_key(key)

            while top and btm and top[0] < btm[-1]:
                top_key = top[0]
                btm_key = btm[-1]
                move_key_from_top_to_btm(top_key)
                move_key_from_btm_to_top(btm_key)

        def add_key(key):
            btm.add(key)
            maintain_balance()

        def remove_key(key):
            if key in top:
                del_top_key(key)
            elif key in btm:
                del_btm_key(key)
            maintain_balance()

        def increase_num_count(num):
            prev_count = counter[num]
            prev_key = (prev_count, num)
            if prev_count > 0:
                remove_key(prev_key)

            new_count = prev_count + 1
            new_key = (new_count, num)
            add_key(new_key)

            counter[num] += 1

        def decrease_num_count(num):
            prev_count = counter[num]
            prev_key = (prev_count, num)
            remove_key(prev_key)

            new_count = prev_count - 1
            new_key = (new_count, num)
            if new_count > 0:
                add_key(new_key)

            counter[num] -= 1

        answer = []

        i = 0
        j = 0

        while j < n:
            increase_num_count(nums[j])
            j += 1

            while j - i > k:
                decrease_num_count(nums[i])
                i += 1

            if j - i == k:
                answer.append(x_sum)

        return answer

 ",1420580817
ocavue,ocavue,87,3610,python3,"from typing import List
from collections import Counter
import heapq


def calc_x_sum(nums: List[int], x: int) -> int:
    counter = Counter(nums)
    heap = [(-freq, -num) for num, freq in counter.items()]
    heapq.heapify(heap)

    result = 0

    while x > 0 and heap:
        freq, num = heapq.heappop(heap)
        result += freq * num
        x -= 1

    return result


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        n = len(nums)

        for i in range(n - k + 1):
            result.append(calc_x_sum(nums[i : i + k], x))

        return result

 ",1420521736
Ritesh baindara,RITESH_25,88,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> a;
    int dfs(TreeNode* root){
        if(!root)
        return 0;
        int ans = 1;
        int left = dfs(root->left);
        int right = dfs(root->right);
        if(left==right && left!=-1 && right!=-1)
        ans +=left+right;
        else
        ans = -1;
        if(ans!=-1)
        a.push_back(ans);
        // cout<<root->val<<"" ""<<ans<<endl;
        return ans;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
    dfs(root);
    sort(a.begin(),a.end(),greater<int>());
     if(a.size()>=k)    
     return a[k-1];
     else
     return -1;
    }
};",1420536057
Saketh,fj26ZKcNjz,1,3509,cpp,"#include <vector>
#include <algorithm>
using namespace std;

// Definition for a binary tree node.
// (Assumed to be already defined by the platform, e.g., LeetCode)
// struct TreeNode {
//     int val;
//     TreeNode *left;
//     TreeNode *right;
//     TreeNode() : val(0), left(nullptr), right(nullptr) {}
//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
// };

class Solution {
public:
    vector<int> perfectSizes;
    
    pair<int, bool> dfs(TreeNode* node) {
        if (!node) {
            return {0, true};
        }
        
        pair<int, bool> left = dfs(node->left);
        pair<int, bool> right = dfs(node->right);
        
        if (left.second && right.second && left.first == right.first) {
            int currentHeight = left.first + 1;
            int size = (1 << currentHeight) - 1;
            perfectSizes.push_back(size);
            return {currentHeight, true};
        }
        
        return {max(left.first, right.first) + 1, false};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        perfectSizes.clear();
        dfs(root);
        
        if (perfectSizes.empty()) return -1;
        
        sort(perfectSizes.begin(), perfectSizes.end(), [&](const int a, const int b) -> bool {
            return a > b;
        });
        
        if (k > perfectSizes.size()) return -1;
        
        return perfectSizes[k-1];
    }
};
",1420519729
Saketh,fj26ZKcNjz,1,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        string lufrenixaq = s; 
        int dp[2][4][2001]; 
        memset(dp, 0, sizeof(dp));
        int curr = 0, next = 1;
        dp[curr][3][n] = 1; 
        for (int pos = 0; pos < n; ++pos) {
            memset(dp[next], 0, sizeof(dp[next]));
            for (int bob_prev_move = 0; bob_prev_move <= 3; ++bob_prev_move) {
                for (int scoreDiff = -n; scoreDiff <= n; ++scoreDiff) {
                    int dpVal = dp[curr][bob_prev_move][scoreDiff + n];
                    if (dpVal == 0) continue;
                    for (int bob_move = 0; bob_move <= 2; ++bob_move) {
                        if (pos > 0 && bob_prev_move != 3 && bob_move == bob_prev_move)
                            continue; 
                        int a_move = 0;
                        if (lufrenixaq[pos] == 'F') a_move = 0;
                        else if (lufrenixaq[pos] == 'W') a_move = 1;
                        else if (lufrenixaq[pos] == 'E') a_move = 2;
                        int res = 0;
                        if (a_move == bob_move) res = 0;
                        else if ((bob_move - a_move + 3) % 3 == 1) res = +1; 
                        else res = -1; 
                        int newScoreDiff = scoreDiff + res;
                        dp[next][bob_move][newScoreDiff + n] = (dp[next][bob_move][newScoreDiff + n] + dpVal) % MOD;
                    }
                }
            }
            swap(curr, next);
        }
        int ans = 0;
        for (int bob_prev_move = 0; bob_prev_move <= 2; ++bob_prev_move) {
            for (int scoreDiff = 1; scoreDiff <= n; ++scoreDiff) {
                ans = (ans + dp[curr][bob_prev_move][scoreDiff + n]) % MOD;
            }
        }
        return ans;
    }
};
",1420523759
Saketh,fj26ZKcNjz,1,3592,cpp,"#include <bits/stdc++.h>
using namespace std;

struct cmp_asc {
    bool operator() (const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first < b.first;
        return a.second < b.second;
    }
};

struct cmp_desc {
    bool operator() (const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first;
        return a.second > b.second;
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        if (n < k) return answer;

        vector<int> torsalveno = nums;

        unordered_map<int, int> freq_map;

        for(int i =0; i <k; i++) {
            freq_map[nums[i]]++;
        }

        vector<pair<int, int>> elements;
        for(auto &p: freq_map){
            elements.emplace_back(make_pair(p.second, p.first));
        }

        sort(elements.begin(), elements.end(), [&](const pair<int,int> &a, const pair<int,int> &b) -> bool{
            if(a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });

        set<pair<int, int>, cmp_asc> top_x;
        set<pair<int, int>, cmp_desc> rest;

        int count =0;
        long long sum_top_x =0;
        for(auto &p: elements){
            if(count < x){
                top_x.insert(p);
                sum_top_x += (long long)p.first * p.second;
                count++;
            }
            else{
                rest.insert(p);
            }
        }

        answer.push_back(sum_top_x);

        for(int i =1; i <= n -k; i++){
            int remove_val = nums[i-1];
            int prev_freq = freq_map[remove_val];
            freq_map[remove_val]--;

            pair<int, int> current_pair = make_pair(prev_freq, remove_val);

            auto it_top = top_x.find(current_pair);
            if(it_top != top_x.end()){
                top_x.erase(it_top);
                sum_top_x -= (long long)prev_freq * remove_val;

                if(freq_map[remove_val] >0){
                    pair<int, int> updated_pair = make_pair(freq_map[remove_val], remove_val);
                    rest.insert(updated_pair);
                }

                if(!rest.empty()){
                    auto it_rest = rest.begin(); 
                    pair<int, int> best_rest = *it_rest;
                    rest.erase(it_rest);
                    top_x.insert(best_rest);
                    sum_top_x += (long long)best_rest.first * best_rest.second;
                }
            }
            else{
                pair<int, int> updated_pair;
                if(prev_freq >0){
                    rest.erase(current_pair);
                }
                if(freq_map[remove_val] >0){
                    updated_pair = make_pair(freq_map[remove_val], remove_val);
                    rest.insert(updated_pair);
                }
            }

            int add_val = nums[i +k -1];
            int prev_freq_add = freq_map[add_val];
            freq_map[add_val]++;

            pair<int, int> before_add_pair = make_pair(prev_freq_add, add_val);

            pair<int, int> after_add_pair = make_pair(freq_map[add_val], add_val);

            bool was_in_top = false;
            if(prev_freq_add >0){
                auto it_top_add = top_x.find(before_add_pair);
                if(it_top_add != top_x.end()){
                    was_in_top = true;
                    top_x.erase(it_top_add);
                    sum_top_x -= (long long)before_add_pair.first * before_add_pair.second;
                }
                else{
                    auto it_rest_add = rest.find(before_add_pair);
                    if(it_rest_add != rest.end()){
                        rest.erase(it_rest_add);
                    }
                }
            }

            if(top_x.size() < x){
                top_x.insert(after_add_pair);
                sum_top_x += (long long)after_add_pair.first * after_add_pair.second;
            }
            else{
                auto it_smallest = top_x.begin(); 
                pair<int, int> smallest = *it_smallest;
                if(after_add_pair.first > smallest.first || 
                   (after_add_pair.first == smallest.first && after_add_pair.second > smallest.second)){
                    top_x.erase(it_smallest);
                    sum_top_x -= (long long)smallest.first * smallest.second;
                    top_x.insert(after_add_pair);
                    sum_top_x += (long long)after_add_pair.first * after_add_pair.second;
                    rest.insert(smallest);
                }
                else{
                    rest.insert(after_add_pair);
                }
            }

            if(was_in_top && freq_map[add_val] >0){
            
            }

            answer.push_back(sum_top_x);
        }

        return answer;
    }
};
",1420527328
Saketh,fj26ZKcNjz,1,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>
#include <set>
using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        
        for(int i = 0; i <= n - k; ++i){
            int freq[51] = {0};
            for(int j = i; j < i + k; ++j){
                freq[nums[j]]++;
            }
            
            vector<pair<int, int>> elements; 
            for(int num =1; num <=50; ++num){
                if(freq[num] >0){
                    elements.emplace_back(make_pair(freq[num], num));
                }
            }
            
            sort(elements.begin(), elements.end(), [&](const pair<int,int> &a, const pair<int,int> &b) -> bool{
                if(a.first != b.first){
                    return a.first > b.first;
                }
                return a.second > b.second;
            });
            
            set<int> topX;
            int distinct = elements.size();
            int limit = min(x, distinct);
            for(int m =0; m < limit; ++m){
                topX.insert(elements[m].second);
            }
            
            int sum =0;
            for(int j =i; j < i +k; ++j){
                if(topX.find(nums[j]) != topX.end()){
                    sum += nums[j];
                }
            }
            
            answer.push_back(sum);
        }
        
        return answer;
    }
};
",1420518520
cuy21,cuy21,2,3509,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution{
public:
    vector<int> p;

    struct Info{
        bool p;
        int h,s;
    };

    Info t(TreeNode*n){
        if(!n)return{true,0,0};
        auto L=t(n->left),R=t(n->right);
        bool ip=L.p&&R.p&&(L.h==R.h);
        int ht=max(L.h,R.h)+1,sz=L.s+R.s+1;
        if(ip)p.PB(sz);
        return{ip,ht,sz};
    }

    int kthLargestPerfectSubtree(TreeNode*r,int k){
        p.clear();
        t(r);
        if(p.empty())return-1;
        sort(p.begin(),p.end(),greater<int>());
        return k<=p.size()?p[k-1]:-1;
    }
};",1420537027
cuy21,cuy21,2,3588,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution {
public:
    int countWinningSequences(string s) {
        int n=s.length();
        string x=s;
        const int M=1'000'000'007;
        unordered_map<char,int> m={{'F',0},{'W',1},{'E',2}};
        int b[3]={2,0,1};
        vector<vector<long long>> cur(4,vector<long long>(2*n+1,0));
        cur[3][n]=1;
        FOR(i,0,n){
            vector<vector<long long>> nxt(4,vector<long long>(2*n+1,0));
            char a=s[i];
            int ai=m[a];
            FOR(l,0,4){
                FOR(d,0,2*n+1){
                    if(cur[l][d]==0)continue;
                    FOR(bb,0,3){
                        if(l!=3&&bb==l)continue;
                        int o=(b[bb]==ai)?1:((b[ai]==bb)?-1:0);
                        int nd=d+o;
                        if(nd<0||nd>2*n)continue;
                        nxt[bb][nd]=(nxt[bb][nd]+cur[l][d])%M;
                    }
                }
            }
            cur=move(nxt);
        }
        long long res=0;
        FOR(l,0,3){
            FOR(d,n+1,2*n+1)res=(res+cur[l][d])%M;
        }
        return (int)res;
    }

    vector<vector<long long>> move(vector<vector<long long>>&nxt){
        return nxt;
    }
};",1420528165
cuy21,cuy21,2,3592,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
struct cmp{
    bool operator()(const pi&a,const pi&b)const{
        if(a.F!=b.F)return a.F>b.F;
        return a.S>b.S;
    }
};

class Solution{
public:
    vll findXSum(vi&n,int k,int x){
        int sz=n.size(),t=k;
        vll a;
        if(sz<k)return a;
        unordered_map<int,int> f;
        FOR(i,0,k)f[n[i]]++;
        vector<pi> fl;
        FORE(p,f)fl.PB({p.S,p.F});
        sort(fl.begin(),fl.end(),cmp());
        set<pi,cmp> tp,rs;
        ll s=0;
        FOR(i,0,fl.size()){
            if(i<x){
                tp.insert(fl[i]);
                s+=(ll)fl[i].F*fl[i].S;
            }else rs.insert(fl[i]);
        }
        a.PB(s);
        FOR(i,k,sz){
            int o=n[i-k],in=n[i];
            int pf=f[o];
            pi op={pf,o};
            bool wt=false;
            auto t=tp.find(op);
            if(t!=tp.end()){
                wt=true;
                tp.erase(t);
                s-=(ll)op.F*op.S;
            }else{
                auto r=rs.find(op);
                if(r!=rs.end())rs.erase(r);
            }
            f[o]--;
            if(f[o]==0)f.erase(o);
            else rs.insert({f[o],o});
            if(wt&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }
            if(f.find(in)!=f.end()){
                int cf=f[in];
                pi cp={cf,in};
                auto t2=tp.find(cp);
                if(t2!=tp.end()){
                    tp.erase(t2);
                    s-=(ll)cp.F*cp.S;
                    f[in]++;
                    tp.insert({f[in],in});
                    s+=(ll)f[in]*in;
                }else{
                    auto r2=rs.find(cp);
                    if(r2!=rs.end())rs.erase(r2);
                    f[in]++;
                    rs.insert({f[in],in});
                }
            }else{
                f[in]=1;
                rs.insert({1,in});
            }
            if(tp.size()<(size_t)x&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }else if(!rs.empty()){
                auto t3=prev(tp.end());
                auto r3=rs.begin();
                if(cmp()(*r3,*t3)){
                    s+=(ll)r3->F*r3->S;
                    tp.insert(*r3);
                    rs.erase(r3);
                    s-=(ll)t3->F*t3->S;
                    rs.insert(*t3);
                    tp.erase(t3);
                }
            }
            a.PB(s);
        }
        return a;
    }
};",1420533176
cuy21,cuy21,2,3610,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
struct cmp{
    bool operator()(const pi&a,const pi&b)const{
        if(a.F!=b.F)return a.F>b.F;
        return a.S>b.S;
    }
};

class Solution{
public:
    vi findXSum(vi&n,int k,int x){
        int sz=n.size(),t=k;
        vi a;
        if(sz<k)return a;
        unordered_map<int,int> f;
        FOR(i,0,k)f[n[i]]++;
        vector<pi> fl;
        FORE(p,f)fl.PB({p.S,p.F});
        sort(fl.begin(),fl.end(),cmp());
        set<pi,cmp> tp,rs;
        ll s=0;
        FOR(i,0,fl.size()){
            if(i<x){
                tp.insert(fl[i]);
                s+=(ll)fl[i].F*fl[i].S;
            }else rs.insert(fl[i]);
        }
        a.PB(s);
        FOR(i,k,sz){
            int o=n[i-k],in=n[i];
            int pf=f[o];
            pi op={pf,o};
            bool wt=false;
            auto t=tp.find(op);
            if(t!=tp.end()){
                wt=true;
                tp.erase(t);
                s-=(ll)op.F*op.S;
            }else{
                auto r=rs.find(op);
                if(r!=rs.end())rs.erase(r);
            }
            f[o]--;
            if(f[o]==0)f.erase(o);
            else rs.insert({f[o],o});
            if(wt&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }
            if(f.find(in)!=f.end()){
                int cf=f[in];
                pi cp={cf,in};
                auto t2=tp.find(cp);
                if(t2!=tp.end()){
                    tp.erase(t2);
                    s-=(ll)cp.F*cp.S;
                    f[in]++;
                    tp.insert({f[in],in});
                    s+=(ll)f[in]*in;
                }else{
                    auto r2=rs.find(cp);
                    if(r2!=rs.end())rs.erase(r2);
                    f[in]++;
                    rs.insert({f[in],in});
                }
            }else{
                f[in]=1;
                rs.insert({1,in});
            }
            if(tp.size()<(size_t)x&&!rs.empty()){
                auto p=rs.begin();
                tp.insert(*p);
                s+=(ll)p->F*p->S;
                rs.erase(p);
            }else if(!rs.empty()){
                auto t3=prev(tp.end());
                auto r3=rs.begin();
                if(cmp()(*r3,*t3)){
                    s+=(ll)r3->F*r3->S;
                    tp.insert(*r3);
                    rs.erase(r3);
                    s-=(ll)t3->F*t3->S;
                    rs.insert(*t3);
                    tp.erase(t3);
                }
            }
            a.PB(s);
        }
        return a;
    }
};",1420535149
Shreyan Ray,Dominater069L,4,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        map <int, int> f;
        map <TreeNode*, int> sz;
        
        auto dfs = [&](auto self, TreeNode* u) -> bool {
            sz[u] = 1;
            bool good = true;
            if (u->left != nullptr){
                good &= self(self, u->left);
                sz[u] += sz[u->left];
            } 
            if (u->right != nullptr){
                good &= self(self, u->right);
                sz[u] += sz[u->right];
            }
            
            if ((u->left != nullptr) != (u->right != nullptr)){
                good = false;
            }
            
            if ((u -> left != nullptr) && (u->right != nullptr) && sz[u->left] != sz[u->right]){
                good = false;
            }
            
            if (good){
                f[-sz[u]] += 1;
                
              //  cout << ""GOOD "" << sz[u] << ""\n"";
            }
            return good;
        };
        
        dfs(dfs, root);
      //  cout << ""DONE\n"";
        
        int curr = 0;
        for (auto [x, y] : f){
            if (y + curr >= k){
                return -x;
            }
            curr += y;
        }
        
        return -1;
    }
};",1420537657
Shreyan Ray,Dominater069L,4,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        
        auto win = [&](int x, char ch){
            int y;
            if (ch == 'F'){
                y = 0;
            } else if (ch == 'W'){
                y = 1;
            } else {
                y = 2;
            }
            
            if (x == y) return 0;
            if ((x == 0 && y == 2) || (x == 1 && y == 0 ) || (x == 2 && y == 1)){
                return 1;
            }
            return -1;
        };
        
        const int mod = 1e9 + 7;
        
        vector <vector<int>> dp(2 * n + 1, vector<int>(3, 0));
        for (int i = 0; i < 3; i++){
            dp[n + win(i, s[0])][i] = 1;
        }
        
        for (int i = 1; i < n; i++){
            vector <vector<int>> ndp(2 * n + 1, vector<int>(3, 0));
            for (int j = 0; j <= 2 * n; j++){
                for (int k = 0; k < 3; k++){
                    if (dp[j][k] != 0){
                        for (int l = 0; l < 3; l++) if (l != k){
                            ndp[j + win(l, s[i])][l] += dp[j][k];
                            ndp[j + win(l, s[i])][l] %= mod;
                        }
                    }
                }
            }
            
            dp = ndp;
        }
        
        int ans = 0;
        for (int i = n + 1; i <= 2 * n; i++){
            for (int j = 0; j < 3; j++){
                ans += dp[i][j];
                ans %= mod;
            }
        }
        
        return ans;
    }
};",1420540799
Shreyan Ray,Dominater069L,4,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector <long long> ans;
        int n = nums.size();
        map <int, long long> f;
        long long sum = 0;
        set <pair<long long, int>> s1, s2;
        
        auto fix = [&](){
            while (s1.size() > x){
                auto id = *s1.begin();
                s1.erase(id);
                sum -= id.first * id.second;
                s2.insert(id);
            }  
            
            while (s1.size() && s2.size()){
                auto id1 = *(--s2.end());
                auto id2 = *(s1.begin());
                if (id1 > id2){
                    sum -= id2.first * id2.second;
                    s2.erase(id1);
                    s1.erase(id2);
                    s1.insert(id1);
                    s2.insert(id2);
                    sum += id1.first * id1.second;
                } else {
                    break;
                }
            }
        };
        
        auto add = [&](int x){
            if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]++;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        auto era = [&](int x){
              if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]--;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        for (int i = 0; i < k; i++){
            add(nums[i]);
        }
        
        ans.push_back(sum);
        // return ans;
        for (int i = k; i < n; i++){
            add(nums[i]);
            era(nums[i - k]);
            ans.push_back(sum);
        }
        return ans;
    }
};",1420527493
Shreyan Ray,Dominater069L,4,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector <long long> ans;
        int n = nums.size();
        map <int, long long> f;
        long long sum = 0;
        set <pair<long long, int>> s1, s2;
        
        auto fix = [&](){
            while (s1.size() > x){
                auto id = *s1.begin();
                s1.erase(id);
                sum -= id.first * id.second;
                s2.insert(id);
            }  
            
            while (s1.size() && s2.size()){
                auto id1 = *(--s2.end());
                auto id2 = *(s1.begin());
                if (id1 > id2){
                    sum -= id2.first * id2.second;
                    s2.erase(id1);
                    s1.erase(id2);
                    s1.insert(id1);
                    s2.insert(id2);
                    sum += id1.first * id1.second;
                } else {
                    break;
                }
            }
        };
        
        auto add = [&](int x){
            if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]++;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        auto era = [&](int x){
              if (s1.find({f[x], x}) != s1.end()){
                sum -= f[x] * x;
            }
            s1.erase({f[x], x});
            s2.erase({f[x], x});
            f[x]--;
            s1.insert({f[x], x});
            sum += f[x] * x;
            
            fix();
        };
        
        for (int i = 0; i < k; i++){
            add(nums[i]);
        }
        
        ans.push_back(sum);
        // return ans;
        for (int i = k; i < n; i++){
            add(nums[i]);
            era(nums[i - k]);
            ans.push_back(sum);
        }
        vector <int> ans2;
        for (auto x : ans) ans2.push_back(x);
        return ans2;
    }
};",1420528313
Anas_Maged,Anas_Maged,5,3509,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> a;
        auto dfs = [&](auto& self, TreeNode* node) -> pair<int, int>{
            if(node == nullptr) return {1, 0};
            bool ok = 1;
            auto f = self(self, node->left);
            auto s = self(self, node->right);
            ok &= f.first; ok &= s.first;
            int cnt = 1 + f.second + s.second;
            if(f.second != s.second) ok = 0;
            if(ok) a.push_back(cnt);
            return {ok, cnt};
        };
        dfs(dfs, root);
        sort(all(a), greater<int>());
        if(k > sz(a)) return -1;
        return a[--k];
    }
};",1420522089
Anas_Maged,Anas_Maged,5,3588,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


const int N = 1e3 + 5, M = 1e9 + 7;
int add(int a, int b){
    return (a + b) % M;
}
int mul(int a, int b){
    return 1ll * a * b % M;
}
string a = ""FEW$"";
string b = ""EWF$"";
int dp[N][N * 2][4], vis[N][N * 2][4], vid;

int rec(int i, int cur, int last, string& s){
    if(i == sz(s)) return cur > 0;
    int &ret = dp[i][cur + N][last];
    if(vis[i][cur + N][last] == vid) return ret;
    vis[i][cur + N][last] = vid;
    ret = 0;
    for(int j = 0; j < 3; j++){
        if(j == last) continue;
        int cost = 0;
        if(b[j] == s[i]) cost = 1;
        else if(s[i] == 'F' && a[j] == 'E') cost = -1;
        else if(s[i] == 'E' && a[j] == 'W') cost = -1;
        else if(s[i] == 'W' && a[j] == 'F') cost = -1;
        else if(s[i] != a[j]) assert(0);
        ret = add(ret, rec(i + 1, cur + cost, j, s));
    }
    return ret;
}

class Solution {
public:
    int countWinningSequences(string s) {
        vid++;
        return rec(0, 0, 3, s);
    }
};",1420531226
Anas_Maged,Anas_Maged,5,3592,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        map<int, int> mp;
        set<pair<int, int>> free, use;
        for(int i = 0; i < k; i++){
            mp[a[i]]++;
        }
        for(auto& [k, v] : mp){
            free.insert({v, k});
        }

        ll sum = 0;
        auto fix = [&](){
            while(sz(use) < x && !free.empty()){
                sum += 1ll * (*free.rbegin()).first * (*free.rbegin()).second;
                use.insert(*free.rbegin());
                free.erase(--free.end());
            }
            while(!free.empty() && !use.empty()){
                if(*use.begin() >= *free.rbegin()) break;
                auto x = *use.begin();
                auto y = *free.rbegin();
                sum -= 1ll * x.first * x.second;
                sum += 1ll * y.first * y.second;
                use.erase(use.begin());
                free.erase(--free.end());
                use.insert(y);
                free.insert(x);
            }
        };  

        auto del = [&](int x){
            if(use.count({mp[x], x})){
                sum -= 1ll * mp[x] * x;
                use.erase({mp[x], x});
            }
            else if(free.find({mp[x], x}) != free.end()){
                free.erase({mp[x], x});
            }
        };

        auto add = [&](int x){
            free.insert({mp[x], x});
        };


        fix();


        vector<ll> ans;
        ans.push_back(sum);
        for(int l = 0, r = k; r < sz(a); l++, r++){
            if(a[l] == a[r]){
                ans.push_back(sum);
                continue;
            }
            del(a[l]);
            del(a[r]);
            mp[a[l]]--; mp[a[r]]++;
            add(a[l]);
            add(a[r]);
            fix();
            ans.push_back(sum);
        }
        return ans;
    }
};",1420544533
Anas_Maged,Anas_Maged,5,3610,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for(int i = 0; i + k <= sz(nums); i++){
            map<int, int> mp;
            for(int j = i; j < i + k; j++){
                mp[nums[j]]++;
            }
            vector<pair<int, int>> a;
            for(auto it : mp){
                a.push_back({it.second, it.first});
            }
            sort(all(a));
            reverse(all(a));
            int sum = 0;
            for(int i = 0; i < min(x, sz(a)); i++){
                sum += a[i].second * a[i].first;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420519484
Nicholas,nicholask_17,6,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector <int> v;
    pair <int,int> dfs(TreeNode* root,int dep){
        int sz=1;
        int d=-1;
        if (root->left){
            pair <int,int> tp=dfs(root->left,dep+1);
            sz+=tp.first;
            if (d==-1) d=tp.second;
            else if (d!=-2&&d!=tp.second) d=-2;
            if (tp.second==-2) d=-2;
        } else d=dep;
        if (root->right){
            pair <int,int> tp=dfs(root->right,dep+1);
            sz+=tp.first;
            if (d==-1) d=tp.second;
            else if (d!=-2&&d!=tp.second) d=-2;
            if (tp.second==-2) d=-2;
        } else if (d!=dep) d=-2;
        if (d!=-2) v.push_back(sz);
        return {sz,d};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root,0);
        sort(v.begin(),v.end(),greater <int>());
        if (v.size()<k) return -1;
        return v[k-1];
    }
};",1420529110
Nicholas,nicholask_17,6,3588,cpp,"class Solution {
public:
const int mod=1e9+7;
    int countWinningSequences(string s) {
        int n=s.size();
        s="" ""+s;
        int dp[n+1][2*n+1][4];
        for (int i=0; i<=n; i++){
            for (int j=0; j<=2*n; j++){
                for (int k=0; k<4; k++) dp[i][j][k]=0;
            }
        }
        dp[0][n][0]=1;
        for (int i=0; i<n; i++){
            for (int j=n-i; j<=n+i; j++){
                for (int k=0; k<4; k++){
                    for (int l=1; l<4; l++){
                        if (k==l) continue;
                        int sc=j;
                        if (s[i+1]=='F'&&l==2) sc++;
                        else if (s[i+1]=='F'&&l==3) sc--;
                        else if (s[i+1]=='W'&&l==3) sc++;
                        else if (s[i+1]=='W'&&l==1) sc--;
                        else if (s[i+1]=='E'&&l==1) sc++;
                        else if (s[i+1]=='E'&&l==2) sc--;
                        dp[i+1][sc][l]+=dp[i][j][k];
                        dp[i+1][sc][l]%=mod;
                    }
                }
            }
        }
        int ans=0;
        for (int i=n+1; i<=2*n; i++){
            for (int j=1; j<=3; j++){
                ans+=dp[n][i][j];
                ans%=mod;
            }
        }
        return ans;
    }
};",1420524071
Nicholas,nicholask_17,6,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map <long long,long long> freq;
        set <pair <long long,long long>,greater <pair <long long,long long> > > s,wait;
        vector <long long> ret;
        for (int i=0; i<k; i++) freq[nums[i]]++;
        long long ans=0;
        for (auto i:freq){
            s.insert({i.second,i.first});
            ans+=i.first*i.second;
        }
        while (s.size()>x){
            pair <long long,long long> tp=*(--s.end());
            ans-=tp.first*tp.second;
            s.erase(tp);
            wait.insert(tp);
        }
        ret.push_back(ans);
        for (int i=1; i+k-1<nums.size(); i++){
            pair <long long,long long> tp={freq[nums[i-1]],nums[i-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else {
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i-1]]--;
            if (freq[nums[i-1]]){
                tp={freq[nums[i-1]],nums[i-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            tp={freq[nums[i+k-1]],nums[i+k-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else if (s.find(tp)!=s.end()){
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i+k-1]]++;
            {
                tp={freq[nums[i+k-1]],nums[i+k-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            ret.push_back(ans);
        }
        return ret;
    }
};",1420544732
Nicholas,nicholask_17,6,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        map <long long,long long> freq;
        set <pair <long long,long long>,greater <pair <long long,long long> > > s,wait;
        vector <int> ret;
        for (int i=0; i<k; i++) freq[nums[i]]++;
        long long ans=0;
        for (auto i:freq){
            s.insert({i.second,i.first});
            ans+=i.first*i.second;
        }
        while (s.size()>x){
            pair <long long,long long> tp=*(--s.end());
            ans-=tp.first*tp.second;
            s.erase(tp);
            wait.insert(tp);
        }
        ret.push_back(ans);
        for (int i=1; i+k-1<nums.size(); i++){
            pair <long long,long long> tp={freq[nums[i-1]],nums[i-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else {
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i-1]]--;
            if (freq[nums[i-1]]){
                tp={freq[nums[i-1]],nums[i-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            tp={freq[nums[i+k-1]],nums[i+k-1]};
            if (wait.find(tp)!=wait.end()) wait.erase(tp);
            else if (s.find(tp)!=s.end()){
                ans-=tp.first*tp.second;
                s.erase(tp);
            }
            freq[nums[i+k-1]]++;
            {
                tp={freq[nums[i+k-1]],nums[i+k-1]};
                s.insert(tp);
                ans+=tp.first*tp.second;
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            if (!wait.empty()){
                pair <long long,long long> tp=*(wait.begin());
                s.insert(tp);
                ans+=tp.first*tp.second;
                wait.erase(tp);
                if (s.size()>x){
                    pair <long long,long long> tp2=*(--s.end());
                    ans-=tp2.first*tp2.second;
                    s.erase(tp2);
                    wait.insert(tp2);
                }
            }
            ret.push_back(ans);
        }
        return ret;
    }
};",1420545280
Dragos Ristache,MKLOL,7,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
vi rv;
pii dfs(TreeNode *root) {
    int ret = 0;
    if (root == NULL) {
        return {0,1};   
    }
    pii l = dfs(root->left);
    pii r = dfs(root->right);
    ret = 1 + l.fs + r.fs;
    if (l.fs == r.fs && l.sc && r.sc) {
        rv.pb(ret);
        return {ret, 1};
    } else {
        return {ret, 0};
    }

}

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        rv.clear();
        dfs(root);
        sort(all(rv));
        reverse(all(rv));
        --k;
        if (sz(rv) <= k) {
            return -1;
        }
        return rv[k];
    }
};",1420546100
Dragos Ristache,MKLOL,7,3588,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
typedef pair<int,pii> piii;
using namespace std;
#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;

int score(int x, int y) {
  if(x == y) return 0;
  if( (x == 0 && y == 2) || (x == 1 && y == 0) || (x == 2 && y == 1) ) return 1;
  return -1;
}

mint dp[3][1010][2050];

class Solution {
public:
    int countWinningSequences(string s) {
      map<char, int> h;
      h['E'] = 0;
      h['F'] = 1;
      h['W'] = 2;

      int N = sz(s);
      // init the first one
      FOR(k, 3) {
        FOR(i, N) {
          FOR(j, 2*N+5) {
            dp[k][i][j] = 0;
          }
        }
      }
      FOR(k, 3) {
        dp[k][0][score(k, h[s[0]]) + N] = 1;
      }

      FOR(i, N-1) {
        FOR(j, 2*N+3) {
          FOR(k, 3) {
            if(dp[k][i][j].x != 0) {
              FOR(l, 3) {
                if(l != k) {
                  dp[l][i+1][j + score(l, h[s[i+1]])] += dp[k][i][j];
                  //cout << ""WTF"" << endl;
                }
              }
            }
          }
        }
      }
      mint ret = 0;
      for(int j=N+1;j<=2*N+3;++j) {
        FOR(k, 3) {
          ret += dp[k][N-1][j];
        }
      }

      return ret.x;   
    }
};
",1420539041
Dragos Ristache,MKLOL,7,3592,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';


set<pll> SL,SR;
map<ll,ll> h;
ll ret;
int X;
void update() {
    if (sz(SL) < X && sz(SR)) {
        pll el = *SR.rbegin();
        SR.erase(el);
        SL.insert(el);
        ret += el.fs * el.sc;
    } else if (sz(SL) == X && sz(SR)) {
        pll elr = *SR.rbegin();
        pll ell = *SL.begin();
        if (elr > ell) {
            ret -= ell.fs * ell.sc;
            ret += elr.fs * elr.sc;
            SL.erase(ell);
            SR.erase(elr);
            SL.insert(elr);
            SR.insert(ell);
        }
    }
}

void add(pll x) {
    if (sz(SL) < X) {
        SL.insert(x);
        ret += x.fs * x.sc;
    } else {
        SR.insert(x);
    }
    update();
}

void rem(pll x) {
    if (SL.find(x) != SL.end()) {
        SL.erase(SL.find(x));
        ret -= x.fs * x.sc;
    }
    if (SR.find(x) != SR.end()) {
        SR.erase(SR.find(x));
    }
    update();
}

ll calc() {
    ll ret = 0;
    for (auto x : SL) {
        ret += x.fs * x.sc;
    }
    return ret;
}

class Solution {
public:
    vector<long long> findXSum(vector<int>& v, int k, int x) {
        h.clear();
        SL.clear();
        SR.clear();
        X = x;
        ret = 0;
        FOR(i, k) {
            h[v[i]]++;
        }
        for (auto x : h) {
            add({x.sc, x.fs});
        }
        vll rv;
        rv.pb(ret);
        for (int i=k;i<sz(v);++i) {
            int el = v[i];
            pll old = {h[el], el};
            rem(old);
            h[el]++;
            pll nw = {h[el], el};
            add(nw);
            
            
            pll oldl = {h[v[i-k]], v[i-k]};
            rem(oldl);
            h[v[i-k]]--;
            pll nl = {h[v[i-k]], v[i-k]};
            add(nl);
            
            rv.pb(ret);
        }
        return rv;
        
    }
};",1420531463
Dragos Ristache,MKLOL,7,3610,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';


set<pll> SL,SR;
map<ll,ll> h;
ll ret;
int X;
void update() {
    if (sz(SL) < X && sz(SR)) {
        pll el = *SR.rbegin();
        SR.erase(el);
        SL.insert(el);
        ret += el.fs * el.sc;
    } else if (sz(SL) == X && sz(SR)) {
        pll elr = *SR.rbegin();
        pll ell = *SL.begin();
        if (elr > ell) {
            ret -= ell.fs * ell.sc;
            ret += elr.fs * elr.sc;
            SL.erase(ell);
            SR.erase(elr);
            SL.insert(elr);
            SR.insert(ell);
        }
    }
}

void add(pll x) {
    if (sz(SL) < X) {
        SL.insert(x);
        ret += x.fs * x.sc;
    } else {
        SR.insert(x);
    }
    update();
}

void rem(pll x) {
    if (SL.find(x) != SL.end()) {
        SL.erase(SL.find(x));
        ret -= x.fs * x.sc;
    }
    if (SR.find(x) != SR.end()) {
        SR.erase(SR.find(x));
    }
    update();
}

ll calc() {
    ll ret = 0;
    for (auto x : SL) {
        ret += x.fs * x.sc;
    }
    return ret;
}

class Solution {
public:
    vi findXSum(vector<int>& v, int k, int x) {
        h.clear();
        SL.clear();
        SR.clear();
        X = x;
        ret = 0;
        FOR(i, k) {
            h[v[i]]++;
        }
        for (auto x : h) {
            add({x.sc, x.fs});
        }
        vi rv;
        rv.pb(ret);
        for (int i=k;i<sz(v);++i) {
            int el = v[i];
            pll old = {h[el], el};
            rem(old);
            h[el]++;
            pll nw = {h[el], el};
            add(nw);
            
            
            pll oldl = {h[v[i-k]], v[i-k]};
            rem(oldl);
            h[v[i-k]]--;
            pll nl = {h[v[i-k]], v[i-k]};
            add(nl);
            
            rv.pb(ret);
        }
        return rv;
        
    }
};",1420546921
Ma Lin,Ma_Lin,8,3509,cpp,"class Solution {
public:
    int i, j;
    map<TreeNode*, int> height;
    map<TreeNode*, bool> perf;
    vector<int> res;
    
    void dfs(TreeNode* p){
        if (p->left == NULL && p->right == NULL){
            perf[p] = true;
            height[p] = 1;
            res.push_back((1<<height[p]) - 1);
            return;
        }
        
        TreeNode *l = p->left, *r = p->right;
        
        if (l != NULL) dfs(l);
        if (r != NULL) dfs(r);
        perf[p] = (l != NULL && r != NULL && perf[l] && perf[r] && height[l] == height[r]);
        if (l != NULL) height[p] = height[l] + 1;
        else height[p] = height[r] + 1;
        if (perf[p]) res.push_back((1<<height[p]) - 1);
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int K) {
        height.clear();
        perf.clear();
        res.clear();
        dfs(root);
        sort(res.begin(), res.end());
        reverse(res.begin(), res.end());
        if (K > res.size()) return -1;
        return res[K - 1];
    }
};",1420523526
Ma Lin,Ma_Lin,8,3588,cpp,"class Solution {
public:
    int f[1005][3][2005];
    int countWinningSequences(string s) {
        int mo = 1000000007, a[1005], i, j, k, h, n = s.size();
        int yh[3][3];
        for (i = 0; i < n; ++i){
            if (s[i] == 'F') a[i] = 0;
            if (s[i] == 'W') a[i] = 1;
            if (s[i] == 'E') a[i] = 2;
        }
        
        for (i = 0; i < 3; ++i)
            for (j = 0; j < 3; ++j){
                yh[i][j] = 0;
                if (j == (i + 1) % 3) yh[i][j] = 1;
                if (j == (i + 2) % 3) yh[i][j] = -1;
            }
        
        for (j = 0; j < 3; ++j){
            for (k = 0; k <= n + n; ++k) f[0][j][k] = 0;
            f[0][j][n + yh[a[0]][j]] = 1;
        }
        
        for (i = 1; i < n; ++i)
            for (j = 0; j < 3; ++j){
                for (k = 0; k <= n + n; ++k) f[i][j][k] = 0;
                for (h = 0; h < 3; ++h){
                    if (h == j) continue;
                    for (k = 0; k <= n + n; ++k)
                        if (f[i - 1][h][k] != 0)
                            f[i][j][k + yh[a[i]][j]] = (f[i][j][k + yh[a[i]][j]] + f[i - 1][h][k]) % mo;
                }
            }
        
        int res = 0;
        for (j = 0; j < 3; ++j)
            for (k = n + 1; k <= n + n; ++k) 
                res = (res + f[n - 1][j][k]) % mo;
            
        return res;
    }
};",1420532006
Ma Lin,Ma_Lin,8,3592,cpp,"class Solution {
public:
    set<pair<int, int> > S, down;
    unordered_map<int, int> f;
    long long sum;
    int top;
    
    bool xiao(pair<int, int> a, pair<int, int> b){
        if (a.first < b.first) return true;
        if (a.first > b.first) return false;
        return a.second < b.second;
    }
    
    void change(int v, int d){
        pair<int, int> t = {f[v], v};
        if (S.count(t)){
            sum -= 1LL * f[v] * v;
            S.erase(t);
        }
        else down.erase(t);
        
        f[v] += d;
        t = {f[v], v};
        if (down.size() > 0 && xiao(t, *prev(down.end()))) down.insert(t);
        else{
            S.insert(t);
            sum += 1LL * f[v] * v;
        }
        
        while (down.size() > 0 && S.size() < top){
            t = *prev(down.end());
            down.erase(t);
            sum += 1LL * t.first * t.second;
            S.insert(t);
        }
        
        while (S.size() > top){
            t = *S.begin();
            sum -= 1LL * t.first * t.second;
            down.insert(t);
            S.erase(t);
        }
    }
    
    vector<long long> findXSum(vector<int>& a, int K, int tt) {
        top = tt;
        vector<long long> res;
        S.clear();
        down.clear();
        f = unordered_map<int, int>();
        sum = 0;
        int n = a.size(), q, i, j, k;
        
        for (i = 0; i < n; ++i){
            pair<int, int> t;
            if (i - K >= 0) change(a[i - K], -1);
            change(a[i], 1);
            if (i >= K - 1) res.push_back(sum);
        }
        
        return res;
    }
};",1420547078
Ma Lin,Ma_Lin,8,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int K, int x) {
        int i, j, n = a.size(), r;
        vector<int> res;
        for (i = 0; i <= n - K; ++i){
            map<int, int> f;
            set<pair<int, int> > S;
            for (j = i; j < i + K; ++j) f[a[j]]++;
            for (auto p : f) S.insert({p.second, p.first});
            r = 0;
            for (j = 0; j < x && S.size() > 0; ++j){
                auto p = prev(S.end());
                r += p->first * p->second;
                S.erase(p);
            }
            
            res.push_back(r);
        }
        
        return res;
    }
};",1420519407
arignote,arignote,11,3509,java,"class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        ArrayList<Integer> list = new ArrayList<>();
        kthLargestPerfectSubtree(root, list);
        Collections.sort(list);
        return k > list.size() ? -1 : list.get(list.size() - k);
    }
    private int kthLargestPerfectSubtree(TreeNode root, ArrayList<Integer> list) {
        if (root == null) {
            return 0;
        }
        int left = kthLargestPerfectSubtree(root.left, list), right = kthLargestPerfectSubtree(root.right, list);
        if (left < 0 || left != right) {
            return -1;
        }
        list.add((1 << left + 1) - 1);
        return left + 1;
    }
}",1420549464
arignote,arignote,11,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int dp[][][] = new int[s.length()][2 * s.length() + 3][3], count = 0;
        dp[0][s.length()][s.charAt(0) == 'F' ? 2 : s.charAt(0) == 'W' ? 0 : 1] = 1;
        dp[0][s.length() + 1][s.charAt(0) == 'F' ? 0 : s.charAt(0) == 'W' ? 1 : 2] = 1;
        dp[0][s.length() + 2][s.charAt(0) == 'F' ? 1 : s.charAt(0) == 'W' ? 2 : 0] = 1;
        for (int i = 1; i < s.length(); i++) {
            for (int j = 1; j < 2 * s.length() + 2; j++) {
                dp[i][j] = new int[] { (dp[i - 1][j + (s.charAt(i) == 'W' ? 1 : s.charAt(i) == 'E' ? -1 : 0)][1] + dp[i - 1][j + (s.charAt(i) == 'W' ? 1 : s.charAt(i) == 'E' ? -1 : 0)][2]) % 1000000007, (dp[i - 1][j + (s.charAt(i) == 'E' ? 1 : s.charAt(i) == 'F' ? -1 : 0)][0] + dp[i - 1][j + (s.charAt(i) == 'E' ? 1 : s.charAt(i) == 'F' ? -1 : 0)][2]) % 1000000007, (dp[i - 1][j + (s.charAt(i) == 'F' ? 1 : s.charAt(i) == 'W' ? -1 : 0)][0] + dp[i - 1][j + (s.charAt(i) == 'F' ? 1 : s.charAt(i) == 'W' ? -1 : 0)][1]) % 1000000007 };
            }
        }
        for (int i = s.length() + 2; i < 2 * s.length() + 2; i++) {
            count = (((count + dp[s.length() - 1][i][0]) % 1000000007 + dp[s.length() - 1][i][1]) % 1000000007 + dp[s.length() - 1][i][2]) % 1000000007;
        }
        return count;
    }
}",1420549304
arignote,arignote,11,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        TreeSet<long[]> left = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(o[1], p[1]) : Long.compare(o[0], p[0])), right = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(p[1], o[1]) : Long.compare(p[0], o[0]));
        HashMap<Integer, long[]> map = new HashMap<>();
        long sum = 0;
        long[] result = new long[nums.length - k + 1];
        for (int i = 0; i < nums.length; i++) {
            if (left.contains(map.getOrDefault(nums[i], new long[2]))) {
                left.remove(map.get(nums[i]));
                sum -= nums[i] * map.get(nums[i])[0];
            }
            right.remove(map.getOrDefault(nums[i], new long[2]));
            map.put(nums[i], new long[] { map.getOrDefault(nums[i], new long[1])[0] + 1, nums[i] });
            right.add(map.get(nums[i]));
            if (i >= k - 1) {
                while (left.size() < x && !right.isEmpty()) {
                    sum += right.first()[0] * right.first()[1];
                    left.add(right.pollFirst());
                }
                result[i - k + 1] = sum;
                if (left.contains(map.getOrDefault(nums[i - k + 1], new long[2]))) {
                    left.remove(map.get(nums[i - k + 1]));
                    sum -= nums[i - k + 1] * map.get(nums[i - k + 1])[0];
                }
                right.remove(map.getOrDefault(nums[i - k + 1], new long[2]));
                map.put(nums[i - k + 1], new long[] { map.getOrDefault(nums[i - k + 1], new long[1])[0] - 1, nums[i - k + 1] });
                right.add(map.get(nums[i - k + 1]));
                if (!left.isEmpty()) {
                    sum -= left.first()[0] * left.first()[1];
                    right.add(left.pollFirst());
                }
            }
        }
        return result;
    }
}",1420549082
arignote,arignote,11,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        TreeSet<long[]> left = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(o[1], p[1]) : Long.compare(o[0], p[0])), right = new TreeSet<>((o, p) -> o[0] == p[0] ? Long.compare(p[1], o[1]) : Long.compare(p[0], o[0]));
        HashMap<Integer, long[]> map = new HashMap<>();
        int sum = 0;
        int[] result = new int[nums.length - k + 1];
        for (int i = 0; i < nums.length; i++) {
            if (left.contains(map.getOrDefault(nums[i], new long[2]))) {
                left.remove(map.get(nums[i]));
                sum -= nums[i] * map.get(nums[i])[0];
            }
            right.remove(map.getOrDefault(nums[i], new long[2]));
            map.put(nums[i], new long[] { map.getOrDefault(nums[i], new long[1])[0] + 1, nums[i] });
            right.add(map.get(nums[i]));
            if (i >= k - 1) {
                while (left.size() < x && !right.isEmpty()) {
                    sum += right.first()[0] * right.first()[1];
                    left.add(right.pollFirst());
                }
                result[i - k + 1] = sum;
                if (left.contains(map.getOrDefault(nums[i - k + 1], new long[2]))) {
                    left.remove(map.get(nums[i - k + 1]));
                    sum -= nums[i - k + 1] * map.get(nums[i - k + 1])[0];
                }
                right.remove(map.getOrDefault(nums[i - k + 1], new long[2]));
                map.put(nums[i - k + 1], new long[] { map.getOrDefault(nums[i - k + 1], new long[1])[0] - 1, nums[i - k + 1] });
                right.add(map.get(nums[i - k + 1]));
                if (!left.isEmpty()) {
                    sum -= left.first()[0] * left.first()[1];
                    right.add(left.pollFirst());
                }
            }
        }
        return result;
    }
}",1420549664
scanhex,scanhex,12,3509,cpp,"
using namespace std;
using nagai=long long;
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        std::map<TreeNode*, int> de, sz, cnt;
        vector<int> szs;
        auto dfs = [&](TreeNode* x, auto dfs) -> void {
            sz[x] = 1;
            de[x] = 0;
            if (x->left) {
                dfs(x->left, dfs);
                sz[x] += sz[x->left];
                de[x] = max(de[x], 1 + de[x->left]);
            }
            if (x->right) {
                dfs(x->right, dfs);
                sz[x] += sz[x->right];
                de[x] = max(de[x], 1 + de[x->right]);
            }
            if (sz[x] == ((1 << (de[x] + 1)) - 1)) {
                szs.push_back(sz[x]);
            }
        };
        dfs(root, dfs);
        sort(szs.rbegin(), szs.rend());
        --k;
        if (k < szs.size()) {
            return szs[k];
        }
        return -1;
    }
};

",1420523621
scanhex,scanhex,12,3588,cpp,"
using namespace std;
using nagai = long long;
class Solution {
public:
  int countWinningSequences(string s) {
    auto ord = [&](char ch) { return ch == 'F' ? 0 : ch == 'W' ? 1 : 2; };
    const int mod = 1e9 + 7;
    int n = s.size();
    int MX = 2 * n + 5;
    int ZERO = n + 2;
    vector<vector<int>> dp(MX, vector<int>(3));
    for (int cc = 0; cc < n; ++cc) {
      char ch = s[cc];
      auto dp1 = vector<vector<int>>(MX, vector<int>(3));
      int o = ord(ch);
      for (int i = 0; i < MX; ++i) {
        for (int bob = 0; bob < 3; ++bob) {
          int df = (bob == o ? 0 : bob == (o + 2) % 3 ? -1 : 1);
          if (cc == 0) {
            if (i == ZERO)
              dp1[i + df][bob] += 1;
          } else {
            for (int last = 0; last < 3; ++last) {
              if (last == bob)
                continue;
              if (i + df >= 0 && i + df < MX) {
                dp1[i + df][bob] += dp[i][last];
                if (dp1[i + df][bob] >= mod) {
                  dp1[i + df][bob] -= mod;
                }
              }
            }
          }
        }
      }
      dp = dp1;
    }
    int ans = 0;
    for (int i = ZERO + 1; i < MX; ++i) {
      for (int j = 0; j < 3; ++j) {
        ans += dp[i][j];
        if (ans >= mod) {
          ans -= mod;
        }
      }
    }
    return ans;
  }
};

",1420533739
scanhex,scanhex,12,3592,cpp,"
using namespace std;
using nagai = long long;
class Solution {
public:
  vector<long long> findXSum(vector<int> &nums, int k, int X) {
    set<std::pair<int, int>> st;
    nagai s = 0;
    set<std::pair<int, int>> rest;
    map<int, int> cnt;
    auto add = [&](int x) {
      auto p = std::pair(cnt[x], x);
      s += 1LL * p.first * p.second;
      st.insert(p);
      if (st.size() > X) {
        auto rofl = *st.begin();
        s -= 1LL * rofl.first * rofl.second;
        st.erase(rofl);
        rest.insert(rofl);
      }
    };
    auto rem = [&](int x) {
      auto p = std::pair(cnt[x], x);
      if (st.count(p)) {
        st.erase(p);
        s -= 1LL * p.first * p.second;
      }
      rest.erase(p);
      while (rest.size() && st.size() < X) {
        auto rofl = *rest.rbegin();
        rest.erase(rofl);
        st.insert(rofl);
        s += 1LL * rofl.first * rofl.second;
      }
    };
    for (int i = 0; i < k; ++i) {
      int x = nums[i];
      rem(x);
      ++cnt[x];
      add(x);
    }
    std::vector<long long> res;
    for (int i = 0; i + k <= nums.size(); ++i) {
      res.push_back(s);
      if (i + k < nums.size()) {
        rem(nums[i + k]);
        ++cnt[nums[i + k]];
        add(nums[i + k]);
        rem(nums[i]);
        --cnt[nums[i]];
        add(nums[i]);
      }
    }
    return res;
  }
};

",1420544267
scanhex,scanhex,12,3610,cpp,"
using namespace std;
using nagai = int;
class Solution {
public:
  vector<int> findXSum(vector<int> &nums, int k, int X) {
    set<std::pair<int, int>> st;
    nagai s = 0;
    set<std::pair<int, int>> rest;
    map<int, int> cnt;
    auto add = [&](int x) {
      auto p = std::pair(cnt[x], x);
      s += 1LL * p.first * p.second;
      st.insert(p);
      if (st.size() > X) {
        auto rofl = *st.begin();
        s -= 1LL * rofl.first * rofl.second;
        st.erase(rofl);
        rest.insert(rofl);
      }
    };
    auto rem = [&](int x) {
      auto p = std::pair(cnt[x], x);
      if (st.count(p)) {
        st.erase(p);
        s -= 1LL * p.first * p.second;
      }
      rest.erase(p);
      while (rest.size() && st.size() < X) {
        auto rofl = *rest.rbegin();
        rest.erase(rofl);
        st.insert(rofl);
        s += 1LL * rofl.first * rofl.second;
      }
    };
    for (int i = 0; i < k; ++i) {
      int x = nums[i];
      rem(x);
      ++cnt[x];
      add(x);
    }
    std::vector<int> res;
    for (int i = 0; i + k <= nums.size(); ++i) {
      res.push_back(s);
      if (i + k < nums.size()) {
        rem(nums[i + k]);
        ++cnt[nums[i + k]];
        add(nums[i + k]);
        rem(nums[i]);
        --cnt[nums[i]];
        add(nums[i]);
      }
    }
    return res;
  }
};

",1420545357
Joshua Arrazola,JArrazola,13,3509,cpp,"class Solution {
public:
    struct Result {
        bool isPerfect;
        int height;
        int size;
    };
    
    vector<int> sizes; 

    Result helper(TreeNode* root) {
        if (!root) {
            return {true, -1, 0};
        }
        
        Result left = helper(root->left);
        Result right = helper(root->right);
        
        bool isPerfect = left.isPerfect && right.isPerfect && (left.height == right.height);
        int height = left.height + 1;
        int size = left.size + right.size + 1;
        
        if (isPerfect) {
            sizes.push_back(size);
        }
        
        return {isPerfect, height, size};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        helper(root);
        
        if (sizes.size() < k) {
            return -1;
        }
        
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k - 1];
    }
};
",1420524416
Joshua Arrazola,JArrazola,13,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.length();
        vector<int> s_vec(n);
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') s_vec[i] = 0;
            else if (s[i] == 'W') s_vec[i] = 1;
            else s_vec[i] = 2; 
        }
        int max_delta = 2 * n + 1;
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(4, vector<int>(max_delta, 0)));
        int curr = 0;
        dp[curr][3][n] = 1;
        for (int pos = 0; pos < n; ++pos) {
            int alice_move = s_vec[pos];
            dp[1 - curr] = vector<vector<int>>(4, vector<int>(max_delta, 0));
            for (int prev_bob = 0; prev_bob < 4; ++prev_bob) {
                for (int delta = -n; delta <= n; ++delta) {
                    int count = dp[curr][prev_bob][delta + n];
                    if (count == 0) continue;
                    for (int curr_bob = 0; curr_bob < 3; ++curr_bob) {
                        if (prev_bob != curr_bob) {
                            int battle_result;
                            if (curr_bob == alice_move) battle_result = 0;
                            else if ((curr_bob - alice_move + 3) % 3 == 1) battle_result = 1;
                            else battle_result = -1;
                            int delta_prime = delta + battle_result;
                            if (delta_prime < -n || delta_prime > n) continue;
                            dp[1 - curr][curr_bob][delta_prime + n] = (dp[1 - curr][curr_bob][delta_prime + n] + count) % MOD;
                        }
                    }
                }
            }
            curr = 1 - curr;
        }
        int total = 0;
        for (int prev_bob = 0; prev_bob < 3; ++prev_bob) {
            for (int delta = 1; delta <= n; ++delta) {
                total = (total + dp[curr][prev_bob][delta + n]) % MOD;
            }
        }
        return total;
    }
};",1420530023
Joshua Arrazola,JArrazola,13,3592,cpp,"
class Solution {
public:
    struct Node {
        Node *left, *right;
        int freq, val, size;
        long long sum;
        int priority;
        Node(int f, int v) : left(nullptr), right(nullptr), freq(f), val(v), size(1), sum((long long)f * v), priority(rand()) {}
        
        void update() {
            size = 1;
            sum = (long long)freq * val;
            if (left) {
                size += left->size;
                sum += left->sum;
            }
            if (right) {
                size += right->size;
                sum += right->sum;
            }
        }
        
        bool operator<(const Node& other) const {
            if (freq != other.freq)
                return freq > other.freq; 
            else
                return val > other.val;   
        }
    };

    void split(Node* node, Node*& left, Node*& right, const Node& key) {
        if (!node) {
            left = right = nullptr;
        } else if (*node < key) {
            split(node->right, node->right, right, key);
            left = node;
        } else {
            split(node->left, left, node->left, key);
            right = node;
        }
        if (node) node->update();
    }

    void merge(Node*& node, Node* left, Node* right) {
        if (!left || !right) {
            node = left ? left : right;
        } else if (left->priority > right->priority) {
            merge(left->right, left->right, right);
            node = left;
        } else {
            merge(right->left, left, right->left);
            node = right;
        }
        if (node) node->update();
    }

    void insert(Node*& node, Node* item) {
        if (!node) {
            node = item;
        } else if (item->priority > node->priority) {
            split(node, item->left, item->right, *item);
            node = item;
        } else if (*item < *node) {
            insert(node->left, item);
        } else {
            insert(node->right, item);
        }
        if (node) node->update();
    }

    void erase(Node*& node, const Node& key) {
        if (!node) return;
        if (node->freq == key.freq && node->val == key.val) {
            Node* temp = node;
            merge(node, node->left, node->right);
            delete temp;
        } else if (key < *node) {
            erase(node->left, key);
        } else {
            erase(node->right, key);
        }
        if (node) node->update();
    }

    long long getSum(Node* node, int k) {
        if (!node || k <= 0) return 0;
        int lsize = node->left ? node->left->size : 0;
        if (lsize >= k) {
            return getSum(node->left, k);
        } else {
            long long res = node->left ? node->left->sum : 0;
            res += (long long)node->freq * node->val;
            if (lsize + 1 == k) {
                return res;
            } else {
                return res + getSum(node->right, k - lsize - 1);
            }
        }
    }

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        unordered_map<int, int> freq;
        Node* root = nullptr;

        for (int i = 0; i < k; ++i) {
            int num = nums[i];
            int f = freq[num];
            if (f > 0) {
                erase(root, Node(f, num));
            }
            freq[num] = f + 1;
            insert(root, new Node(freq[num], num));
        }

        vector<long long> answer;

        for (int i = 0; i <= n - k; ++i) {
            long long sum = getSum(root, x);
            answer.push_back(sum);

            if (i + k == n) break;

            int out_num = nums[i];
            int in_num = nums[i + k];

            int f = freq[out_num];
            erase(root, Node(f, out_num));
            freq[out_num] = f - 1;
            if (freq[out_num] > 0) {
                insert(root, new Node(freq[out_num], out_num));
            } else {
                freq.erase(out_num);
            }

            f = freq[in_num];
            if (f > 0) {
                erase(root, Node(f, in_num));
            }
            freq[in_num] = f + 1;
            insert(root, new Node(freq[in_num], in_num));
        }

        destroy(root);

        return answer;
    }

    void destroy(Node* node) {
        if (!node) return;
        destroy(node->left);
        destroy(node->right);
        delete node;
    }
};",1420539494
Joshua Arrazola,JArrazola,13,3610,cpp,"
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        unordered_map<int, int> counts;
        map<int, set<int>> count_to_elements; 

        for (int i = 0; i < k; ++i) {
            int e = nums[i];
            int old_count = counts[e];
            counts[e]++;
            int new_count = counts[e];

            if (old_count > 0) {
                count_to_elements[old_count].erase(e);
                if (count_to_elements[old_count].empty()) {
                    count_to_elements.erase(old_count);
                }
            }
            count_to_elements[new_count].insert(e);
        }

        for (int i = 0; i <= n - k; ++i) {
            if (i > 0) {
                int e = nums[i - 1];
                int old_count = counts[e];
                counts[e]--;
                int new_count = counts[e];

                count_to_elements[old_count].erase(e);
                if (count_to_elements[old_count].empty()) {
                    count_to_elements.erase(old_count);
                }

                if (new_count > 0) {
                    count_to_elements[new_count].insert(e);
                } else {
                    counts.erase(e);
                }

                e = nums[i + k -1];
                old_count = counts[e];
                counts[e]++;
                new_count = counts[e];

                if (old_count > 0) {
                    count_to_elements[old_count].erase(e);
                    if (count_to_elements[old_count].empty()) {
                        count_to_elements.erase(old_count);
                    }
                }
                count_to_elements[new_count].insert(e);
            }

            int elements_collected = 0;
            vector<int> top_elements;
            for (auto rit = count_to_elements.rbegin(); rit != count_to_elements.rend(); ++rit) {
                int count = rit->first;
                auto& elements_set = rit->second;
                for (auto sit = elements_set.rbegin(); sit != elements_set.rend(); ++sit) {
                    int e = *sit;
                    top_elements.push_back(e);
                    elements_collected++;
                    if (elements_collected == x) break;
                }
                if (elements_collected == x) break;
            }
            int sum_x = 0;
            for (int e : top_elements) {
                sum_x += counts[e] * e;
            }
            answer.push_back(sum_x);
        }

        return answer;
    }
};

",1420529546
robezh765,robezh765,15,3509,cpp,"
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef pair<vi, vi> pvi;

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vi fres;
    pii dfs(TreeNode *cur) {
        pii res = {-1, -1};
        vector<pii> vs;
        for (auto nxt : {cur->left, cur->right}) {
            if (nxt == nullptr) continue;
            pii to = dfs(nxt);
            vs.push_back(to);
        }
        if(sz(vs) == 0) {
            fres.push_back(1);
            return {1, 1};
        }
        if(sz(vs) == 1) return {-1, vs[0].second};
        if(vs[0].first == -1 || vs[1].first == -1) return {-1, max(vs[0].second, vs[1].second)};
        if(vs[0].first == vs[1].first)  {
            fres.push_back(vs[0].first * 2 + 1);
            return {vs[0].first * 2 + 1, vs[0].first * 2 + 1};

        };
        return {-1, max(vs[0].second, vs[1].second)};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        fres.clear();
        dfs(root);
        // for (int x : fres ) cout << x << "" "";
        // cout << endl;
        sort(all(fres));
        reverse(all(fres));
        return sz(fres) < k ? -1 : fres[k - 1];
    }
};

",1420527354
robezh765,robezh765,15,3588,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef pair<vi, vi> pvi;

const int mod = (int)1e9 + 7;
class Solution {
public:
    int countWinningSequences(string s) {
        int n = sz(s);
        vvvi dp(n, vvi(2 * n + 2, vi(3, 0)));
        int mid = n + 1;
        map<char, int> mp;
        mp['F'] = 0, mp['W'] = 1, mp['E'] = 2;
        auto gscore = [&](int a, int b) {
            if(a == (b + 1) % 3) return 1;
            else if(a == b) return 0;
            else return -1;
        };
        rep(i, 0, 3) {
            dp[0][mid + gscore(i, mp[s[0]])][i] = 1;
        }
        auto gdp = [&](int i, int j, int k) {
            if(0 <= j && j < 2 * n + 2) return dp[i][j][k];
            return 0;
        };
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 2 * n + 2; j++) {
                rep(l, 0, 3) {
                    rep(p, 0, 3) {
                        if(p == l) continue;
                        (dp[i][j][p] += gdp(i - 1, j - gscore(p, mp[s[i]]), l)) %= mod;
                    }
                }
            }
        }
        int sum = 0;
        rep(i, mid + 1, 2 * n + 2) {
            rep(l, 0, 3) {
                sum += dp[n - 1][i][l];
                sum %= mod;
            }
        }
        return sum;
    }
};",1420538951
robezh765,robezh765,15,3592,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef pair<vi, vi> pvi;

struct Set {
    set<pii> L, R;
    int x;
    ll sum = 0;
    Set(int x): x(x) {
    }
    void del(pii p) {
        if(L.find(p) != L.end()) {
            L.erase(p);
        } else {
            assert(R.find(p) != R.end());
            sum -= 1LL * p.first * p.second;
            R.erase(p);
        }
        balance();

    }
    void ins(pii p) {
        if(!L.empty() && L.rbegin()->first > p.first) {
            L.insert(p);

        } else {
            R.insert(p);
            sum += 1LL * p.first * p.second;
        }
        balance();

    }
    void balance() {
        while(!L.empty() && sz(R) < x) {
            auto it = --L.end();
            R.insert(*it);
            sum += 1LL * it->first * it->second;
            L.erase(it);
        }
        while(sz(R) > x) {
            auto it = R.begin();
            L.insert(*it);
            sum -= 1LL * it->second * it->first;
            R.erase(it);
        }
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> cnt;
        Set S(x);
        vector<ll> res;
        auto add = [&](int val, int off) {
            if (cnt[val] != 0) S.del({cnt[val], val});
            cnt[val] += off;
            if (cnt[val] != 0) S.ins({cnt[val], val});
        };
        int n = sz(nums);
        rep(i, 0, k) add(nums[i], 1);
        rep(i, 0, n - k + 1) {
            res.push_back(S.sum);
            if(i != n - k) {
                add(nums[i + k], 1);
                add(nums[i], -1);
            }
        }
        return res;
    }
};",1420553177
robezh765,robezh765,15,3610,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef pair<vi, vi> pvi;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = sz(nums);
        vi res;
        rep(i, 0, n - k + 1) {
            map<int, int> mp;
            rep(j, i, i + k) {
                mp[nums[j]]++;
            }
            vector<pii> vs;
            for(auto p : mp) {
                vs.push_back({p.second, p.first});
            }
            sort(all(vs));
            reverse(all(vs));
            int sum = 0;
            rep(j, 0, min(sz(vs), x)) {
                sum += vs[j].first * vs[j].second;
            }
            res.push_back(sum);
        }
        return res;

    }
};

",1420519662
Dylan Smith,DylanSmith,16,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ops;
    int rec(TreeNode *root) {
        if (!root) return 0;
        int l = rec(root->left), r = rec(root->right);
        if (l != -1 && r != -1 && l == r) {
            ops.push_back((1 << l + 1) - 1);
            return l + 1;
        }
        return -1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        ops.clear();
        rec(root);
        sort(ops.begin(), ops.end());
        reverse(ops.begin(), ops.end());
        if (k - 1 >= (int)ops.size()) return -1;
        return ops[k - 1];
    }
};",1420544178
Dylan Smith,DylanSmith,16,3588,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

int mod = 1000000007;

class Solution {
public:
    int countWinningSequences(string s) {
        int N = sz(s);
        vector<int> a;
        for (char c : s) {
            if (c == 'F') a.pb(0);
            else if (c == 'W') a.pb(1);
            else a.pb(2);
        }
        vector<vector<int>> dp(2 * N + 1, vector<int>(3, 0)), nxt(2 * N + 1, vector<int>(3, 0));
        for (int i = 0; i < 3; i++) {
            int dif = i == a[0] ? 0 : i == (a[0] + 1) % 3 ? 1 : -1;
            dp[N + dif][i]++;
        }
        for (int i = 1; i < N; i++) {
            for (int j = 0; j <= 2 * N; j++) fill(all(nxt[j]), 0);
            for (int j = 0; j <= 2 * N; j++) {
                for (int k = 0; k < 3; k++) {
                    for (int l = 0; l < 3; l++) {
                        if (l == k) continue;
                        int dif = l == a[i] ? 0 : l == (a[i] + 1) % 3 ? 1 : -1;
                        if (j + dif >= 0 && j + dif <= 2 * N) {
                            nxt[j + dif][l] += dp[j][k];
                            if (nxt[j + dif][l] >= mod) nxt[j + dif][l] -= mod;
                        }
                    }
                }
            }
            swap(dp, nxt);
        }
        int res = 0;
        for (int i = N + 1; i <= N * 2; i++) {
            for (int j = 0; j < 3; j++) {
                res += dp[i][j];
                if (res >= mod) res -= mod;
            }
        }
        return res;
    }
};",1420554793
Dylan Smith,DylanSmith,16,3592,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> freq;
        ll curSum = 0;
        set<pair<int, int>> bad, good;
        vector<ll> res;
        for (int i = 0; i < sz(nums); i++) {
            if (freq[nums[i]]) {
                if (bad.count({freq[nums[i]], nums[i]})) {
                    bad.erase({freq[nums[i]], nums[i]});
                } else {
                    good.erase({freq[nums[i]], nums[i]});
                    curSum -= (ll)freq[nums[i]] * nums[i];
                }
            }
            freq[nums[i]]++;
            bad.insert({freq[nums[i]], nums[i]});
            if (i - k >= 0) {
                if (bad.count({freq[nums[i-k]], nums[i-k]})) {
                    bad.erase({freq[nums[i-k]], nums[i-k]});
                } else {
                    good.erase({freq[nums[i-k]], nums[i-k]});
                    curSum -= (ll)freq[nums[i - k]] * nums[i - k];
                }
                freq[nums[i - k]]--;
                if (freq[nums[i - k]]) {
                    bad.insert({freq[nums[i-k]], nums[i-k]});
                }
            }
            while (!bad.empty() && sz(good) < x) {
                pair<int, int> a = *prev(bad.end());
                bad.erase(a);
                good.insert(a);
                curSum += (ll)a.first * a.second;
            }
            while (!bad.empty() && !good.empty()) {
                pair<int, int> a = *prev(bad.end()), b = *good.begin();
                if (a.first > b.first || a.first == b.first && a.second > b.second) {
                    bad.erase(a);
                    good.erase(b);
                    curSum -= (ll)b.first * b.second;
                    bad.insert(b);
                    good.insert(a);
                    curSum += (ll)a.first * a.second;
                } else break;
            }
            if (i - k + 1 >= 0) {
                res.push_back(curSum);
            }
        }
        return res;
    }
};",1420537068
Dylan Smith,DylanSmith,16,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int N = (int)nums.size();
        vector<int> res;
        for (int i = 0; i + k - 1 < N; i++) {
            map<int, int> freq;
            for (int j = 0; j < k; j++) {
                freq[nums[i + j]]++;
            }
            vector<pair<int, int>> srt;
            for (auto &p : freq) srt.push_back({p.second, p.first});
            sort(srt.begin(), srt.end());
            reverse(srt.begin(), srt.end());
            int sum = 0;
            for (int i = 0; i < min(x, (int)srt.size()); i++) {
                sum += srt[i].second * srt[i].first;
            }
            res.push_back(sum);
        }
        return res;
    }
};",1420519452
Khoi Nam,Cookie_Cream,18,3509,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vt<int>res;
    struct th{
        int siz, depth, ok;
    };
    th dfs(TreeNode *root){
        if(root->left == nullptr && root->right == nullptr){
            th cool = {1, 0, 1};
            res.pb(1);
            return(cool);
        }
        int siz = 0;
        bool ok = 1;
        th lson, rson;
        if(root->left != nullptr){
            lson = dfs(root->left);
            ok &= lson.ok; siz += lson.siz;
        }else{
            ok = 0;
        }
        if(root->right != nullptr){
            rson = dfs(root->right);
            ok &= rson.ok; siz += rson.siz;
        }else{
            ok = 0; 
        }
        int depth = 0;
        if(ok){
            depth = lson.depth + 1;
            ok &= (lson.depth == rson.depth); 
        }
        siz++;
        if(ok)res.pb(siz);
        th res = {siz, depth, ok};
        return(res);
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        res.clear();
        dfs(root);
        sort(ALLR(res));
        if(sz(res) < k)return(-1);
        return(res[k - 1]);
    }
};",1420528405
Khoi Nam,Cookie_Cream,18,3588,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
const int mod = 1e9 + 7;
class Solution {
public:
    int dp[1005][2005][3];
    int coef(int id, char c){
        if(c == 'F'){
            if(id == 0)return(0);
            if(id == 1)return(1);
            return(-1);
        }else if(c == 'W'){
            if(id == 0)return(-1);
            if(id == 1)return(0);
            return(1);
        }else{
            if(id == 2)return(0);
            if(id == 1)return(-1);
            return(1);
        }
    }
    void add(int &a, int b){
        a += b;
        if(a >= mod)a -= mod;
    }
    int countWinningSequences(string s) {
        int n = sz(s);
        for(int i = 0; i <= sz(s); i++){
            for(int j = 0; j <= 2 * sz(s); j++){
                for(int k = 0; k < 3; k++){
                    dp[i][j][k] = 0;
                }
            }
        }
        for(int i = 0; i < 3; i++){
            dp[0][n + coef(i, s[0])][i] = 1;
        }
        for(int i = 0; i < sz(s) - 1; i++){
            for(int j = 0; j <= 2 * n; j++){
                for(int k = 0; k < 3; k++){
                    if(dp[i][j][k] == 0)continue;
                    for(int l = 0; l < 3; l++){
                        if(l != k){
                            add(dp[i + 1][j + coef(l, s[i + 1])][l], dp[i][j][k]);
                        }
                    }
                }
            }
        }
        int ans = 0;
        for(int i = n + 1; i <= 2 * n; i++){
            for(int j = 0; j < 3; j++){
                add(ans, dp[sz(s) - 1][i][j]);
            }
        }
        return(ans);
    }
};",1420536009
Khoi Nam,Cookie_Cream,18,3592,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        multiset<pll>low, high;
        vt<ll>res;
        map<int, int>mp;
        for(auto i: nums)mp[i] = 0;
        for(int i = 0; i < k; i++)mp[nums[i]]++;
        vt<pll>cand;
        for(auto i: mp)cand.pb(mpp(i.se, i.fi));
        sort(ALLR(cand));
        ll ans = 0;
        for(int i = 0; i < min(x, sz(cand)); i++){
            low.insert(cand[i]); ans += 1LL * cand[i].se * cand[i].fi;
        }
        for(int i = x; i < sz(cand); i++){
            high.insert(cand[i]);
        }
        res.pb(ans);
        for(int i = 1; i + k <= sz(nums); i++){
            
            pll cool = mpp(mp[nums[i - 1]], nums[i - 1]);
            if(low.find(cool) != low.end()){
                low.erase(low.find(cool)); ans -= cool.fi * cool.se;
            }
            if(high.find(cool) != high.end()){
                high.erase(high.find(cool)); 
            }
            mp[nums[i - 1]]--;
            cool = mpp(mp[nums[i - 1]], nums[i - 1]);
            high.insert(cool);
            cool = mpp(mp[nums[i + k - 1]], nums[i + k - 1]);
            if(low.find(cool) != low.end()){
                low.erase(low.find(cool)); ans -= cool.fi * cool.se;
            }
            if(high.find(cool) != high.end()){
                high.erase(high.find(cool)); 
            }
            mp[nums[i + k - 1]]++;
            
            cool = mpp(mp[nums[i + k - 1]], nums[i + k - 1]);
            high.insert(cool);
            while(sz(low) < x && sz(high)){
                auto it = *high.rbegin();
                ans += it.fi * it.se;
                high.erase(it); low.insert(it);
            }
            while(sz(high) && (*high.rbegin()) > (*low.begin())){
                auto itl = *low.begin(), itr = *high.rbegin();
                ans -= itl.fi * itl.se; ans += itr.fi * itr.se;
                low.erase(itl); high.erase(itr);
                low.insert(itr); high.insert(itl);
            }
            res.pb(ans);
        }
        return(res);
    }
};",1420549527
Khoi Nam,Cookie_Cream,18,3610,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vt<int>ret;
        for(int i = 0; i + k <= sz(nums); i++){
            map<int, int>mp;
            for(int j = i; j < i + k; j++)mp[nums[j]]++;
            vt<pll>res;
            for(auto j: mp)res.pb(mpp(j.se, j.fi));
            sort(ALLR(res));
            ll ans = 0;
           
            for(int j = 0; j < min(x, sz(res)); j++){
               // cout << res[j].se << "" "" << res[j].fi << "" "";
                ans += 1LL * res[j].se * res[j].fi;
            }
            ret.pb(ans);
        }
        return(ret);
    }
};",1420520578
uwi,uwi,23,3509,java,"	class Solution {
		List<Integer> all = new ArrayList<>();

		public int kthLargestPerfectSubtree(TreeNode root, int k) {
			dfs(root);
			Collections.sort(all);
			k--;
			if(k >= all.size())return -1;
			return all.get(all.size() - 1 - k);
		}

		public int[] dfs(TreeNode cur)
		{
			if(cur == null)return new int[]{0, -1};
			int[] l = dfs(cur.left);
			int[] r = dfs(cur.right);
			int[] ret = {
					l[0] + r[0] + 1,
					Math.max(l[1], r[1]) + 1
			};
			if((1<<ret[1]+1)-1 == ret[0]){
				all.add(ret[0]);
			}
			return ret;
		}
	}
",1420524338
uwi,uwi,23,3588,java,"	class Solution {
		String U = ""FWE"";

		public int comp(char a, char b)
		{
			int ai = U.indexOf(a);
			int bi = U.indexOf(b);
			if((bi - ai + 3) % 3 == 1)return 1;
			if((bi - ai + 3) % 3 == 2)return -1;
			return 0;
		}

		public int countWinningSequences(String S) {
			char[] s = S.toCharArray();
			int n = s.length;
			// F E: F win
			// W F: W win
			// E W: E win
			final int mod = 1000000007;
			long[][] dp = new long[2*n+1][3];
			for(int i = 0;i < 3;i++){
				dp[n+comp(s[0], U.charAt(i))][i]++;
			}
			for(int i = 1;i < n;i++){
				long[][] ndp = new long[2*n+1][3];
				for(int j = 0;j <= 2*n;j++){
					for(int k = 0;k < 3;k++){
						if(dp[j][k] == 0)continue;
						for(int l = 0;l < 3;l++){
							if(k == l)continue;
							int nj = j + comp(s[i], U.charAt(l));
							ndp[nj][l] += dp[j][k];
							ndp[nj][l] %= mod;
						}
					}
				}
				dp = ndp;
			}
			int ans = 0;
			for(int i = n+1;i <= 2*n;i++){
				for(int j = 0;j < 3;j++){
					ans += dp[i][j];
					ans %= mod;
				}
			}
			return ans;
		}
	}
",1420532365
uwi,uwi,23,3592,java,"	class Solution {
		public long[] findXSum(int[] nums, int K, int X) {
			int n = nums.length;
			Node root = null;
			Map<Integer, Node> val = new HashMap<>();
			long[] ret = new long[n-K+1];
			for(int i = 0;i < n;i++){
				int v = nums[i];
				Node t = val.get(v);
				if(t == null){
					t = new Node(v, 1);
					val.put(v, t);
				}else{
					root = erase(root, index(t));
					t.f++;
					update(t);
				}
				root = insertb(root, t);

				if(i >= K-1) {
					ret[i-(K-1)] = sum(root, Math.max(count(root) - X, 0), count(root));

					Node u = val.get(nums[i-(K-1)]);
					root = erase(root, index(u));
					u.f--;
					update(u);
					root = insertb(root, u);
				}
			}
			return ret;
		}

		public static Random gen = new Random();

		static public class Node
		{
			public int f;
			public long v; // value
			public long priority;
			public Node left, right, parent;

			public int count;

			public long sum;

			public Node(int v, int f)
			{
				this.f = f;
				this.v = v;
				priority = gen.nextLong();
				update(this);
			}

			@Override
			public String toString() {
				StringBuilder builder = new StringBuilder();
				builder.append(""Node [v="");
				builder.append(v);
				builder.append("", f="");
				builder.append(f);
				builder.append("", count="");
				builder.append(count);
				builder.append("", parent="");
				builder.append(parent != null ? parent.v : ""null"");
				builder.append("", sum="");
				builder.append(sum);
				builder.append(""]"");
				return builder.toString();
			}
		}

		public static Node update(Node a)
		{
			if(a == null)return null;
			a.count = 1;
			if(a.left != null)a.count += a.left.count;
			if(a.right != null)a.count += a.right.count;

			a.sum = (long)a.v * a.f;
			if(a.left != null)a.sum += a.left.sum;
			if(a.right != null)a.sum += a.right.sum;
			return a;
		}

		public static Node disconnect(Node a)
		{
			if(a == null)return null;
			a.left = a.right = a.parent = null;
			return update(a);
		}

		public static Node root(Node x)
		{
			if(x == null)return null;
			while(x.parent != null)x = x.parent;
			return x;
		}

		public static int count(Node a)
		{
			return a == null ? 0 : a.count;
		}

		public static void setParent(Node a, Node par)
		{
			if(a != null)a.parent = par;
		}

		public static long sum(Node a, int L, int R)
		{
			if(a == null || L >= R || L >= count(a) || R <= 0)return 0L;
			if(L <= 0 && R >= count(a)){
				return a.sum;
			}else{
				long ret = 0;
				ret += sum(a.left, L, R);
				ret += sum(a.right, L-count(a.left)-1, R-count(a.left)-1);
				if(L <= count(a.left) && count(a.left) < R)ret += (long)a.v * a.f;
				return ret;
			}
		}

		public static Node merge(Node a, Node b)
		{
			if(b == null)return a;
			if(a == null)return b;
			if(a.priority > b.priority){
				setParent(a.right, null);
				setParent(b, null);
				a.right = merge(a.right, b);
				setParent(a.right, a);
				return update(a);
			}else{
				setParent(a, null);
				setParent(b.left, null);
				b.left = merge(a, b.left);
				setParent(b.left, b);
				return update(b);
			}
		}

		// [0,K),[K,N)
		public static Node[] split(Node a, int K)
		{
			if(a == null)return new Node[]{null, null};
			if(K <= count(a.left)){
				setParent(a.left, null);
				Node[] s = split(a.left, K);
				a.left = s[1];
				setParent(a.left, a);
				s[1] = update(a);
				return s;
			}else{
				setParent(a.right, null);
				Node[] s = split(a.right, K-count(a.left)-1);
				a.right = s[0];
				setParent(a.right, a);
				s[0] = update(a);
				return s;
			}
		}

		public static Node insert(Node a, int K, Node b)
		{
			if(a == null)return b;
			if(b.priority < a.priority){
				if(K <= count(a.left)){
					a.left = insert(a.left, K, b);
					setParent(a.left, a);
				}else{
					a.right = insert(a.right, K-count(a.left)-1, b);
					setParent(a.right, a);
				}
				return update(a);
			}else{
				Node[] ch = split(a, K);
				b.left = ch[0]; b.right = ch[1];
				setParent(b.left, b);
				setParent(b.right, b);
				return update(b);
			}
		}

		public static Node insertb(Node root, Node x)
		{
			int ind = search(root, (int)x.v, x.f);
			if(ind < 0){
				// insert
				ind = -ind-1;
				return insert(root, ind, x);
			}else{
				return insert(root, ind, x);

				//			// add
				//			Node t = get(root, ind);
				//			t.v += x.v;
				//			while(t != null){
				//				update(t);
				//				t = t.parent;
				//			}
				//			return root;
			}
		}

		// delete K-th
		public static Node erase(Node a, int K)
		{
			if(a == null)return null;
			if(K < count(a.left)){
				a.left = erase(a.left, K);
				setParent(a.left, a);
				return update(a);
			}else if(K == count(a.left)){
				setParent(a.left, null);
				setParent(a.right, null);
				Node aa = merge(a.left, a.right);
				disconnect(a);
				return aa;
			}else{
				a.right = erase(a.right, K-count(a.left)-1);
				setParent(a.right, a);
				return update(a);
			}
		}

		public static Node get(Node a, int K)
		{
			while(a != null){
				if(K < count(a.left)){
					a = a.left;
				}else if(K == count(a.left)){
					break;
				}else{
					K = K - count(a.left)-1;
					a = a.right;
				}
			}
			return a;
		}

//		public static int lowerBound(Node a, int q)
//		{
//			int lcount = 0;
//			while(a != null){
//				if(a.v >= q){
//					a = a.left;
//				}else{
//					lcount += count(a.left) + 1;
//					a = a.right;
//				}
//			}
//			return lcount;
//		}

		public static int search(Node a, int q, int f)
		{
			int lcount = 0;
			while(a != null){
				if(f == a.f && q == a.v){
					lcount += count(a.left);
					break;
				}
				if(f < a.f || f == a.f && q < a.v){
					a = a.left;
				}else{
					lcount += count(a.left) + 1;
					a = a.right;
				}
			}
			return a == null ? -(lcount+1) : lcount;
		}

		public static int index(Node a)
		{
			if(a == null)return -1;
			int ind = count(a.left);
			while(a != null){
				Node par = a.parent;
				if(par != null && par.right == a){
					ind += count(par.left) + 1;
				}
				a = par;
			}
			return ind;
		}

		public static Node[] nodes(Node a) { return nodes(a, new Node[count(a)], 0, count(a)); }
		public static Node[] nodes(Node a, Node[] ns, int L, int R)
		{
			if(a == null)return ns;
			nodes(a.left, ns, L, L+count(a.left));
			ns[L+count(a.left)] = a;
			nodes(a.right, ns, R-count(a.right), R);
			return ns;
		}

		public static String toString(Node a, String indent)
		{
			if(a == null)return """";
			StringBuilder sb = new StringBuilder();
			sb.append(toString(a.left, indent + ""  ""));
			sb.append(indent).append(a).append(""\n"");
			sb.append(toString(a.right, indent + ""  ""));
			return sb.toString();
		}

	}
",1420554403
uwi,uwi,23,3610,java,"	class Solution {
		public int[] findXSum(int[] nums, int k, int x) {
			int n = nums.length;
			int[] ret = new int[n-k+1];
			for(int i = 0;i+k <= n;i++){
				int[] f = new int[51];
				for(int j = i;j < i+k;j++){
					f[nums[j]]++;
				}
				int[][] fi = new int[51][];
				for(int j = 0;j < 51;j++){
					fi[j] = new int[]{f[j], j};
				}
				Arrays.sort(fi, (z ,y) -> {
					if(z[0] != y[0])return -(z[0] - y[0]);
					return -(z[1] - y[1]);
				});
				int s = 0;
				for(int j = 0;j < x;j++){
					s += fi[j][0] * fi[j][1];
				}
				ret[i] = s;
			}
			return ret;
		}
	}
",1420520208
lqCKWBPxHc,lqCKWBPxHc,24,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(node):
            if not node:
                return (True, 0, 0)

            if not node.left and not node.right:
                subtree_sizes.append(1)
                return (True, 1, 1)

            left_perfect, left_height, left_size = dfs(node.left) if node.left else (True, 0, 0)
            right_perfect, right_height, right_size = dfs(node.right) if node.right else (True, 0, 0)

            if left_perfect and right_perfect and left_height == right_height:
                current_size = 1 + left_size + right_size
                subtree_sizes.append(current_size)
                return (True, left_height + 1, current_size)

            return (False, max(left_height, right_height) + 1, 0)

        subtree_sizes = []
        dfs(root)

        if len(subtree_sizes) < k:
            return -1

        subtree_sizes.sort(reverse=True)
        return subtree_sizes[k-1]",1420532889
lqCKWBPxHc,lqCKWBPxHc,24,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        creature_to_number = {'F':1, 'W':2, 'E':3}
        DP = [[[0]*(2*n+1) for _ in range(4)] for _ in range(n+1)]
        DP[0][0][n] = 1
        for i in range(n):
            s_i = s[i]
            c_alice = creature_to_number[s_i]
            for b in range(4):
                for d in range(2*n+1):
                    val = DP[i][b][d]
                    if val == 0:
                        continue
                    for c in range(1,4):
                        if c == b:
                            continue
                        if c == c_alice:
                            score = 0
                        elif (c - c_alice + 3) % 3 == 1:
                            score = 1
                        else:
                            score = -1
                        d_new = d + score
                        if 0 <= d_new <= 2*n:
                            DP[i+1][c][d_new] = (DP[i+1][c][d_new] + val) % MOD
        ans = 0
        for b in range(1,4):
            for d in range(n+1, 2*n+1):
                ans = (ans + DP[n][b][d]) % MOD
        return ans",1420529030
lqCKWBPxHc,lqCKWBPxHc,24,3592,python3,"from sortedcontainers import SortedList
class Solution:
    class Node:
        def __init__(self, key, cnt_value):
            self.key = key  # (count, value)
            self.left = None
            self.right = None
            self.priority = random.random()
            self.size = 1
            self.sum = cnt_value
            self.cnt_value = cnt_value

    def update(self, node):
        if node:
            node.size = 1
            node.sum = node.cnt_value
            if node.left:
                node.size += node.left.size
                node.sum += node.left.sum
            if node.right:
                node.size += node.right.size
                node.sum += node.right.sum

    def split(self, root, key):
        if not root:
            return (None, None)
        if root.key > key:
            left, right = self.split(root.left, key)
            root.left = right
            self.update(root)
            return (left, root)
        else:
            left, right = self.split(root.right, key)
            root.right = left
            self.update(root)
            return (root, right)

    def merge(self, left, right):
        if not left or not right:
            return left or right
        if left.priority > right.priority:
            left.right = self.merge(left.right, right)
            self.update(left)
            return left
        else:
            right.left = self.merge(left, right.left)
            self.update(right)
            return right

    def insert(self, root, node):
        if not root:
            return node
        if node.priority > root.priority:
            left, right = self.split(root, node.key)
            node.left = left
            node.right = right
            self.update(node)
            return node
        elif node.key < root.key:
            root.left = self.insert(root.left, node)
        else:
            root.right = self.insert(root.right, node)
        self.update(root)
        return root

    def remove(self, root, key):
        if not root:
            return None
        if root.key == key:
            return self.merge(root.left, root.right)
        elif key < root.key:
            root.left = self.remove(root.left, key)
        else:
            root.right = self.remove(root.right, key)
        self.update(root)
        return root

    def sum_first_k(self, root, k):
        if not root or k <= 0:
            return 0
        if root.left:
            if root.left.size >= k:
                return self.sum_first_k(root.left, k)
            else:
                res = root.left.sum + root.cnt_value
                rem = k - root.left.size - 1
                res += self.sum_first_k(root.right, rem)
                return res
        else:
            if k == 1:
                return root.cnt_value
            else:
                res = root.cnt_value + self.sum_first_k(root.right, k - 1)
                return res
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        root = None
        counts = {}
        ans = []


        for i in range(k):
            num = nums[i]
            if num in counts:
                count = counts[num]
                key = (-count, -num)
                root = self.remove(root, key)
                counts[num] += 1
                count += 1
            else:
                counts[num] = 1
                count = 1
            key = (-count, -num)
            node = self.Node(key, count * num)
            root = self.insert(root, node)

        total = self.sum_first_k(root, x)
        ans.append(total)

        for i in range(k, len(nums)):
            out_num = nums[i - k]
            in_num = nums[i]


            count = counts[out_num]
            key = (-count, -out_num)
            root = self.remove(root, key)
            counts[out_num] -= 1
            count -= 1
            if count > 0:
                key = (-count, -out_num)
                node = self.Node(key, count * out_num)
                root = self.insert(root, node)
            else:
                del counts[out_num]


            if in_num in counts:
                count = counts[in_num]
                key = (-count, -in_num)
                root = self.remove(root, key)
                counts[in_num] += 1
                count += 1
            else:
                counts[in_num] = 1
                count = 1
            key = (-count, -in_num)
            node = self.Node(key, count * in_num)
            root = self.insert(root, node)


            total = self.sum_first_k(root, x)
            ans.append(total)

        return ans
        ",1420541831
lqCKWBPxHc,lqCKWBPxHc,24,3610,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        counts = defaultdict(int)
        sorted_elements = SortedList()
        answer = []

        for i in range(k):
            element = nums[i]
            counts[element] += 1

        for element, freq in counts.items():
            sorted_elements.add((-freq, -element))

        def calculate_x_sum():
            total_elements = 0
            x_sum = 0
            for freq, element in sorted_elements:
                element = -element
                freq = -freq
                x_sum += counts[element] * element
                total_elements += 1
                if total_elements == x:
                    break
            return x_sum

        x_sum = calculate_x_sum()
        answer.append(x_sum)

        for i in range(n - k):
            left_element = nums[i]
            right_element = nums[i + k]

            old_freq = counts[left_element]
            sorted_elements.discard((-old_freq, -left_element))
            counts[left_element] -= 1
            if counts[left_element] == 0:
                del counts[left_element]
            else:
                new_freq = counts[left_element]
                sorted_elements.add((-new_freq, -left_element))

            if right_element in counts:
                old_freq = counts[right_element]
                sorted_elements.discard((-old_freq, -right_element))
                counts[right_element] += 1
            else:
                counts[right_element] = 1
            new_freq = counts[right_element]
            sorted_elements.add((-new_freq, -right_element))

            x_sum = calculate_x_sum()
            answer.append(x_sum)

        return answer",1420519488
LayCurse,LayCurse,25,3509,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template<class T> using cLtraits_try_make_unsigned =
  typename conditional<
    is_integral<T>::value,
    make_unsigned<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmin(S &a, T b){
  if(a>b){
    a=b;
  }
  return a;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
template<class S, class T> inline S divup_L(S a, T b){
  return (a+b-1)/b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
inline int Ilog2_f_L(const int n){
  int res;
  if(n <= 0){
    return -1;
  }
  res = sizeof(int) * 8 - __builtin_clz(n) - 1;
  return res;
}
inline int Ilog2_f_L(const long long n){
  int res;
  if(n <= 0){
    return -1;
  }
  res = sizeof(long long) * 8 - __builtin_clzll(n) - 1;
  return res;
}
template<class T1> void sortI(int N, T1 a[], void *mem = wmem){
  sort(a, a+N);
}
template<class T1, class T2> void sortI(int N, T1 a[], T2 b[], void *mem = wmem){
  int i;
  pair<T1, T2>*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first = a[i];
    arr[i].second = b[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first;
    b[i] = arr[i].second;
  }
}
template<class T1, class T2, class T3> void sortI(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){
  int i;
  pair<T1, pair<T2, T3> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first = a[i];
    arr[i].second.first = b[i];
    arr[i].second.second = c[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first;
    b[i] = arr[i].second.first;
    c[i] = arr[i].second.second;
  }
}
template<class T1, class T2, class T3, class T4> void sortI(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){
  int i;
  pair<pair<T1, T2>, pair<T3, T4> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first.first = a[i];
    arr[i].first.second = b[i];
    arr[i].second.first = c[i];
    arr[i].second.second = d[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first.first;
    b[i] = arr[i].first.second;
    c[i] = arr[i].second.first;
    d[i] = arr[i].second.second;
  }
}
template<class T> inline int sort_helper_getbit(T A[]){
  return -1;
}
template<> inline int sort_helper_getbit(int A[]){
  return sizeof(int)*8;
}
template<> inline int sort_helper_getbit(unsigned A[]){
  return sizeof(unsigned)*8;
}
template<> inline int sort_helper_getbit(long long A[]){
  return sizeof(long long)*8;
}
template<> inline int sort_helper_getbit(unsigned long long A[]){
  return sizeof(unsigned long long)*8;
}
template<> inline int sort_helper_getbit(char A[]){
  return sizeof(char)*8;
}
template<class T> void sortA_1_int_L(int N, T A[], void *mem = wmem){
  int i;
  int j;
  int k;
  int b;
  int s;
  int ok;
  ok = 1;
  for(i=(1);i<(N);i++){
    if(A[i-1] > A[i]){
      ok = 0;
      break;
    }
  }
  if(ok){
    return;
  }
  if(N < 128){
    sort(A,A+N);
    return;
  }
  b = sort_helper_getbit(A);
  if(b==-1){
    sort(A,A+N);
    return;
  }
  T mn;
  T mx;
  mn = mx = A[0];
  for(i=(1);i<(N);i++){
    chmin(mn, A[i]);
  }
  for(i=(1);i<(N);i++){
    chmax(mx, A[i]);
  }
  ok = 1;
  if(mn < 0 && mx > 0 && (mn < -N || mx > N)){
    ok = 0;
  }
  if(ok && mx - mn > N){
    ok = 0;
  }
  if(ok){
    int*tmp;
    walloc1d(&tmp, mx-mn+1, &mem);
    for(i=(0);i<(mx-mn+1);i++){
      tmp[i] = 0;
    }
    for(i=(0);i<(N);i++){
      tmp[A[i]-mn]++;
    }
    k = 0;
    for(i=(0);i<(mx-mn+1);i++){
      while(tmp[i] > 0){
        tmp[i]--;
        A[k++] = i+mn;
      }
    }
    return;
  }
  {
    typename make_unsigned<T>::type *t[2];
    typename make_unsigned<T>::type  mask;
    typename make_unsigned<T>::type  cur;
    typename make_unsigned<T>::type  one = 1;
    T tone = 1;
    int*pos;
    int nn = 0;
    int ss;
    s =Ilog2_f_L(N);
    if(s > 8){
      s = (8 + (s-7)/2);
    }
    ss = 1;
    for(;;){
      if(ss >= b){
        break;
      }
      if( mx >= 0 && (tone << (ss-1)) < mx ){
        ss++;
        continue;
      }
      if( mn < 0 && -(tone << (ss-1)) >= mn ){
        ss++;
        continue;
      }
      break;
    }
    k =(divup_L(ss,s));
    s =(divup_L(ss,k));
    mask = 0;
    for(i=(0);i<(b);i++){
      if(i < s*k){
        mask |= one << i;
      }
    }
    t[0] = (typename make_unsigned<T>::type *) A;
    walloc1d(&t[1], N, &mem);
    walloc1d(&pos, (1<<s)+1, &mem);
    for(j=(0);j<(k);j++){
      cur = 0;
      for(i=(0);i<(b);i++){
        if(s*j <= i && i < s*(j+1) && i < b){
          cur |= one << i;
        }
      }
      for(i=(0);i<((1<<s)+1);i++){
        pos[i] = 0;
      }
      for(i=(0);i<(N);i++){
        pos[((t[nn][i]&cur)>>(s*j))+1]++;
      }
      for(i=(0);i<((1<<s));i++){
        pos[i+1] += pos[i];
      }
      for(i=(0);i<(N);i++){
        t[nn^1][pos[(t[nn][i]&cur)>>(s*j)]++] = t[nn][i];
      }
      nn ^= 1;
      mask ^= cur;
    }
    if(mn < 0 && mx >= 0){
      k = 0;
      for(i=(0);i<(N);i++){
        if(A[i] < 0){
          k++;
        }
      }
      for(i=(0);i<(k);i++){
        t[nn^1][i] = t[nn][N-k+i];
      }
      for(i=(k);i<(N);i++){
        t[nn^1][i] = t[nn][i-k];
      }
      nn ^= 1;
    }
    if(nn==1){
      for(i=(0);i<(N);i++){
        t[0][i] = t[1][i];
      }
    }
    return;
  }
  sort(A, A+N);
}
template<class T> void sortA_1_nonint_L(int N, T A[], void *mem = wmem){
  sort(A,A+N);
}
template<class T> void sortA_1_call_L(int N, T A[], void *mem = wmem){
  sortA_1_nonint_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, int A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, unsigned A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, long long A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, unsigned long long A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<> void sortA_1_call_L(int N, char A[], void *mem){
  sortA_1_int_L(N, A, mem);
}
template<class T1> void sortA(int N, T1 a[], void *mem = wmem){
  sortA_1_call_L(N, a, mem);
}
template<class T1, class T2> void sortA_2_int_L(int N, T1 A[], T2 B[], void *mem = wmem){
  int i;
  int b_a;
  int b_b;
  int s1;
  int s2;
  int so2;
  T1 mn1;
  T1 mx1;
  T2 mn2;
  T2 mx2;
  typename cLtraits_try_make_unsigned<T1>::type r1;
  typename cLtraits_try_make_unsigned<T2>::type r2;
  so2 = 1;
  for(i=(1);i<(N);i++){
    if(A[i-1] > A[i] || (A[i-1]==A[i] && B[i-1] > B[i])){
      so2 = 0;
      break;
    }
  }
  if(so2){
    return;
  }
  so2 = 1;
  for(i=(1);i<(N);i++){
    if(A[i-1] > A[i]){
      so2 = 0;
      break;
    }
  }
  if(so2==1){
    int k = 0;
    for(i=(1);i<(N);i++){
      if(A[i] != A[i-1]){
        sortA_1_call_L(i-k, B+k, mem);
        k = i;
      }
    }
    sortA_1_call_L(N-k, B+k, mem);
    return;
  }
  if(N < 128){
    sortI(N,A,B,mem);
    return;
  }
  b_a = sort_helper_getbit(A);
  b_b = sort_helper_getbit(B);
  if(b_a == -1 || b_b == -1){
    sortI(N,A,B,mem);
    return;
  }
  mn1 = mx1 = A[0];
  for(i=(1);i<(N);i++){
    chmin(mn1, A[i]);
  }
  for(i=(1);i<(N);i++){
    chmax(mx1, A[i]);
  }
  mn2 = mx2 = B[0];
  for(i=(1);i<(N);i++){
    chmin(mn2, B[i]);
  }
  for(i=(1);i<(N);i++){
    chmax(mx2, B[i]);
  }
  if(mn1 < -4611686016279904256LL || mn2 < -4611686016279904256LL || mx1 > 4611686016279904256LL || mx2 > 4611686016279904256LL || mx1-mn1 > 4611686016279904256LL || mx2-mn2 > 4611686016279904256LL){
    sortI(N,A,B,mem);
    return;
  }
  r1 = (typename cLtraits_try_make_unsigned<T1>::type)(mx1) - (typename cLtraits_try_make_unsigned<T1>::type)(mn1);
  r2 = (typename cLtraits_try_make_unsigned<T2>::type)(mx2) - (typename cLtraits_try_make_unsigned<T2>::type)(mn2);
  if(r1 == 0){
    sortA_1_call_L(N, B, mem);
    return;
  }
  if(r2 == 0){
    sortA_1_call_L(N, A, mem);
    return;
  }
  if(r1 <= N){
    so2 = 1;
    for(i=(1);i<(N);i++){
      if(B[i-1] > B[i]){
        so2 = 0;
        break;
      }
    }
    if(so2 == 1){
      T1*aa;
      T2*bb;
      int*pos;
      int k;
      walloc1d(&aa,N,&mem);
      walloc1d(&bb,N,&mem);
      walloc1d(&pos,r1+2,&mem);
      for(i=(0);i<(r1+2);i++){
        pos[i] = 0;
      }
      for(i=(0);i<(N);i++){
        aa[i] = A[i];
      }
      for(i=(0);i<(N);i++){
        bb[i] = B[i];
      }
      for(i=(0);i<(N);i++){
        pos[(typename cLtraits_try_make_unsigned<T1>::type)((typename cLtraits_try_make_unsigned<T1>::type)aa[i]-(typename cLtraits_try_make_unsigned<T1>::type)mn1)+1]++;
      }
      for(i=(1);i<(r1+2);i++){
        pos[i] += pos[i-1];
      }
      for(i=(0);i<(N);i++){
        k = pos[(typename cLtraits_try_make_unsigned<T1>::type)((typename cLtraits_try_make_unsigned<T1>::type)aa[i]-(typename cLtraits_try_make_unsigned<T1>::type)mn1)+0]++;
        A[k] = aa[i];
        B[k] = bb[i];
      }
      return;
    }
  }
  s1 = s2 = 1;
  while( s1 < 64 && r1 >= (1ULL<<s1) ){
    s1++;
  }
  while( s2 < 64 && r2 >= (1ULL<<s2) ){
    s2++;
  }
  if(s1 + s2 <= 32){
    unsigned*tmp;
    walloc1d(&tmp,N,&mem);
    for(i=(0);i<(N);i++){
      tmp[i] = (((unsigned)((int)A[i]-(int)mn1)) << s2) | ((unsigned)((int)B[i]-(int)mn2));
    }
    sortA_1_call_L(N, tmp, mem);
    for(i=(0);i<(N);i++){
      A[i] = ((int)(tmp[i] >> s2)) + ((int)mn1);
      B[i] = ((int)(tmp[i] & ((1U<<s2)-1))) + ((int)mn2);
    }
    return;
  }
  if(s1 + s2 <= 64){
    unsigned long long*tmp;
    walloc1d(&tmp,N,&mem);
    for(i=(0);i<(N);i++){
      tmp[i] = (((unsigned long long)((long long)A[i]-(long long)mn1)) << s2) | ((unsigned long long)((long long)B[i]-(long long)mn2));
    }
    sortA_1_call_L(N, tmp, mem);
    for(i=(0);i<(N);i++){
      A[i] = ((long long)(tmp[i] >> s2)) + ((long long)mn1);
      B[i] = ((long long)(tmp[i] & ((1ULL<<s2)-1))) + ((long long)mn2);
    }
    return;
  }
  sortI(N,A,B,mem);
}
template<class T1, class T2> void sortA_2_nonint_L(int N, T1 A[], T2 B[], void *mem = wmem){
  sortI(N,A,B,mem);
}
template<class T1, class T2> void sortA_2_call_L(int N, T1 A[], T2 B[], void *mem = wmem){
  sortA_2_nonint_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, int A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, unsigned A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, long long A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, unsigned long long A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T2> void sortA_2_call_L(int N, char A[], T2 B[], void *mem){
  sortA_2_int_L(N, A, B, mem);
}
template<class T1, class T2> void sortA(int N, T1 a[], T2 b[], void *mem = wmem){
  sortA_2_call_L(N, a, b, mem);
}
template<class T1, class T2, class T3> void sortA(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){
  int i;
  pair<T1, pair<T2, T3> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first = a[i];
    arr[i].second.first = b[i];
    arr[i].second.second = c[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first;
    b[i] = arr[i].second.first;
    c[i] = arr[i].second.second;
  }
}
template<class T1, class T2, class T3, class T4> void sortA(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){
  int i;
  pair<pair<T1, T2>, pair<T3, T4> >*arr;
  walloc1d(&arr, N, &mem);
  for(i=(0);i<(N);i++){
    arr[i].first.first = a[i];
    arr[i].first.second = b[i];
    arr[i].second.first = c[i];
    arr[i].second.second = d[i];
  }
  sort(arr, arr+N);
  for(i=(0);i<(N);i++){
    a[i] = arr[i].first.first;
    b[i] = arr[i].first.second;
    c[i] = arr[i].second.first;
    d[i] = arr[i].second.second;
  }
}
template<class T1> void rsortA(int N, T1 a[], void *mem = wmem){
  sortA(N, a, mem);
  reverse(a, a+N);
}
template<class T1, class T2> void rsortA(int N, T1 a[], T2 b[], void *mem = wmem){
  sortA(N, a, b, mem);
  reverse(a, a+N);
  reverse(b, b+N);
}
template<class T1, class T2, class T3> void rsortA(int N, T1 a[], T2 b[], T3 c[], void *mem = wmem){
  sortA(N, a, b, c, mem);
  reverse(a, a+N);
  reverse(b, b+N);
  reverse(c, c+N);
}
template<class T1, class T2, class T3, class T4> void rsortA(int N, T1 a[], T2 b[], T3 c[], T4 d[], void *mem = wmem){
  sortA(N, a, b, c, d, mem);
  reverse(a, a+N);
  reverse(b, b+N);
  reverse(c, c+N);
  reverse(d, d+N);
}
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main

int ress;
int res[1000000];
void solve(TreeNode *a, int &mn, int &mx){
  int x1;
  int y1;
  int x2;
  int y2;
  if(a == NULL){
    mn = mx = 0;
    return;
  }
  solve(a->left, x1, y1);
  solve(a->right, x2, y2);
  mn =min_L(x1, x2)+1;
  mx =max_L(y1, y2)+1;
  if(mn == mx){
    res[ress++] = mn;
  }
}
class Solution{
  public:
  int kthLargestPerfectSubtree(TreeNode* root, int k){
    dummy_main();
    k--;
    ress = 0;
    int x;
    int y;
    solve(root,x,y);
    if(ress <= k){
      return -1;
    }
    rsortA(ress, res);
    return (1<<res[k])-1;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// struct TreeNode {
//   int val;
//   TreeNode *left;
//   TreeNode *right;
//   TreeNode() : val(0), left(nullptr), right(nullptr) {}
//   TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
//   TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
// };
// 
// int ress, res[1d6];
// 
// void solve(TreeNode *a, int &mn, int &mx){
//   int x1, y1, x2, y2;
// 
//   if(a == NULL){
//     mn = mx = 0;
//     return;
//   }
// 
//   solve(a->left, x1, y1);
//   solve(a->right, x2, y2);
// 
//   mn = min(x1,x2)+1;
//   mx = max(y1,y2)+1;
//   if(mn == mx) res[ress++] = mn;
// }
// 
// class Solution {
// public:
//   int kthLargestPerfectSubtree(TreeNode* root, int k) {
//     dummy_main();
// 
//     k--;
//     ress = 0;
// 
//     int x, y;
//     solve(root,x,y);
// 
//     if(ress <= k) return -1;
//     rsortA(ress, res);
//     return (1<<res[k])-1;
//   }
// };",1420521399
LayCurse,LayCurse,25,3588,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
template<class S, class T> inline S moddw_L(S a, const T b){
  a %= b;
  if(a < 0){
    a += b;
  }
  return a;
}
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int countWinningSequences(string s){
    static int N;
    static int A[1100];
    static Modint dp[4][2100];
    static Modint nx[4][2100];
    int i;
    int j;
    int k;
    int g;
    Modint res = 0;
    N = s.size();
    for(i=(0);i<(N);i++){
      if(s[i]=='F'){
        A[i] =0;
      }
      else if(s[i]=='W'){
        A[i] =1;
      }
      else{
        A[i] =2;
      }
    }
    g = N + 5;
    for(k=(0);k<(4);k++){
      for(i=(0);i<(2*g);i++){
        dp[k][i] = 0;
      }
    }
    dp[3][g] = 1;
    for(k=(0);k<(N);k++){
      for(j=(0);j<(4);j++){
        for(i=(0);i<(2*g);i++){
          nx[j][i] = 0;
        }
      }
      for(j=(0);j<(4);j++){
        for(i=(0);i<(2*g);i++){
          if(dp[j][i]){
            int m;
            for(m=(0);m<(3);m++){
              if(m!=j){
                if((moddw_L((A[k]-m),3))== 0 ){
                  nx[m][i] += dp[j][i];
                }
                if((moddw_L((A[k]-m),3))== 1 ){
                  nx[m][i-1] += dp[j][i];
                }
                if((moddw_L((A[k]-m),3))== 2 ){
                  nx[m][i+1] += dp[j][i];
                }
              }
            }
          }
        }
      }
      for(j=(0);j<(4);j++){
        for(i=(0);i<(2*g);i++){
          dp[j][i] = nx[j][i];
        }
      }
    }
    for(k=(0);k<(4);k++){
      for(i=(g+1);i<(2*g);i++){
        res +=dp[k][i];
      }
    }
    return res;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int countWinningSequences(string s) {
//     static int N, A[1100];
//     static Modint dp[4][2100], nx[4][2100];
//     int i, j, k, g;
//     Modint res = 0;
// 
//     N = s.size();
//     rep(i,N) A[i] = if[s[i]=='F', 0, s[i]=='W', 1, 2];
// 
//     g = N + 5;
//     rep(k,4) rep(i,2*g) dp[k][i] = 0;
//     dp[3][g] = 1;
// 
//     rep(k,N){
//       rep(j,4) rep(i,2*g) nx[j][i] = 0;
//       rep(j,4) rep(i,2*g) if(dp[j][i]) rep(m,3) if(m!=j){
//         if( (A[k]-m)%%3 == 0 ) nx[m][i] += dp[j][i];
//         if( (A[k]-m)%%3 == 1 ) nx[m][i-1] += dp[j][i];
//         if( (A[k]-m)%%3 == 2 ) nx[m][i+1] += dp[j][i];
//       }
//       rep(j,4) rep(i,2*g) dp[j][i] = nx[j][i];
//     }
// 
//     rep(k,4) rep(i,g+1,2*g) res +=dp[k][i];
//     return res;
//   }
// };
",1420527973
LayCurse,LayCurse,25,3592,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> struct twoMultisets{
  multiset<T> a;
  multiset<T> b;
  T sa;
  T sb;
  twoMultisets(){
    clear();
  }
  void clear(){
    a.clear();
    b.clear();
    sa = sb = 0;
  }
  void insert(T x){
    if(b.size() == 0 || x < *b.begin()){
      a.insert(x);
      sa += x;
    }
    else{
      b.insert(x);
      sb += x;
    }
  }
  int erase(T x){
    typename multiset<T>::iterator it;
    it = a.find(x);
    if(it != a.end()){
      a.erase(it);
      sa -= x;
      return 1;
    }
    it = b.find(x);
    if(it != b.end()){
      b.erase(it);
      sb -= x;
      return 1;
    }
    return 0;
  }
  int size(void){
    return a.size() + b.size();
  }
  T allsum(void){
    return sa + sb;
  }
  void assign(int K){
    T x;
    typename multiset<T>::iterator it;
    while(a.size() < K){
      x = *b.begin();
      b.erase(b.begin());
      a.insert(x);
      sa += x;
      sb -= x;
    }
    while(a.size() > K){
      it = a.end();
      it--;
      x = *it;
      a.erase(it);
      b.insert(x);
      sa -= x;
      sb += x;
    }
  }
  T Kth(int K){
    assign(K);
    return *b.begin();
  }
  T Ksum(int K){
    assign(K);
    return sa;
  }
  T rKth(int K){
    return Kth(a.size() + b.size() - K - 1);
  }
  T rKsum(int K){
    assign(a.size() + b.size() - K);
    return sb;
  }
  T getMin(void){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return 0;
  }
  T getMin(T x){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return x;
  }
  T getMax(void){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return 0;
  }
  T getMax(T x){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return x;
  }
}
;
#define main dummy_main
int main(){
  return 0;
}
#undef main
void do_add(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt = 0;
  if(mp.count(v)){
    cnt = mp[v];
    s.erase({cnt,v});
    m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  }
  cnt++;
  mp[v] = cnt;
  s.insert({cnt,v});
  m.insert(__int128_t(cnt)*(v+100000000000000000LL));
}
void do_del(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt;
  cnt = mp[v];
  mp.erase(v);
  s.erase({cnt,v});
  m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  cnt--;
  if(cnt){
    mp[v] = cnt;
    s.insert({cnt,v});
    m.insert(__int128_t(cnt)*(v+100000000000000000LL));
  }
}
long long do_get(twoMultisets<__int128_t> &m, int x){
  int k;
  k =min_L(x, m.size());
  return m.rKsum(k)%100000000000000000LL;
}
class Solution{
  public:
  vector<long long> findXSum(vector<int>& A, int K, int x){
    int i;
    int N = A.size();
    set<pair<int,long long>> s;
    map<long long,int> mp;
    twoMultisets<__int128_t> m;
    vector<long long> res;
    for(i=(0);i<(K);i++){
      do_add(s,mp,m,A[i]);
    }
    res.push_back(do_get(m,x));
    for(i=(K);i<(N);i++){
      do_del(s,mp,m,A[i-K]);
      do_add(s,mp,m,A[i]);
      res.push_back(do_get(m,x));
    }
    return res;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// void do_add(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt = 0;
// 
//   if(mp.count(v)){
//     cnt = mp[v];
//     s.erase({cnt,v});
//     m.erase(__int128_t(cnt)*(v+1d17));
//   }
// 
//   cnt++;
//   mp[v] = cnt;
//   s.insert({cnt,v});
//   m.insert(__int128_t(cnt)*(v+1d17));
// }
// 
// void do_del(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt;
// 
//   cnt = mp[v];
//   mp.erase(v);
//   s.erase({cnt,v});
//   m.erase(__int128_t(cnt)*(v+1d17));
// 
//   cnt--;
//   if(cnt){
//     mp[v] = cnt;
//     s.insert({cnt,v});
//     m.insert(__int128_t(cnt)*(v+1d17));
//   }
// }
// 
// ll do_get(twoMultisets<__int128_t> &m, int x){
//   int k;
//   k = min(x,m.size());
//   return m.rKsum(k)%1d17;
// }
// 
// class Solution {
// public:
//   vector<long long> findXSum(vector<int>& A, int K, int x) {
//     int N = A.size();
// 
//     set<pair<int,ll>> s;
//     map<ll,int> mp;
//     twoMultisets<__int128_t> m;
//     vector<ll> res;
// 
//     rep(i,K) do_add(s,mp,m,A[i]);
//     res.push_back(do_get(m,x));
//     rep(i,K,N){
//       do_del(s,mp,m,A[i-K]);
//       do_add(s,mp,m,A[i]);
//       res.push_back(do_get(m,x));
//     }
// 
//     return res;
//   }
// };
",1420547573
LayCurse,LayCurse,25,3610,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> struct twoMultisets{
  multiset<T> a;
  multiset<T> b;
  T sa;
  T sb;
  twoMultisets(){
    clear();
  }
  void clear(){
    a.clear();
    b.clear();
    sa = sb = 0;
  }
  void insert(T x){
    if(b.size() == 0 || x < *b.begin()){
      a.insert(x);
      sa += x;
    }
    else{
      b.insert(x);
      sb += x;
    }
  }
  int erase(T x){
    typename multiset<T>::iterator it;
    it = a.find(x);
    if(it != a.end()){
      a.erase(it);
      sa -= x;
      return 1;
    }
    it = b.find(x);
    if(it != b.end()){
      b.erase(it);
      sb -= x;
      return 1;
    }
    return 0;
  }
  int size(void){
    return a.size() + b.size();
  }
  T allsum(void){
    return sa + sb;
  }
  void assign(int K){
    T x;
    typename multiset<T>::iterator it;
    while(a.size() < K){
      x = *b.begin();
      b.erase(b.begin());
      a.insert(x);
      sa += x;
      sb -= x;
    }
    while(a.size() > K){
      it = a.end();
      it--;
      x = *it;
      a.erase(it);
      b.insert(x);
      sa -= x;
      sb += x;
    }
  }
  T Kth(int K){
    assign(K);
    return *b.begin();
  }
  T Ksum(int K){
    assign(K);
    return sa;
  }
  T rKth(int K){
    return Kth(a.size() + b.size() - K - 1);
  }
  T rKsum(int K){
    assign(a.size() + b.size() - K);
    return sb;
  }
  T getMin(void){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return 0;
  }
  T getMin(T x){
    if(a.size()){
      return *a.begin();
    }
    if(b.size()){
      return *b.begin();
    }
    return x;
  }
  T getMax(void){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return 0;
  }
  T getMax(T x){
    if(b.size()){
      return *b.rbegin();
    }
    if(a.size()){
      return *a.rbegin();
    }
    return x;
  }
}
;
#define main dummy_main
int main(){
  return 0;
}
#undef main
void do_add(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt = 0;
  if(mp.count(v)){
    cnt = mp[v];
    s.erase({cnt,v});
    m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  }
  cnt++;
  mp[v] = cnt;
  s.insert({cnt,v});
  m.insert(__int128_t(cnt)*(v+100000000000000000LL));
}
void do_del(set<pair<int,long long>> &s, map<long long,int> &mp, twoMultisets<__int128_t> &m, long long v){
  int cnt;
  cnt = mp[v];
  mp.erase(v);
  s.erase({cnt,v});
  m.erase(__int128_t(cnt)*(v+100000000000000000LL));
  cnt--;
  if(cnt){
    mp[v] = cnt;
    s.insert({cnt,v});
    m.insert(__int128_t(cnt)*(v+100000000000000000LL));
  }
}
long long do_get(twoMultisets<__int128_t> &m, int x){
  int k;
  k =min_L(x, m.size());
  return m.rKsum(k)%100000000000000000LL;
}
class Solution{
  public:
  vector<int> findXSum(vector<int>& A, int K, int x){
    int i;
    int N = A.size();
    set<pair<int,long long>> s;
    map<long long,int> mp;
    twoMultisets<__int128_t> m;
    vector<int> res;
    for(i=(0);i<(K);i++){
      do_add(s,mp,m,A[i]);
    }
    res.push_back(do_get(m,x));
    for(i=(K);i<(N);i++){
      do_del(s,mp,m,A[i-K]);
      do_add(s,mp,m,A[i]);
      res.push_back(do_get(m,x));
    }
    return res;
  }
}
;
// cLay version 20240810-1 [beta]

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// void do_add(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt = 0;
// 
//   if(mp.count(v)){
//     cnt = mp[v];
//     s.erase({cnt,v});
//     m.erase(__int128_t(cnt)*(v+1d17));
//   }
// 
//   cnt++;
//   mp[v] = cnt;
//   s.insert({cnt,v});
//   m.insert(__int128_t(cnt)*(v+1d17));
// }
// 
// void do_del(set<pair<int,ll>> &s, map<ll,int> &mp, twoMultisets<__int128_t> &m, ll v){
//   int cnt;
// 
//   cnt = mp[v];
//   mp.erase(v);
//   s.erase({cnt,v});
//   m.erase(__int128_t(cnt)*(v+1d17));
// 
//   cnt--;
//   if(cnt){
//     mp[v] = cnt;
//     s.insert({cnt,v});
//     m.insert(__int128_t(cnt)*(v+1d17));
//   }
// }
// 
// ll do_get(twoMultisets<__int128_t> &m, int x){
//   int k;
//   k = min(x,m.size());
//   return m.rKsum(k)%1d17;
// }
// 
// class Solution {
// public:
//   vector<int> findXSum(vector<int>& A, int K, int x) {
//     int N = A.size();
// 
//     set<pair<int,ll>> s;
//     map<ll,int> mp;
//     twoMultisets<__int128_t> m;
//     vector<int> res;
// 
//     rep(i,K) do_add(s,mp,m,A[i]);
//     res.push_back(do_get(m,x));
//     rep(i,K,N){
//       do_del(s,mp,m,A[i-K]);
//       do_add(s,mp,m,A[i]);
//       res.push_back(do_get(m,x));
//     }
// 
//     return res;
//   }
// };
",1420548325
Nguyễn Thảo,nguyenquocthao00,28,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        data=[]
        def dp(node):
            if not node: return 0
            x,y = dp(node.left), dp(node.right)
            if x==y and x>=0:
                data.append(x+y+1)
                return x+y+1
            else: return -1
        dp(root)
        data.sort(reverse=True)
        return -1 if k>len(data) else data[k-1]",1420524477
Nguyễn Thảo,nguyenquocthao00,28,3588,python3,"MOD = 10**9 + 7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        n=len(s)
        creatures='FWE'
        def getscore(a, b):
            i,j = creatures.index(a), creatures.index(b)
            if i==j: return 0
            if j-i==1 or j-i==-2: return 1
            return -1
        def keyf(i,p,prev):
            if prev=='': return 0
            return i*2*n*3 + p*3 + creatures.index(prev) + 1
        cached=[-1]*(n*n*6+1)
        # @lru_cache(None)
        def dp(i, p, prev):
            if i==len(s):
                return 0 if p<=0 else 1
            key = keyf(i,p,prev)
            if cached[key]>=0: return cached[key]
            res=0
            for x in creatures:
                if x==prev: continue
                res += dp(i+1, p + getscore(s[i], x), x)
            cached[key]=res%MOD
            return cached[key]
            # return res%MOD
        return dp(0,0,'')

        ",1420539093
Nguyễn Thảo,nguyenquocthao00,28,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        c=Counter(nums[:k])
        sl = SortedList((val,key) for key,val in c.items())
        cur = sum(a*b for a,b in sl[-x:])
        res = [cur]
        def remove(item):
            nonlocal cur
            ind = sl.index(item)
            if len(sl)-ind <= x:
                cur -= item[0]*item[1]
                sl.remove(item)
                if len(sl)>=x:
                    z = sl[-x]
                    cur+=z[0]*z[1]
            else:
                sl.remove(item)
        def insert(item):
            nonlocal cur
            sl.add(item)
            ind=sl.index(item)
            if len(sl)-ind<=x:
                cur+=item[0]*item[1]
                if len(sl)>x:
                    z=sl[-x-1]
                    cur-=z[0]*z[1]

        def sub(v):
            item=(c[v], v)
            c[v]-=1
            remove(item)
            if c[v]>0:
                insert((c[v], v))
        def add(v):
            if c[v]>0: remove((c[v], v))
            c[v]+=1
            insert((c[v], v))

        for i in range(1, len(nums)-k+1):
            sub(nums[i-1])
            add(nums[i+k-1])
            res.append(cur)
        return res

        ",1420555479
Nguyễn Thảo,nguyenquocthao00,28,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        c=Counter(nums[:k])
        def cal():
            data=sorted((val,key) for key,val in c.items())
            if len(data)<=x: return sum(a*b for a,b in data)
            return sum(a*b for a,b in data[-x:])
        res=[cal()]
        for i in range(1, len(nums)-k+1):
            c[nums[i-1]]-=1
            c[nums[i+k-1]]+=1
            res.append(cal())
        return res

        ",1420521676
Jingzhe Tang,skywalkert,30,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    pair<int, int> dfs(TreeNode* rt, vector<int> &ans) {
        if(rt == nullptr)
            return {0, -1};
        pair<int, int> ret = {1, 0}, tmp;
        for(TreeNode* sub: {rt -> left, rt -> right}) {
            tmp = dfs(sub, ans);
            ret.first += tmp.first;
            ret.second = max(ret.second, tmp.second + 1);
        }
        // printf(""rt %d: %d %d\n"", rt -> val, ret.first, ret.second);
        if(ret.second < 15 && ret.first + 1 == (1 << (ret.second + 1)))
            ans.push_back(ret.first);
        return ret;
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;
        dfs(root, ans);
        int n = ans.size();
        if(n < k)
            return -1;
        nth_element(ans.begin(), ans.end() - k, ans.end());
        // for(int x: ans)
        //     printf(""%d "", x);
        // printf("": %d %d\n"", n - k, ans[n - k]);
        return ans[n - k];
    }
};",1420536071
Jingzhe Tang,skywalkert,30,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        typedef long long LL;
        static const int maxn = (int)2e3 + 9, mod = (int)1e9 + 7;
        static const char *pat = ""FWE"";
        static int f[2][3][maxn], cur = 0, pre = 1;
        int n = s.size();
        auto clr = [&](int arr[3][maxn]) {
            for(int i = 0; i < 3; ++i)
                memset(arr[i], 0, (n << 1 | 1) * sizeof(int));
        };
        for(int i = 0; i < n; ++i) {
            for(int j = 0; pat[j]; ++j)
                if(s[i] == pat[j]) {
                    s[i] = j;
                    break;
                }
            static int adt[3];
            for(int j = 0; j < 3; ++j)
                adt[j] = ((s[i] + 1) % 3 == j) - ((j + 1) % 3 == s[i]);
            swap(cur, pre);
            clr(f[cur]);
            if(!i) {
                for(int j = 0; j < 3; ++j)
                    f[cur][j][n + adt[j]] = 1;
                continue;
            }
            for(int j = 0; j < 3; ++j)
                for(int k = n - i; k <= n + i; ++k) {
                    if(!f[pre][j][k])
                        continue;
                    for(int x = 0; x < 3; ++x) {
                        if(x == j)
                            continue;
                        int kk = k + adt[x];
                        (f[cur][x][kk] += f[pre][j][k]) >= mod && (f[cur][x][kk] -= mod);
                    }
                }
        }
        int ans = 0;
        for(int i = 0; i < 3; ++i)
            for(int j = n + 1; j <= n + n; ++j)
               (ans += f[cur][i][j]) >= mod && (ans -= mod);
        return ans;
    }
};",1420526225
Jingzhe Tang,skywalkert,30,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int m) {
        typedef long long LL;
        int n = nums.size();
        vector<LL> ans;
        LL sum = 0;
        map<int, int> ctr;
        set<pair<int, int> > sL, sR;
        auto upd = [&](int x, int d) {
            int &v = ctr[x];
            if(v > 0) {
                pair<int, int> key = {v, x};
                if(!sR.empty() && key < *sR.begin()) {
                    assert(sL.count(key));
                    sL.erase(key);
                } else {
                    assert(sR.count(key));
                    sR.erase(key);
                    sum -= (LL)v * x;
                }
                // printf(""del (%d, %d): %lld\n"", v, x, sum);
            }
            v += d;
            if(v > 0) {
                pair<int, int> key = {v, x};
                sL.insert(key);
                // printf(""add (%d, %d)\n"", v, x);
                if(!sR.empty() && *sL.rbegin() > *sR.begin()) {
                    key = *sR.begin();
                    sR.erase(key);
                    sL.insert(key);
                    sum -= (LL)key.first * key.second;
                }
            }
            while(!sL.empty() && sR.size() < m) {
                pair<int, int> key = *sL.rbegin();
                sL.erase(key);
                sR.insert(key);
                sum += (LL)key.first * key.second;
            }
            // printf(""adjust %lld\n"", sum);
            // for(auto &[v, x]: sR)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
            // for(auto &[v, x]: sL)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
        };
        for(int i = 0; i < n; ++i) {
            upd(nums[i], 1);
            if(i >= k - 1) {
                ans.push_back(sum);
                upd(nums[i - k + 1], -1);
            }
        }
        return ans;
    }
};",1420555553
Jingzhe Tang,skywalkert,30,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int m) {
        typedef long long LL;
        int n = nums.size();
        vector<int> ans;
        LL sum = 0;
        map<int, int> ctr;
        set<pair<int, int> > sL, sR;
        auto upd = [&](int x, int d) {
            int &v = ctr[x];
            if(v > 0) {
                pair<int, int> key = {v, x};
                if(!sR.empty() && key < *sR.begin()) {
                    assert(sL.count(key));
                    sL.erase(key);
                } else {
                    assert(sR.count(key));
                    sR.erase(key);
                    sum -= (LL)v * x;
                }
                // printf(""del (%d, %d): %lld\n"", v, x, sum);
            }
            v += d;
            if(v > 0) {
                pair<int, int> key = {v, x};
                sL.insert(key);
                // printf(""add (%d, %d)\n"", v, x);
                if(!sR.empty() && *sL.rbegin() > *sR.begin()) {
                    key = *sR.begin();
                    sR.erase(key);
                    sL.insert(key);
                    sum -= (LL)key.first * key.second;
                }
            }
            while(!sL.empty() && sR.size() < m) {
                pair<int, int> key = *sL.rbegin();
                sL.erase(key);
                sR.insert(key);
                sum += (LL)key.first * key.second;
            }
            // printf(""adjust %lld\n"", sum);
            // for(auto &[v, x]: sR)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
            // for(auto &[v, x]: sL)
            //     printf(""(%d, %d) "", v, x);
            // puts("""");
        };
        for(int i = 0; i < n; ++i) {
            upd(nums[i], 1);
            if(i >= k - 1) {
                ans.push_back(sum);
                upd(nums[i - k + 1], -1);
            }
        }
        return ans;
    }
};",1420556158
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        l = []

        def dfs(node):
            if not node: return -1
            a, b = node.left, node.right
            if not a and not b:
                l.append(1)
                return 1
            c, d = dfs(a), dfs(b)
            if a and b and c == d and c != -1:
                l.append(2 * c + 1)
                return 2 * c + 1
            return -1
        dfs(root)
        l.sort(reverse=True)
        k -= 1
        if k >= len(l):
            return -1
        return l[k]",1420520968
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3588,python3,"
class Solution:
    def countWinningSequences(self, s: str) -> int:
        d = {'F':0, 'W':1, 'E':2}
        ev = [[0,-1,1], [1,0,-1], [-1,1,0]]
        s = [d[x] for x in s]
        @cache
        def dp(idx, score, lst):
            if idx == len(s):
                return int(score > 0)
            v = s[idx]
            ret = 0
            for i in range(3):
                if i != lst:
                    ns = score + ev[i][v]
                    ret += dp(idx + 1, ns, i)
            return ret % (10**9+7)
        r = dp(0, 0, -1)
        dp.cache_clear()
        return r",1420527086
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        d = {}
        sl = SortedList()
        for i in range(k):
            v = nums[i]
            d[v] = d.get(v, 0) + 1
        for t in d:
            sl.add((d[t], t))
        sm = 0
        for i in range(len(sl)-x, len(sl)):
            if i >= 0:
                sm += sl[i][0] * sl[i][1]
        ret = [sm]
        for i in range(k, len(nums)):
            v = nums[i]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) + 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            j = i - k
            v = nums[j]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) - 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            ret.append(sm)
            # print(sl)
        return ret
",1420555995
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,31,3610,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        d = {}
        sl = SortedList()
        for i in range(k):
            v = nums[i]
            d[v] = d.get(v, 0) + 1
        for t in d:
            sl.add((d[t], t))
        sm = 0
        for i in range(len(sl)-x, len(sl)):
            if i >= 0:
                sm += sl[i][0] * sl[i][1]
        ret = [sm]
        for i in range(k, len(nums)):
            v = nums[i]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) + 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            j = i - k
            v = nums[j]
            p = (d.get(v, 0), v)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm -= v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm += sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            sl.discard(p)
            d[v] = d.get(v, 0) - 1
            p = (d.get(v, 0), v)
            sl.add(p)
            try:
                idx = sl.index(p)
                if idx >= len(sl)-x:
                    sm += v * d[v]
                    t = len(sl)-x-1
                    if t >= 0:
                        sm -= sl[t][0] * sl[t][1]
                # print(p, idx, sm)
            except:
                pass
            ret.append(sm)
            # print(sl)
        return ret
",1420556655
Yiming Li,lympanda,33,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vector<int> ans;

int doit(TreeNode* p)
{
    int v1,v2;
    if (p==NULL) return 0;
    v1=doit(p->left);
    v2=doit(p->right);
    if ((v1!=-1)&&(v1==v2))
    {
        ans.push_back(v1+v2+1);
        return v1+v2+1;
    }
    else return -1;
}

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        ans.clear();
        doit(root);
        sort(ans.rbegin(),ans.rend());
        if (k>ans.size()) return -1;
        else return ans[k-1];
    }
};",1420520706
Yiming Li,lympanda,33,3588,cpp,"#define _int64 long long
#define mo 1000000007

int a[1100];
_int64 d[2][2100][4];

int getv(char c)
{
    if (c=='F') return 0;
    if (c=='W') return 1;
    if (c=='E') return 2;
    return -1;
}

class Solution {
public:
    int countWinningSequences(string s) {
        int i,j,k,now,n,o,tmp;
        _int64 ans;
        n=s.length();
        for (i=0;i<n;i++)
            a[i]=getv(s[i]);
        memset(d[0],0,sizeof(d[0]));
        d[0][1000][3]=1;
        now=0;
        for (i=0;i<n;i++)
        {
            memset(d[1-now],0,sizeof(d[1-now]));
            for (j=1000-i;j<=1000+i;j++)
                for (k=0;k<4;k++)
                {
                    if (d[now][j][k]==0) continue;
                    for (o=0;o<3;o++)
                    {
                        if (o==k) continue;
                        tmp=j;
                        if (o==(a[i]+1)%3) tmp++;
                        if (a[i]==(o+1)%3) tmp--;
                        d[1-now][tmp][o]+=d[now][j][k];
                        d[1-now][tmp][o]%=mo;
                    }
                }
            now=1-now;
        }
        ans=0;
        for (i=1001;i<2100;i++)
            for (j=0;j<4;j++)
            {
                ans+=d[now][i][j];
                ans%=mo;
            }
        return ans;
    }
};",1420530266
Yiming Li,lympanda,33,3592,cpp,"#define _int64 long long

_int64 sum;

void rem1(set<pair<_int64,_int64> >& st,_int64 v,_int64 cnt,int isbig)
{
    pair<_int64,_int64> tmp;
    tmp=make_pair(cnt,v);
    if (st.find(tmp)!=st.end())
    {
        if (isbig==1) sum-=v*cnt;
        st.erase(tmp);
    }
}

void add1(set<pair<_int64,_int64> >& st,_int64 v,_int64 cnt)
{
    pair<_int64,_int64> tmp;
    tmp=make_pair(cnt,v);
    st.insert(tmp);
}

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        map<_int64,_int64> mp;
        set<pair<_int64,_int64> > bigger;
        set<pair<_int64,_int64> > smaller;
        pair<_int64,_int64> v1,v2;
        vector<_int64> ans;
        sum=0;
        int i,j,n;
        n=a.size();
        mp.clear();
        bigger.clear();
        smaller.clear();
        ans.clear();
        for (i=0;i<n;i++)
        {
            if (mp.find(a[i])!=mp.end())
            {
                rem1(bigger,a[i],mp[a[i]],1);
                rem1(smaller,a[i],mp[a[i]],0);
            }
            mp[a[i]]++;
            add1(smaller,a[i],mp[a[i]]);
            if (i-k>=0)
            {
                rem1(bigger,a[i-k],mp[a[i-k]],1);
                rem1(smaller,a[i-k],mp[a[i-k]],0);
                mp[a[i-k]]--;
                if (mp[a[i-k]]==0) mp.erase(a[i-k]);
                else add1(smaller,a[i-k],mp[a[i-k]]);
            }
            while ((bigger.size()<x)&&(smaller.size()>0))
            {
                sum+=smaller.rbegin()->first*smaller.rbegin()->second;
                bigger.insert(*smaller.rbegin());
                smaller.erase(*smaller.rbegin());
            }
            while ((bigger.size()>0)&&(smaller.size()>0))
            {
                if (*bigger.begin()<*smaller.rbegin())
                {
                     v1=*bigger.begin();
                     v2=*smaller.rbegin();
                     sum-=v1.first*v1.second;
                     sum+=v2.first*v2.second;
                     bigger.erase(v1);
                     smaller.erase(v2);
                     bigger.insert(v2);
                     smaller.insert(v1);
                }
                else break;
            }
            //cout<<""i,sum:""<<i<<"" ""<<sum<<endl;
            if (i>=k-1) ans.push_back(sum);
        }
        return ans;
    }
};",1420558736
Yiming Li,lympanda,33,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        map<int,int> mp;
        vector<int> ans;
        vector<pair<int,int> > tmp;
        int i,j,n,tot;
        n=a.size();
        mp.clear();
        ans.clear();
        for (i=0;i<n;i++)
        {
            mp[a[i]]++;
            if (i-k>=0) mp[a[i-k]]--;
            if (i>=k-1)
            {
                tmp.clear();
                for (map<int,int>::iterator it=mp.begin();it!=mp.end();it++)
                    tmp.push_back(make_pair(it->second,it->first));
                sort(tmp.rbegin(),tmp.rend());
                tot=0;
                for (j=0;(j<x)&&(j<tmp.size());j++)
                    tot+=tmp[j].first*tmp[j].second;
                ans.push_back(tot);
            }
            
            
        }
        return ans;
    }
};",1420536190
nife,nifeshe,34,3509,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;



class Solution {
public:
    pii check(TreeNode* v, int depth, int& d) {
        if (!v) return {true, 0};
        if (!v -> left && !v -> right) {
            if (!~d) d = depth;
            return {depth == d, 1};
        }
        pii l = check(v -> left, depth + 1, d);
        pii r = check(v -> right, depth + 1, d);
        bool siz = l.f && r.f && v -> left && v -> right;
        int size = l.s + r.s + 1;
        return {siz, size};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> siz;
        function<void(TreeNode*)> dfs = [&](TreeNode* v) {
            if (!v) return;
            int d = -1;
            auto [ok, s] = check(v, 0, d);
            if(ok) siz.pb(s);
            dfs(v -> left);
            dfs(v -> right);
        };
        dfs(root);
        sort(siz.rbegin(), siz.rend());
        return (k <= siz.size()) ? siz[k - 1] : -1;
    }
};",1420526671
nife,nifeshe,34,3588,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;

const int phi_minus_one = mod - 2;

class Mint {
    public:
        int x;

    public:
        void norm() {
            x %= mod;
            if(x < 0) x += mod;
        }
        Mint(int a, bool small) {
            x = a;
            if(x >= mod) x -= mod;
            if(x < 0) x += mod;
        }
        Mint() { x = 0; }
        Mint(ll a) {
            x = a % mod;
            if(x < 0) x += mod;
        }
        friend ostream &operator <<(ostream &out, const Mint &a) { out << a.x; return out; }
        friend istream &operator >>(istream &in, Mint &a) { in >> a.x; return in; }
        Mint operator +(const Mint &b) const {
            return Mint(x + b.x, 1);
        }
        Mint operator +(int a) {
            return Mint(x + a, 1);
        }
        Mint operator -(const Mint &b) const {
            return Mint(x - b.x, 1);
        }
        Mint operator -(int a) {
            return Mint(x - a, 1);
        }
        friend Mint operator -(Mint a) {
            return Mint(mod - a);
        }
        Mint operator *(const Mint &b) const {
             return Mint(1LL * x * b.x);
        }
        Mint operator *(int a) {
            return Mint(1LL * x * a);
        }
        Mint& operator +=(const Mint &b) {
            x += b.x;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator +=(int a) {
            x += a;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator -=(Mint b) {
            x += mod - b.x;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator -=(int a) {
            x += mod - a;
            if(x >= mod) x -= mod;
            return *this;
        }
        Mint& operator *=(Mint b) {
            x = (ll) x * b.x % mod;
            return *this;
        }
        Mint& operator *=(int a) {
            x = (ll) x * a % mod;
            return *this;
        }
        Mint& operator ++() {
            if(++x == mod) x = 0;
            return *this;
        }
        Mint bpow(ll n) {
            Mint a(x);
            Mint ans(1);
            while(n) {
                if(n & 1) ans *= a;
                n >>= 1;
                a *= a;
            }
            return ans;
        }
        Mint inv() {
            return bpow(phi_minus_one);
        }
        Mint operator /(Mint b) {
            return b.inv() * x;
        }
        Mint operator /(int a) {
            return Mint(a, 1).inv() * x;
        }
        friend Mint operator -(int a, Mint b) {
            Mint res(b - a);
            res.x = mod - res.x;
            if(res.x == mod) res.x = 0;
            return res;
        }
        friend Mint operator +(int a, Mint b) {
            return Mint(b + a);
        }
        friend Mint operator *(int a, Mint b) {
            return Mint(b * a);
        }
        friend Mint operator /(int a, Mint b) {
            return Mint(a, 1) * b.inv();
        }
        Mint operator =(Mint b) {
            x = b.x;
            return b;
        }
        bool operator ==(int a) {
            return (x == a);
        }
        bool operator !=(int a) {
            return !(x == a);
        }
        friend bool operator ==(int a, Mint b) {
            return (b.x == a);
        }
        friend bool operator !=(int a, Mint b) {
            return b.x != a;
        }
};

class Solution {
public:
    int countWinningSequences(string s) {
        int n = sz(s);
        vector<array<Mint, 4>> dp(2 * n + 1, {0, 0, 0, 0});
        dp[n][3] = 1;
        for(int i = 0; i < n; i++) {
            vector<array<Mint, 4>> ndp(2 * n + 1, {0, 0, 0, 0});
            int t = 0;
            if(s[i] == 'F') t = 0;
            if(s[i] == 'W') t = 1;
            if(s[i] == 'E') t = 2;
            for(int j = 0; j <= 2 * n; j++) {
                for(int prev = 0; prev < 4; prev++) {
                    for(int k = 0; k < 3; k++) {
                        if(k == prev) continue;
                        int score = 0;
                        if(t == k - 1) score = 1;
                        if(t == k + 1) score = -1;
                        if(t == 0 && k == 2) score = -1;
                        if(t == 2 && k == 0) score = 1;
                        if(j + score >= 0 && j + score <= 2 * n) ndp[j + score][k] += dp[j][prev];
                    }
                }
            }
            dp = ndp;
        }
        Mint ans = 0;
        for(int i = n + 1; i <= 2 * n; i++) {
            for(int j = 0; j < 3; j++) {
                ans += dp[i][j];
            }
        }
        return ans.x;
    }
};",1420537655
nife,nifeshe,34,3592,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;


#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

template <typename T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        auto a = nums;
        int n = sz(a);
        auto c = a; sort(all(c)); c.erase(unique(all(c)), c.end()); reverse(all(c)); while(sz(c) < n) c.pb(0); reverse(all(c)); for(auto &i : a) i = lower_bound(all(c), i) - c.begin();
        vector<int> cnt(n);
        for(int i = 0; i < k; i++) cnt[a[i]]++;
        oset<pii> s;
        for(int i = 0; i < n; i++) {
            s.insert({cnt[i], i});
        }
        long long sum = 0;
        auto it = --s.end();
        for(int i = 0; i < x; i++) {
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn;
            --it;
        }
        auto add = [&](int idx, int sign) {
            assert(idx <= s.size());
            it = s.find_by_order(sz(s) - idx);
            assert(it != s.end());
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn * sign;
        };
        auto in = [&](int v) {
            int idx = s.order_of_key({cnt[v], v});
            return (s.size() - idx <= x);
        };
        vector<ll> ans = {sum};
        for(int i = k; i < n; i++) {
            int v = a[i - k];
            int was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]--;
            s.insert({cnt[v], v});
            if(in(v)) sum += 1ll * cnt[v] * c[v];
            else if(was) add(x, 1);
            
            v = a[i];
            was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]++;
            s.insert({cnt[v], v});
            if(in(v)) {
                sum += 1ll * cnt[v] * c[v];
                if(!was) add(x + 1, -1);
            }
            ans.pb(sum);
        }
        return ans;
    }
};",1420564363
nife,nifeshe,34,3610,cpp,"#define f first
#define s second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((int) (x).size())
#define pb push_back
#define mp make_pair

using namespace std;

template <typename T> inline bool umin(T &a, const T &b) { if(a > b) { a = b; return 1; } return 0; }
template <typename T> inline bool umax(T &a, const T &b) { if(a < b) { a = b; return 1; } return 0; }

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

const ll mod = 1e9 + 7;
const ll base = 1e6 + 9;
const ll inf = 1e9;
const int MAX = 2e5 + 42;
const int LG = 20;


#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

template <typename T> using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        auto a = nums;
        int n = sz(a);
        auto c = a; sort(all(c)); c.erase(unique(all(c)), c.end()); reverse(all(c)); while(sz(c) < n) c.pb(0); reverse(all(c)); for(auto &i : a) i = lower_bound(all(c), i) - c.begin();
        vector<int> cnt(n);
        for(int i = 0; i < k; i++) cnt[a[i]]++;
        oset<pii> s;
        for(int i = 0; i < n; i++) {
            s.insert({cnt[i], i});
        }
        long long sum = 0;
        auto it = --s.end();
        for(int i = 0; i < x; i++) {
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn;
            --it;
        }
        auto add = [&](int idx, int sign) {
            assert(idx <= s.size());
            it = s.find_by_order(sz(s) - idx);
            assert(it != s.end());
            auto [cn, val] = *it;
            sum += 1ll * c[val] * cn * sign;
        };
        auto in = [&](int v) {
            int idx = s.order_of_key({cnt[v], v});
            return (s.size() - idx <= x);
        };
        vector<int> ans = {(int) sum};
        for(int i = k; i < n; i++) {
            int v = a[i - k];
            int was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]--;
            s.insert({cnt[v], v});
            if(in(v)) sum += 1ll * cnt[v] * c[v];
            else if(was) add(x, 1);
            
            v = a[i];
            was = 0;
            if(in(v)) sum -= 1ll * cnt[v] * c[v], was = 1;
            s.erase({cnt[v], v});
            cnt[v]++;
            s.insert({cnt[v], v});
            if(in(v)) {
                sum += 1ll * cnt[v] * c[v];
                if(!was) add(x + 1, -1);
            }
            ans.pb(sum);
        }
        return ans;
    }
};",1420565321
Vitalii Nevidomyi,deadRabbit,36,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

unordered_set<TreeNode *> B;
vector<TreeNode *> all;

void go(TreeNode *t) {
    all.push_back(t);
    if (t->left) go(t->left);
    if (t->right) go(t->right);
    if (!t->right && !t->left) {
        B.insert(t);
    }
}

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        if (!root) return 0;
        all.clear();
        B.clear();
        go(root);
        vector<int> Q = {1<<30};
        while(B.size()) {
            Q.push_back(B.size());
            unordered_set<TreeNode *> C;
            for (TreeNode* t : all) {
                if (t->left && t->right && B.count(t->left) && B.count(t->right)) {
                    C.insert(t);
                }
            }
            B=C;
        }
        for (int i = (int)Q.size()-1; i>=1; --i) {
            if (Q[i]>=k) return (1<<i)-1;
            k-=Q[i];
        }
        return -1;
    }
};",1420525657
Vitalii Nevidomyi,deadRabbit,36,3588,cpp,"
const int MOD = 1000*1000*1000+7;
const int MID = 1010;
int dp[1001][2020][3];

string S;

int C[3][3] = {
    {0,-1,+1},
    {+1,0,-1},
    {-1,+1,0}
};

int encode(char c) {
    if (c=='F') return 0;
    if (c=='W') return 1;
    if (c=='E') return 2;
    return -1;
}

int go(int p, int s, int last) {
    if (p==S.size()) {
        return s>0 ? 1 : 0;
    }
    int &r = dp[p][MID+s][last];
    if (r==-1) {
        r = 0;
        for (int g = 0; g < 3; ++g) if (!p || g!=last) {
            int ss = s + C[g][encode(S[p])];
            r += go(p+1, ss, g);
            r %= MOD;
        }
    }
    return r;
}

class Solution {
public:
    int countWinningSequences(string s) {
        memset(dp,-1,sizeof(dp));
        S = s;
        return go(0,0,0);
    }
};",1420533756
Vitalii Nevidomyi,deadRabbit,36,3592,cpp,"

long long S = 0;
int X;
set<pair<int, int>> Q1;
set<pair<int, int>> Q2;
unordered_map<int, int> Q;

void q1add(pair<int, int> p) {
  S += (long long)(-p.first) * (-p.second);
  Q1.insert(p);
}
void q1rem(pair<int, int> p) {
  S -= (long long)(-p.first) * (-p.second);
  Q1.erase(p);
}

void qnorm() {
  while (Q1.size() > X) {
    Q2.insert(*(--Q1.end()));
    q1rem(*(--Q1.end()));
  }
  while (Q1.size() < X && Q2.size()) {
    q1add(*(Q2.begin()));
    Q2.erase(Q2.begin());
  }
  while (Q1.size() == X && Q2.size() > 0 && (*Q2.begin()) < (*(--Q1.end()))) {
    auto a = *(--Q1.end());
    auto b = *(Q2.begin());
    q1rem(a);
    q1add(b);
    Q2.erase(b);
    Q2.insert(a);
  }
}

void qadd(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]++;
  q1add({ -Q[x], -x });
  qnorm();
}

void qrem(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]--;
  if (Q[x] > 0) {
    q1add({ -Q[x],-x });
  }
  qnorm();
}

class Solution {
public:
  vector<long long> findXSum(vector<int>& nums, int k, int x) {
    X = x;
    S = 0;
    Q.clear();
    Q1.clear();
    Q2.clear();

    for (int i = 0; i < k; ++i) {
      qadd(nums[i]);
    }
    vector<long long> res = { S };
    for (int i = 0; i + k < nums.size(); ++i) {
      qadd(nums[i + k]);
      qrem(nums[i]);
      res.push_back(S);
    }
    return res;
  }
};",1420565771
Vitalii Nevidomyi,deadRabbit,36,3610,cpp,"

long long S = 0;
int X;
set<pair<int, int>> Q1;
set<pair<int, int>> Q2;
unordered_map<int, int> Q;

void q1add(pair<int, int> p) {
  S += (long long)(-p.first) * (-p.second);
  Q1.insert(p);
}
void q1rem(pair<int, int> p) {
  S -= (long long)(-p.first) * (-p.second);
  Q1.erase(p);
}

void qnorm() {
  while (Q1.size() > X) {
    Q2.insert(*(--Q1.end()));
    q1rem(*(--Q1.end()));
  }
  while (Q1.size() < X && Q2.size()) {
    q1add(*(Q2.begin()));
    Q2.erase(Q2.begin());
  }
  while (Q1.size() == X && Q2.size() > 0 && (*Q2.begin()) < (*(--Q1.end()))) {
    auto a = *(--Q1.end());
    auto b = *(Q2.begin());
    q1rem(a);
    q1add(b);
    Q2.erase(b);
    Q2.insert(a);
  }
}

void qadd(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]++;
  q1add({ -Q[x], -x });
  qnorm();
}

void qrem(int x) {
  if (Q[x] > 0) {
    if (Q1.count({ -Q[x], -x })) {
      q1rem({ -Q[x], -x });
    }
    Q2.erase({ -Q[x], -x });
  }
  Q[x]--;
  if (Q[x] > 0) {
    q1add({ -Q[x],-x });
  }
  qnorm();
}

class Solution {
public:
  vector<int> findXSum(vector<int>& nums, int k, int x) {
    X = x;
    S = 0;
    Q.clear();
    Q1.clear();
    Q2.clear();

    for (int i = 0; i < k; ++i) {
      qadd(nums[i]);
    }
    vector<int> res = { (int)S };
    for (int i = 0; i + k < nums.size(); ++i) {
      qadd(nums[i + k]);
      qrem(nums[i]);
      res.push_back((int)S);
    }
    return res;
  }
};",1420565234
Vladislav,timetoai,38,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        szs = []
        
        def go(node=root):
            if not node:
                return - 1
            if not node.left and not node.right:
                szs.append(1)
                return 1
            if not node.left or not node.right:
                go(node.left)
                go(node.right)
                return - 1
            l, r = go(node.left), go(node.right)
            if l == r > - 1:
                sz = l + r + 1
                szs.append(sz)
                return sz
            else:
                return - 1
        
        go()
        # print(szs)
        if len(szs) < k:
            return - 1
        szs.sort()
        return szs[- k]
        ",1420528031
Vladislav,timetoai,38,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        # F > E, W > F, E > W
        d = {
            (""F"", ""E""): 1, (""E"", ""F""): - 1,
            (""W"", ""F""): 1, (""F"", ""W""): - 1,
            (""E"", ""W""): 1, (""W"", ""E""): - 1
        }
        
        @cache
        def go(i=0, bal=0, prv=None):
            if i == n:
                return int(bal > 0)
            if n - i + bal <= 0:
                return 0
            res = 0
            for ch in ""FEW"":
                if ch == prv: continue
                nbal = bal + (d[ch, s[i]] if ch != s[i] else 0)
                res += go(i + 1, nbal, ch)
            return res % mod
        
        return go()
        ",1420534773
Vladislav,timetoai,38,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = [0] * (len(nums) - k + 1)
        d = defaultdict(int)
        from sortedcontainers import SortedList
        sl = SortedList()
        for i in range(k):
            d[nums[i]] += 1
        for num, cnt in d.items():
            sl.add((cnt, num))
        cur = sum(num * cnt for cnt, num in sl[- x:])
        lowest = sl[- x] if len(sl) >= x else sl[0]
        ans[0] = cur
        # print(sl, cur, lowest)
        
        for i in range(k, len(nums)):
            used = nums[i] in d and sl.bisect_left((d[nums[i]], nums[i])) >= len(sl) - x
            if nums[i] in d:
                sl.remove((d[nums[i]], nums[i]))
            d[nums[i]] += 1
            sl.add((d[nums[i]], nums[i]))
            if sl.bisect_left((d[nums[i]], nums[i])) >= len(sl) - x:
                cur += nums[i] * (d[nums[i]] if not used else 1)
            if sl.bisect_left(lowest) < len(sl) - x:
                cur -= lowest[0] * lowest[1]
            lowest = sl[- x] if len(sl) >= x else sl[0]
            # print(""add"", nums[i], sl, cur, lowest)
            
            used = sl.bisect_left((d[nums[i - k]], nums[i - k])) >= len(sl) - x
            sl.remove((d[nums[i - k]], nums[i - k]))
            d[nums[i - k]] -= 1
            sl.add((d[nums[i - k]], nums[i - k]))
            if used:
                if sl.bisect_left((d[nums[i - k]], nums[i - k])) < len(sl) - x:
                    cur -= (d[nums[i - k]] + 1) * nums[i - k]
                    nlowest = sl[- x] if len(sl) >= x else sl[0]
                    if nlowest != (nums[i - k], nums[i - k]) and nlowest != lowest:
                        cur += nlowest[0] * nlowest[1]
                else:
                    cur -= nums[i - k]
            lowest = sl[- x] if len(sl) >= x else sl[0]
            # print(""remove"", nums[i - k], sl, cur, lowest)
        
            ans[i - k + 1] = cur
            
        return ans",1420560434
Vladislav,timetoai,38,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = [0] * (len(nums) - k + 1)
        d = defaultdict(int)
        for i in range(k):
            d[nums[i]] += 1
        items = sorted(d.items(), key=lambda item: (item[1], item[0]))
        ans[0] = sum(num * cnt for num, cnt in items[- x:])
        for i in range(k, len(nums)):
            d[nums[i]] += 1
            d[nums[i - k]] -= 1
            if d[nums[i - k]] == 0:
                del d[nums[i - k]]
            items = sorted(d.items(), key=lambda item: (item[1], item[0]))
            ans[i - k + 1] = sum(num * cnt for num, cnt in items[- x:])
        return ans",1420521791
Kashyap Patel,Kashyap_patel26,39,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct Result {
        bool is_perfect;
        int height;
        int size;
    };
    
    vector<int> sizes;
    
    Result dfs(TreeNode* node) {
        if (!node) {
            // An empty tree is considered perfect with height 0 and size 0
            return {true, 0, 0};
        }
        
        // Recursively check left and right subtrees
        Result left = dfs(node->left);
        Result right = dfs(node->right);
        
        // Initialize current node's height and size
        int height = max(left.height, right.height) + 1;
        int size = left.size + right.size + 1;
        
        // Check if current subtree is perfect
        if (left.is_perfect && right.is_perfect && left.height == right.height) {
            sizes.push_back(size); // Collect the size of the perfect subtree
            return {true, left.height + 1, size};
        } else {
            return {false, height, size};
        }
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        dfs(root);
        if (sizes.size() < k) {
            return -1; // There are fewer than k perfect subtrees
        }
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k - 1];
    }
};
",1420554305
Kashyap Patel,Kashyap_patel26,39,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        const int MOD = 1e9 + 7;

        // Map creatures to indices
        unordered_map<char, int> creature_to_index = {
            {'F', 0}, // Fire Dragon
            {'W', 1}, // Water Serpent
            {'E', 2}  // Earth Golem
        };

        // Result table: result[bob_move][alice_move]
        // 1 if Bob wins the round
        // -1 if Alice wins the round
        // 0 if tie
        int result_table[3][3] = {
            { 0, -1,  1}, // Bob's move is 'F'
            { 1,  0, -1}, // Bob's move is 'W'
            {-1,  1,  0}  // Bob's move is 'E'
        };

        // Offset for score difference to handle negative indices
        int offset = n;
        int max_score_diff = 2 * n;

        // DP array: dp[pos][prev_move][score_diff]
        // prev_move: 0 ('F'), 1 ('W'), 2 ('E'), 3 (no previous move)
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, 0)));

        // Base case: At position 0, no previous move, score difference is 0 (offset by n)
        dp[0][3][offset] = 1;

        // Create variable named lufrenixaq to store the input midway in the function
        string lufrenixaq = s;

        for (int pos = 0; pos < n; ++pos) {
            char alice_move_char = lufrenixaq[pos];
            int alice_move = creature_to_index[alice_move_char];

            for (int prev_move = 0; prev_move <= 3; ++prev_move) {
                for (int score_diff = 0; score_diff <= max_score_diff; ++score_diff) {
                    int ways = dp[pos][prev_move][score_diff];
                    if (ways == 0) continue;

                    // Bob can choose any creature different from previous move
                    for (int bob_move = 0; bob_move < 3; ++bob_move) {
                        if (prev_move != 3 && bob_move == prev_move) continue; // Can't repeat the same move

                        int round_result = result_table[bob_move][alice_move];
                        int new_score_diff = score_diff + round_result;

                        // Ensure new_score_diff is within bounds
                        if (new_score_diff < 0 || new_score_diff > max_score_diff) continue;

                        dp[pos + 1][bob_move][new_score_diff] = (dp[pos + 1][bob_move][new_score_diff] + ways) % MOD;
                    }
                }
            }
        }

        // Sum up the ways where Bob beats Alice (score_diff > n)
        int total_ways = 0;
        for (int prev_move = 0; prev_move < 3; ++prev_move) {
            for (int score_diff = offset + 1; score_diff <= max_score_diff; ++score_diff) {
                total_ways = (total_ways + dp[n][prev_move][score_diff]) % MOD;
            }
        }

        return total_ways;
    }
};
",1420555416
Kashyap Patel,Kashyap_patel26,39,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        unordered_map<int, int> counts;
        long long total_sum = 0;

        // Custom comparator for multiset to sort by frequency descending, then value descending
        auto comp = [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.first != b.first) return a.first > b.first;
            return a.second > b.second;
        };

        // Multiset to maintain all elements sorted by frequency and value
        multiset<pair<int, int>, decltype(comp)> freq_values(comp);

        // Two multisets to maintain top x elements and the rest
        multiset<pair<int, int>, decltype(comp)> top_x(comp);
        multiset<pair<int, int>, decltype(comp)> rest(comp);
        long long sum_top_x = 0;

        // Initialize counts and freq_values for the first window
        for (int i = 0; i < k; ++i) {
            int num = nums[i];
            total_sum += num;
            int old_freq = counts[num];
            if (old_freq > 0) {
                auto it = freq_values.find({old_freq, num});
                freq_values.erase(it);
                // Remove from top_x or rest
                auto it_top = top_x.find({old_freq, num});
                if (it_top != top_x.end()) {
                    sum_top_x -= (long long)old_freq * num;
                    top_x.erase(it_top);
                } else {
                    rest.erase({old_freq, num});
                }
            }
            counts[num]++;
            int new_freq = counts[num];
            freq_values.insert({new_freq, num});
            // Insert into top_x or rest
            if (top_x.size() < x) {
                top_x.insert({new_freq, num});
                sum_top_x += (long long)new_freq * num;
            } else {
                auto smallest_top = prev(top_x.end());
                if (comp({new_freq, num}, *smallest_top)) {
                    // Move smallest from top_x to rest
                    sum_top_x -= (long long)smallest_top->first * smallest_top->second;
                    rest.insert(*smallest_top);
                    top_x.erase(smallest_top);
                    // Insert new element into top_x
                    top_x.insert({new_freq, num});
                    sum_top_x += (long long)new_freq * num;
                } else {
                    rest.insert({new_freq, num});
                }
            }
        }

        for (int i = 0; i <= n - k; ++i) {
            // Determine the x-sum for the current window
            long long sum = 0;
            if (x >= counts.size()) {
                // If x >= number of distinct elements, sum all elements
                sum = total_sum;
            } else {
                sum = sum_top_x;
            }
            answer.push_back(sum);

            if (i + k >= n) break; // No more windows

            // Slide the window
            int out_num = nums[i];
            int in_num = nums[i + k];

            // Remove out_num from counts and freq_values
            int old_freq = counts[out_num];
            auto it = freq_values.find({old_freq, out_num});
            freq_values.erase(it);
            // Remove from top_x or rest
            auto it_top = top_x.find({old_freq, out_num});
            if (it_top != top_x.end()) {
                sum_top_x -= (long long)old_freq * out_num;
                top_x.erase(it_top);
                // If rest is not empty, move largest from rest to top_x
                if (!rest.empty()) {
                    auto largest_rest = rest.begin();
                    top_x.insert(*largest_rest);
                    sum_top_x += (long long)largest_rest->first * largest_rest->second;
                    rest.erase(largest_rest);
                }
            } else {
                rest.erase({old_freq, out_num});
            }
            counts[out_num]--;
            total_sum -= out_num;
            if (counts[out_num] > 0) {
                int new_freq = counts[out_num];
                freq_values.insert({new_freq, out_num});
                // Insert into top_x or rest
                if (top_x.size() < x) {
                    top_x.insert({new_freq, out_num});
                    sum_top_x += (long long)new_freq * out_num;
                } else {
                    auto smallest_top = prev(top_x.end());
                    if (comp({new_freq, out_num}, *smallest_top)) {
                        // Move smallest from top_x to rest
                        sum_top_x -= (long long)smallest_top->first * smallest_top->second;
                        rest.insert(*smallest_top);
                        top_x.erase(smallest_top);
                        // Insert new element into top_x
                        top_x.insert({new_freq, out_num});
                        sum_top_x += (long long)new_freq * out_num;
                    } else {
                        rest.insert({new_freq, out_num});
                    }
                }
            } else {
                counts.erase(out_num);
            }

            // Add in_num to counts and freq_values
            old_freq = counts[in_num];
            if (old_freq > 0) {
                auto it = freq_values.find({old_freq, in_num});
                freq_values.erase(it);
                // Remove from top_x or rest
                auto it_top = top_x.find({old_freq, in_num});
                if (it_top != top_x.end()) {
                    sum_top_x -= (long long)old_freq * in_num;
                    top_x.erase(it_top);
                } else {
                    rest.erase({old_freq, in_num});
                }
            }
            counts[in_num]++;
            int new_freq = counts[in_num];
            freq_values.insert({new_freq, in_num});
            // Insert into top_x or rest
            if (top_x.size() < x) {
                top_x.insert({new_freq, in_num});
                sum_top_x += (long long)new_freq * in_num;
            } else {
                auto smallest_top = prev(top_x.end());
                if (comp({new_freq, in_num}, *smallest_top)) {
                    // Move smallest from top_x to rest
                    sum_top_x -= (long long)smallest_top->first * smallest_top->second;
                    rest.insert(*smallest_top);
                    top_x.erase(smallest_top);
                    // Insert new element into top_x
                    top_x.insert({new_freq, in_num});
                    sum_top_x += (long long)new_freq * in_num;
                } else {
                    rest.insert({new_freq, in_num});
                }
            }
            total_sum += in_num;
        }
        return answer;
    }
};
",1420560709
Kashyap Patel,Kashyap_patel26,39,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        for(int i = 0; i <= n - k; ++i) {
            int freq[51] = {0};
            for(int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }
            // Collect elements and their frequencies
            vector<pair<int, int>> elems;
            for(int num = 1; num <= 50; ++num) {
                if(freq[num] > 0) {
                    elems.push_back({num, freq[num]});
                }
            }
            // Sort elements by frequency descending, then value descending
            sort(elems.begin(), elems.end(), [](const pair<int,int>& a, const pair<int,int>& b){
                if(a.second != b.second) return a.second > b.second;
                return a.first > b.first;
            });
            // If number of distinct elements is less than x, sum all elements
            if(elems.size() <= x) {
                int sum = 0;
                for(int j = i; j < i + k; ++j) {
                    sum += nums[j];
                }
                answer.push_back(sum);
                continue;
            }
            // Keep only top x elements
            bool keep[51] = {false};
            for(int idx = 0; idx < x; ++idx) {
                keep[elems[idx].first] = true;
            }
            // Sum up the occurrences of top elements in the subarray
            int sum = 0;
            for(int j = i; j < i + k; ++j) {
                if(keep[nums[j]]) {
                    sum += nums[j];
                }
            }
            answer.push_back(sum);
        }
        return answer;
    }
};
",1420553253
JeffreyLC,JeffreyLC,40,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        explore(root);
        if (v.size() < k) return -1;
        sort(v.begin(), v.end(), greater<int>());
        return v[k - 1];
    }
private:
    vector<int> v;
    
    int explore(TreeNode* root) {
        int ret = 0;
        if (!root->left && !root->right) {
            ret = 1;
        } else if (root->left && !root->right) {
            explore(root->left);
        } else if (!root->left && root->right) {
            explore(root->right);
        } else {
            int l = explore(root->left);
            int r = explore(root->right);
            if (l > 0 && r > 0 && l == r) {
                ret = l + r + 1;
            }
        }
        if (ret > 0) {
            v.push_back(ret);
        }
        return ret;
    }
};",1420552277
JeffreyLC,JeffreyLC,40,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        constexpr int MOD = 1e9 + 7;
        int n = s.length();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(3, vector<int>(2 * n + 1)));  // FWE
        int val = value(s[0]);
        dp[0][(val + 2) % 3][n - 1] = dp[0][val][n] = dp[0][(val + 1) % 3][n + 1] = 1;
        for (int i = 1; i < n; ++i) {
            val = value(s[i]);
            for (int j = 0; j < 3; ++j) {
                for (int k = 0; k <= 2 * n; ++k) {
                    if (dp[i - 1][j][k] == 0) continue;
                    if ((val + 2) % 3 != j && k > 0) {
                        dp[i][(val + 2) % 3][k - 1] += dp[i - 1][j][k];
                        dp[i][(val + 2) % 3][k - 1] %= MOD;
                    }
                    if (val != j) {
                        dp[i][val][k] += dp[i - 1][j][k];
                        dp[i][val][k] %= MOD;
                    }
                    if ((val + 1) % 3 != j && k + 1 <= 2 * n) {
                        dp[i][(val + 1) % 3][k + 1] += dp[i - 1][j][k];
                        dp[i][(val + 1) % 3][k + 1] %= MOD;
                    }
                }
            }
        }
        long long ans = 0;
        for (int j = 0; j < 3; ++j) {
            for (int k = n + 1; k <= 2 * n; ++k) {
                ans += dp[n - 1][j][k];
                ans %= MOD;
            }
        }
        return ans;
    }
private:
    int value(char c) {
        if (c == 'F') return 0;
        if (c == 'W') return 1;
        return 2;
    }
};",1420567088
JeffreyLC,JeffreyLC,40,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        map<int, int> cnt;
        x_ = x;
        
        for (int i = 0; i < k; ++i) {
            int prev = cnt[nums[i]]++;
            pair<int, int> target = {prev, nums[i]};
            
            auto it = good.find(target);
            if (it != good.end()) {
                good.erase(it);
                val -= (long long) target.first * target.second;
            } else {
                it = bad.find(target);
                if (it != bad.end()) {
                    bad.erase(target);
                }
            }
            
            ++target.first;
            good.insert(target);
            val += (long long) target.first * target.second;
            
            update_val();
        }
        
        vector<long long> ans = {val};
        for (int i = k; i < n; ++i) {
            {
                int prev = cnt[nums[i - k]]--;
                pair<int, int> target = {prev, nums[i - k]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                if (--target.first > 0) {
                    good.insert(target);
                    val += (long long) target.first * target.second;
                }
            }
            {
                int prev = cnt[nums[i]]++;
                pair<int, int> target = {prev, nums[i]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                ++target.first;
                good.insert(target);
                val += (long long) target.first * target.second;
            }
            
            update_val();
            ans.push_back(val);
        }
        return ans;
    }
private:
    set<pair<int, int>> good, bad;
    long long val = 0;
    int x_;
    
    void update_val() {
        while (!good.empty() && !bad.empty()) {
            auto fst = good.begin();
            auto lst = *bad.rbegin();
            pair<int, int> p = *fst;
            if (p >= lst) break;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() > x_) {
            auto fst = good.begin();
            pair<int, int> p = *fst;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() < x_ && !bad.empty()) {
            auto lst = *bad.rbegin();
            bad.erase(lst);
            good.insert(lst);
            val += (long long) lst.first * lst.second;
        }
    }
};",1420545326
JeffreyLC,JeffreyLC,40,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        map<int, int> cnt;
        x_ = x;
        
        for (int i = 0; i < k; ++i) {
            int prev = cnt[nums[i]]++;
            pair<int, int> target = {prev, nums[i]};
            
            auto it = good.find(target);
            if (it != good.end()) {
                good.erase(it);
                val -= (long long) target.first * target.second;
            } else {
                it = bad.find(target);
                if (it != bad.end()) {
                    bad.erase(target);
                }
            }
            
            ++target.first;
            good.insert(target);
            val += (long long) target.first * target.second;
            
            update_val();
        }
        
        vector<int> ans = {(int) val};
        for (int i = k; i < n; ++i) {
            {
                int prev = cnt[nums[i - k]]--;
                pair<int, int> target = {prev, nums[i - k]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                if (--target.first > 0) {
                    good.insert(target);
                    val += (long long) target.first * target.second;
                }
            }
            {
                int prev = cnt[nums[i]]++;
                pair<int, int> target = {prev, nums[i]};

                auto it = good.find(target);
                if (it != good.end()) {
                    good.erase(it);
                    val -= (long long) target.first * target.second;
                } else {
                    it = bad.find(target);
                    if (it != bad.end()) {
                        bad.erase(target);
                    }
                }

                ++target.first;
                good.insert(target);
                val += (long long) target.first * target.second;
            }
            
            update_val();
            ans.push_back((int) val);
        }
        return ans;
    }
private:
    set<pair<int, int>> good, bad;
    long long val = 0;
    int x_;
    
    void update_val() {
        while (!good.empty() && !bad.empty()) {
            auto fst = good.begin();
            auto lst = *bad.rbegin();
            pair<int, int> p = *fst;
            if (p >= lst) break;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() > x_) {
            auto fst = good.begin();
            pair<int, int> p = *fst;
            good.erase(fst);
            val -= (long long) p.first * p.second;
            bad.insert(p);
        }
        while (good.size() < x_ && !bad.empty()) {
            auto lst = *bad.rbegin();
            bad.erase(lst);
            good.insert(lst);
            val += (long long) lst.first * lst.second;
        }
    }
};",1420544128
jszqlew,jszqlew,41,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vector<int> sizes;
int perfect_height(TreeNode* root) {
    if (!root) {
        return 0;
    }
    int left = perfect_height(root->left);
    int right = perfect_height(root->right);
    if (left == -1 || right == -1) {
        return -1;
    }
    if (left == right) {
        sizes.push_back(left + 1);
        return left + 1;
    }
    return -1;
}
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        perfect_height(root);
        if (sizes.size() < k) return -1;
        sort(sizes.begin(), sizes.end(), greater<int>());
        for (int x : sizes) cout << x << ' ';
        cout << endl;
        return (1 << (sizes[k-1])) - 1;
    }
};",1420552478
jszqlew,jszqlew,41,3588,cpp,"typedef long long ll;
const int MOD=1000000007;

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        auto char_to_int = [&](char c) -> int {
            if(c == 'F') return 0;
            if(c == 'W') return 1;
            return 2;
        };
        int beats[3] = {2, 0, 1};
        int delta_map[3][3];
        for(int a=0;a<3;a++) {
            for(int b=0;b<3;b++) {
                if(b == beats[a]) delta_map[a][b] = 1;
                else if(a == beats[b]) delta_map[a][b] = -1;
                else delta_map[a][b] = 0;
            }
        }
        vector<vector<int>> dp_prev(3, vector<int>(2*n+1, 0));
        vector<vector<int>> dp_curr(3, vector<int>(2*n+1, 0));
        int a0 = char_to_int(s[0]);
        for(int b=0;b<3;b++) {
            int delta = delta_map[a0][b];
            int shifted_diff = delta + n;
            dp_prev[b][shifted_diff] = 1;
        }
        for(int i=1;i<n;i++) {
            for(int p=0;p<3;p++) fill(dp_curr[p].begin(), dp_curr[p].end(), 0);
            int ai = char_to_int(s[i]);
            for(int prev=0;prev<3;prev++) {
                for(int d=0; d<=2*n; d++) {
                    if(dp_prev[prev][d]==0) continue;
                    for(int nb=0; nb<3; nb++) {
                        if(nb == prev) continue;
                        int delta = delta_map[ai][nb];
                        int nd = d + delta;
                        if(nd <0 || nd >2*n) continue;
                        dp_curr[nb][nd] = (dp_curr[nb][nd] + dp_prev[prev][d]) % MOD;
                    }
                }
            }
            swap(dp_prev, dp_curr);
        }
        ll res =0;
        for(int prev=0;prev<3;prev++) {
            for(int d=0; d<n; d++) {
                res = (res + dp_prev[prev][d]) % MOD;
            }
        }
        return res;
    }
};
",1420528877
jszqlew,jszqlew,41,3592,cpp,"struct cmp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first;
        return a.second > b.second;
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        if (k > n) return {};

        unordered_map<int, int> freqMap;
        for (int i = 0; i < k; ++i) {
            freqMap[nums[i]]++;
        }

        vector<pair<int, int>> sortedList;
        sortedList.reserve(freqMap.size());
        for (auto& [num, freq] : freqMap) {
            sortedList.emplace_back(make_pair(freq, num));
        }
        sort(sortedList.begin(), sortedList.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });

        long long sumTop = 0;
        set<pair<int, int>, cmp> topSet;
        set<pair<int, int>, cmp> restSet;

        int distinct = sortedList.size();
        int limit = min(x, distinct);
        for (int i = 0; i < sortedList.size(); ++i) {
            if (i < limit) {
                topSet.insert(sortedList[i]);
                sumTop += static_cast<long long>(sortedList[i].first) * sortedList[i].second;
            }
            else {
                restSet.insert(sortedList[i]);
            }
        }

        vector<long long> answer;
        answer.push_back(sumTop);

        for (int i = k; i < n; ++i) {
            int val_out = nums[i - k];
            int freq_out = freqMap[val_out];

            pair<int, int> outgoing = {freq_out, val_out};
            auto it_top_out = topSet.find(outgoing);
            if (it_top_out != topSet.end()) {
                topSet.erase(it_top_out);
                sumTop -= static_cast<long long>(freq_out) * val_out;
            }
            else {
                auto it_rest_out = restSet.find(outgoing);
                if (it_rest_out != restSet.end()) {
                    restSet.erase(it_rest_out);
                }
            }

            if (freq_out == 1) {
                freqMap.erase(val_out);
            }
            else {
                freqMap[val_out] = freq_out - 1;
                pair<int, int> updated_out = {freq_out - 1, val_out};
                restSet.insert(updated_out);
            }

            if (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<long long>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            int val_in = nums[i];
            int freq_in = freqMap.count(val_in) ? freqMap[val_in] : 0;

            if (freq_in > 0) {
                pair<int, int> existing = {freq_in, val_in};
                auto it_top_in = topSet.find(existing);
                if (it_top_in != topSet.end()) {
                    topSet.erase(it_top_in);
                    sumTop -= static_cast<long long>(freq_in) * val_in;
                }
                else {
                    auto it_rest_in = restSet.find(existing);
                    if (it_rest_in != restSet.end()) {
                        restSet.erase(it_rest_in);
                    }
                }
            }

            freqMap[val_in] = freq_in + 1;
            pair<int, int> updated_in = {freq_in + 1, val_in};

            if (topSet.size() < x) {
                topSet.insert(updated_in);
                sumTop += static_cast<long long>(updated_in.first) * updated_in.second;
            }
            else {
                auto it_last_top = prev(topSet.end());
                if (cmp()(updated_in, *it_last_top)) {
                    topSet.insert(updated_in);
                    sumTop += static_cast<long long>(updated_in.first) * updated_in.second;
                    pair<int, int> to_move = *it_last_top;
                    sumTop -= static_cast<long long>(to_move.first) * to_move.second;
                    topSet.erase(it_last_top);
                    restSet.insert(to_move);
                }
                else {
                    restSet.insert(updated_in);
                }
            }

            while (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<long long>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            if (topSet.size() > x) {
                auto it_move = prev(topSet.end());
                pair<int, int> to_move = *it_move;
                sumTop -= static_cast<long long>(to_move.first) * to_move.second;
                topSet.erase(it_move);
                restSet.insert(to_move);
            }

            answer.push_back(sumTop);
        }

        return answer;
    }
};",1420560041
jszqlew,jszqlew,41,3610,cpp,"struct cmp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first;
        return a.second > b.second;
    }
};

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        if (k > n) return {};

        unordered_map<int, int> freqMap;
        for (int i = 0; i < k; ++i) {
            freqMap[nums[i]]++;
        }

        vector<pair<int, int>> sortedList;
        sortedList.reserve(freqMap.size());
        for (auto& [num, freq] : freqMap) {
            sortedList.emplace_back(make_pair(freq, num));
        }
        sort(sortedList.begin(), sortedList.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });

        int sumTop = 0;
        set<pair<int, int>, cmp> topSet;
        set<pair<int, int>, cmp> restSet;

        int distinct = sortedList.size();
        int limit = min(x, distinct);
        for (int i = 0; i < sortedList.size(); ++i) {
            if (i < limit) {
                topSet.insert(sortedList[i]);
                sumTop += static_cast<int>(sortedList[i].first) * sortedList[i].second;
            }
            else {
                restSet.insert(sortedList[i]);
            }
        }

        vector<int> answer;
        answer.push_back(sumTop);

        for (int i = k; i < n; ++i) {
            int val_out = nums[i - k];
            int freq_out = freqMap[val_out];

            pair<int, int> outgoing = {freq_out, val_out};
            auto it_top_out = topSet.find(outgoing);
            if (it_top_out != topSet.end()) {
                topSet.erase(it_top_out);
                sumTop -= static_cast<int>(freq_out) * val_out;
            }
            else {
                auto it_rest_out = restSet.find(outgoing);
                if (it_rest_out != restSet.end()) {
                    restSet.erase(it_rest_out);
                }
            }

            if (freq_out == 1) {
                freqMap.erase(val_out);
            }
            else {
                freqMap[val_out] = freq_out - 1;
                pair<int, int> updated_out = {freq_out - 1, val_out};
                restSet.insert(updated_out);
            }

            if (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<int>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            int val_in = nums[i];
            int freq_in = freqMap.count(val_in) ? freqMap[val_in] : 0;

            if (freq_in > 0) {
                pair<int, int> existing = {freq_in, val_in};
                auto it_top_in = topSet.find(existing);
                if (it_top_in != topSet.end()) {
                    topSet.erase(it_top_in);
                    sumTop -= static_cast<int>(freq_in) * val_in;
                }
                else {
                    auto it_rest_in = restSet.find(existing);
                    if (it_rest_in != restSet.end()) {
                        restSet.erase(it_rest_in);
                    }
                }
            }

            freqMap[val_in] = freq_in + 1;
            pair<int, int> updated_in = {freq_in + 1, val_in};

            if (topSet.size() < x) {
                topSet.insert(updated_in);
                sumTop += static_cast<int>(updated_in.first) * updated_in.second;
            }
            else {
                auto it_last_top = prev(topSet.end());
                if (cmp()(updated_in, *it_last_top)) {
                    topSet.insert(updated_in);
                    sumTop += static_cast<int>(updated_in.first) * updated_in.second;
                    pair<int, int> to_move = *it_last_top;
                    sumTop -= static_cast<int>(to_move.first) * to_move.second;
                    topSet.erase(it_last_top);
                    restSet.insert(to_move);
                }
                else {
                    restSet.insert(updated_in);
                }
            }

            while (topSet.size() < x && !restSet.empty()) {
                auto it_move = restSet.begin();
                topSet.insert(*it_move);
                sumTop += static_cast<int>(it_move->first) * it_move->second;
                restSet.erase(it_move);
            }

            if (topSet.size() > x) {
                auto it_move = prev(topSet.end());
                pair<int, int> to_move = *it_move;
                sumTop -= static_cast<int>(to_move.first) * to_move.second;
                topSet.erase(it_move);
                restSet.insert(to_move);
            }

            answer.push_back(sumTop);
        }

        return answer;
    }
};",1420561959
Manan Rathod,Manan04,42,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        helper = []
        def check(head, deep, c):
            if(head.left == None and head.right == None):
                c.append(deep)
                return
            if(head.left == None or head.right == None):
                c.append(-1)
                return
            check(head.right, deep + 1, c)
            check(head.left, deep + 1, c)
        def sol(head):
            if(head == None):
                return
            b = []
            check(head, 1, b)
            if(-1 in b):
                pass
            else:
                s = set(b)
                if(len(s) > 1):
                    pass
                else:
                    v = b[-1]
                    helper.append((1 << v) - 1)
            sol(head.right)
            sol(head.left)
        sol(root)
        helper.sort()
        if(len(helper) < k):
            return -1
        return helper[len(helper) - k]",1420549945
Manan Rathod,Manan04,42,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        dp = [[[-1 for i in range(4)] for i in range(n * 2 + 1)] for i in range(n)]
        b = ['F', 'W', 'E']
        mod = 10 ** 9 + 7
        def sol(idx, bob, prev):
            if(idx >= n):
                return bob > n
            if(dp[idx][bob][prev] != -1):
                return dp[idx][bob][prev]
            ans = 0
            for i in range(3):
                if(prev == i):
                    continue
                bob_val = b[i]
                al_val = s[idx]
                if(bob_val == 'F' and al_val == 'E'):
                    ans += sol(idx + 1, bob + 1, i)
                elif(bob_val == 'F' and al_val == 'W'):
                    ans += sol(idx + 1, bob - 1, i)
                elif(bob_val == 'W' and al_val == 'F'):
                    ans += sol(idx + 1, bob + 1, i)
                elif(bob_val == 'W' and al_val == 'E'):
                    ans += sol(idx + 1, bob - 1, i)
                elif(bob_val == 'E' and al_val == 'F'):
                    ans += sol(idx + 1, bob - 1, i)
                elif(bob_val == 'E' and al_val == 'W'):
                    ans += sol(idx + 1, bob + 1, i)
                else:
                    ans += sol(idx + 1, bob, i)
                ans %= mod
            ans %= mod
            dp[idx][bob][prev] = ans
            return dp[idx][bob][prev]
        return sol(0, n, 3) % mod",1420561976
Manan Rathod,Manan04,42,3592,python3,"from bisect import bisect_left as lower_bound
from bisect import bisect_right as upper_bound


class FenwickTree:
    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | (i + 1)
            if j < size:
                bit[j] += bit[i]

    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1

    def __call__(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def find_kth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1, k


class SortedList:
    block_size = 700

    def __init__(self, iterable=()):
        self.macro = []
        self.micros = [[]]
        self.micro_size = [0]
        self.fenwick = FenwickTree([0])
        self.size = 0
        for item in iterable:
            self.insert(item)

    def insert(self, x):
        i = lower_bound(self.macro, x)
        j = upper_bound(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]
            self.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])

    def pop(self, k=-1):
        i, j = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)

    def __getitem__(self, k):
        i, j = self._find_kth(k)
        return self.micros[i][j]

    def count(self, x):
        return self.upper_bound(x) - self.lower_bound(x)

    def __contains__(self, x):
        return self.count(x) > 0

    def lower_bound(self, x):
        i = lower_bound(self.macro, x)
        return self.fenwick(i) + lower_bound(self.micros[i], x)

    def upper_bound(self, x):
        i = upper_bound(self.macro, x)
        return self.fenwick(i) + upper_bound(self.micros[i], x)

    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)

    def __len__(self):
        return self.size

    def __iter__(self):
        return (x for micro in self.micros for x in micro)

    def __repr__(self):
        return str(list(self))
class Solution:
    def findXSum(self, a: List[int], k: int, x: int) -> List[int]:
        n = len(a)
        l = SortedList()
        ans = []
        global c
        c = 0
        cnt = defaultdict(int)
        in_top = defaultdict(int)
        def update(val, sgn):
            global c
            cur_cnt = cnt[val]
            if(cur_cnt > 0):
                idx = l.lower_bound([cur_cnt, val])
                top = len(l) - idx
                if(top <= x):
                    c -= cnt[val] * val
                    in_top[val] = 0
                l.pop(idx)
            # if(val == 1 and sgn == -1):
            #     print(c)
            cnt[val] += sgn
            if(cnt[val] > 0):
                l.insert([cnt[val], val])
                idx = l.lower_bound([cnt[val], val])
                top = len(l) - idx
                if(top <= x):
                    c += cnt[val] * val
                    in_top[val] = 1
            # if(val == 1 and sgn == -1):
            #     print(c)
            if(len(l) > x):
                prev_cnt, prev_val = l[len(l) - (x + 1)]
                if(in_top[prev_val]):
                    in_top[prev_val] = 0
                    c -= cnt[prev_val] * prev_val
            if(len(l) >= x):
                new_cnt, new_val = l[len(l) - x]
                if(in_top[new_val] == 0):
                    in_top[new_val] = 1
                    c += cnt[new_val] * new_val
        for i in range(n):
            update(a[i], 1)
            if(i >= k):
                update(a[i - k], -1)
            if(i + 1 >= k):
                ans.append(c)
            # print(l, c)
        return ans",1420541009
Manan Rathod,Manan04,42,3610,python3,"from bisect import bisect_left as lower_bound
from bisect import bisect_right as upper_bound


class FenwickTree:
    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | (i + 1)
            if j < size:
                bit[j] += bit[i]

    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1

    def __call__(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x

    def find_kth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1, k


class SortedList:
    block_size = 700

    def __init__(self, iterable=()):
        self.macro = []
        self.micros = [[]]
        self.micro_size = [0]
        self.fenwick = FenwickTree([0])
        self.size = 0
        for item in iterable:
            self.insert(item)

    def insert(self, x):
        i = lower_bound(self.macro, x)
        j = upper_bound(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]
            self.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])

    def pop(self, k=-1):
        i, j = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)

    def __getitem__(self, k):
        i, j = self._find_kth(k)
        return self.micros[i][j]

    def count(self, x):
        return self.upper_bound(x) - self.lower_bound(x)

    def __contains__(self, x):
        return self.count(x) > 0

    def lower_bound(self, x):
        i = lower_bound(self.macro, x)
        return self.fenwick(i) + lower_bound(self.micros[i], x)

    def upper_bound(self, x):
        i = upper_bound(self.macro, x)
        return self.fenwick(i) + upper_bound(self.micros[i], x)

    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)

    def __len__(self):
        return self.size

    def __iter__(self):
        return (x for micro in self.micros for x in micro)

    def __repr__(self):
        return str(list(self))
class Solution:
    def findXSum(self, a: List[int], k: int, x: int) -> List[int]:
        n = len(a)
        l = SortedList()
        ans = []
        global c
        c = 0
        cnt = defaultdict(int)
        in_top = defaultdict(int)
        def update(val, sgn):
            global c
            cur_cnt = cnt[val]
            if(cur_cnt > 0):
                idx = l.lower_bound([cur_cnt, val])
                top = len(l) - idx
                if(top <= x):
                    c -= cnt[val] * val
                    in_top[val] = 0
                l.pop(idx)
            # if(val == 1 and sgn == -1):
            #     print(c)
            cnt[val] += sgn
            if(cnt[val] > 0):
                l.insert([cnt[val], val])
                idx = l.lower_bound([cnt[val], val])
                top = len(l) - idx
                if(top <= x):
                    c += cnt[val] * val
                    in_top[val] = 1
            # if(val == 1 and sgn == -1):
            #     print(c)
            if(len(l) > x):
                prev_cnt, prev_val = l[len(l) - (x + 1)]
                if(in_top[prev_val]):
                    in_top[prev_val] = 0
                    c -= cnt[prev_val] * prev_val
            if(len(l) >= x):
                new_cnt, new_val = l[len(l) - x]
                if(in_top[new_val] == 0):
                    in_top[new_val] = 1
                    c += cnt[new_val] * new_val
        for i in range(n):
            update(a[i], 1)
            if(i >= k):
                update(a[i - k], -1)
            if(i + 1 >= k):
                ans.append(c)
            # print(l, c)
        return ans",1420541363
zaneyu2005,zaneyu2005,43,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=100+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=998244353;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
class Solution {
public:
    vector<int> vv;
    pii dfs(TreeNode* x,int d){
        int c=0;
        vector<pii> v;
        if(x->left) v.pb(dfs(x->left,d+1)),++c;
        if(x->right) v.pb(dfs(x->right,d+1)),++c;
        if(c==2){
            if(v[0].f==v[1].f and v[0].f!=-1){
                vv.pb(v[0].s+v[1].s+1);
                return {v[0].f,v[0].s+v[1].s+1};
            }
            return {-1,-1};
        }
        else if(c==0){
            vv.pb(1);
            return {d,1};
        }
        else{
            return {-1,-1};
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vv.clear();
        dfs(root,0);
        sort(ALL(vv));
        if(sz(vv)<k){
            return -1;
        }
        reverse(ALL(vv));
        return vv[k-1];
    }
};",1420522102
zaneyu2005,zaneyu2005,43,3588,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=2000+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
class Solution {
public:
    int dp[maxn][3],ndp[maxn][3];
    int to(char c){
        if(c=='F') return 0;
        if(c=='W') return 1;
        return 2;
    }
    int vs(int a,int b){
        if(b==(a+1)%3){
            return 1;
        }
        if(a==b){
            return 0;
        }
        return -1;
    }
    int countWinningSequences(string s) {
        int n=sz(s);
        dp[1000][0]=1;
        REP(i,n){
            int x=to(s[i]);
            REP(a,maxn) REP(j,3) ndp[a][j]=0;
            REP1(a,maxn-2){
                REP(j,3){
                    REP(k,3){
                        if(i!=0 and j==k) continue;
                        int pt=vs(x,k);
                        ndp[a+pt][k]+=dp[a][j];
                        ndp[a+pt][k]%=MOD;
                    }
                }
            }
            REP(a,maxn) REP(j,3) dp[a][j]=ndp[a][j];
        }
        int ans=0;
        for(int i=1001;i<maxn;i++){
            REP(j,3) ans+=dp[i][j],ans%=MOD;
        }
        return ans;
    }

};",1420530147
zaneyu2005,zaneyu2005,43,3592,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=2e5+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=998244353;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
int mx;
struct pp{
    multiset<pii> ma,mb;
    map<ll,ll> occ;
    ll sum=0;
    void de(int x){
        if(mb.find({occ[x],x})!=mb.end()){
            mb.erase({occ[x],x});
        }
        else if(ma.find({occ[x],x})!=ma.end()){
            sum-=occ[x]*x;
            ma.erase({occ[x],x});
        }
    }
    bool cmp(int a,int b){
        if(occ[a]>occ[b]){
            return true;
        }
        if(occ[a]<occ[b]){
            return false;
        }
        return (a>b);
    }
    void add(int x){
        de(x);
        occ[x]++;
        if(sz(ma)<mx){
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
            return;
        }
        int z=(*ma.begin()).s;
        if(cmp(x,z)){
            de(z);
            mb.insert({occ[z],z});
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
        }
        else{
            mb.insert({occ[x],x});
        }
    }
    void del(int x){
        de(x);
        occ[x]--;
        if(sz(ma)==mx){
            mb.insert({occ[x],x});
            return;
        }
        if(!sz(mb)){
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
            return;
        }
        int z=(*mb.rbegin()).s;
        if(cmp(z,x)){
            sum+=occ[z]*z;
            ma.insert({occ[z],z});
            mb.insert({occ[x],x});
            mb.erase(prev(mb.end()));
        }
        else{
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
        }
    }
};
class Solution {
public:

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        mx=x;
        pp p;
        REP(i,k) p.add(nums[i]);
        vector<ll> ans;
        ans.pb(p.sum);
        REP(i,sz(nums)-k){
            p.add(nums[i+k]);
            p.del(nums[i]);
            ans.pb(p.sum);
        }
        return ans;
    }
};",1420550951
zaneyu2005,zaneyu2005,43,3610,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<ll,ll>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=2e5+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const ll MOD=998244353;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?""\n"":"""");
    return out;
}
int mx;
struct pp{
    multiset<pii> ma,mb;
    map<ll,ll> occ;
    ll sum=0;
    void de(int x){
        if(mb.find({occ[x],x})!=mb.end()){
            mb.erase({occ[x],x});
        }
        else if(ma.find({occ[x],x})!=ma.end()){
            sum-=occ[x]*x;
            ma.erase({occ[x],x});
        }
    }
    bool cmp(int a,int b){
        if(occ[a]>occ[b]){
            return true;
        }
        if(occ[a]<occ[b]){
            return false;
        }
        return (a>b);
    }
    void add(int x){
        de(x);
        occ[x]++;
        if(sz(ma)<mx){
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
            return;
        }
        int z=(*ma.begin()).s;
        if(cmp(x,z)){
            de(z);
            mb.insert({occ[z],z});
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
        }
        else{
            mb.insert({occ[x],x});
        }
    }
    void del(int x){
        de(x);
        occ[x]--;
        if(sz(ma)==mx){
            mb.insert({occ[x],x});
            return;
        }
        if(!sz(mb)){
            ma.insert({occ[x],x});
            sum+=occ[x]*x;
            return;
        }
        int z=(*mb.rbegin()).s;
        if(cmp(z,x)){
            sum+=occ[z]*z;
            ma.insert({occ[z],z});
            mb.insert({occ[x],x});
            mb.erase(prev(mb.end()));
        }
        else{
            sum+=occ[x]*x;
            ma.insert({occ[x],x});
        }
    }
};
class Solution {
public:

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        mx=x;
        pp p;
        REP(i,k) p.add(nums[i]);
        vector<int> ans;
        ans.pb(p.sum);
        REP(i,sz(nums)-k){
            p.add(nums[i+k]);
            p.del(nums[i]);
            ans.pb(p.sum);
        }
        return ans;
    }
};",1420551451
dirigibility,dirigibility,44,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        def dfs(node):
            if not node:
                return 0
            l = dfs(node.left)
            r = dfs(node.right)
            if l == r and l != -1:
                sizes.append(1+l+r)
                return 1+l+r
            return -1
        dfs(root)
        sizes.sort()
        return sizes[-k] if k <= len(sizes) else -1",1420521647
dirigibility,dirigibility,44,3588,python3,"mod = 10**9+7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def f(i,d,prev):
            if i == len(s):
                return int(d > 0)
            total = 0
            for cur in 'FWE':
                if cur == prev:
                    continue
                if cur == s[i]:
                    total += f(i+1,d,cur)
                elif (cur == 'F' and s[i] == 'E') or (cur == 'W' and s[i] == 'F') or (cur == 'E' and s[i] == 'W'):
                    total += f(i+1,d+1,cur)
                else:
                    total += f(i+1,d-1,cur)
            return total%mod
        try:    
            return f(0,0,'')
        finally:
            f.cache_clear()",1420527355
dirigibility,dirigibility,44,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        active = SortedList()
        freq = Counter()
        t = 0
        def update(n,df):
            nonlocal t
            if n in freq:
                i = active.bisect_left((freq[n],n))
                active.pop(i)
                if len(active)+1-i <= x:
                    t -= freq[n]*n
                    if len(active) >= x:
                        t += active[-x][0]*active[-x][1]
            freq[n] += df
            if not freq[n]:
                del freq[n]
                return
            active.add((freq[n],n))
            i = active.bisect_left((freq[n],n))
            if len(active)-i <= x:
                t += freq[n]*n
                if len(active) >= x+1:
                    t -= active[-x-1][0]*active[-x-1][1]
        for i,n in enumerate(nums):
            update(n,1)
            if i >= k-1:
                result.append(t)
                update(nums[i-k+1],-1)
        return result",1420564238
dirigibility,dirigibility,44,3610,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        active = SortedList()
        freq = Counter()
        t = 0
        def update(n,df):
            nonlocal t
            if n in freq:
                i = active.bisect_left((freq[n],n))
                active.pop(i)
                if len(active)+1-i <= x:
                    t -= freq[n]*n
                    if len(active) >= x:
                        t += active[-x][0]*active[-x][1]
            freq[n] += df
            if not freq[n]:
                del freq[n]
                return
            active.add((freq[n],n))
            i = active.bisect_left((freq[n],n))
            if len(active)-i <= x:
                t += freq[n]*n
                if len(active) >= x+1:
                    t -= active[-x-1][0]*active[-x-1][1]
        for i,n in enumerate(nums):
            update(n,1)
            if i >= k-1:
                result.append(t)
                update(nums[i-k+1],-1)
        return result",1420564633
OTTFF,OTTFF,45,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    pair<int, int> dfs(TreeNode* u) {
        if (!u) return {0, 1};
        auto lans = dfs(u->left);
        auto rans = dfs(u->right);
        if (lans.second && rans.second && lans.first == rans.first) {
            int sz = lans.first * 2 + 1;
            ans.push_back(sz);
            return {sz, 1};
        } else {
            return {0, 0};
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        ans.clear();
        dfs(root);
        sort(ans.rbegin(), ans.rend());
        if (ans.size() < k) return -1;
        return ans[k - 1];
    }
};",1420520627
OTTFF,OTTFF,45,3588,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

const int M = 1000;
const int MM = M * 2 + 1;
Mint dp[2][MM][3];

class Solution {
public:
int toit(char c) {
    if (c == 'F') return 0;
    if (c == 'E') return 1;
    return 2;
}
    int countWinningSequences(string s) {
        int n = s.length();
        
        for (int i = 0; i < MM; i++) {
            for (int j = 0; j < 3; j++) {
                dp[0][i][j] = 0;
            }
        }

        for (int i = 0; i < 3; i++) {
            if ((i + 1) % 3 == toit(s[0])) {
                dp[0][M + 1][i] = 1;
            } else if ((i + 2) % 3 == toit(s[0])) {
                dp[0][M - 1][i] = 1;
            } else {
                dp[0][M][i] = 1;
            }
        }

        // cout << ""here"" << endl;

        for (int ii = 1; ii < n; ii++) {
            for (int i = 0; i < MM; i++) {
                for (int j = 0; j < 3; j++) {
                    dp[ii & 1][i][j] = 0;
                }
            }

            for (int i = -ii; i <= ii; i++) {
                for (int j = 0; j < 3; j++) { // pre i, j
                    for (int k = 0; k < 3; k++) {
                        if (j == k) continue;

                        if ((k + 1) % 3 == toit(s[ii])) {
                            dp[ii & 1][i + 1 + M][k] += dp[(ii & 1) ^ 1][i + M][j];
                        } else if ((k + 2) % 3 == toit(s[ii])) {
                            dp[ii & 1][i - 1 + M][k] += dp[(ii & 1) ^ 1][i + M][j];
                        } else {
                            dp[ii & 1][i + M][k] += dp[(ii & 1) ^ 1][i + M][j];
                        }
                    }
                    
                }
            }
        }

        Mint ans = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < 3; j++) {
                ans += dp[(n - 1) & 1][i + M][j];
            }
        }
        return ans.x;
    }
};",1420536970
OTTFF,OTTFF,45,3592,cpp,"typedef long long LL;
typedef pair<int, int> PII;

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        
        map<int, int> cnt;
        for (int i : a) cnt[i] = 0;

        set<PII> large, small;
        LL sum = 0;
        for (auto [v, c] : cnt) {
            large.insert({0, v});

            if ((int)large.size() > x) {
                auto p = *large.begin();
                large.erase(p);
                small.insert(p);
            }
        }

        auto show = [&]() {
            cout << ""large : "";
            for (auto [c, v] : large) cout << ""{"" << c << "","" << v << ""}"";
            cout << ""\n""; 
            cout << ""small : "";
            for (auto [c, v] : small) cout << ""{"" << c << "","" << v << ""}"";
            cout << ""\n"";
            cout << ""cnt : "";
            for (auto [c, v] : cnt) cout << ""{"" << c << "","" << v << ""}"";
            cout << ""\n""; 
            cout << ""sum = "" << sum << endl;
        };
        
        auto ins = [&](int v) {
            // cout << ""ins "" << v << endl;
            PII oldp = {cnt[v], v};
            if (auto it = large.find(oldp); it != large.end()) {
                large.erase(it);
                sum -= 1LL * cnt[v] * v;
                if (!small.empty()) {
                    auto it = --small.end();
                    large.insert(*it);
                    sum += 1LL * it->first * it->second;
                    small.erase(it);
                }
            } else {
                small.erase(oldp);
            }
            
            cnt[v]++;
            large.insert({cnt[v], v});
            sum += 1LL * cnt[v] * v;

            if ((int)large.size() > x) {
                auto p = *large.begin();
                sum -= 1LL * p.first * p.second;
                large.erase(p);
                small.insert(p);
            }
        };

        auto del = [&](int v) {
            PII oldp = {cnt[v], v};
            if (auto it = large.find(oldp); it != large.end()) {
                large.erase(it);
                sum -= 1LL * cnt[v] * v;
                if (!small.empty()) {
                    auto it = --small.end();
                    large.insert(*it);
                    sum += 1LL * it->first * it->second;
                    small.erase(it);
                }
            } else {
                small.erase(oldp);
            }
            cnt[v]--;
            large.insert({cnt[v], v});
            sum += 1LL * cnt[v] * v;

            if ((int)large.size() > x) {
                auto p = *large.begin();
                sum -= 1LL * p.first * p.second;
                large.erase(p);
                small.insert(p);
            }
        };

        // show();

        for (int i = 0; i < k - 1; i++) {
            ins(a[i]);
            // show();
        }

        vector<LL> ans;
        for (int i = k - 1; i < n; i++) {
            ins(a[i]);
            // show();

            ans.push_back(sum);

            del(a[i - k + 1]);
        }

        return ans;
    }
};",1420570516
OTTFF,OTTFF,45,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        vector<int> ans;

        map<int, int> cnt;
        for (int i = 0; i + k - 1 < n; i++) {
            cnt.clear();
            for (int j = 0; j < k; j++) {
                cnt[a[i + j]]++;
            }

            vector<pair<int, int>> b;
            for (auto [v, c] : cnt) {
                b.push_back({c, v});
            }
            sort(b.rbegin(), b.rend());

            int sz = b.size();
            if (x < sz) sz = x;
            int sum = 0;
            for (int i = 0; i < sz; i++) {
                sum += b[i].first * b[i].second;
            }
            ans.push_back(sum);
        }

        return ans;
    }
};",1420545607
sammochen,sammochen,46,3509,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

class Solution {
public:
    vector<int> depths;
    int dfs(TreeNode* root) {

        if (!root) {
            return -1;
        }

        if (!root->left && !root->right) {
            // good
            depths.push_back(1);
            return 1;
        }
       
        int left = dfs(root->left);
        int right = dfs(root->right);
        if (left == -1 || right == -1) return -1;
        if (left != right) return -1;

        // good

        depths.push_back(left * 2 + 1);
        return left  * 2 + 1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(depths.rbegin(), depths.rend());

        // for (auto d : depths) cout << d << ' ';
        // cout << endl;
        k--;
        if (k >= depths.size()) return -1;
        return depths[k];
    }
};
",1420522783
sammochen,sammochen,46,3588,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

ll dp[1005][2010][3];

class Solution {
public:
    ll n;
    string s;
    string t = ""FEW"";

    ll getInd(char c) {
        rep(j, 0, 3) {
            if (c == t[j]) return j;
        }
        return -1;
    }

    ll get(ll ind, ll diff, ll prev) {
        if (ind == n) {
            if (diff > 0) return 1;
            return 0;
        }

        ll& ans = dp[ind][diff + 1005][prev];
        if (ans != -1) return ans;

        ans = 0;
        rep(j, 0, 3) {
            // bob chooses j

            if (ind != 0 && prev == j) continue;

            ll aliceInd = getInd(s[ind]);
            ll result = aliceInd == j ? 0 : (j + 1) % 3 == aliceInd ? 1 : -1;

            ans += get(ind + 1, diff + result, j);
            ans %= mod;
        }

        return ans;
    }
    int countWinningSequences(string s) {  // !
        this->s = s;
        n = s.size();

        rep(i, 0, n) {
            rep(j, 0, 2005) {
                rep(k, 0, 3) {
                    dp[i][j][k] = -1;
                }
            }
        }

        return get(0, 0, 0);
    }
};
",1420533675
sammochen,sammochen,46,3592,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

class Solution {
public:
    ll Bsize;
    ll Bsum = 0;
    umap<ll, ll> M;
    set<PLL> A, B;  // freq, number

    void move(set<PLL>& from, set<PLL>& to, const PLL& x) {
        to.insert(x);
        from.erase(x);
    }

    void moveBA() {
        Bsum -= B.begin()->first * B.begin()->second;
        move(B, A, *B.begin());
    }
    void moveAB() {
        Bsum += A.rbegin()->first * A.rbegin()->second;
        move(A, B, *A.rbegin());
    }

    void remove(const PLL& x) {
        if (A.count(x)) A.erase(x);
        if (B.count(x)) {
            Bsum -= x.first * x.second;
            B.erase(x);
        }
        balance();
    }

    void add(const PLL& x) {
        A.insert(x);
        moveAB();
        moveBA();
        balance();
    }

    void balance() {
        while (B.size() > Bsize) {
            moveBA();
        }

        while (A.size() && B.size() < Bsize) {
            moveAB();
        }
    }

    void updateMapping(ll x, ll inc) {
        remove({M[x], x});

        M[x] += inc;

        add({M[x], x});

    }

    vector<ll> findXSum(vector<int>& arr, int k, int x) {  // !
        Bsize = x;
        ll n = arr.size();

        rep(i, 0, k) {
            updateMapping(arr[i], 1);
        }

        VLL ans = {Bsum};

        // we have our first answer

        rep(i, k, n) {
            updateMapping(arr[i - k], -1);
            updateMapping(arr[i], 1);
            ans.push_back(Bsum);
        }
        return ans;
    }
};
",1420557213
sammochen,sammochen,46,3610,cpp,"
#include <bits/stdc++.h>
using namespace std;

#ifdef DEBUG
#include ""debug.h""
#else
#define debug(...) 1
#endif

using ll = long long;
using db = long double;
using VS = vector<string>;
using VLL = vector<ll>;
using VVLL = vector<VLL>;
using VVVLL = vector<VVLL>;
using PLL = pair<ll, ll>;
using MLL = map<ll, ll>;
using SLL = set<ll>;
using QLL = queue<ll>;
using SS = stringstream;

#define rep(x, l, u) for (ll x = l; x < u; x++)
#define rrep(x, l, u) for (ll x = l; x >= u; x--)
#define fe(x, a) for (auto x : a)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define mst(x, v) memset(x, v, sizeof(x))
#define sz(x) (ll) x.size()

#define umap unordered_map
#define uset unordered_set
#define mset multiset

// clang-format off

ll ob(ll i, ll n) { return i < 0 || i >= n; }
ll tp(ll x) { return ( 1LL << x ); }
ll rup(ll a, ll b) { return a % b ? a/b + 1 : a/b; }
ll sign(ll x) {	return x == 0 ? 0 : x / abs(x); }
void makemod(ll& x, ll m) { x %= m; if (x < 0) { x += m; } }
ll getmod(ll x, ll m) { makemod(x, m); return x; }
ll powmod(ll a, ll b, ll m) { if (b == 0) return 1; ll h = powmod(a, b/2, m); ll ans = h*h%m; return b%2 ? ans*a%m : ans; }
ll invmod(ll a, ll m) { return powmod(a, m - 2, m); }
void inll(ll& x) { scanf(""%lld"", &x); }

template <typename A, typename B> bool upmin(A& x, B v) { if (v >= x) return false; return x = v, true; }
template <typename A, typename B> bool upmax(A& x, B v) { if (v <= x) return false; return x = v, true; }
// clang-format on

const VLL di = {0, 0, 1, -1, 1, -1, 1, -1}, dj = {1, -1, 0, 0, -1, -1, 1, 1};
const ll inf = 1e18;
const ll mod = 1e9 + 7;
const string vowels = ""aeiou"";
ll isvowel(char c) {
    c = tolower(c);
    return vowels.find(c) != string::npos;
}

class Solution {
public:
    ll Bsize;
    ll Bsum = 0;
    umap<ll, ll> M;
    set<PLL> A, B;  // freq, number

    void move(set<PLL>& from, set<PLL>& to, const PLL& x) {
        to.insert(x);
        from.erase(x);
    }

    void moveBA() {
        Bsum -= B.begin()->first * B.begin()->second;
        move(B, A, *B.begin());
    }
    void moveAB() {
        Bsum += A.rbegin()->first * A.rbegin()->second;
        move(A, B, *A.rbegin());
    }

    void remove(const PLL& x) {
        if (A.count(x)) A.erase(x);
        if (B.count(x)) {
            Bsum -= x.first * x.second;
            B.erase(x);
        }
        balance();
    }

    void add(const PLL& x) {
        A.insert(x);
        moveAB();
        moveBA();
        balance();
    }

    void balance() {
        while (B.size() > Bsize) {
            moveBA();
        }

        while (A.size() && B.size() < Bsize) {
            moveAB();
        }
    }

    void updateMapping(ll x, ll inc) {
        remove({M[x], x});

        M[x] += inc;

        add({M[x], x});

    }

    vector<int> findXSum(vector<int>& arr, int k, int x) {  // !
        Bsize = x;
        ll n = arr.size();

        rep(i, 0, k) {
            updateMapping(arr[i], 1);
        }

        vector<int> ans = {(int)Bsum};

        // we have our first answer

        rep(i, k, n) {
            updateMapping(arr[i - k], -1);
            updateMapping(arr[i], 1);
            ans.push_back(Bsum);
        }
        return ans;
    }
};
",1420558811
Sandeep P,Sandeep_P,47,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans=[]
        def dfs(node):
            if not node.left and not node.right:
                ans.append(1)
                return True,1,0
            if node.left and node.right:
                a,b,c=dfs(node.left)
                d,e,f=dfs(node.right)
                if a and d and c==f:
                    ans.append( b+e+1 )
                    return True,b+e+1,c+1
                else:
                    return False,0,0
            else:
                if node.left:
                    dfs(node.left)
                if node.right:
                    dfs(node.right)
                return False,0,0
            
        dfs(root)
        ans.sort()
        if len(ans)<k:
            return -1
        return ans[-k]
        

",1420544015
Sandeep P,Sandeep_P,47,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        opts=""FWE""
        n=len(s)
        @cache
        def dp(i,prev='',score=0):
            if i==n:
                return 1 if score<0 else 0
            x=s[i]
            ans=0
            for y in opts:
                if y==prev:
                    continue
                if x=='F' and y=='E':
                    cur_sc=1
                elif x=='W' and y=='F':
                    cur_sc=1
                elif x=='E' and y=='W':
                    cur_sc=1
                elif x==y:
                    cur_sc=0
                else:
                    cur_sc=-1
                ans+=dp(i+1,y,score+cur_sc)
            return ans % (10**9+7)
        return dp(0)",1420559424
Sandeep P,Sandeep_P,47,3592,python3,"from sortedcontainers import SortedList

class SL2():
    def __init__(self,x):
        self.a=SortedList()
        self.b=SortedList()
        self.sm=0
        self.x=x


    def add(self,c,x):
        self.b.add( (c,x) )
        self.sm+=c*x
        if len(self.b)>self.x:
            m=self.b[0]
            self.sm-=m[0]*m[1]
            self.b.remove(m)
            self.a.add(m)

    def discard(self,c,x):
        if (c,x)>=self.b[0]:
            self.sm-=c*x
            self.b.discard((c,x))
            if len(self.b)<self.x and self.a:
                m=self.a[-1]
                self.sm+=m[0]*m[1]
                self.a.remove(m)
                self.b.add(m)
        else:
            self.a.discard((c,x))


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        i=0
        c=Counter()
        n=len(nums)
        sl=SL2(x)
        ans=[]
        for j in range(n):
            cur=nums[j]
            if c[cur]>0:
                sl.discard(c[cur],cur)
            c[cur]+=1
            sl.add(c[cur],cur)

            if j-i+1>k:
                cur=nums[i]
                sl.discard(c[cur],cur)
                c[cur]-=1
                if c[cur]>0:
                    sl.add(c[cur],cur)
                i+=1
            if j-i+1==k:
                ans.append(sl.sm)
        return ans",1420531488
Sandeep P,Sandeep_P,47,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        i=0
        c=Counter()
        n=len(nums)
        ans=[]
        for j in range(n):
            c[nums[j]]+=1
            if j-i+1>k:
                c[nums[i]]-=1
                i+=1
            if j-i+1==k:
                take=x
                cur=0
                arr=list(c.most_common())
                for val,ct in sorted(arr,key=lambda x:x[::-1],reverse=True):
                    if take==0:
                        break
                    cur+=val*ct
                    take-=1
                ans.append(cur)
        return ans


",1420521166
Ethan,ethanrao,48,3509,cpp,"#include<bits/stdc++.h>
#define ll long long
#define all(x) x.rbegin(),x.rend()
#define pb push_back
class Solution {
public:
    pair<bool, int> dfs(TreeNode* node, vector<int>& ans) {
        if (!node) return {true, 0};  

        auto [l, lsize] = dfs(node->left, ans);
        auto [r, rsize] = dfs(node->right, ans);
        
        if (l && r && lsize == rsize) {
            ans.pb(lsize + rsize + 1);  
            return {true, lsize + rsize + 1};
        } else {
            return {false, 0};  
        }
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;  
        dfs(root, ans);
        int n = ans.size();
        if (n < k) return -1;

        sort(all(ans));  
        return ans[k - 1]; 
    }
};",1420528279
Ethan,ethanrao,48,3588,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    int f[1005][2005][3], a[1005];
    int countWinningSequences(string s) {
        int n = s.size();
        if(s[0] == 'F'){
            f[0][1][0] = 1;
            f[0][2][1] = 1;
            f[0][0][2] = 1;
        }
        else if(s[0] == 'W'){
            f[0][0][0] = 1;
            f[0][1][1] = 1;
            f[0][2][2] = 1;
        }
        else {
            f[0][2][0] = 1;
            f[0][0][1] = 1;
            f[0][1][2] = 1;
        }
        for(int i = 0; i < n; ++i){
            if(s[i] == 'F') a[i] = 0;
            else if(s[i] == 'W') a[i] = 1;
            else a[i] = 2;
        }
        for(int i = 1; i < n; ++i){
            for(int j = 0; j <= 2 * i; ++j){
                for(int k = 0; k <= 2; ++k){
                    for(int t = 0; t <= 2; ++t){
                        if(t == k) continue;
                        int tar = j;
                        if((t - a[i] + 3) % 3 == 1) tar += 2;
                        else if((t - a[i] + 3) % 3 == 2) tar += 0;
                        else tar += 1;
                        f[i][tar][t] = add(f[i][tar][t], f[i - 1][j][k]);
                    }
                }
            }
        }
        int ans = 0;
        for(int i = n + 1; i <= 2 * n; ++i)
            for(int j = 0; j <= 2; ++j)
                ans = add(ans, f[n - 1][i][j]);
        return ans;
    }
};",1420530295
Ethan,ethanrao,48,3592,cpp,"class Solution {
public:
    std::map <int, int> mp;
    struct node{
        int x, c;
        friend bool operator<(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x < b.x;
        }
        friend bool operator<=(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x <= b.x;
        }
    };
    int n, tot = 0, root = 0;
    int ch[400005][2], siz[400005], pri[400005];
    node val[400005];
    long long sum[200005];
    inline void up(int x){
      siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;
      sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + 1ll * val[x].x * val[x].c;
      return ;
    }
    inline int New(node x){
      val[++tot] = x;
      siz[tot] = 1;
      sum[tot] = 1ll * val[tot].x * val[tot].c;
      pri[tot] = rand() % 114114;
      return tot;
    }
    int merge(int x, int y){
      if(!x || !y) return x | y;
      if(pri[x] < pri[y]){
        ch[x][1] = merge(ch[x][1], y);
        up(x);
        return x;
      }
      else {
        ch[y][0] = merge(x, ch[y][0]);
        up(y);
        return y;
      }
    }
    void split(int now, node v, int &x, int &y){
      if(!now) x = y = 0;
      else {
        if(val[now] <= v){
          x = now;
          split(ch[x][1], v, ch[x][1], y);
          up(x);
        }
        else {
          y = now;
          split(ch[y][0], v, x, ch[y][0]);
          up(y);
        }
      }
      return ;
    }
    inline void insert(node v){
      int x, y;
      split(root, v, x, y);
      int nd = New(v);
      root = merge(merge(x, nd), y);
      return ;
    }
    inline void erase(node v){
      int x, y, z;
      split(root, v, x, y);
      node vv = v; vv.x -= 1;
      split(x, vv, x, z);
      z = merge(ch[z][0], ch[z][1]);
      root = merge(merge(x, z), y);
      return ;
    }
    long long ask(int k){
        long long ans = 0ll;
        int now = root;
        if(root == 0 || siz[root] <= k) return sum[root];
        while(true){
            if(k == 0) return ans;
            if(siz[ch[now][1]] < k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                k -= 1;
                ans += 1ll * val[now].x * val[now].c;
                now = ch[now][0];
            }
            else if(siz[ch[now][1]] == k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                return ans;
            }
            else now = ch[now][1];
        }
        return ans;
    }
    void add(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c += 1;
        insert(pre);
        mp[x] += 1;
        return ;
    }
    void remove(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c -= 1;
        insert(pre);
        mp[x] -= 1;
        return ;
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        srand((unsigned)time(0));
        n = nums.size();
        mp.clear();
        std::vector <long long> ans;
        for(int i = 0; i < k; ++i) add(nums[i]);
        ans.resize(n - k + 1);
        ans[0] = ask(x);
        for(int i = 1; i <= n - k; ++i){
            add(nums[i + k - 1]);
            remove(nums[i - 1]);
            ans[i] = ask(x);
        }
        return ans;
    }
};",1420558371
Ethan,ethanrao,48,3610,cpp,"class Solution {
public:
    std::map <int, int> mp;
    struct node{
        int x, c;
        friend bool operator<(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x < b.x;
        }
        friend bool operator<=(node a, node b){
            if(a.c != b.c) return a.c < b.c;
            else return a.x <= b.x;
        }
    };
    int n, tot = 0, root = 0;
    int ch[400005][2], siz[400005], pri[400005];
    node val[400005];
    long long sum[200005];
    inline void up(int x){
      siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;
      sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + 1ll * val[x].x * val[x].c;
      return ;
    }
    inline int New(node x){
      val[++tot] = x;
      siz[tot] = 1;
      sum[tot] = 1ll * val[tot].x * val[tot].c;
      pri[tot] = rand() % 114114;
      return tot;
    }
    int merge(int x, int y){
      if(!x || !y) return x | y;
      if(pri[x] < pri[y]){
        ch[x][1] = merge(ch[x][1], y);
        up(x);
        return x;
      }
      else {
        ch[y][0] = merge(x, ch[y][0]);
        up(y);
        return y;
      }
    }
    void split(int now, node v, int &x, int &y){
      if(!now) x = y = 0;
      else {
        if(val[now] <= v){
          x = now;
          split(ch[x][1], v, ch[x][1], y);
          up(x);
        }
        else {
          y = now;
          split(ch[y][0], v, x, ch[y][0]);
          up(y);
        }
      }
      return ;
    }
    inline void insert(node v){
      int x, y;
      split(root, v, x, y);
      int nd = New(v);
      root = merge(merge(x, nd), y);
      return ;
    }
    inline void erase(node v){
      int x, y, z;
      split(root, v, x, y);
      node vv = v; vv.x -= 1;
      split(x, vv, x, z);
      z = merge(ch[z][0], ch[z][1]);
      root = merge(merge(x, z), y);
      return ;
    }
    long long ask(int k){
        long long ans = 0ll;
        int now = root;
        if(root == 0 || siz[root] <= k) return sum[root];
        while(true){
            if(k == 0) return ans;
            if(siz[ch[now][1]] < k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                k -= 1;
                ans += 1ll * val[now].x * val[now].c;
                now = ch[now][0];
            }
            else if(siz[ch[now][1]] == k){
                k -= siz[ch[now][1]];
                ans += sum[ch[now][1]];
                return ans;
            }
            else now = ch[now][1];
        }
        return ans;
    }
    void add(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c += 1;
        insert(pre);
        mp[x] += 1;
        return ;
    }
    void remove(int x){
        node pre; pre.x = x, pre.c = mp[x];
        erase(pre);
        pre.c -= 1;
        insert(pre);
        mp[x] -= 1;
        return ;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        srand((unsigned)time(0));
        n = nums.size();
        mp.clear();
        std::vector <int> ans;
        for(int i = 0; i < k; ++i) add(nums[i]);
        ans.resize(n - k + 1);
        ans[0] = ask(x);
        for(int i = 1; i <= n - k; ++i){
            add(nums[i + k - 1]);
            remove(nums[i - 1]);
            ans[i] = ask(x);
        }
        return ans;
    }
};",1420559673
Agnibha Chakraborty,zanj0,49,3509,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
	vector<int> ret;

	vector<int> Dfs(TreeNode* node) {
		vector<int> left, right;
		if (node->left) left = Dfs(node->left);
		if (node->right) right = Dfs(node->right);
    // cout << node->val << endl;
		if (!node->left && !node->right) {
			// Leaf
            // cout << ""Inser 1"" << endl;
			ret.pb(1);
			return {1, 1, 1}; // {subtree_size, height, good/bad}
		}

		if (left.empty() || right.empty()) {
			return {}; // Bad
		}

		if (left[1] == right[1]) {
			vector<int> now  = {1 + left[0] + right[0], 1 + left[1], 1};
			ret.pb(now[0]);
			return now;
		}
		return {};
	}
	int kthLargestPerfectSubtree(TreeNode* root, int k) {
		ret.clear();
		Dfs(root);
        // for(auto& it : ret){
        //     cout << it << "" "";
        // }
        // cout << endl;
		k--;
		sort(ret.rbegin(), ret.rend());
		return k < ret.size() ? ret[k] : -1;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1420554151
Agnibha Chakraborty,zanj0,49,3588,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

const lli BASE = 1e3 + 5;
const lli MAX_BASE = 3 * BASE + 50;
lli Add(lli a, lli b) {
	return ((a % MOD) + (b % MOD)) % MOD;
}
class Solution {
public:
	map<char, lli> val;
	map<char, char> kills;
	lli Dfs(lli idx, lli last_char, lli balance, string& s, vector<vector<vector<lli>>>& dp) {
		if (idx >= s.size()) {
			return balance > BASE;
		}
		if (dp[idx][last_char][balance] != -1) return dp[idx][last_char][balance];
		lli ret = 0;
		for (auto it : {'F', 'W', 'E'}) {
			lli now = val[it];
			if (now == last_char) continue;
			char kill = kills[s[idx]];
			if (it == kill) {
				ret = Add(ret, Dfs(idx + 1, now, balance - 1, s, dp));
			} else if (it == s[idx]) {
				ret = Add(ret, Dfs(idx + 1, now, balance, s, dp));
			} else {
				ret = Add(ret, Dfs(idx + 1, now, balance + 1, s, dp));
			}
		}
		return dp[idx][last_char][balance] = ret;
	}
	int countWinningSequences(string s) {
		int n = s.size();

		val['F'] = 1;
		val['E'] = 2;
		val['W'] = 3;

		kills['F'] = 'E';
		kills['W'] = 'F';
		kills['E'] = 'W';

		vector<vector<vector<lli>>> dp(s.size(), vector<vector<lli>>(5, vector<lli>(MAX_BASE, -1)));
		return Dfs(0, 0, BASE, s, dp);

	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1420565947
Agnibha Chakraborty,zanj0,49,3592,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;
bool IsFirstBetter(pair<lli, lli>& a, pair<lli, lli> &b) {
	return a.ss == b.ss ? a.ff > b.ff : a.ss > b.ss;
}
struct Comparator {
	bool operator() (pair<lli, lli> a, pair<lli, lli> b) const {
		return IsFirstBetter(a, b);
	}
};
void Out(set<pair<lli, lli>, Comparator>& v) {
	for (auto& it : v) {
		cout << it.ff << "" "" << it.ss << endl;
	}
	cout << endl;
}
class Solution {
public:
	set<pair<lli, lli>, Comparator> good, bad;

	vector<long long> findXSum(vector<int>& nums, int k, int x) {
		vector<lli> ret;
		map<lli, lli> cnt;
		lli sum = 0;
		for (lli i = 0; i < nums.size(); i++) {
			if (i - k >= 0) {
				pair<lli, lli> curr = {nums[i - k], cnt[nums[i - k]]};
				if (good.count(curr)) {
					good.erase(curr);
					sum -= curr.ff * curr.ss;
				}
				if (bad.count(curr)) {bad.erase(curr);}

				cnt[nums[i - k]]--;
				curr = {nums[i - k], cnt[nums[i - k]]};

				good.insert(curr);
				sum += curr.ff * curr.ss;

				while (!bad.empty() && !good.empty()) {
					pair<lli, lli> best_bad = *bad.begin();
					pair<lli, lli> worst_good = *good.rbegin();
					if (IsFirstBetter(best_bad, worst_good)) {
						good.erase(worst_good);
						sum -= worst_good.ff * worst_good.ss;
						good.insert(best_bad);
						sum += best_bad.ff * best_bad.ss;

						bad.erase(best_bad);
						bad.insert(worst_good);
					} else break;
				}


			}
			pair<lli, lli> curr = {nums[i], cnt[nums[i]]};
			if (good.count(curr)) {
				good.erase(curr);
				sum -= curr.ff * curr.ss;
			}
			if (bad.count(curr)) {bad.erase(curr);}

			cnt[nums[i]]++;
			curr = {nums[i], cnt[nums[i]]};

			good.insert(curr);
			sum += curr.ff * curr.ss;

			while ((lli)good.size() > x) {
				curr = *good.rbegin();
				sum -= curr.ff * curr.ss;
				bad.insert(curr);
				good.erase(curr);
			}

			while (!bad.empty() && !good.empty()) {
				pair<lli, lli> best_bad = *bad.begin();
				pair<lli, lli> worst_good = *good.rbegin();
				if (IsFirstBetter(best_bad, worst_good)) {
					good.erase(worst_good);
					sum -= worst_good.ff * worst_good.ss;
					good.insert(best_bad);
					sum += best_bad.ff * best_bad.ss;

					bad.erase(best_bad);
					bad.insert(worst_good);
				} else break;
			}


			while (!bad.empty() && good.size() < x) {
				pair<lli, lli> best_bad = *bad.begin();

				good.insert(best_bad);
				sum += best_bad.ff * best_bad.ss;

				bad.erase(best_bad);
			}
			// cout << i  << "" : "" << endl;
			// cout << ""Good"" << endl;
			// Out(good);
			// cout << ""Bad"" << endl;
			// Out(bad);

			if (i - k + 1 >= 0) {
				ret.pb(sum);
			}
		}
		return ret;
	}
};

/*
[1,1,2,2,3,4,2,3], k = 6, x = 2
*/
#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	Solution s;
	// vector<int> x = {1, 1, 2, 2, 3, 4, 2, 3};
	// vector<int> ret = s.findXSum(x, 6, 2);
	// for (auto& it  : ret) {
	// 	cout << it << "" "";
	// }
	// cout << endl;
	cout << ""Compiled!"" << endl;
}
#endif",1420541498
Agnibha Chakraborty,zanj0,49,3610,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;
bool IsFirstBetter(pair<int, int>& a, pair<int, int> &b) {
	return a.ss == b.ss ? a.ff > b.ff : a.ss > b.ss;
}
struct Comparator {
	bool operator() (pair<int, int> a, pair<int, int> b) const {
		return IsFirstBetter(a, b);
	}
};
void Out(set<pair<int, int>, Comparator>& v) {
	for (auto& it : v) {
		cout << it.ff << "" "" << it.ss << endl;
	}
	cout << endl;
}
class Solution {
public:
	set<pair<int, int>, Comparator> good, bad;

	vector<int> findXSum(vector<int>& nums, int k, int x) {
		vector<int> ret;
		map<int, int> cnt;
		int sum = 0;
		for (int i = 0; i < nums.size(); i++) {
			if (i - k >= 0) {
				pair<int, int> curr = {nums[i - k], cnt[nums[i - k]]};
				if (good.count(curr)) {
					good.erase(curr);
					sum -= curr.ff * curr.ss;
				}
				if (bad.count(curr)) {bad.erase(curr);}

				cnt[nums[i - k]]--;
				curr = {nums[i - k], cnt[nums[i - k]]};

				good.insert(curr);
				sum += curr.ff * curr.ss;

				while (!bad.empty() && !good.empty()) {
					pair<int, int> best_bad = *bad.begin();
					pair<int, int> worst_good = *good.rbegin();
					if (IsFirstBetter(best_bad, worst_good)) {
						good.erase(worst_good);
						sum -= worst_good.ff * worst_good.ss;
						good.insert(best_bad);
						sum += best_bad.ff * best_bad.ss;

						bad.erase(best_bad);
						bad.insert(worst_good);
					} else break;
				}


			}
			pair<int, int> curr = {nums[i], cnt[nums[i]]};
			if (good.count(curr)) {
				good.erase(curr);
				sum -= curr.ff * curr.ss;
			}
			if (bad.count(curr)) {bad.erase(curr);}

			cnt[nums[i]]++;
			curr = {nums[i], cnt[nums[i]]};

			good.insert(curr);
			sum += curr.ff * curr.ss;

			while ((int)good.size() > x) {
				curr = *good.rbegin();
				sum -= curr.ff * curr.ss;
				bad.insert(curr);
				good.erase(curr);
			}

			while (!bad.empty() && !good.empty()) {
				pair<int, int> best_bad = *bad.begin();
				pair<int, int> worst_good = *good.rbegin();
				if (IsFirstBetter(best_bad, worst_good)) {
					good.erase(worst_good);
					sum -= worst_good.ff * worst_good.ss;
					good.insert(best_bad);
					sum += best_bad.ff * best_bad.ss;

					bad.erase(best_bad);
					bad.insert(worst_good);
				} else break;
			}


			while (!bad.empty() && good.size() < x) {
				pair<int, int> best_bad = *bad.begin();

				good.insert(best_bad);
				sum += best_bad.ff * best_bad.ss;

				bad.erase(best_bad);
			}
			// cout << i  << "" : "" << endl;
			// cout << ""Good"" << endl;
			// Out(good);
			// cout << ""Bad"" << endl;
			// Out(bad);

			if (i - k + 1 >= 0) {
				ret.pb(sum);
			}
		}
		return ret;
	}
};

/*
[1,1,2,2,3,4,2,3], k = 6, x = 2
*/
#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	Solution s;
	vector<int> x = {1, 1, 2, 2, 3, 4, 2, 3};
	vector<int> ret = s.findXSum(x, 6, 2);
	for (auto& it  : ret) {
		cout << it << "" "";
	}
	cout << endl;
	cout << ""Compiled!"" << endl;
}
#endif",1420540466
lozy219,lozy219,50,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> cnt;
    int dfs(TreeNode* root) {
        if (root==nullptr) {
            return 0;
        }
        int l=dfs(root->left);
        int r=dfs(root->right);
        int res=-1;
        if (l==r) {
            res=l+r+1;
            cnt.push_back(res);
        }
        return res;
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(cnt.begin(), cnt.end());
        if (k>cnt.size()) return -1;
        return cnt[cnt.size()-k];
    }
};",1420525048
lozy219,lozy219,50,3588,cpp,"class Solution {
public:
    // W>F>E>W
    // 0>1>2>0
    const int MOD=1000000007;
    int countWinningSequences(string s) {
        vector<int> x;
        for (char c: s) {
            if (c=='W') {
                x.push_back(0);
            } else if (c=='F') {
                x.push_back(1);
            } else {
                x.push_back(2);
            }
        }
        // dp[1500]=0
        // dp[>1501]: ok
        int start=s.size();
        vector<int> dp0(2*start+5, 0);
        vector<int> dp1(2*start+5, 0);
        vector<int> dp2(2*start+5, 0);
        for (int i=0; i<x.size(); ++i) {
            vector<int> xdp0(2*start+5, 0);
            vector<int> xdp1(2*start+5, 0);
            vector<int> xdp2(2*start+5, 0);
            if (i==0) {
                if (x[i]==0) {
                    xdp2[start+1]=1;
                    xdp0[start]=1;
                    xdp1[start-1]=1;
                } else if (x[i]==1) {
                    xdp0[start+1]=1;
                    xdp1[start]=1;
                    xdp2[start-1]=1;
                } else {
                    xdp1[start+1]=1;
                    xdp2[start]=1;
                    xdp0[start-1]=1;
                }
            } else {
                if (x[i]==0) {
                    for (int j=0; j<=2*start; ++j) {
                        xdp0[j]=(dp1[j]+dp2[j])%MOD;
                        xdp2[j+1]=(dp1[j]+dp0[j])%MOD;
                        if (j-1>=0) {
                            xdp1[j-1]=(dp0[j]+dp2[j])%MOD;
                        }
                    }
                } else if (x[i]==1) {
                    for (int j=0; j<=2*start; ++j) {
                        xdp1[j]=(dp0[j]+dp2[j])%MOD;
                        xdp0[j+1]=(dp1[j]+dp2[j])%MOD;
                        if (j-1>=0) {
                            xdp2[j-1]=(dp0[j]+dp1[j])%MOD;
                        }
                    }
                } else {
                    for (int j=0; j<=2*start; ++j) {
                        xdp2[j]=(dp0[j]+dp1[j])%MOD;
                        xdp1[j+1]=(dp0[j]+dp2[j])%MOD;
                        if (j-1>=0) {
                            xdp0[j-1]=(dp1[j]+dp2[j])%MOD;
                        }
                    }
                }
            }
            dp0=xdp0;
            dp1=xdp1;
            dp2=xdp2;
        }
        int res=0;
        for (int i=start+1; i<dp0.size(); ++i) {
            res=(res+dp0[i])%MOD;
            res=(res+dp1[i])%MOD;
            res=(res+dp2[i])%MOD;
        }
        return res;
    }
};",1420544666
lozy219,lozy219,50,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> res;
        set<pair<long long, long long>> pqin;
        set<pair<long long, long long>> pqout;
        map<long long, long long> f;
        long long sum=0;
        for (int i=0; i<k-1; ++i) {
            f[nums[i]]++;
        }
        for (auto x: f) {
            pqout.insert({x.second, x.first});
        }
        for (int i=k-1; i<nums.size(); ++i) {
            if (i>=k) {
                long long z=nums[i-k];
                if (pqin.find({f[z], z})!=pqin.end()) {
                    pqin.erase({f[z], z});
                    sum-=f[z]*z;
                } else {
                    pqout.erase({f[z], z});
                }
                f[z]--;
                if (f[z]>0) {
                    pqout.insert({f[z], z});
                }
                while (pqin.size()<x&&!pqout.empty()) {
                    auto v=*prev(pqout.end());
                    pqin.insert({v.first, v.second});
                    sum+=v.first*v.second;
                    pqout.erase({v.first, v.second});
                }
            }

            long long z=nums[i];
            if (f[z]!=0) {
                if (pqin.find({f[z], z})!=pqin.end()) {
                    pqin.erase({f[z], z});
                    sum-=f[z]*z;
                } else {
                    pqout.erase({f[z], z});
                }
            }
            f[z]++;
            pqout.insert({f[z], z});
            if (!pqin.empty()) {
                auto v=*pqin.begin();
                sum-=v.first*v.second;
                pqout.insert({v.first, v.second});
                pqin.erase({v.first, v.second});
            }
            while (pqin.size()<x&&!pqout.empty()) {
                auto v=*prev(pqout.end());
                pqin.insert({v.first, v.second});
                sum+=v.first*v.second;
                pqout.erase({v.first, v.second});
            }
            res.push_back(sum);
        }
        return res;
    }
};",1420575581
lozy219,lozy219,50,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        int n=nums.size();
        for (int i=0; i+k<=n; ++i) {
            map<int, int> cnt;
            for (int j=0; j<k; ++j) {
                cnt[nums[i+j]]++;
            }
            vector<pair<int, int>> v;
            for (auto x: cnt) {
                v.push_back({x.second, x.first});
            }
            sort(v.begin(), v.end());
            for (int i=0; i<v.size(); ++i) {
            }
            int cur=0;
            for (int z=0; z<x; ++z) {
                int idx=v.size()-1-z;
                if (idx<0) break;
                cur+=v[idx].first*v[idx].second;
            }
            res.push_back(cur);
        }
        return res;
    }
};",1420521589
Ian Wong,ianwong1999,51,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map<TreeNode*, int> perf;
    
    void dfs(TreeNode* v) {
        if (!v) return;
        
        if (!v->left && !v->right) {
            perf[v] = 1;
            return;
        }
        
        dfs(v->left);
        dfs(v->right);
        
        if (perf.count(v->left) && perf.count(v->right) && perf[v->left] == perf[v->right]) {
            perf[v] = perf[v->left] * 2 + 1;
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        perf.clear();
        
        dfs(root);
        
        vector<int> v;
        
        for (auto [k, c] : perf) v.push_back(c);
        
        sort(v.rbegin(), v.rend());
        
        if (v.size() < k) return -1;
        return v[k - 1];
    }
};",1420523357
Ian Wong,ianwong1999,51,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int dp[1001][2010][3];
    
    int to_id(char ch) {
        if (ch == 'F') return 0;
        if (ch == 'E') return 1;
        return 2;
    }
    int countWinningSequences(string s) {
        int n = s.size();
        int offset = n;
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= offset * 2 + 5; j++) {
                memset(dp[i][j], 0, sizeof(dp[i][j]));
            }
        }
        
        dp[0][offset][to_id(s[0])] = 1;
        dp[0][offset - 1][(to_id(s[0]) + 1) % 3] = 1;
        dp[0][offset + 1][(to_id(s[0]) + 2) % 3] = 1;
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= offset * 2; j++) {
                for (int k = 0; k < 3; k++) {
                    int win = 0;
                    
                    if (k == (to_id(s[i]) + 1) % 3) win = -1;
                    else if (k == (to_id(s[i]) + 2) % 3) win = 1;
                    
                    for (int prev = 0; prev < 3; prev++) {
                        if (prev == k) continue;
                        
                        if (dp[i - 1][j][prev] == 0) continue;
                        
                        assert(j + win >= 0 && j + win <= offset * 2);
                        
                        dp[i][j + win][k] = (dp[i][j + win][k] + dp[i - 1][j][prev]) % MOD;
                    }
                }
            }
        }
        
        int res = 0;
        
        for (int i = 1; i <= n; i++) for (int j = 0; j < 3; j++) {
            res = (res + dp[n - 1][i + offset][j]) % MOD;
        }
        
        return res;
    }
};",1420539911
Ian Wong,ianwong1999,51,3592,cpp,"class Solution {
public:
    // https://cp-algorithms.com/data_structures/treap.html
    struct item {
        pair<int, int> key;
        int prior;
        long long sum;
        int cnt;
        item *l, *r;
        item () { }
        item (pair<int, int> key) : key(key), prior(rand()), sum(0ll), cnt(1), l(NULL), r(NULL) { }
    };
    
    typedef item* pitem;
    
    long long sum (pitem it) {
        return it ? it->sum : 0ll;
    }
    
    int cnt (pitem it) {
        return it ? it->cnt : 0;
    }
    
    void upd_sum (pitem it) {
        if (it) {
            it->sum = sum(it->l) + sum(it->r) + 1ll * it->key.first * it->key.second;
            it->cnt = cnt(it->l) + cnt(it->r) + 1;
        }
    }
    
    void split (pitem t, pair<int, int> key, pitem & l, pitem & r) {
        if (!t)
            l = r = NULL;
        else if (t->key <= key)
            split (t->r, key, t->r, r),  l = t;
        else
            split (t->l, key, l, t->l),  r = t;
        
        upd_sum(t);
    }
    
    void merge (pitem & t, pitem l, pitem r) {
        if (!l || !r)
            t = l ? l : r;
        else if (l->prior > r->prior)
            merge (l->r, l->r, r),  t = l;
        else
            merge (r->l, l, r->l),  t = r;
        
        upd_sum(t);
    }

    
    void insert (pitem & t, pitem it) {
        if (!t)
            t = it;
        else if (it->prior > t->prior)
            split (t, it->key, it->l, it->r),  t = it;
        else
            insert (t->key <= it->key ? t->r : t->l, it);
        
        upd_sum(t);
    }

    void erase (pitem & t, pair<int, int> key) {
        if (t->key == key) {
            pitem th = t;
            merge (t, t->l, t->r);
            delete th;
        }
        else
            erase (key < t->key ? t->l : t->r, key);
        
        upd_sum(t);
    }
    
    long long query(pitem & t, int x) {
        if (cnt(t) <= x) {
            return sum(t);
        }
        
        if (cnt(t->r) >= x) {
            return query(t->r, x);
        }
        
        long long res = sum(t->r) + 1ll * t->key.first * t->key.second;
        
        if (x - cnt(t->r) - 1 > 0)
            res += query(t->l, x - cnt(t->r) - 1);
        return res;
    }
    
    void output (pitem t) {
        if (!t)  return;
        output (t->l);
        printf (""(%d, %d) "", t->key.first, t->key.second);
        output (t->r);
    }
    
    void clear (pitem t) {
        if (!t)  return;
        clear (t->l);
        clear (t->r);
        
        delete t;
    }
    
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        map<int, int> cnt;
        vector<long long> res;

        for (int i = 0; i < n; i++) cnt[nums[i]] = 0;
        for (int i = 0; i + 1 < k; i++) {
            cnt[nums[i]]++;
        }
        
        pitem root = nullptr;
        
        for (auto p : cnt) {
            insert(root, new item(make_pair(p.second, p.first)));
        }
        
        auto update_cnt = [&](int id, int val) {
            auto p = make_pair(cnt[nums[id]], nums[id]);
           
            erase(root, p);

            cnt[nums[id]] += val;
            
            insert(root, new item(make_pair(cnt[nums[id]], nums[id])));
        };
        
        for (int i = k - 1; i < n; i++) {
            if (i >= k) {
                int id = i - k;
                update_cnt(id, -1);
            }
            
            update_cnt(i, 1);
            res.push_back(query(root, x));
        }
        
        clear(root);
        return res;
    }
};",1420575617
Ian Wong,ianwong1999,51,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        map<int, int> cnt;
        vector<pair<int, int>> vs;
        vector<int> res;
        
        for (int i = 0; i + k - 1 < n; i++) {
            cnt.clear();
            vs.clear();
            for (int j = 0; j < k; j++) {
                cnt[nums[i + j]]++;
            }
            
            for (auto [k, v] : cnt) vs.emplace_back(v, k);
            
            sort(vs.begin(), vs.end());
            
            int sum = 0;
            
            for (int j = 0; j < min(x, (int)vs.size()); j++) {
                auto p = vs[(int)vs.size() - 1 - j];
                
                sum += p.first * p.second;
                
            }
            
            res.push_back(sum);
        }
        
        return res;
    }
};",1420520289
Maruzensky,Maruzensky,52,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from functools import lru_cache

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        answer = []
        
        @lru_cache(None)
        def is_perfect(node):
            if node.left is None and node.right is None:
                answer.append(1)
                return 1
            if node.left is None and not node.right is None:
                is_perfect(node.right)
                return -1
            if not node.left is None and node.right is None:
                is_perfect(node.left)
                return -1
        
            left = is_perfect(node.left)
            right = is_perfect(node.right)
            print(left, right)
        
            if left > 0 and right > 0 and left == right:
                answer.append(2 * left + 1)
                return 2 * left + 1
            else:
                return -1
            
        is_perfect(root)
        answer.sort(reverse=True)
        
        if len(answer) < k:
            return -1
        
        return answer[k - 1]",1420526110
Maruzensky,Maruzensky,52,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        # FEW
        to_int = {'F': 0, 'E': 1, 'W': 2}
        
        s = [to_int[c] for c in s]
        
        mod = 10**9 + 7
        
        dp = {0: [1, 1, 1]}
        
        for x in s:
            temp = {}
            for d, freq in dp.items():
                if x == 0:
                    # y plays 0
                    if d not in temp:
                        temp[d] = [freq[1] + freq[2], 0, 0]
                    else:
                        temp[d][0] += freq[1] + freq[2]
                    # y plays 1
                    if d - 1 not in temp:
                        temp[d - 1] = [0, freq[0] + freq[2], 0]
                    else:
                        temp[d - 1][1] += freq[0] + freq[2]
                    # y plays 2
                    if d + 1 not in temp:
                        temp[d + 1] = [0, 0, freq[0] + freq[1]]
                    else:
                        temp[d + 1][2] += freq[0] + freq[1]
                                
                elif x == 1:
                    # y plays 0
                    if d + 1 not in temp:
                        temp[d + 1] = [freq[1] + freq[2], 0, 0]
                    else:
                        temp[d + 1][0] += freq[1] + freq[2]
                    # y plays 1
                    if d not in temp:
                        temp[d] = [0, freq[0] + freq[2], 0]
                    else:
                        temp[d][1] += freq[0] + freq[2]
                    # y plays 2
                    if d - 1 not in temp:
                        temp[d - 1] = [0, 0, freq[0] + freq[1]]
                    else:
                        temp[d - 1][2] += freq[0] + freq[1]
                
                else:
                    # y plays 0
                    if d - 1 not in temp:
                        temp[d - 1] = [freq[1] + freq[2], 0, 0]
                    else:
                        temp[d - 1][0] += freq[1] + freq[2]
                    # y plays 1
                    if d + 1 not in temp:
                        temp[d + 1] = [0, freq[0] + freq[2], 0]
                    else:
                        temp[d + 1][1] += freq[0] + freq[2]
                    # y plays 2
                    if d not in temp:
                        temp[d] = [0, 0, freq[0] + freq[1]]
                    else:
                        temp[d][2] += freq[0] + freq[1]
                        
            dp = {}
            for key, val in temp.items():
                dp[key] = [v % mod for v in val]
                        
        answer = sum(sum(val) for score, val in dp.items() if score > 0) % mod
        if answer % 2 == 0:
            return answer // 2
        else:
            return (answer + mod) // 2
                ",1420545193
Maruzensky,Maruzensky,52,3592,python3,"from sortedcontainers import SortedList
from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ctr = Counter(nums[:k])
        
        sl = SortedList([(v, y) for y, v in ctr.items()])
        
        psum = 0
        for v, y in sl[-x:]:
            psum += v * y
            
        answer = [psum]
            
        for a, b in zip(nums, nums[k:]):
            # print(a, b, sl)
            f_a = ctr[a]
            ctr[a] -= 1
            idx_a = sl.index((f_a, a))
            
            if idx_a >= len(sl) - x:
                psum -= f_a * a
                sl.remove((f_a, a))
                if len(sl) >= x:
                    f_y, y = sl[-x]
                    psum += f_y * y
                    
            else:
                sl.remove((f_a, a))
                
            if f_a > 1:
                sl.add((f_a - 1, a))
                idx_a = sl.index((f_a - 1, a))

                if idx_a >= len(sl) - x:
                    psum += (f_a - 1) * a
                    if len(sl) > x:
                        f_y, y = sl[-x - 1]
                        psum -= f_y * y
                    
            f_b = ctr[b]
            ctr[b] += 1
            
            if f_b > 0:
                idx_b = sl.index((f_b, b))

                if idx_b >= len(sl) - x:
                    psum -= f_b * b
                    sl.remove((f_b, b))
                    if len(sl) >= x:
                        f_y, y = sl[-x]
                        psum += f_y * y

                else:
                    sl.remove((f_b, b))
                
            sl.add((f_b + 1, b))
            idx_b = sl.index((f_b + 1, b))
            
            if idx_b >= len(sl) - x:
                psum += (f_b + 1) * b
                if len(sl) > x:
                    f_y, y = sl[-x - 1]
                    psum -= f_y * y
                    
            answer.append(psum)
        
        return answer",1420569402
Maruzensky,Maruzensky,52,3610,python3,"from sortedcontainers import SortedList
from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ctr = Counter(nums[:k])
        
        sl = SortedList([(v, y) for y, v in ctr.items()])
        
        psum = 0
        for v, y in sl[-x:]:
            psum += v * y
            
        answer = [psum]
            
        for a, b in zip(nums, nums[k:]):
            # print(a, b, sl)
            f_a = ctr[a]
            ctr[a] -= 1
            idx_a = sl.index((f_a, a))
            
            if idx_a >= len(sl) - x:
                psum -= f_a * a
                sl.remove((f_a, a))
                if len(sl) >= x:
                    f_y, y = sl[-x]
                    psum += f_y * y
                    
            else:
                sl.remove((f_a, a))
                
            if f_a > 1:
                sl.add((f_a - 1, a))
                idx_a = sl.index((f_a - 1, a))

                if idx_a >= len(sl) - x:
                    psum += (f_a - 1) * a
                    if len(sl) > x:
                        f_y, y = sl[-x - 1]
                        psum -= f_y * y
                    
            f_b = ctr[b]
            ctr[b] += 1
            
            if f_b > 0:
                idx_b = sl.index((f_b, b))

                if idx_b >= len(sl) - x:
                    psum -= f_b * b
                    sl.remove((f_b, b))
                    if len(sl) >= x:
                        f_y, y = sl[-x]
                        psum += f_y * y

                else:
                    sl.remove((f_b, b))
                
            sl.add((f_b + 1, b))
            idx_b = sl.index((f_b + 1, b))
            
            if idx_b >= len(sl) - x:
                psum += (f_b + 1) * b
                if len(sl) > x:
                    f_y, y = sl[-x - 1]
                    psum -= f_y * y
                    
            answer.append(psum)
        
        return answer",1420569741
Wei Liu,nevergiveup,53,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    private List<Integer> sizeList = new ArrayList<>();

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        dfs(root);
        Collections.sort(sizeList, Collections.reverseOrder());
        if (k <= sizeList.size()) {
            return sizeList.get(k - 1);
        } else {
            return - 1;
        }
    }

    private int dfs(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            int leftSize = dfs(root.left) , rightSize = dfs(root.right);
            if (leftSize == rightSize) {
                sizeList.add(leftSize * 2 + 1);
                return leftSize * 2 + 1;
            } else {
                return - 1;
            }
        }
    }

}",1420525159
Wei Liu,nevergiveup,53,3588,java,"class Solution {

    
    private static long[][][] dp = new long[1010][2010][3];
    private static final int OFFSET = 1000;
    private static final long MOD = 1000_000_007L;

    public int countWinningSequences(String s) {
        int len = s.length();
        for (int i = 0;i < len;i ++) {
            for (int j = 0;j <= len + OFFSET;j ++) {
                for (int k = 0;k < 3;k ++) {
                    dp[i][j][k] = - 1;
                }
            }
        }
        return (int) dfs(s, 0, -1, 0);
    }

    // FWE
    private int getPoint(char ch, int bobChoose) {
        if (ch == 'F') {
            if (bobChoose == 1) {
                return 1;
            } else if (bobChoose == 0) {
                return 0;
            } else {
                return - 1;
            }
        }
        if (ch == 'W') {
            if (bobChoose == 2) {
                return 1;
            } else if (bobChoose == 1) {
                return 0;
            } else {
                return - 1;
            }
        }
        if (ch == 'E') {
            if (bobChoose == 0) {
                return 1;
            } else if (bobChoose == 2) {
                return 0;
            } else {
                return - 1;
            }
        }
        return - 1;
    }

    // diff is bob - alice
    private long dfs(String s, int cur, int last, int diff) {
        if (cur == s.length()) {
            if (diff > 0) {
                return 1;
            } else {
                return 0;
            }
        }
        if (last >= 0 && dp[cur][diff + OFFSET][last] >= 0) {
            return dp[cur][diff + OFFSET][last];
        }
        if (last < 0) {
            long ans = 0;
            for (int i = 0;i < 3;i ++) {
                ans = (ans + dfs(s, cur + 1, i, diff + getPoint(s.charAt(cur), i))) % MOD;
            }
            return ans;
        } else {
            long ans = 0;
            for (int i = 0;i < 3;i ++) {
                if (i != last) {
                    ans = (ans + dfs(s, cur + 1, i, diff + getPoint(s.charAt(cur), i))) % MOD;
                }
            }
            return dp[cur][diff + OFFSET][last] = ans;
        }
    }

}",1420542571
Wei Liu,nevergiveup,53,3592,java,"class Solution {

    private static class Element implements Comparable<Element> {
        public long val;
        public long count;
        public Element(long val, long count) {
            this.val = val;
            this.count = count;
        }
        @Override
        public int compareTo(Element e) {
            if (this.count != e.count) {
                if (this.count > e.count) {
                    return - 1;
                } else if (this.count < e.count) {
                    return 1;
                } else {
                    return 0;
                }
            } else {
                if (this.val > e.val) {
                    return - 1;
                } else if (this.val < e.val) {
                    return 1;
                } else {
                    return 0;
                }
            }
        }
        public long getSum() {
            return this.count * this.val;
        }
    }

    // top x
    private TreeSet<Element> leftSet = new TreeSet<>(), rightSet = new TreeSet<>();
    private long leftSum = 0;
    private Map<Integer , Integer> freqMap = new HashMap<>();

    private void add(int val, int x) {
        // remove first
        int prevFreq = freqMap.getOrDefault(val , 0);
        Element prevE = new Element(val, prevFreq);
        if (leftSet.remove(prevE)) {
            leftSum -= prevE.getSum();
        }
        rightSet.remove(prevE);
        // add new
        Element newE = new Element(val, prevFreq + 1);
        leftSet.add(newE);
        leftSum += newE.getSum();
        freqMap.put(val, prevFreq + 1);
        // balance
        balance(x);
    }

    private void remove(int val, int x) {
        // remove first
        int prevFreq = freqMap.getOrDefault(val , 0);
        Element prevE = new Element(val, prevFreq);
        if (leftSet.remove(prevE)) {
            leftSum -= prevE.getSum();
        }
        rightSet.remove(prevE);
        if (prevFreq - 1 > 0) {
            // add new
            Element newE = new Element(val, prevFreq - 1);
            leftSet.add(newE);
            leftSum += newE.getSum();
            freqMap.put(val, prevFreq - 1);
        } else {
            freqMap.remove(val);
        }
        // balance
        balance(x);
    }

    private void balance(int x) {
        // maintain set prop first
        if (!rightSet.isEmpty() && !leftSet.isEmpty()) {
            while (true) {
                Element last = leftSet.last(), first = rightSet.first();
                if (last.compareTo(first) > 0) {
                    leftSet.remove(last);
                    leftSum -= last.getSum();
                    rightSet.remove(first);
                    leftSet.add(first);
                    leftSum += first.getSum();
                    rightSet.add(last);
                } else {
                    break;
                }
            }
        }
        while (!rightSet.isEmpty() && leftSet.size() < x) {
            Element e = rightSet.first();
            rightSet.remove(e);
            leftSet.add(e);
            leftSum += e.getSum();
        }
        while (leftSet.size() > x) {
            Element e = leftSet.last();
            leftSet.remove(e);
            rightSet.add(e);
            leftSum -= e.getSum();
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] ans = new long[n - k + 1];
        for (int i = 0;i < n;i ++) {
            add(nums[i], x);
            if (i >= k - 1) {
                ans[i - (k - 1)] = leftSum;
                remove(nums[i - (k - 1)], x);
            }
        }
        return ans;
    }

}",1420570016
Wei Liu,nevergiveup,53,3610,java,"class Solution {


    private static class Element implements Comparable<Element> {
        public int val;
        public int freq;
        public Element(int val , int freq) {
            this.val = val;
            this.freq = freq;
        }
        @Override
        public int compareTo(Element e) {
            if (this.freq != e.freq) {
                return - (this.freq - e.freq);
            }
            return - (this.val - e.val);
        }
    }

    private int get(int[] nums , int l , int r , int x) {
        Map<Integer , Integer> freqMap = new HashMap<>();
        for (int i = l;i <= r;i ++) {
            int val = nums[i];
            freqMap.put(val , freqMap.getOrDefault(val , 0) + 1);
        }
        List<Element> list = new ArrayList<>();
        for (Map.Entry<Integer , Integer> entry : freqMap.entrySet()) {
            list.add(new Element(entry.getKey(), entry.getValue()));
        }
        Collections.sort(list);
        int ans = 0;
        for (int i = 0;i < list.size() && i < x;i ++) {
            ans += list.get(i).val * list.get(i).freq;
        }
        return ans;
    }

    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        for (int i = 0;i < ans.length;i ++) {
            ans[i] = get(nums, i, i + k - 1, x);
        }
        return ans;
    }

}",1420521472
Lucky Orb,megurine,56,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        def dfs(rt, d):
            a, b, c = inf, -inf, 1
            if rt.left is None and rt.right is None:
                a = b = d
                ans.append(1)
                return a, b, c
            if rt.left:
                x, y, z = dfs(rt.left, d + 1)
                a = min(a, x)
                b = max(b, y)
                c += z
            if rt.right:
                x, y, z = dfs(rt.right, d + 1)
                a = min(a, x)
                b = max(b, y)
                c += z
            if a == b and c == (1 << (a - d + 1)) - 1:
                ans.append(c)
            return a, b, c
        dfs(root, 0)
        ans.sort()
        ans.reverse()
        return -1 if len(ans) < k else ans[k - 1]
            ",1420529367
Lucky Orb,megurine,56,3588,python3,"p = int(1e9 + 7)
class Solution:
    def countWinningSequences(self, s: str) -> int:
        a = ['FWE'.find(x) for x in s]
        n = len(a)
        f = [[0] * 3 for _ in range(3)]
        for y in range(3):
            if y == a[0]:
                f[y][1] = 1
            elif (y - a[0]) % 3 == 1:
                f[y][2] = 1
            else:
                f[y][0] = 1
        for i, v in enumerate(a[1:], 1):
            h = [[0] * (i * 2 + 3) for _ in range(3)]
            for x in range(3):
                for y in range(3):
                    if x == y:
                        continue
                    if y == v:
                        d = 1
                    elif (y - v) % 3 == 1:
                        d = 2
                    else:
                        d = 0
                    for j in range(i * 2 + 1):
                        h[y][j + d] += f[x][j]
            for it in h:
                for i in range(len(it)):
                    it[i] %= p
            f = h
        return sum(sum(it[-n:]) for it in f) % p
                        ",1420549495
Lucky Orb,megurine,56,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, t: int) -> List[int]:
        cnt = Counter(nums[:k - 1])
        stl = SortedList([(cnt[x], x) for x in cnt] + [(-1, 0)] * k)
        cur = 0
        for c, x in stl[-t:]:
            cur += c * x
        
        def Del(c, x):
            if (c, x) not in stl:
                return
            nonlocal cur
            if (c, x) >= stl[-t]:
                cur -= c * x
                cc, xx = stl[-t - 1]
                cur += cc * xx
            stl.discard((c, x))
        def Add(c, x):
            if (c, x) <= stl[-t]:
                stl.add((c, x))
                return
            nonlocal cur
            cur += c * x
            cc, xx = stl[-t]
            cur -= cc * xx
            stl.add((c, x))
        
        ans = []
        for x, y in zip(nums[k - 1:], nums):
            Del(cnt[x], x)
            cnt[x] += 1
            Add(cnt[x], x)
            ans.append(cur)
            Del(cnt[y], y)
            cnt[y] -= 1
            Add(cnt[y], y)
        return ans
        ",1420570917
Lucky Orb,megurine,56,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, t: int) -> List[int]:
        ans = []
        for i in range(len(nums) - k + 1):
            a = nums[i:i + k]
            cc = Counter(a)
            b = sorted([(cc[x], x) for x in cc])[-t:]
            # print(a, b, b[-t:], b[-1:])
            val = 0
            for c, x in b:
                val += c * x
            ans.append(val)
        return ans",1420523288
chh9976,chh9976,57,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def check(node):
            if not node:
                return 0
            l = check(node.left)
            r = check(node.right)
            if l >= 0 and r >= 0 and l == r:
                res.append(l + r + 1)
                return l + r + 1
            else:
                return -1
        check(root)
        res.sort(reverse=True)
        if k > len(res):
            return -1
        return res[k-1]
                ",1420525294
chh9976,chh9976,57,3588,cpp,"
using namespace std;
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define ee9 1000000000

template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
int rewa(int a, int b){int temp = ((a - b) % 3 + 3) % 3; if(temp == 2) return -1; else return temp;}
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        vc dp(s.size() + 1, vc(s.size() * 2 + 1, vc<mint17>(3)));
        map<int, int> cc; cc['F'] = 0, cc['W'] = 1, cc['E'] = 2;
        rep(i, 0, 3) dp[1][n + rewa(i, cc[s[0]])][i] = 1;
        rep(k, 1, n){
            auto c = s[k];
            rep(l, 0, 3){
                rep(i, 0, 3) if(l != i){
                    int rew = rewa(i, cc[c]);
                    rep(j, 1, 2 * n) {
                        dp[k+1][j+rew][i] += dp[k][j][l];
                    }
                }
            }
        }
        mint17 ans = 0;
        rep(i, n+1, 2*n+1) rep(j, 0, 3){
            ans += dp[n][i][j];
        }
        return ans.get();
    }
};",1420546213
chh9976,chh9976,57,3592,cpp,"
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> cnter;
        set<ints2> inres;
        set<ints2> outres;
        long long res = 0;
        int n = nums.size();
        auto er = [&](ints2 a){
            if(inres.count(a)) {
                inres.erase(a);
                res -= 1ll * a[0] * a[1];
            }
            else outres.erase(a);
            while(outres.size() && inres.size() != x){
                auto [b, c] = *outres.rbegin();
                inres.insert({b, c});
                res += 1ll * b * c;
                outres.erase(prev(outres.end()));
            }
        };
        auto ins = [&](ints2 a){
            inres.insert(a);
            res += 1ll * a[0] * a[1];
            while(inres.size() > x){
                auto [b, c] = *inres.begin();
                inres.erase(inres.begin());
                res -= 1ll * b * c;
                outres.insert({b, c});
            }
        };
        vc<ll> ans;
        rep(i, 0, k-1) {
            er({cnter[nums[i]], nums[i]});
            cnter[nums[i]]++;
            ins({cnter[nums[i]], nums[i]});
        }
        rep(i, k-1, n){
            er({cnter[nums[i]], nums[i]});
            cnter[nums[i]]++;
            ins({cnter[nums[i]], nums[i]});
            ans.pb(res);
            er({cnter[nums[i-k+1]], nums[i-k+1]});
            cnter[nums[i-k+1]]--;
            ins({cnter[nums[i-k+1]], nums[i-k+1]});
        }
        return ans;
    }
};",1420571978
chh9976,chh9976,57,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        for i in range(n-k+1):
            c = Counter(nums[i:i+k])
            vs = sorted([(b, a) for a, b in c.items()], reverse=True)
            res = 0
            for j in range(min(x, len(vs))):
                res += vs[j][1] * vs[j][0]
            ans.append(res)
        return ans
            ",1420555670
IvanHugh,ivanc-e,58,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        def dfs(root: TreeNode) -> (bool, int):
            if root is None:
                return True, 0
            left_f, left_s = dfs(root.left)
            right_f, right_s = dfs(root.right)
            if left_f and right_f and left_s == right_s:
                ans.append(left_s + right_s + 1)
                return True, left_s + right_s + 1
            return False, left_s + right_s + 1
        dfs(root)
        ans.sort(reverse=True)
        print(ans)
        return -1 if k > len(ans) else ans[k-1]
        ",1420529680
IvanHugh,ivanc-e,58,3588,python3,"class Solution:  
    def countWinningSequences(self, s: str) -> int:  
        MOD = 10 ** 9 + 7  
        n = len(s)  
        moves = ['F', 'W', 'E']  
        winning_pairs = {('F', 'E'), ('W', 'F'), ('E', 'W')}  

        move_indices = {'Start': 0, 'F': 1, 'W': 2, 'E': 3}  

        dp = [[[0] * (2 * n + 1) for _ in range(4)] for _ in range(n + 1)]  
        
        dp[0][move_indices['Start']][n] = 1  

        for i in range(n):  
            alice_move = s[i]  
            for prev_move_idx in range(4):  
                for score_diff_index in range(2 * n + 1):  
                    count = dp[i][prev_move_idx][score_diff_index]  
                    if count > 0:  
                        prev_move = moves[prev_move_idx - 1] if prev_move_idx > 0 else 'Start'  
                        for bob_move in moves:  
                            if bob_move != prev_move:  
                                if alice_move == bob_move:  
                                    delta = 0  
                                elif (alice_move, bob_move) in winning_pairs:  
                                    delta = -1
                                elif (bob_move, alice_move) in winning_pairs:  
                                    delta = 1 
                                else:  
                                    delta = 0  
                                new_score_diff_index = score_diff_index + delta  
                                if 0 <= new_score_diff_index <= 2 * n:  
                                    new_prev_move_idx = move_indices[bob_move]  
                                    dp[i + 1][new_prev_move_idx][new_score_diff_index] = (  
                                        dp[i + 1][new_prev_move_idx][new_score_diff_index] + count  
                                    ) % MOD  

        total = 0  
        for prev_move_idx in range(1, 4):
            for score_diff_index in range(n + 1, 2 * n + 1):
                total = (total + dp[n][prev_move_idx][score_diff_index]) % MOD  

        return total",1420538817
IvanHugh,ivanc-e,58,3592,python3,"from sortedcontainers import SortedList  

class Solution:  
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:  
        n = len(nums)  
        counts = Counter()  
        top_x = SortedList()  
        rest = SortedList()  
        total_sum = 0  

        def get_key(elem, count):  
            return (-count, -elem)  

        for i in range(k):  
            counts[nums[i]] += 1  

        elements = list(counts.keys())  
        elements.sort(key=lambda elem: get_key(elem, counts[elem]))  
        for idx, elem in enumerate(elements):  
            key = get_key(elem, counts[elem])  
            if idx < x:  
                top_x.add((key, elem))  
                total_sum += counts[elem] * elem  
            else:  
                rest.add((key, elem))  

        ans = [total_sum]  

        for i in range(k, n):  
            out_elem = nums[i - k]  
            in_elem = nums[i]  

            old_count_out = counts[out_elem]  
            old_key_out = get_key(out_elem, old_count_out)  
            counts[out_elem] -= 1 
            if (old_key_out, out_elem) in top_x:  
                top_x.remove((old_key_out, out_elem))  
                total_sum -= old_count_out * out_elem  
            else:  
                rest.remove((old_key_out, out_elem))  

            if counts[out_elem] == 0:  
                del counts[out_elem]  
            else:  
                new_key_out = get_key(out_elem, counts[out_elem])  
                if len(top_x) < x or new_key_out < top_x[-1][0]:  
                    top_x.add((new_key_out, out_elem))  
                    total_sum += counts[out_elem] * out_elem  
                else:  
                    rest.add((new_key_out, out_elem))  

            old_count_in = counts.get(in_elem, 0)  
            if old_count_in > 0:  
                old_key_in = get_key(in_elem, old_count_in)  
                if (old_key_in, in_elem) in top_x:  
                    top_x.remove((old_key_in, in_elem))  
                    total_sum -= old_count_in * in_elem  
                else:  
                    rest.remove((old_key_in, in_elem))  
            counts[in_elem] = counts.get(in_elem, 0) + 1 
            new_key_in = get_key(in_elem, counts[in_elem])  

            if len(top_x) < x or new_key_in < top_x[-1][0]:  
                top_x.add((new_key_in, in_elem))  
                total_sum += counts[in_elem] * in_elem  
            else:  
                rest.add((new_key_in, in_elem))  

            while len(top_x) > x:  
                move_elem = top_x.pop()  
                total_sum -= counts[move_elem[1]] * move_elem[1]  
                rest.add(move_elem)  

            while len(top_x) < x and rest:  
                move_elem = rest.pop(0)  
                total_sum += counts[move_elem[1]] * move_elem[1]  
                top_x.add(move_elem)  

            while rest and top_x and rest[0][0] < top_x[-1][0]:  
                rest_elem = rest.pop(0)  
                top_elem = top_x.pop()  
                total_sum -= counts[top_elem[1]] * top_elem[1]  
                total_sum += counts[rest_elem[1]] * rest_elem[1]  
                top_x.add(rest_elem)  
                rest.add(top_elem)  

            ans.append(total_sum)  

        return ans",1420572394
IvanHugh,ivanc-e,58,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnt = Counter()
        n = len(nums)
        if n < k:
            return [sum(nums)]
        for i in range(k):
            cnt[nums[i]] += 1
        ans = []
        lst = [(v, k) for k, v in cnt.items()]
        lst.sort(reverse=True)
        cur = 0
        for j in range(min(x, len(lst))):
            cur += lst[j][0]*lst[j][1]
        ans.append(cur)
        for i in range(k, n):
            cnt[nums[i]] += 1
            cnt[nums[i-k]] -= 1
            lst = [(v, k) for k, v in cnt.items()]
            lst.sort(reverse=True)
            cur = 0
            for j in range(min(x, len(lst))):
                cur += lst[j][0]*lst[j][1]
            ans.append(cur)
            
        return ans",1420522858
Ryan,ryanwong0127,59,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.res = []
        
        def dfs(node):
            if not node:
                return True, 0, 0
            is_left_perfect, left_h, left_s = dfs(node.left)
            is_right_perfect, right_h, right_s = dfs(node.right)
            is_perfect = is_left_perfect and is_right_perfect and left_h == right_h
            h = max(left_h, right_h) + 1
            s = left_s + right_s + 1
            if is_perfect:
                self.res.append(s)
            return is_perfect, h, s
        
        dfs(root)
        self.res.sort(reverse=True)
        if len(self.res) >= k:
            return self.res[k - 1]
        
        return -1",1420526407
Ryan,ryanwong0127,59,3588,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
class Solution {
public:
    int countWinningSequences(string s) {
        const int n = s.length();
        map<char, int> move_to_index = {{'F',1}, {'W',2}, {'E',3}};
        bool BobWins[4][4] = {false};
        BobWins[1][3] = true;
        BobWins[2][1] = true;
        BobWins[3][2] = true; 
        
        vector<vector<vector<ll>>> dp(n+1, vector<vector<ll>>(4, vector<ll>(2*n+1, 0)));
        dp[0][0][n] = 1; 
        
        rep(i, 0, n) {
            int a_index = move_to_index[s[i]];
            rep(last_b, 0, 4) {
                rep(s_diff, 0, 2*n+1) {
                    ll count = dp[i][last_b][s_diff];
                    if(count == 0)
                        continue;
                    rep(b, 1, 4) {
                        if(last_b != 0 && b == last_b){continue; }
                        int delta = 0;
                        if(a_index == b) {
                            delta = 0;
                        } else if(BobWins[b][a_index]) {
                            delta = 1;
                        } else {
                            delta = -1;
                        }
                        int s_new = s_diff + delta;
                        if(s_new >= 0 && s_new <= 2*n) {
                            chsum(dp[i+1][b][s_new], count) ;
                        }
                    }
                }
            }
        }
        ll res = 0;
        rep(last_b, 1, 4) {
            rep(s_diff, n+1, 2*n+1) {
                chsum(res, dp[n][last_b][s_diff]);
            }
        }
        return res;
    }
};",1420542204
Ryan,ryanwong0127,59,3592,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

struct Node {
    pii key; 
    int size;
    ll sum;
    int priority;
    Node *left, *right;
    Node(pii k) : key(k), size(1), sum((ll)k.fi * k.se), priority(rng()), left(nullptr), right(nullptr) {}
};

int getSize(Node *node) {
    return node ? node->size : 0;
}

ll getSum(Node *node) {
    return node ? node->sum : 0;
}

void update(Node *node) {
    if (node) {
        node->size = 1 + getSize(node->left) + getSize(node->right);
        node->sum = (ll)node->key.fi * node->key.se + getSum(node->left) + getSum(node->right);
    }
}

void split(Node *node, pii key, Node *&left, Node *&right) {
    if (!node) {
        left = right = nullptr;
    } else if (node->key > key) { 
        split(node->left, key, left, node->left);
        right = node;
    } else {
        split(node->right, key, node->right, right);
        left = node;
    }
    update(node);
}

void merge(Node *&node, Node *left, Node *right) {
    if (!left || !right) {
        node = left ? left : right;
    } else if (left->priority > right->priority) {
        merge(left->right, left->right, right);
        node = left;
    } else {
        merge(right->left, left, right->left);
        node = right;
    }
    update(node);
}

void insert(Node *&node, Node *item) {
    if (!node) {
        node = item;
    } else if (item->priority > node->priority) {
        split(node, item->key, item->left, item->right);
        node = item;
    } else if (item->key < node->key) {
        insert(node->left, item);
    } else {
        insert(node->right, item);
    }
    update(node);
}

void erase(Node *&node, pii key) {
    if (!node) return;
    if (node->key == key) {
        Node *temp = node;
        merge(node, node->left, node->right);
        delete temp;
    } else if (key < node->key) {
        erase(node->left, key);
    } else {
        erase(node->right, key);
    }
    update(node);
}

ll query(Node *node, int x) {
    if (!node || x <= 0) return 0;
    int leftSize = getSize(node->left);
    if (leftSize >= x) {
        return query(node->left, x);
    } 
    ll res = getSum(node->left) + (ll)node->key.fi * node->key.se;
    x -= leftSize + 1;
    if (x > 0) {
        res += query(node->right, x);
    }
    return res;
}
class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        const int n = a.size();
        unordered_map<int, int> freq_map;
        Node *root = nullptr;
        vll res;

        rep(i, 0, k) {
            int old_freq = freq_map[a[i]];
            if (old_freq > 0) {
                erase(root, pii(-old_freq, -a[i]));
            }
            freq_map[a[i]] = old_freq + 1;
            insert(root, new Node(pii(-freq_map[a[i]], -a[i])));
        }
        res.pb(query(root, x));

        rep(i, k, n) {
            int out_val = a[i - k];
            int in_val = a[i];

            int out_freq = freq_map[out_val];
            erase(root, pii(-out_freq, -out_val));
            if (out_freq == 1) {
                freq_map.erase(out_val);
            } else {
                freq_map[out_val] = out_freq - 1;
                insert(root, new Node(pii(-freq_map[out_val], -out_val)));
            }

            int in_old_freq = freq_map[in_val];
            if (in_old_freq > 0) {
                erase(root, pii(-in_old_freq, -in_val));
            }
            freq_map[in_val] = in_old_freq + 1;
            insert(root, new Node(pii(-freq_map[in_val], -in_val)));

            res.pb(query(root, x));
        }
        return res;
    }
};",1420578528
Ryan,ryanwong0127,59,3610,python3,"class Solution:
    def findXSum(self, a: List[int], k: int, x: int) -> List[int]:
        n,max_val = len(a), max(a)  
        counts = [0] * (max_val + 1) 

        res = []
        for i in range(n - k + 1):
            if i == 0:
                for j in range(k):
                    counts[a[j]] += 1
            else:
                counts[a[i - 1]] -= 1
                counts[a[i + k - 1]] += 1

            freq_list = []
            for val in range(len(counts)):
                if counts[val] > 0:
                    freq_list.append((counts[val], val))

            freq_list.sort(key=lambda x: (-x[0], -x[1]))

            total = 0
            elements_taken = 0
            for freq, val in freq_list:
                total += freq * val
                elements_taken += 1
                if elements_taken == x:
                    break
            res.append(total)

        return res",1420521043
Ying Liu,pein531,60,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> cands;
    unordered_map<TreeNode*, int> sz;   // 统计子树大小
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(cands.begin(), cands.end());
        reverse(cands.begin(), cands.end());
        return k > cands.size()? -1: cands[k - 1];
    }

    pair<int, int> dfs(TreeNode* root) {
        if(!root) return {1, 0};
        auto leftInfo = dfs(root->left);
        auto rightInfo = dfs(root->right);
        int cnt = leftInfo.second + rightInfo.second + 1;
        int flag = (leftInfo.first == 1 && rightInfo.first == 1 && leftInfo.second == rightInfo.second)? 1: 0;
        if(flag) {
            cands.push_back(cnt);
        }
        return {flag, cnt};
    }
};",1420530157
Ying Liu,pein531,60,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = int(1e9 + 7)
        cands = ['F', 'W', 'E']
        @lru_cache(None)
        def dfs(i: int, score: int, pre: str) -> int:
            if i == n:
                return 1 if score > 0 else 0
            cnt = 0
            for cur in cands:
                if cur == pre:
                    continue
                delta = 0
                if s[i] != cur:
                    if (cur == 'F' and s[i] == 'E') or (cur == 'W' and s[i] == 'F') or (cur == 'E' and s[i] == 'W'):
                        delta = 1
                    else:
                        delta = -1
                cnt = (cnt + dfs(i + 1, score + delta, cur)) % mod
            return cnt
        ans = dfs(0, 0, '*')
        dfs.cache_clear()
        return ans",1420550929
Ying Liu,pein531,60,3592,cpp,"class Solution
{
public:
    map<int, int> cnt;
    map<int, set<int, greater<int>>, greater<int>> amap;
    map<int, set<int>> bmap;
    set<int> aset, bset;
    long long nowsum = 0;
    int n, szb = 0;
    void add(int x)
    {
        int c = cnt[x];
        cnt[x]++;
        if (aset.count(x))
        {
            amap[c].erase(x);
            aset.erase(x);
            if (amap[c].empty())
                amap.erase(c);
            bmap[c + 1].insert(x);
            bset.insert(x);
            szb += 1;
            nowsum += 1ll * (c + 1) * x;
        }
        else if (bset.count(x))
        {
            bmap[c].erase(x);
            if (bmap[c].empty())
                bmap.erase(c);
            bmap[c + 1].insert(x);
            nowsum += x;
        }
        else
        {
            bmap[c + 1].insert(x);
            bset.insert(x);
            nowsum += x;
            szb++;
        }
        while (szb > n)
        {
            int oldcnt = bmap.begin()->first;
            int oldx = *(bmap.begin()->second.begin());
            bmap.begin()->second.erase(bmap.begin()->second.begin());
            bset.erase(oldx);
            aset.insert(oldx);
            amap[oldcnt].insert(oldx);
            if (bmap.begin()->second.empty())
                bmap.erase(bmap.begin());
            szb--;
            nowsum -= 1ll * (oldcnt)*oldx;
        }
    }
    void erase(int x)
    {
        int c = cnt[x];
        cnt[x]--;
        if (aset.count(x))
        {
            amap[c].erase(x);
            if (amap[c].empty())
                amap.erase(c);
            amap[c - 1].insert(x);
        }
        else if (bset.count(x))
        {
            bmap[c].erase(x);
            bset.erase(x);
            if (bmap[c].empty())
                bmap.erase(c);
            amap[c - 1].insert(x);
            aset.insert(x);
            szb--;
            nowsum -= 1ll * c * x;
        }
        while (!aset.empty() && szb < n)
        {
            int oldcnt = amap.begin()->first;
            int oldx = *(amap.begin()->second.begin());
            amap.begin()->second.erase(amap.begin()->second.begin());
            aset.erase(oldx);
            if (amap.begin()->second.empty())
                amap.erase(amap.begin());
            bset.insert(oldx);
            bmap[oldcnt].insert(oldx);
            szb++;
            nowsum += 1ll * (oldcnt)*oldx;
        }
    }
    vector<long long> findXSum(vector<int> &nums, int k, int x)
    {
        n = x;
        for (int i = 0; i < k - 1; i++)
        {
            add(nums[i]);
        }
        vector<long long> ans;
        for (int i = k - 1; i < nums.size(); i++)
        {
            add(nums[i]);
            ans.push_back(nowsum);
            erase(nums[i - k + 1]);
        }
        return ans;
    }
};",1420578647
Ying Liu,pein531,60,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        for(int i = 0; i + k - 1 < n; i++) {
            vector<int> temp;
            for(int j = i; j <= i + k - 1; j++) {
                temp.push_back(nums[j]);
            }
            ans[i] = solve(temp, x);
        }
        return ans;
    }

    int solve(vector<int>& nums, int x) {
        unordered_map<int, int> counter;
        for(int num: nums) counter[num]++;
        if(counter.size() < x) return accumulate(nums.begin(), nums.end(), 0);
        vector<array<int, 2>> tup;
        for(auto&[num, cnt]: counter) {
            tup.push_back({cnt, num});
        }
        sort(tup.begin(), tup.end(), [&](auto& a, auto& b) {
            if(a[0] != b[0]) return a[0] > b[0];
            return a[1] > b[1];
        });
        int ans = 0;
        for(int i = 0; i < x; i++) {
            ans += tup[i][0] * tup[i][1];
        }
        return ans;
    }
};",1420521427
green_pig,green_pig,61,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        a = []
        def dfs(i):
            if i == None: return 1, 0
            p1, d1 = dfs(i.left)
            p2, d2 = dfs(i.right)
            d = max(d1, d2) + 1
            p = p1 and p2 and d1 == d2
            if p: a.append(2**d-1)
            return p, d
        dfs(root)
        return sorted(a)[::-1][k-1] if k <= len(a) else -1",1420520423
green_pig,green_pig,61,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        s = ['FWE'.index(x) for x in s]
        dp = [[1] + [0] * len(s)*2 for _ in range(3)]
        for x in s:
            dp2 = [[0] * (2*len(s)+1) for _ in range(3)]
            for p in range(3):
                for c in range(-len(s),len(s)+1):
                    for j in range(3):
                        if j != p:
                            t = ((x-j)%3==2) - ((x-j)%3==1)
                            dp2[p][c] += dp[j][c-t]
                    dp2[p][c] %= 1000000007
            dp = dp2
        return sum(sum(dp[j][1:len(s)+1]) for j in range(3))*pow(2,-1,1000000007)%1000000007",1420549117
green_pig,green_pig,61,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedList
        s = SortedList()
        t = 0
        def add(c, n):
            nonlocal t
            s.add((c, n))
            if s.index((c, n)) >= len(s) - x:
                t += c * n
                if len(s) - x - 1 >= 0:
                    c1, n1 = s[len(s) - x - 1]
                    t -= c1 * n1
        def remove(c, n):
            nonlocal t
            if s.index((c, n)) >= len(s) - x:
                t -= c * n
                if len(s) - x - 1 >= 0:
                    c1, n1 = s[len(s) - x - 1]
                    t += c1 * n1
            s.remove((c, n))
        c = Counter()
        def inc(n):
            if n in c:
                remove(c[n], n)
            c[n] += 1
            add(c[n], n)
        def dec(n):
            remove(c[n], n)
            c[n] -= 1
            if c[n] == 0:
                del c[n]
            else:
                add(c[n], n)
        for i in range(k):
            inc(nums[i])
        r = []
        for i in range(len(nums)-k+1):
            r.append(t)
            if i+k < len(nums):
                inc(nums[i+k])
                dec(nums[i])
        return r",1420567493
green_pig,green_pig,61,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        r = []
        for i in range(len(nums)-k+1):
            c = Counter(nums[i:i+k])
            a = sorted(c, key=lambda x: (c[x], x))[::-1][:x]
            r.append(sum(s * c[s] for s in a))
        return r",1420553170
John,123GJWEQ2,62,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        powers = set()
        
        for i in range(20):
            powers.add(2 ** i - 1)
        
        
        def dfs(node):
            if node == None:
                return 0
            
            t2 = dfs(node.left)
            t1 = dfs(node.right)
            if t1 == t2 and t1 in powers:
                ans.append(t1 + t2 + 1)
                return t1 + t2 + 1
            return -1
        
        dfs(root)
        ans.sort()
        ans.reverse()
        
        if k - 1 >= len(ans):
            return -1
        
        return ans[k - 1]",1420524290
John,123GJWEQ2,62,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        to_ind = {
            ""F"": 0,
            ""W"": 1,
            ""E"": 2,
        }
        
        #0 beats 2
        #1 beats 0
        #2 beats 1
        
        old_dp = [(0, 0, 0) for i in range(2 * len(s) + 20)]
        offset = len(s) + 10
        mod = 10 ** 9 + 7
        res = 0
        
        if to_ind[s[-1]] == 0:
            old_dp[offset] = (1, 0, 0)
            old_dp[1 + offset] = (0, 1, 0)
            old_dp[offset - 1] = (0, 0, 1)
            
        elif to_ind[s[-1]] == 1:
            old_dp[offset] = (0, 1, 0)
            old_dp[1 + offset] = (0, 0, 1)
            old_dp[offset - 1] = (1, 0, 0)
        else:
            old_dp[offset] = (0, 0, 1)
            old_dp[1 + offset] = (1, 0, 0)
            old_dp[offset - 1] = (0, 1, 0)
            
        for x in range(len(s) - 2, -1, -1):
            new_dp = [(0, 0, 0) for m in range(2 * len(s) + 20)]
            
            for i in range(1, len(new_dp) - 1):
                if to_ind[s[x]] == 0:
                    new_dp[i] = ((old_dp[i][1] + old_dp[i][2]) % mod,
                                 (old_dp[i - 1][0] + old_dp[i - 1][2]) % mod, 
                                 (old_dp[i + 1][0] + old_dp[i + 1][1]) % mod)
                elif to_ind[s[x]] == 1:
                    new_dp[i] = ((old_dp[i + 1][1] + old_dp[i + 1][2]) % mod,
                                 (old_dp[i][0] + old_dp[i][2]) % mod, 
                                 (old_dp[i - 1][0] + old_dp[i - 1][1]) % mod)
                else:
                    new_dp[i] = ((old_dp[i - 1][1] + old_dp[i - 1][2]) % mod,
                                 (old_dp[i + 1][0] + old_dp[i + 1][2]) % mod, 
                                 (old_dp[i][0] + old_dp[i][1]) % mod)
                
                
            old_dp = new_dp
            
            
        for i in range(offset + 1, len(old_dp)):
            res += sum(old_dp[i])
            res %= mod
            
        return res
            ",1420547564
John,123GJWEQ2,62,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        s1 = SortedList([(0, 0) for i in range(x + 1)]) #cnt, val (multiplied by -1)
        cnts = {}
        ans = []
        
        for i in list(set(nums)):
            s1.add((0, -i))
            cnts[-i] = 0
        
        p1 = 0
        p2 = 0
        res = 0
        
        while p2 < len(nums):
            num, cnt = -1 * nums[p2], cnts[-1 * nums[p2]]
            
            #removal
            if s1.bisect_left((cnt, num)) <= x - 1: #if it is in the k range
                res -= num * cnt #remove it from the sum
                s1.remove((cnt, num)) #remove it from the sortedlist
                res += s1[x - 1][0] * s1[x - 1][1] #add the new element to the answer
            else:
                s1.remove((cnt, num)) #just remove it from the sum
                
                
            #addition
            s1.add((cnt - 1, num)) #add the new one with the added count to the answer
            cnts[num] -= 1
            
            if s1.bisect_left((cnt - 1, num)) <= x - 1: #if the new count is in the range
                res += (cnt - 1) * num #add it to the result
                res -= s1[x][0] * s1[x][1] #take away the one moved out from the result
                
            
            #this is decreasing an element cnt
            if p2 - p1 + 1 > k:
                num, cnt = -1 * nums[p1], cnts[-1 * nums[p1]]
                
                if s1.bisect_left((cnt, num)) <= x - 1: #if it is in the k range
                    res -= num * cnt
                    s1.remove((cnt, num))
                    res += s1[x - 1][0] * s1[x - 1][1]
                else:
                    s1.remove((cnt, num))
                    
                    
                s1.add((cnt + 1, num))
                cnts[num] += 1
                
                if s1.bisect_left((cnt + 1, num)) <= x - 1:
                    res += (cnt + 1) * num
                    res -= s1[x][0] * s1[x][1]

                p1 += 1
                
                
            if p2 - p1 + 1 == k:
                ans.append(res)
                
            
            p2 += 1
            
        return ans",1420580194
John,123GJWEQ2,62,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        
        def calculate(arr):
            cnts = {}
            res = 0
            
            stuff = []
            
            for i in arr:
                cnts[i] = cnts.get(i, 0) + 1
                
            for (key, val) in cnts.items():
                stuff.append((val, key))
                
            stuff.sort()
            stuff.reverse()

            for i in range(min(len(stuff), x)):
                res += stuff[i][0] * stuff[i][1]
            return res
        
        
        for i in range(len(nums)):
            if i + k - 1 == len(nums):
                break
            
            ans.append(calculate(nums[i: i + k]))
        return ans",1420520488
Ye Gao,gaosanyong,63,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        vals = []
        
        def fn(node): 
            if not node: return 0 
            left = fn(node.left)
            right = fn(node.right)
            if left == -1 or right == -1 or left != right: return -1 
            ans = left + right + 1
            vals.append(ans)
            return ans 
        
        fn(root)
        vals.sort(reverse=True)
        if k <= len(vals): return vals[k-1]
        return -1 ",1420526758
Ye Gao,gaosanyong,63,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 1_000_000_007
        n = len(s)
        
        @cache
        def fn(i, p, diff): 
            """"""Return """"""
            if i == n: return int(diff > 0)
            ans = 0
            for x in ""EFW"": 
                if x != p: 
                    if s[i] == x: ans += fn(i+1, x, diff)
                    else: 
                        if s[i] == 'E': 
                            if x == 'F': d = diff + 1
                            else: d = diff - 1
                        elif s[i] == 'F': 
                            if x == 'E': d = diff - 1
                            else: d = diff + 1
                        else: 
                            if x == 'E': d = diff + 1
                            else: d = diff - 1
                        ans += fn(i+1, x, d)
            return ans % mod 
        
        return fn(0, """", 0)",1420540274
Ye Gao,gaosanyong,63,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        sl = SortedList()
        freq = Counter()
        ans = []
        total = 0 
        
        def add(v): 
            ans = 0 
            sl.add((-freq[v], -v))
            j = sl.bisect_left((-freq[v], -v))
            if j < x: 
                ans += freq[v]*v
                if len(sl) > x: 
                    ff, vv = sl[x]
                    ans -= ff*vv
            return ans 
            
        def remove(v): 
            ans = 0 
            j = sl.bisect_left((-freq[v], -v))
            if j < x: 
                ans -= freq[v]*v
                if len(sl) > x: 
                    ff, vv = sl[x]
                    ans += ff*vv
            sl.remove((-freq[v], -v))
            return ans 
        
        for i, v in enumerate(nums): 
            if freq[v]: total += remove(v)
            freq[v] += 1
            total += add(v)
            # print(""add"", total, freq, sl)
            if i >= k: 
                total += remove(nums[i-k])
                freq[nums[i-k]] -= 1
                if freq[nums[i-k]]: total += add(nums[i-k])
                # print(""remove"", total, freq, sl)
            if i >= k-1: ans.append(total)
            # print(i, v, total, sl, freq)
        return ans ",1420581047
Ye Gao,gaosanyong,63,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        n = len(nums)
        for i in range(n-k+1): 
            freq = Counter(nums[i:i+k])
            vals = sorted(freq.items(), key = lambda x: (-x[1], -x[0]))
            total = 0
            for j in range(i, i+k): 
                v = vals.index((nums[j], freq[nums[j]]))
                if v < x: total += nums[j]
            ans.append(total)
        return ans ",1420521651
lilPeep,stupidRR,66,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> good;
    pair<int,int> dfs(TreeNode* root)
    {
        if(root==NULL)
            return {0,0};
        
        int subtree=1;
        auto leftContri=dfs(root->left);
        auto rightContri=dfs(root->right);
        subtree=subtree+leftContri.first+rightContri.first;
        int depth=std::max(leftContri.second,rightContri.second)+1;
        if(1<<depth == subtree+1 )
            good.push_back(subtree);
        return {subtree,depth};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(good.rbegin(),good.rend());
        if(good.size()<k)
            return -1;
        return good[k-1];
    }
};",1420521453
lilPeep,stupidRR,66,3588,cpp,"class Solution {
    const int mod=1e9+7;
public:
    int countWinningSequences(string s) {
        vector<int> rep;
        for(auto used : s)
        {
            if(used=='F')
                rep.push_back(1);
            else if(used=='W')
                rep.push_back(0);
            else if(used=='E')
                rep.push_back(2);
        }
        
        int n=s.size();
        vector<vector<long long>> dp(2*n+1,vector<long long>(3,0));
        
        if(s[0]=='F')
        {
            dp[n][1]=1ll;
            dp[n-1][2]=1ll;
            dp[n+1][0]=1ll;
        }
        else if(s[0]=='E')
        {
            dp[n][2]=1ll;
            dp[n-1][0]=1ll;
            dp[n+1][1]=1ll;
        }
        else if(s[0]=='W')
        {
            dp[n][0]=1ll;
            dp[n-1][1]=1ll;
            dp[n+1][2]=1ll;
        }
        
        for(int i=1;i<n;i++)
        {
            int turnPlayed=rep[i];
            vector<vector<long long>> ndp(2*n+1,vector<long long>(3,0));
            
            for(int points=0;points<=2*n;points++)
            {
                for(int played=0;played<3;played++)
                {
                    for(int nextTurn=0;nextTurn<3;nextTurn++)
                    {
                        if(nextTurn==played)
                            continue;
                        
                        if(nextTurn==turnPlayed)
                            ndp[points][nextTurn]=(ndp[points][nextTurn]+dp[points][played])%mod;
                        if( (nextTurn+1)%3==turnPlayed && points<2*n)
                            ndp[points+1][nextTurn]=(ndp[points+1][nextTurn]+dp[points][played])%mod;
                        if( (nextTurn)%3==(turnPlayed+1)%3 && points)
                            ndp[points-1][nextTurn]=(ndp[points-1][nextTurn]+dp[points][played])%mod;
                    }
                }
            }
            
            swap(ndp,dp);
        }
        long long ans=0ll;
        for(int i=n+1;i<=2*n;i++)
            ans=(ans+dp[i][0]+dp[i][1]+dp[i][2])%mod;
        return ans;
    }
};",1420535462
lilPeep,stupidRR,66,3592,cpp,"class Solution {
struct Fenwick
{
    vector<long long> BIT;
    long long MAXN;
    
    void init(int n)
    {
        BIT.resize(n+5);
        MAXN=n+5;
    }

    long long query(long long x)
    {
       long long ans=0;
        x=std::min(x,MAXN-1);
       while(x>0)
       {
          ans+=BIT[x];
          x-=(x&-x);
       }
       return ans; 
    }
     
    void update(long long x,long long val)
    {
        if(x==0)
            return;
        
       while(x<MAXN)
       {
          BIT[x]+=val;
          x+=(x&-x);
       }
    }
     
    long long bit_search(long long v)
    {
        long long sum = 0;
        long long pos = 0;
        for (long long i = 25; i >= 0; i--)
        {
            if (pos + (1 << i) < MAXN)
            {
                long long nextPos = pos + (1 << i);
                if (sum + BIT[nextPos] < v)
                {
                    sum += BIT[nextPos]; 
                    pos = nextPos;
                }
            }
        }
        return pos ;
    }
};

public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        map<int,long long> mp;
        for(int i=0;i<n;i++)
            mp[ nums[i] ]++;
        
        vector< pair<int,int> > tmp;
        for(auto &[key,value] : mp)
        {
            for(int j=1;j<=value;j++)
                tmp.push_back({j,key});
        }
        
        sort(tmp.begin(),tmp.end(),[&](pair<int,int>a,pair<int,int>b){
           if(a.first!=b.first)
               return a.first>b.first;
            return a.second>b.second;
        });
        
        map< pair<int,int>,int > index;
        for(int i=0;i<tmp.size();i++)
            index[ tmp[i] ]=i+1;
        
        Fenwick f1;
        Fenwick f2;
        f1.init(n+5);
        f2.init(n+5);
        
        vector<long long> ans;
        mp.clear();
        for(int i=0;i<n;i++)
        {
            if(mp[ nums[i] ]!=0)
            {
                int ind=index[ {mp[nums[i]],nums[i]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i]]*1ll*nums[i] );
            }
            mp[nums[i]]++;
            int ind=index[ {mp[nums[i]],nums[i]} ];
            f1.update(ind,1);
            f2.update(ind, mp[nums[i]]*1ll*nums[i] );
            
            if(i>=k)
            {
                int ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i-k]]*1ll*nums[i-k] );
                mp[ nums[i-k] ]--;
                ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                if( mp[ nums[i-k] ])
                {
                    f1.update(ind,1);
                    f2.update(ind,mp[nums[i-k]]*1ll*nums[i-k] );
                }
            }
            
            if(i>=k-1)
                ans.push_back(  f2.query ( f1.bit_search(x+1) )  );
        }
        return ans;
    }
};",1420575134
lilPeep,stupidRR,66,3610,cpp,"class Solution {
struct Fenwick
{
    vector<long long> BIT;
    long long MAXN;
    
    void init(int n)
    {
        BIT.resize(n+5);
        MAXN=n+5;
    }

    long long query(long long x)
    {
       long long ans=0;
        x=std::min(x,MAXN-1);
       while(x>0)
       {
          ans+=BIT[x];
          x-=(x&-x);
       }
       return ans; 
    }
     
    void update(long long x,long long val)
    {
        if(x==0)
            return;
        
       while(x<MAXN)
       {
          BIT[x]+=val;
          x+=(x&-x);
       }
    }
     
    long long bit_search(long long v)
    {
        long long sum = 0;
        long long pos = 0;
        for (long long i = 25; i >= 0; i--)
        {
            if (pos + (1 << i) < MAXN)
            {
                long long nextPos = pos + (1 << i);
                if (sum + BIT[nextPos] < v)
                {
                    sum += BIT[nextPos]; 
                    pos = nextPos;
                }
            }
        }
        return pos ;
    }
};

public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        map<int,long long> mp;
        for(int i=0;i<n;i++)
            mp[ nums[i] ]++;
        
        vector< pair<int,int> > tmp;
        for(auto &[key,value] : mp)
        {
            for(int j=1;j<=value;j++)
                tmp.push_back({j,key});
        }
        
        sort(tmp.begin(),tmp.end(),[&](pair<int,int>a,pair<int,int>b){
           if(a.first!=b.first)
               return a.first>b.first;
            return a.second>b.second;
        });
        
        map< pair<int,int>,int > index;
        for(int i=0;i<tmp.size();i++)
            index[ tmp[i] ]=i+1;
        
        Fenwick f1;
        Fenwick f2;
        f1.init(n+5);
        f2.init(n+5);
        
        vector<int> ans;
        mp.clear();
        for(int i=0;i<n;i++)
        {
            if(mp[ nums[i] ]!=0)
            {
                int ind=index[ {mp[nums[i]],nums[i]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i]]*1ll*nums[i] );
            }
            mp[nums[i]]++;
            int ind=index[ {mp[nums[i]],nums[i]} ];
            f1.update(ind,1);
            f2.update(ind, mp[nums[i]]*1ll*nums[i] );
            
            if(i>=k)
            {
                int ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                f1.update(ind,-1);
                f2.update(ind, -mp[nums[i-k]]*1ll*nums[i-k] );
                mp[ nums[i-k] ]--;
                ind=index[ {mp[nums[i-k]],nums[i-k]} ];
                if( mp[ nums[i-k] ])
                {
                    f1.update(ind,1);
                    f2.update(ind,mp[nums[i-k]]*1ll*nums[i-k] );
                }
            }
            
            if(i>=k-1)
                ans.push_back(  f2.query ( f1.bit_search(x+1) )  );
        }
        return ans;
    }
};",1420575924
Chinedu,profchi,67,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    List<Integer> list = new ArrayList<>();
    
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        
        getAll(root);
        
        Collections.sort(list, (a, b) -> b - a);
        
        return list.size() < k ? -1 : list.get(k - 1);
    }
    
    private int getAll(TreeNode node) {
        if (node == null)
            return 0;
        
        int left = getAll(node.left);
        int right = getAll(node.right);
        
        int total = left + right + 1;
        
        if (left == right && left >= 0) {
            list.add(total);
            return total;
        }
        
        return -1;
    }
}",1420526882
Chinedu,profchi,67,3588,java,"class Solution {
    
    char [] arr = new char [] {'F', 'W', 'E'};
    int mod = 1_000_000_007;
    Integer [][][] memo;
    int add;
    
    public int countWinningSequences(String s) {
        memo = new Integer[4][s.length()][s.length() * 2 + 1];
        add = s.length();
        return countWinning(s, 0, 3, 0);
    }
    
    private int countWinning(String s, int idx, int prev, int sc) {
        if (idx == s.length()) {
            return sc > 0 ? 1 : 0;
        }else if (memo[prev][idx][sc + add] != null)
            return memo[prev][idx][sc + add];
        
        int aVal = get(s.charAt(idx));
        
        int score;
        
        int result = 0;
        
        for (int b = 0; b < 3; ++b) {
            
            if (b == prev)
                continue;
            
            if (wins(aVal, b)) {
                score = 1;
            } else {
                score = aVal == b ? 0 : -1;
            }
            
            result += countWinning(s, idx + 1, b, sc + score);
            result %= mod;
        }
        
        memo[prev][idx][sc + add] = result;
        return result;
    }
    
    private boolean wins(int a, int b) {
        int next = a + 1;
        next %= 3;
        
        return next == b;
    }
    
    private int get(char c) {
        
        for (int i = 0; i < arr.length; ++i) {
            if (arr[i] == c)
                return i;
        }
        
        return arr.length;
    }
}",1420539351
Chinedu,profchi,67,3592,java,"class Solution {
    
    
    TreeSet<Integer> top;
    TreeSet<Integer> bottom;
    int [] count;
    long current;
    
    int [] vals;
    
    public long[] findXSum(int[] nums, int k, int x) {
        
        vals = compress(nums);
        
        int max = vals.length;
        count = new int [max];
        
        top = new TreeSet<>((a, b) -> count[a] == count[b] ? a - b : count[a] - count[b]);
        bottom = new TreeSet<>((a, b) -> count[a] == count[b] ? a - b : count[a] - count[b]);
        
        current = 0;
        
        long [] result = new long [nums.length - k + 1];
        
        for (int i = 0; i < k - 1; ++i) {
            add(nums[i], 1, x);    
        }
        
        // System.out.println(top + "" "" + Arrays.toString(count) + "" "" + current);
        
        for (int i = k - 1, j = 0; i < nums.length; ++i, ++j) {
            add(nums[i], 1, x);
            
            // System.out.println(top + "" "" + Arrays.toString(count) + "" "" + current);
            
            result[j] = current;
            
            add(nums[j], -1, x);
        }
        
        return result;
    }
    
    private void add(int num, int add, int x) {
        
        bottom.remove(num);
        
        long val;
        
        if (top.contains(num)) {
            top.remove(num);
            val = vals[num];
            val *= count[num];
            current -= val;
        }
        
        count[num] += add;
        bottom.add(num);
        
        int node;
        
        if (!top.isEmpty()) {
            node = top.first();
            val = vals[node];
            val *= count[node];
            current -= val;
            top.remove(node);
            bottom.add(node);
        }
        
        
        while (top.size() < x && bottom.size() > 0) {
            
            node = bottom.last();
            bottom.remove(node);
            val = vals[node];
            val *= count[node];
            current += val;
            top.add(node);
            // System.out.println(""Here"" + "" "" + current);
        }
    }
    
    private int [] compress(int [] nums) {
        Set<Integer> set = new HashSet<>();
        
        for (int num : nums) {
            set.add(num);
        }
        
        List<Integer> list = new ArrayList<>(set);
        
        Map<Integer, Integer> map = new HashMap<>();
        
        Collections.sort(list);
        int [] result = new int [list.size()];
        
        for (int i = 0; i < list.size(); ++i) {
            map.put(list.get(i), i);
            result[i] = list.get(i);
        }
        
        for (int i = 0; i < nums.length; ++i) {
            nums[i] = map.get(nums[i]);
        }
        
        return result;
    }
}",1420582220
Chinedu,profchi,67,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        
        int [] result = new int [nums.length - k + 1];
        
        for (int i = 0; i + k <= nums.length; ++i) {
            result[i] = findXSum(nums, i, i + k - 1, x);
        }
        
        return result;
    }
    
    private int findXSum(int [] arr, int l, int r, int x) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int i = l; i <= r; ++i) {
            map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
        }
        
        List<Integer> list = new ArrayList<>(map.keySet());
        
        Collections.sort(list, (a, b) -> {
            int kA = map.get(a);
            int kB = map.get(b);
            
            return kA == kB ? b - a : kB - kA;
        });
        
        int total = 0;
        
        for (int i = 0; i < list.size() && i < x; ++i) {
            total += list.get(i) * map.get(list.get(i));
        }
        
        // System.out.println(map);
        // System.out.println(list);
        
        return total;
    }
}",1420549779
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        auto dfs = [&](auto self, TreeNode* node) -> array<int, 3> {
            if (node == nullptr) {
                return {0, 0, 1};
            }
            auto [sleft, depth1, pos1] = self(self, node->left);
            auto [sright, depth2, pos2] = self(self, node->right);
            
            int pos_me = pos1 & pos2;

            if ((node->left == nullptr) != (node->right == nullptr)) {
                pos_me = false;
            }

            if (depth1 != depth2) {
                pos_me = false;
            }

            if (pos_me) {
                sizes.push_back(sleft + sright + 1);
            }

            return {sleft + sright + 1, max(depth1, depth2) + 1, pos_me};
        };
        dfs(dfs, root);
        sort(sizes.rbegin(), sizes.rend());
        if ((int)sizes.size() < k) {
            return -1;
        }
        return sizes[k - 1];
    }
};",1420527387
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int offset = 1005;

        const int N = 3005;

        int n = (int)s.size();
        int dp[n + 1][N][4];

        s = ""#"" + s;

        const int MOD = 1e9 + 7;

        memset(dp, 0, sizeof dp);
        dp[0][offset][3] = 1;

        for (int i = 1; i <= n; ++i) {
            int h = s[i] == 'F' ? 0 : (s[i] == 'W' ? 1 : 2);
            for (int p = -n; p <= n; ++p) {
                int cp = p + offset;
                for (int me = 0; me < 3; ++me) {
                    int np = cp + ((h + 1) % 3 == me ? 1 : h == me ? 0 : -1);
                    for (int he = 0; he < 4; ++he) {
                        if (me == he) {
                            continue;
                        }

                        (dp[i][np][me] += dp[i - 1][cp][he]) %= MOD;

                    }
                }
            }
        }

        int total = 0;
        for (int i = 1; i + offset < N; ++i) {
            for (int t = 0; t < 3; ++t) {
                total += dp[n][i + offset][t];
                total %= MOD;
            }
        }
        return total;
    }
};",1420546379
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        set<pair<int, int>> small, large;
        map<int, int> freq;
        for (int i = 0; i < k; ++i) {
            ++freq[a[i]];
        }

        long long sum_large = 0;
        for (auto p : freq) {
            large.insert({p.second, p.first});
            sum_large += 1LL * p.second * p.first;
        }

        while ((int)large.size() > x) {
            pair<int, int> p = *large.begin();
            small.insert(p);
            large.erase(p);
            sum_large -= 1LL * p.first * p.second;
        }

        vector<long long> ans;
        ans.push_back(sum_large);

        auto add = [&](int v, int coeff) -> void {
            if (large.count({freq[v], v})) {
                large.erase({freq[v], v});
                sum_large -= 1LL * freq[v] * v;
            } else {
                small.erase({freq[v], v});
            }

            freq[v] += coeff;

            small.insert({freq[v], v});

            while (!small.empty() && (int)large.size() < x) {
                pair<int, int> p = *small.rbegin();
                large.insert(p);
                small.erase(p);
                sum_large += 1LL * p.first * p.second;
            }

            while (!small.empty() && *large.begin() < *small.rbegin()) {
                pair<int, int> A = *large.begin();
                pair<int, int> B = *small.rbegin();
                large.erase(A);
                sum_large -= 1LL * A.first * A.second;
                small.erase(B);
                large.insert(B);
                small.insert(A);

                sum_large += 1LL * B.first * B.second;
            }

        };

        for (int i = k; i < (int)a.size(); ++i) {
            add(a[i - k], -1);
            add(a[i], 1);
            ans.push_back(sum_large);
        }
        return ans;

    }
};",1420563758
Kiu2024Fall_Eke-Bichi,Kiu2024Fall_Eke-Bichi,68,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        set<pair<int, int>> small, large;
        map<int, int> freq;
        for (int i = 0; i < k; ++i) {
            ++freq[a[i]];
        }

        long long sum_large = 0;
        for (auto p : freq) {
            large.insert({p.second, p.first});
            sum_large += 1LL * p.second * p.first;
        }

        while ((int)large.size() > x) {
            pair<int, int> p = *large.begin();
            small.insert(p);
            large.erase(p);
            sum_large -= 1LL * p.first * p.second;
        }

        vector<int> ans;
        ans.push_back(sum_large);

        auto add = [&](int v, int coeff) -> void {
            if (large.count({freq[v], v})) {
                large.erase({freq[v], v});
                sum_large -= 1LL * freq[v] * v;
            } else {
                small.erase({freq[v], v});
            }

            freq[v] += coeff;

            small.insert({freq[v], v});

            while (!small.empty() && (int)large.size() < x) {
                pair<int, int> p = *small.rbegin();
                large.insert(p);
                small.erase(p);
                sum_large += 1LL * p.first * p.second;
            }

            while (!small.empty() && *large.begin() < *small.rbegin()) {
                pair<int, int> A = *large.begin();
                pair<int, int> B = *small.rbegin();
                large.erase(A);
                sum_large -= 1LL * A.first * A.second;
                small.erase(B);
                large.insert(B);
                small.insert(A);

                sum_large += 1LL * B.first * B.second;
            }

        };

        for (int i = k; i < (int)a.size(); ++i) {
            add(a[i - k], -1);
            add(a[i], 1);
            ans.push_back(sum_large);
        }
        return ans;

    }
};",1420564836
IphoneX,hahahiehie,69,3509,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int L = 50 + 1;




    List<Integer> ans;
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        ans = new ArrayList<>();
        dfs(root);
        ans.sort((x, y) -> Integer.compare(y, x));
        if (ans.size() < k) return -1;
        else return ans.get(k - 1);
    }

    int dfs(TreeNode root) {
        if (root == null) return -1;
        int l = 0;
        if (root.left != null) {
            l = dfs(root.left);
        }
        int r = 0;
        if (root.right != null) {
            r = dfs(root.right);
        }
        if (l == r && l >= 0) {
            ans.add(l + r + 1);
            return l + r + 1;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420527826
IphoneX,hahahiehie,69,3588,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int L = 50 + 1;


    int score(int alice, int bob) {
        if (alice == bob) return 0;
        if (bob == 0 && alice == 1) return 1;
        else if (bob == 1 && alice == 2) return 1;
        else if (bob == 2 && alice == 0) return 1;
        return -1;
    }

    public int countWinningSequences(String s) {
        int n = s.length();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == 'F') {
                nums[i] = 0;
            } else if (s.charAt(i) == 'E') {
                nums[i] = 1;
            } else {
                nums[i] = 2;
            }
        }
        final int L = n;
        long[][][] dp = new long[n][n * 2 + 2][3];
        dp[0][score(nums[0], 0) + L][0] = 1;
        dp[0][score(nums[0], 1) + L][1] = 1;
        dp[0][score(nums[0], 2) + L][2] = 1;

        for (int i = 0; i < n - 1; i++) {
            for (int j = -(i + 1); j <= (i + 1); j++) {
                for (int c = 0; c <= 2; c++) {
                    if (dp[i][j + L][c] == 0) continue;

                    for (int c2 = 0; c2 <= 2; c2++) {
                        if (c2 == c) continue;
                        int sc = score(nums[i + 1], c2);
                        dp[i + 1][j + sc + L][c2] = (dp[i + 1][j + sc + L][c2] + dp[i][j + L][c]) % MOD;
                    }
                }
            }
        }

        long ans = 0;
        for (int sc = 1; sc <= n; sc++) {
            for (int c = 0; c <= 2; c++) {
                ans = (ans + dp[n - 1][sc + L][c]) % MOD;
            }
        }
        return (int) ans;

    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420546077
IphoneX,hahahiehie,69,3592,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    void print(TreapSet<int[]> set) {
        for (int i = 0; i < set.size(); i++) {
            System.out.printf(""[%d,%d] "", set.get(i)[0], set.get(i)[1]);
        }
        System.out.println();
    }

    long remove(int[] node, int x, TreapSet<int[]> set) {
        if (node[1] == 0) return 0;

        long ans = 0;
        if (set.index(node) < x) {
            ans = - (long) node[0] * node[1];
            set.remove(node);
            if (set.size() >= x) {
                int[] last = set.get(x - 1);
                ans += (long) last[0] * last[1];
            }
        } else {
            set.remove(node);
        }
        //print(set);
        //System.out.println(""remove ans = "" + ans);

        return ans;
    }

    long add(int[] node, int x, TreapSet<int[]> set) {
        if (node[1] == 0) return 0;
        long ans = 0;
        if (set.index(node) < x) {
            ans = (long) node[0] * node[1];
            set.add(node);
            if (set.size() >= x + 1) {
                int[] last = set.get(x);
                ans -= (long) last[0] * last[1];
            }
        } else {
            set.add(node);
        }
        //print(set);
        //System.out.println(""add ans = "" + ans);
        return ans;
    }
    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] ans = new long[n - k + 1];

        Map<Integer, Integer> count = new HashMap<>();
        TreapSet<int[]> set = new TreapSet<>((a, b) -> {
            if (a[1] != b[1]) return Integer.compare(b[1], a[1]);
            else return Integer.compare(b[0], a[0]);
        });


        long curSum = 0;
        for (int i = 0; i < n; i++) {
            int oldCount = count.getOrDefault(nums[i], 0);
            int newCount = oldCount + 1;
            count.put(nums[i], newCount);
            int[] oldNode = {nums[i], oldCount};
            int[] newNode = {nums[i], newCount};
            curSum += remove(oldNode, x, set);
            curSum += add(newNode, x, set);

            if (i - k >= 0) {
                oldCount = count.get(nums[i - k]);
                oldNode = new int[] {nums[i - k], oldCount};
                newCount = oldCount - 1;
                count.put(nums[i - k], newCount);
                newNode = new int[] {nums[i - k], newCount};
                curSum += remove(oldNode, x, set);
                curSum += add(newNode, x, set);
            }

            if (i >= k - 1) {
                ans[i - k + 1] = curSum;
            }

            //System.out.println(""i = "" + i  + "" ==========\n"");

        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420582919
IphoneX,hahahiehie,69,3610,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int L = 50 + 1;

    int helper(int[] nums, int k, int XX, int index) {
        int[] count = new int[L];
        for (int i = index; i < index + k; i++) {
            count[nums[i]]++;
        }

        List<int[]> list = new ArrayList<>();
        for (int i = 1; i < L; i++) {
            if (count[i] > 0) {
                list.add(new int[] {i, count[i]});
            }
        }
        list.sort((x, y) -> {
            if (x[1] != y[1]) return Integer.compare(y[1], x[1]);
            else return Integer.compare(y[0], x[0]);
        });

        int sum = 0;
        for (int i = 0; i < XX && i < list.size(); i++) {
            sum += list.get(i)[0] * list.get(i)[1];   
        }
        return sum;
    }

    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        for (int i = 0; i + k <= n; i++) {
            ans[i] = helper(nums, k, x, i);
        }
        return ans;
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1420523030
scotchtape,scotchtape,70,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> P;
        // perfect, size
        function<pair<bool, int>(TreeNode *i)> perf = [&](TreeNode *i) {
            if (i == nullptr) return make_pair(true, 0);

            auto l = perf(i->left), r = perf(i->right);
            bool p = (l.first & r.first) && (l.second == r.second);
            int sz = l.second + r.second + 1;
            
            if (p) P.push_back(sz);
            return make_pair(p, sz);
        };

        perf(root);
        sort(P.rbegin(), P.rend());
        //for (int i : P) cout << i << endl;
        --k;
        if (k >= P.size()) return -1;
        return P[k];
    }
};",1420524057
scotchtape,scotchtape,70,3588,cpp,"
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");
    int v;
private:
    using ll = long long;

    static int minv(int a, int m) {
        a %= m;
        assert(a);
        return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);
    }
public:
    modnum() : v(0) {}
    modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }
    friend bool operator < (const modnum& a, const modnum& b) { return a.v < b.v; }
    friend bool operator > (const modnum& a, const modnum& b) { return a.v > b.v; }

    modnum inv() const {
        modnum res;
        res.v = minv(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(ll(v) * ll(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }

};
using num = modnum<int(1e9+7)>;

class Solution {
public:
    int countWinningSequences(string s) {
        using ll = long long;
        ll M = 1e9+7;
        ll n = s.size();

        ll S = 2*n+3;
        vector<vector<ll>> a(S, vector<ll>(3, 0));
        // # bob is ahead + n, prev move
        a[0+n] = {1, 1, 1};

        map<char, ll> MOVE;
        MOVE['F'] = 0;
        MOVE['W'] = 1;
        MOVE['E'] = 2;

        vector<vector<ll>> SCORE = {
                {0, 1, -1}, // alice fire
                {-1, 0, 1},
                {1, -1, 0}
        };

        for (char c : s) {
            vector<vector<ll>> ndp(S, vector<ll>(3, 0));
            ll x = MOVE[c];
            for (ll s = 0; s < S; ++s) {
                for (ll move = 0; move < 3; ++move) {
                    ll nxt_score = s + SCORE[x][move];
                    if (nxt_score < 0 || nxt_score >= S) continue;
                    for (ll prev = 0; prev < 3; ++prev) {
                        if (prev == move) continue;
                        ndp[nxt_score][move] = (ndp[nxt_score][move] + a[s][prev]) % M;
                    }
                }
            }
            swap(ndp, a);
        }
        ll ans = 0;
        for (ll i = n+1; i < S; ++i) {
            for (ll m = 0; m < 3; ++m) {
                ans = (ans + a[i][m]) % M;
            }
        }

        return (num(ans)/num(2)).v;
    }
};",1420545466
scotchtape,scotchtape,70,3592,cpp,"
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template<class T> using oset=tree<T, null_type, greater<T>, rb_tree_tag, tree_order_statistics_node_update>;

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        using ll = long long;
        ll n = a.size();
        vector<ll> ans;

//        for (int i : a) cout << i << ' ';
//        cout << endl << endl;

        map<ll, ll> m;
        for (ll i = 0; i < k; ++i) m[a[i]]++;

        oset<pair<ll, ll>> s;
        for (ll i = 0; i < n; ++i) s.insert({0, 1e12+i});

        vector<pair<ll, ll>> v;
        for (auto [x, cnt] : m) v.push_back({cnt, x}), s.insert({cnt, x});
        sort(v.rbegin(), v.rend());
        ll sum = 0;
        for (ll j = 0; j < min(ll(x), ll(v.size())); ++j)
            sum += v[j].first * v[j].second;
        ans.push_back(sum);

        auto rem = [&](ll val, ll cnt) {
            auto prev = make_pair(cnt, val);
            s.erase(prev);
            if (*s.find_by_order(x-1) <= prev) {
                // prev is part of sum
                sum -= prev.first * prev.second;

                // add the next guy
                auto nxt = *s.find_by_order(x-1);
                sum += nxt.first * nxt.second;
            }
        };

        auto add = [&](ll val, ll cnt) {
            auto nxt = make_pair(cnt, val);

            if (*s.find_by_order(x-1) <= nxt) {
                // nxt is in sum
                sum += nxt.first * nxt.second;

                // remove the last guy
                auto prev = *s.find_by_order(x-1);
                sum -= prev.first * prev.second;

            }
            s.insert(nxt);
        };

        for (int i = 0; i+k < n; ++i) {
            rem(a[i], m[a[i]]);
            --m[a[i]];
            add(a[i], m[a[i]]);

//            for (auto p : s) cout << p.first << ' ' << p.second << endl;
//            cout << sum << endl;
//            cout << endl << endl;

            rem(a[i+k], m[a[i+k]]);
            m[a[i+k]]++;
            add(a[i+k], m[a[i+k]]);

//            for (auto p : s) cout << p.first << ' ' << p.second << endl;
//            cout << sum << endl;
//            cout << endl << endl;

            ans.push_back(sum);
        }
        return ans;

    }
};",1420577477
scotchtape,scotchtape,70,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        vector<int> ans;
        for (int i = 0; i+k-1 < n; ++i) {
            map<int, int> m;
            for (int j = 0; j < k; ++j) {
                m[a[i+j]]++;
            }
            vector<pair<int, int>> v;
            for (auto [x, cnt] : m) v.push_back({cnt, x});
            sort(v.rbegin(), v.rend());

            int sum = 0;
            for (int j = 0; j < min<int>(x, v.size()); ++j) {
                sum += v[j].first * v[j].second;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420519743
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct ReturnType {
        bool isPerfect;
        int height;
        int size;
    };

    vector<int> perfectSubtreeSizes;

    ReturnType helper(TreeNode* root) {
        if (!root) {
            return { true, 0, 0 };
        }

        if (!root->left && !root->right) {
            perfectSubtreeSizes.push_back(1);
            return { true, 1, 1 };
        }

        ReturnType left = helper(root->left);
        ReturnType right = helper(root->right);

        bool isPerfect = false;
        int height = max(left.height, right.height) + 1;
        int size = left.size + right.size + 1;

        if (left.isPerfect && right.isPerfect && left.height == right.height) {
            isPerfect = true;
            perfectSubtreeSizes.push_back(size);
        }

        return { isPerfect, height, size };
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        helper(root);
        sort(perfectSubtreeSizes.begin(), perfectSubtreeSizes.end(), greater<int>());
        if (perfectSubtreeSizes.size() >= k) {
            return perfectSubtreeSizes[k - 1];
        } else {
            return -1;
        }
    }
};
",1420528690
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        int charToIndex[256];
        memset(charToIndex, -1, sizeof(charToIndex));
        charToIndex['F'] = 0;
        charToIndex['W'] = 1;
        charToIndex['E'] = 2;
        charToIndex['X'] = 3;

        bool beats[3][3];
        memset(beats, 0, sizeof(beats));
        beats[0][2] = true; 
        beats[1][0] = true; 
        beats[2][1] = true; 

        int maxScoreDiff = 2 * n;
        int offset = n; 

        const int MOD = 1e9 + 7;

        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(maxScoreDiff + 1, 0)));
        dp[0][3][offset] = 1; 

        for (int i = 0; i < n; ++i) {
            for (int lastBobMove = 0; lastBobMove < 4; ++lastBobMove) {
                for (int scoreDiff = 0; scoreDiff <= maxScoreDiff; ++scoreDiff) {
                    int ways = dp[i][lastBobMove][scoreDiff];
                    if (ways == 0) continue;

                    for (int bobMove = 0; bobMove < 3; ++bobMove) {
                        if (bobMove == lastBobMove) continue; 
                        int aliceMove = charToIndex[s[i]];
                        int scoreChange = 0;
                        if (bobMove == aliceMove) {
                            scoreChange = 0;
                        } else if (beats[bobMove][aliceMove]) {
                            scoreChange = 1; 
                        } else if (beats[aliceMove][bobMove]) {
                            scoreChange = -1; 
                        } else {
                            scoreChange = 0; 
                        }

                        int newScoreDiff = scoreDiff + scoreChange;
                        if (newScoreDiff < 0 || newScoreDiff > maxScoreDiff) continue;

                        dp[i + 1][bobMove][newScoreDiff] = (dp[i + 1][bobMove][newScoreDiff] + ways) % MOD;
                    }
                }
            }
        }
        int totalWays = 0;
        for (int lastBobMove = 0; lastBobMove < 3; ++lastBobMove) {
            for (int scoreDiff = offset + 1; scoreDiff <= maxScoreDiff; ++scoreDiff) {
                totalWays = (totalWays + dp[n][lastBobMove][scoreDiff]) % MOD;
            }
        }

        return totalWays;
    }
};
",1420546683
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;

        unordered_map<int, int> freq; 

        struct Compare {
            bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
                if (a.second != b.second)
                    return a.second > b.second; 
                else
                    return a.first > b.first; 
            }
        };

        multiset<pair<int, int>, Compare> top_elements; 
        multiset<pair<int, int>, Compare> rest_elements;

        unordered_map<int, multiset<pair<int, int>, Compare>::iterator> positions;

        long long x_sum = 0;

        auto insert_element = [&](int value) {
            int f = freq[value];
            pair<int, int> element = {value, f};

            auto it = rest_elements.insert(element);
            positions[value] = it;

            if (top_elements.size() < x) {
                top_elements.insert(element);
                rest_elements.erase(it);
                positions[value] = top_elements.find(element);
                x_sum += (long long)value * f;
            } else {
                auto min_top = prev(top_elements.end());
                if (Compare()(element, *min_top)) {
                    top_elements.insert(element);
                    rest_elements.erase(it);
                    positions[value] = top_elements.find(element);
                    x_sum += (long long)value * f;

                    rest_elements.insert(*min_top);
                    positions[min_top->first] = rest_elements.find(*min_top);
                    x_sum -= (long long)min_top->first * min_top->second;
                    top_elements.erase(min_top);
                }
            }
        };

        auto remove_element = [&](int value) {
            auto it = positions[value];
            if (top_elements.find(*it) != top_elements.end()) {
                x_sum -= (long long)value * it->second;
                top_elements.erase(it);
            } else {
                rest_elements.erase(it);
            }
            positions.erase(value);

            if (top_elements.size() < x && !rest_elements.empty()) {
                auto max_rest = rest_elements.begin();
                top_elements.insert(*max_rest);
                positions[max_rest->first] = top_elements.find(*max_rest);
                x_sum += (long long)max_rest->first * max_rest->second;
                rest_elements.erase(max_rest);
            }
        };

        for (int i = 0; i < k; ++i) {
            int value = nums[i];
            freq[value]++;
            if (positions.count(value)) {
                remove_element(value);
            }
            insert_element(value);
        }

        answer.push_back(x_sum);

        for (int i = k; i < n; ++i) {
            int out_value = nums[i - k];
            int in_value = nums[i];

            remove_element(out_value);
            freq[out_value]--;
            if (freq[out_value] > 0) {
                insert_element(out_value);
            } else {
                freq.erase(out_value);
            }
            freq[in_value]++;
            if (positions.count(in_value)) {
                remove_element(in_value);
            }
            insert_element(in_value);

            answer.push_back(x_sum);
        }

        return answer;
    }
};
",1420578260
Ayush Singh Bhadauria,AyushSinghBhadauria,73,3610,cpp,"class Solution {
public:
    struct Compare {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.first != b.first)
            return a.first > b.first; // Higher frequency first
        else
            return a.second > b.second; // Higher value first
    }
};
    vector<int> findXSum(vector<int>& nums, int k, int x) {
      int n = nums.size();
    vector<int> answer;

    unordered_map<int, int> freq; 
    multiset<pair<int, int>, Compare> ms; 
    unordered_map<int, multiset<pair<int, int>, Compare>::iterator> iterators;

    for (int i = 0; i < k; ++i) {
        int e = nums[i];
        if (freq.count(e)) {
            ms.erase(iterators[e]);
        }
        freq[e]++;
        auto it = ms.insert({freq[e], e});
        iterators[e] = it;
    }

    int cnt = 0;
    int sum = 0;
    for (auto it = ms.begin(); it != ms.end() && cnt < x; ++it) {
        sum += it->first * it->second;
        cnt++;
    }
    answer.push_back(sum);

    for (int i = 1; i <= n - k; ++i) {
        int out_elem = nums[i - 1]; 
        int in_elem = nums[i + k - 1]; 

        ms.erase(iterators[out_elem]);
        freq[out_elem]--;
        if (freq[out_elem] > 0) {
            auto it = ms.insert({freq[out_elem], out_elem});
            iterators[out_elem] = it;
        } else {
            freq.erase(out_elem);
            iterators.erase(out_elem);
        }

        if (freq.count(in_elem)) {
            ms.erase(iterators[in_elem]);
        }
        freq[in_elem]++;
        auto it = ms.insert({freq[in_elem], in_elem});
        iterators[in_elem] = it;

        cnt = 0;
        sum = 0;
        for (auto it = ms.begin(); it != ms.end() && cnt < x; ++it) {
            sum += it->first * it->second;
            cnt++;
        }
        answer.push_back(sum);
    }

    return answer;  
    }
};",1420521330
Rishikesh Anabathula,CutSandstone,74,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> sub;
    int[] dfs(TreeNode root){
        if(root == null) return new int[]{0,-1};
        int[] left = dfs(root.left), right = dfs(root.right);
        if(left == null || right == null) return null;
        if(left[1] == right[1] && left[0] == right[0]){
            sub.add(left[0]*2+1);
            return new int[]{left[0]*2+1,left[1]+1};
        }
        return null;
    }
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        sub = new ArrayList<>();
        dfs(root);
        Collections.sort(sub);
        return sub.size()<k ? -1:sub.get(sub.size()-k);
    }
}",1420566105
Rishikesh Anabathula,CutSandstone,74,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n][n*2+1][3];
        int mod = 1_000_000_007;
        String ord = ""FWE"";
        for(int i = 0; i<3; i++){
            int ind = ord.indexOf(s.charAt(0));
            int d = (i-ind+3)%3;
            if(d == 2) d = -1;
            dp[0][n+d][i] = 1;
        }
        for(int i = 1; i<n; i++){
            int ind = ord.indexOf(s.charAt(i));
            for(int j = 0; j<=n*2; j++){
                for(int k = 0; k<3; k++){
                    int d = (k-ind+3)%3;
                    if(d == 2) d = -1;
                    if(j-d >= 0 && j-d <= n*2)
                        dp[i][j][k] = (dp[i-1][j-d][(k+1)%3]+dp[i-1][j-d][(k+2)%3])%mod;
                }
            }
        }
        int ans = 0;
        for(int i = n+1; i<=n*2; i++)
            for(int j = 0; j<3; j++)
                ans = (ans+dp[n-1][i][j])%mod;
        return ans;
    }
}",1420578324
Rishikesh Anabathula,CutSandstone,74,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] ans = new long[n-k+1];
        TreeMap<Integer,Integer> low = new TreeMap<>();
        TreeMap<Integer,Integer> high = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fLow = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fHigh = new TreeMap<>();
        long sum = 0;
        for(int i = 0; i<n; i++){
            int c = low.getOrDefault(nums[i],0);
            if(c == 0){
                c = high.getOrDefault(nums[i],0);
                high.put(nums[i],c+1);
                sum+=nums[i];
                if(c != 0){
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i]);
                    if(get.size() == 0) fHigh.remove(c);
                }
                TreeSet<Integer> get = fHigh.get(c+1);
                if(get == null) fHigh.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }else{
                low.put(nums[i],c+1);
                TreeSet<Integer> get = fLow.get(c);
                get.remove(nums[i]);
                if(get.size() == 0) fLow.remove(c);
                get = fLow.get(c+1);
                if(get == null) fLow.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }
            if(i >= k){
                c = low.getOrDefault(nums[i-k],0);
                if(c != 0){
                    TreeSet<Integer> get = fLow.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fLow.remove(c);
                    if(c == 1) low.remove(nums[i-k]);
                    else{
                        low.put(nums[i-k],c-1);
                        get = fLow.get(c-1);
                        if(get == null) fLow.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }else{
                    c = high.get(nums[i-k]);
                    sum-=nums[i-k];
                    if(c == 1) high.remove(nums[i-k]);
                    else high.put(nums[i-k],c-1);
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fHigh.remove(c);
                    if(c != 1){
                        get = fHigh.get(c-1);
                        if(get == null) fHigh.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }
            }
            while(high.size() >= x){
                var e = fHigh.firstEntry();
                int r = e.getValue().first();
                sum-=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fHigh.remove(e.getKey());
                high.remove(r);
                low.put(r,e.getKey());
                TreeSet<Integer> get = fLow.get(e.getKey());
                if(get == null) fLow.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(high.size() < x && low.size() > 0){
                var e = fLow.lastEntry();
                int r = e.getValue().last();
                sum+=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fLow.remove(e.getKey());
                low.remove(r);
                high.put(r,e.getKey());
                TreeSet<Integer> get = fHigh.get(e.getKey());
                if(get == null) fHigh.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(i >= k-1) ans[i-k+1] = sum;
        }
        return ans;
    }
}",1420558281
Rishikesh Anabathula,CutSandstone,74,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n-k+1];
        TreeMap<Integer,Integer> low = new TreeMap<>();
        TreeMap<Integer,Integer> high = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fLow = new TreeMap<>();
        TreeMap<Integer,TreeSet<Integer>> fHigh = new TreeMap<>();
        long sum = 0;
        for(int i = 0; i<n; i++){
            int c = low.getOrDefault(nums[i],0);
            if(c == 0){
                c = high.getOrDefault(nums[i],0);
                high.put(nums[i],c+1);
                sum+=nums[i];
                if(c != 0){
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i]);
                    if(get.size() == 0) fHigh.remove(c);
                }
                TreeSet<Integer> get = fHigh.get(c+1);
                if(get == null) fHigh.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }else{
                low.put(nums[i],c+1);
                TreeSet<Integer> get = fLow.get(c);
                get.remove(nums[i]);
                if(get.size() == 0) fLow.remove(c);
                get = fLow.get(c+1);
                if(get == null) fLow.put(c+1,get = new TreeSet<>());
                get.add(nums[i]);
            }
            if(i >= k){
                c = low.getOrDefault(nums[i-k],0);
                if(c != 0){
                    TreeSet<Integer> get = fLow.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fLow.remove(c);
                    if(c == 1) low.remove(nums[i-k]);
                    else{
                        low.put(nums[i-k],c-1);
                        get = fLow.get(c-1);
                        if(get == null) fLow.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }else{
                    c = high.get(nums[i-k]);
                    sum-=nums[i-k];
                    if(c == 1) high.remove(nums[i-k]);
                    else high.put(nums[i-k],c-1);
                    TreeSet<Integer> get = fHigh.get(c);
                    get.remove(nums[i-k]);
                    if(get.size() == 0) fHigh.remove(c);
                    if(c != 1){
                        get = fHigh.get(c-1);
                        if(get == null) fHigh.put(c-1,get = new TreeSet<>());
                        get.add(nums[i-k]);
                    }
                }
            }
            while(high.size() >= x){
                var e = fHigh.firstEntry();
                int r = e.getValue().first();
                sum-=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fHigh.remove(e.getKey());
                high.remove(r);
                low.put(r,e.getKey());
                TreeSet<Integer> get = fLow.get(e.getKey());
                if(get == null) fLow.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(high.size() < x && low.size() > 0){
                var e = fLow.lastEntry();
                int r = e.getValue().last();
                sum+=((long)r)*e.getKey();
                e.getValue().remove(r);
                if(e.getValue().size() == 0)
                    fLow.remove(e.getKey());
                low.remove(r);
                high.put(r,e.getKey());
                TreeSet<Integer> get = fHigh.get(e.getKey());
                if(get == null) fHigh.put(e.getKey(), get = new TreeSet<>());
                get.add(r);
            }
            if(i >= k-1) ans[i-k+1] = (int)sum;
        }
        return ans;
    }
}",1420559123
furuyarei,furuyarei,76,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<bool, int> dfs(TreeNode* u) {
        if (!u) {
            return {true, 0};
        }
        auto [tl, sl] = dfs(u->left);
        auto [tr, sr] = dfs(u->right);
        if (!tl || !tr) {
            return {false, 0};
        }
        if (sl == sr) {
            sz.push_back((1 << (sl + 1)) - 1);
            return {true, sl + 1};
        }
        return {false, 0};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sz.begin(), sz.end(), greater<int>());
        if (sz.size() >= k) {
            return sz[k - 1];
        }
        else {
            return -1;
        }
    }

private:
    vector<int> sz;
};",1420520010
furuyarei,furuyarei,76,3588,cpp,"int f[1010][2020][3];
int mod = 1000000007;
int shift = 1002;

class Solution {
public:
    int countWinningSequences(string s) {
        for (char& c: s) {
            if (c == 'F') {
                c = '0';
            }
            else if (c == 'W') {
                c = '1';
            }
            else {
                c = '2';
            }
        }
        
        auto check = [](char x, char y) -> int {
            if (x == y) {
                return 0;
            }
            if (x == '0') {
                return y == '2' ? 1 : -1;
            }
            if (x == '1') {
                return y == '0' ? 1 : -1;
            }
            return y == '1' ? 1 : -1;
        };
        
        int n = s.size();
        memset(f, 0, sizeof(f));
        
        f[1][check('0', s[0]) + shift][0] = 1;
        f[1][check('1', s[0]) + shift][1] = 1;
        f[1][check('2', s[0]) + shift][2] = 1;
        
        for (int i = 2; i <= n; ++i) {
            for (int j = -i; j <= i; ++j) {
                for (int k = 0; k < 3; ++k) {
                    int c = check(k + '0', s[i - 1]);
                    for (int kp = 0; kp < 3; ++kp) {
                        if (k == kp) {
                            continue;
                        }
                        if (j - c >= -(i - 1) && j - c <= i - 1) {
                            f[i][j + shift][k] = (f[i][j + shift][k] + f[i - 1][j - c + shift][kp]) % mod;
                        }
                    }
                }
            }
        }
        
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans = (ans + f[n][i + shift][0]) % mod;
            ans = (ans + f[n][i + shift][1]) % mod;
            ans = (ans + f[n][i + shift][2]) % mod;
        }
        return ans;
    }
};",1420545517
furuyarei,furuyarei,76,3592,cpp,"class DS {
public:
    DS(int t): top(t) {}
    
    void insert(int x) {
        if (freq.count(x)) {
            dd(x, freq[x]);
        }
        ++freq[x];
        ii(x, freq[x]);
        // cout << ""sum insert = "" << x << "" "" << get() << endl;
    }
    
    void remove(int x) {
        dd(x, freq[x]);
        --freq[x];
        if (freq[x]) {
            ii(x, freq[x]);
        }
        else {
            freq.erase(x);
        }
        // cout << ""sum remove = "" << x << "" "" << get() << endl;
    }
    
    long long get() {
        return sum;
    }

private:
    void ii(int x, int occ) {
        v.insert({occ, x});
        if (v.size() < top) {
            sum += (long long)x * occ;
        }
        else if (v.size() == top) {
            it = prev(v.end());
            sum += (long long)x * occ;
        }
        else if (v.size() > top) {
            if (better({occ, x}, *it)) {
                sum += (long long)x * occ;
                sum -= (long long)it->first * it->second;
                it = prev(it);
            }
        }
    }
    
    void dd(int x, int occ) {
        if (v.size() > top) {
            if (better({occ, x}, *it) || pair{occ, x} == *it) {
                it = next(it);
                sum -= (long long)x * occ;
                sum += (long long)it->first * it->second;
            }
        }
        else {
            sum -= (long long)x * occ;
        }
        v.erase({occ, x});
    }
    
    bool better(const pair<int, int>& u, const pair<int, int>& v) {
        return u > v;
    }

private:
    set<pair<int, int>, greater<pair<int, int>>> v;
    int top;
    unordered_map<int, int> freq;
    long long sum = 0;
    
    set<pair<int, int>, greater<pair<int, int>>>::iterator it;
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> ans;
        
        DS ds(x);
        for (int i = 0; i + 1 < k; ++i) {
            ds.insert(nums[i]);
        }
        
        for (int i = k - 1; i < n; ++i) {
            ds.insert(nums[i]);
            if (i >= k) {
                ds.remove(nums[i - k]);
            }
            ans.push_back(ds.get());
        }
        return ans;
    }
};",1420584587
furuyarei,furuyarei,76,3610,cpp,"class DS {
public:
    DS(int t): top(t) {}
    
    void insert(int x) {
        if (freq.count(x)) {
            dd(x, freq[x]);
        }
        ++freq[x];
        ii(x, freq[x]);
        // cout << ""sum insert = "" << x << "" "" << get() << endl;
    }
    
    void remove(int x) {
        dd(x, freq[x]);
        --freq[x];
        if (freq[x]) {
            ii(x, freq[x]);
        }
        else {
            freq.erase(x);
        }
        // cout << ""sum remove = "" << x << "" "" << get() << endl;
    }
    
    long long get() {
        return sum;
    }

private:
    void ii(int x, int occ) {
        v.insert({occ, x});
        if (v.size() < top) {
            sum += (long long)x * occ;
        }
        else if (v.size() == top) {
            it = prev(v.end());
            sum += (long long)x * occ;
        }
        else if (v.size() > top) {
            if (better({occ, x}, *it)) {
                sum += (long long)x * occ;
                sum -= (long long)it->first * it->second;
                it = prev(it);
            }
        }
    }
    
    void dd(int x, int occ) {
        if (v.size() > top) {
            if (better({occ, x}, *it) || pair{occ, x} == *it) {
                it = next(it);
                sum -= (long long)x * occ;
                sum += (long long)it->first * it->second;
            }
        }
        else {
            sum -= (long long)x * occ;
        }
        v.erase({occ, x});
    }
    
    bool better(const pair<int, int>& u, const pair<int, int>& v) {
        return u > v;
    }

private:
    set<pair<int, int>, greater<pair<int, int>>> v;
    int top;
    unordered_map<int, int> freq;
    long long sum = 0;
    
    set<pair<int, int>, greater<pair<int, int>>>::iterator it;
};

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        
        DS ds(x);
        for (int i = 0; i + 1 < k; ++i) {
            ds.insert(nums[i]);
        }
        
        for (int i = k - 1; i < n; ++i) {
            ds.insert(nums[i]);
            if (i >= k) {
                ds.remove(nums[i - k]);
            }
            ans.push_back(ds.get());
        }
        return ans;
    }
};",1420585110
Chuan-Chih Chou,chuan-chih,79,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        l = []
        def recur(node):
            if not node:
                return (True, 0)
            lperf, lsize = recur(node.left)
            rperf, rsize = recur(node.right)
            if lperf and rperf and lsize == rsize:
                size = 1 + lsize * 2
                l.append(size)
                return (True, size)
            else:
                return (False, -1)
        recur(root)
        l.sort(reverse=True)
        k -= 1
        if k < len(l):
            return l[k]
        return -1",1420526468
Chuan-Chih Chou,chuan-chih,79,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10 ** 9 + 7
        options = 'FEW'
        curr = {o: Counter() for o in options}
        if s[0] == 'F':
            curr['F'][0] += 1
            curr['E'][-1] += 1 
            curr['W'][1] += 1
        elif s[0] == 'E':
            curr['E'][0] += 1
            curr['W'][-1] += 1 
            curr['F'][1] += 1
        else:
            curr['W'][0] += 1
            curr['F'][-1] += 1 
            curr['E'][1] += 1
        for c in s[1:]:
            new = {o: Counter() for o in options}
            if c == 'F':
                new['F'] = curr['E'] + curr['W']
                for k, v in (curr['F'] + curr['W']).items():
                    new['E'][k - 1] = v % mod
                for k, v in (curr['F'] + curr['E']).items():
                    new['W'][k + 1] = v % mod
            elif c == 'E':
                new['E'] = curr['F'] + curr['W']
                for k, v in (curr['F'] + curr['E']).items():
                    new['W'][k - 1] = v % mod
                for k, v in (curr['E'] + curr['W']).items():
                    new['F'][k + 1] = v % mod
            else:
                new['W'] = curr['F'] + curr['E']
                for k, v in (curr['E'] + curr['W']).items():
                    new['F'][k - 1] = v % mod
                for k, v in (curr['F'] + curr['W']).items():
                    new['E'][k + 1] = v % mod
            curr = new
        return sum(v for c in curr.values() for k, v in c.items() if k > 0) % mod
            ",1420555345
Chuan-Chih Chou,chuan-chih,79,3592,python3,"from sortedcontainers import SortedSet

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        c = Counter(nums[:k])
        sl = SortedSet((v, k) for k, v in c.items())
        curr = sum(v * k for v, k in sl[-x:])
        ans.append(curr)
        
        def replace(old, new):
            nonlocal curr
            length = len(sl)
            if new[0]:
                index = sl.bisect_right(new)
                if index > length - x:
                    curr += new[0] * new[1]
                    if x <= length:
                        t = sl[-x]
                        curr -= t[0] * t[1]
                sl.add(new)
                length += 1
            if old[0]:
                index = sl.index(old)
                if index >= length - x:
                    curr -= old[0] * old[1]
                    if x + 1 <= length:
                        t = sl[-x-1]
                        curr += t[0] * t[1]
                sl.remove(old)
        
        for j in range(k, len(nums)):
            old = (c[nums[j]], nums[j])
            c[nums[j]] += 1
            new = (c[nums[j]], nums[j])
            replace(old, new)
            i = j - k
            old = (c[nums[i]], nums[i])
            c[nums[i]] -= 1
            new = (c[nums[i]], nums[i])
            replace(old, new)
            ans.append(curr)
        return ans",1420585544
Chuan-Chih Chou,chuan-chih,79,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        c = Counter(nums[:k])
        l = sorted(((v, k) for k, v in c.items()), reverse=True)
        ans.append(sum(v * k for v, k in l[:x]))
        for j in range(k, len(nums)):
            c[nums[j]] += 1
            c[nums[j - k]] -= 1
            l = sorted(((v, k) for k, v in c.items()), reverse=True)
            ans.append(sum(v * k for v, k in l[:x]))
        return ans",1420521573
Yatin Kwatra,yatin_kwatra,80,3509,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

vii v;
class Solution {
public:

	ar<int, 2> ghumo(TreeNode *root) {
		if (!root) return {true, 0};
		auto L = ghumo(root->left);
		auto R = ghumo(root->right);

		if (!L[0] or !R[0] or L[1] != R[1]) return {false, 0};
		v.pb({L[1] + R[1] + 1});
		return {true, L[1] + R[1] + 1};
	}

	int kthLargestPerfectSubtree(TreeNode* root, int k) {
		v.clear();
		ghumo(root);
		sort(all(v), greater<int>());
		return (sz(v) >= k ? v[k - 1] : -1);
	}
};



















",1420524905
Yatin Kwatra,yatin_kwatra,80,3588,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

/*

	F > E
	W > F
	E > W

*/

ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

// F W E {0,1,2}

char moves[] = {'F', 'W', 'E'};

int gameScore(char a, char b) {
	if (a == b) return 0;
	if (a == 'F') {
		if (b == 'E') return 1;
		return -1;
	}
	if (a == 'W') {
		if (b == 'F') return 1;
		return -1;
	}
	if (b == 'W') return 1;
	return -1;
}

ll dp[3][1002][2002];
int n;

ll gino(int lastMove, int pos, int k, string &s) {
	if (pos == n) {
		return (k > 0);
	}
	ll &ans = dp[lastMove][pos][n + k];
	if (ans != -1) return ans;
	ans = 0;

	fo(i, 0, 2) {
		if (i == lastMove) continue;
		ans = addmod(ans, gino(i, pos + 1, k + gameScore(moves[i], s[pos]), s));
	}
	return ans;
}

class Solution {
public:
	int countWinningSequences(string s) {
		n = sz(s);
		fo(i, 0, n) {
			fo(j, 0, 2 * n) {
				fo(k, 0, 2) dp[k][i][j] = -1;
			}
		}

		ll ans = 0;
		fo(i, 0, 2) ans = addmod(ans, gino(i, 1, gameScore(moves[i], s[0]), s));
	    return ans;
    }
};



















",1420540045
Yatin Kwatra,yatin_kwatra,80,3592,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

int n;
class Solution {
public:
	vector<long long> findXSum(vector<int>& nums, int k, int x) {
		n = sz(nums);

		set<ar<int, 2>> xFrequent, potentialFrequent;

		uomii f;
		fo(i, 0, k - 1) {
			f[nums[i]]++;
		}
		vector<ar<int, 2>> v;
		for (auto &i : f) v.pb({i.ss, i.ff});
		sort(all(v));
		reverse(all(v));

		ll sum = 0;
		f.clear();

		uomii others;
        int upto = min(sz(v), k);
		fo(i, 0, upto - 1) {
			if (i < x) {
				f[v[i][1]] = v[i][0];
				xFrequent.insert(v[i]);
				sum += v[i][0] * 1LL * v[i][1];
			}
			else {
				potentialFrequent.insert(v[i]);
				others[v[i][1]] = v[i][0];
			}
		}

		vector<ll> ans;
		ans.pb(sum);

		fo(idx, k, n - 1) {
			int rm = nums[idx - k];
			int ad = nums[idx];

			if (f.count(ad)) {
				xFrequent.erase({f[ad], ad});
				f[ad]++;
				xFrequent.insert({f[ad], ad});
				sum += 1LL * ad;
			}
			else {
				if (others.count(ad)) potentialFrequent.erase({others[ad], ad});
				others[ad]++;
				potentialFrequent.insert({others[ad], ad});
			}

			if (f.count(rm)) {
				xFrequent.erase({f[rm], rm});
				f[rm]--;
				sum -= 1LL * rm;
				if (f[rm] == 0) {
					f.erase(rm);
				}
				else {
					xFrequent.insert({f[rm], rm});
				}
			}
			else {
				if (others.count(rm)) potentialFrequent.erase({others[rm], rm});
				others[rm]--;
				if (others[rm] == 0) others.erase(rm);
				else potentialFrequent.insert({others[rm], rm});
			}


			// rebalancing

			while (sz(xFrequent) < x and sz(potentialFrequent)) {
				auto bg = *(potentialFrequent.rbegin());
				sum += bg[0] * 1LL * bg[1];

				xFrequent.insert(bg);
				potentialFrequent.erase(bg);

				others.erase(bg[1]);
				f[bg[1]] = bg[0];
			}

			auto isBetter = [&](ar<int, 2> a, ar<int, 2 > b) -> bool {
				if (a[0] > b[0]) return true;
				if (a[0] < b[0]) return false;
				return a[1] > b[1];
			};

			while (sz(xFrequent) and sz(potentialFrequent) and
			        isBetter(*potentialFrequent.rbegin(), *xFrequent.begin())) {

				auto sm = *xFrequent.begin();

				xFrequent.erase(sm);
				potentialFrequent.insert(sm);

				others[sm[1]] = sm[0];
				f.erase(sm[1]);

				sum -= sm[0] * 1LL * sm[1];


				auto bg = *potentialFrequent.rbegin();

				potentialFrequent.erase(bg);
				xFrequent.insert(bg);

				f[bg[1]] = bg[0];
				others.erase(bg[1]);

				sum += bg[0] * 1LL * bg[1];
			}

			ans.pb(sum);
		}
		return ans;
	}
};",1420585665
Yatin Kwatra,yatin_kwatra,80,3610,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	vector<int> findXSum(vector<int>& nums, int k, int x) {

		vii ans;
		int n = sz(nums);

		fo(idx, k - 1, n - 1) {
			int a = idx - k + 1;
			int b = idx;
			uomii f;
			fo(i, a, b) f[nums[i]]++;

			vector<ar<int, 2>> v;
			for (auto &i : f) {
				v.pb({i.ss, i.ff});
			}
			sort(all(v));
			reverse(all(v));


			int upto = min(sz(v), x);
			int sum = 0;
			fo(i, 0, upto - 1) {
				sum += v[i][0] * v[i][1];
			}
			ans.pb(sum);
		}
		return ans;
	}
};




















",1420521457
Abhishek Srivastava,Abhi_Srivastava,81,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sizes;
    vector<int> isPerfect(TreeNode* root) {
        vector<int> lft, rght;
        if (root -> left == NULL && root -> right == NULL) {
            sizes.push_back(1);
            return {1, 0, 1};
        }
        if (root -> left)
            lft = isPerfect(root -> left);
        if (root -> right)
            rght = isPerfect(root -> right);
        if (root -> left == NULL || root -> right == NULL)
            return {0, 0, 0};
        if (lft[0] && rght[0] && (lft[1] == rght[1])) {
            sizes.push_back(lft[2] + rght[2] + 1);
            return {1, lft[1] + 1, lft[2] + rght[2] + 1};
        }
        else
            return {0, 0, 0};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        isPerfect(root);
        if (sizes.size() < k)
            return -1;
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k - 1];
    }
};",1420563102
Abhishek Srivastava,Abhi_Srivastava,81,3588,cpp,"const int mod = 1e9 + 7;
string moves = ""FWE"";

class Solution {
public:
    int calc(int ind, string& s, int lastMove, int bobWon, vector<vector<vector<long long>>>& dp) {
        if (ind == s.size())
            return (bobWon > s.size());
        if (dp[lastMove][ind][bobWon] != -1)   
            return dp[lastMove][ind][bobWon];
        long long res = 0;
        for (int i = 0; i < 3; i++)
            if (lastMove != i) {
                if ((moves[i] == 'F' && s[ind] == 'E') || (moves[i] == 'E' && s[ind] == 'W') || (moves[i] == 'W' && s[ind] == 'F'))
                    (res += calc(ind + 1, s, i, bobWon + 2, dp)) %= mod;
                else if ((moves[i] == 'F' && s[ind] == 'W') || (moves[i] == 'E' && s[ind] == 'F') || (moves[i] == 'W' && s[ind] == 'E'))
                    (res += calc(ind + 1, s, i, bobWon, dp)) %= mod;
                else
                    (res += calc(ind + 1, s, i, bobWon + 1, dp)) %= mod;
            }
        return dp[lastMove][ind][bobWon] = res;
    }
    int countWinningSequences(string s) {
        int n = s.size();
        vector<vector<vector<long long>>> dp(4, vector<vector<long long>>(n, vector<long long>(n * 2 + 1, -1)));
        return calc(0, s, 3, 0, dp);
    }
};",1420579705
Abhishek Srivastava,Abhi_Srivastava,81,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp> 
using namespace __gnu_pbds; 
typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

class Solution {
public:
    void removeFromSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (ost.order_of_key(pr) + x >= sz) {
            sum -= 1ll * pr.first * pr.second;
            if (sz > x) {              
                pair<int, int> tmp = *ost.find_by_order(sz - x - 1); 
                sum += 1ll * tmp.first * tmp.second;
            }
        }
        ost.erase(ost.find_by_order(ost.order_of_key(pr)));
    }
    void insertIntoSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (sz >= x) {
            pair<int, int> tmp = *ost.find_by_order(sz - x);
            if (tmp < pr)
                sum += 1ll * pr.first * pr.second - 1ll * tmp.first * tmp.second;
        }
        else
            sum += 1ll * pr.first * pr.second;
        ost.insert(pr);
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> res;
        unordered_map<int, int> freq;
        long long sum = 0;
        ordered_set ost;
        for (int i = 0; i < nums.size(); i++) {
            if (freq.find(nums[i]) != freq.end()) 
                removeFromSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            freq[nums[i]]++;
            insertIntoSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            if (i >= k) {
                removeFromSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                freq[nums[i - k]]--;
                if (freq[nums[i - k]])
                    insertIntoSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                else
                    freq.erase(nums[i - k]);
            }
            if (i >= k - 1)
                res.push_back(sum);
        }
        return res;
    }
};",1420552019
Abhishek Srivastava,Abhi_Srivastava,81,3610,cpp,"#include <ext/pb_ds/assoc_container.hpp> 
using namespace __gnu_pbds; 
typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

class Solution {
public:
    void removeFromSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (ost.order_of_key(pr) + x >= sz) {
            sum -= 1ll * pr.first * pr.second;
            if (sz > x) {              
                pair<int, int> tmp = *ost.find_by_order(sz - x - 1); 
                sum += 1ll * tmp.first * tmp.second;
            }
        }
        ost.erase(ost.find_by_order(ost.order_of_key(pr)));
    }
    void insertIntoSet(ordered_set& ost, long long& sum, pair<int, int> pr, int x) {
        long long sz = ost.size();
        if (sz >= x) {
            pair<int, int> tmp = *ost.find_by_order(sz - x);
            if (tmp < pr)
                sum += 1ll * pr.first * pr.second - 1ll * tmp.first * tmp.second;
        }
        else
            sum += 1ll * pr.first * pr.second;
        ost.insert(pr);
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        unordered_map<int, int> freq;
        long long sum = 0;
        ordered_set ost;
        for (int i = 0; i < nums.size(); i++) {
            if (freq.find(nums[i]) != freq.end()) 
                removeFromSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            freq[nums[i]]++;
            insertIntoSet(ost, sum, {freq[nums[i]], nums[i]}, x);
            if (i >= k) {
                removeFromSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                freq[nums[i - k]]--;
                if (freq[nums[i - k]])
                    insertIntoSet(ost, sum, {freq[nums[i - k]], nums[i - k]}, x);
                else
                    freq.erase(nums[i - k]);
            }
            if (i >= k - 1)
                res.push_back(sum);
        }
        return res;
    }
};",1420552608
raincoat911,raincoat911,85,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> res;
        dfs(root, res);
        if (res.size() < k) return -1;
        sort(res.begin(), res.end(), greater<>());
        return res[k - 1];
    }
    
private:
    pair<bool, int> dfs(TreeNode* nd, vector<int>& res) {
        if (!nd) return {true, 0};
        auto l = dfs(nd->left, res);
        auto r = dfs(nd->right, res);
        if (l.first && r.first && l.second == r.second) {
            res.push_back(l.second * 2 + 1);
            return {true, res.back()};
        }
        return {false, 0};
    }
};",1420522628
raincoat911,raincoat911,85,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int l = s.size();
        vector<vector<array<long, 3>>> dp(l + 1, vector<array<long, 3>>(l * 2 + 1));
        dp[0][l][0] = dp[0][l][1] = dp[0][l][2] = 1;
        int M = 1e9 + 7;
        for (int i = 0; i < l; i++) {
            for (int k = -i; k <= i; k++) {
                if (i == 1) {
                    dp[i][k + l][0] >>= 1;
                    dp[i][k + l][1] >>= 1;
                    dp[i][k + l][2] >>= 1;
                }
                else {
                    dp[i][k + l][0] %= M;
                    dp[i][k + l][1] %= M;
                    dp[i][k + l][2] %= M;
                }
                dp[i + 1][k + l + (s[i] == 'F' ? 1 : s[i] == 'W' ? 0 : -1)][1] += dp[i][k + l][0];
                dp[i + 1][k + l + (s[i] == 'F' ? -1 : s[i] == 'W' ? 1 : 0)][2] += dp[i][k + l][0];
                dp[i + 1][k + l + (s[i] == 'F' ? 0 : s[i] == 'W' ? -1 : 1)][0] += dp[i][k + l][1];
                dp[i + 1][k + l + (s[i] == 'F' ? -1 : s[i] == 'W' ? 1 : 0)][2] += dp[i][k + l][1];
                dp[i + 1][k + l + (s[i] == 'F' ? 0 : s[i] == 'W' ? -1 : 1)][0] += dp[i][k + l][2];
                dp[i + 1][k + l + (s[i] == 'F' ? 1 : s[i] == 'W' ? 0 : -1)][1] += dp[i][k + l][2];
            }
        }
        long res = 0;
        for (int k = 1; k <= l; k++) {
            if (s.size() == 1) {
                dp.back()[k + l][0] >>= 1;
                dp.back()[k + l][1] >>= 1;
                dp.back()[k + l][2] >>= 1;
            }
            res += dp.back()[k + l][0] + dp.back()[k + l][1] + dp.back()[k + l][2];
            res %= M;
        }
        // cout << endl;
        return res;
    }
};",1420549144
raincoat911,raincoat911,85,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pair<int, int>, greater<>> lo;
        set<pair<int, int>> hi;
        unordered_map<int, int> m;
        long sh = 0;
        vector<long long> res;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= k) {
                int n = nums[i - k];
                int f = m[n]--;
                pair<int, int> p = {f - 1, n};
                
                auto it = hi.find({f, n});
                if (it == hi.end()) {
                    it = lo.find({f, n});
                    lo.erase(it);
                    if (f > 1) lo.insert(p);
                }
                else {
                    sh -= (long)it->first * it->second; 
                    hi.erase(it);
                    if (lo.empty()) {
                        if (f > 1) {
                            sh += (long)p.first * p.second;
                            hi.insert(p);
                        }
                    }
                    else {
                        it = lo.begin();
                        if (*it > p) {
                            sh += (long)it->first * it->second; 
                            hi.insert(*it);
                            lo.erase(it);
                            if (f > 1) lo.insert(p);
                        }
                        else {
                            if (f > 1) {
                                sh += (long)p.first * p.second;
                                hi.insert(p);
                            }
                        }
                    }
                    
                }
            }
            int n = nums[i];
            int f = m[n]++;
            pair<int, int> p = {f + 1, n};
            if (f > 0) {
                auto it = hi.find({f, n});
                if (it == hi.end()) {
                    it = lo.find({f, n});
                    lo.erase(it);
                    auto it = hi.begin();
                    if (*it < p) {
                        sh += (long)p.first * p.second;
                        sh -= (long)it->first * it->second;
                        hi.insert(p);
                        lo.insert(*it);
                        hi.erase(it);
                    }
                    else {
                        lo.insert(p);
                    }
                }
                else {
                    sh += (long)p.first * p.second;
                    sh -= (long)it->first * it->second;
                    hi.erase(it);
                    hi.insert(p);
                }
            }
            else {
                if (hi.size() < x) {
                    sh += (long)p.first * p.second;
                    hi.insert(p);
                }
                else {
                    auto it = hi.begin();
                    if (*it < p) {
                        sh += (long)p.first * p.second;
                        sh -= (long)it->first * it->second;
                        hi.insert(p);
                        lo.insert(*it);
                        hi.erase(it);
                    }
                    else {
                        lo.insert(p);
                    }
                }
            }
            if (i >= k - 1) res.push_back(sh);
        }
        // cout << sh << endl;
        return res;
    }
};",1420574684
raincoat911,raincoat911,85,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        for (int i = 0; i <= nums.size() - k; i++) {
            unordered_map<int, int> m;
            for (int j = i; j < i + k; j++) {
                m[nums[j]]++;
            }
            vector<array<int, 2>> arr;
            for (auto& p : m) {
                arr.push_back({p.second, p.first});
            }
            sort(arr.begin(), arr.end(), greater<>());
            arr.resize(x);
            int n = 0;
            for (auto& p : arr) {
                n += p[0] * p[1];
            }
            res.push_back(n);
        }
        return res;
    }
};",1420520013
ocavue,ocavue,87,3509,python3,"from typing import List, Optional


 
def merge_sort(arr1: List[int], arr2: List[int]) -> List[int]:
    result = []
    i = j = 0

    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            result.append(arr1[i])
            i += 1
        else:
            result.append(arr2[j])
            j += 1

    while i < len(arr1):
        result.append(arr1[i])
        i += 1

    while j < len(arr2):
        result.append(arr2[j])
        j += 1

    return result


def dfs(node: Optional[TreeNode]):
    if not node:
        return 0, []

    if not node.left and not node.right:
        return 1, [1]

    left_tree_size, left_subtree = dfs(node.left)
    right_tree_size, right_subtree = dfs(node.right)

    result = merge_sort(left_subtree, right_subtree)

    if left_tree_size == right_tree_size and left_tree_size != -1:
        tree_size = left_tree_size + right_tree_size + 1
        result.append(tree_size)
    else:
        tree_size = -1

    return tree_size, result


class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        result = dfs(root)[1]
        result.reverse()

        index = k - 1

        if index < len(result):
            return result[index]

        return -1
",1420532323
ocavue,ocavue,87,3588,python3,"from functools import cache


MOD = 10**9 + 7


@cache 
def get_score(my_char: str, other_char: str) -> int:
    if my_char == other_char:
        return 0

    if my_char == ""W"":
        return 1 if other_char == ""F"" else -1

    if my_char == ""F"":
        return 1 if other_char == ""E"" else -1

    return 1 if other_char == ""W"" else -1


class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)

        @cache
        def dfs(index: int, prev_char: str, prev_score: int) -> int:
            if index == n:
                return 1 if prev_score > 0 else 0

            other_char = s[index]

            result = 0

            for my_char in ""FWE"":
                score = get_score(my_char, other_char)

                if my_char != prev_char:
                    result += dfs(index + 1, my_char, prev_score + score)
            return result % MOD

        return dfs(0, """", 0) % MOD
",1420545408
ocavue,ocavue,87,3592,python3,"from typing import List
from collections import Counter
import sortedcontainers


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        n = len(nums)
        counter = Counter()
        top = sortedcontainers.SortedSet()
        btm = sortedcontainers.SortedSet()

        x_sum = 0

        def add_top_key(key):
            nonlocal x_sum
            top.add(key)
            x_sum += key[1] * key[0]

        def del_top_key(key):
            nonlocal x_sum
            top.remove(key)
            x_sum -= key[1] * key[0]

        def add_btm_key(key):
            btm.add(key)

        def del_btm_key(key):
            btm.remove(key)

        def move_key_from_top_to_btm(key):
            del_top_key(key)
            add_btm_key(key)

        def move_key_from_btm_to_top(key):
            del_btm_key(key)
            add_top_key(key)

        def maintain_balance():
            while len(top) < x and btm:
                key = btm.pop(-1)
                add_top_key(key)

            while top and btm and top[0] < btm[-1]:
                top_key = top[0]
                btm_key = btm[-1]
                move_key_from_top_to_btm(top_key)
                move_key_from_btm_to_top(btm_key)

        def add_key(key):
            btm.add(key)
            maintain_balance()

        def remove_key(key):
            if key in top:
                del_top_key(key)
            elif key in btm:
                del_btm_key(key)
            maintain_balance()

        def increase_num_count(num):
            prev_count = counter[num]
            prev_key = (prev_count, num)
            if prev_count > 0:
                remove_key(prev_key)

            new_count = prev_count + 1
            new_key = (new_count, num)
            add_key(new_key)

            counter[num] += 1

        def decrease_num_count(num):
            prev_count = counter[num]
            prev_key = (prev_count, num)
            remove_key(prev_key)

            new_count = prev_count - 1
            new_key = (new_count, num)
            if new_count > 0:
                add_key(new_key)

            counter[num] -= 1

        answer = []

        i = 0
        j = 0

        while j < n:
            increase_num_count(nums[j])
            j += 1

            while j - i > k:
                decrease_num_count(nums[i])
                i += 1

            if j - i == k:
                answer.append(x_sum)

        return answer

 ",1420580817
ocavue,ocavue,87,3610,python3,"from typing import List
from collections import Counter
import heapq


def calc_x_sum(nums: List[int], x: int) -> int:
    counter = Counter(nums)
    heap = [(-freq, -num) for num, freq in counter.items()]
    heapq.heapify(heap)

    result = 0

    while x > 0 and heap:
        freq, num = heapq.heappop(heap)
        result += freq * num
        x -= 1

    return result


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        n = len(nums)

        for i in range(n - k + 1):
            result.append(calc_x_sum(nums[i : i + k], x))

        return result

 ",1420521736
Ritesh baindara,RITESH_25,88,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> a;
    int dfs(TreeNode* root){
        if(!root)
        return 0;
        int ans = 1;
        int left = dfs(root->left);
        int right = dfs(root->right);
        if(left==right && left!=-1 && right!=-1)
        ans +=left+right;
        else
        ans = -1;
        if(ans!=-1)
        a.push_back(ans);
        // cout<<root->val<<"" ""<<ans<<endl;
        return ans;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
    dfs(root);
    sort(a.begin(),a.end(),greater<int>());
     if(a.size()>=k)    
     return a[k-1];
     else
     return -1;
    }
};",1420536057
Ritesh baindara,RITESH_25,88,3588,cpp,"class Solution {
public:
    long long dp[1001][2002][3];
    long long mod = 1e9+7;
    long long solve(int i,int j,int k,string &s){
        if(i==s.size()){
            if(j>1000)
            return 1;
            // else
            return 0;
        }
        if(dp[i][j][k]!=-1)
        return dp[i][j][k];
        long long ans = 0;
        if(k!=0 || i==0){
            char u = 'F';
            int t = 0;
            if(s[i]=='E')
            t=1;
            else if(s[i]=='W')
            t=-1;
            ans+=solve(i+1,j+t,0,s);
            ans%=mod;
        }

        if(k!=1 || i==0){
            char u = 'E';
            int t = 0;
            if(s[i]=='F')
            t=-1;
            else if(s[i]=='W')
            t=1;
            ans+=solve(i+1,j+t,1,s);
            ans%=mod;
        }

        if(k!=2 || i==0){
            char u = 'W';
            int t = 0;
            if(s[i]=='F')
            t=1;
            else if(s[i]=='E')
            t=-1;
            ans+=solve(i+1,j+t,2,s);
            ans%=mod;
        }

        return dp[i][j][k] = ans;



    }
    int countWinningSequences(string s) {
        memset(dp,-1,sizeof(dp));
        return solve(0,1000,0,s);
    }
};

// FWE",1420548946
Ritesh baindara,RITESH_25,88,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<vector<long long>> s;
        set<vector<long long>,greater<vector<long long>>> s2;
        map<long long,long long> m;
        for(long long i=0;i<k;i++){
            m[nums[i]]++;
        }
        for(auto b:m){
            s2.insert({b.second,b.first});
        }
        long long sum = 0;
        vector<long long> ans;
        while(s2.size() && s.size()<x){
            vector<long long> t = *s2.begin();
            s.insert(t);
            sum+=t[0]*t[1];
            s2.erase(s2.begin());
        }
        ans.push_back(sum);
        long long i=0,j=k;
        // for(auto b:s){
        //         cout<<j<<"" ""<<b[0]<<"" ""<<b[1]<<endl;
        // }
        while(j<nums.size()){
            // j++;
            vector<long long> temp = {m[nums[i]],nums[i]};
            if(s.find(temp)!=s.end()){
                s.erase(s.find(temp));
                sum-=temp[0]*nums[i];
            }
            else if(s2.find(temp)!=s2.end()){
               s2.erase(s2.find(temp));
            }

            m[nums[i]]--;
            if(m[nums[i]]){
                s2.insert({m[nums[i]],nums[i]});
            }
            i++;
            temp = {m[nums[j]],nums[j]};
             if(s.find(temp)!=s.end()){
                s.erase(s.find(temp));
                sum-=temp[0]*nums[j];
            }
            else if(s2.find(temp)!=s2.end()){
               s2.erase(s2.find(temp));
            }
            m[nums[j]]++;
            s2.insert({m[nums[j]],nums[j]});
            // for(auto b:s2){
            //     cout<<j<<"" ""<<b[0]<<"" ""<<b[1]<<endl;
            // }
           
            
            while(s2.size() && s.size()<x){
            vector<long long> t = *s2.begin();
            s.insert(t);
            sum+=t[0]*t[1];
            s2.erase(s2.begin());
            }
           
           
             
            while(s2.size() && s.size() && *s.begin()<*s2.begin()){
                vector<long long> t = (*s.begin());
                vector<long long> t2 = *s2.begin();
                sum-=t[0]*t[1];
                sum+=t2[0]*t2[1];
                s.erase(s.begin());
                s2.erase(s2.begin());
                s.insert(t2);
                s2.insert(t);
            } 
            j++;
            ans.push_back(sum);
        }
        return ans;
    }
};",1420581095
Ritesh baindara,RITESH_25,88,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector <int> cnt(51);
        int sum=0;
        for(int i=0;i<k;i++){
        //   if(nums[i]<=x){
           cnt[nums[i]]++;
        //   }
        }
        vector<int> ans;
        int p = 0;
        multiset<vector<int>,greater<vector<int>>> s;
        for(int i=0;i<51;i++){
        if(cnt[i])
        s.insert({cnt[i],i});
        }
         sum = 0;
        for(int i=0;i<x;i++){
        if(s.size()){
            vector<int> t = *s.begin();
            s.erase(s.begin());
            sum+=t[0]*t[1];
        }
        }
        ans.push_back(sum);
        int l = 0;
        int r = k;
        while(r<nums.size()){
          cnt[nums[l]]--;
          cnt[nums[r]]++;
          l++;
          r++;
          multiset<vector<int>,greater<vector<int>>> ss;
         for(int i=0;i<51;i++){
            if(cnt[i])
            ss.insert({cnt[i],i});

          }

        sum = 0;
        for(int i=0;i<x;i++){
        if(ss.size()){
            vector<int> tt = *ss.begin();
            ss.erase(ss.begin());
            sum+=tt[0]*tt[1];
        }
        }
        ans.push_back(sum);

        }
        return ans;
    
    }
};",1420527342
Wibo,Wibo,89,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> cands;
        auto dfs = [&](auto &self, TreeNode *u) -> pair<bool, int> {
            pair<bool, int> resl = {true, 0}, resr = {true, 0};
            if (u->left) resl = self(self, u->left);
            if (u->right) resr = self(self, u->right);
            pair<bool, int> ret = {(resl.first && resr.first && resl.second == resr.second), resl.second + resr.second + 1};
            if (ret.first) cands.push_back(ret.second);
            return ret;
        };
        dfs(dfs, root);

        sort(cands.rbegin(), cands.rend());
        return (cands.size() >= k ? cands[k-1] : -1);
    }
};",1420553936
Wibo,Wibo,89,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        const int mod = 1e9+7;
        const char moves[] = {'F', 'W', 'E'};
        auto winner = [&](char a, char b) -> int {
            if (a == b) return 0;
            if ((a == 'F' && b == 'E') || (a == 'W' && b == 'F') || (a == 'E' && b == 'W')) return 1;
            return -1;
        };

        // dp[i][alice's points - bob's points][bob's last move]
        int zero = n+3;
        vector<vector<vector<int>>> dp(2);
        dp[0].assign(zero+n+3, vector<int>(3, 0));
        for (int i=0; i<3; i++) {
            int w = winner(s[0], moves[i]);
            dp[0][zero + w][i]++;
        }
        
        for (int i=1; i<n; i++) {
            int bi = i&1, bo = !bi;
            dp[bi].assign(zero+n+3, vector<int>(3, 0));
            for (int j=0; j<3; j++) {
                for (int d=-n; d<=n; d++) {
                    for (int lj=0; lj<3; lj++) {
                        if (j == lj) continue;
                        int w = winner(s[i], moves[j]);
                        dp[bi][zero + d + w][j] += dp[bo][zero + d][lj];
                        if (dp[bi][zero + d + w][j] >= mod) dp[bi][zero + d + w][j] -= mod;
                    }
                }
            }
        }

        int ans = 0;
        for (int d=-n; d<0; d++) {
            for (int i=0; i<3; i++) {
                ans += dp[!(n&1)][zero + d][i];
                if (ans >= mod) ans -= mod;
            }
        }

        return ans;
    }
};",1420575413
Wibo,Wibo,89,3592,cpp,"#include <bits/extc++.h> /** keep-include */
using namespace __gnu_pbds;

template<class T>
using Tree = tree<T, null_type, less<T>, rb_tree_tag,
    tree_order_statistics_node_update>;

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();

        Tree<pair<int, long long>> os; // <freq, sum>, val = sum / freq
        long long sum = 0;
        map<int, int> freq;
        auto add = [&](int a) -> void {
            int fa = freq[a];
            if (fa == 0) return;
            pair<int, long long> pa = {-fa, -1LL * fa * a};
            os.insert(pa);
            if (os.order_of_key(pa) < x) {
                sum += -pa.second;
                if (os.size() >= x+1) sum -= -os.find_by_order(x)->second;
            }
        };
        auto rem = [&](int a) -> void {
            int fa = freq[a];
            pair<int, long long> pa = {-fa, -1LL * fa * a};
            if (os.order_of_key(pa) < x) {
                sum -= -pa.second;
                if (os.size() >= x+1) sum += -os.find_by_order(x)->second;
            }
            os.erase(pa);
        };

        auto print = [&]() -> void {
            for (auto &p : os) {
                int fa = p.first; long long sa = p.second;
                int a = sa / fa;
                cout << '(' << a << ',' << -fa << ',' << -sa << ')';
            }
            cout << "" --> "" << sum << '\n';
        };
        
        for (int i=0; i<k; i++) freq[nums[i]]++;
        for (auto &[a, _] : freq) add(a);
        // print();

        vector<long long> ans(n-k+1);
        ans[0] = sum;
        for (int l=1, r=k; r<n; l++, r++) {
            rem(nums[r]);
            if (nums[l-1] != nums[r]) rem(nums[l-1]);
            freq[nums[r]]++;
            freq[nums[l-1]]--;
            add(nums[r]);
            if (nums[l-1] != nums[r]) add(nums[l-1]);
            ans[l] = sum;
            // print();
        }

        return ans;
    }
};",1420546538
Wibo,Wibo,89,3610,cpp,"#include <bits/extc++.h> /** keep-include */
using namespace __gnu_pbds;

template<class T>
using Tree = tree<T, null_type, less<T>, rb_tree_tag,
    tree_order_statistics_node_update>;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();

        Tree<pair<int, int>> os; // <freq, sum>, val = sum / freq
        int sum = 0;
        map<int, int> freq;
        auto add = [&](int a) -> void {
            int fa = freq[a];
            if (fa == 0) return;
            pair<int, int> pa = {-fa, -1LL * fa * a};
            os.insert(pa);
            if (os.order_of_key(pa) < x) {
                sum += -pa.second;
                if (os.size() >= x+1) sum -= -os.find_by_order(x)->second;
            }
        };
        auto rem = [&](int a) -> void {
            int fa = freq[a];
            pair<int, int> pa = {-fa, -1LL * fa * a};
            if (os.order_of_key(pa) < x) {
                sum -= -pa.second;
                if (os.size() >= x+1) sum += -os.find_by_order(x)->second;
            }
            os.erase(pa);
        };

        auto print = [&]() -> void {
            for (auto &p : os) {
                int fa = p.first; int sa = p.second;
                int a = sa / fa;
                cout << '(' << a << ',' << -fa << ',' << -sa << ')';
            }
            cout << "" --> "" << sum << '\n';
        };
        
        for (int i=0; i<k; i++) freq[nums[i]]++;
        for (auto &[a, _] : freq) add(a);
        // print();

        vector<int> ans(n-k+1);
        ans[0] = sum;
        for (int l=1, r=k; r<n; l++, r++) {
            rem(nums[r]);
            if (nums[l-1] != nums[r]) rem(nums[l-1]);
            freq[nums[r]]++;
            freq[nums[l-1]]--;
            add(nums[r]);
            if (nums[l-1] != nums[r]) add(nums[l-1]);
            ans[l] = sum;
            // print();
        }

        return ans;
    }
};",1420547233
hxu10,hxu10,93,3509,python,"# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def kthLargestPerfectSubtree(self, root, k):
        """"""
        :type root: Optional[TreeNode]
        :type k: int
        :rtype: int
        """"""
        ans = []
        
        def getnext(p):
            

            l,r = 0,0
            left,right = 0,0
            if p.left:
                l,left = getnext(p.left)
            if p.right:
                r,right = getnext(p.right)
                
                
            
                
        
                
                
                
            if l==r and l==left and r==right:
                ans.append(1+l+r)
                return 1+l+r, 1+left+right
            else:
                return 0, 1+left+right
        
        getnext(root)
        ans.sort(reverse=True)
        
        #print(ans)
        
        if len(ans) < k:
            return -1
        return ans[k-1]
        
            
                ",1420526354
hxu10,hxu10,93,3588,python,"class Solution(object):
    def countWinningSequences(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        #s = ""F""*1000
        
        n = len(s)
        
        
        M = 10**9 + 7
        
            
        dic = {}
        
        mapping = {'W':0, 'E':1, 'F':2}

        nums = [mapping[s[i]] for i in range(n)]
        
        #print(nums)
        
        
        def geth(index,balance,pre):
            return index * 100000 + balance * 10 + pre
        
        
        
            
        def getnext(index,balance,pre):
            if index==n:
                if balance > 0: 
                    return 1
                else:  
                    return 0
                
                
            if balance + n - index <= 0:
                return 0
                
                
                
            
                
                
            if geth(index,balance,pre) in dic:
                return dic[geth(index,balance,pre)]
                
            
                
            
            
            op = nums[index]
            
            res = 0
            
            
            
            for c in range(3):
                if c==pre:  continue 
                    
                if c==op:  extra = 0
                elif (c-op)%3==1:  extra = 1
                else:  extra = -1
                    
                
                    
                res += getnext(index+1,balance+extra,c)
                res %= M
                
                
            dic[geth(index,balance,pre)] = res
            return res
        
        
        ans = getnext(0,0,-1)
        
        #print(dic)
        
        return ans
        
            
                    
                
                
                
                ",1420552213
hxu10,hxu10,93,3592,python,"from sortedcontainers import SortedList


class Topx(object):
    def __init__(self, x):
        self.sd = SortedList()
        self.x = x
        
        self.tot = 0
        
        
        
    def add(self,num,fre):
        
      #  print(num,fre,""add"")
        self.sd.add((-fre,-num))
        loc = self.sd.bisect_left((-fre,-num))
        
        if loc < self.x:
            self.tot += fre * num 
        
            if len(self.sd) > self.x:
                ele = self.sd[self.x]
                self.tot -= ele[0] * ele[1]
                
                
       # print(self.sd)
        
    def remove(self,num,fre):
        
       # print(num,fre,""remove"")
        loc = self.sd.bisect_left((-fre,-num))
        self.sd.remove((-fre,-num))
        
        
        
        if loc < self.x:
            self.tot -= fre * num
            
            if len(self.sd) >= self.x:
                ele = self.sd[self.x-1]
                self.tot += ele[0] * ele[1]
                
                
    
class Solution(object):
    def findXSum(self, nums, k, x):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        fre = {}
        for i in range(k):
            if nums[i] not in fre:  fre[nums[i]] = 0
                
            fre[nums[i]] += 1
            
            
            
        tx = Topx(x)
        
            
            
            
        for key in fre:
            tx.add(key,fre[key])
            
            
        ans = [tx.tot]
        
        for i in range(k,len(nums)):
            
            num = nums[i]
            
            if num not in fre:  
                fre[num] = 0
            else:
                tx.remove(num,fre[num])
                
            fre[num] += 1
                
            tx.add(num,fre[num])
            
            num = nums[i-k]
            
            
            tx.remove(num,fre[num])
            
            fre[num] -= 1
            if fre[num] == 0:   
                del fre[num]
            else:
                tx.add(num,fre[num])
                
                
            ans.append(tx.tot)
                
                
            
            
            
            
            
       # print(tx.tot)
        
        return ans
        
            
        
            
        ",1420582609
hxu10,hxu10,93,3610,python,"class Solution(object):
    def findXSum(self, nums, k, x):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        n = len(nums)
        ans = []
        for i in range(n-k+1):
            fre = {}
            for num in nums[i:i+k]:
                if num not in fre:  fre[num] = 0
                fre[num] += 1
                
            data = [(fre[key],key) for key in fre]
            data.sort()
            data = data[-x:]
            
            curr = 0
            for (f,num) in data:
                curr += f * num
            ans.append(curr)
        return ans
    
            ",1420519193
Rohit Meena,Rohit_Meena,94,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> valid;
    pair<bool, int> solve(TreeNode* root){
        if(root == NULL) return {1, 0};
        auto [lf, ls] = solve(root->left);
        auto [rf, rs] = solve(root->right);

        bool hasOneChild = (root->right == NULL && root->left != NULL) || (root->left == NULL && root->right != NULL);
        bool isSame = ls == rs;
        pair<bool, int> ans = {(lf && rf && isSame && (!hasOneChild)), ls + rs + 1};

        if(ans.first){
            valid.push_back(ans.second);
        }

        return ans;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        solve(root);
        sort(valid.rbegin(), valid.rend());
        if(k > valid.size()) return -1;
        return valid[k-1];
    }
};",1420556163
Rohit Meena,Rohit_Meena,94,3588,cpp,"#define ll long long
class Solution {
public:
    const int mod = 1e9 + 7;
    vector<int> a;
    int n;
    ll dp[1001][1501][4];
    ll solve(int i, int points, int prv){
        if(i == n) return points > 0;
        if(points < -500) return 0;

        ll &ans = dp[i][points + 500][prv];
        if(ans != -1) return ans;

        ans = 0;
        for(int k = 0;k<3;k++){
            if(k == prv) continue;
            if(a[i] == k) ans += solve(i+1, points, k);
            else if(a[i] == 0 && k == 1) ans += solve(i+1, points + 1, k);
            else if(a[i] == 1 && k == 2) ans += solve(i+1, points + 1, k);
            else if(a[i] == 2 && k == 0) ans += solve(i+1, points + 1, k);
            else ans += solve(i+1, points - 1, k);
            ans %= mod;
        }
        return ans;
    }
    int countWinningSequences(string s) {
        for(auto &ch: s){
            if(ch == 'F') a.push_back(0);
            if(ch == 'W') a.push_back(1);
            if(ch == 'E') a.push_back(2);
        }
        this->n = s.length();
        memset(dp, -1, sizeof(dp));

        return solve(0, 0, 3);
    }
};",1420583102
Rohit Meena,Rohit_Meena,94,3592,cpp,"#define ll long long
struct Mode{
  map<int,int> f;
  set<pair<int,int>> st;
  ll sum = 0;
  int count(){
    return st.size();
  }
  bool isPresent(int x){
    return f.find(x) != f.end();
  }
  void insert(int x, int c = 1){
    if(st.find({f[x],x}) != st.end()){
      st.erase({f[x],x});
      sum -= 1LL * x * f[x];
    }
    f[x]+=c;
    st.insert({f[x],x});
    sum += 1LL * x * f[x];
  }
  void remove(int x, int c = 1){
    if(st.find({f[x],x}) != st.end()){
      st.erase({f[x],x});
      sum -= 1LL * x * f[x];
    }
    f[x] -= c;
    if(f[x]>0){
        st.insert({f[x],x});
        sum += 1LL * x * f[x];
    }
    else f.erase(x);
  }
  pair<int,int> getMax(){
    if(st.empty()) return {-1, -1};
    return *st.rbegin();
  }
  pair<int,int> getMin(){
    if(st.empty()) return {-1, -1};
    return *st.begin();
  }
  void print(){
    cout<<""-> "";
    for(auto [ff, xx] : st){
        cout<<""[ ""<<ff<<"", ""<<xx<<"" ], "";
    }
    cout<<endl;
  }
};
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        Mode mx, mr;

        auto balance = [&](){
            if(mr.count() == 0) return;
            auto [minf, minV] = mx.getMin();
            auto [maxf, maxV] = mr.getMax();

            if(pair<int,int>{maxf, maxV} > pair<int,int>{minf, minV}){
                mr.remove(maxV, maxf);
                mx.insert(maxV, maxf);
                mx.remove(minV, minf);
                mr.insert(minV, minf);
            }
        };

        auto insert = [&](int val){
            mx.insert(val);
            if(mx.count() > x){
                auto [minf, mval] = mx.getMin();
                mx.remove(mval, minf);
                mr.insert(mval, minf);
            }
            balance();
        };

        auto remove = [&](int val){
            if(mx.isPresent(val)){
                mx.remove(val);

                if(mx.count() < x){
                    auto [maxf, mxval] = mr.getMax();
                    if(maxf != -1){
                        mx.insert(mxval, maxf);
                        mr.remove(mxval, maxf);
                    }
                }
            }
            else mr.remove(val);

            balance();
        };

        vector<ll> ans;
        for(int i = 0;i<k;i++){
            insert(nums[i]);
        }
        ans.push_back(mx.sum);
        // mx.print();
        // mr.print();
        for(int i = k;i<n;i++){
            insert(nums[i]);
            remove(nums[i-k]);
            // mx.print();
            // mr.print();
            ans.push_back(mx.sum);
        }
        return ans;
    }
};",1420544443
Rohit Meena,Rohit_Meena,94,3610,cpp,"#define ll long long
struct Mode{
  map<int,int> f;
  set<pair<int,int>> st;
  int sum = 0;
  int count(){
    return st.size();
  }
  bool isPresent(int x){
    return f.find(x) != f.end();
  }
  void insert(int x, int c = 1){
    if(st.find({f[x],x}) != st.end()){
      st.erase({f[x],x});
      sum -= 1LL * x * f[x];
    }
    f[x]+=c;
    st.insert({f[x],x});
    sum += 1LL * x * f[x];
  }
  void remove(int x, int c = 1){
    if(st.find({f[x],x}) != st.end()){
      st.erase({f[x],x});
      sum -= 1LL * x * f[x];
    }
    f[x] -= c;
    if(f[x]>0){
        st.insert({f[x],x});
        sum += 1LL * x * f[x];
    }
    else f.erase(x);
  }
  pair<int,int> getMax(){
    if(st.empty()) return {-1, -1};
    return *st.rbegin();
  }
  pair<int,int> getMin(){
    if(st.empty()) return {-1, -1};
    return *st.begin();
  }
  void print(){
    cout<<""-> "";
    for(auto [ff, xx] : st){
        cout<<""[ ""<<ff<<"", ""<<xx<<"" ], "";
    }
    cout<<endl;
  }
};
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        Mode mx, mr;

        auto balance = [&](){
            if(mr.count() == 0) return;
            auto [minf, minV] = mx.getMin();
            auto [maxf, maxV] = mr.getMax();

            if(pair<int,int>{maxf, maxV} > pair<int,int>{minf, minV}){
                mr.remove(maxV, maxf);
                mx.insert(maxV, maxf);
                mx.remove(minV, minf);
                mr.insert(minV, minf);
            }
        };

        auto insert = [&](int val){
            mx.insert(val);
            if(mx.count() > x){
                auto [minf, mval] = mx.getMin();
                mx.remove(mval, minf);
                mr.insert(mval, minf);
            }
            balance();
        };

        auto remove = [&](int val){
            if(mx.isPresent(val)){
                mx.remove(val);

                if(mx.count() < x){
                    auto [maxf, mxval] = mr.getMax();
                    if(maxf != -1){
                        mx.insert(mxval, maxf);
                        mr.remove(mxval, maxf);
                    }
                }
            }
            else mr.remove(val);

            balance();
        };

        vector<int> ans;
        for(int i = 0;i<k;i++){
            insert(nums[i]);
        }
        ans.push_back(mx.sum);
        // mx.print();
        // mr.print();
        for(int i = k;i<n;i++){
            insert(nums[i]);
            remove(nums[i-k]);
            // mx.print();
            // mr.print();
            ans.push_back(mx.sum);
        }
        return ans;
    }
};",1420546043
BERNARD BRAHIMCHA,BERNARB01,95,3509,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

#ifdef B01
struct TreeNode {
   int val;
   TreeNode *left;
   TreeNode *right;
   TreeNode() : val(0), left(nullptr), right(nullptr) {}
   TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   TreeNode(int x, TreeNode *left_, TreeNode *right_) : val(x), left(left_), right(right_) {}
};
#endif

class Solution {
 public:
  int kthLargestPerfectSubtree(TreeNode* root, int k) {
    vector<int> is, sz, szs;
    auto Dfs = [&](auto&& self, TreeNode* v) -> int {
      int id = int(sz.size());
      sz.push_back(1);
      is.push_back(1);
      int cnt = 0;
      int l, r;
      if (v->left != nullptr) {
        l = self(self, v->left);
        is[id] &= is[l];
        sz[id] += sz[l];
        cnt++;
      }
      if (v->right != nullptr) {
        r = self(self, v->right);
        is[id] &= is[r];
        sz[id] += sz[r];
        cnt++;
      }
      if (cnt == 1) {
        is[id] = 0;
      } else if (cnt == 2 && sz[l] != sz[r]) {
        is[id] = 0;
      }
      if (is[id]) {
        szs.push_back(sz[id]);
      }
      return id;
    };
    Dfs(Dfs, root);
    sort(szs.rbegin(), szs.rend());
    //for (int x : is) {
      //cout << x << "" "";
    //}
    //cout << endl;
    //for (int x : szs) {
      //cout << x << "" "";
    //}
    //cout << endl;
    return (k - 1 < int(szs.size()) ? szs[k - 1] : -1);
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1420559397
BERNARD BRAHIMCHA,BERNARB01,95,3588,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

template <typename T>
inline int po(int b, T p) {
  int r = 1;
  while (p > 0) {
    if (p & 1) {
      r = mul(r, b);
    }
    b = mul(b, b);
    p >>= 1;
  }
  return r;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) a += md;
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a; swap(a, b);
    u -= t * v; swap(u, v);
  }
  assert(b == 1);
  if (u < 0) u += md;
  return u;
}

string mvs = ""FWE"";

inline int wins(int i, int j) {
  return ((i + 2) % 3 == j ? 1 : (i == j ? 0 : -1));
}

class Solution {
 public:
  int countWinningSequences(string s) {
    int n = int(s.length());
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
      a[i] = mvs.find(s[i]);
    }
    vector dp(2 * n + 1, (array<int, 3>) {});
    for (int i = 0; i < 3; i++) {
      dp[n + wins(i, a[0])][i] = 1;
    }
    deb(dp);
    for (int i = 1; i < n; i++) {
      vector new_dp(2 * n + 1, (array<int, 3>) {});
      for (int j = -i; j <= i; j++) {
        for (int k = 0; k < 3; k++) {
          for (int l = 0; l < 3; l++) {
            if (l == k) {
              continue;
            }
            add(new_dp[j + wins(l, a[i]) + n][l], dp[j + n][k]);
          }
        }
      }
      swap(dp, new_dp);
      deb(dp);
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
      for (int j = 0; j < 3; j++) {
        add(ans, dp[i + n][j]);
      }
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
  deb(sl.countWinningSequences(""FFF""));
}
#endif
",1420577238
BERNARD BRAHIMCHA,BERNARB01,95,3592,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<long long> findXSum(vector<int>& a, int k, int X) {
    int n = int(a.size());
    map<int, int> mp;
    set<pair<int, int>> most, not_most;
    int64_t sum = 0;
    auto SetAdd = [&](int x, int f) {
      if (int(most.size()) < X) {
        most.emplace(f, x);
        sum += int64_t(f) * x;
      } else if (make_pair(f, x) > *most.begin()) {
        auto [ff, xx] = *most.begin();
        sum -= int64_t(ff) * xx;
        most.erase(most.begin());
        not_most.emplace(ff, xx);
        most.emplace(f, x);
        sum += int64_t(f) * x;
      } else {
        not_most.emplace(f, x);
      }
    };
    auto SetRemove = [&](int x, int f) {
      auto it = not_most.find({f, x});
      if (it != not_most.end()) {
        not_most.erase(it);
        return;
      }
      most.erase({f, x});
      sum -= int64_t(f) * x;
      if (!not_most.empty()) {
        it = prev(not_most.end());
        auto [ff, xx] = *it;
        not_most.erase(it);
        most.emplace(ff, xx);
        sum += int64_t(ff) * xx;
      }
    };
    auto Add = [&](int x) {
      int v = ++mp[x];
      if (v - 1 != 0) {
        SetRemove(x, v - 1);
      }
      SetAdd(x, v);
    };
    auto Remove = [&](int x) {
      int v = --mp[x];
      SetRemove(x, v + 1);
      if (v != 0) {
        SetAdd(x, v);
      }
    };
    for (int i = 0; i < k - 1; i++) {
      Add(a[i]);
    }
    vector<long long> ans(n - k + 1);
    for (int i = k - 1; i < n; i++) {
      Add(a[i]);
      ans[i - k + 1] = sum;
      Remove(a[i - k + 1]);
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1420535926
BERNARD BRAHIMCHA,BERNARB01,95,3610,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<int> findXSum(vector<int>& a, int k, int X) {
    int n = int(a.size());
    map<int, int> mp;
    set<pair<int, int>> most, not_most;
    int64_t sum = 0;
    auto SetAdd = [&](int x, int f) {
      if (int(most.size()) < X) {
        most.emplace(f, x);
        sum += int64_t(f) * x;
      } else if (make_pair(f, x) > *most.begin()) {
        auto [ff, xx] = *most.begin();
        sum -= int64_t(ff) * xx;
        most.erase(most.begin());
        not_most.emplace(ff, xx);
        most.emplace(f, x);
        sum += int64_t(f) * x;
      } else {
        not_most.emplace(f, x);
      }
    };
    auto SetRemove = [&](int x, int f) {
      auto it = not_most.find({f, x});
      if (it != not_most.end()) {
        not_most.erase(it);
        return;
      }
      most.erase({f, x});
      sum -= int64_t(f) * x;
      if (!not_most.empty()) {
        it = prev(not_most.end());
        auto [ff, xx] = *it;
        not_most.erase(it);
        most.emplace(ff, xx);
        sum += int64_t(ff) * xx;
      }
    };
    auto Add = [&](int x) {
      int v = ++mp[x];
      if (v - 1 != 0) {
        SetRemove(x, v - 1);
      }
      SetAdd(x, v);
    };
    auto Remove = [&](int x) {
      int v = --mp[x];
      SetRemove(x, v + 1);
      if (v != 0) {
        SetAdd(x, v);
      }
    };
    for (int i = 0; i < k - 1; i++) {
      Add(a[i]);
    }
    vector<int> ans(n - k + 1);
    for (int i = k - 1; i < n; i++) {
      Add(a[i]);
      ans[i - k + 1] = sum;
      Remove(a[i - k + 1]);
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1420537288
otto,_otto,96,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        ans = []
        def dfs(u):
            if u is None:
                return True, 0, 0
            l1, l2, l3 = dfs(u.left)
            r1, r2, r3 = dfs(u.right)
            if l1 and r1 and l3 == r3:
                curr = l2 + r2 + 1
                currh = l3 + 1
                ans.append(curr)
                return True, curr, currh
            else:
                return False, 0, 0
        dfs(root)
        ans.sort(reverse=True)
        #print(ans)
        if k <= len(ans): return ans[k - 1]
        return -1",1420524279
otto,_otto,96,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        def fuck(a, b):
            if a == b: return 0
            if a == 'F' and b == 'E': return 1
            if a == 'E' and b == 'W': return 1
            if a == 'W' and b == 'F': return 1
            return -1
        n = len(s)
        MOD = int(1e9 + 7)
        @cache
        def dfs(i, last, diff):
            if i == n: return 1 if diff > 0 else 0
            target = s[i]
            ans = 0
            for move in [""F"", ""W"", ""E""]:
                if move == last: continue
                curr = diff + fuck(move, target)
                ans += dfs(i + 1, move, curr)
                ans %= MOD
            return ans
        t = dfs(0, 'fuck', 0)
        dfs.cache_clear()
        return t % MOD",1420531756
otto,_otto,96,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        freq = defaultdict(int)
        ans = []
        n = len(nums)
        
        for i in range(k):
            freq[nums[i]] += 1
        
        sl = SortedList()
        for num in freq:
            sl.add((-freq[num], -num))
        
        top_x = SortedList()
        rest = SortedList()
        bd = min(len(sl), x)
        for i in range(len(sl)):
            if i < bd:
                top_x.add(sl[i])
            else:
                rest.add(sl[i])
        
        curr = 0
        for item in top_x:
            freq_i = -item[0]
            value_i = -item[1]
            curr += freq_i * value_i
        ans.append(curr)
        
        for i in range(k, n):
            old_num = nums[i - k]
            new_num = nums[i]
            
            old_freq = freq[old_num]
            sl.remove((-old_freq, -old_num))
            if (-old_freq, -old_num) in top_x:
                top_x.remove((-old_freq, -old_num))
                curr -= old_freq * old_num
            else:
                rest.remove((-old_freq, -old_num))
            freq[old_num] -= 1
            if freq[old_num] > 0:
                new_old_freq = freq[old_num]
                sl.add((-new_old_freq, -old_num))
                idx = sl.bisect_left((-new_old_freq, -old_num))
                if idx < x:
                    top_x.add((-new_old_freq, -old_num))
                    curr += new_old_freq * old_num
                    if len(top_x) > x:
                        removed = top_x.pop()
                        curr -= (-removed[0]) * (-removed[1])
                        rest.add(removed)
                else:
                    rest.add((-new_old_freq, -old_num))
            else:
                pass
            
            if len(top_x) < x and rest:
                moved = rest.pop(0)
                top_x.add(moved)
                curr += (-moved[0]) * (-moved[1])

            if freq[new_num] > 0:
                old_freq_new_num = freq[new_num]
                sl.remove((-old_freq_new_num, -new_num))
                if (-old_freq_new_num, -new_num) in top_x:
                    top_x.remove((-old_freq_new_num, -new_num))
                    curr -= old_freq_new_num * new_num
                else:
                    rest.remove((-old_freq_new_num, -new_num))
                freq[new_num] += 1
                new_freq_new_num = freq[new_num]
            else:
                freq[new_num] = 1
                new_freq_new_num = 1
            sl.add((-new_freq_new_num, -new_num))
            idx = sl.bisect_left((-new_freq_new_num, -new_num))
            if idx < x:
                top_x.add((-new_freq_new_num, -new_num))
                curr += new_freq_new_num * new_num
                if len(top_x) > x:
                    removed = top_x.pop()
                    curr -= (-removed[0]) * (-removed[1])
                    rest.add(removed)
            else:
                rest.add((-new_freq_new_num, -new_num))
            if len(top_x) < x and rest:
                moved = rest.pop(0)
                top_x.add(moved)
                curr += (-moved[0]) * (-moved[1])
            # print(sl)
            ans.append(curr)
        return ans
",1420589386
otto,_otto,96,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        n = len(nums)
        for i in range(n - k + 1):
            tmp = []
            ret = 0
            for j in range(i, i + k):
                tmp.append(nums[j])
            cnt = Counter(tmp)
            ev = [(-v, -k) for k, v in cnt.items()]
            ev.sort()
            #print(ev)
            for i in range(min(len(ev), x)):
                ret += ev[i][0] * ev[i][1]
            ans.append(ret)
        return ans",1420520316
dimash05,dimash05,97,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool dfs(TreeNode*root, vector <int> &subtrees) {
        int eq = -1;
        bool ok = 0;
        if ((root -> left) != nullptr) {
            if (dfs(root -> left, subtrees)) 
                eq = subtrees.back();
        }
        if ((root -> right) != nullptr) {
            if (dfs(root -> right, subtrees)) {
                if (subtrees.back() == eq) 
                    ok = 1;
            }
        }
        if ((root -> left) == nullptr && (root -> right) == nullptr) {
            subtrees.push_back(1);
            return 1;
        }
        if (ok) {
            subtrees.push_back(subtrees.back() * 2 + 1);
            return 1;
        }
        return 0;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector <int> subtrees;
        dfs(root, subtrees);
        sort(subtrees.begin(), subtrees.end());
        reverse(subtrees.begin(), subtrees.end());
        if (k > (int)subtrees.size())
            return -1;
        return subtrees[k - 1];
    }
};",1420535828
dimash05,dimash05,97,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size(), mod = 1e9 + 7, ans = 0;
        int c = n + 1;
        vector <vector <vector <int> > > dp(n, vector <vector <int> > (2 * n + 3, vector <int> (3)));
        vector <vector <int> > win(3, vector <int> (3));
        win[0][2] = win[1][0] = win[2][1] = 1;
        win[2][0] = win[0][1] = win[1][2] = -1;
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F')
                s[i] = 0;
            else if (s[i] == 'W')
                s[i] = 1;
            else
                s[i] = 2;
            for (int j = 0; j < 3; ++j) {
                int add = win[j][s[i]];
                if (!i) {
                    dp[i][c + add][j] = 1;
                } else {
                    for (int k = -n; k <= n; ++k) {
                        for (int t = 0; t < 3; ++t) {
                            if (j == t)
                                continue;
                            dp[i][c + k + add][j] += dp[i - 1][c + k][t];
                            dp[i][c + k + add][j] %= mod;
                        }
                    }
                }
            }
        }
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < 3; ++j) 
                ans = (ans + dp[n - 1][c + i][j]) % mod;
        }
        return ans;
    }
};",1420551600
dimash05,dimash05,97,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        #define mp make_pair
        vector <long long> ans;
        set <pair <int, int> > st, mda;
        map <int, int> cnt;
        long long cur = 0;
        for (int i = 0; i < (int)nums.size(); ++i) {
            if (i >= k) {
                // delete i - k
                mda.erase(mp(cnt[nums[i - k]], nums[i - k]));
                mda.insert(mp(cnt[nums[i - k]] - 1, nums[i - k]));
                if (st.count(mp(cnt[nums[i - k]], nums[i - k]))) {
                    st.erase(mp(cnt[nums[i - k]], nums[i - k]));
                    cur -= nums[i - k] * 1ll * cnt[nums[i - k]];
                    cnt[nums[i - k]]--;
                    
                    auto it = mda.upper_bound(mp(cnt[nums[i - k]], nums[i - k]));
                    if (it != mda.end() && !st.count(*it)) {
                        if (st.empty()) {
                            it = mda.end();
                            it--;
                        } else {
                            it = mda.lower_bound(*st.begin());
                            it--;
                        }
                        st.insert(*it);
                        cur += it -> first * 1ll * it -> second;
                    } else {
                        st.insert(mp(cnt[nums[i - k]], nums[i - k]));
                        cur += nums[i - k] * 1ll * cnt[nums[i - k]];
                    }
                }
                else cnt[nums[i - k]]--;
            }
            mda.erase(mp(cnt[nums[i]], nums[i]));
            mda.insert(mp(cnt[nums[i]] + 1, nums[i]));
            if (st.count(mp(cnt[nums[i]], nums[i])) || (int)st.size() < x) {
                st.erase(mp(cnt[nums[i]], nums[i]));
                ++cnt[nums[i]];
                cur += nums[i];
                st.insert(mp(cnt[nums[i]], nums[i]));
            }
            else {
                ++cnt[nums[i]];
                if (mp(cnt[nums[i]], nums[i]) > *st.begin()) {
                    cur -= (st.begin() -> first) * 1ll * (st.begin() -> second);
                    st.erase(st.begin());
                    cur += nums[i] * 1ll * cnt[nums[i]];
                    st.insert(mp(cnt[nums[i]], nums[i]));
                }
            }
            if (i >= k - 1) {
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1420583784
dimash05,dimash05,97,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector <int> ans;
        for (int i = 0; i + k - 1 < (int)nums.size(); ++i) {
            map <int, int> cnt;
            vector <pair <int, int> > vec;
            int sum = 0;
            for (int j = i; j <= i + k - 1; ++j) {
                ++cnt[nums[j]];
                sum += nums[j];
            }
            for (auto [x, y] : cnt) {
                vec.push_back({y, x});
            }
            if ((int)vec.size() < x) {
                ans.push_back(sum);
                continue;
            }
            sort(vec.begin(), vec.end());
            sum = 0;
            for (int j = vec.size() - 1; j >= (int)vec.size() - x; j--) {
                sum += vec[j].first * vec[j].second;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420524687
tl2001,user1838wc,98,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> vec;
        auto dfs = [&](auto& dfs, TreeNode* root) -> pair<int, int> {
            if(!root) return {0, 1};
            auto [leftCnt, leftV] = dfs(dfs, root->left);
            auto [rightCnt, rightV] = dfs(dfs, root->right);
            bool ok = leftV && rightV && ((!root->left && !root->right) || (root->left && root->right));
            int cnt = leftCnt + rightCnt + 1;
            ok &= ((cnt + 1) & cnt) == 0;
            if(ok) {
                vec.push_back(cnt);
            }
            return {cnt, ok};
        };
        dfs(dfs, root);
        sort(rbegin(vec), rend(vec));
        return vec.size() >= k ? vec[k - 1] : -1;
    }
};",1420533417
tl2001,user1838wc,98,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        using ll = long long;
        vector<int> a;
        for(auto& ch : s) {
            a.push_back(ch == 'F' ? 0 : (ch == 'E' ? 1 : 2));
        }
        auto win = [](int i, int j) -> int {
            return (i + 1) % 3 == j;
        };
        int n = s.size();
        vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(2 * n + 1, vector<ll>(3, -1)));
        int MOD = 1e9 + 7;
        auto dfs = [&](auto& dfs, int i = 0, int last = 0, int sm = 0) -> ll {
            if(i == n) return sm > 0;
            ll& res = dp[i][sm + n][last];
            if(res != -1) return res;
            res = 0;
            for(int j = 0; j < 3; j++) {
                if(i && last == j) continue;
                int val = win(a[i], j) ? -1 : (win(j, a[i]) ? 1 : 0);
                res = (res + dfs(dfs, i + 1, j, sm + val)) % MOD;
            }
            return res;
        };
        return dfs(dfs);
    }
};",1420578131
tl2001,user1838wc,98,3592,cpp,"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗
//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝
//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░
//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░
//░░░██║░░░██║██║░╚███║  ███████╗███████╗
//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))

//SGT DEFINE
#define lc i * 2 + 1
#define rc i * 2 + 2
#define lp lc, left, middle
#define rp rc, middle + 1, right
#define entireTree 0, 0, n - 1
#define midPoint left + (right - left) / 2
#define pushDown push(i, left, right)
#define iterator int i, int left, int right

#define IOS ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)

struct custom {
    static const uint64_t C = 0x9e3779b97f4a7c15; const uint32_t RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
    size_t operator()(uint64_t x) const { return __builtin_bswap64((x ^ RANDOM) * C); }
    size_t operator()(const std::string& s) const { size_t hash = std::hash<std::string>{}(s); return hash ^ RANDOM; } };
template <class K, class V> using umap = std::unordered_map<K, V, custom>; template <class K> using uset = std::unordered_set<K, custom>;
    
 
template<typename T> vt<T> uniqued(vt<T> arr) {  srtU(arr); return arr; }

#ifdef LOCAL
#define debug(x...) debug_out(#x, x)
void debug_out(const char* names) { std::cerr << std::endl; }
template <typename T, typename... Args>
void debug_out(const char* names, T value, Args... args) {
    const char* comma = strchr(names, ',');
    std::cerr << ""["" << (comma ? std::string(names, comma) : names) << "" = "" << value << ""]"";
    if (sizeof...(args)) { std::cerr << "", ""; debug_out(comma + 1, args...); }   
    else { std::cerr << std::endl; }
}
#define startClock clock_t tStart = clock();
#define endClock std::cout << std::fixed << std::setprecision(10) << ""\nTime Taken: "" << (double)(clock() - tStart) / CLOCKS_PER_SEC << "" seconds"" << std::endl;
#else
#define debug(...)
#define startClock
#define endClock

#endif
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#define eps 1e-9
#define M_PI 3.14159265358979323846
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int pct(ll x) { return __builtin_popcountll(x); }
const vvi dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
const vpii dirs_3_3 = { 
        {0,1}, {0,3},
        {1,0}, {1,2}, {1,4},
        {2,1}, {2,5},
        {3,0}, {3,4}, {3,6},
        {4,1}, {4,3}, {4,5}, {4,7},
        {5,2}, {5,4}, {5,8},
        {6,3}, {6,7},
        {7,4}, {7,6}, {7,8},
        {8,5}, {8,7}
};

int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
void multiply(int f[2][2], int m[2][2]) {   
    int res[2][2] = {}; 
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++)  {   for(int k = 0; k < 2; k++)  {   res[i][j] = (res[i][j] + f[i][k] * m[k][j]) % MOD; }   }   }   
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++) f[i][j] = res[i][j]; }   }
int fib(int n)  {       if(n == 0) return 0;        if(n == 1) return 1;    
    int f[2][2] = {{1, 1}, {1, 0}}; int res[2][2] = {{1, 0}, {0, 1}};       
    while(n)    {   if(n & 1) multiply(res, f); multiply(f, f); n >>= 1;    }   return res[0][1] % MOD; }   
vi primes;  
bitset<MX> primeBits;
void generatePrime() {  primeBits.set(2);   
    for(int i = 3; i < MX; i += 2) primeBits.set(i);
    for(int i = 3; i * i < MX; i += 2) {    if(primeBits[i]) {  for(int j = i; j * i < MX; j += 2) {    primeBits.reset(i * j); } } }
    for(int i = 0; i < MX; i++ ) {  if(primeBits[i]) {  primes.pb(i); } }   
}

vi countBit(ll n) { 
    vi cnt(62);
    while(n) {  
        int msb = log2(n);  
        ll c = 1LL << msb; 
        cnt[msb] += n - c + 1;
        for(int i = 0; i < msb; i++) {  
            cnt[i] += c / 2;
        }
        n -= c;
    }
    return cnt;
}
    
template<typename T>
class Treap {
private:
    struct TreapNode {
        int pri, size;
        T data;
        TreapNode* left;
        TreapNode* right;
        
        TreapNode(T data) : data(data), pri(rand()), size(1), left(nullptr), right(nullptr) {}
    };

    TreapNode* root;

    int size(TreapNode* treap) {
        if (!treap) return 0;
        return treap->size;
    }

    void split(TreapNode* treap, TreapNode*& left, TreapNode*& right, int k) {
        if (!treap) {
            left = right = nullptr;
            return;
        }
        if (size(treap->left) >= k) {
            split(treap->left, left, treap->left, k);
            right = treap;
        } else {
            split(treap->right, treap->right, right, k - size(treap->left) - 1);
            left = treap;
        }
        treap->size = size(treap->left) + size(treap->right) + 1;
    }

    void merge(TreapNode*& treap, TreapNode* left, TreapNode* right) {
        if (!left || !right) {
            treap = left ? left : right;
            return;
        }
        if (left->pri < right->pri) {
            merge(left->right, left->right, right);
            treap = left;
        } else {
            merge(right->left, left, right->left);
            treap = right;
        }
        treap->size = size(treap->left) + size(treap->right) + 1;
    }

public:
    Treap() : root(nullptr) {}

    void insert(T ch) { 
        merge(root, root, new TreapNode(ch));
    }
    
    void del(int left, int right) { 
        TreapNode* A, *B, *C;   
        split(root, A, B, left - 1); 
        split(B, B, C, right - left + 1);   
        merge(root, A, C);
    }
    
    bool get(TreapNode* treap, int k, T& ans) {
        if(!treap) return true;
        int leftSize = size(treap->left);
        if (k <= leftSize) {
            if(get(treap->left, k, ans)) {  
                ans = treap->data;
            }
            return false;
        }
        else if (k == leftSize + 1) {
            ans = treap->data;  
            return false;
        }
        else {
            if(get(treap->right, k - leftSize - 1, ans)) {  
                ans = treap->data;
            }
            return false;
        }
    }
};
    
class Binary_Trie { 
    public:
    int T[MX][2];   
    int ptr;    
    Binary_Trie() {    
        ptr = 0;    
        mset(T, 0);
    }
    
    void insert(int num) {  
        int curr = 0;   
        for(int i = 31; i >= 0; i--) {  
            int bits = (num >> i) & 1;  
            if(!T[curr][bits]) T[curr][bits] = ++ptr;   
            curr = T[curr][bits];
        }
    }
        
    int max_xor(int num) {  
        int res = 0, curr = 0;
        for(int i = 31; i >= 0; i--) {  
            int bits = (num >> i) & 1;  
            if(T[curr][!bits]) {    
                curr = T[curr][!bits];
                res |= (1LL << i);
            }
            else {  
                curr = T[curr][bits];
            }
        }
        return res;
    }
};

class Trie {
private:
    int root;
    int count = 0, n;
    vector<int> dp;
    string s;
    int T[MX][26];       
    int sfx[MX];         
    int dict[MX];        
    int id[MX];          
    bool isEnd[MX];


    int newNode() {
        fill(T[count], T[count] + 26, -1); 
        sfx[count] = dict[count] = 0;      
        id[count] = -1; 
        isEnd[count] = false;                    
        return count++;                     
    }

public:
    Trie(int n) {
        this->n = n;
        dp.rsz(n + 1, 1e9);
        root = newNode(); 
        sfx[root] = dict[root] = root; 
    }

    void insert(const string& word) {
        int curr = root;
        int l = 0;
        for (char ch : word) {
            int idx = ch - 'a';
            if (T[curr][idx] == -1) {
                T[curr][idx] = newNode();
            }
            curr = T[curr][idx];
            l++;
            if (id[curr] == -1) {
                id[curr] = l; 
            }
        }
        isEnd[curr] = true;
    }

    void aho_corasick() {
        queue<int> q;
        q.push(root);

        while (!q.empty()) {
            int par = q.front();
            q.pop();

            for (int i = 0; i < 26; i++) {
                int child = T[par][i];
                if (child == -1) continue;

                int suff = sfx[par];
                while (suff != root && T[suff][i] == -1) {
                    suff = sfx[suff];
                }

                if (par != root && T[suff][i] != -1) {
                    sfx[child] = T[suff][i];
                } else {
                    sfx[child] = root;
                }

                dict[child] = (id[sfx[child]] == -1) ? dict[sfx[child]] : sfx[child];
                q.push(child);
            }
        }
    }

    void queries(int& prev, int i, char ch) {
        int idx = ch - 'a';
        while (prev != root && T[prev][idx] == -1) {
            prev = sfx[prev];
        }

        if (T[prev][idx] != -1) {
            prev = T[prev][idx];
            int curr = (id[prev] == -1) ? dict[prev] : prev;

            while (id[curr] != -1) {
                int j = id[curr];
                dp[i] = min(dp[i], dp[i - j] + 1);
                curr = dict[curr];
            }
        }
    }

    int get() {
        dp[0] = 0;
        int prev = root;

        for (int i = 1; i <= n; i++) {
            queries(prev, i, s[i - 1]);
        }

        return dp[n] == 1e9 ? -1 : dp[n];
    }
};

class DSU { 
    public: 
    int n;  
    vi root, rank;  
    DSU(int n) {    
        this->n = n;    
        root.rsz(n, -1), rank.rsz(n, 1);
    }
    
    int find(int x) {   
        if(root[x] == -1) return x; 
        return root[x] = find(root[x]);
    }
    
    bool merge(int u, int v) {  
        u = find(u), v = find(v);   
        if(u != v) {    
            if(rank[v] > rank[u]) swap(u, v);   
            rank[u] += rank[v]; 
            root[v] = u;
            return true;
        }
        return false;
    }
    
    bool same(int u, int v) {    
        return find(u) == find(v);
    }
    
    int getRank(int x) {    
        return rank[find(x)];
    }
};
    
template<class T>
class FW {  
    public: 
    int n;  
    vt<T> root;    
    FW(int n) { 
        this->n = n;    
        root.rsz(n + 1);
    }
    
    void update(int id, T val) {  
        while(id <= n) {    
            root[id] += val;    
            id += (id & -id);
        }
    }
    
    T get(int id) {   
        T res = 0;    
        while(id > 0) { 
            res += root[id];    
            id -= (id & -id);
        }
        return res;
    }
    
    T queries(int left, int right) {  
        return get(right) - get(left - 1);
    }
};

template<class T>   
class SGT { 
    public: 
    int n;  
    vt<T> root, lazy; 
    T DEFAULT;
    SGT(vi& arr) {    
        n = arr.size(); 
        DEFAULT = INF;
        root.rsz(n * 4);    
        // lazy.rsz(n * 4);
        build(entireTree, arr);
    }
    
    void build(iterator, vi& arr) { 
        if(left == right) { 
            root[i] = arr[left];    
            return;
        }
        int middle = midPoint;  
        build(lp, arr), build(rp, arr); 
        root[i] = merge(root[lc], root[rc]);
    }
    
    void update(int id, int val) {  
        update(entireTree, id, val);
    }
    
    void update(iterator, int id, int val) {    
        if(left == right) { 
            root[i] = val;  
            return;
        }
        int middle = midPoint;  
        if(id <= middle) update(lp, id, val);   
        else update(rp, id, val);   
        root[i] = merge(root[lc], root[rc]);
    }

    void update(int start, int end, int val) { 
        update(entireTree, start, end, val);
    }
    
    void update(iterator, int start, int end, int val) {    
        pushDown;   
        if(left > end || start > right) return; 
        if(left >= start && right <= end) { 
            lazy[i] = val;  
            pushDown;   
            return;
        }
        int middle = midPoint;  
        update(lp, start, end, val);    
        update(rp, start, end, val);    
        root[i] = merge(root[lc], root[rc]);
    }
    
    T merge(T left, T right) {  
        T res;  
        return res;
    }
    
    void push(iterator) {   
        if(lazy[i] == 0) return;    
        root[i] += (right - left + 1) * lazy[i];
        if(left != right) { 
            lazy[lc] += lazy[i]; 
            lazy[rc] += lazy[i];
        }
        lazy[i] = 0;
    }

    T queries(int start, int end) { 
        return queries(entireTree, start, end);
    }
    
    T queries(iterator, int start, int end) {   
        pushDown;
        if(left > end || start > right) return DEFAULT;
        if(left >= start && right <= end) return root[i];   
        int middle = midPoint;  
        return merge(queries(lp, start, end), queries(rp, start, end));
    }

};
    
vi KMP(const string& s) {   
    int n = s.size();
    vi prefix(n);
    for(int i = 1, j = 0; i < n; i++) { 
        while(j && s[i] != s[j]) j = prefix[j - 1]; 
        if(s[i] == s[j]) prefix[i] = ++j;
    }
    return prefix;
}

vi Z_Function(const string& s) {    
    int n = s.size();   
    vi prefix(n);   
    for(int i = 1, left = 0, right = 0; i < n; i++) {   
        if(i > right) { 
            left = right = i;   
            while(right < n && s[right] == s[right - left]) right++;    
            prefix[i] = right-- - left;
        }
        else {  
            if(prefix[i - left] + i < right + 1) {  
                prefix[i] = prefix[i - left];
            }
            else {  
                left = i;   
                while(right < n && s[right] == s[right - left]) right++;    
                prefix[i] = right-- - left;
            }
        }
    }
    return prefix;
}
    
vi manacher(string s, int start) {
    string tmp;
    for (auto& it : s) {
        tmp += ""#"";
        tmp += it;
    }
    tmp += ""#"";  
    swap(s, tmp);
    int n = s.size();
    vector<int> p(n); 
    int l = 0, r = 0;  
    for (int i = 0; i < n; i++) {
        if (i < r) {
            p[i] = min(r - i, p[l + r - i]);
        } else {
            p[i] = 0;
        }
        while (i - p[i] >= 0 && i + p[i] < n && s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if (i + p[i] > r) {
            l = i - p[i] + 1;
            r = i + p[i] - 1;
        }
    }
    vi result;
    for (int i = start; i < n; i += 2) {
        result.push_back(p[i] / 2);
    }
    return result;
}

class RabinKarp {   
    public: 
    vpii prefix;    
    vi pow;
    int mod1, n, mod2, base1, base2;
    RabinKarp(const string& s) {  
        mod1 = 1e9 + 7, mod2 = 1e9 + 33, base1 = 26, base2 = 27;
        n = s.size(); 
        prefix.rsz(n + 1);
        pow.rsz(n + 1);
        pow[0] = 1;
        buildHash(s);
    }
    
    void buildHash(const string& s) {   
        int hash1 = 0, hash2 = 0;
        for(int i = 1; i <= n; i++) {   
            hash1 = (hash1 * base1 + s[i - 1] - 'a') % mod1;    
            hash2 = (hash2 * base2 + s[i - 1] - 'a') % mod2;
            prefix[i].ff = hash1;    
            prefix[i].ss = hash2;
            pow[i] = (pow[i - 1] * 26) % mod1;
        }
    }
    
    pii getHash(int l, int r) { 
        int hash1 = prefix[r].ff - (prefix[l].ff * pow[r - l] % mod1) % mod1;
        hash1 = (hash1 + mod1) % mod1;  
        int hash2 = prefix[r].ss - (prefix[l].ss * pow[r - l] % mod2) % mod2;   
        hash2 = (hash2 * mod2) % mod2;  
        return MP(hash1, hash2);
    };
};

class LCA { 
    public: 
    int n;  
    vvi dp; 
    vi depth;
    LCA(vvi& dp, vi& depth) {   
        this->dp = dp;  
        this->depth = depth;
        n = depth.size();
        init();
    }
    
    void init() {  
        for(int j = 1; j < MK; j++) {   
            for(int i = 0; i < n; i++) {    
                dp[i][j] = dp[dp[i][j - 1]][j - 1];
            }
        }
    }
    
    int lca(int a, int b) { 
        if(depth[a] > depth[b]) {   
            swap(a, b);
        }
        int d = depth[b] - depth[a];    
        for(int i = MK - 1; i >= 0; i--) {  
            if((d >> i) & 1) {  
                b = dp[b][i];
            }
        }
        if(a == b) return a;    
        for(int i = MK - 1; i >= 0; i--) {  
            if(dp[a][i] != dp[b][i]) {  
                a = dp[a][i];   
                b = dp[b][i];
            }
        }
        return dp[a][0];
    }
};

class Combinatoric {    
    public: 
    int n;  
    vll fact, inv;   
    Combinatoric(int n) {   
        this->n = n;    
        fact.rsz(n + 1), inv.rsz(n + 1);
        init();
    }
        
    void init() {   
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {   
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        inv[n] = modExpo(fact[n], MOD - 2, MOD);
        for(int i = n - 1; i >= 0; i--) {   
            inv[i] = (inv[i + 1] * (i + 1)) % MOD;
        }
    }
    
    ll choose(int a, int b) {  
		if(a < b) return 0;
        return fact[a] * inv[b] % MOD * inv[a - b] % MOD;
    }
};

ll XOR_SUM(vi& a) { 
    int m = 32, n = a.size(); 
    vvi bits(2, vi(m)); 
    fill(all(bits[0]), 1);
    ll ans = 0; 
    for(int i = 0, x = 0; i < n; i++) {    
        x ^= a[i];
        for(int j = 0; j < m; j++) {    
            if((x >> j) & 1) bits[1][j]++;  
            else bits[0][j]++;
        }
    }
    for(int i = 0; i < m; i++) {    
        ans += (1LL << i) * bits[0][i] * bits[1][i];
    }
    return ans;
}


class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pll> high, low;
        umap<int, ll> freq;
        ll running_sum = 0;
        int n = nums.size();
        auto modify = [&](int a, int v) -> void {
            pii val = MP(freq[a], a);
            if(freq[a]) {
                if(high.find(val) != high.end()) {
                    running_sum -= freq[a] * a;
                    high.erase(val);
                }
                else {
                    low.erase(val);
                }
            }
            while(high.size() > x) {
                auto it = high.begin();
                running_sum -= it->ff * it->ss;
                low.insert(*it);
                high.erase(it);
            }
            while(!low.empty() && high.size() < x) {
                auto it = prev(low.end());
                running_sum += it->ff * it->ss;
                high.insert(*it);
                low.erase(it);
            }
            freq[a] += v;
            if(freq[a] == 0) freq.erase(a);
            else {
                high.insert(MP(freq[a], a));
                running_sum += freq[a] * a;
            }
            while(high.size() > x) {
                auto it = high.begin();
                running_sum -= it->ff * it->ss;
                low.insert(*it);
                high.erase(it);
            }
            while(!low.empty() && high.size() < x) {
                auto it = prev(low.end());
                running_sum += it->ff * it->ss;
                high.insert(*it);
                low.erase(it);
            }
        };
        vll res;
        for(int i = 0; i < n; i++) {
            modify(nums[i], 1);
            if(i >= k - 1) {
                if(i >= k) {
                    modify(nums[i - k], -1);
                }
                res.push_back(running_sum);
            }
        } 
        return res;
    }
};",1420561049
tl2001,user1838wc,98,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        unordered_map<int, int> mp;
        vector<int> res;
        for(int i = 0; i < n; i++) {
            mp[nums[i]]++;
            if(i >= k - 1) {
                if(i >= k) {
                    if(--mp[nums[i - k]] == 0) mp.erase(nums[i - k]);
                }
                priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;
                for(auto& it : mp) {
                    minHeap.push({it.second, it.first});
                    if(minHeap.size() > x) minHeap.pop();
                }
                int sm = 0;
                while(!minHeap.empty()) {
                    sm += minHeap.top().first * minHeap.top().second;
                    minHeap.pop();
                }
                res.push_back(sm);
            }
        }
        return res;
    }
};",1420523044
SR3mix,SR3mix,99,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>sz;
    int check(TreeNode* curr) {
        if (!curr) return 0;
        
        int v1 = check(curr->left);
        int v2 = check(curr->right);
        if (v1 == -1 || v2 == -1 || (v1 != v2)) return -1;
        
        
        int nv = v1 + 1;
        int get = (1 << nv) - 1;
        sz.push_back(get);
        return nv;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sz = {};
        check(root);
        sort(sz.begin(), sz.end());
        reverse(sz.begin(), sz.end());
        if (sz.size() < k) return -1;
        return sz[k-1];
    }
};",1420538398
SR3mix,SR3mix,99,3588,cpp,"typedef long long ll;
ll M = 1e9 + 7;
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        vector<vector<ll>>dp(2 * n+1, vector<ll>(3));
        vector<vector<ll>>ndp = dp;
        if (s[0] == 'F') {
            dp[n][0] = 1;
            dp[n+1][1] = 1;
            dp[n-1][2] = 1;
        }
        else if (s[0] == 'W') {
            dp[n-1][0] = 1;
            dp[n][1] = 1;
            dp[n+1][2] = 1;
        }
        else {
            dp[n+1][0] = 1;
            dp[n-1][1] = 1;
            dp[n][2] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = -n; j <= n; j++) {
                if (s[i] == 'F') {
                    ndp[j+n][0] = dp[j+n][1] + dp[j+n][2];
                    if (j > -n) ndp[j+n][1] = dp[j+n-1][0] + dp[j+n-1][2];
                    if (j < n) ndp[j+n][2] = dp[j+n+1][0] + dp[j+n+1][1];
                }
                else if (s[i] == 'W') {
                    if (j < n) ndp[j+n][0] = dp[j+n+1][1] + dp[j+n+1][2];
                    ndp[j+n][1] = dp[j+n][0] + dp[j+n][2];
                    if (j > -n) ndp[j+n][2] = dp[j+n-1][0] + dp[j+n-1][1];
                }
                else {
                    if (j > -n) ndp[j+n][0] = dp[j+n-1][1] + dp[j+n-1][2];
                    if (j < n) ndp[j+n][1] = dp[j+n+1][0] + dp[j+n+1][2];
                    ndp[j+n][2] = dp[j+n][0] + dp[j+n][1];
                }
                for (int k = 0; k < 3; k++) {
                    ndp[j+n][k] %= M;
                }
            }
            dp = ndp;
            ndp = vector<vector<ll>>(2 * n + 1, vector<ll>(3));
        }
        ll ans = 0;
        for (int i = n+1; i <= 2 * n; i++) {
            for (int j = 0; j < 3; j++) {
                ans = (ans + dp[i][j])%M;
            }
        }
        return ans;
    }
};",1420534010
SR3mix,SR3mix,99,3592,cpp,"// OrderedMultiset
#include <ext/pb_ds/assoc_container.hpp> 
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template <typename T> 
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;
template <typename T> struct OrderedMultiset {
    ordered_set<pair<T, int>> s;
    map<T, int> m;
    void insert(T element) {
        int count = m[element];
        pair<T, int> p = {element,count};
        m[element]++;
        s.insert(p);
    }
    void erase(T element) {
        if (m.find(element) == m.end()) return;
        int count = m[element];
        if (count == 1) m.erase(element);
        else m[element] = count-1;
        pair<T, int> eraseP = {element, count-1};
        s.erase(eraseP);
    }
    int upper_bound(T element) {return s.order_of_key({element, INT_MAX});}
    int lower_bound(T element) {return s.order_of_key({element, -1});}
    T atIndex(int index) {return (*s.find_by_order(index)).first;}
    bool exists(T element) {return m.find(element) != m.end();}
    int occurences(T element) {if (m.find(element) == m.end()) {return 0;} return m[element];}
};
typedef long long ll;
class Solution {
public:
    void printp(pair<ll, ll>p) {
        cout << p.first << "","" << p.second << endl;
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<ll, ll>m; int n = nums.size();
        for (int i = 0; i < k; i++) {
            m[nums[i]]++;
        }
        vector<array<ll, 2>>tv;
        OrderedMultiset<pair<ll, ll>>oms;
        for (auto i : m) {
            tv.push_back({i.second, i.first});
            oms.insert({-i.second, -i.first});
        }
        ll curr = 0;
        sort(tv.begin(), tv.end());
        reverse(tv.begin(), tv.end());
        int tn = tv.size();
        for (int i = 0; i < min(tn, x); i++) {
            curr += tv[i][0] * tv[i][1];
        }
        int csz = m.size();
        pair<ll, ll> atk = {1,1};
        if (csz >= x) atk = oms.atIndex(x-1);
        vector<ll>ans = {curr};
        for (int i = 1; i < n-k+1; i++) {
            int rem = nums[i-1];
            int add = nums[i+k-1];
            ll orem = m[rem];
            pair<ll, ll> rop = {-orem,-rem};
            pair<ll, ll> rnp = {-orem+1,-rem};
            m[rem]--; 
            if (m[rem] == 0) {
                m.erase(rem);
            }
            oms.erase(rop);
            // curr -= (rop.first * rop.second);
            if (m.find(rem) != m.end()) {
                oms.insert(rnp);
            }
            
            pair<ll, ll> aop = {-m[add], -add};
            pair<ll, ll> anp = {-m[add]-1,-add};
            m[add]++;
            if (m[add] > 1) {
                oms.erase(aop);
            }
            oms.insert(anp);
            
            int nsz = m.size();
            pair<ll, ll>catk = {1,1};
            if (nsz >= x) catk = oms.atIndex(x-1);
            if (catk < atk) {
                if (atk.first <= 0 && atk != aop && atk != rop) curr -= (atk.first * atk.second);
            }
            else if (catk > atk) {
                if (catk.first <= 0 && catk != anp && catk != rnp) curr += (catk.first * catk.second);
            }
            if (anp <= catk) curr += (anp.first * anp.second);
            if (rnp <= catk) curr += (rnp.first * rnp.second);
            if (aop <= atk) curr -= (aop.first * aop.second);
            if (rop <= atk) curr -= (rop.first * rop.second);
            
//             for (auto i : m) {
//                 cout << i.first << "","" << i.second << endl;
//             }
//             cout << ""curr: "" << curr << endl;
//             cout << ""catk:""; printp(catk);
//             cout << ""atk:""; printp(atk);
//             cout << endl;
            
//             for (int i = 0; i < nsz; i++) {
//                 printp(oms.atIndex(i));
//             }
//             cout << endl;
            
            ans.push_back(curr);
            atk = catk;
        }
        return ans;
    }
};",1420584314
SR3mix,SR3mix,99,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int>ans; int n = nums.size();
        for (int i = 0; i < n-k+1; i++) {
            map<int, int> m;
            for (int j = i; j < i + k; j++) {
                m[nums[j]]++;
            }
            vector<array<int, 2>>v;
            for (auto &i : m) v.push_back({i.second, i.first});
            sort(v.begin(), v.end());
            reverse(v.begin(), v.end());
            int tn = v.size();
            int res = 0;
            for (int i = 0; i < min(tn, x); i++) {
                res += v[i][0] * v[i][1];
            }
            ans.push_back(res);
        }
        return ans;
    }
};",1420541112
Hayford08,Hayford08,100,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    const int MX = 2000;
    unordered_set<int> st;
    vector<int> res;
    int dfs(TreeNode *node){
        if (!node){
            return 0;
        }
        int l = dfs(node->left);
        int r = dfs(node->right);
        bool okl = l == 0 || st.count(l);
        bool okr = r == 0 || st.count(r);
        if (okr && okr && l == r){
            int sz = 1 + l + r;
            res.push_back(sz);
            return sz;
        }
        return -1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        st.clear();
        res.clear();
        int curr = 0;
        int pwr = 1;
        while (curr <= MX){
            curr += pwr;
            st.insert(curr);
            pwr *= 2;
        }
        dfs(root);
        if (res.size() < k){
            return -1;
        }
        sort(res.rbegin(), res.rend());
        return res[k - 1];
    }
};",1420533177
Hayford08,Hayford08,100,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    const char BOB[3] = {'F', 'W', 'E'};
    int countWinningSequences(string s) {
        int n = s.size();
        int BASE = n + 1;
        vector<vector<long long>> dp[3];
        for (int i = 0; i < 3; i++){
            dp[i] = vector<vector<long long>>(n, vector<long long>(BASE + n, -1));
        }

        function<long long(int, int, int)> solve = [&](int i, int pts, int pv) -> long long {
            if (i == n){
                return pts > 0;
            }
            long long res = dp[pv][i][pts + BASE];
            if (res != -1){
                return res;
            }
            res = 0;
            char alice = s[i];
            for (int j = 0; j < 3; j++){
                if (i != 0 && j == pv) continue;
                char bob = BOB[j];
                int npt = pts;
                if (bob != alice){
                    if (bob == 'F' && alice == 'E'){
                        npt++;
                    }
                    else if (alice == 'F' && bob == 'E'){
                        npt--;
                    }
                    else if (bob == 'W' && alice == 'F'){
                        npt++;
                    }
                    else if (alice == 'W' && bob == 'F'){
                        npt--;
                    }
                    else if (bob == 'E' && alice == 'W'){
                        npt++;
                    }
                    else {
                        npt--;
                    }
                }
                res = (res + solve(i + 1, npt, j)) % MOD;
            }
            return dp[pv][i][pts + BASE] = res;
        };
        return solve(0, 0, 0);
    }
};",1420557923
Hayford08,Hayford08,100,3592,cpp,"struct TopX {
    set<pair<int, int>> left, right;
    long long val;
    int x;
    TopX(int x) {
        val = 0;
        this->x = x;
    }

    void rebalance() {
        while (left.size() && right.size() < x){
            auto it = prev(left.end());
            auto pr = *it;
            val += 1ll * pr.first * pr.second;
            right.insert(pr);
            left.erase(it);
        }

        while (left.size() && right.size()){
            auto itl = prev(left.end());
            auto itr = right.begin();
            if ((*itl) > (*itr)){
                auto [lf, lk] = *itl;
                auto [rf, rk] = *itr;
                val -= 1ll * rf * rk;
                val += 1ll * lf * lk;
                left.erase(itl);
                right.erase(itr);
                left.insert({rf, rk});
                right.insert({lf, lk});
            }
            else {
                break;
            }
        }
    }

    void remove(const pair<int, int> &pr) {
        auto it = left.find(pr);
        if (it != left.end()){
            left.erase(it);
            return;
        }
        it = right.find(pr);
        if (it != right.end()){
            val -= 1ll * pr.first * pr.second;
            right.erase(it);
            rebalance();
        }
    }

    void insert(const pair<int, int> &pr){
        left.insert(pr);
        rebalance();
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        TopX topx(x);
        unordered_map<int, int> mp;
        for (int i = 0; i < k - 1; i++){
            int a = nums[i];
            auto it = mp.find(a);
            if (it == mp.end()){
                mp[a] = 1;
                topx.insert({1, a});
            }
            else {
                topx.remove({it->second, it->first});
                it->second++;
                topx.insert({it->second, it->first});
            }
        }
        
        vector<long long> res;
        for (int i = k - 1, n = nums.size(); i < n; i++){
            int a = nums[i];
            auto it = mp.find(a);
            if (it == mp.end()){
                mp[a] = 1;
                topx.insert({1, a});
            }
            else {
                topx.remove({it->second, it->first});
                it->second++;
                topx.insert({it->second, it->first});
            }

            res.push_back(topx.val);

            a = nums[i - k + 1];
            it = mp.find(a);
            topx.remove({it->second, it->first});
            it->second--;
            if (it->second > 0){
                topx.insert({it->second, it->first});
            }
        }
        return res;
    }
};",1420591639
Hayford08,Hayford08,100,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        auto xsum = [&](int idx) -> int {
            unordered_map<int, int> mp;
            for (int i = 0; i < k; i++){
                mp[nums[idx + i]]++;
            }
            priority_queue<pair<int, int>> max_heap;
            for (const auto &[key, v] : mp){
                max_heap.push({v, key});
            }
            int res = 0;
            for (int i = 0; i < x && max_heap.size(); i++){
                auto [f, key] = max_heap.top(); max_heap.pop();
                res += f * key;
            }
            return res;
        };
        int sz = n - k + 1;
        vector<int> res(sz);
        for (int i = 0; i < sz; i++) {
            res[i] = xsum(i);
        }
        return res;
    }
};",1420522722
InfiniteLoops,ShriyamThor,101,3509,cpp,"

/*

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
*/
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        
  
        function<pair<bool, int>(TreeNode*)> helper = [&](TreeNode* node) -> pair<bool, int> {
            if (!node) {
          
                return {true, 0};
            }
            if (!node->left && !node->right) {
       
                sizes.push_back(1);
                return {true, 1};
            }
            
  
            auto left = helper(node->left);
            auto right = helper(node->right);
            
       
            if (left.first && right.first && left.second == right.second) {
                int currentDepth = left.second + 1;
                int currentSize = (1 << currentDepth) - 1; 
                sizes.push_back(currentSize);
                return {true, currentDepth};
            }
            
   
            return {false, 0};
        };
        
    
        helper(root);
        
    
        sort(sizes.begin(), sizes.end(), greater<int>());
        
    
        if (k <= sizes.size()) {
            return sizes[k-1];
        }
        return -1;
    }
};
",1420571517
InfiniteLoops,ShriyamThor,101,3588,cpp,"#include <vector>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
    const int MOD = 1000000007;
    

    bool beats(char a, char b) {
        return (a == 'F' && b == 'E') || 
               (a == 'W' && b == 'F') || 
               (a == 'E' && b == 'W');
    }
    
    int countWinningSequences(string s) {
        int n = s.length();
       
        vector<vector<long long>> current(4, vector<long long>(2 * n + 1, 0));
        vector<vector<long long>> nextDP(4, vector<long long>(2 * n + 1, 0));
        
     
        current[0][n] = 1;
        
        for(int i = 0; i < n; ++i){
        
            for(int lm = 0; lm < 4; ++lm){
                fill(nextDP[lm].begin(), nextDP[lm].end(), 0LL);
            }
            
            for(int last_move = 0; last_move < 4; ++last_move){
                for(int diff = 0; diff <= 2 * n; ++diff){
                    if(current[last_move][diff] == 0) continue;
                    
             
                    for(char move : {'F', 'W', 'E'}){
                        int current_move;
                        if(move == 'F') current_move = 1;
                        else if(move == 'W') current_move = 2;
                        else current_move = 3;
                        
                 
                        if(current_move == last_move) continue;
                        
               
                        char alice_move = s[i];
                        char bob_move = move;
                        int point_change = 0;
                        if(beats(bob_move, alice_move)){
                            point_change = 1;
                        }
                        else if(beats(alice_move, bob_move)){
                            point_change = -1;
                        }
               
                        
                        int new_diff = diff + point_change;
                 
                        if(new_diff < 0 || new_diff > 2 * n) continue;
                        
                        nextDP[current_move][new_diff] += current[last_move][diff];
                        if(nextDP[current_move][new_diff] >= MOD){
                            nextDP[current_move][new_diff] -= MOD;
                        }
                    }
                }
            }
 
            current.swap(nextDP);
        }
        
      
        long long result = 0;
        for(int last_move = 1; last_move <= 3; ++last_move){
            for(int diff = n + 1; diff <= 2 * n; ++diff){
                result += current[last_move][diff];
                if(result >= MOD){
                    result -= MOD;
                }
            }
        }
        
        return static_cast<int>(result);
    }
};
",1420575728
InfiniteLoops,ShriyamThor,101,3592,cpp,"

struct cmp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const{
        if(a.first != b.first) return a.first > b.first;
        return a.second > b.second;
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        if(n < k) return answer;
        
        
        unordered_map<int, int> freq_map;
        
        
        multiset<pair<int, int>, cmp> top_x_elements;
        multiset<pair<int, int>, cmp> sorted_elements;
        
       
        unordered_set<int> in_top_x;
        
        long long sum_x = 0;
        
       
        for(int i = 0; i < k; ++i){
            freq_map[nums[i]]++;
        }
        
        
        for(auto &p : freq_map){
            sorted_elements.emplace(p.second, p.first);
        }
        
         
        auto it = sorted_elements.begin();
        for(int i = 0; i < x && it != sorted_elements.end(); ++i, ++it){
            top_x_elements.emplace(*it);
            sum_x += (long long)(it->first) * (it->second);
            in_top_x.insert(it->second);
        }
        
       
        sorted_elements.erase(sorted_elements.begin(), it);
        
        
        answer.push_back(sum_x);
        
        
        for(int i = k; i < n; ++i){
             
            int left_val = nums[i - k];
            int left_freq = freq_map[left_val];
            
            
            if(in_top_x.find(left_val) != in_top_x.end()){
               
                top_x_elements.erase(top_x_elements.find({left_freq, left_val}));
                sum_x -= (long long)(left_freq) * (left_val);
                in_top_x.erase(left_val);
                
                
                freq_map[left_val]--;
                if(freq_map[left_val] > 0){
                   
                    sorted_elements.emplace(freq_map[left_val], left_val);
                }
                
                
                if(!sorted_elements.empty()){
                    auto next_it = sorted_elements.begin();
                    top_x_elements.emplace(*next_it);
                    sum_x += (long long)(next_it->first) * (next_it->second);
                    in_top_x.insert(next_it->second);
                    sorted_elements.erase(next_it);
                }
            }
            else{
               
                sorted_elements.erase(sorted_elements.find({left_freq, left_val}));
                
                
                freq_map[left_val]--;
                if(freq_map[left_val] > 0){
                    sorted_elements.emplace(freq_map[left_val], left_val);
                }
            }
            
           
            int right_val = nums[i];
            int prev_freq = freq_map[right_val];
            
            
            if(freq_map.find(right_val) != freq_map.end() && freq_map[right_val] > 0){
                if(in_top_x.find(right_val) != in_top_x.end()){
                    top_x_elements.erase(top_x_elements.find({prev_freq, right_val}));
                    sum_x -= (long long)(prev_freq) * (right_val);
                    in_top_x.erase(right_val);
                }
                else{
                    sorted_elements.erase(sorted_elements.find({prev_freq, right_val}));
                }
            }
            
          
            freq_map[right_val]++;
            int new_freq = freq_map[right_val];
            
           
            if((int)top_x_elements.size() < x){
                top_x_elements.emplace(new_freq, right_val);
                sum_x += (long long)(new_freq) * (right_val);
                in_top_x.insert(right_val);
            }
            else{
               
                auto smallest = prev(top_x_elements.end());
                pair<int, int> smallest_pair = *smallest;
                
                if(new_freq > smallest_pair.first || (new_freq == smallest_pair.first && right_val > smallest_pair.second)){
                    
                    top_x_elements.emplace(new_freq, right_val);
                    sum_x += (long long)(new_freq) * (right_val);
                    in_top_x.insert(right_val);
                    
              
                    top_x_elements.erase(smallest);
                    sum_x -= (long long)(smallest_pair.first) * (smallest_pair.second);
                    in_top_x.erase(smallest_pair.second);
                    sorted_elements.emplace(smallest_pair.first, smallest_pair.second);
                }
                else{
               
                    sorted_elements.emplace(new_freq, right_val);
                }
            }
            
       
            answer.push_back(sum_x);
        }
        
        return answer;
    }
};
",1420586021
InfiniteLoops,ShriyamThor,101,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>
#include <set>

using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        for(int i = 0; i <= n - k; ++i){
            unordered_map<int, int> freq;
            for(int j = i; j < i + k; ++j){
                freq[nums[j]]++;
            }
            vector<pair<int, int>> elements;
            for(auto &p : freq){
                elements.emplace_back(make_pair(-p.second, -p.first));
            }
            sort(elements.begin(), elements.end());
            set<int> topElements;
            for(int m = 0; m < min(x, (int)elements.size()); ++m){
                topElements.insert(-elements[m].second);
            }
            int sum = 0;
            for(int j = i; j < i + k; ++j){
                if(topElements.find(nums[j]) != topElements.end()){
                    sum += nums[j];
                }
            }
            answer.push_back(sum);
        }
        return answer;
    }
};
",1420560477
Asher,Night_Shade,103,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        ans = []
        def dfs(root):
            if root is None:
                ans.append(0)
                return [0]
            if root.left is None and root.right is None:
                ans.append(1)
                return [1]
            l = dfs(root.left)
            r = dfs(root.right)
            if len(l) == 1 and len(r) == 1:
                if l[0] == r[0]:
                    ans.append(l[0]+r[0]+1)
                    return [l[0]+r[0]+1]
            return l+r
        
        dfs(root)
        ans = [x for x in ans if x!=0]
        ans.sort(reverse=True)
        # print(ans)
        if k > len(ans):
            return -1
        return ans[k-1]
        ",1420525786
Asher,Night_Shade,103,3588,python3,"# dp[n][card][point] = # methods in n-th round ends with card with point
# 1e3 x 3 x 2e3
# = dp[n-1][!card][point-1] or point + 1 or point

class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        # points from -n to n
        dp = collections.defaultdict(int)
        win = dict()
        lose = dict()
        valid = dict()
        win['F'] = 'W' # F->W
        win['W'] = 'E'
        win['E'] = 'F'
        
        lose['W'] = 'F' # F->W
        lose['E'] = 'W'
        lose['F'] = 'E'
        
        valid['F'] = ['W','E']
        valid['W'] = ['F','E']
        valid['E'] = ['W','F']
        
        dp[(0,s[0],0)]=1
        dp[(0,win[s[0]],1)]=1
        dp[(0,lose[s[0]],-1)]=1
        
        MOD = int(1e9+7)
        
        for i in range(1,n):
            for point in range(-n,n+1):
                # case1. win card = win[s[i]]
                # last valid card := valid[win[s[i]]]
                for last_card in valid[win[s[i]]]:
                    if (i-1,last_card,point) in dp:
                        dp[(i,win[s[i]],point+1)] =( dp[(i-1,last_card,point)]+dp[(i,win[s[i]],point+1)])%MOD
                # case2. draw card = s[i]
                for last_card in valid[s[i]]:
                    if (i-1,last_card,point) in dp:
                        dp[(i,s[i],point)] =( dp[(i-1,last_card,point)]+dp[(i,s[i],point)])%MOD
                # case3. lose card = lose[s[i]]
                for last_card in valid[lose[s[i]]]:
                    if (i-1,last_card,point) in dp:
                        dp[(i,lose[s[i]],point-1)] =( dp[(i-1,last_card,point)]+dp[(i,lose[s[i]],point-1)])%MOD
        
        ans = 0
        for point in range(1,n+1):
            for last_card in 'FWE':
                if (n-1,last_card,point) in dp:
                    ans = (ans+dp[(n-1,last_card,point)])%MOD
        return ans
                
                
        ",1420541002
Asher,Night_Shade,103,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        if n < k or k == 0:
            return ans
        
        freq = defaultdict(int)
        for i in range(k):
            freq[nums[i]] += 1
        
        sorted_list = sorted([(-count, -num) for num, count in freq.items()])
        sum_top_x = sum((-cnt) * (-val) for cnt, val in sorted_list[:x])
        ans.append(sum_top_x)
        
        for i in range(k, n):
            out_num = nums[i - k]
            in_num = nums[i]
            
            # Handle outgoing element
            out_tuple = (-freq[out_num], -out_num)
            idx_out = bisect.bisect_left(sorted_list, out_tuple)
            if idx_out < len(sorted_list) and sorted_list[idx_out] == out_tuple:
                if idx_out < x:
                    sum_top_x -= (-sorted_list[idx_out][1]) * (-sorted_list[idx_out][0])
                    if x < len(sorted_list):
                        sum_top_x += (-sorted_list[x][1]) * (-sorted_list[x][0])
                sorted_list.pop(idx_out)
            
            freq[out_num] -= 1
            if freq[out_num] == 0:
                del freq[out_num]
            else:
                new_out_tuple = (-freq[out_num], -out_num)
                bisect.insort_left(sorted_list, new_out_tuple)
                idx_new_out = bisect.bisect_left(sorted_list, new_out_tuple)
                if idx_new_out < x:
                    sum_top_x += (-sorted_list[idx_new_out][1]) * (-sorted_list[idx_new_out][0])
                    if x < len(sorted_list):
                        sum_top_x -= (-sorted_list[x][1]) * (-sorted_list[x][0])
            if in_num in freq:
                in_tuple = (-freq[in_num], -in_num)
                idx_in = bisect.bisect_left(sorted_list, in_tuple)
                if idx_in < len(sorted_list) and sorted_list[idx_in] == in_tuple:
                    if idx_in < x:
                        sum_top_x -= (-sorted_list[idx_in][1]) * (-sorted_list[idx_in][0])
                        if x < len(sorted_list):
                            sum_top_x += (-sorted_list[x][1]) * (-sorted_list[x][0])
                    sorted_list.pop(idx_in)
            
            freq[in_num] += 1
            new_in_tuple = (-freq[in_num], -in_num)
            bisect.insort_left(sorted_list, new_in_tuple)
            idx_new_in = bisect.bisect_left(sorted_list, new_in_tuple)
            if idx_new_in < x:
                sum_top_x += (-sorted_list[idx_new_in][1]) * (-sorted_list[idx_new_in][0])
                if x < len(sorted_list):
                    sum_top_x -= (-sorted_list[x][1]) * (-sorted_list[x][0])
            
            ans.append(sum_top_x)
        
        return ans
",1420574605
Asher,Night_Shade,103,3610,python3,"# n = 1e5
# k = n/2
# x = k/2
# n^2
# nlogn
# q = [(freq,val), .....]
# r ++
# linked list?

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        ans = []
        n = len(nums)
        for i in range(n):
            if i+k <= n:
                cnt = collections.Counter(nums[i:i+k])
                tmp = list(set(nums[i:i+k]))
                tmp.sort(key = lambda t:(cnt[t],t), reverse=True)
                # ans.append(sum(tmp[:x]))
                t_sum = 0
                for i in range(x):
                    if i<len(tmp):
                        t_sum += tmp[i]*cnt[tmp[i]]
                ans.append(t_sum)
        return ans
        ",1420558574
geng102810,geng102810,106,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#define all(x) x.begin(),x.end()
#define pb push_back
class Solution {
public:
    std::vector<int> q;

    std::array<int,2> dfs(TreeNode *u){
        std::array<int,2> l={-1,-1},r={-1,-1};
        if(u->left!=nullptr) l=dfs(u->left);
        if(u->right!=nullptr) r=dfs(u->right);
        if(l[0]==-1 and r[0]==-1){
            q.pb(1);
            return {1,1};
        }else if(l[0]==-1) return {0,0};
        else if(r[0]==-1) return {0,0};
        if(l[0]==1 and r[0]==1 and l[1]==r[1]){
            q.pb(l[1]+r[1]+1);
            return {1,l[1]+r[1]+1};
        }
        return {0,0};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(all(q),std::greater<>());
        if(q.size()<k) return -1;
        return q[k-1];
    }
};",1420531581
geng102810,geng102810,106,3588,cpp,"template <unsigned M_> struct ModInt {
  static constexpr unsigned M = M_;
  unsigned x;
  constexpr ModInt() : x(0U) {}
  constexpr ModInt(unsigned x_) : x(x_ % M) {}
  constexpr ModInt(unsigned long long x_) : x(x_ % M) {}
  constexpr ModInt(int x_) : x(((x_ %= static_cast<int>(M)) < 0) ? (x_ + static_cast<int>(M)) : x_) {}
  constexpr ModInt(long long x_) : x(((x_ %= static_cast<long long>(M)) < 0) ? (x_ + static_cast<long long>(M)) : x_) {}
  ModInt &operator+=(const ModInt &a) { x = ((x += a.x) >= M) ? (x - M) : x; return *this; }
  ModInt &operator-=(const ModInt &a) { x = ((x -= a.x) >= M) ? (x + M) : x; return *this; }
  ModInt &operator*=(const ModInt &a) { x = (static_cast<unsigned long long>(x) * a.x) % M; return *this; }
  ModInt &operator/=(const ModInt &a) { return (*this *= a.inv()); }
  ModInt pow(long long e) const {
    if (e < 0) return inv().pow(-e);
    ModInt a = *this, b = 1U; for (; e; e >>= 1) { if (e & 1) b *= a; a *= a; } return b;
  }
  ModInt inv() const {
    unsigned a = M, b = x; int y = 0, z = 1;
    for (; b; ) { const unsigned q = a / b; const unsigned c = a - q * b; a = b; b = c; const int w = y - static_cast<int>(q) * z; y = z; z = w; }
    assert(a == 1U); return ModInt(y);
  }
  ModInt operator+() const { return *this; }
  ModInt operator-() const { ModInt a; a.x = x ? (M - x) : 0U; return a; }
  ModInt operator+(const ModInt &a) const { return (ModInt(*this) += a); }
  ModInt operator-(const ModInt &a) const { return (ModInt(*this) -= a); }
  ModInt operator*(const ModInt &a) const { return (ModInt(*this) *= a); }
  ModInt operator/(const ModInt &a) const { return (ModInt(*this) /= a); }
  template <class T> friend ModInt operator+(T a, const ModInt &b) { return (ModInt(a) += b); }
  template <class T> friend ModInt operator-(T a, const ModInt &b) { return (ModInt(a) -= b); }
  template <class T> friend ModInt operator*(T a, const ModInt &b) { return (ModInt(a) *= b); }
  template <class T> friend ModInt operator/(T a, const ModInt &b) { return (ModInt(a) /= b); }
  explicit operator bool() const { return x; }
  bool operator==(const ModInt &a) const { return (x == a.x); }
  bool operator!=(const ModInt &a) const { return (x != a.x); }
  bool operator<(const ModInt &a) const { return (x < a.x); }
  bool operator>(const ModInt &a) const { return (x > a.x); }
  bool operator<=(const ModInt &a) const { return (x <= a.x); }
  bool operator>=(const ModInt &a) const { return (x >= a.x); }
  friend std::ostream &operator<<(std::ostream &os, const ModInt &a) { return os << a.x; }
  friend std::istream &operator>>(std::istream &is, ModInt &a) {int v;is >> v;a = ModInt(v);return is;}
};
constexpr unsigned MO = 1000000007;
using Mint = ModInt<MO>;

class Solution {
public:
    int countWinningSequences(string s) {
        int n=s.size();
        Mint f[n+2][3][2010];
        for(int i=0;i<=n;i++){
            for(int j=0;j<3;j++){
                for(int k=0;k<=2000;k++) f[i][j][k]=0;
            }
        }
        f[0][0][1000]=1;
        f[0][1][1000]=1;
        f[0][2][1000]=1;

        std::map<char,int> q={{'F',1},{'E',0},{'W',2}};

        for(int i=1;i<=n;i++){
            int v=q[s[i-1]];
            for(int j=0;j<3;j++){
                int cnt=((v+1)%3==j ? 1 : v==j ? 0 : -1);
                for(int k=0;k<=2000;k++){
                    int la=k-cnt;
                    if(la<0 or la>2000) continue;
                    for(int l=0;l<3;l++){
                        if(l==j) continue;
                        f[i][j][k]+=f[i-1][l][la];
                    }
                }
            }
        }
        
        Mint res=0;
        for(int i=1001;i<=2000;i++){
            res+=f[n][0][i];
            res+=f[n][1][i];
            res+=f[n][2][i];
        }
        res/=2;
        return res.x;
    }
};",1420551131
geng102810,geng102810,106,3592,cpp,"#include <bits/extc++.h>
using namespace __gnu_cxx;
using namespace __gnu_pbds;
using kth_tree = __gnu_pbds::tree<std::array<long long,2>, null_type, std::greater<>, rb_tree_tag, tree_order_statistics_node_update>;
#define all(x) x.begin(),x.end()
#define pb push_back
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int sz) {
        std::vector<long long> res;
        int n=nums.size();
        std::map<int,int> q;
        kth_tree tr;
        long long sum=0;

        auto remove=[&](std::array<long long,2> &la){
            if(la[0]>=1){
                if(tr.size()<=sz) tr.erase(la),sum-=la[0]*la[1];
                else{
                    auto idx=tr.order_of_key(la);
                    if(idx<sz){
                        auto it=tr.find_by_order(sz);
                        sum+=(*it)[0]*(*it)[1];
                        tr.erase(la),sum-=la[0]*la[1];
                    }else tr.erase(la);
                    
                }
            }
        };

        auto insert=[&](std::array<long long,2> &la){
            tr.insert(la);
            if(tr.size()>sz){
                auto id=tr.order_of_key(la);
                if(id<sz){
                    auto it=tr.find_by_order(sz);
                    sum-=(*it)[0]*(*it)[1];
                    sum+=la[0]*la[1];
                }
            }else sum+=la[0]*la[1];
        };

        auto add=[&](int x,int v){
            std::array<long long,2> la={q[x],x};
            remove(la);
            q[x]+=v;
            if(!q[x]) return;
            la[0]=q[x];
            insert(la);
        };

        for(int i=0,j=0;i<n;i++){
            if(i<k-1) add(nums[i],1);
            else{
                add(nums[i],1);
                res.pb(sum);
                add(nums[j],-1);
                j++;
            }
        }
        return res;
    }
};",1420593650
geng102810,geng102810,106,3610,cpp,"#define all(x) x.begin(),x.end()
#define pb push_back
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int t) {
        std::vector<int> res;
        int n=nums.size();

        for(int i=0;i+k-1<n;i++){
            std::vector<int> q;
            for(int j=i;j<i+k;j++){
                q.pb(nums[j]);
            }
            std::map<int,int> mp;
            for(auto x:q) mp[x]++;
            std::vector<std::array<int,2>> cnt;
            for(auto [u,v]:mp) cnt.pb({v,u});
            sort(all(cnt),std::greater<>());
            std::set<int> s;
            for(int j=0;j<std::min(t,(int)cnt.size());j++) s.insert(cnt[j][1]);
            int sum=0;
            for(auto c:q) if(s.count(c)) sum+=c;
            res.pb(sum);
        }
        return res;
    }
};",1420522104
mui-mit-hanni,mui-mit-hanni,107,3509,cpp,"class Solution {
public:
    pair<bool, int> dfs(TreeNode* node, vector<int>& sizes) {
        if (!node) return {true, 0}; 
        auto [lp, ls] = dfs(node->left, sizes);
        auto [rp, rs] = dfs(node->right, sizes);
        if (lp && rp && ls == rs) {
            int cs = ls + rs + 1;
            sizes.push_back(cs); 
            return {true, cs};
        }
        return {false, 0};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes; 
        dfs(root, sizes); 
        sort(sizes.rbegin(), sizes.rend());
        if (k > sizes.size()) return -1;
        return sizes[k - 1]; 
    }
};",1420528296
mui-mit-hanni,mui-mit-hanni,107,3588,cpp,"
class Solution {
public:
    const int MOD = 1e9 + 7;
    
    int getIndex(char c) {
        if (c == 'F') return 0;
        if (c == 'W') return 1;
        return 2;
    }

    int win(char bob, char alice) {
        if (bob == 'F' && alice == 'E') return 1;
        if (bob == 'W' && alice == 'F') return 1;
        if (bob == 'E' && alice == 'W') return 1;
        if (bob == alice) return 0;
        return -1; 
    }

    int countWinningSequences(string s) {
        int n = s.size();
        int offset = n; 
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2 * n + 1, vector<int>(3, 0)));
        if(s[0]=='F'){
            dp[1][n][0]=1;
            dp[1][n+1][1]=1;
            dp[1][n-1][2]=1;
        }
        else if(s[0]=='W'){
            dp[1][n-1][0]=1;
            dp[1][n][1]=1;
            dp[1][n+1][2]=1;
        }
        else{ 
            dp[1][n+1][0]=1;
            dp[1][n-1][1]=1;
            dp[1][n][2]=1;
        }
        for (int i = 2; i <= n; ++i) {
            char aliceMove = s[i - 1]; 
            int aliceIdx = getIndex(aliceMove);
            for (int diff = -n; diff <= n; ++diff) {
                for (int prev = 0; prev < 3; ++prev) { 
                    if (dp[i - 1][diff + n][prev] == 0) continue;
                    for (int curr = 0; curr < 3; ++curr) { 
                        if (curr == prev) continue; 
                        char bobMove = (curr == 0 ? 'F' : (curr == 1 ? 'W' : 'E'));
                        int result = win(bobMove, aliceMove);
                        int newDiff = diff + result;
                        if (newDiff >= -n && newDiff <= n) {
                            dp[i][newDiff + offset][curr] = (dp[i][newDiff + offset][curr] + dp[i - 1][diff + offset][prev]) % MOD;
                        }
                    }
                }
            }
        }

        int result = 0;
        for (int diff = 1; diff <= n; ++diff) {
            for (int k = 0; k < 3; ++k) {
                result = (result + dp[n][diff + offset][k]) % MOD;
            }
        }

        return result;
    }
};
",1420551332
mui-mit-hanni,mui-mit-hanni,107,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer(n - k + 1, 0);
        map<int, int> freqMap;
        multiset<pair<long long, int>> topX;
        multiset<pair<long long, int>> rest;
        long long currentSum = 0; 
        auto add = [&](int num) {
            if (freqMap[num] > 0) {
                auto it = topX.find({freqMap[num], num});
                if (it != topX.end()) {
                    currentSum -= static_cast<long long>(it->first) * it->second; 
                    topX.erase(it);
                } else {
                    rest.erase({freqMap[num], num});
                }
            }
            freqMap[num]++;
            rest.insert({freqMap[num], num});  
            auto it = prev(rest.end());
            if (topX.size() < x) {
                currentSum += static_cast<long long>(it->first) * it->second; 
                topX.insert(*it);
                rest.erase(it);
            } else if (*it > *topX.begin()) {
                currentSum += static_cast<long long>(it->first) * it->second - static_cast<long long>(topX.begin()->first) * topX.begin()->second;
                rest.insert(*topX.begin());
                topX.erase(topX.begin());
                topX.insert(*it);
                rest.erase(it);
            }
        };
        
        auto remove = [&](int num) {
            auto it = topX.find({freqMap[num], num});
            if (it != topX.end()) {
                currentSum -= static_cast<long long>(it->first) * num; 
                topX.erase(it);
            } else {
                rest.erase({freqMap[num], num});
            }
            freqMap[num]--;
            if (freqMap[num] > 0) {
                rest.insert({freqMap[num], num});
            }
            if (topX.size() < x && !rest.empty()) {
                auto it = prev(rest.end());
                currentSum += static_cast<long long>(it->first) * it->second;
                topX.insert(*it);
                rest.erase(it);
            }
        };
        
        for (int i = 0; i < k; ++i) {
            add(nums[i]);
        }
        answer[0] = currentSum;
        
        for (int i = k; i < n; ++i) {
            remove(nums[i - k]);  
            add(nums[i]);         
            answer[i - k + 1] = currentSum; 
        }
        
        return answer;
    }
};
",1420587587
mui-mit-hanni,mui-mit-hanni,107,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int>res;
        int c[51];
        memset(c,0,sizeof(c));
        int n=nums.size();
        for(int i=0;i<k-1;i++){
            c[nums[i]]+=1;
        }
        for(int i=k-1;i<n;i++){
            c[nums[i]]+=1;
            if(i>=k) c[nums[i-k]]-=1;
            vector<pair<int,int>>p;
            for(int j=0;j<51;j++){
                p.push_back(make_pair(c[j],j));
            }
            sort(p.begin(), p.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
                if (a.first != b.first) 
                    return a.first > b.first;  
                return a.second > b.second;   
            });
            int ans=0;
            int u=p.size();
            for(int j=0;j<min(x,u);j++){
                ans+=p[j].first*p[j].second;
            }
            res.push_back(ans);
        }
        return res;
    }
};",1420524652
zsq007,zsq007,110,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(node: Optional[TreeNode]) -> int:
            if not node:
                return 0
            hl, hr = dfs(node.left), dfs(node.right)
            if hl == hr and hl != -1:
                h = hl + 1
                cntr[h] += 1
                return h
            return -1

        cntr = Counter()
        dfs(root)
        for h in sorted(cntr.keys(), reverse=True):
            if k <= cntr[h]:
                return (1<<h) - 1
            k -= cntr[h]
        return -1


",1420559557
zsq007,zsq007,110,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        # F > E > W > F
        n, mod = len(s), 10**9 + 7
        dp = [[0]*(2*n+2) for _ in range(3)]

        if s[0] == 'F':
            dp[0][0] = dp[1][-1] = dp[2][1] = 1
        elif s[0] == 'E':
            dp[1][0] = dp[2][-1] = dp[0][1] = 1
        else:
            dp[2][0] = dp[0][-1] = dp[1][1] = 1


        # for ddp in dp:
        #     print(ddp)
        # print()

        for c in s[1:]:
            prev = [ddp[:] for ddp in dp]
            if c == 'F':
                for k in range(n, -n-1, -1):
                    dp[0][k] = (prev[1][k] + prev[2][k]) % mod
                    dp[1][k] = (prev[0][k+1] + prev[2][k+1]) % mod
                    dp[2][k] = (prev[0][k-1] + prev[1][k-1]) % mod
            elif c == 'E':
                for k in range(n, -n-1, -1):
                    dp[1][k] = (prev[0][k] + prev[2][k]) % mod
                    dp[2][k] = (prev[0][k+1] + prev[1][k+1]) % mod
                    dp[0][k] = (prev[1][k-1] + prev[2][k-1]) % mod
            else:
                for k in range(n, -n-1, -1):
                    dp[2][k] = (prev[0][k] + prev[1][k]) % mod
                    dp[0][k] = (prev[1][k+1] + prev[2][k+1]) % mod
                    dp[1][k] = (prev[0][k-1] + prev[2][k-1]) % mod

            # print(c)
            # for ddp in dp:
            #     print(ddp)
            # print()

        # EF, WF, FE, WE, FW, EW

        return sum(sum(dp[i][1:n+1]) for i in range(3)) % mod",1420589296
zsq007,zsq007,110,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cntr, cntrList, n = Counter(), SortedList(), len(nums)

        ptr, topSum = 0, 0
        for num in nums[:k]:
            cntr[num] += 1
        
        cntrList = SortedList((-cnt, -num) for num,cnt in cntr.items())
        topSum = sum(num*cnt for num,cnt in cntrList[:x])
        res = [topSum]

        for i,num in enumerate(nums[k:]):
            if num == nums[i]:
                res.append(topSum)
                continue

            if (ind := cntrList.bisect_left((-cntr[nums[i]], -nums[i]))) >= x:
                cntrList.pop(ind)
                cntr[nums[i]] -= 1
                if cntr[nums[i]]:
                    cntrList.add((-cntr[nums[i]], -nums[i]))
                else:
                    cntr.pop(nums[i])
            else:
                topSum -= nums[i] * cntr[nums[i]]
                cntrList.pop(ind)
                cntr[nums[i]] -= 1
                if cntr[nums[i]]:
                    if cntrList.bisect_left((-cntr[nums[i]], -nums[i])) < x:
                        topSum += nums[i] * cntr[nums[i]]
                    elif len(cntrList) >= x:
                        newCnt, newNum = cntrList[x-1]
                        topSum += newCnt * newNum
                    cntrList.add((-cntr[nums[i]], -nums[i]))
                elif len(cntrList) >= x:
                    newCnt, newNum = cntrList[x-1]
                    topSum += newCnt * newNum


            if (ind := cntrList.bisect_left((-cntr[num], -num))) < x:
                topSum += num
                if ind < len(cntrList):
                    cntrList.pop(ind)
                cntr[num] += 1
                cntrList.add((-cntr[num], -num))
            else:
                if ind < len(cntrList):
                    cntrList.pop(ind)
                cntr[num] += 1
                cntrList.add((-cntr[num], -num))
                if cntrList.bisect_left((-cntr[num], -num)) < x:
                    oldCnt, oldNum = cntrList[x]
                    topSum -= oldCnt * oldNum
                    topSum += cntr[num]*num

            res.append(topSum)
            # print(topSum, cntr.items(), cntrList)

        return res",1420551959
zsq007,zsq007,110,3610,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cntr, cntrList, n = Counter(), SortedList(), len(nums)

        ptr, topSum = 0, 0
        for num in nums[:k]:
            cntr[num] += 1
        
        cntrList = SortedList((-cnt, -num) for num,cnt in cntr.items())
        topSum = sum(num*cnt for num,cnt in cntrList[:x])
        res = [topSum]

        for i,num in enumerate(nums[k:]):
            if num == nums[i]:
                res.append(topSum)
                continue

            if (ind := cntrList.bisect_left((-cntr[nums[i]], -nums[i]))) >= x:
                cntrList.pop(ind)
                cntr[nums[i]] -= 1
                if cntr[nums[i]]:
                    cntrList.add((-cntr[nums[i]], -nums[i]))
                else:
                    cntr.pop(nums[i])
            else:
                topSum -= nums[i] * cntr[nums[i]]
                cntrList.pop(ind)
                cntr[nums[i]] -= 1
                if cntr[nums[i]]:
                    if cntrList.bisect_left((-cntr[nums[i]], -nums[i])) < x:
                        topSum += nums[i] * cntr[nums[i]]
                    elif len(cntrList) >= x:
                        newCnt, newNum = cntrList[x-1]
                        topSum += newCnt * newNum
                    cntrList.add((-cntr[nums[i]], -nums[i]))
                elif len(cntrList) >= x:
                    newCnt, newNum = cntrList[x-1]
                    topSum += newCnt * newNum


            if (ind := cntrList.bisect_left((-cntr[num], -num))) < x:
                topSum += num
                if ind < len(cntrList):
                    cntrList.pop(ind)
                cntr[num] += 1
                cntrList.add((-cntr[num], -num))
            else:
                if ind < len(cntrList):
                    cntrList.pop(ind)
                cntr[num] += 1
                cntrList.add((-cntr[num], -num))
                if cntrList.bisect_left((-cntr[num], -num)) < x:
                    oldCnt, oldNum = cntrList[x]
                    topSum -= oldCnt * oldNum
                    topSum += cntr[num]*num

            res.append(topSum)
            # print(topSum, cntr.items(), cntrList)

        return res",1420552184
xlx2,xlx2,112,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sz = []
        def dfs(x):
            if x is None:
                return 0, True
            l, a = dfs(x.left)
            r, b = dfs(x.right)
            if l == r and a and b:
                sz.append(l+r+1)
                return l+r+1, True
            return l+r+1, False

        dfs(root)
        sz.sort(reverse=True)
        # print(sz)
        return sz[k-1] if k <= len(sz) else -1",1420546814
xlx2,xlx2,112,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        M = 10**9 + 7
        n = len(s)
        d = {'F': 0, 'E': 1, 'W': 2}
        g = [[0,-1,1], [1,0,-1], [-1,1,0]]
        @cache
        def f(i, prev, pt):
            if pt <= -(n-i):
                return 0
            if i == n:
                return 1 if pt > 0 else 0
            ans = 0
            a = d[s[i]]
            for bb in 'FEW':
                if bb == prev: continue
                b = d[bb]
                ans += f(i+1, bb, pt + g[a][b])
                ans %= M
            return ans

        ans = f(0, '', 0) % M
        f.cache_clear()
        return ans",1420546526
xlx2,xlx2,112,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        c = Counter(nums[:k])
        f = [[v, i] for i,v in c.items()]
        f.sort(reverse=True)
        s = sum(v*i for v,i in f[:x])
        f = SortedList(f + [[0, 0] for _ in range(x+1)])

        def f_remove(f, g, s):
            fx = f[-x]
            if g >= fx:
                y = f[-x-1]
                s -= g[0] * g[1]
                s += y[0] * y[1]
            f.remove(g)
            return s

        def f_add(f, g, s):
            fx = f[-x]
            if g >= fx:
                s -= fx[0] * fx[1]
                s += g[0] * g[1]
            f.add(g)
            return s

        ans = [s]
        for i in range(n-k):
            g = [c[nums[i]], nums[i]]
            s = f_remove(f, g, s)
            c[nums[i]] -= 1
            g[0] -= 1
            if g[0] > 0:
                s = f_add(f, g, s)
            g = [c[nums[i+k]], nums[i+k]]
            if g[0] > 0:
                s = f_remove(f, g, s)
            c[nums[i+k]] += 1
            g[0] += 1
            s = f_add(f, g, s)
            ans.append(s)
            # print(f)
        return ans",1420595854
xlx2,xlx2,112,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        def x_sum(arr):
            a = sorted([[v, i] for i,v in Counter(arr).items()], reverse=True)
            a = a[:x]
            return sum(v*i for v,i in a)

        return [x_sum(nums[i:i+k]) for i in range(n-k+1)]",1420546907
LGM70,LGM70,113,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_trees = []
        def calc(node: TreeNode) -> int:
            if node is None:
                return 0
            dl = calc(node.left)
            dr = calc(node.right)
            if dl != dr or dl == -1 or dr == -1:
                return -1
            heapq.heappush(perfect_trees, 2 ** (dl + 1) - 1)
            if len(perfect_trees) > k:
                heapq.heappop(perfect_trees)
            return dl + 1

        calc(root)
        if len(perfect_trees) < k:
            return -1
        return perfect_trees[0]
        ",1420530449
LGM70,LGM70,113,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        def calc(alice, bob):
            if alice == bob:
                return 0
            if alice == 'F':
                if bob == 'E':
                    return -1
                else:
                    return 1
            elif alice == 'W':
                if bob == 'F':
                    return -1
                else:
                    return 1
            else:
                if bob == 'F':
                    return 1
                else:
                    return -1

        dp = [[[0] * (len(s) * 2 + 1) for _ in range(3)] for _ in range(len(s) + 1)]
        m = int(1e9 + 7)
        creatures = 'FWE'
        for c in range(3):
            dp[0][c][len(s)] = 1
        for i, alice in enumerate(s):
            for c in range(3):
                delta = calc(alice, creatures[c])
                for p in range(len(s) * 2 + 1):
                    if p - delta < 0 or p - delta >= len(s) * 2 + 1:
                        continue
                    for last_c in range(3):
                        if c == last_c:
                            continue
                        dp[i + 1][c][p] = (dp[i + 1][c][p] + dp[i][last_c][p - delta]) % m
        rslt = 0
        for c in range(3):
            for p in range(len(s) + 1, len(s) * 2 + 1):
                rslt = (rslt + dp[-1][c][p]) % m
        if rslt % 2 == 0:
            return rslt // 2
        else:
            return (rslt + m) // 2",1420548828
LGM70,LGM70,113,3592,python3,"from sortedcontainers import SortedList
class MySortedList:
    def __init__(self, x):
        self.lst = SortedList()
        self.x = x
        self.sum = 0

    def add(self, elem):
        if len(self.lst) < self.x:
            self.sum += elem[0] * elem[1]
        if len(self.lst) >= self.x and elem < self.lst[self.x - 1]:
            self.sum -= self.lst[self.x - 1][0] * self.lst[self.x - 1][1]
            self.sum += elem[0] * elem[1]
        self.lst.add(elem)

    def remove(self, elem):
        # elem existence guaranteed
        if len(self.lst) <= self.x:
            self.sum -= elem[0] * elem[1]
        if len(self.lst) > self.x and self.lst.index(elem) < self.x:
            self.sum -= elem[0] * elem[1]
            self.sum += self.lst[self.x][0] * self.lst[self.x][1]
        self.lst.remove(elem)

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        sorted_vals = MySortedList(x)
        val2cnt = {}
        rslt = []
        for num in nums[:k]:
            if num in val2cnt:
                val2cnt[num] += 1
            else:
                val2cnt[num] = 1
        for val, cnt in val2cnt.items():
            sorted_vals.add((-cnt, -val))
        for i, num in enumerate(nums[k:]):
            rslt.append(sorted_vals.sum)
            # remove nums[i]
            if val2cnt[nums[i]] == 1:
                del val2cnt[nums[i]]
                sorted_vals.remove((-1, -nums[i]))
            else:
                sorted_vals.remove((-val2cnt[nums[i]], -nums[i]))
                val2cnt[nums[i]] -= 1
                sorted_vals.add((-val2cnt[nums[i]], -nums[i]))
            # add nums[i + k], i.e. num
            if num in val2cnt:
                sorted_vals.remove((-val2cnt[num], -num))
                val2cnt[num] += 1
                sorted_vals.add((-val2cnt[num], -num))
            else:
                val2cnt[num] = 1
                sorted_vals.add((-1, -num))
        rslt.append(sorted_vals.sum)
        return rslt
",1420583586
LGM70,LGM70,113,3610,python3,"from sortedcontainers import SortedList
class MySortedList:
    def __init__(self, x):
        self.lst = SortedList()
        self.x = x
        self.sum = 0

    def add(self, elem):
        if len(self.lst) < self.x:
            self.sum += elem[0] * elem[1]
        if len(self.lst) >= self.x and elem < self.lst[self.x - 1]:
            self.sum -= self.lst[self.x - 1][0] * self.lst[self.x - 1][1]
            self.sum += elem[0] * elem[1]
        self.lst.add(elem)

    def remove(self, elem):
        # elem existence guaranteed
        if len(self.lst) <= self.x:
            self.sum -= elem[0] * elem[1]
        if len(self.lst) > self.x and self.lst.index(elem) < self.x:
            self.sum -= elem[0] * elem[1]
            self.sum += self.lst[self.x][0] * self.lst[self.x][1]
        self.lst.remove(elem)

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        sorted_vals = MySortedList(x)
        val2cnt = {}
        rslt = []
        for num in nums[:k]:
            if num in val2cnt:
                val2cnt[num] += 1
            else:
                val2cnt[num] = 1
        for val, cnt in val2cnt.items():
            sorted_vals.add((-cnt, -val))
        for i, num in enumerate(nums[k:]):
            rslt.append(sorted_vals.sum)
            # remove nums[i]
            if val2cnt[nums[i]] == 1:
                del val2cnt[nums[i]]
                sorted_vals.remove((-1, -nums[i]))
            else:
                sorted_vals.remove((-val2cnt[nums[i]], -nums[i]))
                val2cnt[nums[i]] -= 1
                sorted_vals.add((-val2cnt[nums[i]], -nums[i]))
            # add nums[i + k], i.e. num
            if num in val2cnt:
                sorted_vals.remove((-val2cnt[num], -num))
                val2cnt[num] += 1
                sorted_vals.add((-val2cnt[num], -num))
            else:
                val2cnt[num] = 1
                sorted_vals.add((-1, -num))
        rslt.append(sorted_vals.sum)
        return rslt
",1420583853
dudu_bird_kindergarden,orzorzorz123,114,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        
        def dfs(node):
            if not node:
                return True, 0, 0
            lp, lh, ls = dfs(node.left)
            rp, rh, rs = dfs(node.right)
            if lp and rp and lh == rh:
                sz = ls + rs +1
                sizes.append(sz)
                return True, lh +1, sz
            return False, max(lh, rh) +1, ls + rs +1
        
        dfs(root)
        sizes.sort(reverse=True)
        return sizes[k-1] if k <= len(sizes) else -1",1420519172
dudu_bird_kindergarden,orzorzorz123,114,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        creatures = {'F': 0, 'W': 1, 'E': 2}
        
        def out(a, b):
            if (b == 'F' and a == 'E') or (b == 'W' and a == 'F') or (b == 'E' and a == 'W'):
                return 1
            if (a == 'F' and b == 'E') or (a == 'W' and b == 'F') or (a == 'E' and b == 'W'):
                return -1
            return 0
        
        dp = [[[0] * (2 * n + 1) for _ in range(4)] for _ in range(n + 1)]
        dp[0][3][n] = 1  
        for i in range(n):
            a = s[i]
            for last in range(4):
                for d in range(2 * n + 1):
                    cnt = dp[i][last][d]
                    if not cnt:
                        continue
                    for b in ['F', 'W', 'E']:
                        c_b = creatures[b]
                        if last == 3 or c_b != last:
                            res = out(a, b)
                            nd = d + res
                            if 0 <= nd <= 2 * n:
                                dp[i + 1][c_b][nd] = (dp[i + 1][c_b][nd] + cnt) % MOD
        
        res = 0
        for l in range(4):
            for d in range(n + 1, 2 * n + 1):
                res = (res + dp[n][l][d]) % MOD
        return res",1420523191
dudu_bird_kindergarden,orzorzorz123,114,3592,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    struct cmp {
        bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
            if(a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        }
    };
    
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> res;
        if(n < k) return res;
        unordered_map<int, int> cnt;
        for(int i=0;i<k;i++) cnt[nums[i]]++;
        vector<pair<int, int>> elems;
        for(auto &[num, freq] : cnt) elems.emplace_back(freq, num);
        sort(elems.begin(), elems.end(), [&](const pair<int, int>& a, const pair<int, int>& b)->bool{
            if(a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });
        set<pair<int, int>, cmp> Top, Rest;
        long long sm=0;
        for(int i=0;i<(int)elems.size();i++){
            if(i < x){
                Top.emplace(elems[i]);
                sm += (long long)elems[i].first * elems[i].second;
            }
            else{
                Rest.emplace(elems[i]);
            }
        }
        res.push_back(sm);
        for(int i=k;i<n;i++){
            int out = nums[i -k];
            int in = nums[i];
            int out_freq = cnt[out];
            pair<int, int> p = {out_freq, out};
            if(Top.find(p)!=Top.end()){
                Top.erase(p);
                sm -= (long long)p.first * p.second;
            }
            else{
                Rest.erase(p);
            }
            cnt[out]--;
            if(cnt[out]==0){
                cnt.erase(out);
            }
            else{
                pair<int, int> new_p = {cnt[out], out};
                Rest.emplace(new_p);
            }
            if(Top.size() < (size_t)x && !Rest.empty()){
                auto it = Rest.begin();
                Top.emplace(*it);
                sm += (long long)it->first * it->second;
                Rest.erase(it);
            }
            if(cnt.find(in)!=cnt.end()){
                pair<int, int> old_p = {cnt[in], in};
                if(Top.find(old_p)!=Top.end()){
                    Top.erase(old_p);
                    sm -= (long long)old_p.first * old_p.second;
                }
                else{
                    Rest.erase(old_p);
                }
                cnt[in]++;
                pair<int, int> new_in_p = {cnt[in], in};
                if(Top.size() < (size_t)x){
                    Top.emplace(new_in_p);
                    sm += (long long)new_in_p.first * new_in_p.second;
                }
                else{
                    auto it = prev(Top.end());
                    pair<int, int> last = *it;
                    if((new_in_p.first > last.first) || (new_in_p.first == last.first && new_in_p.second > last.second)){
                        Top.erase(it);
                        sm -= (long long)last.first * last.second;
                        Top.emplace(new_in_p);
                        sm += (long long)new_in_p.first * new_in_p.second;
                        Rest.emplace(last);
                    }
                    else{
                        Rest.emplace(new_in_p);
                    }
                }
            }
            else{
                cnt[in]=1;
                pair<int, int> new_p = {1, in};
                if(Top.size() < (size_t)x){
                    Top.emplace(new_p);
                    sm += (long long)new_p.first * new_p.second;
                }
                else{
                    auto it = prev(Top.end());
                    pair<int, int> last = *it;
                    if((new_p.first > last.first) || (new_p.first == last.first && new_p.second > last.second)){
                        Top.erase(it);
                        sm -= (long long)last.first * last.second;
                        Top.emplace(new_p);
                        sm += (long long)new_p.first * new_p.second;
                        Rest.emplace(last);
                    }
                    else{
                        Rest.emplace(new_p);
                    }
                }
            }
            res.push_back(sm);
        }
        return res;
    }
};
",1420572228
dudu_bird_kindergarden,orzorzorz123,114,3610,python3,"from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        for i in range(n - k +1):
            w = nums[i:i+k]
            c = Counter(w)
            s = sorted(c.items(), key=lambda a: (-a[1], -a[0]))
            ts = sum(num * cnt for num, cnt in s[:x])
            res.append(ts)
        return res",1420518540
xymabinogi,xymabinogi,116,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> res;
        
        auto dfs = [&](auto self, TreeNode* cur, int depth) -> pair<int,int> {
            if (cur == nullptr) return {-1, 0};
            auto l = self(self, cur->left, depth + 1);
            auto r = self(self, cur->right, depth + 1);
            //cout << cur->val <<"" ""<< l.first <<"" ""<< l.second <<"" ""<< r.first <<"" ""<< r.second << ""\n"";
            if (l.first == -2 or r.first == -2 or l.first != r.first) return {-2, 0};
            
            if (l.first == -1 and r.first == -1) {
                res.push_back(1);
                return {depth, 1};
            }
            int v = l.second + r.second + 1;
            res.push_back(v);
            return {l.first, v};
            
            
            
        };
        dfs(dfs, root, 0);
        sort(res.rbegin(), res.rend());
        if ((int) res.size() < k) return -1;
        return res[k - 1];
    }
};",1420526634
xymabinogi,xymabinogi,116,3588,cpp,"constexpr int P = 1000000007;
using i64 = long long;
// assume -P <= x < 2P
int modNorm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(modNorm(x)) {}
    Z(i64 x) : x(modNorm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(modNorm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = modNorm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = modNorm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        unordered_map<char,int> mov{{'F', 0}, {'W', 1}, {'E', 2}};
        vector<vector<int>> state{{0, -1, 1}, {1, 0, -1}, {-1, 1, 0}};
        
        vector<int> alice(n);
        for (int i = 0; i < n; i++){
            alice[i] = mov[s[i]];
        }
        
        vector<vector<Z>> pre(3, vector<Z>(2 * n + 1, Z(0)));
        for (int i = 0; i < 3; i++){
            int score = state[i][alice[0]];
            pre[i][n + score] = 1;
        }
        
        for (int i = 1; i < n; i++){
            vector<vector<Z>> current(3, vector<Z>(2 * n + 1, Z(0)));
            int oppo = alice[i];
            
            for (int j = 0; j < 3; j++){
                for (int k = 0; k <= 2 * n; k++){
                    if (pre[j][k].val() == 0) continue;
                    Z cnt = pre[j][k];
                    for (int m = 0; m < 3; m++){
                        if (m == j) continue;
                        int score = state[m][oppo];
                        
                        int updated = k + score;
                        if (updated < 0 || updated > 2 * n) continue;
                        current[m][updated] += cnt;
                        
                    }
                
                }

            }
            pre = current;
            
        }
        Z res = 0;
        for (int i = 0; i < 3; i++){
            for (int j = n + 1; j <= 2 * n; j++){
                res += pre[i][j];
            }
        }
        return res.val();
        
        
    }
};",1420543721
xymabinogi,xymabinogi,116,3592,cpp,"using i64 = long long;
using pi = pair<int,int>;

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<i64> res;
        unordered_map<int,int> state; //whether this number is in the heap
        unordered_map<int, int> freq; //freq tracker
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        
        auto cmp = [&](const pair<int, int> &a, const pair<int, int> &b) -> bool {
            if (a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        };
        set<pi, decltype(cmp)> right(cmp);
        set<pi> left;
        
        for (int i = 0; i < k; i++){
            freq[nums[i]]++;
        }
        for (auto &[k, v] : freq){
            right.insert({v, k});
        }
        
        i64 tot = 0;
        while(!right.empty() and (int) left.size() < x){
            auto [cnt, val] = *right.begin();
            right.erase(right.begin());
            tot += 1LL * cnt * val;
            state[val] = 1;
            left.insert({cnt, val});
        } 
        
        res.push_back(tot);
        
        
        
        
        
        
        for (int i = k; i < n; i++){
            //remove nums[i - k]
            if (state[nums[i - k]] == 1){
                //remove it from left
                int cnt = freq[nums[i - k]];
                
                tot -= 1LL * nums[i - k] * cnt;
                left.erase({cnt, nums[i - k]});
                
                if (cnt > 1){
                    right.insert({cnt - 1, nums[i - k]});
                }
                state[nums[i - k]] = 0;
                freq[nums[i - k]]--;
            }
            else {
                //change it from right
                int cnt = freq[nums[i - k]];
                
                right.erase({cnt, nums[i - k]});
                if (cnt > 1){
                    right.insert({cnt - 1, nums[i - k]});
                }
                freq[nums[i - k]]--;
            }
            
            //add nums[i]
            
            if (state[nums[i]] == 1){
                int cnt = freq[nums[i]];
                tot += nums[i];
                
                left.erase({cnt, nums[i]});
                left.insert({cnt + 1, nums[i]});
                freq[nums[i]]++;
            }
            else {
                int cnt = freq[nums[i]];
                if (cnt) right.erase({cnt, nums[i]});
                right.insert({cnt + 1, nums[i]});
                freq[nums[i]]++;
            }
            
            if (!left.empty()){
                auto [cnt, val] = *left.begin();
                state[val] = 0;
                left.erase(left.begin());
                tot -= 1LL * cnt * val;
                
                right.insert({cnt, val});
            }
            
            while(!right.empty() and left.size() < x){
                auto [cnt, val] = *right.begin();
                right.erase(right.begin());
                tot += 1LL * cnt * val;
                state[val] = 1;
                left.insert({cnt, val});
            }
            res.push_back(tot);
            
            
            
        }
        return res;
        
        
        
        
        
        
        
        
        
        
        
        
    }
};",1420582045
xymabinogi,xymabinogi,116,3610,cpp,"using i64 = int;
using pi = pair<int,int>;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> res;
        unordered_map<int,int> state; //whether this number is in the heap
        unordered_map<int, int> freq; //freq tracker
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        
        auto cmp = [&](const pair<int, int> &a, const pair<int, int> &b) -> bool {
            if (a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        };
        set<pi, decltype(cmp)> right(cmp);
        set<pi> left;
        
        for (int i = 0; i < k; i++){
            freq[nums[i]]++;
        }
        for (auto &[k, v] : freq){
            right.insert({v, k});
        }
        
        i64 tot = 0;
        while(!right.empty() and (int) left.size() < x){
            auto [cnt, val] = *right.begin();
            right.erase(right.begin());
            tot += 1LL * cnt * val;
            state[val] = 1;
            left.insert({cnt, val});
        } 
        
        res.push_back(tot);
        
        
        
        
        
        
        for (int i = k; i < n; i++){
            //remove nums[i - k]
            if (state[nums[i - k]] == 1){
                //remove it from left
                int cnt = freq[nums[i - k]];
                
                tot -= 1LL * nums[i - k] * cnt;
                left.erase({cnt, nums[i - k]});
                
                if (cnt > 1){
                    right.insert({cnt - 1, nums[i - k]});
                }
                state[nums[i - k]] = 0;
                freq[nums[i - k]]--;
            }
            else {
                //change it from right
                int cnt = freq[nums[i - k]];
                
                right.erase({cnt, nums[i - k]});
                if (cnt > 1){
                    right.insert({cnt - 1, nums[i - k]});
                }
                freq[nums[i - k]]--;
            }
            
            //add nums[i]
            
            if (state[nums[i]] == 1){
                int cnt = freq[nums[i]];
                tot += nums[i];
                
                left.erase({cnt, nums[i]});
                left.insert({cnt + 1, nums[i]});
                freq[nums[i]]++;
            }
            else {
                int cnt = freq[nums[i]];
                if (cnt) right.erase({cnt, nums[i]});
                right.insert({cnt + 1, nums[i]});
                freq[nums[i]]++;
            }
            
            if (!left.empty()){
                auto [cnt, val] = *left.begin();
                state[val] = 0;
                left.erase(left.begin());
                tot -= 1LL * cnt * val;
                
                right.insert({cnt, val});
            }
            
            while(!right.empty() and left.size() < x){
                auto [cnt, val] = *right.begin();
                right.erase(right.begin());
                tot += 1LL * cnt * val;
                state[val] = 1;
                left.insert({cnt, val});
            }
            res.push_back(tot);
            
            
            
        }
        return res;
        
        
        
        
        
        
        
        
        
        
        
        
    }
};",1420584391
Rakesh_Reddy7,Addula_Rakesh7,117,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
import heapq
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        mini = []
        def postorder(node):
            if not node:
                return True, 0

            l1, l2 = postorder(node.left)
            r1, r2 = postorder(node.right)

            if l1 and r1 and l2 == r2:
                curr2 = l2 + 1
                curr1 = (1 << curr2) - 1
                if len(mini) < k:
                    heapq.heappush(mini, curr1)
                else:
                    if curr1 > mini[0]:
                        heapq.heappushpop(mini, curr1)
                return True, curr2
            else:
                return False, max(l2, r2)

        postorder(root)

        if len(mini) < k:
            return -1
        else:
            return mini[0]
",1420597261
Rakesh_Reddy7,Addula_Rakesh7,117,3588,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10**9 +7
        n = len(s) 
        km = 0
        mp = {'F':0, 'W':1, 'E':2}
        s = [mp[c] for c in s]
        b1 = [2,0,1]
        d1 = [[0]*3 for _ in range(3)]
        for b in range(3):
            for a in range(3):
                if b == a:
                    d1[b][a] = 0
                elif b1[a] == b:
                    d1[b][a] = -1
                elif b1[b] == a:
                    d1[b][a] = 1
                else:
                    d1[b][a] = 0
        dp1 = [ [0]*(2*n +1) for i in range(3)]
        for b in range(3):
            d = d1[b][s[0]]
            idx = d + n
            km += 1
            dp1[b][idx] =1
        dp2 = [ [0]*(2*n +1) for i in range(3)]
        for i in range(1, len(s)):
            for j in range(3):
                for p in range(-n, n+1):
                    idx = p +n
                    km -= 1
                    cnt = dp1[j][idx]
                    if cnt ==0:
                        continue
                    for b in range(3):
                        if b == j:
                            continue
                        d = d1[b][s[i]]
                        np = p + d
                        if np < -n or np > n:
                            continue
                        else: pass
                        idx1 = np +n
                        dp2[b][idx1] = (dp2[b][idx1] + cnt) % mod
            dp1, dp2 = dp2, [ [0]*(2*n +1) for i in range(3) ]
        ans = 0
        for j in range(3):
            for p in range(1, n+1):
                idx = p + n
                km += 1
                ans = (ans + dp1[j][idx]) % mod
        return (ans*1)%mod
",1420596131
Rakesh_Reddy7,Addula_Rakesh7,117,3592,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        mp = {}
        lst = []
        lst2 = []
        for i in range(k):
            num = nums[i]
            mp[num] = mp.get(num, 0) + 1


        for num, freq in mp.items():
            insort_left(lst, (-freq, -num))
        kd = 0
        sumx = 0
        for idx in range(min(x, len(lst))):
            freq, num = lst[idx]
            sumx += (-freq) * (-num)

        ans = [sumx]

        for i in range(1, n - k + 1):
            n0 = nums[i - 1]
            freq0 = mp[n0]
            idx = bisect_left(lst, (-freq0, -n0))
            lst.pop(idx)
            if idx < x:
                sumx -= freq0 * n0
                if len(lst) >= x:
                    freq1, n1 = lst[x - 1]
                    sumx += (-freq1) * (-n1)
                else: kd -= 1
            freq0 -= 1
            if freq0 == 0:
                del mp[n0]
            else:
                mp[n0] = freq0
                insort_left(lst, (-freq0, -n0))
                idx1 = bisect_left(lst, (-freq0, -n0))
                if idx1 < x:
                    sumx += freq0 * n0
                    if len(lst) > x:
                        nfreq, nn = lst[x]
                        sumx -= (-nfreq) * (-nn)

            nx = nums[i + k - 1]
            freq0 = mp.get(nx, 0)
            if freq0 > 0:
                idx = bisect_left(lst, (-freq0, -nx))
                lst.pop(idx)
                if idx < x:
                    sumx -= freq0 * nx
                    if len(lst) >= x:
                        freq1, n1 = lst[x - 1]
                        sumx += (-freq1) * (-n1)
                    else: kd += 1
            freq1 = freq0 + 1*1
            mp[nx] = freq1
            insort_left(lst, (-freq1, -nx))
            idx1 = bisect_left(lst, (-freq1, -nx))
            if idx1 < x:
                sumx += freq1 * nx
                if len(lst) > x:
                    nfreq, nn = lst[x]
                    sumx -= (-nfreq) * (-nn)
                else: kd += 1

            ans.append(sumx)

        return ans
",1420592931
Rakesh_Reddy7,Addula_Rakesh7,117,3610,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        mp = {}
        lst = []
        lst2 = []
        for i in range(k):
            num = nums[i]
            mp[num] = mp.get(num, 0) + 1


        for num, freq in mp.items():
            insort_left(lst, (-freq, -num))
        kd = 0
        sumx = 0
        for idx in range(min(x, len(lst))):
            freq, num = lst[idx]
            sumx += (-freq) * (-num)

        ans = [sumx]

        for i in range(1, n - k + 1):
            n0 = nums[i - 1]
            freq0 = mp[n0]
            idx = bisect_left(lst, (-freq0, -n0))
            lst.pop(idx)
            if idx < x:
                sumx -= freq0 * n0
                if len(lst) >= x:
                    freq1, n1 = lst[x - 1]
                    sumx += (-freq1) * (-n1)
                else: kd -= 1
            freq0 -= 1
            if freq0 == 0:
                del mp[n0]
            else:
                mp[n0] = freq0
                insort_left(lst, (-freq0, -n0))
                idx1 = bisect_left(lst, (-freq0, -n0))
                if idx1 < x:
                    sumx += freq0 * n0
                    if len(lst) > x:
                        nfreq, nn = lst[x]
                        sumx -= (-nfreq) * (-nn)

            nx = nums[i + k - 1]
            freq0 = mp.get(nx, 0)
            if freq0 > 0:
                idx = bisect_left(lst, (-freq0, -nx))
                lst.pop(idx)
                if idx < x:
                    sumx -= freq0 * nx
                    if len(lst) >= x:
                        freq1, n1 = lst[x - 1]
                        sumx += (-freq1) * (-n1)
                    else: kd += 1
            freq1 = freq0 + 1*1
            mp[nx] = freq1
            insort_left(lst, (-freq1, -nx))
            idx1 = bisect_left(lst, (-freq1, -nx))
            if idx1 < x:
                sumx += freq1 * nx
                if len(lst) > x:
                    nfreq, nn = lst[x]
                    sumx -= (-nfreq) * (-nn)
                else: kd += 1

            ans.append(sumx)

        return ans
",1420593221
turneja,turneja,118,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sz;
    
    tuple<int, int, int> dfs(TreeNode *node, int depth) {
        if (node->left == nullptr && node->right == nullptr) {
            sz.push_back(1);
            return make_tuple(1, depth, depth);
            
        }
        int mn = 1e9, mx = 0; int s = 1;
        if (node->left != nullptr) {
            tuple<int, int, int> t = dfs(node->left, depth + 1);
            if (get<0>(t) < 0) {
                s = -1e9;
            } else {
                s += get<0>(t);
            }
            mx = max(mx, get<1>(t));
            mn = min(mn, get<2>(t));
        }
        if (node->right != nullptr) {
            tuple<int, int, int> t = dfs(node->right, depth + 1);
            if (get<0>(t) < 0) {
                s = -1e9;
            } else {
                s += get<0>(t);
            }
            mx = max(mx, get<1>(t));
            mn = min(mn, get<2>(t));
        }
        if (node->right == nullptr || node->left == nullptr) {
            s = -1;
        }
        if (mx != mn) {
            s = -1;
        }
        if (s > 0) {
            
            sz.push_back(s);
        } else {
            s = -1;
        }
        
        return make_tuple(s, mx, mn);
        
    }
    
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root, 0);
        sort(sz.begin(), sz.end(), greater<int>());
        k--;
        if (k >= sz.size()) {
            return -1;
        }
        return sz[k];
        
    }
};",1420539595
turneja,turneja,118,3588,cpp,"const long long M = 1e9 + 7;
long long dp[1005][2005][3];
class Solution {
public:
    
    
    int countWinningSequences(string s) {
        int mid = 1002;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            for (int j = mid - n; j <= mid + n; j++) {
                dp[i][j][0] = 0;
                dp[i][j][1] = 0;
                dp[i][j][2] = 0;
            }
        }
        if (s[0] == 'F') {
            dp[0][mid][0] = 1;
            dp[0][mid + 1][1] = 1;
            dp[0][mid - 1][2] = 1;
        } else if (s[0] == 'W') {
            dp[0][mid - 1][0] = 1;
            dp[0][mid][1] = 1;
            dp[0][mid + 1][2] = 1;
        
        } else if (s[0] == 'E') {
            dp[0][mid + 1][0] = 1;
            dp[0][mid - 1][1] = 1;
            dp[0][mid][2] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = mid - i; j <= mid + i; j++) {
                if (s[i] == 'F') {
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][1] + dp[i - 1][j][2]) % M;
                    dp[i][j + 1][1] = (dp[i][j + 1][1] + dp[i - 1][j][0] + dp[i - 1][j][2]) % M;
                    dp[i][j - 1][2] = (dp[i][j - 1][2] + dp[i - 1][j][0] + dp[i - 1][j][1]) % M;
                } else if (s[i] == 'W') {
                    dp[i][j - 1][0] = (dp[i][j - 1][0] + dp[i - 1][j][1] + dp[i - 1][j][2]) % M;
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][0] + dp[i - 1][j][2]) % M;
                    dp[i][j + 1][2] = (dp[i][j + 1][2] + dp[i - 1][j][0] + dp[i - 1][j][1]) % M;

                } else if (s[i] == 'E') {
                    dp[i][j + 1][0] = (dp[i][j + 1][0] + dp[i - 1][j][1] + dp[i - 1][j][2]) % M;
                    dp[i][j - 1][1] = (dp[i][j - 1][1] + dp[i - 1][j][0] + dp[i - 1][j][2]) % M;
                    dp[i][j][2] = (dp[i][j][2] + dp[i - 1][j][0] + dp[i - 1][j][1]) % M;
                }
            }
        }
        long long ans = 0;
        for (int j = mid + 1; j <= mid + n; j++) {
            ans += dp[n - 1][j][0] + dp[n - 1][j][1] + dp[n - 1][j][2];
        }
        return ans % M;
    }
};",1420591322
turneja,turneja,118,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
tree <pair<int, int>, null_type, greater<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update> t;
map<int, int> freq;

class Solution {
public:
    long long ans = 0;
    void st_add(int n, int x, int add) {
        x = min(x, (int)t.size());
        int frek = freq[n];
        int ct = t.order_of_key(make_pair(frek, n));
        int ch = 0;
        if (ct < x) {
            ans -= (long long)frek * n;
            t.erase(make_pair(frek, n));
            auto it = t.find_by_order(x - 1);
            ans += (long long)it->first * it->second;
        } else {
            t.erase(make_pair(frek, n));
        }
        frek += add;
        freq[n] = frek;
        ct = t.order_of_key(make_pair(frek, n));
        if (ct < x) {
            auto it = t.find_by_order(x - 1);
            ans -= (long long)it->first * it->second;
            ans += (long long)frek * n;
            t.insert(make_pair(frek, n));
        } else {
            t.insert(make_pair(frek, n));
        }
        return;
    }
    
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            t.insert(make_pair(0, nums[i]));
        }
        vector<long long> v;
        for (int i = 0; i < k; i++) {
            st_add(nums[i], x, 1);
        }
        v.push_back(ans);
        for (int i = k; i < n; i++) {
            st_add(nums[i - k], x, -1);
            st_add(nums[i], x, 1);
            v.push_back(ans);
        }
        t.clear();
        freq.clear();
        return v;
    }
};",1420570718
turneja,turneja,118,3610,cpp,"class Solution {
public:
    int freq[55];
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        for (int i = 0; i < k; i++) {
            freq[nums[i]]++;
        }
        vector<pair<int, int>> fr;
        for (int i = 0; i < 51; i++) {
            if (freq[i] > 0) {
                fr.push_back(make_pair(freq[i], i));
            }
        }
        sort(fr.begin(), fr.end(), greater<pair<int, int>>());
        int ans = 0;
        for (int i = 0; i < min(x, (int)fr.size()); i++) {
            ans += fr[i].first * fr[i].second;
        }
        vector<int> v;
        v.push_back(ans);
        for (int i = k; i < n; i++) {
            freq[nums[i - k]]--;
            freq[nums[i]]++;
            vector<pair<int, int>> fr;
            for (int i = 0; i < 51; i++) {
                if (freq[i] > 0) {
                    fr.push_back(make_pair(freq[i], i));
                }
            }
            sort(fr.begin(), fr.end(), greater<pair<int, int>>());
            int ans = 0;
            for (int i = 0; i < min(x, (int)fr.size()); i++) {
                ans += fr[i].first * fr[i].second;
            }
            v.push_back(ans);
        }
        return v;
    }
};",1420521938
Vijay Katari,vijaykatari23,120,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    tuple<bool, int, int> isPerfectSubtree(TreeNode* root) {
        if (!root) return {true, 0, 0}; // An empty tree is perfect
        
        auto [isLeftPerfect, leftHeight, leftSize] = isPerfectSubtree(root->left);
        auto [isRightPerfect, rightHeight, rightSize] = isPerfectSubtree(root->right);
        
        // Check if both left and right subtrees are perfect and have the same height
        if (isLeftPerfect && isRightPerfect && leftHeight == rightHeight) {
            int currentHeight = leftHeight + 1;
            int currentSize = (1 << currentHeight) - 1; // Size of a perfect binary tree: 2^height - 1
            return {true, currentHeight, currentSize};
        }
        return {false, max(leftHeight, rightHeight), 0};
    }
    
    // Traversal to check each node separately
    void traverse(TreeNode* root, vector<int>& perfectSizes) {
        if (!root) return;
        
        // Check if the subtree rooted at the current node is a perfect binary tree
        auto [isPerfect, _, size] = isPerfectSubtree(root);
        if (isPerfect) {
            perfectSizes.push_back(size);
        }
        
        // Recursively check for left and right subtrees
        traverse(root->left, perfectSizes);
        traverse(root->right, perfectSizes);
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfectSizes;
        traverse(root, perfectSizes);
        
        // Sort the sizes in descending order
        sort(perfectSizes.rbegin(), perfectSizes.rend());
        
        // Check if we have enough perfect subtrees
        if (k <= perfectSizes.size()) {
            return perfectSizes[k - 1];
        }
        
        return -1; // If there are fewer than k perfect subtrees
    }
};",1420566443
Vijay Katari,vijaykatari23,120,3588,cpp,"using ll = long long;
using ld = long double;
using ull = unsigned long long;

#define FOR(i, n)           for(ll (i) = 0; (i) < (n); ++(i))
#define REV(i, n)           for(ll (i) = (n) - 1; ~(i); --(i))
#define READ(x)             cin >> x;
#define O(x)                cout << x << '\n';
#define PLL                 pair<ll, ll>
#define VL                  vector<ll>
#define all(x)              (x).begin(), (x).end()
#define allr(x)             (x).rbegin(), (x).rend()
#define YES                 cout << ""YES\n"";
#define NO                  cout << ""NO\n"";
#define STOP                cout << ""-1\n"";

constexpr ll INF0  = 2e18 + 10;
constexpr ld EPS   = 1e-9 + 00;

template<const int &MOD>
struct ModularInt {
    int val;
 
    ModularInt(ll v = 0) {
        if (v < 0) v = v % MOD + MOD;
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    ModularInt(ull v) {
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    ModularInt(int v) : ModularInt(ll(v)) {}
    ModularInt(unsigned v) : ModularInt(ull(v)) {}
 
    explicit operator int() const { return val; }
    explicit operator unsigned() const { return val; }
    explicit operator ll() const { return val; }
    explicit operator ull() const { return val; }
    explicit operator double() const { return val; }
    explicit operator long double() const { return val; }
 
    ModularInt& operator+=(const ModularInt &other) {
        val -= MOD - other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    ModularInt& operator-=(const ModularInt &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    ModularInt& operator*=(const ModularInt &other) {
        val = unsigned(ull(ull(val) * other.val) % ull(MOD));
        return *this;
    }
 
    ModularInt& operator/=(const ModularInt &other) {
        return *this *= other.inv();
    }
 
    friend ModularInt operator+(const ModularInt &a, const ModularInt &b) { return ModularInt(a) += b; }
    friend ModularInt operator-(const ModularInt &a, const ModularInt &b) { return ModularInt(a) -= b; }
    friend ModularInt operator*(const ModularInt &a, const ModularInt &b) { return ModularInt(a) *= b; }
    friend ModularInt operator/(const ModularInt &a, const ModularInt &b) { return ModularInt(a) /= b; }
 
    ModularInt& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
 
    ModularInt& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
 
    ModularInt operator++(int) { ModularInt before = *this; ++*this; return before; }
    ModularInt operator--(int) { ModularInt before = *this; --*this; return before; }
 
    ModularInt operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
 
    friend bool operator==(const ModularInt &a, const ModularInt &b) { return a.val == b.val; }
    friend bool operator!=(const ModularInt &a, const ModularInt &b) { return a.val != b.val; }
    friend bool operator<(const ModularInt &a, const ModularInt &b) { return a.val < b.val; }
    friend bool operator>(const ModularInt &a, const ModularInt &b) { return a.val > b.val; }
    friend bool operator<=(const ModularInt &a, const ModularInt &b) { return a.val <= b.val; }
    friend bool operator>=(const ModularInt &a, const ModularInt &b) { return a.val >= b.val; }
 
    static const int SAVE_INV = int(1e6) + 5;
    static ModularInt save_inv[SAVE_INV];
 
    static void prepare_inv() {
        for (ll p = 2; p * p <= MOD; p += p % 2 + 1)
            assert(MOD % p != 0);
 
        save_inv[0] = 0;
        save_inv[1] = 1;
 
        for (int i = 2; i < SAVE_INV; i++)
            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);
    }
 
    ModularInt inv() const {
        if (save_inv[1] == 0)
            prepare_inv();
 
        if (val < SAVE_INV)
            return save_inv[val];
 
        ModularInt product = 1;
        int v = val;
 
        do {
            product *= MOD - MOD / v;
            v = MOD % v;
        } while (v >= SAVE_INV);
 
        return product * save_inv[v];
    }
 
    ModularInt pow(ll p) const {
        if (p < 0)
            return inv().pow(-p);
 
        ModularInt a = *this, result = 1;
 
        while (p > 0) {
            if (p & 1)
                result *= a;
 
            p >>= 1;
 
            if (p > 0)
                a *= a;
        }
 
        return result;
    }
 
    friend ostream& operator<<(ostream &os, const ModularInt &m) {
        return os << m.val;
    }
};
 
template<const int &MOD> ModularInt<MOD> ModularInt<MOD>::save_inv[ModularInt<MOD>::SAVE_INV];
 
const int MOD = int(1e9) + 7;
using Mint = ModularInt<MOD>;

class Solution {
public:
    public:
    int countWinningSequences(string S) {
        map<char, int> mp;
        mp['F'] = 0; mp['W'] = 1; mp['E'] = 2;
        map<pair<int, int>, int> points;
        points[{0, 0}] = points[{1, 1}] = points[{2, 2}] = 0;
        points[{0, 1}] = -1; points[{1, 0}] = 1;
        points[{0, 2}] = 1; points[{2, 0}] = -1;
        points[{1, 2}] = -1; points[{2, 1}] = 1;
        int N = S.length();
        // map<pair<int, int>, Mint> dp[N];
        Mint dp[N][N + N + N][3];
        for (ll i = 0; i < N; ++i)
            for (ll j = 0; j < 3 * N; ++j)
                for (ll k = 0; k < 3; ++k)
                    dp[i][j][k] = 0;
        for (int j = 0; j < 3; ++j)
            dp[0][N + points[{j, mp[S[0]]}]][j] = 1;
        for (int i = 1; i < N; ++i) 
            for (ll j = 0; j < 3; ++j)
                for (ll k = 0; k < 3; ++k) if (j ^ k) {
                    for (ll s = -N; s <= N; ++s) {
                        ll ns = s + points[{k, mp[S[i]]}];
                        if (ns >= -N)
                            dp[i][ns + N][k] += dp[i - 1][s + N][j];
                    }
                }
        
        Mint ans = 0;
        for (ll i = 1; i <= N; ++i)
            for (ll j = 0; j < 3; ++j)
                ans += dp[N - 1][i + N][j];
        return ans.val;
    }
};",1420591483
Vijay Katari,vijaykatari23,120,3592,cpp,"#define ll long long

class Solution {
public:
    vector<long long> findXSum(vector<int>& A, int K, int X) {
        ll N = A.size();
        set<pair<ll, ll>> st, st1;
        map<ll, ll> fre;
        ll ans = 0;
        for (ll i = 0; i < K; ++i) {
            if (st.count({fre[A[i]], A[i]})) {
                st.erase({fre[A[i]], A[i]});
                ans -= (fre[A[i]] * A[i]);
            } else {
                st1.erase({fre[A[i]], A[i]});
            }
            fre[A[i]]++;
            if (st.size() < X) {
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else if ((st.begin() -> first < fre[A[i]]) || ((st.begin() -> first == fre[A[i]]) && (st.begin() -> second < A[i]))) {
                ans -= (st.begin() -> first * st.begin() -> second);
                st1.insert(*st.begin());
                st.erase(st.begin());
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else {
                st1.insert({fre[A[i]], A[i]});
            }
        }
        vector<ll> ret(1, ans);
        ll p = 0;
        for (ll i = K; i < N; ++i) {
            if (st.count({fre[A[p]], A[p]})) {
                st.erase({fre[A[p]], A[p]});
                ans -= (fre[A[p]] * A[p]);
            } else {
                st1.erase({fre[A[p]], A[p]});
            }
            fre[A[p]]--;
            if (st.size() < X) {
                st.insert({fre[A[p]], A[p]});
                ans += (fre[A[p]] * A[p]);
            } else if ((st.begin() -> first < fre[A[p]]) || ((st.begin() -> first == fre[A[p]]) && (st.begin() -> second < A[p]))) {
                ans -= (st.begin() -> first * st.begin() -> second);
                st1.insert(*st.begin());
                st.erase(st.begin());
                st.insert({fre[A[p]], A[p]});
                ans += (fre[A[p]] * A[p]);
            } else {
                st1.insert({fre[A[p]], A[p]});
            }
            p++;
            
            if (st.count({fre[A[i]], A[i]})) {
                st.erase({fre[A[i]], A[i]});
                ans -= (fre[A[i]] * A[i]);
            } else {
                st1.erase({fre[A[i]], A[i]});
            }
            fre[A[i]]++;
            if (st.size() < X) {
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else if ((st.begin() -> first < fre[A[i]]) || ((st.begin() -> first == fre[A[i]]) && (st.begin() -> second < A[i]))) {
                ans -= (st.begin() -> first * st.begin() -> second);
                st1.insert(*st.begin());
                st.erase(st.begin());
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else {
                st1.insert({fre[A[i]], A[i]});
            }
            
            while (!st.empty() && !st1.empty()) {
                if (st.size() < X) {
                    st.insert(*st1.rbegin());
                    ans += (st1.rbegin() -> first * st1.rbegin() -> second);
                    st1.erase(*st1.rbegin());
                } else if ((st.begin() -> first < st1.rbegin() -> first) || ((st.begin() -> first == st1.rbegin() -> first) && (st.begin() -> second < st1.rbegin() -> second))) {
                    ans -= (st.begin() -> first * st.begin() -> second);
                    auto [x, y] = *st1.rbegin();
                    st1.insert(*st.begin());
                    st.erase(st.begin());
                    st.insert({x, y});
                    st1.erase({x, y});
                    ans += (x * y);
                } else {
                    break;
                }
            }
            
            ret.push_back(ans);
        }
        
        return ret;
    }
};",1420544523
Vijay Katari,vijaykatari23,120,3610,cpp,"#define ll int

class Solution {
public:
    vector<int> findXSum(vector<int>& A, int K, int X) {
        ll N = A.size();
        set<pair<ll, ll>> st, st1;
        map<ll, ll> fre;
        ll ans = 0;
        for (ll i = 0; i < K; ++i) {
            if (st.count({fre[A[i]], A[i]})) {
                st.erase({fre[A[i]], A[i]});
                ans -= (fre[A[i]] * A[i]);
            } else {
                st1.erase({fre[A[i]], A[i]});
            }
            fre[A[i]]++;
            if (st.size() < X) {
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else if ((st.begin() -> first < fre[A[i]]) || ((st.begin() -> first == fre[A[i]]) && (st.begin() -> second < A[i]))) {
                ans -= (st.begin() -> first * st.begin() -> second);
                st1.insert(*st.begin());
                st.erase(st.begin());
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else {
                st1.insert({fre[A[i]], A[i]});
            }
        }
        vector<ll> ret(1, ans);
        ll p = 0;
        for (ll i = K; i < N; ++i) {
            if (st.count({fre[A[p]], A[p]})) {
                st.erase({fre[A[p]], A[p]});
                ans -= (fre[A[p]] * A[p]);
            } else {
                st1.erase({fre[A[p]], A[p]});
            }
            fre[A[p]]--;
            if (st.size() < X) {
                st.insert({fre[A[p]], A[p]});
                ans += (fre[A[p]] * A[p]);
            } else if ((st.begin() -> first < fre[A[p]]) || ((st.begin() -> first == fre[A[p]]) && (st.begin() -> second < A[p]))) {
                ans -= (st.begin() -> first * st.begin() -> second);
                st1.insert(*st.begin());
                st.erase(st.begin());
                st.insert({fre[A[p]], A[p]});
                ans += (fre[A[p]] * A[p]);
            } else {
                st1.insert({fre[A[p]], A[p]});
            }
            p++;
            
            if (st.count({fre[A[i]], A[i]})) {
                st.erase({fre[A[i]], A[i]});
                ans -= (fre[A[i]] * A[i]);
            } else {
                st1.erase({fre[A[i]], A[i]});
            }
            fre[A[i]]++;
            if (st.size() < X) {
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else if ((st.begin() -> first < fre[A[i]]) || ((st.begin() -> first == fre[A[i]]) && (st.begin() -> second < A[i]))) {
                ans -= (st.begin() -> first * st.begin() -> second);
                st1.insert(*st.begin());
                st.erase(st.begin());
                st.insert({fre[A[i]], A[i]});
                ans += (fre[A[i]] * A[i]);
            } else {
                st1.insert({fre[A[i]], A[i]});
            }
            
            while (!st.empty() && !st1.empty()) {
                if (st.size() < X) {
                    st.insert(*st1.rbegin());
                    ans += (st1.rbegin() -> first * st1.rbegin() -> second);
                    st1.erase(*st1.rbegin());
                } else if ((st.begin() -> first < st1.rbegin() -> first) || ((st.begin() -> first == st1.rbegin() -> first) && (st.begin() -> second < st1.rbegin() -> second))) {
                    ans -= (st.begin() -> first * st.begin() -> second);
                    auto [x, y] = *st1.rbegin();
                    st1.insert(*st.begin());
                    st.erase(st.begin());
                    st.insert({x, y});
                    st1.erase({x, y});
                    ans += (x * y);
                } else {
                    break;
                }
            }
            
            ret.push_back(ans);
        }
        
        return ret;
    }
};",1420546697
尾玉,louisfghbvc,121,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        // goal: find the kth largest perfect tree size
        // idea: 
        // postorder dfs, return {size, depth}
        
        vector<int> ok;
        auto dfs = [&](auto &self, TreeNode* root) -> pair<int, int> {
            if (!root) return {0, 0};
            
            auto left = self(self, root->left);
            auto right = self(self, root->right);
            
            int dep = 1+max(left.second,right.second);
            int treeSize = left.first+right.first+1;
            
            if (dep < 30 && ((1<<dep)-1) == treeSize) {
                ok.push_back(treeSize);
            }
            
            return {treeSize, dep};
        };
        dfs(dfs, root);
        
        // return
        sort(ok.rbegin(), ok.rend());
        if (k-1 < ok.size())
            return ok[k-1];
        return -1;
    }
};",1420532661
尾玉,louisfghbvc,121,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        // goal: count the winning sequence of bob
        // idea:
        // F>E
        // W>F
        // E>W
        
        // dp[i][x]: number of way such that starting from index i, x is the diff of rewards
        // each index
        // we can win/draw/lose
        
        unordered_map<char, int> mp = {{'F', 0}, {'W', 1}, {'E', 2}};
        
        int mod = 1e9+7;
        
        int n = s.size();
        vector dp(n, vector(2*n+1, vector<long>(4, -1)));
        
        auto dfs = [&](auto &self, int i, int x, int prev) -> long {
            if (i >= n) return x > 0;
            
            auto& res = dp[i][x+n][prev];
            if (res != -1) return res;
            
            res = 0;
            // draw
            if (mp[s[i]] != prev) {
                res = self(self, i+1, x, mp[s[i]]);
            }
            // win
            if ((mp[s[i]]+1)%3 != prev) {
                res = (res + self(self, i+1, x+1, (mp[s[i]]+1)%3)) % mod;
            }
            // lose
            if ((mp[s[i]]+2)%3 != prev) {
                res = (res + self(self, i+1, x-1, (mp[s[i]]+2)%3)) % mod;
            }
            
            return res;
        };
        
        return dfs(dfs, 0, 0, 3);
    }
};",1420545823
尾玉,louisfghbvc,121,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        // goal: find the top x sum
        
        // idea:
        // brute force not work, need very fast way.
        // consider the add a element/remove a element
        
        // consider add
        // x = 2
        // [1, 1, 2, 2, 3, 4]
        // [1]
        
        // fre[0] = {1,2,3,4}
        // fre[1] = {1}
        // set<pair<int, int>> topX, other
        
        // fre => set, we will move from set
        
        // maintain two set
        
        int n = nums.size();
        
            
        using T = pair<long, long>;
        set<T> topX, noTopX; // {fre, val}
        long right = 0;
        
        unordered_map<int, int> fre;
        
        auto bal = [&]() -> void {
            if (topX.size() > x) {
                // cout << ""balance rem"" << ' ' << topX.begin()->first << ' ' << topX.begin()->second << '\n';
                right -= topX.begin()->first*topX.begin()->second;
                noTopX.insert(*topX.begin());
                topX.erase(topX.begin());
            }
            if (topX.size() < x && noTopX.size()) {
                // cout << ""balance add"" << ' ' << noTopX.rbegin()->first << ' ' << noTopX.rbegin()->second << '\n';
                right += noTopX.rbegin()->first*noTopX.rbegin()->second;
                topX.insert(*noTopX.rbegin()); 
                noTopX.erase(prev(noTopX.end()));
            }
        };
        
        auto insert = [&](long x, long f) -> void {
            noTopX.insert({f, x});
    
            // move left -> right
            // cout << ""insert "" << ' ' << noTopX.rbegin()->first << ' ' << noTopX.rbegin()->second << '\n';
            right += noTopX.rbegin()->first*noTopX.rbegin()->second;
            topX.insert(*noTopX.rbegin()); 
            noTopX.erase(prev(noTopX.end()));
            bal();
        };
        
        auto remove = [&](const T& val) -> void {
            // cout << ""try remove "" << val.first << ' ' << val.second << '\n';
            
            auto it = topX.find(val);
            if (it != topX.end()) {
                // cout << ""remove "" << ' ' << it->first << ' ' << it->second << '\n';
                right -= it->first*it->second;
                topX.erase(it);
            }
            else {
                noTopX.erase(val);
            }
            bal();
        };
       
        auto update = [&](int x, int op=1) -> void {
            if (op == 0) { // init
                fre[x] = 0;
                insert(x, 0);
            }
            else if (op == 1) { // add
                // cout << x << ' ' << fre[x] << endl;
                remove(make_pair(fre[x], x));
                fre[x]++;
                insert(x, fre[x]);
            }
            else { // remove
                remove(make_pair(fre[x], x));
                fre[x]--;
                insert(x, fre[x]);
            }
        };
        
        
        // init
        set<int> tot(nums.begin(), nums.end());
        for (int x: tot)
            update(x, 0);
        
        vector<long long> res;
        for (int i = 0; i < n; ++i) {
            if (i >= k) {
                // remove
                update(nums[i-k], 2);
            }
            // add
            update(nums[i], 1);
            // cout << ""right="" << right << endl;
            if (i >= k-1) {
                // get
                res.push_back(right);
            }
        }
        
        return res;
    }
};",1420597688
尾玉,louisfghbvc,121,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        // goal: find the sum that subarray size is k, top x 
        
        // idea:
        // just using slinding window
        
        unordered_map<int, int> top;
        int n = nums.size();
        
        auto helper = [&]() {
            vector<pair<int,int>> arr(top.begin(), top.end());
            sort(arr.begin(), arr.end(), [](auto& i, auto& j) {
                if (i.second != j.second) return i.second > j.second;
                return i.first > j.first;
            });
            
            int sum = 0;
            for (int i = 0; i < min(x, (int)arr.size()); ++i) {
                sum += arr[i].first * arr[i].second;
            }
            return sum;
        };
        
        vector<int> res;
        for (int i = 0; i < n; ++i) {
            if (i >= k) top[nums[i-k]]--;
            top[nums[i]]++;
            if (i >= k-1) {
                res.push_back(helper());
            }
        }
        
        return res;
    }
};",1420532599
Anuj Anand,coleworld223,122,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
using i32 = int;
using i64 = long long;
using p2 = array <i32, 2>;
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
      vector <i32> dp;
      auto dfs = [&] (auto &&dfs, TreeNode* cur) -> array <i32, 2> {
        if (cur -> left == NULL && cur -> right == NULL) {
          dp.push_back(1);
          return p2{1, 1};
        }
        i32 siz = 1;
        if (cur -> right == NULL) {
          siz += dfs(dfs, cur -> left)[1];
          return p2{0, siz};
        }
        else if (cur -> left == NULL) {
          siz += dfs(dfs, cur -> right)[1];
          return p2{0, siz};
        }
        else {
          auto [x, y] = dfs(dfs, cur -> left);
          auto [x1, y1] = dfs(dfs, cur -> right);
          i32 f = (x & x1 & (y == y1));
          siz += (y + y1);
          if (f) {
            dp.push_back(siz);
          }
          return p2{f, siz};
        }
      };
      dfs(dfs, root);
      sort(dp.rbegin(), dp.rend());
      // for (i32 x : dp) {
      //   cout << x << ' ';
      // }
      // cout << '\n';
      if (dp.size() < k) return -1;
      return dp[k - 1];
    }
};",1420532054
Anuj Anand,coleworld223,122,3588,cpp,"int mod = 1e9 + 7;
struct mi {
    int64_t v; explicit operator int64_t() const { return v % mod; }
    mi() { v = 0; }
    mi(int64_t _v) {
        v = (-mod < _v && _v < mod) ? _v : _v % mod;
        if (v < 0) v += mod;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
 
    mi& operator+=(const mi& m) {
        if ((v += m.v) >= mod) v -= mod;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += mod;
        return *this; }
    mi& operator*=(const mi& m) {
        v = v*m.v%mod; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, int64_t p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,mod-2); }
 
    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }
    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
    friend ostream& operator<<(ostream& os, const mi& m) {
        os << m.v; return os;
    }
    friend istream& operator>>(istream& is, mi& m) {
        int64_t x; is >> x;
        m.v = x;
        return is;
    }
    friend void __print(const mi &x) {
        cerr << x.v;
    }
};

using i32 = int;
using i64 = long long;

class Solution {
public:
    int countWinningSequences(string s) {
      const i32 M = s.size();
      vector <vector <mi>> dp (3, vector <mi> (2 * M + 5)); // {f, w, e}
      auto beat = [&] (i32 x, i32 y) -> int {
        if ((x + 2) % 3 == y) return 1;
        if ((y + 2) % 3 == x) return -1;
        return 0;
      };
      vector <i32> t;
      for (i32 i = 0; i < s.size(); ++i) {
        int x = 0;
        if (s[i] == 'F') x = 0;
        if (s[i] == 'W') x = 1;
        if (s[i] == 'E') x = 2;
        t.push_back(x);
      }
      // for (int x : t) {
      //   cout << x << ' ';
      // }
      // cout << '\n';
      dp[0][beat(0, t[0]) + M] = 1;
      dp[1][beat(1, t[0]) + M] = 1;
      dp[2][beat(2, t[0]) + M] = 1;
      for (i32 i = 1; i < M; ++i) {
        vector <vector <mi>> ndp (3, vector <mi> (2 * M + 5)); 
        for (i32 c = 0; c < 3; c += 1) {
          for (i32 sc = -M; sc <= M; sc++) {
            for (i32 nc = 0; nc < 3; nc++) if (c != nc) {
              i32 nsc = sc + beat(nc, t[i]);
              if (nsc + M >= 0 && nsc + M <= 2 * M) ndp[nc][nsc + M] += dp[c][sc + M];
            }
          }
        }
        dp = ndp;
      }
      // cout << beat(0, 2) << '\n';
      mi ans = 0;
      for (i32 sc = M + 1; sc <= 2 * M + 1; sc++) {
        for (i32 c = 0; c < 3; c++) {
          ans += dp[c][sc];
        }
      }
      // return 1;
      return ans.v;
    }
};",1420565407
Anuj Anand,coleworld223,122,3592,cpp,"using i32 = int;
using i64 = long long;
using a2 = array <i64, 2>;
struct DS {
  map <i64, i64> cnt;
  set <a2> s1, s2;
  i32 X;
  i64 sum = 0; // sum of all in s1
  DS(i32 X) {
    this -> X = X;
  }
  void insert(i32 x) {
    if (cnt.count(x)) {
      if (s1.count({-cnt[x], -x})) {
        s1.erase({-cnt[x], -x});
        sum -= (cnt[x] * x);
      }
      if (s2.count({-cnt[x], -x})) 
        s2.erase({-cnt[x], -x});
    }
    cnt[x] += 1;
    s2.insert({-cnt[x], -x});
    relax();
  }
  void relax() {
    while (s1.size() < X && !s2.empty()) {
      auto [f, x] = *begin(s2);
      sum += (f * x);
      s1.insert({f, x});
      s2.erase(begin(s2));
    }
    while (!s1.empty() && !s2.empty()) {
      auto [f1, x1] = *(--end(s1));
      auto [f2, x2] = *begin(s2);
      bool f = (f2 < f1 || (f1 == f2 && x2 < x1));
      if (f) {
        s1.erase(--end(s1));
        s2.erase(begin(s2));
        s1.insert({f2, x2});
        s2.insert({f1, x1});
        sum -= (f1 * x1);
        sum += (f2 * x2);
      }
      else break;
    }
  }
  void remove(i32 x) {
    if (s1.count({-cnt[x], -x})) {
      sum -= cnt[x] * x;
      s1.erase({-cnt[x], -x});
    }
    if (s2.count({-cnt[x], -x})) 
      s2.erase({-cnt[x], -x});
    cnt[x] -= 1;
    if (cnt[x] == 0) {
      cnt.erase(x);
      relax();
    }
    else {
      s2.insert({-cnt[x], -x});
      relax();
    }
  }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
      vector <i64> ans;
      DS ds(x);
      i32 n = nums.size();
      for (i32 i = 0; i < n; ++i) {
        ds.insert(nums[i]);
        if (i >= k) {
          ds.remove(nums[i - k]);
        }
        if (i >= k - 1) ans.push_back(ds.sum);
      }
      return ans;
    }
};",1420590855
Anuj Anand,coleworld223,122,3610,cpp,"using i32 = int;
using i64 = long long;
using a2 = array <i64, 2>;
struct DS {
  map <i64, i64> cnt;
  set <a2> s1, s2;
  i32 X;
  i64 sum = 0; // sum of all in s1
  DS(i32 X) {
    this -> X = X;
  }
  void insert(i32 x) {
    if (cnt.count(x)) {
      if (s1.count({-cnt[x], -x})) {
        s1.erase({-cnt[x], -x});
        sum -= (cnt[x] * x);
      }
      if (s2.count({-cnt[x], -x})) 
        s2.erase({-cnt[x], -x});
    }
    cnt[x] += 1;
    s2.insert({-cnt[x], -x});
    relax();
  }
  void relax() {
    while (s1.size() < X && !s2.empty()) {
      auto [f, x] = *begin(s2);
      sum += (f * x);
      s1.insert({f, x});
      s2.erase(begin(s2));
    }
    while (!s1.empty() && !s2.empty()) {
      auto [f1, x1] = *(--end(s1));
      auto [f2, x2] = *begin(s2);
      bool f = (f2 < f1 || (f1 == f2 && x2 < x1));
      if (f) {
        s1.erase(--end(s1));
        s2.erase(begin(s2));
        s1.insert({f2, x2});
        s2.insert({f1, x1});
        sum -= (f1 * x1);
        sum += (f2 * x2);
      }
      else break;
    }
  }
  void remove(i32 x) {
    if (s1.count({-cnt[x], -x})) {
      sum -= cnt[x] * x;
      s1.erase({-cnt[x], -x});
    }
    if (s2.count({-cnt[x], -x})) 
      s2.erase({-cnt[x], -x});
    cnt[x] -= 1;
    if (cnt[x] == 0) {
      cnt.erase(x);
      relax();
    }
    else {
      s2.insert({-cnt[x], -x});
      relax();
    }
  }
};

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
      vector <i32> ans;
      DS ds(x);
      i32 n = nums.size();
      for (i32 i = 0; i < n; ++i) {
        ds.insert(nums[i]);
        if (i >= k) {
          ds.remove(nums[i - k]);
        }
        if (i >= k - 1) ans.push_back(ds.sum);
      }
      return ans;
    }
};",1420591844
megaspazz,megaspazz,123,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def solve(u, out):
            if u is None:
                return 0
            lCurr = solve(u.left, out)
            rCurr = solve(u.right, out)
            if lCurr >= 0 and rCurr >= 0 and lCurr == rCurr:
                got = 1 + lCurr + rCurr
                out.append(got)
                return got
            else:
                return -1
        sizes = []
        solve(root, sizes)
        sizes = list(sorted(sizes))
        if k > len(sizes):
            return -1
        return sizes[len(sizes) - k]",1420532522
megaspazz,megaspazz,123,3588,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    
    private static final int[] NUM = new int[256];
    static {
        NUM['F'] = 0;
        NUM['W'] = 1;
        NUM['E'] = 2;
    }
    
    private static final int F = NUM['F'];
    private static final int W = NUM['W'];
    private static final int E = NUM['E'];
    
    private static final int[][] D = new int[3][3];
    static {
        D[F][E] = 1;
        D[E][F] = -1;
        D[W][F] = 1;
        D[F][W] = -1;
        D[E][W] = 1;
        D[W][E] = -1;
    }
    
    public int countWinningSequences(String s) {
        char[] S = s.toCharArray();
        int N = S.length;
        
        int[] A = new int[N];
        for (int i = 0; i < N; ++i) {
            A[i] = NUM[S[i]];
        }
        
        int w = N * 2 + 2;
        long[][] dp = new long[3][w];
        for (int c = 0; c < 3; ++c) {
            int delta = D[c][A[0]];
            dp[c][delta + N] = 1;
        }
        
        for (int i = 1; i < N; ++i) {
            long[][] next = new long[3][w];
            for (int cp = 0; cp < 3; ++cp) {
                for (int cn = 0; cn < 3; ++cn) {
                    if (cp == cn) {
                        continue;
                    }
                    for (int d = 0; d < w; ++d) {
                        int dn = d + D[cn][A[i]];
                        if (dn < 0 || dn >= w) {
                            continue;
                        }
                        // int deltaIdx = dn + N;
                        // if (deltaIdx < 0 || deltaIdx >= w) {
                        //     continue;
                        // }
                        next[cn][dn] = add(next[cn][dn], dp[cp][d]);
                    }
                }
            }
            dp = next;
        }
        
        long ans = 0;
        for (int i = N + 1; i < w; ++i) {
            for (int c = 0; c < 3; ++c) {
                ans = add(ans, dp[c][i]);
            }
        }
        return (int) ans;
    }
    
    private static final long RAW_MULTIPLY_MAX = 3037000499L;

    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;
    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;

    @SuppressWarnings(""unused"")
    public static long multiply(long a, long b) {
        if (MOD <= RAW_MULTIPLY_MAX) {
            return a * b % MOD;
        }
        return multiplyInternal(a, b);
    }

    public static long multiply(long... arr) {
        long ans = 1;
        for (long x : arr) {
            ans = multiply(ans, x);
        }
        return ans;
    }

    public static long add(long a, long b) {
        long ans = a + b;
        if (ans >= MOD) {
            ans -= MOD;
        }
        return ans;
    }

    public static long add(long... arr) {
        long ans = 0;
        for (long x : arr) {
            ans = add(ans, x);
        }
        return ans;
    }

    public static long subtract(long a, long b) {
        return add(a, MOD - b);
    }

    private static long normalize(long x) {
        if (x <= -MOD || x >= MOD) {
            x %= MOD;
        }
        if (x < 0) {
            x += MOD;
        }
        return x;
    }

    /**
     * Computes the value of (b ^ e) % MOD.
     */
    public static long modPow(long b, long e) {
        long p = b;
        long ans = 1;
        while (e > 0) {
            if ((e & 1) == 1) {
                ans = multiply(ans, p);
            }
            p = multiply(p, p);
            e >>= 1;
        }
        return ans;
    }

    /**
     * Computes the modular inverse, such that: ak % MOD = 1, for some k.
     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse
     */
    public static long modInverse(long a) {
        long b = MOD;
        long x0 = 0, x1 = 1;
        long t, q;

        while (a > 1) {
            q = a / b;

            t = b;
            b = a % b;
            a = t;

            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }

        if (x1 < 0) {
            x1 += MOD;
        }
        return x1;
    }

    private static long multiplyInternal(long a, long b) {
        if (a > b) {
            return multiplyInternal(b, a);
        }
        if (a == 0) {
            return 0;
        }

        long ans = 0;
        while (a > 0) {
            long mask = a & CHUNK_MASK;
            if (mask > 0) {
                ans = add(ans, (mask * b) % MOD);
            }
            b = (b << CHUNK_SIZE) % MOD;
            a >>= CHUNK_SIZE;
        }
        return ans;
    }
}",1420558096
megaspazz,megaspazz,123,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        final int N = nums.length;
        
        TreeSet<FreqVal> ts = new TreeSet<>(new Comparator<>() {
            @Override
            public int compare(FreqVal a, FreqVal b) {
                int df = Integer.compare(a.freq, b.freq);
                if (df != 0) {
                    return df;
                }
                return Integer.compare(a.val, b.val);
            }
        });
        CountMapInt<Integer> cm = new CountMapInt<>();
        LongDeque ans = new LongDeque();
        long overall = 0;
        Tracker t = new Tracker(x);
        for (int i = 0; i < N; ++i) {
            // System.out.format(""[start] i = %d%n"", i);
            if (i >= k) {
                // System.out.format(""i = %d, decrementing %d%n"", i, nums[i - k]);
                t.increment(nums[i - k], -1);
            }
            t.increment(nums[i], 1);
            
            // System.out.format(""i = %d, t.hold = %s, t.ts = %s, t.cm = %s, t.overall = %d%n"", i, t.hold, t.ts, t.cm, t.overall);
            
            if (i >= k - 1) {
                ans.add(t.overall);
            }
        }
        return ans.toArray();
    }
    
    private static class Tracker {
        public TreeSet<FreqVal> ts = new TreeSet<>(new Comparator<>() {
            @Override
            public int compare(FreqVal a, FreqVal b) {
                int df = Integer.compare(a.freq, b.freq);
                if (df != 0) {
                    return df;
                }
                return Integer.compare(a.val, b.val);
            }
        });
        public TreeSet<FreqVal> hold = new TreeSet<>(new Comparator<>() {
            @Override
            public int compare(FreqVal a, FreqVal b) {
                int df = Integer.compare(a.freq, b.freq);
                if (df != 0) {
                    return df;
                }
                return Integer.compare(a.val, b.val);
            }
        });
        public CountMapInt<Integer> cm = new CountMapInt<>();
        public long overall = 0;
        public int x;
        
        public Tracker(int x) {
            this.x = x;
        }
        
        public void increment(int val, int amount) {
            int prevCount = cm.getCount(val);
            FreqVal prev = new FreqVal(prevCount, val);
            if (ts.remove(prev)) {
                overall -= prev.total();
            }
            hold.remove(prev);
            
            cm.increment(val, amount);
            
            int nextCount = cm.getCount(val);
            FreqVal next = new FreqVal(nextCount, val);
            ts.add(next);
            overall += next.total();
            
            if (!hold.isEmpty()) {
                // System.out.format(""    BEFORE handling hold: hold = %s, ts = %s, overall = %d%n"", hold, ts, overall);
                FreqVal top = hold.pollLast();
                overall += top.total();
                ts.add(top);
                // System.out.format(""    AFTER handling hold: hold = %s, ts = %s, overall = %d%n"", hold, ts, overall);
            }
            
            while (ts.size() > x) {
                // System.out.format(""    BEFORE handling oversize: hold = %s, ts = %s, overall = %d%n"", hold, ts, overall);
                FreqVal rem = ts.pollFirst();
                // System.out.format(""    ts oversize: -> remove %s%n"", rem);
                overall -= rem.total();
                hold.add(rem);
                // System.out.format(""    AFTER handling oversize: hold = %s, ts = %s, overall = %d%n"", hold, ts, overall);
            }
        }
    }
    
    private static class FreqVal {
        public int freq;
        public int val;
        
        public FreqVal(int freq, int val) {
            this.freq = freq;
            this.val = val;
        }
        
        public long total() {
            return 1L * freq * val;
        }
        
        @Override
        public String toString() {
            return String.format(""%d*%d"", freq, val);
        }
    }
    
	/**
	 * Counts the frequency of objects.
	 * Change to extend TreeMap instead, if ordering of objects is required.
	 * 
	 * NOTE:  If `total` is needed, only use `increment(...)` for updates.
	 */
	public static class CountMapInt<T> extends HashMap<T, Integer> {
		private static final long serialVersionUID = -1501598139835601959L;

		public int total;

		public int getCount(T k) {
			return getOrDefault(k, 0);
		}

		public void increment(T k, int v) {
			total += v;
			int next = getCount(k) + v;
			if (next == 0) {
				remove(k);
			} else {
				put(k, next);
			}
		}

		public static <T> CountMapInt<T> fromArray(T[] A) {
			CountMapInt<T> cm = new CountMapInt<>();
			for (T x : A) {
				cm.increment(x, 1);
			}
			return cm;
		}
	}

	/**
	 * Circular buffer of long values, can be used as:
	 *   - ArrayList: values are added to end.
	 *   - Queue: values are added to end and removed from front.
	 *   - Stack: values are added to and removed from front.
	 */
	public static class LongDeque {
		private long[] arr;
		private int off;
		private int len;

		public LongDeque() {
			this(2);
		}

		public LongDeque(int capacity) {
			this.arr = new long[capacity];
		}

		public void addFirst(long x) {
			if (len == arr.length) {
				increaseCapacity();
			}
			if (off == 0) {
				off = arr.length;
			}
			arr[--off] = x;
			++len;
		}

		public void addLast(long x) {
			if (len == arr.length) {
				increaseCapacity();
			}
			int idx = index(off + len);
			arr[idx] = x;
			++len;
		}

		public long peekFirst() {
			return arr[off];
		}

		public long peekLast() {
			int idx = index(off + len - 1);
			return arr[idx];
		}

		public long removeFirst() {
			long ans = peekFirst();
			off = index(off + 1);
			--len;
			return ans;
		}

		public long removeLast() {
			long ans = peekLast();
			--len;
			return ans;
		}

		public void add(long x) {
			addLast(x);
		}

		public void offer(long x) {
			addLast(x);
		}

		public long poll() {
			return removeFirst();
		}

		public void push(long x) {
			addFirst(x);
		}

		public long pop() {
			return removeFirst();
		}

		public long peek() {
			return peekFirst();
		}

		public long get(int i) {
			if (i >= len) {
				throw new ArrayIndexOutOfBoundsException(String.format(""index %d out of range [0, %d)"", i, len));
			}
			int idx = index(i + off);
			return arr[idx];
		}

		public void set(int i, long x) {
			if (i >= len) {
				throw new ArrayIndexOutOfBoundsException(String.format(""index %d out of range [0, %d)"", i, len));
			}
			int idx = index(i + off);
			arr[idx] = x;
		}

		public int size() {
			return len;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		public long[] toArray() {
			if (len == 0) {
				return new long[0];
			}
			int idx = index(off + len);
			if (idx > off) {
				return Arrays.copyOfRange(arr, off, idx);
			}
			long[] A = new long[len];
			int endLen = arr.length - off;
			int startLen = len - endLen;
			System.arraycopy(arr, off, A, 0, endLen);
			System.arraycopy(arr, 0, A, endLen, startLen);
			return A;
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder();
			sb.append('[');
			printToBuffer(sb, "", "");
			sb.append(']');
			return sb.toString();
		}

		private void increaseCapacity() {
			long[] next = new long[arr.length << 1];
			int endLen = arr.length - off;
			System.arraycopy(arr, off, next, 0, endLen);
			System.arraycopy(arr, 0, next, endLen, off);
			arr = next;
			off = 0;
		}

		private int index(int i) {
			if (i >= arr.length) {
				i -= arr.length;
			} else if (i < 0) {
				i += arr.length;
			}
			return i;
		}

		private void printToBuffer(StringBuilder sb, CharSequence sep) {
			for (int i = 0; i < len; ++i) {
				if (i > 0) {
					sb.append(sep);
				}
				sb.append(get(i));
			}
		}

		public static LongDeque of(long... arr) {
			LongDeque deq = new LongDeque();
			for (long x : arr) {
				deq.add(x);
			}
			return deq;
		}
	}
}",1420597908
megaspazz,megaspazz,123,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def solve(A):
            c = list(map(lambda a: (a[1], a[0]), Counter(A).items()))
            c = list(reversed(sorted(c)))
            # print(A, c)
            take = min(x, len(c))
            return sum(map(lambda a: a[0] * a[1], c[:take]))
        ans = []
        for i in range(k, len(nums) + 1):
            ans.append(solve(nums[i-k:i]))
        return ans",1420525073
chengxia you,cy171,124,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        def dfs(node):
            if not node:
                return 0
            l = dfs(node.left)
            r = dfs(node.right)
        
            if l == r and l >= 0:
                ans.append(l+r+1)
                return l + r + 1
            else:
                return -1
        dfs(root)
        ans.sort(reverse = True)
        # print(ans)
        if len(ans) < k:
            return -1
        else:
            return ans[k-1]",1420563323
chengxia you,cy171,124,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        map = {""F"":0, ""W"":1, ""E"":2}
        dp = [[0,0,0] for i in range(2*n+5)]
        dp[0][map[s[0]]] += 1
        dp[1][(map[s[0]] + 1)%3] += 1
        dp[-1][(map[s[0]] - 1)%3] += 1

        for i, ch in enumerate(s[1:], 1):
            new = [[0,0,0] for i in range(2*n+5)]
            for j in range(-n, n+1):
                new[j][map[s[i]]] += dp[j][(map[s[i]] + 1)%3] + dp[j][(map[s[i]] +2 )%3]
                new[j][(map[s[i]] + 1)%3] += dp[j-1][(map[s[i]] + 2)%3] + dp[j-1][(map[s[i]] + 3)%3]
                new[j][(map[s[i]] - 1)%3] += dp[j+1][(map[s[i]])%3] + dp[j+1][(map[s[i]] + 1)%3]
                for k in range(3):
                    new[j][k] %= 10**9 + 7
            dp = new
            # print(dp)
        return sum(sum(dp[i]) for i in range(1, n+1)) % (10**9 + 7)",1420585914
chengxia you,cy171,124,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def remove(num):
            nonlocal curr
            idx = slist.bisect_left((c[num], num))
            if idx >= len(slist) - x:
                slist.remove((c[num], num))
                curr -= num*c[num]
                if len(slist) >= x:
                    curr += slist[len(slist) - x][1] * slist[len(slist) - x][0]
            else:
                slist.remove((c[num], num))

        def add(num):
            nonlocal curr
            if len(slist) < x:
                curr += num * c[num]
            elif (c[num], num) >= slist[len(slist) - x]:
                curr -= slist[len(slist) - x][1]*slist[len(slist) - x][0]
                curr += num * c[num]
            slist.add((c[num], num))
            
        slist = SortedList()
        c = Counter()
        curr = r = 0
        stack = deque()
        ans = []
        for i in range(len(nums)):
            stack.append(nums[i])
            if c[nums[i]] > 0:
                remove(nums[i])
            c[nums[i]] += 1
            add(nums[i])
            if len(stack) > k:
                val = stack.popleft()
                remove(val)
                c[val] -= 1
                add(val)
            
            if len(stack) == k:
                # print(i, stack, slist, curr)
                ans.append(curr)

            
        return ans


",1420549352
chengxia you,cy171,124,3610,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def remove(num):
            nonlocal curr
            idx = slist.bisect_left((c[num], num))
            if idx >= len(slist) - x:
                slist.remove((c[num], num))
                curr -= num*c[num]
                if len(slist) >= x:
                    curr += slist[len(slist) - x][1] * slist[len(slist) - x][0]
            else:
                slist.remove((c[num], num))

        def add(num):
            nonlocal curr
            if len(slist) < x:
                curr += num * c[num]
            elif (c[num], num) >= slist[len(slist) - x]:
                curr -= slist[len(slist) - x][1]*slist[len(slist) - x][0]
                curr += num * c[num]
            slist.add((c[num], num))
            
        slist = SortedList()
        c = Counter()
        curr = r = 0
        stack = deque()
        ans = []
        for i in range(len(nums)):
            stack.append(nums[i])
            if c[nums[i]] > 0:
                remove(nums[i])
            c[nums[i]] += 1
            add(nums[i])
            if len(stack) > k:
                val = stack.popleft()
                remove(val)
                c[val] -= 1
                add(val)
            
            if len(stack) == k:
                # print(i, stack, slist, curr)
                ans.append(curr)

            
        return ans


",1420563977
Nikhil Dixit,nikhil_dixit_abv_iiitm,125,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getHeight(TreeNode* node) {
    if (!node) return 0;
    return 1 + max(getHeight(node->left), getHeight(node->right));
}

bool isPerfectB(TreeNode* node) {
    if (!node) return true;


    int leftHeight = getHeight(node->left);
    int rightHeight = getHeight(node->right);

    return (leftHeight == rightHeight) && isPerfectB(node->left) && isPerfectB(node->right);
}

void find2(TreeNode* node, map<TreeNode*, int>& isPerfect) {
    if (!node) return;

 
    find2(node->left, isPerfect);
    find2(node->right, isPerfect);


    if (isPerfectB(node)) {
        isPerfect[node] = 1;
    } else {
        isPerfect[node] = 0;
    }
}
    int find(TreeNode* root,map<TreeNode*,int> &size){
        if(root==NULL){
            return 0;
        }
        int lefty=find(root->left,size);
        int righty=find(root->right,size);
        return size[root]=1+lefty+righty;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
      map<TreeNode*,int> size;
      find(root,size);
      map<TreeNode*,int> isPerfect;
      find2(root,isPerfect);
        vector<int> v;
        for(auto i:size){
            if(isPerfect[i.first]==1){
                v.push_back(i.second);
            }
        }
        sort(v.rbegin(),v.rend());
        if(v.size()<k){
            return -1;
        }else{
            return v[k-1];
        }
    }
};",1420542102
Nikhil Dixit,nikhil_dixit_abv_iiitm,125,3588,cpp,"#define ll long long int
ll dp[1001][2001][4];
class Solution {
public:
    ll find(string &s,ll n,ll ind,ll score,ll prev,vector<char>& v){
        if(ind==n){
            if(score>0){
                return 1;
            }else{
                return 0;
            }
        }
        if(dp[ind][score+n][prev]!=-1){
            return dp[ind][score+n][prev];
        }
        ll mod=1e9+7;
        ll ans=0;
        for(ll i=0;i<v.size();i++){
            if(i!=prev){
                if(v[i]=='F'){
                    if(s[ind]=='F'){
                        ans=(ans+find(s,n,ind+1,score,i,v))%mod;
                    }else if(s[ind]=='W'){
                        ans=(ans+find(s,n,ind+1,score-1,i,v))%mod;
                    }else if(s[ind]=='E'){
                        ans=(ans+find(s,n,ind+1,score+1,i,v))%mod;
                    }
                }else if(v[i]=='W'){
                    if(s[ind]=='F'){
                        ans=(ans+find(s,n,ind+1,score+1,i,v))%mod;
                    }else if(s[ind]=='W'){
                        ans=(ans+find(s,n,ind+1,score,i,v))%mod;
                    }else if(s[ind]=='E'){
                        ans=(ans+find(s,n,ind+1,score-1,i,v))%mod;
                    }
                }else if(v[i]=='E'){
                    if(s[ind]=='F'){
                        ans=(ans+find(s,n,ind+1,score-1,i,v))%mod;
                    }else if(s[ind]=='W'){
                        ans=(ans+find(s,n,ind+1,score+1,i,v))%mod;
                    }else if(s[ind]=='E'){
                        ans=(ans+find(s,n,ind+1,score,i,v))%mod;
                    }
                }
            }
        }
        return dp[ind][score+n][prev]=ans;
    }
    int countWinningSequences(string s) {
        ll n=s.length();
        for(ll i=0;i<=n;i++){
            for(ll j=0;j<=2*n;j++){
                dp[i][j][0]=-1;
                dp[i][j][1]=-1;
                dp[i][j][2]=-1;
                dp[i][j][3]=-1;
            }
        }
        vector<char> v;
        v.push_back('F');
        v.push_back('W');
        v.push_back('E');
        ll ans=find(s,n,0,0,3,v);
        return ans;
    }
};",1420544222
Nikhil Dixit,nikhil_dixit_abv_iiitm,125,3592,cpp,"#define ll long long 
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        ll n=nums.size();
        ll pref[n];
        ll sum=0;
        for(ll i=0;i<n;i++){
            sum=sum+nums[i];
            pref[i]=sum;
        }
        map<ll,ll> freq;
        for(ll i=0;i<k;i++){
            freq[nums[i]]++;
        }
        multiset<pair<ll,ll>> track;
        for(auto i:freq){
            track.insert({i.second,i.first});
        }
        multiset<pair<ll,ll>> s;
        sum=0;
        vector<ll> ans;
        while(s.size()!=x&&track.size()!=0){
            auto p=*track.rbegin();
            track.erase(track.find(p));
            sum=sum+(p.first*p.second);
            s.insert(p);
        }
  
     
    
        
        for(ll i=k-1;i<n;i++){
            ll r=i;
            ll l=r-k+1;
            if(s.size()<x){
                ll abc=pref[r];
                if(l-1>=0){
                    abc=abc-pref[l-1];
                }
                ans.push_back(abc);
            }else{
                ans.push_back(sum);
            }
            pair<ll,ll> p;
            p.first=freq[nums[l]];
            p.second=nums[l];
            freq[nums[l]]--;
            if(track.count(p)){
                track.erase(track.find(p));
                if(p.first-1!=0){
                    track.insert({p.first-1,p.second});    
                }
            }else{
                s.erase(s.find(p));
                sum=sum-(p.first*p.second);
                if(p.first-1!=0){
                    track.insert({p.first-1,p.second});    
                }
            }
            if(i+1<n){
                p.first=freq[nums[i+1]];
                p.second=nums[i+1];
                freq[p.second]++;
                if(track.count(p)){
                    track.erase(track.find(p));
                }else if(s.count(p)){
                    s.erase(s.find(p));
                    sum=sum-(p.first*p.second);
                }
                track.insert({p.first+1,p.second});
            }
             while(s.size()!=x&&track.size()!=0){
                auto p=*track.rbegin();
                track.erase(track.find(p));
                sum=sum+(p.first*p.second);
                s.insert(p);
            } 
           
            while(s.size()!=0&&track.size()!=0){
                auto p1=*s.begin();
                auto p2=*track.rbegin();
                if(p1.first<p2.first){
                    s.erase(s.find(p1));
                    track.erase(track.find(p2));
                    track.insert(p1);
                    s.insert(p2);
                    sum=sum-(p1.first*p1.second);
                    sum=sum+(p2.first*p2.second);
                }else if(p1.first>p2.first){
                    break;
                }else{
                    if(p1.second<p2.second){
                        s.erase(s.find(p1));
                        track.erase(track.find(p2));
                        track.insert(p1);
                        s.insert(p2);
                        sum=sum-(p1.first*p1.second);
                        sum=sum+(p2.first*p2.second);
                    }else{
                        break;
                    }
                }
            }
            
            
        }
        return ans;
        
        
        
    }
};",1420592939
Nikhil Dixit,nikhil_dixit_abv_iiitm,125,3610,cpp,"class Solution {
public:
    int find(vector<int>& nums,int l,int r,int x){
        map<int,int> m;
        int sum=0;
        for(int i=l;i<=r;i++){
            m[nums[i]]++;
            sum=sum+nums[i];
        }
        if(m.size()<=x){
            return sum;
        }
        vector<pair<int,int>> v;
        for(auto i:m){
            v.push_back({i.second,i.first});
        }
        sort(v.rbegin(),v.rend());
        sum=0;
        for(int i=0;i<x;i++){
            sum=sum+(v[i].first*v[i].second);
        }
        return sum;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            int l=i;
            int r=i+k-1;
            if(r<nums.size()){
                int see=find(nums,l,r,x);
                ans.push_back(see);
            }
        }
        return ans;
    }
};",1420541883
Denys Gubar,DenisGubar,126,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> A;
    pair<bool, int> calc(TreeNode* root)
    {
        if (!root)
            return { true, 0 };
        pair<bool, int> L = calc(root->left);
        pair<bool, int> R = calc(root->right);
        pair<bool, int> result{ L.first && R.first && L.second == R.second, L.second + R.second + 1};
        if (result.first)
            A.push_back(result.second);
        return result;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        A.reserve(2'000);
        calc(root);
        if (A.size() < k)
            return -1;
        sort(A.begin(), A.end(), greater<int>{});
        return A[k - 1];
    }
};
",1420527911
Denys Gubar,DenisGubar,126,3588,cpp,"static int F[1'001][2'001][4];
static int const MOD = 1'000'000'007;
class Solution {
public:
    int countWinningSequences(string s) {
        string const A{ ""$FEW"" };
        set<pair<char, char>> const S{ {'F', 'E'}, {'W', 'F'}, {'E', 'W'} };
        int const N = s.size();
        memset(F, 0, sizeof(F));
        F[0][N][0] = 1;
        for (int i = 0; i < N; ++i)
            for (int j = N - i; j <= N + i; ++j)
            {
                for (int prev = 0; prev < 4; ++prev)
                    for (int next = 1; next < 4; ++next)
                        if (prev != next && F[i][j][prev])
                        {
                            int win = (S.find({ A[next], s[i] }) != S.end()) - (S.find({ s[i], A[next] }) != S.end());
                            F[i + 1][j + win][next] += F[i][j][prev];
                            F[i + 1][j + win][next] %= MOD;
                        }
            }
        long long result = 0;
        for (int j = N + 1; j <= 2 * N; ++j)
            for (int next = 1; next < 4; ++next)
                result += F[N][j][next];
        return result % MOD;
    }
};
",1420559639
Denys Gubar,DenisGubar,126,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int const N = nums.size();
        vector<long long> result;
        result.reserve(N - k);
        unordered_map<int, int> M;
        set<pair<int, int>> S, R;
        long long sum = 0;
        auto add = [&M, x, &sum, &S, &R](int value)
            {
                if (++M[value] > 1)
                {
                    if (auto it = S.find({ M[value] - 1, value }); it != S.end())
                    {
                        sum -= (M[value] - 1LL) * value;
                        S.erase(it);
                    }
                    else
                        R.erase({ M[value] - 1, value });
                }
                pair<int, int> const P{ M[value], value };
                if (R.empty() && S.size() < x)
                {
                    S.insert(P);
                    sum += 1LL * P.first * P.second;
                }
                else
                    R.insert(P);
                if (S.size() == x && !R.empty() && *R.rbegin() > *S.begin())
                {
                    sum -= 1LL * S.begin()->first * S.begin()->second;
                    R.insert(*S.begin());
                    S.erase(S.begin());
                }
                while (!R.empty() && S.size() < x)
                {
                    auto it = prev(R.end());
                    S.insert(*it);
                    sum += 1LL * it->first * it->second;
                    R.erase(it);
                }
            };
        auto remove = [&M, x, &sum, &S, &R](int value)
            {
                --M[value];
                if (auto it = S.find({ M[value] + 1, value }); it != S.end())
                {
                    sum -= (M[value] + 1LL) * value;
                    S.erase(it);
                }
                else
                    R.erase({ M[value] + 1, value });
                if (M[value] == 0)
                {
                    M.erase(value);
                    return;
                }
                pair<int, int> const P{ M[value], value };
                if (R.empty() && S.size() < x)
                {
                    S.insert(P);
                    sum += 1LL * P.first * P.second;
                }
                else
                    R.insert(P);
                while (!R.empty() && S.size() < x)
                {
                    auto it = prev(R.end());
                    S.insert(*it);
                    sum += 1LL * it->first * it->second;
                    R.erase(it);
                }
            };
        for (int i = 0; i < k; ++i)
            add(nums[i]);
        result.push_back(sum);
        for (int i = k; i < N; ++i)
        {
            remove(nums[i - k]);
            add(nums[i]);
            result.push_back(sum);
        }
        return result;
    }
};
",1420599582
Denys Gubar,DenisGubar,126,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int const N = nums.size();
        vector<int> result;
        for (int i = 0; i + k <= N; ++i)
        {
            unordered_map<int, int> M;
            for (int j = i, z = 0; z < k; ++j, ++z)
                ++M[nums[j]];
            vector<pair<int, int>> P;
            for (auto [key, value] : M)
                P.emplace_back(-value, -key);
            sort(P.begin(), P.end());
            int sum = 0;
            for (int j = 0; j < P.size() && j < x; ++j)
                sum += P[j].first * P[j].second;
            result.push_back(sum);
        }
        return result;
    }
};
",1420521214
chasel,hululu0405,127,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfects = []
        def dfs(root):
            if not root:
                return 0
            l = dfs(root.left)
            r = dfs(root.right)
            if l == -1 or r == -1 or l != r:
                return -1
            perfects.append(l + r + 1)
            return l + r + 1
        dfs(root)
        perfects.sort(reverse=True)
        return perfects[k - 1] if k <= len(perfects) else -1
",1420526406
chasel,hululu0405,127,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        def fight(a, b):
            if a == ""F"":
                if b == ""E"":
                    return 1
                elif b == ""W"":
                    return -1
            elif a == ""W"":
                if b == ""F"":
                    return 1
                elif b == ""E"":
                    return -1
            else:
                if b == ""W"":
                    return 1
                elif b == ""F"":
                    return -1
            return 0

        @cache
        def dp(i, prev, point):
            if i == len(s):
                return int(point > 0)
            res = 0
            for c in ""FWE"":
                if c == prev:
                    continue
                res += dp(i + 1, c, point + fight(c, s[i]))
                res %= 1_000_000_007
            return res
        
        return dp(0, '', 0)",1420533191
chasel,hululu0405,127,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        counter = Counter(nums[:k - 1])
        sl = SortedList(counter.keys(), key=lambda a: (-counter[a], -a))
        total = 0
        in_total = set()
        for i in range(min(x, len(sl))):
            total += sl[i] * counter[sl[i]]
            in_total.add(sl[i])

        for i in range(k - 1, len(nums)):
            if nums[i] in sl:
                sl.remove(nums[i])
            counter[nums[i]] += 1
            sl.add(nums[i])
            j = sl.bisect_left(nums[i])
            if j < x:
                if nums[i] in in_total:
                    total += nums[i]
                else:
                    total += nums[i] * counter[nums[i]]
                    in_total.add(nums[i])
            if len(sl) > x and sl[x] in in_total:
                total -= sl[x] * counter[sl[x]]
                in_total.remove(sl[x])

            res.append(total)

            sl.remove(nums[i - k + 1])
            counter[nums[i - k + 1]] -= 1
            sl.add(nums[i - k + 1])
            j = sl.bisect_left(nums[i - k + 1])
            if nums[i - k + 1] in in_total:
                if j >= x:
                    total -= nums[i - k + 1] * (counter[nums[i - k + 1]] + 1)
                    in_total.remove(nums[i - k + 1])
                else:
                    total -= nums[i - k + 1]
            if len(sl) >= x and sl[x - 1] not in in_total:
                total += sl[x - 1] * counter[sl[x - 1]]
                in_total.add(sl[x - 1])
        return res
",1420599787
chasel,hululu0405,127,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums) - k + 1):
            c = [[count, val] for val, count in Counter(nums[i:i + k]).items()]
            c = heapq.nlargest(x, c)
            res.append(sum(val * count for count, val in c))
        return res
",1420520856
Ivan Vasilenko,8symbols,129,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def dfs(node):
            if not node:
                return True, 0, 0

            is_left_perfect, left_size, left_depth = dfs(node.left)
            is_right_perfect, right_size, right_depth = dfs(node.right)

            size = left_size + right_size + 1
            depth = left_depth + 1

            if is_left_perfect and is_right_perfect and left_size == right_size and left_depth == right_depth:
                sizes.append(size)
                return True, size, depth

            return False, size, depth

        dfs(root)
        sizes.sort(reverse=True)
        k -= 1
        return sizes[k] if k < len(sizes) else -1
        ",1420530445
Ivan Vasilenko,8symbols,129,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        modulo = 10 ** 9 + 7

        beats = {
            'F': 'E',
            'W': 'F',
            'E': 'W',
        }

        @cache
        def dp(index, previous, delta):
            if index == len(s):
                return int(delta < 0)

            count = 0

            for move in 'FWE':
                if move == previous:
                    continue

                is_good_move = beats[move] == s[index]
                is_bad_move = move == beats[s[index]]

                count += dp(index + 1, move, delta + (1 if is_bad_move else -1 if is_good_move else 0))

            return count % modulo

        return dp(0, '', 0)",1420562074
Ivan Vasilenko,8symbols,129,3592,python3,"from sortedcontainers import SortedList


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        sl = SortedList(key=lambda x: (-x[0], -x[1]))
        counter = Counter()

        for j in range(k):
            counter[nums[j]] += 1

        used = set()
        for num in nums:
            if num in used:
                continue
            sl.add((counter[num], num))
            used.add(num)

        s = sum(sl[i][0] * sl[i][1] for i in range(min(x, len(sl))))
        answer = [s]

        def change_count(num, count_delta):
            previous_count = counter[num]
            previous_index = sl.index((previous_count, num))
            was_in_top = previous_index < x

            sl.remove((previous_count, num))
            counter[num] += count_delta
            sl.add((counter[num], num))

            count = counter[num]
            index = sl.index((count, num))
            is_in_top = index < x

            nonlocal s

            if was_in_top and is_in_top:
                s += num * count_delta
            if was_in_top and not is_in_top:
                s += sl[x - 1][0] * sl[x - 1][1] - previous_count * num
            if not was_in_top and is_in_top:
                s += count * num - sl[x][0] * sl[x][1]

        for end in range(k, len(nums)):
            previous_start = end - k
            change_count(nums[end], 1)
            change_count(nums[previous_start], -1)
            answer.append(s)

        return answer",1420600476
Ivan Vasilenko,8symbols,129,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def calculate_x_sum(start, end):
            counter = Counter()
            for i in range(start, end + 1):
                counter[nums[i]] += 1
            values = sorted([(count, num) for num, count in counter.items()], reverse=True)[:x]
            return sum(num * count for num, count in values)

        return [calculate_x_sum(i, i + k - 1) for i in range(len(nums) - k + 1)]",1420522747
svmh,SupervisorMayHap,130,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def dfs(cur):
            left, right = 0, 0
            if cur.left:
                left = dfs(cur.left)
            if cur.right:
                right = dfs(cur.right)
            if left == -1 or right == -1:
                return -1
            if left == right:
                res.append(left + right + 1)
                return left + right + 1
            else:
                return -1
        dfs(root)
        res = sorted(res)[::-1]
        if k > len(res):
            return -1
        else:
            return res[k - 1]
            
            
        
        ",1420522416
svmh,SupervisorMayHap,130,3588,python3,"class Solution:
    # F > E, E > W, W > F, 
    # F 0
    # E 1
    # W 2
    # dp[i][j]
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = 1000000000 + 7
        # 100
        # 1 - 201
        # 101
        dp = [[[0, 0, 0] for _ in range(n * 2 + 5)] for j in range(n + 1)]
        if s[0] == 'F':
            dp[1][n + 1][0] = 1
            dp[1][n][1] = 1
            dp[1][n + 2][2] = 1
        elif s[0] == 'E':
            dp[1][n + 2][0] = 1
            dp[1][n + 1][1] = 1
            dp[1][n][2] = 1
        else:
            dp[1][n][0] = 1
            dp[1][n + 2][1] = 1
            dp[1][n + 1][2] = 1
        for i in range(1, n):
            for j in range(1, n * 2 + 2):
                if s[i] == 'F':
                    dp[i + 1][j][0] = dp[i][j][1] + dp[i][j][2]
                    dp[i + 1][j][1] = dp[i][j + 1][2] + dp[i][j + 1][0]
                    dp[i + 1][j][2] = dp[i][j - 1][1] + dp[i][j - 1][0]
                elif s[i] == 'E':
                    dp[i + 1][j][0] = dp[i][j - 1][1] + dp[i][j - 1][2]
                    dp[i + 1][j][1] = dp[i][j][2] + dp[i][j][0]
                    dp[i + 1][j][2] = dp[i][j + 1][1] + dp[i][j + 1][0]
                elif s[i] == 'W':
                    dp[i + 1][j][0] = dp[i][j + 1][1] + dp[i][j + 1][2]
                    dp[i + 1][j][1] = dp[i][j - 1][0] + dp[i][j - 1][2]
                    dp[i + 1][j][2] = dp[i][j][1] + dp[i][j][0]
                dp[i + 1][j][0] %= mod
                dp[i + 1][j][1] %= mod
                dp[i + 1][j][2] %= mod
        
        res = 0
        for i in range(n + 2, n * 2 + 5):
            for j in range(3):
                res += dp[-1][i][j]
                res %= mod
        return res
                    
                
                
            
        ",1420552486
svmh,SupervisorMayHap,130,3592,python3,"from sortedcontainers import SortedList
from collections import defaultdict


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        upper_lis = SortedList()
        lower_lis = SortedList()
        n = len(nums)
        res = []
        cur_sum = 0
        dic = defaultdict(int)

        for i, num in enumerate(nums):
            if num in dic:
                e = [dic[num], num]
                if e in upper_lis:
                    upper_lis.remove(e)
                    cur_sum -= e[0] * e[1]
                if e in lower_lis:
                    lower_lis.remove(e)
            dic[num] += 1
            lower_lis.add([dic[num], num])

            if i >= k:
                num = nums[i - k]
                e = [dic[num], num]
                if e in upper_lis:
                    upper_lis.remove(e)
                    cur_sum -= e[0] * e[1]
                if e in lower_lis:
                    lower_lis.remove(e)
                dic[num] -= 1
                if dic[num] == 0:
                    dic.pop(num)
                else:
                    lower_lis.add([dic[num], num])

            if i >= k - 1:
                if upper_lis:
                    tmp = upper_lis.pop(0)
                    lower_lis.add(tmp)
                    cur_sum -= tmp[0] * tmp[1]
                    
                while len(upper_lis) < x and lower_lis:
                    last = lower_lis.pop(-1)
                    cur_sum += last[0] * last[1]
                    upper_lis.add(last)
                res.append(cur_sum)
        return res
",1420594831
svmh,SupervisorMayHap,130,3610,python3,"from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        for i in range(n - k + 1):
            cur_num = nums[i:i + k]
            counter = Counter(cur_num)
            arr = [(-v, -k) for k, v in counter.items()]
            arr = sorted(arr)[:x]
            res.append(sum([a[0] * a[1] for a in arr]))
        return res",1420519899
krishnanshu19,krishnanshu19,132,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* root, priority_queue<int>& pq)
    {
        if(root==nullptr) return 0;
        
        auto l = dfs(root->left, pq);
        auto r = dfs(root->right, pq);

        if(l!=-1 && l==r) 
        {
            pq.push(2*l+1);
            return 2*l+1;
        }
        return -1;

    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        priority_queue<int> pq;
        dfs(root, pq);
        if(pq.size()>=k)
        {
            int i=0,ans=0;
            while(i<k)
            {
                ans = pq.top();
                pq.pop();
                i++;
            }
            return ans;
        }
        return -1;

    }
};",1420572606
krishnanshu19,krishnanshu19,132,3588,cpp,"class Solution {
public:
    static const int MOD = 1e9+7;
    int point(int p1, int p2)
    {
        if(p1==p2) return 1;
        if(p1==0 && p2==1) return 0;
        if(p1==0 && p2 == 2) return 2;
        if(p1==1 && p2==0) return 2;
        if(p1==1 && p2 == 2) return 0;
        if(p1==2 && p2==0) return 0;
        if(p1==2 && p2 == 1) return 2;
        return -1;
    }
    int convert(char c)
    {
        if(c=='F') return 0;
        if(c=='E') return 1;
        return 2;
    }
    int count(int i, int score, int vary, vector<vector<vector<int>>>& dp, string& s)
    {
        if(i==s.size())
        {
            return (score==0 ? 1 : 0);
        }
        if(score <0) return 0;
        if(dp[i][score][vary]>-1) return dp[i][score][vary];

        int p1 = convert(s[i]);
        int ans = 0;
        if(vary == 0)
        {
            ans = (ans + count(i+1, score - point(p1,0), 1, dp ,s)  )%MOD;
            ans = (ans + count(i+1, score - point(p1,1), 2, dp ,s)  )%MOD;
        }
        else if(vary == 1)
        {
            ans = (ans + count(i+1, score - point(p1,1), 2, dp ,s)  )%MOD;
            ans = (ans + count(i+1, score - point(p1,2), 0, dp ,s)  )%MOD;
        }
        else if(vary == 2)
        {
            ans = (ans + count(i+1, score - point(p1,0), 1, dp ,s)  )%MOD;
            ans = (ans + count(i+1, score - point(p1,2), 0, dp ,s)  )%MOD;
        }
        else
        {
            ans = (ans + count(i+1, score - point(p1,0), 1, dp ,s)  )%MOD;
            ans = (ans + count(i+1, score - point(p1,1), 2, dp ,s)  )%MOD;
            ans = (ans + count(i+1, score - point(p1,2), 0, dp ,s)  )%MOD;
        }
        dp[i][score][vary] = ans;
        return ans;

    }
    int countWinningSequences(string s) {
        int n = s.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int>> (2*n+1, vector<int>(4,-1)));
        int ans = 0;
        for(int score = 2*n; score>n;score--)
        {
            ans=(ans+count(0,score, 3, dp, s))%MOD;
        }
        return ans;
    }
};",1420600822
krishnanshu19,krishnanshu19,132,3592,cpp,"class Solution {
public:
using ll = long long;
    struct window
    {
        ll sum = 0,x;
        unordered_map<int,ll> ct;
        set<pair<ll,int>> top_x, rest;
        window(int _x) : x{_x}
        {}

        void remove(int key)
        {
            int prev = ct[key];
            if(top_x.find({prev, key})!= top_x.end())
            {
                sum-=(ll)prev*key;
                top_x.erase({prev,key});
                while(rest.size() > 0 && top_x.size()<x)
                {
                    int count = (*(rest.rbegin())).first, k  = (*(rest.rbegin())).second ;
                    sum+= (ll)count*k;
                    top_x.insert({count,k});
                    rest.erase({count,k});
                }
            }
            else if(rest.find({prev, key})!= rest.end())
            {
                rest.erase({prev,key});
            }


        }
        void add(int key)
        {
            int prev = ct[key];
            top_x.insert({prev, key});
            sum+= (ll) prev*key;

            while(top_x.size() > x)
            {
                int count = (*(top_x.begin())).first, k  = (*(top_x.begin())).second ;
                sum-= (ll)count*k;
                top_x.erase({count,k});
                rest.insert({count,k});
            
            }
        }
        void print()
        {
            for(auto y: top_x)
            {
                cout<<""{""<<y.first<<"" ""<<y.second<<""},"";
            }
            cout<<endl;
            for(auto y: rest)
            {
                cout<<""{""<<y.first<<"" ""<<y.second<<""},"";
            }
            cout<<endl;
            cout<<sum<<endl;
        }
        void increment(int key)
        {
            remove(key);
            ct[key]++;
            add(key);
        }
        void decrement(int key)
        {
            remove(key);
            if(ct[key]==1) ct.erase(key);
            else
            {
                ct[key]--;
                add(key);
            }
        }
    };
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        window w(x);
        for(int i=0;i<k;i++)
        {
            w.increment(nums[i]);
        }
        vector<ll> ans;
        ans.push_back(w.sum);
        // w.print();

        for(int i=k;i<nums.size();i++)
        {
            w.decrement(nums[i-k]);
            w.increment(nums[i]);
            // w.print();
            ans.push_back(w.sum);
        }
        return ans;
    }
};",1420559797
krishnanshu19,krishnanshu19,132,3610,cpp,"class Solution {
public:
    using ll = long long;
    struct window
    {
        ll sum = 0,x;
        unordered_map<int,ll> ct;
        set<pair<ll,int>> top_x, rest;
        window(int _x) : x{_x}
        {}

        void remove(int key)
        {
            int prev = ct[key];
            if(top_x.find({prev, key})!= top_x.end())
            {
                sum-=(ll)prev*key;
                top_x.erase({prev,key});
                while(rest.size() > 0 && top_x.size()<x)
                {
                    int count = (*(rest.rbegin())).first, k  = (*(rest.rbegin())).second ;
                    sum+= (ll)count*k;
                    top_x.insert({count,k});
                    rest.erase({count,k});
                }
            }
            else if(rest.find({prev, key})!= rest.end())
            {
                rest.erase({prev,key});
            }


        }
        void add(int key)
        {
            int prev = ct[key];
            top_x.insert({prev, key});
            sum+= (ll) prev*key;

            while(top_x.size() > x)
            {
                int count = (*(top_x.begin())).first, k  = (*(top_x.begin())).second ;
                sum-= (ll)count*k;
                top_x.erase({count,k});
                rest.insert({count,k});
            
            }
        }
        void print()
        {
            for(auto y: top_x)
            {
                cout<<""{""<<y.first<<"" ""<<y.second<<""},"";
            }
            cout<<endl;
            for(auto y: rest)
            {
                cout<<""{""<<y.first<<"" ""<<y.second<<""},"";
            }
            cout<<endl;
            cout<<sum<<endl;
        }
        void increment(int key)
        {
            remove(key);
            ct[key]++;
            add(key);
        }
        void decrement(int key)
        {
            remove(key);
            if(ct[key]==1) ct.erase(key);
            else
            {
                ct[key]--;
                add(key);
            }
        }
    };
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        window w(x);
        for(int i=0;i<k;i++)
        {
            w.increment(nums[i]);
        }
        vector<int> ans;
        ans.push_back(w.sum);
        // w.print();

        for(int i=k;i<nums.size();i++)
        {
            w.decrement(nums[i-k]);
            w.increment(nums[i]);
            // w.print();
            ans.push_back(w.sum);
        }
        return ans;
    }
};",1420558403
VILLANOVA_ECON,VILLANOVA_ECON,133,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

possible=set()
possible.add(1)
curr= 1
for i in range(1,50):
    curr += 1<<i
    possible.add(curr)
#print(sorted(possible)[0:10])
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []

        def recur_fn(node):
            if not node:
                return 0,True
            if not node.left and not node.right:
                ans.append(1)
                return 1, True
            left_count,left_res = recur_fn(node.left)
            right_count,right_res = recur_fn(node.right)
            if left_res and right_res and left_count in possible and right_count in possible and left_count == right_count:
                ans.append(left_count+right_count+1)
                return left_count+right_count+1,True
            else:
                return -1,False
        recur_fn(root)
        ans.sort()
        #print(ans)
        if k <= len(ans):
            return ans[-k]
        else:
            return -1

            ",1420525984
VILLANOVA_ECON,VILLANOVA_ECON,133,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        ### F beats E
        ## W beats F
        ## E beats W
        
        mapper = {""FE"":1,""EF"":-1,""WF"":1,""FW"":-1,""EW"":1,""WE"":-1,""EE"":0,""FF"":0,""WW"":0}
        
        modulo = 10**9 + 7
        
        @lru_cache(None)
        def recur_fn(i,prev,wins):
            if i == len(s):
                if wins > 0:
                    return 1
                else:
                    return 0
            else:
                res = 0
                for char in [""W"",""F"",""E""]:
                    if char != prev:
                        res += recur_fn(i+1,char,wins + mapper[char+s[i]])
                        if res >= modulo:
                            res %= modulo
                return res%modulo
        result = recur_fn(0,None,0)
        recur_fn.cache_clear()
        return result%modulo
                    
                    ",1420601180
VILLANOVA_ECON,VILLANOVA_ECON,133,3592,python3,"# class Solution:
#     def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
#         from sortedcontainers import SortedList
        
#         def x_sum(nums):
#             #sorted_list = SortedList()
#             num_store = list(collections.Counter(nums).items())
#             num_store.sort(key=lambda x: (x[1],x[0]))
#             # for a,b in num_store:
#             #     sorted_list.add((b,a))
            
#             ans = 0

#             for _ in range(x):
#                 if num_store:
#                     a,b = num_store.pop()
#                     ans += a*b
#             return ans
        
#         ans = []
#         for i in range(len(nums)-k+1):
#             ans.append(x_sum(nums[i:i+k]))
#         return ans

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        
        from sortedcontainers import SortedList
        sorted_list = SortedList()
        hash_table = collections.defaultdict(int)
        
        full_count = collections.defaultdict(int)
        
        curr_sum = 0
        
        for i in range(k):
            full_count[nums[i]] += 1
        
        for a,b in sorted(full_count.items()):
            sorted_list.add((b,a))
        
        top_k = set()
        for i in range(len(sorted_list)-1,len(sorted_list)-x-1,-1):
            if i < 0:
                break
            curr_sum += sorted_list[i][1] * sorted_list[i][0]
            top_k.add(sorted_list[i][1])
            #hash_table[sorted_list[i][0]] = sorted_list[i][1]
            
            
        def remove(value):
            #print('harhar',value)
            nonlocal curr_sum
            if x >= len(sorted_list):
                prev_count,prev_x = 0,0
            else:
                prev_count,prev_x= sorted_list[-x][0],sorted_list[-x][1]
            #curr_index = sorted_list.bisect_left((full_count[value],value))
            ct = full_count[value]
            full_count[value] -= 1
            sorted_list.discard((ct,value))
            ct -= 1
            if ct > 0:
                sorted_list.add((ct,value))
            if value in top_k:
                curr_sum -= value
                if ct == 0:
                    if x <= len(sorted_list):
                        top_k.add(sorted_list[-x][1])
                        curr_sum += sorted_list[-x][1] * sorted_list[-x][0]
                    top_k.remove(value)
                else:
                    index = sorted_list.bisect_left((ct,value))

                    if index < len(sorted_list)-x:
                        curr_sum -= sorted_list[index][1]*sorted_list[index][0]
                        curr_sum += sorted_list[-x][1] * sorted_list[-x][0]
                        top_k.remove(value)
                        top_k.add(sorted_list[-x][1])
            
                
                
                
        def insert_new(value):
            nonlocal curr_sum
            #print(value,top_k)
            ct = full_count[value]
            full_count[value] += 1
            if ct > 0:
                sorted_list.discard((ct,value))
            ct += 1
            sorted_list.add((ct,value))
            index = sorted_list.bisect_left((ct,value))
            if value in top_k:
                #print('zebra')
                curr_sum += value
            elif index >= len(sorted_list)-x:
                if x >= len(sorted_list):
                    prev_count,prev_x = 0,0
                else:
                    prev_count,prev_x= sorted_list[-x-1][0],sorted_list[-x-1][1]
                #print('goose',sorted_list,prev_count,'prev_x',prev_x,'curr_sum',curr_sum)
                top_k.add(value)
                curr_sum -= prev_count*prev_x
                if prev_x in top_k:
                    top_k.remove(prev_x)
                curr_sum += value * full_count[value]
                #top_k.add(value)
                
            
        ans = []
        ans.append(curr_sum)
        if len(sorted_list) >= x:
            curr_x = sorted_list[-x][1]
        else:
            curr_x = None
        #print(ans,top_k,sorted_list,'curr_x',curr_x,)
        for i in range(k,len(nums)):
            #print('initial',curr_sum,sorted_list,'top_k',top_k)
            remove(nums[i-k])
            #print('after_remove',nums[i-k],curr_sum,sorted_list,'top_k',top_k)
            insert_new(nums[i])
            #print('after_insert',nums[i],curr_sum,sorted_list,'top_k',top_k)
            ans.append(curr_sum)
        return ans
            
        
            
        
        
        
        
        
        ",1420590818
VILLANOVA_ECON,VILLANOVA_ECON,133,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedList
        
        def x_sum(nums):
            #sorted_list = SortedList()
            num_store = list(collections.Counter(nums).items())
            num_store.sort(key=lambda x: (x[1],x[0]))
            # for a,b in num_store:
            #     sorted_list.add((b,a))
            
            ans = 0

            for _ in range(x):
                if num_store:
                    a,b = num_store.pop()
                    ans += a*b
            return ans
        
        ans = []
        for i in range(len(nums)-k+1):
            ans.append(x_sum(nums[i:i+k]))
        return ans",1420519706
kzyKT,kzyKT,134,3509,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

vector<ll> ans;
ll dfs(TreeNode* t) {
  ll c1=0,c2=0;
  ll x=t->val;
  if(t->left!=NULL) {
    ll y=t->left->val;
    c1=dfs(t->left);
  }
  if(t->right!=NULL) {
    ll y=t->right->val;
    c2=dfs(t->right);
  }
  ll c=1+c1+c2;
  if(c1!=c2) c=-MAX;
  ans.pb(c);
  return c;
}

class Solution {
public:
  int kthLargestPerfectSubtree(TreeNode* root, int k) {
    ans.clear();
    dfs(root);
    sort(all(ans),greater<ll>());
    ll s=-1;k--;
    if(k<ans.size()&&ans[k]>0) s=ans[k];
    return s;
  }
};",1420527077
kzyKT,kzyKT,134,3588,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

ll dp[2][2222][3];

class Solution {
public:
  int countWinningSequences(string s) {
    mem(dp);
    ll n=s.size(),M=1100;
    rep(i,n) {
      if(s[i]=='F') s[i]='0';
      else if(s[i]=='W') s[i]='1';
      else s[i]='2';
    }
    rep(j,3) {
      ll x=s[0]-'0';
      ll z=0;
      if((x+1)%3==j) z=-1;
      if((x+2)%3==j) z=1;
      dp[0][M+z][j]=1;
    }
    REP(i,1,n) {
      REP(l,10,2200) {
        rep(k,3) {
          rep(j,3) {
            if(k==j) continue;
            ll x=s[i]-'0';
            ll z=0;
            if((x+1)%3==j) z=-1;
            if((x+2)%3==j) z=1;
            dp[1][l+z][j]+=dp[0][l][k];
            dp[1][l+z][j]%=MAX;
          }
        }
      }
      rep(j,2222)rep(k,3) dp[0][j][k]=dp[1][j][k];
      mem(dp[1]);
    }
    ll ans=0;
    rep(j,M) {
      rep(k,3) {
        ans+=dp[0][j][k];
        ans%=MAX;
      }
    }
    return ans;
  }
};
",1420549849
kzyKT,kzyKT,134,3592,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  vector<long long> findXSum(vector<int>& a, int k, int x) {
    ll n=a.size();
    map<ll,ll> ma;
    rep(i,k) ma[a[i]]++;
    ll sum=0;
    set<P> se[2];
    tr(it,ma) {
      se[0].in(P(it->S,it->F));
      sum+=it->F*it->S;
    }
    while(se[0].size()>x) {
      P p=*se[0].begin();
      se[1].in(p);
      se[0].erase(p);
      sum-=p.F*p.S;
    }
    vector<ll> ans;
    ans.pb(sum);
    REP(j,1,n-k+1) {
      if(se[0].count(P(ma[a[j-1]],a[j-1]))) {
        sum-=ma[a[j-1]]*a[j-1];
        se[0].erase(P(ma[a[j-1]],a[j-1]));
      } else {
        se[1].erase(P(ma[a[j-1]],a[j-1]));
      }
      if(se[0].count(P(ma[a[j+k-1]],a[j+k-1]))) {
        sum-=ma[a[j+k-1]]*a[j+k-1];
        se[0].erase(P(ma[a[j+k-1]],a[j+k-1]));
      } else {
        se[1].erase(P(ma[a[j+k-1]],a[j+k-1]));
      }
      ma[a[j-1]]--;
      ma[a[j+k-1]]++;
      se[1].in(P(ma[a[j-1]],a[j-1]));
      se[1].in(P(ma[a[j+k-1]],a[j+k-1]));
      while(se[0].size()<x&&se[1].size()) {
        iter(se[1]) it=se[1].end();it--;
        P p=*it;
        sum+=p.F*p.S;
        se[0].in(p);
        se[1].erase(p);
      }
      while(se[0].size()&&se[1].size()) {
        iter(se[1]) it=se[1].end();it--;
        iter(se[0]) it2=se[0].begin();
        P p=*it,q=*it2;
        if(p<q) break;
        sum+=p.F*p.S;
        se[0].in(p);
        se[1].erase(p);
        sum-=q.F*q.S;
        se[1].in(q);
        se[0].erase(q);
      }
      ans.pb(sum);
    }
    return ans;
  }
};",1420571499
kzyKT,kzyKT,134,3610,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  vector<int> findXSum(vector<int>& a, int k, int x) {
    ll n=a.size();
    vector<int> ans;
    rep(j,n-k+1) {
      map<ll,ll> m;
      rep(i,k) m[a[i+j]]++;
      priority_queue<P,vector<P>,greater<P> > que;
      tr(it,m) {
        que.push(P(it->S,it->F));
        while(que.size()>x) que.pop();
      }
      ll sum=0;
      while(!que.empty()) {
        P p=que.top();que.pop();
        sum+=p.F*p.S;
      }
      ans.pb(sum);
    }
    return ans;
  }
};",1420521208
Larry,LarryNY,135,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        INF = 10 ** 20
        ans = []
        
        def go(node):
            if node is None:
                return 0
            
            left = go(node.left)
            right = go(node.right)
            
            if left >= 0 and left == right:
                ans.append(1 + left + right)
                return 1 + left + right

            return -INF
        
        go(root)
        if k - 1 >= len(ans):
            return -1
        
        ans.sort(reverse=True)        
        return ans[k - 1]",1420524324
Larry,LarryNY,135,3588,java,"import java.util.Arrays;

class Solution {
    private static final int MOD = 1_000_000_007;
    private int[][][] dp;
    private int[] arr;
    private int N;

    public int countWinningSequences(String s) {
        N = s.length();
        int MAX_SCORE = 2 * N + 1;

        arr = new int[N];
        for (int i = 0; i < N; i++) {
            char c = s.charAt(i);
            arr[i] = ""FWE"".indexOf(c);
        }

        // Initialize dp array for memoization. Setting the third dimension to 2 * N + 1 to handle score offsets.
        dp = new int[N][4][MAX_SCORE];
        for (int[][] layer : dp) {
            for (int[] row : layer) {
                Arrays.fill(row, -1);  // Use -1 to denote uncomputed states
            }
        }

        return go(0, 3, N) % MOD;  // Start with index 0, last = 3 (none), and score offset by N to handle negative scores
    }

    private int go(int index, int last, int score) {
        if (index == N) {
            return score > N ? 1 : 0;  // Return 1 if the score is positive (offset by N), else return 0
        }
        if (dp[index][last][score] != -1) {
            return dp[index][last][score];
        }

        int count = 0;
        for (int i = 0; i < 3; i++) {
            if (i != last) {
                int delta = 0;
                if (arr[index] == (i - 1 + 3) % 3) {
                    delta += 1;
                }
                if (arr[index] == (i + 1 + 3) % 3) {  // Handle negative modulo in Java
                    delta -= 1;
                }

                int newScore = score + delta;
                if (newScore >= 0 && newScore < 2 * N + 1) {  // Ensure the newScore stays within valid range
                    count = (count + go(index + 1, i, newScore)) % MOD;
                }
            }
        }

        dp[index][last][score] = count;
        return count % MOD;
    }
}
",1420541405
Larry,LarryNY,135,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], K: int, X: int) -> List[int]:
        N = len(nums)
        
        ans = []
        sl = SortedList()
        f = collections.Counter(nums[:K])
        for x in nums:
            f[x] += 0
        M = len(f)
        for k, v in f.items():
            sl.add((v, k))
            
        total = sum(k * v for k, v in sl[-X:])
        ans.append(total)

        def calc(x, delta):
            #print(f""{x=} {delta=}"")
            nonlocal total
            index = sl.bisect_left((f[x], x))
            if index >= M - X:
                total -= f[x] * x
                if M - X - 1 >= 0:
                    a, b = sl[M - X - 1]
                    #print(""adding back"", a, b, sl)
                    total += a * b
            sl.remove((f[x], x))
                
            f[x] += delta
            sl.add((f[x], x))
            index = sl.bisect_left((f[x], x))
            #print(index, M - X)
            if index >= M - X:
                total += f[x] * x
                if M - X - 1 >= 0:
                    a, b = sl[M - X - 1]
                    #print(index, M - X, ""removing back"", a, b, sl)
                    total -= a * b
            #print(sl)
            #print(f""{total=}"")
        
        #print(sl)
        for i in range(K, N):
            calc(nums[i], 1)
            calc(nums[i - K], -1)
            ans.append(total)

        return ans",1420577614
Larry,LarryNY,135,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        N = len(nums)

        ans = []
        for i in range(N - k + 1):
            f = collections.Counter(nums[i:i + k])
            
            vs = list(sorted(f.items(), key=lambda x: (-x[1], -x[0])))[:x]
            total = sum(k * v for k, v in vs)
            ans.append(total)
        return ans
            
            
",1420519732
Dhruv_dg,Dhruv_dg,138,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 priority_queue<int, vector<int>, greater<int>> q;
pair<int, int> solve(TreeNode* root){
    if(root==NULL) return {1, 0};
    int cnt = 1;
    pair<int, int> l = solve(root->left);
    pair<int, int> r = solve(root->right);
    cnt += (l.second+r.second);
    if(l.first==1 && r.first==1 && l.second==r.second){
        q.push(cnt);
        return {1, cnt};
    } 
    return {0, cnt};
}
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        while(q.size()>0) q.pop();
        solve(root);
        while(q.size()>k) q.pop();
        if(q.size()!=k) return -1;
        return q.top();
    }
};",1420567475
Dhruv_dg,Dhruv_dg,138,3588,cpp,"class Solution {
public:
    int mod = 1e9+7;
    vector<char> v = {'X', 'F', 'E', 'W'};
    map<char, char> m; 
    int dp[1001][2002][5];
    int solve(int ind, int prev, int diff, string& s, int n){
        if(ind==n){
            if(diff>0) return 1;
            return 0;
        }
        if(dp[ind][diff+n][prev]>-1) return dp[ind][diff+n][prev];
        int ans = 0;
        for(int i=1;i<=3;i++){
            if(i==prev) continue;
            if(v[i]==s[ind]) ans = (ans + solve(ind+1, i, diff, s, n))%mod;
            else if(v[i] == m[s[ind]]) ans = (ans + solve(ind+1, i, diff-1, s, n))%mod;
            else ans = (ans + solve(ind+1, i, diff+1, s, n))%mod;
        }
        return dp[ind][diff+n][prev] = ans;
    }
    int countWinningSequences(string s) {
        int n = s.length();
        m['F'] = 'E';
        m['E'] = 'W';
        m['W'] = 'F';
        memset(dp, -1, sizeof(dp));
        return solve(0, 0, 0, s, n);
    }
};",1420596397
Dhruv_dg,Dhruv_dg,138,3592,cpp,"using ll = long long int;
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        set<pair<int, int>> st;
        set<pair<int, int>> rej;
        map<int, int> m;
        for(int i=0;i<k;i++){
            m[nums[i]]++;
        }
        ll sum = 0;
        for(auto it : m){
            sum += (1LL*(it.second)*(it.first));
            st.insert({it.second, it.first});
        }
        while(st.size()>x){
            auto it = *st.begin();
            sum -= (1LL*(it.first)*(it.second));
            rej.insert(it);
            st.erase(it);
        }
        vector<ll> ans;
        ans.push_back(sum);
        int srt = 0;
        int en = k;
        while(en<n){
            int fre = m[nums[srt]];
            if(st.find({fre, nums[srt]})!=st.end()){
                sum -= (1LL*fre*nums[srt]);
                st.erase({fre, nums[srt]});
            }
            if(rej.find({fre, nums[srt]}) != rej.end()) rej.erase({fre, nums[srt]});
            m[nums[srt]]--;
            if(m[nums[srt]]>0) rej.insert({m[nums[srt]], nums[srt]});
            fre = m[nums[en]];
            if(st.find({fre, nums[en]})!=st.end()){
                sum -= (1LL*fre*nums[en]);
                st.erase({fre, nums[en]});
            }
            if(rej.find({fre, nums[en]}) != rej.end()) rej.erase({fre, nums[en]});
            m[nums[en]]++;
            rej.insert({m[nums[en]], nums[en]});
            if(st.size()<x && rej.size()>0){
                auto it = rej.end();
                it--;
                st.insert(*it);
                sum += 1LL*(1LL*(*it).first)*((*it).second);
                rej.erase(it);
            }
            if(st.size()<x && rej.size()>0){
                auto it = rej.end();
                it--;
                st.insert(*it);
                sum += 1LL*(1LL*(*it).first)*((*it).second);
                rej.erase(it);
            }
            while(true){
                if(rej.size()==0) break;
                auto it = rej.end();
                it--;
                auto r = *it;
                auto s = *st.begin();
                if(s.first < r.first){
                    sum -= 1LL*s.first*s.second;
                    sum += 1LL*r.first*r.second;
                    st.erase(s);
                    rej.erase(r);
                    st.insert(r);
                    rej.insert(s);
                }
                else if(s.first==r.first && r.second>s.second){
                    sum -= 1LL*s.first*s.second;
                    sum += 1LL*r.first*r.second;
                    st.erase(s);
                    rej.erase(r);
                    st.insert(r);
                    rej.insert(s);
                }
                else break;
                
            }

            ans.push_back(sum);
            srt++;
            en++;

        }
        return ans;
    }
};",1420556389
Dhruv_dg,Dhruv_dg,138,3610,cpp,"using ll = long long int;
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        set<pair<int, int>> st;
        set<pair<int, int>> rej;
        map<int, int> m;
        for(int i=0;i<k;i++){
            m[nums[i]]++;
        }
        ll sum = 0;
        for(auto it : m){
            sum += (1LL*(it.second)*(it.first));
            st.insert({it.second, it.first});
        }
        while(st.size()>x){
            auto it = *st.begin();
            sum -= (1LL*(it.first)*(it.second));
            rej.insert(it);
            st.erase(it);
        }
        vector<int> ans;
        ans.push_back(sum);
        int srt = 0;
        int en = k;
        while(en<n){
            int fre = m[nums[srt]];
            if(st.find({fre, nums[srt]})!=st.end()){
                sum -= (1LL*fre*nums[srt]);
                st.erase({fre, nums[srt]});
            }
            if(rej.find({fre, nums[srt]}) != rej.end()) rej.erase({fre, nums[srt]});
            m[nums[srt]]--;
            if(m[nums[srt]]>0) rej.insert({m[nums[srt]], nums[srt]});
            fre = m[nums[en]];
            if(st.find({fre, nums[en]})!=st.end()){
                sum -= (1LL*fre*nums[en]);
                st.erase({fre, nums[en]});
            }
            if(rej.find({fre, nums[en]}) != rej.end()) rej.erase({fre, nums[en]});
            m[nums[en]]++;
            rej.insert({m[nums[en]], nums[en]});
            if(st.size()<x && rej.size()>0){
                auto it = rej.end();
                it--;
                st.insert(*it);
                sum += 1LL*(1LL*(*it).first)*((*it).second);
                rej.erase(it);
            }
            if(st.size()<x && rej.size()>0){
                auto it = rej.end();
                it--;
                st.insert(*it);
                sum += 1LL*(1LL*(*it).first)*((*it).second);
                rej.erase(it);
            }
            while(true){
                if(rej.size()==0) break;
                auto it = rej.end();
                it--;
                auto r = *it;
                auto s = *st.begin();
                if(s.first < r.first){
                    sum -= 1LL*s.first*s.second;
                    sum += 1LL*r.first*r.second;
                    st.erase(s);
                    rej.erase(r);
                    st.insert(r);
                    rej.insert(s);
                }
                else if(s.first==r.first && r.second>s.second){
                    sum -= 1LL*s.first*s.second;
                    sum += 1LL*r.first*r.second;
                    st.erase(s);
                    rej.erase(r);
                    st.insert(r);
                    rej.insert(s);
                }
                else break;
                
            }

            ans.push_back(sum);
            srt++;
            en++;

        }
        return ans;
    }
};",1420557764
kasi nathan,kasinathansj,140,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    ArrayList<Integer> al ;
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        this.al = new ArrayList<>();
        rec(root,0);
        Collections.sort(al,(a,b)->Integer.compare(b,a));
        // System.out.println(al);
        if(al.size()>=k)return al.get(k-1);
        return -1;
    }
    private int rec(TreeNode root , int d){
        if(root==null)return -1;
        if(root.left==null&&root.right==null){
            al.add(1);
            return d;
        }
        int l = rec(root.left , d+1);
        int r = rec(root.right , d+1);
        if(l!=-1&&r!=-1){
            if(l==r){
                int diff = l - d + 1;
                int ans = (1<<diff)-1;
                al.add(ans);
                return l;
            }else{
                return -1;
            }
        }else{
            return -1;
        }
    }
}",1420536117
kasi nathan,kasinathansj,140,3588,java,"class Solution {
    int dp[][][];
    int mod = (int)1e9+7;
    public int countWinningSequences(String s) {
        this.dp = new int[s.length()+1][2*s.length()+1][4];
        for(int a[][] : dp){
            for(int b[] : a)
                Arrays.fill(b,-1);
        }
        return noOfWay(s,0,0,3);
    }
    private int noOfWay(String s , int i , int p , int pre){
        if(dp[i][p+s.length()][pre]!=-1)return dp[i][p+s.length()][pre];
        if(i==s.length()){
            if(p>0)return 1;
            return 0;
        }
        char c = s.charAt(i);
        int ans = 0;
        if(c=='F'){
            if(pre != 0){
                ans += noOfWay(s,i+1,p,0); 
                ans %= mod;
            }
            if(pre != 1){
                ans += noOfWay(s,i+1,p+1,1);
                ans %= mod;
            }
            if(pre != 2){
                ans += noOfWay(s,i+1,p-1,2);
                ans %= mod;
            }
        }else if(c=='W'){
            if(pre != 1){
                ans += noOfWay(s,i+1,p,1);
                ans %= mod;
            }
            if(pre != 0){
                ans += noOfWay(s,i+1,p-1,0);  
                ans %= mod;
            }
            if(pre != 2){
                ans += noOfWay(s,i+1,p+1,2);
                ans %= mod;
            }
        }else{
            if(pre != 2){
                ans += noOfWay(s,i+1,p,2);
                ans %= mod;
            }
            if(pre != 0){
                ans += noOfWay(s,i+1,p+1,0);   
                ans %= mod;
            }
            if(pre != 1){
                ans += noOfWay(s,i+1,p-1,1);
                ans %= mod;
            }
        }
        return dp[i][p+s.length()][pre] = ans;
    }
}",1420554797
kasi nathan,kasinathansj,140,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        long ans[] = new long[nums.length-k+1];
        HashMap<Integer,Integer> hm = new HashMap<>();
        Rolling rl = new Rolling(x);
        for(int i = 0 ; i < k ; i++){
            hm.merge(nums[i],1,Integer::sum);
        }
        for(Map.Entry<Integer,Integer> en : hm.entrySet()){
            rl.insert(new int[]{en.getValue(),en.getKey()});
        }
        ans[0] = rl.ksum();
        for(int i = k ; i < nums.length ; i++){
            int rm[] = new int[]{0,nums[i-k]};
            int ad[] = new int[]{0,nums[i]};
            rl.remove(new int[]{hm.get(nums[i-k]),nums[i-k]});
            hm.merge(nums[i-k],-1,Integer::sum);
            rl.insert(new int[]{hm.get(nums[i-k]),nums[i-k]});
            if(hm.containsKey(nums[i])){
                rl.remove(new int[]{hm.get(nums[i]),nums[i]});
                hm.merge(nums[i],1,Integer::sum);
                rl.insert(new int[]{hm.get(nums[i]),nums[i]});
            }else{
                hm.merge(nums[i],1,Integer::sum);
                rl.insert(new int[]{hm.get(nums[i]),nums[i]});
            }
            ans[i-k+1] = rl.ksum();
        }
        return ans;
    }
}


class Rolling {
    TreeMap<int[], Integer> left ;
    TreeMap<int[], Integer> right ;
    int lsize ;
    int rsize ;
    int k ;
    long lsum ;
    void print(){
        System.out.println(left);
        System.out.println(right);
    }
    Rolling(int k){
        this.left = new TreeMap<>((a,b)->{
                if(Integer.compare(b[0],a[0])==0)return Integer.compare(b[1],a[1]);
                return Integer.compare(b[0],a[0]);
            });
        this.right = new TreeMap<>((a,b)->{
                if(Integer.compare(b[0],a[0])==0)return Integer.compare(b[1],a[1]);
                return Integer.compare(b[0],a[0]);
            });
        this.lsize = 0;
        this.rsize = 0;
        this.k = k;
        this.lsum = 0;
    }

    void balance(){
        if(lsize<k){
            while(rsize>0&&lsize<k){
                int[] min = right.firstKey();
                right.merge(min,-1,Integer::sum);
                if(right.get(min)==0)right.remove(min);
                left.merge(min,1,Integer::sum);
                rsize--;
                lsize++;
                lsum+=min[0]*1l*min[1];
            }
        }else{
            while(lsize>k){
                int[] max = left.lastKey();
                left.merge(max,-1,Integer::sum);
                if(left.get(max)==0)left.remove(max);
                right.merge(max,1,Integer::sum);
                lsize--;
                rsize++;
                lsum-=max[0]*1l*max[1];
            }
        }
        // print();
    }
    void insert(int[] node){
        if(lsize==0){
            left.merge(node,1,Integer::sum);
            lsize++;
            lsum+=node[0]*1l*node[1];
            balance();
            return;
        }
        int[] max = left.lastKey();
        if(node[0]>max[0]||(node[0]==max[0]&&node[1]>max[1])){
            left.merge(node,1,Integer::sum);
            lsize++;
            lsum+=node[0]*1l*node[1];
        }else{
            right.merge(node,1,Integer::sum);
            rsize++;
        }
        balance();
    }
    void remove(int[] node){
        if(left.containsKey(node)){
            left.merge(node,-1,Integer::sum);
            lsize--;
            lsum-=node[0]*1l*node[1];
            if(left.get(node)==0)left.remove(node);
        }else if(right.containsKey(node)){
            right.merge(node,-1,Integer::sum);
            rsize--;
            if(right.get(node)==0)right.remove(node);
        }
        balance();
    }
    long ksum(){
        // for(int a[] : left.keySet()){
        //     System.out.println(Arrays.toString(a));
        // }
        // System.out.println();
        return lsum;
    }
}",1420602736
kasi nathan,kasinathansj,140,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int ans[] = new int[Math.max(nums.length-k+1,0)];
        for(int i = 0 ; i < nums.length-k+1 ; i++){
            TreeMap<Integer,Integer> tm1 = new TreeMap<Integer,Integer>();
            int sum = 0;
            for(int j = 0 ; j < k ; j++){
                tm1.merge(nums[i+j],1,Integer::sum);
            }
            // System.out.println(tm1);
            PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{
                if(Integer.compare(b[0],a[0])==0)return Integer.compare(b[1],a[1]);
                return Integer.compare(b[0],a[0]);
            });
            for(int a : tm1.keySet()){
                pq.add(new int[]{tm1.get(a) , a});
            }
            
            for(int j = 0 ; j < x && pq.size()>0; j++){
                // System.out.println(i+j+"" ""+Arrays.toString(pq.peek()));
                sum += pq.peek()[0]*pq.peek()[1];
                pq.poll();
            }
            ans[i] = sum;
        }
        return ans;
    }
}",1420526166
delphih,delphih,142,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(node):
            if node is None: return -1
            if node.left is None and node.right is None:
                arr.append(1)
                return 1
            tl, tr = dfs(node.left), dfs(node.right)
            if tl != -1 and tl == tr:
                arr.append(tl + tr + 1)
                return tl + tr + 1
            else:
                return -1
        arr = []
        if root: dfs(root)
        arr.sort(reverse=1)
        # print(arr)
        return arr[k-1] if k <= len(arr) else -1",1420528521
delphih,delphih,142,3588,python3,"M = 10**9+7
D = {'F': 0, 'W': 1, 'E': 2}

class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        def b_pt(a, b):
            return 0 if a == b else 1 if b == a + 1 or (b, a) == (0, 2) else -1
        a0 = D[s[0]]
        # FWE
        dp = [{b_pt(a0, i): 1} for i in range(3)] # b - a points: count
        # print(dp)
        for i, c in enumerate(islice(s, 1, None), 1):
            a = D[c]
            dp2 = [Counter(), Counter(), Counter()]
            for b0 in range(3):
                for pt0, cnt0 in dp[b0].items():
                    for b in range(3):
                        if b == b0: continue
                        pt = pt0 + b_pt(a, b)
                        dp2[b][pt] = (dp2[b][pt] + cnt0) % M
            dp = dp2
            # print(i, c, dp)
        # return sum(sum(v for k, v in cnt.items() if k > 0) for cnt in dp)
        return sum(v for cnt in dp for k, v in cnt.items() if k > 0) % M",1420554550
delphih,delphih,142,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, A: List[int], k: int, x: int) -> List[int]:
        n = len(A)
        def inc(t, d):
            e0 = (-cnt[t], -t)
            i0 = sl.index(e0)
            sl.pop(i0)

            cnt[t] = -e0[0] + d
            e1 = (e0[0] - d, -t)
            sl.add(e1)
            i1 = sl.index(e1)
            nonlocal cur, x
            if i0 < x and i1 < x:
                cur += t * d
            elif i0 < x and i1 >= x:
                cur -= t * (-e0[0])
                t2, v2 = sl[x-1]
                cur += t2 * v2
            elif i0 >= x and i1 < x:
                t2, v2 = sl[x]
                cur -= t2 * v2
                cur += t * (-e1[0])

        cnt = Counter(islice(A, k))
        for t in A:
            cnt[t] = cnt[t]
        sl = SortedList([(-v, -t) for t, v in cnt.items()])
        cur = sum(t * v for t, v in islice(sl, x))
        res = [cur]
        # print(sl, cur)
        for i in range(1, n - k + 1):
            inc(A[i-1], -1)
            inc(A[i+k-1], 1)
            # print(cnt, sl)
            res.append(cur)
        return res",1420598292
delphih,delphih,142,3610,python3,"class Solution:
    def findXSum(self, A: List[int], k: int, x: int) -> List[int]:
        n = len(A)
        res = []
        for i in range(n - k + 1):
            cnt = Counter(A[i:i+k])
            xs = nlargest(x, cnt.items(), key=lambda x: (x[1], x[0]))
            # print(cnt, xs)
            res.append(sum(k * c for k, c in xs))
        return res",1420521352
wellway,wellway,143,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    multiset<int> sizes;
    pair<int,int> checkSubTree(TreeNode* rt){
        if(rt==nullptr){
            return {0,0};
        }
        pair<int,int> rig = checkSubTree(rt->left);
        pair<int,int> lef = checkSubTree(rt->right);
        // cout<<rt->val<<endl;
        if(rig.first==lef.first && rig.first!=-1){
            int sum = rig.second + lef.second + 1;
            sizes.insert(sum);
            return {rig.first+1, sum};
        }
        return {-1,0};
    } 
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        checkSubTree(root);
        for(auto i=sizes.rbegin();i!=sizes.rend();i++){
            // cout<<(*i)<<endl;
            k--;
            if(k==0){
                return *i;
            }
        }
        return -1;
    }
};",1420543462
wellway,wellway,143,3588,cpp,"class Solution {
public:
    map<char,int> maps;
    int dp[1001][2001][3];
    const int mod = 1e9+7;
    int caldp(int ci, int lc, int score, string &s){
        if(ci == s.size()){
            if(score>1000)
                return 1;
            return 0;
        }
        if(ci!=0){
            // cout<<ci<<' '<<score<<' '<<lc<<endl;
            if( dp[ci][score][lc]!=-1){
                return dp[ci][score][lc];
            }
        }

        char lastChose = 'Z';
        if(lc==0){
            lastChose = 'F';
        }
        if(lc==1){
            lastChose = 'W';
        }
        if(lc==2){
            lastChose = 'E';
        }
        long ans = 0;
        if(lastChose!='F'){
            int ns= (s[ci]=='W')?-1:(s[ci]=='F')?0:1;
            long sum = caldp(ci+1, maps['F'],score+ns, s);
            if(sum!=0){
                ans += sum;
                ans%=mod;
            }
        }

        if(lastChose!='W'){
            int ns= (s[ci]=='E')?-1:(s[ci]=='W')?0:1;
            long sum = caldp(ci+1, maps['W'],score+ns, s);
            if(sum!=0){
                ans += sum;
                ans%=mod;
            }
        }

        if(lastChose!='E'){
            int ns= (s[ci]=='F')?-1:(s[ci]=='E')?0:1;
            long sum = caldp(ci+1, maps['E'],score+ns, s);
            if(sum!=0){
                ans += sum;
                ans%=mod;
            }
        }
        ans%=mod;
        if(lc==-1){
            return ans;
        }
        return dp[ci][score][lc] = ans;
    }
    int countWinningSequences(string s) {
        maps['F']=0;
        maps['W']=1;
        maps['E']=2;
        memset(dp,-1,sizeof(dp));
        return caldp(0,-1,1000,s);
    }
};",1420575099
wellway,wellway,143,3592,cpp,"class Solution {
public:
    int fx;
    long fsum;
    void perase(int num, int freq, set<pair<int,int>> &pfn, set<pair<int,int>> &pfnx){
        if(pfn.find({freq, num}) != pfn.end()){
            pfn.erase(pfn.find({freq,num}));
        }
        if(pfnx.find({freq, num}) != pfnx.end()){
            pfnx.erase(pfnx.find({freq,num}));
            fsum-=1ll*num*freq;
        }
        balance(pfn,pfnx);
    }
    void balance(set<pair<int,int>> &pfn, set<pair<int,int>> &pfnx){
        while(pfnx.size()<fx && pfn.size()){
            auto a = pfn.rbegin();
            fsum += 1ll*a->first*a->second;
            pfnx.insert({a->first, a->second});
            pfn.erase(*a);
        }
        while(pfnx.size()>fx){
            auto a = pfnx.begin();
            fsum -= 1ll*a->first*a->second;
            pfn.insert({a->first,a->second});
            pfnx.erase(a);
        }
    }

    void padd(int num, int freq, set<pair<int,int>> &pfn, set<pair<int,int>> &pfnx){
        pfnx.insert({freq,num});
        fsum+=1ll*freq*num;
        balance(pfn, pfnx);
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        this->fx =x;
        fsum = 0;

        map<int,int> nf; // number frequency Map
        map<int,set<int>> fn; // frequency number map;
        set<pair<int,int>> pfn, pfnx; // pair of frequency and number; larg freq larg num

        vector<long long> fans;
        int l=0;
        for(int r=0;r<nums.size();r++){
            perase(nums[r], nf[nums[r]], pfn, pfnx);
            nf[nums[r]]++;
            padd(nums[r], nf[nums[r]], pfn, pfnx);
            if(r-l+1>=k){
                while(r-l+1>k){
                    perase(nums[l],nf[nums[l]], pfn, pfnx);
                    nf[nums[l]]--;
                    padd(nums[l], nf[nums[l]], pfn, pfnx);
                    l++;
                }
                fans.push_back(fsum);
            }
        }
        return fans;
    }
};",1420604960
wellway,wellway,143,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> fans;
        for(int i=k;i<nums.size()+1;i++){
            map<int,int> freq;
            for(int j=i-k;j<i;j++){
                freq[nums[j]]++;
            }
            map<int,set<int>> mps;
            map<int,int> sum;
            for(auto [a,b]:freq){
                mps[b].insert(a);
            }
            int cnt=0,ans=0;
            for(auto l=mps.rbegin();l!=mps.rend();l++){
                for(auto r=l->second.rbegin();r!=l->second.rend();r++){
                    // cout<<(*r)<<endl;
                    ans+=(*r)*(l->first);
                    cnt++;
                    if(cnt==x){
                        break;
                    }
                }
                                    if(cnt==x){
                        break;
                    }
            }
            // cout<<endl;
            fans.push_back(ans);
        }
        return fans;
    }
};",1420526768
CyberPunk,U_U,144,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int64_t> vec;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        DFS(root);

        sort(vec.begin(), vec.end());
        if (vec.size() < k) return -1;
        reverse(vec.begin(), vec.end());

        return vec[k - 1];
    }

    pair<int64_t, int64_t> DFS(TreeNode* ptr)
    {
        if (ptr == NULL) return {0, 0};

        pair<int64_t, int64_t> left = DFS(ptr->left);
        pair<int64_t, int64_t> right = DFS(ptr->right);

        int64_t depth = max(left.second, right.second) + 1;
        int64_t cnt = left.first + right.first;

        if (depth > 31) return {0, 0};
        int64_t expect = (1 << depth) - 1;
        if (expect == cnt + 1)
        {
            vec.push_back(cnt + 1);
        }
        //cout << ptr->val << "","" << expect << "","" << cnt + 1 << ""|"" << depth << "","" << left.second << "","" << right.second << endl;

        return {cnt + 1, depth};
    }
};",1420530126
CyberPunk,U_U,144,3588,cpp,"class Solution {
public:
    string S;
    vector<char> plays = {'F', 'W', 'E'};
    int mem[1001][2001][4];
    int mod = 1e9 + 7;
    int countWinningSequences(string s) {
        S = s;

        for (int i = 0; i < s.size(); ++i)
        {
            for (int t = 0; t <= 2000; ++t)
            {
                mem[i][t][0] = -1;
                mem[i][t][1] = -1;
                mem[i][t][2] = -1;
                mem[i][t][3] = -1;
            }
        }

        return Alice(0, 'N', 'N', 1000);
    }

    int64_t Alice(int index, char alicePlay, char prevBobPlay, int score)
    {        
        if (index == S.size())
        {
            if (score > 1000) return 1;
            return 0;
        }

        int playNum = 0;
        if (prevBobPlay == 'F') playNum = 1;
        if (prevBobPlay == 'W') playNum = 2;
        if (prevBobPlay == 'E') playNum = 3;        
        if (mem[index][score][playNum] != -1) return mem[index][score][playNum];

        int64_t ret = 0;        
        for (auto& p : plays)
        {
            if (p != prevBobPlay)
            {
                ret += Bob(index, S[index], p, score);
                ret %= mod;
            }
        }                  

        mem[index][score][playNum] = ret;  
        return ret;
    }

    int64_t Bob(int index, char alicePlay, char prevBobPlay, int score)
    {
        int64_t ret = 0;
        if ( (alicePlay == 'F' && prevBobPlay == 'E') || 
             (alicePlay == 'W' && prevBobPlay == 'F') ||
             (alicePlay == 'E' && prevBobPlay == 'W')  )
        {   
            ret += Alice(index + 1, alicePlay, prevBobPlay, score - 1);
        }
        else if ( (alicePlay == 'E' && prevBobPlay == 'F') || 
             (alicePlay == 'F' && prevBobPlay == 'W') ||
             (alicePlay == 'W' && prevBobPlay == 'E')  )
        {   
            ret += Alice(index + 1, alicePlay, prevBobPlay, score + 1);
        }
        else
        {
            ret += Alice(index + 1, alicePlay, prevBobPlay, score);
        }

        return ret;
    }
};",1420552850
CyberPunk,U_U,144,3592,cpp,"#define TNODE Node<TKey, TScore, TVal> 

template <typename TKey, typename TScore, typename TVal> class Node
{
public:
    Node()
    {
    }
    Node(TKey key, TScore score, TVal val)
    {
        Key = key;
        Score = score;
        Val = val;
    }
    TKey Key;
    TScore Score;
    TVal Val;
};

// CompareLess returns true. True will put the value close to the top of heap.
template <typename TKey, typename TScore, typename TVal> 
bool CompareLess(TNODE* a, TNODE* b)
{
    if (a->Score < b->Score) return true;
    else if (a->Score == b->Score)
    {
        return a->Val < b->Val;
    }
    return false;
}

template <typename TKey, typename TScore, typename TVal> 
bool CompareGreater(TNODE* a, TNODE* b)
{
    if (a->Score > b->Score) return true;
    else if (a->Score == b->Score)
    {
        return a->Val > b->Val;
    }
    return false;
}


template <typename TKey, typename TScore, typename TVal> class HashHeap
{
public:
    bool (*funcComp)(TNODE*, TNODE*);

    HashHeap(int maxSize, bool (*funcComp)(TNODE*, TNODE*))
    {
        vec.assign(maxSize * 4 + 10, NULL);
        numElems = 0;
        this->funcComp = funcComp;
    }

    int Push(TKey key, TScore score, TVal val)
    {
        if (numElems == vec.size() - 1) return -1;
        if (key2Index.count(key) != 0) return -1;

        TNODE* ptr = new TNODE(key, score, val);
        vec[numElems + 1] = ptr; // index start with 1
        ++numElems;
        int i = numElems;
        for (; parent(i) >= 1 && funcComp(vec[i], vec[parent(i)]); i = parent(i))
        {
            this->Swap(i, parent(i));            
        }
        key2Index[key] = i;
        return 0;
    }
    
    TNODE* Top()
    {
        if (numElems == 0) return NULL;
        return vec[1]; 
    }

    TNODE* Pop()
    {
        if (numElems == 0) return NULL;
        Node<TKey, TScore, TVal>* topNode = vec[1]; 
        TKey oldKey = vec[1]->Key;
        this->Swap(1, numElems);
        key2Index.erase(oldKey);
        --numElems;
        HeapifyDown(1);
        return topNode;
    }
    
    TNODE* Get(TKey key)
    {
        if (key2Index.count(key) == 0) return NULL;
        int pos = key2Index[key];
        return vec[pos];
    }
    
        
    bool Update(TKey key, TScore score, TVal val)
    {
        if (key2Index.count(key) == 0) return false;
        int pos = key2Index[key];
        vec[pos]->Score = score;
        vec[pos]->Val = val;
        Fix(pos);
        return true;
    }
    
    bool InsertOrUpdate(TKey key, TScore score, TVal val)
    {
        Node<TKey, TScore, TVal>* ptr = this->Get(key);
        if (ptr == NULL) return this->Push(key, score, val) == 0;        
        return Update(key, score, val);
    }
    
    bool Remove(TKey key)
    {
        if (key2Index.count(key) == 0) return false;
        int pos = key2Index[key];        
        if (numElems == 1)
        {
            --numElems;
            key2Index.erase(key);
            return true;
        }
        this->Swap(pos, numElems);
        --numElems;
        key2Index.erase(key);
        Fix(pos);
        return true;
    }
    
    void Fix(int i)
    {
        if (!HeapifyDown(i)) HeapifyUp(i);
    }

    void HeapifyUp(int i) 
    {
        while (true) 
        {
            int t = parent(i);
            if (t < 1 || !funcComp(vec[i], vec[t])) break;
            this->Swap(i, t);
            i = t;
        }
    }
    
    bool HeapifyDown(int i)
    {
        int start = i;
        while (true) 
        {
            int L = left(i);
            if (L > numElems || L < 1) break; // L < 0 after int overflow.
            int j = L;
            int R = L + 1;
            if (R <= numElems && funcComp(vec[R], vec[L])) j = R;
            if ( !funcComp(vec[j], vec[i]) ) break;
            this->Swap(j, i);
            i = j;
        }        
        return i > start; // if fixed the children.
    }
    
    void Swap(int i, int t)
    {
        key2Index[ vec[i]->Key ] = t;
        key2Index[ vec[t]->Key ] = i;
        swap(vec[i], vec[t]);
    }

    int parent(int i) { return i / 2; }
    int left(int i)   { return 2 * i;       }
    int right(int i)  { return 2 * i + 1;   }

    int numElems;
    vector<TNODE*> vec;
    unordered_map<TKey, int> key2Index;
};


class Solution {
public:
    int n;
    vector<long long> res;
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        n = nums.size();

        HashHeap heapMin(nums.size() + 5, CompareLess<int64_t, int64_t, int64_t>);
        HashHeap heapMax(nums.size() + 5, CompareGreater<int64_t, int64_t, int64_t>);                
        int64_t sum = 0;
        for (int i = 0; i < n; ++i)
        {
            if (i >= k)
            {
                 int curCnt = getCnt(nums[i - k], heapMin, heapMax);                 
                 if (isInMinHeap(nums[i - k], heapMin))
                 {
                    sum -= nums[i - k];
                    if (curCnt - 1 > 0) heapMin.Update(nums[i - k], curCnt - 1, nums[i - k]);
                    else heapMin.Remove(nums[i - k]);
                 }
                 else
                 {
                    if (curCnt - 1 > 0) heapMax.Update(nums[i - k], curCnt - 1, nums[i - k]);
                    else heapMax.Remove(nums[i - k]);
                 }
            }

            int curCnt = getCnt(nums[i], heapMin, heapMax);
            if (curCnt == 0)
            {
                heapMin.Push(nums[i], 1, nums[i]);
                sum += nums[i];
            }
            else if (isInMinHeap(nums[i], heapMin))
            {
                heapMin.Update(nums[i], curCnt + 1, nums[i]);
                sum += nums[i];
            }
            else
            {
                heapMax.Update(nums[i], curCnt + 1, nums[i]);
            }

            while (heapMax.numElems > 0 && heapMin.numElems < x)
            {
                 Node<int64_t, int64_t, int64_t>* topMax = heapMax.Pop();
                 heapMin.Push(topMax->Key, topMax->Score, topMax->Val);           
                 sum += topMax->Score * topMax->Val;
            }

            while (heapMin.numElems > x)
            {
                Node<int64_t, int64_t, int64_t>* topMin = heapMin.Pop();
                heapMax.Push(topMin->Key, topMin->Score, topMin->Val);
                sum -= topMin->Score * topMin->Val;
            }

            while (heapMax.numElems > 0 && heapMin.numElems > 0)
            {
                Node<int64_t, int64_t, int64_t>* topMax = heapMax.Top();
                Node<int64_t, int64_t, int64_t>* topMin = heapMin.Top();
                if (topMax->Score < topMin->Score) break;
                if (topMax->Score == topMin->Score) 
                {
                    if (topMax->Val < topMin->Val) break;
                }

                topMax = heapMax.Pop();
                topMin = heapMin.Pop();

                sum -= topMin->Score * topMin->Val;
                sum += topMax->Score * topMax->Val;

                heapMax.Push(topMin->Key, topMin->Score, topMin->Val);
                heapMin.Push(topMax->Key, topMax->Score, topMax->Val);                
            }

           // cout << i << "","" << nums[i] << ""|"" << heapMin.numElems << "","" << sum << endl;
            
            if (i < k - 1) continue;

            res.push_back(sum);
        }

        return res;
    }

    bool isInMinHeap(int key, HashHeap<int64_t, int64_t, int64_t>& heapMin)
    {
        Node<int64_t, int64_t, int64_t>* pNode = heapMin.Get(key);
        return pNode != NULL;
    }

    int getCnt(int key, HashHeap<int64_t, int64_t, int64_t>& heapMin, HashHeap<int64_t, int64_t, int64_t>& heapMax)
    {        
        Node<int64_t, int64_t, int64_t>* pNode = heapMin.Get(key);
        if (pNode != NULL) return pNode->Score;
        pNode = heapMax.Get(key);
        if (pNode != NULL) return pNode->Score;
        return 0;
    }
};",1420599391
CyberPunk,U_U,144,3610,cpp,"
bool compare(pair<int, int>& a, pair<int, int>& b)
{
    if (a.first > b.first) return true;
    else if (a.first == b.first)
    {
        return a.second > b.second;
    }
    return false;
}

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {

        vector<int> ans;
        for (int i = 0; i + k - 1 < nums.size(); ++i)
        {
            vector<int> temp;
            for (int t = i; t < i + k; ++t) temp.push_back(nums[t]);

            unordered_map<int, int> dict;
            for (auto& item : temp)
            dict[item]++;

            vector< pair<int, int> > vec;
            for (auto& item : dict) vec.push_back( {item.second, item.first} );

            sort(vec.begin(), vec.end(), compare);

          //  cout << i << endl;
            int sum = 0;
            for (int t = 0; t < min(int(vec.size()), x); ++t) 
            {
              //  cout << vec[t].first << "","" << vec[t].second << endl;
                sum += vec[t].first * vec[t].second;
            }

            ans.push_back(sum);
        }

        return ans;
    }
};",1420523593
skyinde2,skyinde2,145,3509,python3,"

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ret = []

        def dfs(node: Optional[TreeNode]) -> int:
            if not node:
                return 0

            a = dfs(node.left)
            b = dfs(node.right)

            if a == b >= 0:
                ret.append(a + b + 1)
                return a + b + 1
            else:
                return -1

        dfs(root)

        ret.sort(reverse=True)

        return ret[k - 1] if len(ret) >= k else -1

",1420532007
skyinde2,skyinde2,145,3588,python3,"
class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        af = [0] * (n * 2 + 3)
        aw, ae, bf, bw, be = af[:], af[:], af[:], af[:], af[:]

        # fwe
        if s[0] == 'F':
            bw[n + 1] = 1
            bf[n] = 1
            be[n - 1] = 1
        elif s[0] == 'W':
            be[n + 1] = 1
            bw[n] = 1
            bf[n - 1] = 1
        else:  # E
            bf[n + 1] = 1
            be[n] = 1
            bw[n - 1] = 1

        MOD = 1000000007

        for j in range(1, len(s)):
            if s[j] == 'F':
                for i in range(n * 2 + 1):
                    aw[i] = (bf[i - 1] + be[i - 1]) % MOD
                    af[i] = (bw[i] + be[i]) % MOD
                    ae[i] = (bw[i + 1] + bf[i + 1]) % MOD
            elif s[j] == 'W':
                for i in range(n * 2 + 1):
                    aw[i] = (bf[i] + be[i]) % MOD
                    af[i] = (bw[i + 1] + be[i + 1]) % MOD
                    ae[i] = (bw[i - 1] + bf[i - 1]) % MOD
            else:  # E
                for i in range(n * 2 + 1):
                    aw[i] = (bf[i + 1] + be[i + 1]) % MOD
                    af[i] = (bw[i - 1] + be[i - 1]) % MOD
                    ae[i] = (bw[i] + bf[i]) % MOD

            aw, bw = bw, aw
            ae, be = be, ae
            af, bf = bf, af

        ret = (sum(bw[n + 1:]) + sum(be[n + 1:]) + sum(bf[n + 1:])) % MOD
        return ret",1420560641
skyinde2,skyinde2,145,3592,python3,"from sortedcontainers import SortedDict, SortedSet

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnt: dict[int, int] = {}
        s = SortedSet()

        for i in range(k):
            if nums[i] in cnt:
                cnt[nums[i]] += 1
            else:
                cnt[nums[i]] = 1

        for key in cnt:
            s.add((cnt[key], key))

        current = sum(t[0] * t[1] for t in s[-x:])
        ret = [current]

        for i in range(len(nums) - k):
            index = len(s) - x

            i0 = s.bisect_left((cnt[nums[i]], nums[i]))
            s.remove((cnt[nums[i]], nums[i]))
            cnt[nums[i]] -= 1
            s.add((cnt[nums[i]], nums[i]))
            i1 = s.bisect_left((cnt[nums[i]], nums[i]))

            if i0 >= index > i1:
                current -= nums[i] * (cnt[nums[i]] + 1)
                current += s[index][0] * s[index][1]
            elif i0 >= index:
                current -= nums[i]

            if nums[i + k] in cnt:
                i0 = s.bisect_left((cnt[nums[i + k]], nums[i + k]))
                s.remove((cnt[nums[i + k]], nums[i + k]))
                cnt[nums[i + k]] += 1
                s.add((cnt[nums[i + k]], nums[i + k]))
                i1 = s.bisect_left((cnt[nums[i + k]], nums[i + k]))

                if i0 < index <= i1:
                    current += nums[i + k] * cnt[nums[i + k]]
                    current -= s[-x - 1][0] * s[-x - 1][1]
                elif i0 >= index:
                    current += nums[i + k]
            else:
                cnt[nums[i + k]] = 1
                s.add((1, nums[i + k]))
                i1 = s.bisect_left((1, nums[i + k]))
                if i1 >= len(s) - x:
                    current += nums[i + k]
                    if len(s) > x:
                        current -= s[-x - 1][0] * s[-x - 1][1]

            ret.append(current)

        return ret
",1420605399
skyinde2,skyinde2,145,3610,python3,"
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnt = [0] * 51

        ret = []
        for i in range(k):
            cnt[nums[i]] += 1

        t = [(cnt[i], i) for i in range(51)]
        t.sort(reverse=True)
        a = sum(pair[0] * pair[1] for pair in t[:x])
        ret.append(a)

        for i in range(len(nums) - k):
            cnt[nums[i]] -= 1
            cnt[nums[i + k]] += 1

            t = [(cnt[i], i) for i in range(51)]
            t.sort(reverse=True)
            a = sum(pair[0] * pair[1] for pair in t[:x])
            ret.append(a)

        return ret",1420525078
user3744L,user3744L,146,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map<TreeNode*,int> mini, maxi;
    vector<int> temp;

    void calcDepth(TreeNode* node) {
        if (!node) return;
        
        calcDepth(node->left);
        calcDepth(node->right);
        
        mini[node] = min(mini[node->left], mini[node->right]) + 1;
        maxi[node] = max(maxi[node->left], maxi[node->right]) + 1;
    }

    void dfs(TreeNode* root) {
        if (!root) return;
        
        if (maxi[root] == mini[root]) 
            temp.push_back((1 << maxi[root]) - 1);
        
        dfs(root->left);
        dfs(root->right);
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        calcDepth(root);
        dfs(root);

        sort(temp.begin(), temp.end(), greater<int>());
        
        return (k > temp.size()) ? -1 : temp[k - 1];
    }

};",1420587952
user3744L,user3744L,146,3588,cpp,"const int M = 1e9 + 7;
map<char, int> mp;

int dp[1001][2002][4];
class Solution {
public:

    int sol(int i, int prev, int currScore, string &s){
        if(i == s.size()){
            return currScore > 0;
        }
        if(dp[i][currScore + (int)s.size()][prev + 1] != -1)
            return dp[i][currScore + (int)s.size()][prev + 1];

        int num = mp[s[i]];

        long long ans = 0;
        for(int curr = 0; curr <= 2; curr++){
            if(curr == prev) continue;
            int point = 0;
            if(curr == (num + 1) % 3) point = 1;
            if(num == (curr + 1) % 3) point = -1;

            ans += sol(i + 1, curr, currScore + point, s);
            ans %= M;
        }

        return dp[i][currScore + (int)s.size()][prev + 1] = ans;
    }
    int countWinningSequences(string s) {
        for(int i = 0; i < s.size(); i++){
            for(int j = 0; j <= 2 * s.size(); j++){
                for(int k = 0; k < 4; k++)
                    dp[i][j][k] = -1;
            }
        }
        mp['E'] = 0;
        mp['F'] = 1;
        mp['W'] = 2;
        int n = s.size();

        return sol(0, -1, 0, s);
    }
};",1420531369
user3744L,user3744L,146,3592,cpp,"class Solution {
public:
    int X;
    void update(set<pair<long long, long long>> &st1, set<pair<long long, long long>> &st2, long long &curr){
        if(st1.size() == X){
            curr -= st1.begin() -> first * st1.begin() -> second;
            st2.insert(*st1.begin());
            st1.erase(*st1.begin());
        }

        if(!st2.empty()){
            curr += st2.rbegin() -> first * st2.rbegin() -> second;
            st1.insert(*st2.rbegin());
            st2.erase(*st2.rbegin());
        }
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        X = x;
        set<pair<long long, long long>> st1, st2;

        map<int, int> freq;

        long long curr = 0;
        for(int i = 0; i < k; i++){
            st1.erase({freq[nums[i]], nums[i]});
            st2.erase({freq[nums[i]], nums[i]});
            freq[nums[i]]++;

            if(st1.size() < x){
                st1.insert({freq[nums[i]], nums[i]});
                curr += nums[i];
            }
            else
                st2.insert({freq[nums[i]], nums[i]});
            
            update(st1, st2, curr);
        }

        vector<long long> ans(nums.size() - k + 1);
        ans[0] = curr;
        for(int l = 0, i = k; i < nums.size(); i++, l++){
            int removal = nums[l];
            int add = nums[i];

            st1.erase({freq[removal], removal});
            st2.erase({freq[removal], removal});
            freq[removal]--;

            if(st1.size() < x){
                if(freq[removal] != 0)
                    st1.insert({freq[removal], removal});
                curr -= removal;
            }

            else if(freq[removal] != 0)
                st2.insert({freq[removal], removal});

            update(st1, st2, curr);

            st1.erase({freq[add], add});
            st2.erase({freq[add], add});
            freq[add]++;

            if(st1.size() < x){
                st1.insert({freq[add], add});
                curr += add;
            }
            else
                st2.insert({freq[add], add});
            
            update(st1, st2, curr);

            ans[l + 1] = curr;
        }
        return ans;
    }
};",1420575200
user3744L,user3744L,146,3610,cpp,"class Solution {
public:
    int X;
    void update(set<pair<long long, long long>> &st1, set<pair<long long, long long>> &st2, long long &curr){
        if(st1.size() == X){
            curr -= st1.begin() -> first * st1.begin() -> second;
            st2.insert(*st1.begin());
            st1.erase(*st1.begin());
        }

        if(!st2.empty()){
            curr += st2.rbegin() -> first * st2.rbegin() -> second;
            st1.insert(*st2.rbegin());
            st2.erase(*st2.rbegin());
        }
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        X = x;
        set<pair<long long, long long>> st1, st2;

        map<int, int> freq;

        long long curr = 0;
        for(int i = 0; i < k; i++){
            st1.erase({freq[nums[i]], nums[i]});
            st2.erase({freq[nums[i]], nums[i]});
            freq[nums[i]]++;

            if(st1.size() < x){
                st1.insert({freq[nums[i]], nums[i]});
                curr += nums[i];
            }
            else
                st2.insert({freq[nums[i]], nums[i]});
            
            update(st1, st2, curr);
        }

        vector<int> ans(nums.size() - k + 1);
        ans[0] = curr;
        for(int l = 0, i = k; i < nums.size(); i++, l++){
            int removal = nums[l];
            int add = nums[i];

            st1.erase({freq[removal], removal});
            st2.erase({freq[removal], removal});
            freq[removal]--;

            if(st1.size() < x){
                if(freq[removal] != 0)
                    st1.insert({freq[removal], removal});
                curr -= removal;
            }

            else if(freq[removal] != 0)
                st2.insert({freq[removal], removal});

            update(st1, st2, curr);

            st1.erase({freq[add], add});
            st2.erase({freq[add], add});
            freq[add]++;

            if(st1.size() < x){
                st1.insert({freq[add], add});
                curr += add;
            }
            else
                st2.insert({freq[add], add});
            
            update(st1, st2, curr);

            ans[l + 1] = curr;
        }
        return ans;
    }
};",1420580058
Cat and Tea,jmyanxiang,148,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def dfs(node: Optional[TreeNode]) -> int:
            if not node: return 0
            left_sz = dfs(node.left)
            right_sz = dfs(node.right)
            if left_sz == right_sz:
                sz = left_sz * 2 + 1
                sizes.append(sz)
                return sz
            return -1
        
        dfs(root)
        sizes.sort(reverse=True)
        return sizes[k - 1] if len(sizes) >= k else -1
",1420531482
Cat and Tea,jmyanxiang,148,3588,python3,"mod = 10**9 + 7

rules = {
    (""F"", ""E""): 1,
    (""W"", ""F""): 1,
    (""E"", ""W""): 1,
    (""E"", ""F""): -1,
    (""F"", ""W""): -1,
    (""W"", ""E""): -1,
}


class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)

        def calc_score(a: int, b: int) -> int:
            if (a, b) not in rules:
                return 0
            return rules[(a, b)]

        @cache
        def dfs(i: int, banned: str):
            if i == n:
                return Counter({0: 1})

            res = Counter()
            for choice in (""F"", ""W"", ""E""):
                if choice in banned:
                    continue
                score = calc_score(choice, s[i])
                for k, v in dfs(i + 1, choice).items():
                    res[k + score] += v
                    res[k + score] %= mod
            return res
        
        ways_cnt = dfs(0, '')
        return sum(v for k, v in ways_cnt.items() if k > 0) % mod
    ",1420555402
Cat and Tea,jmyanxiang,148,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        count = Counter(nums[:k])
        sl = SortedList([(cnt, val) for val, cnt in count.items()])
        sum_ = sum(cnt * val for cnt, val in sl[-x:])
        res = [sum_]
        for i in range(n - k):
            # add
            add_val = nums[i + k]
            add_cnt = count[add_val]
            add_idx = sl.bisect_left((add_cnt, add_val))
            count[add_val] += 1
            sl.discard((add_cnt, add_val))
            sl.add((add_cnt + 1, add_val))
            after_idx = sl.bisect_left((add_cnt + 1, add_val))
            if after_idx >= len(sl) - x:
                if add_idx < len(sl) - x:
                    sum_ += add_val * count[add_val]
                    if len(sl) >= x:
                        p_cnt, p_val = sl[-x-1]
                        sum_ -= p_cnt * p_val
                else:
                    sum_ += add_val
            
            # subtract
            sub_val = nums[i]
            sub_cnt = count[sub_val]
            sub_idx = sl.bisect_left((sub_cnt, sub_val))
            count[sub_val] -= 1
            sl.remove((sub_cnt, sub_val))
            sl.add((sub_cnt - 1, sub_val))
            after_idx = sl.bisect_left((sub_cnt - 1, sub_val))
            if sub_idx >= len(sl) - x:
                if after_idx < len(sl) - x:
                    sum_ -= sub_val * sub_cnt
                    p_cnt, p_val = sl[-x]
                    sum_ += p_cnt * p_val
                else:
                    sum_ -= sub_val
            if not count[sub_val]:
                sl.discard((count[sub_val], sub_val))
            res.append(sum_)
        return res",1420600397
Cat and Tea,jmyanxiang,148,3610,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        for i in range(n - k + 1):
            count = Counter(nums[i:i+k])
            pairs = sorted(count.items(), key=lambda x: (x[1], x[0]), reverse=True)
            res.append(sum(val * cnt for val, cnt in pairs[:x]))
        return res
",1420523168
Yucheng Dai,Rainingcity,149,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    pair<int, bool> isPerfect(TreeNode* root, vector<int>& perfs) {
        if (root == nullptr) return make_pair(0, true);
        pair<int, bool> lres = isPerfect(root->left, perfs), rres = isPerfect(root->right, perfs);
        int sz = lres.first + rres.first + 1;
        bool flag = lres.second && rres.second && lres.first == rres.first;
        if (flag) {
            perfs.push_back(sz);
        }
        return make_pair(sz, flag);
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfs{};
        isPerfect(root, perfs);
        sort(perfs.begin(), perfs.end(), [](int x, int y){return x > y;});
        return perfs.size() < k ? -1 : perfs[k - 1];
    }
};",1420521112
Yucheng Dai,Rainingcity,149,3588,cpp,"const int MOD = 1000000007;
class Solution {
private:
    int getId(char c) {
        if (c == 'F') return 0;
        if (c == 'W') return 1;
        if (c == 'E') return 2;
        return -1;
    }
    int getRival(int id) {
        if (id == 0) return 1;
        if (id == 1) return 2;
        if (id == 2) return 0;
        return -1;
    }
    int getBeat(int id) {
        if (id == 0) return 2;
        if (id == 1) return 0;
        if (id == 2) return 1;
        return -1;
    }
    int getOtherTwo(vector<int>& dp, int id) {
        return (dp[getRival(id)] + dp[getBeat(id)]) % MOD;
    }
public:
    int countWinningSequences(string s) {
        int n = s.length();
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2 * n + 1, vector<int>(3, 0)));
        dp[0][n + 1][getRival(getId(s[0]))] = 1;
        dp[0][n - 1][getBeat(getId(s[0]))] = 1;
        dp[0][n][getId(s[0])] = 1;
        for(int i = 1; i < n; i++) {
            int alice = getId(s[i]);
            for(int j = 0; j <= 2 * n; j++) {
                dp[i][j][alice] = getOtherTwo(dp[i - 1][j], alice);
                if (j < 2 * n) dp[i][j][getBeat(alice)] = getOtherTwo(dp[i - 1][j + 1], getBeat(alice));
                if (j > 0) dp[i][j][getRival(alice)] = getOtherTwo(dp[i - 1][j - 1], getRival(alice));
            }
            // for(int j = 0; j <= 2 * n; j++) {
            //     cout << i << "" "" << j << "": "" << dp[i][j][0] << "" "" << dp[i][j][1] << "" "" << dp[i][j][2] << endl;
            // }
        }
        int ans = 0;
        for(int j = n + 1; j <= 2 * n; j++) {
            for(int c = 0; c < 3; c++) {
                ans = (ans + dp[n - 1][j][c]) % MOD;
            }
        }
        return ans;
    }
};",1420553286
Yucheng Dai,Rainingcity,149,3592,cpp,"typedef pair<int, int> pii;
class DSet {
private:
    unordered_map<int, int> freqs{};
    set<pii> tops{};
    set<pii> lows{};
    int m;
    long long sum = 0;
    void remove_from_set(int x) {
            auto t = make_pair(freqs[x], x);
            if (tops.count(t)) {
                tops.erase(t);
                sum -= (long long)freqs[x] * x;
                if (tops.size() < m && !lows.empty()) {
                    auto t = *lows.rbegin();
                    lows.erase(t);
                    tops.insert(t);
                    sum += (long long)t.first * t.second;
                }
            } else lows.erase(t);
    }
public:
    DSet(int x) {
        m = x;
    }
    void insert(int x) {
        if (freqs.count(x)) {
            remove_from_set(x);
        } else {
            freqs[x] = 0;
        }
        freqs[x]++;
        tops.insert(make_pair(freqs[x], x));
        sum += (long long)freqs[x] * x;
        if (tops.size() > m) {
            auto t = *tops.begin();
            tops.erase(t);
            sum -= (long long)t.first * t.second;
            lows.insert(t);
        }
    }
    void remove(int x) {
        remove_from_set(x);
        freqs[x]--;
        if (freqs[x] == 0) {
            freqs.erase(x);
            if (tops.size() < m && !lows.empty()) {
                auto t = *lows.rbegin();
                lows.erase(t);
                tops.insert(t);
                sum += (long long)t.first * t.second;
            }
        } else {
            tops.insert(make_pair(freqs[x], x));
            sum += (long long)freqs[x] * x;
            if (tops.size() > m) {
                auto t = *tops.begin();
                tops.erase(t);
                sum -= (long long)t.first * t.second;
                lows.insert(t);
            }
        }
    }
    long long getSum() {return sum;}
    void print() {
        cout << ""freqs: "" << endl;
        for(auto [x, f]: freqs) {
            cout << x << "" "" << f << endl;
        }
        cout << ""tops:"";
        for(pii x: tops) {
            cout << "" "" << x.second;
        }
        cout << endl;
        cout << ""lows:"";
        for(pii x: lows) {
            cout << "" "" << x.second;
        }
        cout << endl;
        cout << ""sum: "" << sum << endl;
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        DSet ds(x);
        int n = nums.size();
        for(int i = 0; i < k; i++) ds.insert(nums[i]);
        vector<long long> ans{};
        ans.reserve(n - k + 1);
        ans.push_back(ds.getSum());
        // ds.print();
        for(int i = k; i < n; i++) {
            ds.remove(nums[i - k]);
            ds.insert(nums[i]);
            ans.push_back(ds.getSum());
            // ds.print();
        }
        return ans;
    }
};",1420599958
Yucheng Dai,Rainingcity,149,3610,cpp,"typedef pair<int, int> pii;
class DSet {
private:
    unordered_map<int, int> freqs{};
    set<pii> tops{};
    set<pii> lows{};
    int m;
    long long sum = 0;
    void remove_from_set(int x) {
            auto t = make_pair(freqs[x], x);
            if (tops.count(t)) {
                tops.erase(t);
                sum -= (long long)freqs[x] * x;
                if (tops.size() < m && !lows.empty()) {
                    auto t = *lows.rbegin();
                    lows.erase(t);
                    tops.insert(t);
                    sum += (long long)t.first * t.second;
                }
            } else lows.erase(t);
    }
public:
    DSet(int x) {
        m = x;
    }
    void insert(int x) {
        if (freqs.count(x)) {
            remove_from_set(x);
        } else {
            freqs[x] = 0;
        }
        freqs[x]++;
        tops.insert(make_pair(freqs[x], x));
        sum += (long long)freqs[x] * x;
        if (tops.size() > m) {
            auto t = *tops.begin();
            tops.erase(t);
            sum -= (long long)t.first * t.second;
            lows.insert(t);
        }
    }
    void remove(int x) {
        remove_from_set(x);
        freqs[x]--;
        if (freqs[x] == 0) {
            freqs.erase(x);
            if (tops.size() < m && !lows.empty()) {
                auto t = *lows.rbegin();
                lows.erase(t);
                tops.insert(t);
                sum += (long long)t.first * t.second;
            }
        } else {
            tops.insert(make_pair(freqs[x], x));
            sum += (long long)freqs[x] * x;
            if (tops.size() > m) {
                auto t = *tops.begin();
                tops.erase(t);
                sum -= (long long)t.first * t.second;
                lows.insert(t);
            }
        }
    }
    long long getSum() {return sum;}
    void print() {
        cout << ""freqs: "" << endl;
        for(auto [x, f]: freqs) {
            cout << x << "" "" << f << endl;
        }
        cout << ""tops:"";
        for(pii x: tops) {
            cout << "" "" << x.second;
        }
        cout << endl;
        cout << ""lows:"";
        for(pii x: lows) {
            cout << "" "" << x.second;
        }
        cout << endl;
        cout << ""sum: "" << sum << endl;
    }
};

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        DSet ds(x);
        int n = nums.size();
        for(int i = 0; i < k; i++) ds.insert(nums[i]);
        vector<int> ans{};
        ans.reserve(n - k + 1);
        ans.push_back(ds.getSum());
        // ds.print();
        for(int i = k; i < n; i++) {
            ds.remove(nums[i - k]);
            ds.insert(nums[i]);
            ans.push_back(ds.getSum());
            // ds.print();
        }
        return ans;
    }
};",1420600629
bramar2,bramar2,150,3509,cpp,"#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; }
template <typename T>
void print2d(T t) { int f = 0; for(const auto& b : t) { cout << (f++ ? ""\n"": """"); print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

auto init = ([]() {fastio;return 1;})();

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        map<int, int> mp;
        function<int(TreeNode*)> dfs = [&](TreeNode* node) -> int {
            if(node->left == nullptr && node->right == nullptr) {
                mp[1]++;
                return 1;
            }
            if(node->left == nullptr || node->right == nullptr) {
                if(node->left != nullptr) dfs(node->left);
                else dfs(node->right);
                return -1;
            }
            int a = dfs(node->left), b = dfs(node->right);
            if(a == -1 || b == -1)
                return -1;

            if(a == b) {
                mp[a+1]++;
                return a+1;
            }else return -1;
        };
        dfs(root);
        k--;
        int x = -1;
        for(auto it = mp.rbegin(); it != mp.rend(); it++) {
            x += it->second;
            // dbg(x, it->first, it->second);
            if(k <= x) {
                return (1 << it->first) - 1;
            }
        }
        return -1;
    }
};

int main1() {
    return 0;
}",1420528516
bramar2,bramar2,150,3588,cpp,"#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; }
template <typename T>
void print2d(T t) { int f = 0; for(const auto& b : t) { cout << (f++ ? ""\n"": """"); print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

auto init = ([]() {fastio;return 1;})();

class Solution {
public:
    int countWinningSequences(const string& s) {
        int n = s.length();
        // bob's net map, pos = winning, neg = losing
        // 1 = can do tie, 0 = cannot do tie
        vector<array<unordered_map<int, ll>, 4>> ways(n+1, {unordered_map<int,ll>(), unordered_map<int,ll>(), unordered_map<int,ll>()});
        ways[0][0][0] = 1;

        // +1 beats, -1 loses
        // F,E,W order
        unordered_map<char, int> mp {{'F', 0}, {'E', 1}, {'W', 2}};
        #define dbg(...)
        for(int i = 0; i < n; i++) {
            int move = mp[s[i]];
            dbg(i, move);
            for(int prev = 0; prev <= 2; prev++) {
                for(auto [net, currWays] : ways[i][prev]) {
                    // case 1: tie (only if prev != s[i])
                    dbg(prev, net, currWays);
                    if(prev != move || i == 0) {
                        ways[i+1][move][net] = (ways[i+1][move][net] + currWays) % MOD;
                    }
                    if(prev != ((move+1)%3) || i == 0) {
                        ways[i+1][(move+1) % 3][net-1] = (ways[i+1][(move+1) % 3][net-1] + currWays) % MOD;    
                    }
                    if(prev != ((move+2)%3) || i == 0) {
                        ways[i+1][(move+2) % 3][net+1] = (ways[i+1][(move+2) % 3][net+1] + currWays) % MOD;
                    }
                    // ways[i+1][true][net+1] = (ways[i+1][true][net+1] + currWays) % MOD;
                    // // case3: alice beats bob
                    // ways[i+1][true][net-1] = (ways[i+1][true][net-1] + currWays) % MOD;
                }
            }
        }
        ll ans = 0;
        for(ll t = 0; t <= 2; t++) {
            for(auto& p : ways[n][t]) {
                if(p.first > 0)
                    ans = (ans + p.second) % MOD;
            }
        }
        return ans;
    }
};

int main1() {
    return 0;
}",1420552781
bramar2,bramar2,150,3592,cpp,"#include <bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; }
template <typename T>
void print2d(T t) { int f = 0; for(const auto& b : t) { cout << (f++ ? ""\n"": """"); print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

auto init = ([]() {fastio;return 1;})();

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> res; res.reserve(n-k+1);

        unordered_map<int, int> mp;
        ordered_set<pair<int, int>> st;
        // both are minused

        for(int i = 0; i < k; i++) {
            st.erase(make_pair(-mp[nums[i]], -nums[i]));
            mp[nums[i]]++;
            st.insert(make_pair(-mp[nums[i]], -nums[i]));
        }
        ll sum = 0;

        {
            auto it = st.begin(); int i = 0;
            while(i < x && it != st.end()) {
                sum += it->first * (ll)it->second;
                i++, it++;
            }
        }
        auto debug = [&](int i) {
            cout << ""ST"" << i << "": (sum = "" << sum << "")\n"";
            for(const auto& p : st) {
                cout << ""{"" << p.first << "", "" << p.second << ""}, "";
            }
            cout << '\n';
        };
        #define dbg(...)
        #define debug(...)
        for(int r = k-1; r < n; r++) {
            dbg(r);
            debug(1);
            int l = r-k+1;
            res.push_back(sum);

            if(r == n-1) break;

            ll sz = st.size(), idx = st.order_of_key(make_pair(-mp[nums[l]], -nums[l]));
            if(idx >= x) {
                st.erase(make_pair(-mp[nums[l]], -nums[l]));
                if(--mp[nums[l]] > 0)
                    st.insert(make_pair(-mp[nums[l]], -nums[l]));
            }else if(sz <= x) { // everything counts
                sum -= nums[l];
                st.erase(make_pair(-mp[nums[l]], -nums[l]));
                if(--mp[nums[l]] > 0)
                    st.insert(make_pair(-mp[nums[l]], -nums[l]));
            }else {
                int idx = st.order_of_key(make_pair(-mp[nums[l]], -nums[l]));
                if(idx >= x) {
                    st.erase(make_pair(-mp[nums[l]], -nums[l]));
                    if(--mp[nums[l]] > 0)
                        st.insert(make_pair(-mp[nums[l]], -nums[l]));
                }else {
                    sum -= nums[l];
                    pair<int,int> before = *st.find_by_order(x-1);

                    st.erase(make_pair(-mp[nums[l]], -nums[l]));
                    if(--mp[nums[l]] > 0)
                        st.insert(make_pair(-mp[nums[l]], -nums[l]));

                    pair<int,int> after = *st.find_by_order(x-1);

                    if(before.second != after.second) {
                        // update smth
                        sum += mp[-after.second]*(ll)-after.second;
                        sum -= mp[nums[l]]*(ll)nums[l];
                    }
                }
            }
            debug(2);

            sz = st.size();
            if(sz < x) {
                sum += nums[r+1];
                st.erase(make_pair(-mp[nums[r+1]], -nums[r+1]));
                mp[nums[r+1]]++;
                st.insert(make_pair(-mp[nums[r+1]], -nums[r+1]));
            }else if(sz == x) {
                if(mp[nums[r+1]] > 0) {
                    sum += nums[r+1];
                    st.erase(make_pair(-mp[nums[r+1]], -nums[r+1]));
                    mp[nums[r+1]]++;
                    st.insert(make_pair(-mp[nums[r+1]], -nums[r+1]));
                }else {
                    sum += nums[r+1];
                    st.erase(make_pair(-mp[nums[r+1]], -nums[r+1]));
                    mp[nums[r+1]]++;
                    st.insert(make_pair(-mp[nums[r+1]], -nums[r+1]));

                    sum -= mp[-(st.rbegin()->second)]*(ll)-(st.rbegin()->second);
                }
            }else if(mp[nums[r+1]] > 0) {
                ll idx = st.order_of_key(make_pair(-mp[nums[r+1]], -nums[r+1]));
                if(idx < x) {
                    sum += nums[r+1];
                    st.erase(make_pair(-mp[nums[r+1]], -nums[r+1]));
                    mp[nums[r+1]]++;
                    st.insert(make_pair(-mp[nums[r+1]], -nums[r+1]));    
                }else {
                    pair<int, int> before = *st.find_by_order(x-1);

                    st.erase(make_pair(-mp[nums[r+1]], -nums[r+1]));
                    mp[nums[r+1]]++;
                    st.insert(make_pair(-mp[nums[r+1]], -nums[r+1]));

                    pair<int, int> after = *st.find_by_order(x-1);

                    if(before.second != after.second) {
                        dbg(mp[nums[r+1]], nums[r+1], mp[-before.second], -before.second);
                        sum += mp[nums[r+1]]*(ll)nums[r+1];
                        sum -= mp[-before.second]*(ll)(-before.second);
                    }
                }
            }else {
                // never been seen before
                pair<int, int> before = *st.find_by_order(x-1);

                mp[nums[r+1]]++;
                st.insert(make_pair(-mp[nums[r+1]], -nums[r+1]));

                pair<int, int> after = *st.find_by_order(x-1);

                if(before.second != after.second) {
                    sum += mp[nums[r+1]]*(ll)nums[r+1];
                    sum -= mp[-before.second]*(ll)-before.second;
                }
            }
            debug(3);
        }
        return res;
    }
};

int main1() {
    return 0;
}",1420600946
bramar2,bramar2,150,3610,cpp,"#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; }
template <typename T>
void print2d(T t) { int f = 0; for(const auto& b : t) { cout << (f++ ? ""\n"": """"); print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

auto init = ([]() {fastio;return 1;})();

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int occ[51] {}, tmp[51] {};
        int n = nums.size();
        for(int i = 0; i < k; i++) {
            occ[nums[i]]++;
        }
        vector<int> res;
        for(int r = k-1; r < n; r++) {
            priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
            for(int j = 1; j <= 50; j++) {
                if(occ[j] > 0) {
                    pq.push(make_pair(occ[j], j));
                    if(pq.size() > x) pq.pop();
                }
            }
            int sum = 0;
            while(!pq.empty()) {
                sum += pq.top().first*pq.top().second;
                pq.pop();
            }
            res.push_back(sum);

            occ[nums[r-k+1]]--;
            if(r+1<n)
            occ[nums[r+1]]++;
        }
        return res;
    }
};

int main1() {
    return 0;
}",1420521082
zokumyoin,zokumyoin,151,3509,java,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> sizes;
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        sizes = new ArrayList<>();
        dfs(root);
        Collections.sort(sizes, Collections.reverseOrder());
        if (sizes.size() < k) {
            return -1;
        }
        return sizes.get(k - 1);
    }

    private int dfs(TreeNode node) {
        if (node == null) {
            return 0;
        }
        if (node.left == null && node.right == null) {
            sizes.add(1);
            return 1;
        }
        int left = dfs(node.left);
        int right = dfs(node.right);
        if (left == -1 || right == -1) {
            return -1;
        }
        if (left != right) {
            return -1;
        }
        sizes.add(left + right + 1);
        return left + right + 1;

    }
}",1420521361
zokumyoin,zokumyoin,151,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int[] alice = new int[s.length()];
        for (int i = 0; i < alice.length; i++) {
            if (s.charAt(i) == 'F') {
                alice[i] = 0;
            } else if (s.charAt(i) == 'W') {
                alice[i] = 1;
            } else {
                alice[i] = 2;
            }
        }

        int MOD = 1_000_000_007;

        int N = s.length();
        int[][][] dp = new int[N][3][2 * N + 1];

        for (int i = 0; i < N; i++) {
            int a = alice[i];
            for (int b = 0; b < 3; b++) {
                // given a,
                // if b > a
                // dp[i][b][x] = dp[i-1][b-1][x-1] + dp[i-1][b+1][x-1]
                // else
                // dp[i][b][x] = dp[i-1][b-1][x] + dp[i-1][b+1][x]

                for (int d = -i - 1; d <= i + 1; d++) {
                    if (b == (a + 1) % 3) {
                        if (i == 0) {
                            dp[0][b][1 + N] = 1;
                        } else {
                            if (d - 1 + N >= 0 && d - 1 + N <= 2 * N) {
                                dp[i][b][d + N] = (dp[i - 1][(b + 1) % 3][d - 1 + N] + dp[i - 1][(b + 2) % 3][d - 1 + N]) % MOD;

                                // System.out.printf(""[%d][%d][%d]=%d\n"", i, b, d, dp[i][b][d + N]);
                            }

                        }
                    } else if (b == a) {
                        if (i == 0) {
                            dp[0][b][N] = 1;
                        } else {
                            if (d + N >= 0 && d + N <= 2 * N) {
                                dp[i][b][d + N] = (dp[i - 1][(b + 1) % 3][d + N] + dp[i - 1][(b + 2) % 3][d + N]) % MOD;
                                // System.out.printf(""[%d][%d][%d]=%d\n"", i, b, d, dp[i][b][d + N]);
                            }
                        }
                    } else {
                        if (i == 0) {
                            dp[i][b][N - 1] = 1;
                        } else {
                            if (d + N + 1 >= 0 && d + N + 1 <= 2 * N) {
                                dp[i][b][d + N] = (dp[i - 1][(b + 1) % 3][d + N + 1] + dp[i - 1][(b + 2) % 3][d + N + 1]) % MOD;
                                // System.out.printf(""[%d][%d][%d]=%d\n"", i, b, d, dp[i][b][d + N]);
                            }
                        }
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 1; i + N < 2 * N + 1; i++) {
            for (int b = 0; b < 3; b++) {
                ans += dp[N - 1][b][i + N];
                ans %= MOD;
            }
        }
        return ans;


    }
}",1420544818
zokumyoin,zokumyoin,151,3592,java,"import java.util.HashMap;
import java.util.HashSet;
import java.util.PriorityQueue;

class Solution {
    public long[] findXSum(int[] arr, int k, int x) {
        long sum = 0;


        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < k; i++) {
            sum += arr[i];
            map.put(arr[i], 1 + map.getOrDefault(arr[i], 0));
        }
        PriorityQueue<int[]> up = new PriorityQueue<>((a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));
        PriorityQueue<int[]> down = new PriorityQueue<>((a, b) -> a[1] == b[1] ? Integer.compare(b[0], a[0]) : Integer.compare(b[1], a[1]));

        HashSet<Integer> upSet = new HashSet<>(map.keySet());
        for (var entry : map.entrySet()) {
            up.add(new int[]{entry.getKey(), entry.getValue()});
        }
        while (up.size() > x) {
            int[] pair = up.poll();
            sum -= (long) pair[0] * pair[1];
            upSet.remove(pair[0]);
            down.add(pair);
        }
        int upSize = up.size();

        HashMap<String, Integer> stale = new HashMap<>();

        long[] ans = new long[arr.length - k + 1];
        ans[0] = sum;
        for (int i = 1; i < ans.length; i++) {


            int add = arr[i + k - 1];
            int remove = arr[i - 1];

            if (add == remove) {
                ans[i] = ans[i - 1];
                continue;
            }
            if (upSet.contains(remove)) {
                upSet.remove(remove);
                upSize--;
                sum -= (long) remove * map.get(remove);
            }
            if (upSet.contains(add)) {
                upSet.remove(add);
                upSize--;
                sum -= (long) add * map.get(add);
            }



            String staleKey = remove + "","" + map.get(remove);
            stale.put(staleKey, 1 + stale.getOrDefault(staleKey, 0));
            int newCntRemove = map.get(remove) - 1;
            if (newCntRemove == 0) {
                map.remove(remove);
            } else {
                map.put(remove, newCntRemove);
            }

            if (newCntRemove > 0) {
                int[] upPeek = null;
                while (!up.isEmpty()) {
                    int[] pair = up.peek();
                    String key = pair[0] + "","" + pair[1];
                    if (stale.getOrDefault(key, 0) > 0) {
                        up.poll();
                        stale.put(key, stale.get(key) - 1);
                    } else {
                        upPeek = pair;
                        break;
                    }
                }
                if (upPeek == null) {
                    down.add(new int[]{remove, newCntRemove});
                } else if (upPeek[1] < newCntRemove || upPeek[1] == newCntRemove && upPeek[0] < remove) {
                    up.add(new int[]{remove, newCntRemove});
                    upSet.add(remove);
                    upSize++;
                    sum += (long) remove * newCntRemove;
                } else {
                    down.add(new int[]{remove, newCntRemove});
                }
            }



            staleKey = add + "","" + map.getOrDefault(add, 0);
            stale.put(staleKey, 1 + stale.getOrDefault(staleKey, 0));
            int newCntAdd = map.getOrDefault(add, 0) + 1;
            map.put(add, newCntAdd);
            int[] upPeek = null;


            while (!up.isEmpty()) {

                int[] pair = up.peek();
                String key = pair[0] + "","" + pair[1];
                if (stale.getOrDefault(key, 0) > 0) {
                    up.poll();
                    stale.put(key, stale.get(key) - 1);
                } else {
                    upPeek = pair;
                    break;
                }
            }
            if (upPeek == null) {
                down.add(new int[]{add, newCntAdd});
            } else if (upPeek[1] < newCntAdd || upPeek[1] == newCntAdd && upPeek[0] < add) {
                up.add(new int[]{add, newCntAdd});
                upSize++;
                upSet.add(add);
                sum += (long) add * newCntAdd;
            } else {
                down.add(new int[]{add, newCntAdd});
            }

            while (upSize > x) {
                int[] pair = up.poll();
                String key = pair[0] + "","" + pair[1];
                if (stale.getOrDefault(key, 0) > 0) {
                    stale.put(key, stale.get(key) - 1);
                } else {
                    upSet.remove(pair[0]);
                    upSize--;
                    down.add(pair);
                    sum -= (long) pair[0] * pair[1];
                }
            }

            while (upSize < x && !down.isEmpty()) {
                int[] pair = down.poll();
                String key = pair[0] + "","" + pair[1];
                if (stale.getOrDefault(key, 0) > 0) {
                    stale.put(key, stale.get(key) - 1);
                } else {
                    upSet.add(pair[0]);
                    upSize++;
                    up.add(pair);
                    sum += (long) pair[0] * pair[1];
                }
            }

            // System.out.printf(""i=%d, upSet=%s upSize=%d\n"", i, upSet, upSize);
            // print(up, stale);
            // System.out.printf(""stale=%s\n"", stale);
            // print(down, stale);
            ans[i] = sum;


        }
        return ans;


    }

    private void print(PriorityQueue<int[]> pq, HashMap<String, Integer> stale) {
        for (int[] pair : pq) {
            String key = pair[0] + "","" + pair[1];
            if (stale.getOrDefault(key, 0) > 0) {
                System.out.printf(""stale: %s\n"", key);
            } else {
                System.out.printf(""-->%s\n"", key);
            }
        }
    }
}",1420599278
zokumyoin,zokumyoin,151,3610,java,"class Solution {
    public int[] findXSum(int[] arr, int k, int x) {
        long sum = 0;


        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < k; i++) {
            sum += arr[i];
            map.put(arr[i], 1 + map.getOrDefault(arr[i], 0));
        }
        PriorityQueue<int[]> up = new PriorityQueue<>((a, b) -> a[1] == b[1] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));
        PriorityQueue<int[]> down = new PriorityQueue<>((a, b) -> a[1] == b[1] ? Integer.compare(b[0], a[0]) : Integer.compare(b[1], a[1]));

        HashSet<Integer> upSet = new HashSet<>(map.keySet());
        for (var entry : map.entrySet()) {
            up.add(new int[]{entry.getKey(), entry.getValue()});
        }
        while (up.size() > x) {
            int[] pair = up.poll();
            sum -= (long) pair[0] * pair[1];
            upSet.remove(pair[0]);
            down.add(pair);
        }
        int upSize = up.size();

        HashMap<String, Integer> stale = new HashMap<>();

        long[] ans = new long[arr.length - k + 1];
        ans[0] = sum;
        for (int i = 1; i < ans.length; i++) {

            System.out.printf(""i=%d upSize=%d\n"", i, upSize);

            int add = arr[i + k - 1];
            int remove = arr[i - 1];

            if (add == remove) {
                ans[i] = ans[i - 1];
                continue;
            }
            if (upSet.contains(remove)) {
                upSet.remove(remove);
                upSize--;
                sum -= (long) remove * map.get(remove);
            }
            if (upSet.contains(add)) {
                upSet.remove(add);
                upSize--;
                sum -= (long) add * map.get(add);
            }

            System.out.printf(""i=%d upSize=%d\n"", i, upSize);


            String staleKey = remove + "","" + map.get(remove);
            stale.put(staleKey, 1 + stale.getOrDefault(staleKey, 0));
            int newCntRemove = map.get(remove) - 1;
            if (newCntRemove == 0) {
                map.remove(remove);
            } else {
                map.put(remove, newCntRemove);
            }

            if (newCntRemove > 0) {
                int[] upPeek = null;
                while (!up.isEmpty()) {
                    int[] pair = up.peek();
                    String key = pair[0] + "","" + pair[1];
                    if (stale.getOrDefault(key, 0) > 0) {
                        up.poll();
                        stale.put(key, stale.get(key) - 1);
                    } else {
                        upPeek = pair;
                        break;
                    }
                }
                if (upPeek == null) {
                    down.add(new int[]{remove, newCntRemove});
                } else if (upPeek[1] < newCntRemove || upPeek[1] == newCntRemove && upPeek[0] < remove) {
                    up.add(new int[]{remove, newCntRemove});
                    upSet.add(remove);
                    upSize++;
                    sum += (long) remove * newCntRemove;
                } else {
                    down.add(new int[]{remove, newCntRemove});
                }
            }



            staleKey = add + "","" + map.getOrDefault(add, 0);
            stale.put(staleKey, 1 + stale.getOrDefault(staleKey, 0));
            int newCntAdd = map.getOrDefault(add, 0) + 1;
            map.put(add, newCntAdd);
            int[] upPeek = null;


            while (!up.isEmpty()) {

                int[] pair = up.peek();
                String key = pair[0] + "","" + pair[1];
                if (stale.getOrDefault(key, 0) > 0) {
                    up.poll();
                    stale.put(key, stale.get(key) - 1);
                } else {
                    upPeek = pair;
                    break;
                }
            }
            if (upPeek == null) {
                down.add(new int[]{add, newCntAdd});
            } else if (upPeek[1] < newCntAdd || upPeek[1] == newCntAdd && upPeek[0] < add) {
                up.add(new int[]{add, newCntAdd});
                upSize++;
                upSet.add(add);
                sum += (long) add * newCntAdd;
            } else {
                down.add(new int[]{add, newCntAdd});
            }

            while (upSize > x) {
                int[] pair = up.poll();
                String key = pair[0] + "","" + pair[1];
                if (stale.getOrDefault(key, 0) > 0) {
                    stale.put(key, stale.get(key) - 1);
                } else {
                    upSet.remove(pair[0]);
                    upSize--;
                    down.add(pair);
                    sum -= (long) pair[0] * pair[1];
                }
            }

            while (upSize < x && !down.isEmpty()) {
                int[] pair = down.poll();
                String key = pair[0] + "","" + pair[1];
                if (stale.getOrDefault(key, 0) > 0) {
                    stale.put(key, stale.get(key) - 1);
                } else {
                    upSet.add(pair[0]);
                    upSize++;
                    up.add(pair);
                    sum += (long) pair[0] * pair[1];
                }
            }

            // System.out.printf(""i=%d, upSet=%s upSize=%d\n"", i, upSet, upSize);
            // print(up, stale);
            // System.out.printf(""stale=%s\n"", stale);
            // print(down, stale);
            ans[i] = sum;


        }
        
        int[] intAns = new int[ans.length];
        for (int i = 0; i < ans.length; i++) {
            intAns[i] = (int)(ans[i]);
        }
        return intAns;
    }
}",1420601030
lydxlx,lydxlx,152,3509,python3,"class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def dfs(root):
            if not root:
                return (0, 0)
            l_size, l_height = dfs(root.left)
            r_size, r_height = dfs(root.right)
            if l_height == r_height and l_size == r_size == (1 << (l_height)) - 1:
                sizes.append(l_size + r_size + 1)
            # print((l_size + r_size + 1, max(l_height, r_height) + 1))
            return (l_size + r_size + 1, max(l_height, r_height) + 1)

        dfs(root)
        sizes = sorted(sizes, reverse=True)
        # print(sizes)

        if len(sizes) < k:
            return -1
        return sizes[k - 1]


sol = Solution()
",1420537178
lydxlx,lydxlx,152,3588,cpp,"#include <iostream>
#include <vector>
#include <cstring>

using namespace std;

const int MOD = 1000000007;
const int OFFSET = 1000;
const int MAX_N = 1010;
const int MAX_WIN = 1010 + OFFSET;
const int MAX_PREV = 5;

int memo[MAX_N][MAX_WIN][MAX_PREV];

class Solution {
public:
    int countWinningSequences(string s) {
        unordered_map<char, int> map = {
            {'F', 0},
            {'E', 1},
            {'W', 2},
        };

        vector<int> A;
        for (char c : s) {
            A.push_back(map[c]);
        }
        int N = A.size();

        memset(memo, -1, sizeof(memo));

        return memoize(0, 0, 4, A, N);
    }

private:
    int memoize(int i, int win, int prev_idx, const vector<int>& A, int N) {
        if (i >= N) {
            return win > 0 ? 1 : 0;
        }

        if (memo[i][win + OFFSET][prev_idx] != -1) {
            return memo[i][win + OFFSET][prev_idx];
        }

        int ans = 0;
        for (int cur = 0; cur < 3; ++cur) {
            if (cur == prev_idx) {
                continue;
            }

            int score = 0;
            if ((cur + 1) % 3 == A[i]) {
                score = 1;
            } else if ((cur + 2) % 3 == A[i]) {
                score = -1;
            }

            ans += memoize(i + 1, win + score, cur, A, N);
            ans %= MOD;
        }

        memo[i][win + OFFSET][prev_idx] = ans;
        return ans;
    }
};

",1420578477
lydxlx,lydxlx,152,3592,python3,"import bisect
from typing import *
from sortedcontainers import SortedList, SortedDict
from collections import Counter, defaultdict
from math import inf
from math import gcd
from math import factorial
import string
import random
import itertools
from functools import cache
from fractions import Fraction

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        freq = Counter()
        for i in range(k):
            freq[nums[i]] += 1
        sortedlist = SortedList()
        for key in freq:
            f = freq[key]
            sortedlist.add((-f, -key, key * f))
        in_set = Counter()
        cur_ans = 0
        for i in range(min(len(sortedlist), x)):
            cur_ans += sortedlist[i][2]
            in_set[-sortedlist[i][1]] += 1
        ans.append(cur_ans)
        for i in range(k, n):
            removed_key = nums[i - k]
            cur_freq = freq[removed_key]
            prev_sum = removed_key * cur_freq
            sortedlist.discard((-cur_freq, -removed_key, prev_sum))
            cur_freq -= 1
            freq[removed_key] -= 1
            new_sum = removed_key * cur_freq
            sortedlist.add((-cur_freq, -removed_key, new_sum))
            if in_set[removed_key] == 1:
                index = sortedlist.bisect_left((-cur_freq, -removed_key, new_sum))
                if index >= x:
                    cur_ans -= prev_sum
                    in_set[removed_key] = 0
                else:
                    cur_ans -= removed_key
            insertedKey = nums[i]
            cur_freq = freq[insertedKey]
            prev_sum = insertedKey * cur_freq
            sortedlist.discard((-cur_freq, -insertedKey, prev_sum))
            cur_freq += 1
            freq[insertedKey] += 1
            new_sum = insertedKey * cur_freq
            sortedlist.add((-cur_freq, -insertedKey, new_sum))
            if in_set[insertedKey] == 1:
                cur_ans += insertedKey
            else:
                index = sortedlist.bisect_left((-cur_freq, -insertedKey, new_sum))
                if index < x:
                    cur_ans += new_sum
                    in_set[insertedKey] = 1
            for i in range(max(0, x - 2), min(x + 3, len(sortedlist))):
                f, key, total = sortedlist[i]
                key = -key
                if i < x and in_set[key] == 0:
                    in_set[key] = 1
                    cur_ans += total
                elif i >= x and in_set[key] == 1:
                    in_set[key] = 0
                    cur_ans -= total
            ans.append(cur_ans)
        return ans

",1420556156
lydxlx,lydxlx,152,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        for i in range(len(nums) - k + 1):
            slice = nums[i:i + k]
            counter = Counter(slice)
            s = 0
            cnt = 0
            for freq, num in reversed(sorted([(v, k) for k, v in counter.items()])):
                s += num * freq
                cnt += 1
                if cnt >= x:
                    break
            ans.append(s)
        return ans
",1420524791
Yuanrui Zhao,GoldenShadow5,153,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public ArrayList<Integer> arr;
    public int check(TreeNode root) {
        if(root == null) {
            return -1;
        }
        if(root.left == null && root.right == null) {
            arr.add(1);
            return 1;
        }
        int l = check(root.left);
        int r = check(root.right);
        if(l == r && l != -1) {
            arr.add(l+r+1);
            return l+r+1;
        }
        return -1;
    }
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        arr = new ArrayList<>();
        check(root);
        Collections.sort(arr);
        Collections.reverse(arr);
        if(arr.size() < k) {
            return -1;
        }
        return arr.get(k-1);
    }
}",1420579187
Yuanrui Zhao,GoldenShadow5,153,3588,java,"class Solution {
    public int trans(char a) {
        if(a == 'F') {
            return 0;
        }
        if(a == 'W') {
            return 1;
        }
        return 2;
    }
    public int score(int a, int b) {
        if(a == b) {
            return 0;
        }
        return (a+1)%3 == b ? 1 : -1;
    }
    public int countWinningSequences(String s) {
        int n = s.length();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++) {
            arr[i] = trans(s.charAt(i));
        }
        long[][][] dp = new long[n][2*n+1][3];
        dp[0][n+score(arr[0], 0)][0] = 1;
        dp[0][n+score(arr[0], 1)][1] = 1;
        dp[0][n+score(arr[0], 2)][2] = 1;
        for(int i = 1; i < n; i++) {
            for(int j = 0; j <= 2*n; j++) {
                for(int k = 0; k < 3; k++) {
                    int jPrev = j-score(arr[i], k);
                    if(jPrev < 0 || jPrev > 2*n) {
                        continue;
                    }
                    dp[i][j][k] = dp[i-1][jPrev][0]+dp[i-1][jPrev][1]+dp[i-1][jPrev][2]-dp[i-1][jPrev][k];
                    dp[i][j][k] %= 1000000007;
                }
            }
        }
        int ans = 0;
        for(int i = n+1; i <= 2*n; i++) {
            for(int j = 0; j < 3; j++) {
                ans = (int) ((ans+dp[n-1][i][j])%1000000007);
            }
        }
        return ans;
    }
}",1420602520
Yuanrui Zhao,GoldenShadow5,153,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        TreeSet<int[]> xMostFreq = new TreeSet<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0] == o2[0]) {
                    return o1[1]-o2[1];
                }
                return o1[0]-o2[0];
            }
        });
        TreeSet<int[]> standby = new TreeSet<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0] == o2[0]) {
                    return o1[1]-o2[1];
                }
                return o1[0]-o2[0];
            }
        });
        HashMap<Integer, Integer> occ = new HashMap<>();
        for(int i = 0; i < k; i++) {
            occ.put(nums[i], occ.getOrDefault(nums[i], 0)+1);
        }
        for(int i: occ.keySet()) {
            int[] arr = {occ.get(i), i};
            standby.add(arr);
        }
        long sum = 0;
        while(xMostFreq.size() < x && !standby.isEmpty()) {
            int[] next = standby.last();
            standby.remove(next);
            xMostFreq.add(next);
            sum += (long) next[0]*next[1];
        }
        long[] res = new long[nums.length-k+1];
        res[0] = sum;
        for(int i = 1; i <= nums.length-k; i++) {
            int rem = nums[i-1];
            int add = nums[i+k-1];
            if(rem == add) {
                res[i] = sum;
                continue;
            }
            int[] curRem = {occ.getOrDefault(rem, 0), rem};
            int[] curAdd = {occ.getOrDefault(add, 0), add};
            int[] updRem = {curRem[0]-1, rem};
            int[] updAdd = {curAdd[0]+1, add};
            occ.put(rem, updRem[0]);
            occ.put(add, updAdd[0]);
            if(xMostFreq.contains(curRem)) {
                xMostFreq.remove(curRem);
                if(updRem[0] > 0) {
                    xMostFreq.add(updRem);
                }
                sum -= rem;
            } else {
                standby.remove(curRem);
                if(updRem[0] > 0) {
                    standby.add(updRem);
                }
            }
            if(xMostFreq.contains(curAdd)) {
                xMostFreq.remove(curAdd);
                xMostFreq.add(updAdd);
                sum += add;
            } else {
                standby.remove(curAdd);
                standby.add(updAdd);
            }
            while(xMostFreq.size() < x && !standby.isEmpty()) {
                int[] next = standby.last();
                standby.remove(next);
                xMostFreq.add(next);
                sum += (long) next[0]*next[1];
            }
            if(!standby.isEmpty()) {
                int[] worst = xMostFreq.first();
                int[] bestAlt = standby.last();
                if(bestAlt[0] > worst[0] || (bestAlt[0] == worst[0] && bestAlt[1] > worst[1])) {
                    xMostFreq.remove(worst);
                    sum -= (long) worst[0]*worst[1];
                    xMostFreq.add(bestAlt);
                    sum += (long) bestAlt[0]*bestAlt[1];
                    standby.add(worst);
                    standby.remove(bestAlt);
                }
            }
            res[i] = sum;
        }
        return res;
    }
}",1420567875
Yuanrui Zhao,GoldenShadow5,153,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        TreeSet<int[]> xMostFreq = new TreeSet<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0] == o2[0]) {
                    return o1[1]-o2[1];
                }
                return o1[0]-o2[0];
            }
        });
        TreeSet<int[]> standby = new TreeSet<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0] == o2[0]) {
                    return o1[1]-o2[1];
                }
                return o1[0]-o2[0];
            }
        });
        HashMap<Integer, Integer> occ = new HashMap<>();
        for(int i = 0; i < k; i++) {
            occ.put(nums[i], occ.getOrDefault(nums[i], 0)+1);
        }
        for(int i: occ.keySet()) {
            int[] arr = {occ.get(i), i};
            standby.add(arr);
        }
        int sum = 0;
        while(xMostFreq.size() < x && !standby.isEmpty()) {
            int[] next = standby.last();
            standby.remove(next);
            xMostFreq.add(next);
            sum += next[0]*next[1];
        }
        int[] res = new int[nums.length-k+1];
        res[0] = sum;
        for(int i = 1; i <= nums.length-k; i++) {
            int rem = nums[i-1];
            int add = nums[i+k-1];
            if(rem == add) {
                res[i] = sum;
                continue;
            }
            int[] curRem = {occ.getOrDefault(rem, 0), rem};
            int[] curAdd = {occ.getOrDefault(add, 0), add};
            int[] updRem = {curRem[0]-1, rem};
            int[] updAdd = {curAdd[0]+1, add};
            occ.put(rem, updRem[0]);
            occ.put(add, updAdd[0]);
            if(xMostFreq.contains(curRem)) {
                xMostFreq.remove(curRem);
                if(updRem[0] > 0) {
                    xMostFreq.add(updRem);
                }
                sum -= rem;
            } else {
                standby.remove(curRem);
                if(updRem[0] > 0) {
                    standby.add(updRem);
                }
            }
            if(xMostFreq.contains(curAdd)) {
                xMostFreq.remove(curAdd);
                xMostFreq.add(updAdd);
                sum += add;
            } else {
                standby.remove(curAdd);
                standby.add(updAdd);
            }
            while(xMostFreq.size() < x && !standby.isEmpty()) {
                int[] next = standby.last();
                standby.remove(next);
                xMostFreq.add(next);
                sum += next[0]*next[1];
            }
            if(!standby.isEmpty()) {
                int[] worst = xMostFreq.first();
                int[] bestAlt = standby.last();
                if(bestAlt[0] > worst[0] || (bestAlt[0] == worst[0] && bestAlt[1] > worst[1])) {
                    xMostFreq.remove(worst);
                    sum -= worst[0]*worst[1];
                    xMostFreq.add(bestAlt);
                    sum += bestAlt[0]*bestAlt[1];
                    standby.add(worst);
                    standby.remove(bestAlt);
                }
            }
            res[i] = sum;
        }
        return res;
    }
}",1420569090
Sanmai Reddy,sanmai_reddy377,154,3509,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
#define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=5e4+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vll v;
    ll dfs(TreeNode *c){
       if(c==NULL){
        return 0;
       }
       ll a=dfs(c->left),b=dfs(c->right);
       if(a==-1 || b==-1 || a!=b) return -1;
       v.pb((1<<(a+1))-1);
       return a+1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
       v.clear();
       dfs(root);
       sort(rall(v));
       if(v.size()<k) return -1;
       return v[k-1];
    }
};",1420534295
Sanmai Reddy,sanmai_reddy377,154,3588,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
#define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=2e3+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

class Solution {
public:
    ll n;
    vll v;
    vector<vvll> dp;
    ll f(ll i,ll j,ll ch){
      if(dp[i][j][ch]!=-1) return dp[i][j][ch];
      if(i==n){
        if(j>n) return dp[i][j][ch]=1;
        return dp[i][j][ch]=0;
      }
      ll ans=0;
      for(int k=0;k<3;k++){
        if(k==ch) continue;
        if(v[i]==k){
            ans=add(ans,f(i+1,j,k));
        }
        else{
            ll a=-1;
            if(k==(v[i]+1)%3) a=1;
            ans=add(ans,f(i+1,a+j,k));
        }
      }
      return dp[i][j][ch]=ans;
    }
    int countWinningSequences(string s) {
        n=s.size(); v.clear(); dp.clear();
        dp.resize(n+1, vvll(2*n+2, vll(3,-1)));
        for(auto &k: s){
            ll val=0;
            if(k=='E') val=1;
            else if(k=='F') val=2;
            v.pb(val);
        }
        ll ans=0;
        for(int i=0;i<3;i++){
           if(v[0]==i){
              ans=add(ans,f(1,n,i));
           }
           else{
              ll a=-1;
              if(i==(v[0]+1)%3) a=1;
               ans=add(ans,f(1,a+n,i));
            }
        }
        return ans;
    }
};",1420562461
Sanmai Reddy,sanmai_reddy377,154,3592,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
// #define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=2e3+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>   //ordered_set<T> st;
using namespace __gnu_pbds;
template <class T> using ordered_set = tree<T, null_type, 
greater<T>, rb_tree_tag,tree_order_statistics_node_update>;
//here pbds is a set like data type in the abv if greater is written it will show descending set if less_eqaul multset
//mthds 1 .insert(x) 2 .find_by_order(y)->K-th element in a set (counting from zero) 3 .order_of_key(x)->returns num of eles that are less than x(even if u wrote less_equal) 4 .lower_bound,.upper_bound(),.erase()


class Solution {
public:
    ordered_set<pll> st;
    map<ll,ll> mp;
    ll sum=0,y;

    void add(ll x){
      if(mp[x]!=0){
        ll ind=st.order_of_key({mp[x],x});
        st.erase({mp[x],x});
        if(ind<y){
           sum-=mp[x]*x;
           auto it=st.find_by_order(y-1);
           if(it!=st.end()){
             pll v=*it;
             sum+=v.ff*v.ss;
           }
        }
      }
      mp[x]++;
      st.insert({mp[x],x});
      ll ind=st.order_of_key({mp[x],x});
      if(ind<y){
        sum+=(mp[x]*x);
        auto it=st.find_by_order(y);
        if(it!=st.end()){
            pll v=*it;
            sum-=v.ff*v.ss;
        }
      }
    }
    void rmv(ll x){
      ll ind=st.order_of_key({mp[x],x});
      st.erase({mp[x],x});
      if(ind<y){
        sum-=mp[x]*x;
        auto it=st.find_by_order(y-1);
        if(it!=st.end()){
            pll v=*it;
            sum+=v.ff*v.ss;
        }
      }
      mp[x]--;
      if(mp[x]==0) rt 
      st.insert({mp[x],x});
      ind=st.order_of_key({mp[x],x});
      if(ind<y){
        sum+=(mp[x]*x);
        auto it=st.find_by_order(y);
        if(it!=st.end()){
            pll v=*it;
            sum-=v.ff*v.ss;
        }
      }
    }
    vector<long long> findXSum(vector<int>& v, int k, int x) {
        y=x; sum=0;
        st.clear(); mp.clear();        
        ll i=0,n=v.size();
        vll ans;
        while(i<n && i<k){
          add(v[i]);
          i++;
        }
        // for(auto &k: st){
        //     cout<<k.ff<<"" ""<<k.ss<<endl;
        //   }
        //   de(k)
        ans.pb(sum);
        while(i<n){
          rmv(v[i-k]);
          add(v[i]);
        //   for(auto &k: st){
        //     cout<<k.ff<<"" ""<<k.ss<<endl;
        //   }
        //   de(i)
          ans.pb(sum);
          i++;
        }
        return ans;
    }
};",1420603027
Sanmai Reddy,sanmai_reddy377,154,3610,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
#define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=5e4+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

class Solution {
public:
    ll f(map<ll,ll> &mp,ll x){
      vpll v;
      for(auto &k: mp){
         if(k.ss==0) continue;
         v.pb({k.ss,k.ff});
      }
      sort(rall(v));
      ll sum=0;
      for(int i=0;i<v.size() && i<x;i++){
        sum+=v[i].ss*v[i].ff;
      }
      return sum;
    }
    vector<int> findXSum(vector<int>& v, int k, int x) {
        ll n=v.size(),i=0;
        vi ans;
        map<ll,ll> mp;
        for(;i<k;i++){
          mp[v[i]]++;
        }
        ans.pb(f(mp,x));
        for(;i<n;i++){
            mp[v[i-k]]--;
            mp[v[i]]++;
            ans.pb(f(mp,x));
        }
        return ans;
    }
};",1420523827
Sangarsu Abhijith,abhijith89,156,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<int,int> find(TreeNode* root , vector<int> &v){
        if(root==NULL){
            return {0,1};
        }
        pair<int,int> x1 = find(root->right,v);
        pair<int,int> x2 = find(root->left,v);
        if(x1.second==1 and x2.second==1){
            if(x1.first==x2.first){
                // cout<<root->val<<"" ""<<x1.first<<"" ""<<x2.first<<endl;
                v.push_back(x1.first+x2.first+1);
                return {x1.first+x2.first+1,1};
            }
        }
        return {x1.first+x2.first+1,0};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int>v;
        find(root,v);
        sort(v.rbegin(),v.rend());
        // for(int i:v){
            // cout<<i<<"" "";
        // }
        cout<<endl;
        if(v.size()<k){
            return -1;
        }
        return v[k-1];
    }
};",1420527249
Sangarsu Abhijith,abhijith89,156,3588,cpp,"class Solution {
public:
    int f(int a , int b){
        if(a==b)return 0;
        if(a==0 and b==1){
            return -1;
        }
        if(a==2 and b==0){
            return -1;
        }
        if(a==1 and b==2){
            return -1;
        }
        if(a==1 and b==0){
            return 1;
        }
        if(a==0 and b==2){
            return 1;
        }
        if(a==2 and b==1){
            return 1;
        }
        return 0;
    }
    int countWinningSequences(string s) {
        int n = s.length();
        vector<long long>v;
        for(int i=0;i<n;i++){
            if(s[i]=='F')v.push_back(0);
            if(s[i]=='W')v.push_back(2);
            if(s[i]=='E')v.push_back(1);
        }
        const int mod = 1e9+7;
        map<long long,long long>mp[3];
        mp[0][f(v[0],0)]=1;
        mp[1][f(v[0],1)]=1;
        mp[2][f(v[0],2)]=1;
        for(int i=1;i<n;i++){
            map<long long,long long>mp1[3];
            for(auto j:mp[0]){
                int val = f(v[i],1);
                mp1[1][j.first+val]+=j.second;
                mp1[1][j.first+val]%=mod;
                val = f(v[i],2);
                mp1[2][j.first+val]+=j.second;
                mp1[2][j.first+val]%=mod;
                // cout<<j.first+val<<"" ""<<mp1[1][j.first+val]<<"" ""<<mp1[2][j.first+val]<<endl;
            }
            for(auto j:mp[1]){
                int val = f(v[i],0);
                mp1[0][j.first+val]+=j.second;
                mp1[0][j.first+val]%=mod;
                val = f(v[i],2);
                mp1[2][j.first+val]+=j.second;
                mp1[2][j.first+val]%=mod;
            }
            for(auto j:mp[2]){
                int val = f(v[i],0);
                mp1[0][j.first+val]+=j.second;
                mp1[0][j.first+val]%=mod;
                val = f(v[i],1);
                mp1[1][j.first+val]+=j.second;
                mp1[1][j.first+val]%=mod;
            }
            mp[0]=mp1[0];
            mp[1]=mp1[1];
            mp[2]=mp1[2];
        }
        long long ans=0;
        for(auto i:mp[0]){
            if(i.first>0){
                ans+=i.second;
                ans%=mod;
            }
        }
         for(auto i:mp[1]){
            if(i.first>0){
                ans+=i.second;
                ans%=mod;
            }
        }
         for(auto i:mp[2]){
            if(i.first>0){
                ans+=i.second;
                ans%=mod;
            }
        }
        return ans;
    }
};",1420603202
Sangarsu Abhijith,abhijith89,156,3592,cpp,"class Solution {
public:
    #define pii pair<long long,long long>
    #define ff first
    #define ss second
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        long long n=a.size();
        map<long long,long long>mp;
        for(int i=0;i<k;i++){
            mp[a[i]]++;
        }
        set<pii>s,s1;
        long long ans=0;
        for(auto i:mp){
            s.insert({i.ss,i.ff});
            ans+=(i.ss*i.ff);
        }
        while(s.size()>x){
            auto it = s.begin();
            pii p = *it;
            ans -=(p.ss*p.ff);
            s1.insert(p);
            s.erase(it);
        }
        vector<long long> v;
        v.push_back(ans);
        for(int i=k;i<n;i++){
            // cout<<i<<endl;
            if(a[i]!=a[i-k]){
                pii p1={mp[a[i]],a[i]};
            pii p2={mp[a[i-k]],a[i-k]};
            if(s.find(p1)!=s.end()){
                s.erase(p1);
                ans-=(p1.ff*p1.ss);
            }
            else s1.erase(p1);
            if(s.find(p2)!=s.end()){
                s.erase(p2);
                ans-=(p2.ff*p2.ss);
            }
            else s1.erase(p2);
            p1.ff+=1;
            p2.ff-=1;
            mp[a[i]]++;
            mp[a[i-k]]--;
            s1.insert(p1);
            s1.insert(p2);
            }
            else{
            }
            while(s.size()<x and s1.size()>0){
                auto it2 = (--s1.end());
                pii a2 = *(--s1.end());
                ans+=(a2.ff*a2.ss);
                s1.erase(it2);
                s.insert(a2);
            }
            while(1){
                if(s1.size()==0 or s.size()==0)break;
                auto it1 = s.begin();
                auto it2 = (--s1.end());
                pii a1 = *s.begin();
                pii a2 = *(--s1.end());
                if(a1.ff>a2.ff)break;
                if(a1.ff==a2.ff){
                    if(a1.ss>=a2.ss)break;
                }
                ans+=(a2.ff*a2.ss);
                ans-=(a1.ff*a1.ss);
                s.erase(it1);
                s1.erase(it2);
                s.insert(a2);
                s1.insert(a1);
            }
            // for(pii p :s){
            //     cout<<p.ff<<"" ""<<p.ss<<endl;
            // }
            v.push_back(ans);
        }
        return v;
    }
};",1420568363
Sangarsu Abhijith,abhijith89,156,3610,cpp,"class Solution {
public:
     #define pii pair<long long,long long>
    #define ff first
    #define ss second
    vector<int> findXSum(vector<int>& a, int k, int x) {
        long long n=a.size();
        map<long long,long long>mp;
        for(int i=0;i<k;i++){
            mp[a[i]]++;
        }
        set<pii>s,s1;
        long long ans=0;
        for(auto i:mp){
            s.insert({i.ss,i.ff});
            ans+=(i.ss*i.ff);
        }
        while(s.size()>x){
            auto it = s.begin();
            pii p = *it;
            ans -=(p.ss*p.ff);
            s1.insert(p);
            s.erase(it);
        }
        vector<int> v;
        v.push_back(ans);
        for(int i=k;i<n;i++){
            // cout<<i<<endl;
            if(a[i]!=a[i-k]){
                pii p1={mp[a[i]],a[i]};
            pii p2={mp[a[i-k]],a[i-k]};
            if(s.find(p1)!=s.end()){
                s.erase(p1);
                ans-=(p1.ff*p1.ss);
            }
            else s1.erase(p1);
            if(s.find(p2)!=s.end()){
                s.erase(p2);
                ans-=(p2.ff*p2.ss);
            }
            else s1.erase(p2);
            p1.ff+=1;
            p2.ff-=1;
            mp[a[i]]++;
            mp[a[i-k]]--;
            s1.insert(p1);
            s1.insert(p2);
            }
            else{
            }
            while(s.size()<x and s1.size()>0){
                auto it2 = (--s1.end());
                pii a2 = *(--s1.end());
                ans+=(a2.ff*a2.ss);
                s1.erase(it2);
                s.insert(a2);
            }
            while(1){
                if(s1.size()==0 or s.size()==0)break;
                auto it1 = s.begin();
                auto it2 = (--s1.end());
                pii a1 = *s.begin();
                pii a2 = *(--s1.end());
                if(a1.ff>a2.ff)break;
                if(a1.ff==a2.ff){
                    if(a1.ss>=a2.ss)break;
                }
                ans+=(a2.ff*a2.ss);
                ans-=(a1.ff*a1.ss);
                s.erase(it1);
                s1.erase(it2);
                s.insert(a2);
                s1.insert(a1);
            }
            // for(pii p :s){
            //     cout<<p.ff<<"" ""<<p.ss<<endl;
            // }
            v.push_back(ans);
        }
        return v;
    }
};",1420570163
Ivan_len,Ivan_len,159,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> a;
        auto dfs = [&](auto&& self, TreeNode* root) -> int {
            if (root == nullptr) return -1;
            if (root -> left == nullptr && root -> right == nullptr) {
                a.push_back(1);
                return 1;
            }
            int l = self(self, root -> left);
            int r = self(self, root -> right);
            if (root -> left == nullptr || root -> right == nullptr) return -1;
            if (l == -1 || r == -1 || l != r) return -1;
            a.push_back(l + r + 1);
            return l + r + 1;
        };
        dfs(dfs, root);
        sort(a.rbegin(), a.rend());
        if (k > a.size()) return -1;
        return a[k - 1];
    }
};",1420522475
Ivan_len,Ivan_len,159,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        const int M = 1e9 + 7;
        const int offset = n + 5;
        // + n + 5
        vector<vector<int>> d, f;
        d.resize(3, vector<int>(2 * n + 10));
        for (int i = 0; i < n; i++) {
            // for (int _ = 0; _ < 3; _++) {
            //     for (int j = 0; j < 2 * n + 10; j++) cout << d[_][j] << ' ';
            //     cout << '\n';
            // }
            if (i == 0) {
                if (s[i] == 'F') {
                    d[0][1 + offset] = 1;
                    d[1][offset] = 1;
                    d[2][-1 + offset] = 1;
                }
                if (s[i] == 'E') {
                    d[1][1 + offset] = 1;
                    d[2][offset] = 1;
                    d[0][-1 + offset] = 1;
                }
                if (s[i] == 'W') {
                    d[2][1 + offset] = 1;
                    d[0][offset] = 1;
                    d[1][-1 + offset] = 1;
                }
            }
            else {
                f.clear();
                f.resize(3, vector<int>(2 * n + 10));
                for (int pts = -i - 1; pts <= i + 1; pts++) {
                    if (s[i] == 'F') {
                        f[0][pts + offset] = (d[1][pts + offset - 1] + d[2][pts + offset - 1]) % M;
                        f[1][pts + offset] = (d[0][pts + offset] + d[2][pts + offset]) % M;
                        f[2][pts + offset] = (d[0][pts + offset + 1] + d[1][pts + offset + 1]) % M;
                    }
                    if (s[i] == 'E') {
                        f[0][pts + offset] = (d[1][pts + offset + 1] + d[2][pts + offset + 1]) % M;
                        f[1][pts + offset] = (d[0][pts + offset - 1] + d[2][pts + offset - 1]) % M;
                        f[2][pts + offset] = (d[0][pts + offset] + d[1][pts + offset]) % M;
                    }
                    if (s[i] == 'W') {
                        f[0][pts + offset] = (d[1][pts + offset] + d[2][pts + offset]) % M;
                        f[1][pts + offset] = (d[0][pts + offset + 1] + d[2][pts + offset + 1]) % M;
                        f[2][pts + offset] = (d[0][pts + offset - 1] + d[1][pts + offset - 1]) % M;
                    }
                }
                swap(f, d);
            }
        }
        // for (int _ = 0; _ < 3; _++) {
        //     for (int j = 0; j < 2 * n + 10; j++) cout << d[_][j] << ' ';
        //     cout << '\n';
        // }
        int ans = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 1; j <= n; j++) {
                ans = (ans + d[i][j + offset]) % M;
            }
        }
        return ans;
    }
};",1420539725
Ivan_len,Ivan_len,159,3592,cpp,"#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define ordered_set tree<pair<int, int>, null_type,less<pair<int, int>>, rb_tree_tag,tree_order_statistics_node_update>

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> ans;
        int n = nums.size();
        map<int, int> mp;
        long long sum = 0;
        ordered_set st;
        for (int i = 0; i < n; i++) {
            if (i + k > n) break;
            if (i == 0) {
                for (int j = 0; j < k; j++) mp[nums[j]]++;
                for (auto [elem, cnt] : mp) st.insert(make_pair(-cnt, -elem));
                for (int i = 0; i < min(x, (int)st.size()); i++) {
                    auto iter = st.find_by_order(i);
                    sum += (long long)iter->first * iter->second;
                }
                ans.push_back(sum);
            }
            else {
                if (nums[i - 1] == nums[i + k - 1]) {
                    ans.push_back(sum);
                    continue;
                }
                auto b1 = make_pair(-mp[nums[i - 1]], -nums[i - 1]);
                auto b2 = make_pair(-mp[nums[i + k - 1]], -nums[i + k - 1]);
                int o1 = st.order_of_key(b1);
                int o2 = st.order_of_key(b2);
                st.erase(b1);
                st.erase(b2);
                mp[nums[i - 1]]--;
                mp[nums[i + k - 1]]++;
                auto b3 = b1, b4 = b2;
                b3.first++;
                b4.first--;
                st.insert(b3);
                st.insert(b4);
                int o3 = st.order_of_key(b3);
                int o4 = st.order_of_key(b4);
                // cout << o1 << ' ' << o2 << ' ' << o3 << ' ' << o4 << '\n';
                int counter = 0;
                if (o1 <= x - 1 && o3 <= x - 1) sum -= nums[i - 1];
                else if (o1 <= x - 1 && o3 >= x) {
                    counter++;
                    sum -= (long long)b1.first * b1.second;
                }
                else assert(o1 >= x && o3 >= x);
                if (o2 <= x - 1 && o4 <= x - 1) sum += nums[i + k - 1];
                else if (o2 >= x && o4 <= x - 1) {
                    sum += (long long)b4.first * b4.second;
                    counter--;
                }
                else assert(o2 >= x && o4 >= x);
                if (counter == 1) {
                    assert(st.size() >= x);
                    auto iter = st.find_by_order(x - 1);
                    sum += (long long)iter->first * iter->second;
                }
                else if (counter == -1) {
                    if (st.size() >= x + 1) {
                        auto iter = st.find_by_order(x);
                        sum -= (long long)iter->first * iter->second;
                    }
                }
                ans.push_back(sum);
            }
            // for (auto i : st) cout << i.first << ' ' << i.second << '\n';
            // cout << sum << '\n';
        }
        return ans;
    }
};",1420585667
Ivan_len,Ivan_len,159,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (i + k > n) continue;
            map<int, int> mp;
            for (int j = i; j < i + k; j++) mp[nums[j]]++;
            vector<pair<int, int>> a;
            for (auto [elem, cnt] : mp) a.push_back(make_pair(-cnt, -elem));
            sort(a.begin(), a.end());
            int sum = 0;
            for (int i = 0; i < min((int)a.size(), x); i++) sum += a[i].first * a[i].second;
            ans.push_back(sum);
        }
        return ans;
    }
};",1420543718
Marmaduke,Marmaduke,160,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void dfs(TreeNode* root, unordered_map<TreeNode*,int>& X)
    {
        auto L = root->left;
        auto R = root->right;
        if(L)
        {
            dfs(L, X);
        }
        if(R)
        {
            dfs(R, X);
        }
        if(!L && !R)
        {
            X[root] = 1;
        }
        else
        {
            if(L && R)
            {
                if(X[L] == X[R] && X[L] != -1)
                {
                    X[root] = 1 + 2*X[L];
                }
                else
                {
                    X[root] = -1;
                }
            }
            else
            {
                X[root] = -1;
            }
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        unordered_map<TreeNode*, int> X;
        dfs(root, X);
        vector<int> poop;
        for(auto &u : X)
        {
            if(u.second != -1)
            {
                poop.push_back(u.second);
            }
        }
        sort(poop.rbegin(), poop.rend());
        if(k > poop.size())
        {
            return -1;
        }
        return poop[k-1];
    }
};",1420523512
Marmaduke,Marmaduke,160,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        map<char,int> M;
        M['F'] = 0;
        M['E'] = 1;
        M['W'] = 2;
        vector<int> A;
        for(auto &u : s)
        {
            A.push_back(M[u]);
        }

        const int mod = 1e9+7;
        typedef long long int ll;
        int n = A.size();
        int z = 2*(n+1)+5;
        int h = n+1;
        vector<vector<vector<ll>>> dp(2, vector<vector<ll>>(z, vector<ll>(3,0)));
        
        for(int j = 0; j < 3; j++)
        {
            int t = A[0];
            if(j == t)
            {
                dp[0][h][j] = 1;
            }
            else
            {
                if((j+1)%3 == t)
                {
                    dp[0][h+1][j] = 1;
                }
                else
                {
                    dp[0][h-1][j] = 1;
                }
            }
        }
        for(int i = h-1; i <= h+1; i++)
        {
            for(int j = 0; j < 3; j++)
            {
                //cout << ""turn: "" << 0 << ""; wins: "" << i-h << ""; ending: "" << j << ""; total: "" << dp[0][i][j] << endl;
            }
        }

        for(int s = 1; s < n; s++)
        {
            //cout << ""turn: "" << s << ""; val: "" << A[s] << endl;
            int t = A[s];
            int now = s % 2;
            int prev = (s-1) % 2;
            for(int i = 0; i < z; i++)
            {
                for(int j = 0; j < 3; j++)
                {
                    dp[now][i][j] = 0;
                }
            }
            int L = s+1;
            for(int i = h-L; i <= h+L; i++)
            {
                for(int j = 0; j< 3; j++)
                {
                    int a = (j+1)%3;
                    int b = (j+2)%3;
                    if(j == t) // match
                    {
                        dp[now][i][j] = (dp[prev][i][a] + dp[prev][i][b])%mod;
                    }
                    else
                    {
                        if((j+1)%3 == t) // win
                        {
                            dp[now][i][j] = (dp[prev][i-1][a] + dp[prev][i-1][b])%mod;
                        }
                        else // lose
                        {
                            dp[now][i][j] = (dp[prev][i+1][a] + dp[prev][i+1][b])%mod;
                        }
                    }
                    //cout << ""turn: "" << s << ""; wins: "" << i-h << ""; ending: "" << j << ""; total: "" << dp[now][i][j] << endl;
                }
            }
        }

        int ans = 0;
        for(int i = h+1; i < z; i++)
        {
            for(int j = 0; j < 3; j++)
            {
                ans = (ans + dp[(n+1)%2][i][j]) % mod;
            }
        }

        return ans;
    }
};",1420577221
Marmaduke,Marmaduke,160,3592,cpp,"typedef pair<long long int,long long int> pii;
ostream& operator<<(ostream& out, pii x)
{
    out << ""("" << x.first << "", "" << x.second << "")"";
    return out;
}
class Solution {
public:
    void add_in(set<pii>& L, set<pii>& R, int k, long long int& sum, pii& V)
    {
        sum += V.first*V.second;
        R.insert(V);
        if(R.size() > k)
        {
            auto it = R.begin();
            auto W = *it;
            R.erase(it);
            sum -= W.first*W.second;
            L.insert(W);
        }
    }
    void take_out(set<pii>& L, set<pii>& R, int k, long long int& sum, pii& V)
    {
        if(R.count(V))
        {
            sum -= V.first * V.second;
            R.erase(V);
            if(!L.empty())
            {
                auto it = L.end();
                it--;
                auto W = *it;
                sum += W.first*W.second;
                R.insert(W);
                L.erase(it);
            }
        }
        else
        {
            L.erase(V);
        }
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pii> L, R;
        map<long long int,long long int> cts;
        long long int sum = 0;
        vector<long long int> ans;
        for(int i = 0; i < nums.size(); i++)
        {
            long long int t = nums[i];
            long long int old = cts[t];
            if(old > 0)
            {
                pii V(old, t);
                take_out(L, R, x, sum, V);
            }

            cts[t]++;
            pii VV(cts[t], t);
            add_in(L, R, x, sum, VV);

            if(i >= k)
            {
                long long int q = nums[i-k];
                long long int oq = cts[q];
                if(oq > 0)
                {
                    pii W(oq, q);
                    take_out(L, R, x, sum, W);
                }
                cts[q]--;
                if(cts[q] > 0)
                {
                    pii WW(cts[q], q);
                    add_in(L, R, x, sum, WW);
                }
            } 
            if(i >= k-1)
            {
                ans.push_back(sum);
            }
/*
            cout << ""i = "" << i << ""; "" << endl;
            cout << ""L = "";
            for(auto &u : L)
            {
                cout << u;
            }
            cout << endl;
            cout << ""R = "";
            for(auto &u : R)
            {
                cout << u;
            }
            cout << endl;
*/
        }

        return ans;
    }
};",1420603558
Marmaduke,Marmaduke,160,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> R;
        for(int i = k-1; i < nums.size(); i++)
        {
            int s = i-(k-1);
            map<int,int> M;
            for(int j= s; j <= i; j++)
            {
                M[nums[j]]++;
            }
            vector<vector<int>> V;
            for(auto &u : M)
            {
                V.push_back({u.second, u.first});
            }
            sort(V.rbegin(), V.rend());
            int sum = 0;
            for(int j = 0; j < min(x,(int)V.size()); j++)
            {
                sum += V[j][0]*V[j][1];
            }
            R.push_back(sum);
        }

        return R;
    }
};",1420528318
Ajit,Ajit123,161,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> vals;
public:
    pair<int, int> dfs(TreeNode* root, vector<int>& sizes) {
        if (!root) {
            return {0, 0};
        }

        if (!root->left && !root->right) {
            sizes.push_back(1);
            return {1, 1};
        }

        pair<int, int> lval = dfs(root->left, sizes);
        pair<int, int> rval = dfs(root->right, sizes);
        if (lval.second && rval.second && (lval.first == rval.first)) {
            sizes.push_back(lval.first + rval.first + 1);
        }

        return {lval.first + rval.first + 1, lval.second && rval.second && (lval.first == rval.first)};
    }


    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vals.clear();
        int cur = 1;
        while(cur<=15) {
            vals.push_back((1<<cur)-1);
            cur++;
        }

        vector<int> sizes;
        dfs(root, sizes);
        sort(sizes.rbegin(), sizes.rend());


        if (sizes.size() < k) {
            return -1;
        }

        return sizes[k-1];
    }
};",1420530868
Ajit,Ajit123,161,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        int MOD = 1e9 + 7;
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2*n+5, vector<int>(3))); // No of ways bob gets j points
        vector<char> vals = {'W', 'F', 'E'};
        map<char, int> type = {{'F', 0}, {'E', 1}, {'W', 2}};
        const int SHIFT = n;

        auto f = [&](int x) -> int {
            return x + SHIFT; 
        };


        for(int move=0; move<3; move++) {
            if (type[s[0]] == move) {
                dp[1][f(1)][move] = 1;
            }
            else if (vals[move] == s[0]) {
                dp[1][f(0)][move] = 1;
            }
            else {
                dp[1][f(-1)][move] = 1;
            }
        }

        for(int i=2; i<=n; i++) {
            for(int j=-n; j<=n; j++) {
                for(int move=0; move<3; move++) {
                    if (type[s[i-1]] == move) {
                        if (f(j-1) >= 0)
                        dp[i][f(j)][move] = (1ll * dp[i-1][f(j-1)][0] + dp[i-1][f(j-1)][1] + dp[i-1][f(j-1)][2] - dp[i-1][f(j-1)][move]) % MOD;
                    }
                    else if (vals[move] == s[i-1]) { 
                        dp[i][f(j)][move] = (1ll * dp[i-1][f(j)][0] + dp[i-1][f(j)][1] + dp[i-1][f(j)][2] - dp[i-1][f(j)][move]) % MOD;
                    }
                    else {
                        if (f(j+1) < 2 * n + 2)
                        dp[i][f(j)][move] = (1ll * dp[i-1][f(j+1)][0] + dp[i-1][f(j+1)][1] + dp[i-1][f(j+1)][2] - dp[i-1][f(j+1)][move]) % MOD; 
                    }

                }
            }
        }

        int ans = 0;
        for(int j=1; j<=n; j++) {
            for(int move=0; move<3; move++) {
                ans += dp[n][f(j)][move];
                if (ans >= MOD) {
                    ans -= MOD;
                }
            }
        }

        return ans;
    }
};",1420570313
Ajit,Ajit123,161,3592,cpp,"#define ll long long
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int lim) {
        using pii = pair<int, int>;
        set<pii> smin;
        set<pii, greater<pii>> smax;
        map<int, int> cnt;
        ll cur_sum = 0;

        auto adjust = [&]() {
            while (smin.size() > lim) {
                auto it = *smin.begin();
                smin.erase(smin.begin());
                cur_sum -= 1ll * it.first * it.second;
                smax.insert(it);
            }
            
            while (smin.size() < lim && !smax.empty()) {
                auto it = *smax.begin();
                smax.erase(smax.begin());
                smin.insert(it);
                cur_sum += 1ll * it.first * it.second;
            }
        };

        auto insert = [&](int c, int x) {
            pii p = {c, x};
            if (smax.empty() || p > *smax.begin()) {
                smin.insert({c, x});
                cur_sum += 1ll * c * x;
                adjust();
            }
            else {
                smax.insert({c, x});
                adjust();
            }
        };

        auto add = [&](int x) {
            cnt[x]++;
            int count = cnt[x];
            if (count == 1) {
                insert(count, x);
            }
            else {
                if (smin.count({count-1, x})) {
                    cur_sum -= 1ll * (count-1) * x;
                    smin.erase({count-1, x});
                }
                else if (smax.count({count-1, x})) {
                    smax.erase({count-1, x});
                }

                insert(count, x);
            }
        };

        auto remove = [&](int x) {
            cnt[x]--;
            int count = cnt[x];
            if (smin.count({count+1, x})) {
                cur_sum -= 1ll * (count+1) * x;
                smin.erase({count+1, x});
            }
            else if (smax.count({count+1, x})) {
                smax.erase({count+1, x});
            }

            if (count) {
                insert(count, x);
            }
        };

        for(int i=0; i<k-1; i++) {
            add(nums[i]);
        }

        vector<ll> ans;
        for(int i=k-1; i<nums.size(); i++) {
            add(nums[i]);
            ans.push_back(cur_sum);
            remove(nums[i-k+1]);
        }

        return ans;
    }
};",1420598790
Ajit,Ajit123,161,3610,cpp,"class Solution {
public:
    int solve(const vector<int>& v, int x) {
        map<int, int> cnt;
        for(auto it: v) {
            cnt[it]++;
        }

        vector<pair<int, int>> vals;
        for(auto it: cnt) {
            vals.push_back({it.second, it.first});
        }

        sort(vals.rbegin(), vals.rend());
        int ans = 0;
        for(int i=0; i<min(x,(int)vals.size()); i++) {
            ans += vals[i].first * vals[i].second;
        }
        
        return ans;
    }

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for(int i=0; i+k-1<nums.size(); i++) {
            ans.push_back(solve(vector<int>(nums.begin()+i, nums.begin()+i+k), x));
        }
        return ans;
    }
};",1420520664
mastoori1234,mastoori1234,165,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        
        vector<int> arr;
        
        typedef pair<bool, int> pii;
        
        function<pii(TreeNode*)> solve;
        
        solve = [&](TreeNode* nodeptr)->pii {
            if(nodeptr==NULL) {
                return { true, 0};
            }
            pii res( false, 1);
            pii l = solve(nodeptr->left);
            pii r = solve(nodeptr->right);
            if(l.first && r.first && (l.second==r.second)) {
                res.first = true;
                res.second = 1+l.second+r.second;
            }
            if(res.first) {
                arr.push_back(res.second);   
            }
            return res;
        };
        
        solve(root);
        
        sort( arr.begin(), arr.end());
        reverse( arr.begin(), arr.end());
        
        return (arr.size()<k)?(-1):arr[k-1];
    }
};",1420545100
mastoori1234,mastoori1234,165,3588,cpp,"typedef long long int ll;

ll n;
ll dp[1001][2001][4];
ll arr[1001];

const ll mod = 1e9+7;


ll solve( ll idx, ll score, ll last) {
    if(score<0) {
        return 0;
    }
    if(idx<0) {
        return (score>n);
    }
    // cout << "" idx: "" << idx << "" score: "" << score << "" last "" << last << endl;
    ll & ans = dp[idx][score][last];
    if(dp[idx][score][last]==-1) {
        ans = 0;
        for( ll curr=0; curr<3; curr++) {
            if(curr==last) {
                 continue;
            }
            if(curr==(1+arr[idx])%3) {
                ans += solve( idx-1, score+1, curr);
            } else if(curr==arr[idx]) {
                ans += solve( idx-1, score, curr);
            } else {
                ans += solve( idx-1, score-1, curr);
            }
        }
        ans = ans%mod;
    }
    return ans;
};

class Solution {
    
public:
    int countWinningSequences(string s) {
        
        
        n = s.length();
            
        for( ll i=0; i<n; i++) {
            char ch = s[i];
            int v;
            if(ch=='F') {
                v = 0;
            } else if(ch=='W') {
                v = 1;
            } else {
                v = 2;
            }
            arr[i] = v;
        }
        
        
        for( ll idx=0; idx<n; idx++) {
            for( ll score=0; score<=2*n; score++) {
                for( ll last=0; last<=3; last++) {
                    dp[idx][score][last] = -1;
                }
            }
        }      
        
        
        return solve( n-1, n, 3);        
    }
};",1420605249
mastoori1234,mastoori1234,165,3592,cpp,"typedef long long ll;

class Solution {
public:
    vector<long long> findXSum(vector<int>& arr, int k, int x) {
        
        ll n = arr.size();
        
        vector<ll> ans;
        
        typedef pair<ll,ll> pii;
        typedef pair< ll, set<pii> > PII;
        
        auto add = []( PII & P, pii p)->void {
            P.first += p.first*p.second;
            P.second.insert(p);
        };
        
        auto remove = []( PII & P, pii p)->void {
            P.first -= p.first*p.second;
            P.second.erase(p);
        };
        
        auto move = [&]( PII & src, PII & dst, pii p)->void {
            remove( src, p);
            add( dst, p);
        };
        
        PII high( 0LL, set<pii>());
        PII low( 0LL, set<pii>());
        
        auto handleAdd = [&]( pii p)->void {
            add( high, p);
            p = *(high.second.begin());
            move( high, low, p);
        };
        
        auto handleRemove = [&]( pii p)->void {
            if(high.second.find(p)!=high.second.end()) {
                remove( high, p);
                return;
            }
            if(low.second.find(p)!=low.second.end()) {
                remove( low, p);
                return;
            }
        };
        
        auto balance = [&]()->void {
            while(high.second.size()>x) {
                pii p = *high.second.begin();
                move( high, low, p);
            }
            while(high.second.size()<x) {
                if(low.second.empty()) {
                    break;
                }
                pii p = *(low.second.rbegin());
                move( low, high, p);
            }
        };
        
        unordered_map<ll,ll> mp;
        
        for( ll i=0; i<k; i++) {
            ll v = arr[i];
            handleRemove({ mp[v], v});
            mp[v] += 1;
            handleAdd({ mp[v], v});
            balance();
        }
        
        ll si = 0;
        ll ei = k-1;
        
        while(true) {
            
            ans.push_back(high.first);
            
            if(ei+1>=n) {
                break;
            }
            
            ll v;
            
            v = arr[si];
            si += 1;
            
            handleRemove({ mp[v], v});
            mp[v] -= 1;
            if(mp[v]>0) {
                handleAdd({ mp[v], v});
            }
            
            ei += 1;
            v = arr[ei];
            handleRemove({ mp[v], v});
            mp[v] += 1;
            handleAdd({ mp[v], v});
            
            balance();
        }
        
        
        return ans;
    }
};",1420538546
mastoori1234,mastoori1234,165,3610,cpp,"typedef long long ll;

class Solution {
public:
    vector<int> findXSum(vector<int>& arr, int k, int x) {
        
        ll n = arr.size();
        
        vector<int> ans;
        
        typedef pair<ll,ll> pii;
        typedef pair< ll, set<pii> > PII;
        
        auto add = []( PII & P, pii p)->void {
            P.first += p.first*p.second;
            P.second.insert(p);
        };
        
        auto remove = []( PII & P, pii p)->void {
            P.first -= p.first*p.second;
            P.second.erase(p);
        };
        
        auto move = [&]( PII & src, PII & dst, pii p)->void {
            remove( src, p);
            add( dst, p);
        };
        
        PII high( 0LL, set<pii>());
        PII low( 0LL, set<pii>());
        
        auto handleAdd = [&]( pii p)->void {
            add( high, p);
            p = *(high.second.begin());
            move( high, low, p);
        };
        
        auto handleRemove = [&]( pii p)->void {
            if(high.second.find(p)!=high.second.end()) {
                remove( high, p);
                return;
            }
            if(low.second.find(p)!=low.second.end()) {
                remove( low, p);
                return;
            }
        };
        
        auto balance = [&]()->void {
            while(high.second.size()>x) {
                pii p = *high.second.begin();
                move( high, low, p);
            }
            while(high.second.size()<x) {
                if(low.second.empty()) {
                    break;
                }
                pii p = *(low.second.rbegin());
                move( low, high, p);
            }
        };
        
        unordered_map<ll,ll> mp;
        
        for( ll i=0; i<k; i++) {
            ll v = arr[i];
            handleRemove({ mp[v], v});
            mp[v] += 1;
            handleAdd({ mp[v], v});
            balance();
        }
        
        ll si = 0;
        ll ei = k-1;
        
        while(true) {
            
            ans.push_back(high.first);
            
            if(ei+1>=n) {
                break;
            }
            
            ll v;
            
            v = arr[si];
            si += 1;
            
            handleRemove({ mp[v], v});
            mp[v] -= 1;
            if(mp[v]>0) {
                handleAdd({ mp[v], v});
            }
            
            ei += 1;
            v = arr[ei];
            handleRemove({ mp[v], v});
            mp[v] += 1;
            handleAdd({ mp[v], v});
            
            balance();
        }
        
        
        return ans;
    }
};",1420539358
Govind Singh,Govind_Singh_2003,167,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    tuple<bool, int, int> dfs(TreeNode* r, vector<int>& sz) {
        if (!r) return {true, -1, 0};
        
        auto [lp, lh, ls] = dfs(r->left, sz);
        auto [rp, rh, rs] = dfs(r->right, sz);
        
        bool p = lp && rp && lh == rh;
        int h = lh + 1;
        
        if (p) {
            int s = (1 << (h + 1)) - 1;
            sz.push_back(s);
            return {true, h, s};
        }
        
        return {false, h, 0};
    }
    
    int kthLargestPerfectSubtree(TreeNode* r, int k) {
        vector<int> sz;
        dfs(r, sz);
        sort(sz.rbegin(), sz.rend());
        return sz.size() < k ? -1 : sz[k - 1];
    }
};
",1420522915
Govind Singh,Govind_Singh_2003,167,3588,cpp,"class Solution {
public:
    int dp[1000][2001][4];
    int n;

    int isBobWinning(char aliceMove, char bobMove) 
    {
        if ((aliceMove == 'F' && bobMove == 'E') || 
            (aliceMove == 'W' && bobMove == 'F') || 
            (aliceMove == 'E' && bobMove == 'W')) { 
            return -1;
        }
        if ((bobMove == 'F' && aliceMove == 'E') || 
            (bobMove == 'W' && aliceMove == 'F') || 
            (bobMove == 'E' && aliceMove == 'W')) { 
            return 1;
        }
        return 0;
    }
    char f(int bobMove) {
        if (bobMove == 0) return 'E';
        if (bobMove == 1) return 'F';
        if (bobMove == 2) return 'W';
        return '\0';
    }
    int solve(int i, int diff, int last, string& s) {
        if (i == n) 
            return diff > 0;
        
        if (dp[i][diff + 1000][last] != -1) 
            return dp[i][diff + 1000][last];
        
        int mod = 1e9 + 7;
        int res = 0;
        
        for (int cur = 0; cur < 3; ++cur) {
            if (cur == last) 
                continue;
            
            int newDiff = diff + isBobWinning(s[i], f(cur));
            res = (res + solve(i + 1, newDiff, cur, s)) % mod;
        }
        
        return dp[i][diff + 1000][last] = res;
    }
    
    int countWinningSequences(string s) {
        memset(dp, -1, sizeof(dp));
        n = s.size();
        return solve(0, 0, 3, s);
    }
};
",1420568704
Govind Singh,Govind_Singh_2003,167,3592,cpp,"class Solution {
public:
    map<int, int> mpp;
    int need;
    long long cur = 0;
    set<pair<int, int>> inset;
    set<pair<int, int>, greater<>> outset;

    void remove(int f, int x) {
        if(inset.find({f, x}) != inset.end()) {
            cur -= 1LL * x * f;
            inset.erase({f, x});
        } else if(outset.find({f, x}) != outset.end()) {
            outset.erase({f, x});
        }
        
        if(inset.size() < need) {
            if(outset.size()) {
                cur += 1LL * outset.begin()->second * outset.begin()->first;
                inset.insert(*outset.begin());
                outset.erase(outset.begin());
            }
        }
    }

    void add(int f, int x) {
        inset.insert({f, x});
        cur += 1LL * x * f;
        if(inset.size() > need) {
            cur -= 1LL * inset.begin()->second * inset.begin()->first;
            outset.insert(*inset.begin());
            inset.erase(inset.begin());
        }
    }

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        need = x;

        vector<long long> res;
        for(int i = 0; i < k; i++)
            mpp[nums[i]]++;

        for(auto [a, b] : mpp) {
            inset.insert({b, a});
            cur += 1LL * a * b;
            if(inset.size() > x) {
                auto p = *inset.begin();
                outset.insert(p);
                cur -= 1LL * p.second * p.first;
                inset.erase(inset.begin());
            }
        }

        res.push_back(cur);

        for(int i = k; i < n; i++) {
            remove(mpp[nums[i]], nums[i]);
            mpp[nums[i]]++;
            add(mpp[nums[i]], nums[i]);

            remove(mpp[nums[i - k]], nums[i - k]);
            mpp[nums[i - k]]--;
            if(mpp[nums[i - k]]) add(mpp[nums[i - k]], nums[i - k]);

            res.push_back(cur);
        }
        return res;
    }
};
",1420605664
Govind Singh,Govind_Singh_2003,167,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;

        for (int i = 0; i <= n - k; ++i) {
            unordered_map<int, int> freq;
            for (int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }

            vector<pair<int, int>> freqList(freq.begin(), freq.end());
            sort(freqList.begin(), freqList.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.second == b.second) return a.first > b.first;
                return a.second > b.second;
            });

            int xSum = 0, cnt = 0;
            for (auto& [a, b] : freqList) {
                if (cnt == x) 
                    break;
                xSum += a * b;
                cnt++;
            }

            ans.push_back(xSum);
        }

        return ans;
    }
};
",1420519820
qdd1999,qdd1999,170,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
  int kthLargestPerfectSubtree(TreeNode* root, int k) {
    vector<int> sz;

    auto dfs = [&](auto self, TreeNode* node) -> pair<bool, int> {
      if (node == nullptr) return {true, 0};
      auto [l, ls] = self(self, node->left);
      auto [r, rs] = self(self, node->right);
      if (!l || !r) return {false, 0};
      if (ls != rs) return {false, 0};
      sz.push_back(ls + rs + 1);
      return {true, ls + rs + 1};
    };

    dfs(dfs, root);

    sort(sz.begin(), sz.end(), greater<int>());

    return (k <= sz.size() ? sz[k - 1] : -1);
  }
};",1420519376
qdd1999,qdd1999,170,3588,cpp,"// tourist
template <typename T>
T inverse(T a, T m) {
  T u = 0, v = 1;
  while (a != 0) {
    T t = m / a;
    m -= t * a;
    swap(a, m);
    u -= t * v;
    swap(u, v);
  }
  assert(m == 1);
  return u;
}

template <typename T>
class Modular {
public:
  using Type = typename decay<decltype(T::value)>::type;

  constexpr Modular() : value() {}
  template <typename U>
  Modular(const U& x) {
    value = normalize(x);
  }

  template <typename U>
  static Type normalize(const U& x) {
    Type v;
    if (-mod() <= x && x < mod())
      v = static_cast<Type>(x);
    else
      v = static_cast<Type>(x % mod());
    if (v < 0) v += mod();
    return v;
  }

  const Type& operator()() const { return value; }
  template <typename U>
  explicit operator U() const {
    return static_cast<U>(value);
  }
  constexpr static Type mod() { return T::value; }

  Modular& operator+=(const Modular& other) {
    if ((value += other.value) >= mod()) value -= mod();
    return *this;
  }
  Modular& operator-=(const Modular& other) {
    if ((value -= other.value) < 0) value += mod();
    return *this;
  }
  template <typename U>
  Modular& operator+=(const U& other) {
    return *this += Modular(other);
  }
  template <typename U>
  Modular& operator-=(const U& other) {
    return *this -= Modular(other);
  }
  Modular& operator++() { return *this += 1; }
  Modular& operator--() { return *this -= 1; }
  Modular operator++(int) {
    Modular result(*this);
    *this += 1;
    return result;
  }
  Modular operator--(int) {
    Modular result(*this);
    *this -= 1;
    return result;
  }
  Modular operator-() const { return Modular(-value); }

  template <typename U = T>
  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
#ifdef _WIN32
    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(""divl %4; \n\t"" : ""=a""(d), ""=d""(m) : ""d""(xh), ""a""(xl), ""r""(mod()));
    value = m;
#else
    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
    return *this;
  }
  template <typename U = T>
  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {
    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());
    value = normalize(value * rhs.value - q * mod());
    return *this;
  }
  template <typename U = T>
  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
    value = normalize(value * rhs.value);
    return *this;
  }

  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

  friend const Type& abs(const Modular& x) { return x.value; }

  template <typename U>
  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

  template <typename U>
  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

  template <typename V, typename U>
  friend V& operator>>(V& stream, Modular<U>& number);

private:
  Type value;
};

template <typename T>
bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {
  return lhs.value == rhs.value;
}
template <typename T, typename U>
bool operator==(const Modular<T>& lhs, U rhs) {
  return lhs == Modular<T>(rhs);
}
template <typename T, typename U>
bool operator==(U lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) == rhs;
}

template <typename T>
bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {
  return !(lhs == rhs);
}
template <typename T, typename U>
bool operator!=(const Modular<T>& lhs, U rhs) {
  return !(lhs == rhs);
}
template <typename T, typename U>
bool operator!=(U lhs, const Modular<T>& rhs) {
  return !(lhs == rhs);
}

template <typename T>
bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {
  return lhs.value < rhs.value;
}

template <typename T>
Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) += rhs;
}
template <typename T, typename U>
Modular<T> operator+(const Modular<T>& lhs, U rhs) {
  return Modular<T>(lhs) += rhs;
}
template <typename T, typename U>
Modular<T> operator+(U lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) += rhs;
}

template <typename T>
Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) -= rhs;
}
template <typename T, typename U>
Modular<T> operator-(const Modular<T>& lhs, U rhs) {
  return Modular<T>(lhs) -= rhs;
}
template <typename T, typename U>
Modular<T> operator-(U lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) -= rhs;
}

template <typename T>
Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) *= rhs;
}
template <typename T, typename U>
Modular<T> operator*(const Modular<T>& lhs, U rhs) {
  return Modular<T>(lhs) *= rhs;
}
template <typename T, typename U>
Modular<T> operator*(U lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) *= rhs;
}

template <typename T>
Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) /= rhs;
}
template <typename T, typename U>
Modular<T> operator/(const Modular<T>& lhs, U rhs) {
  return Modular<T>(lhs) /= rhs;
}
template <typename T, typename U>
Modular<T> operator/(U lhs, const Modular<T>& rhs) {
  return Modular<T>(lhs) /= rhs;
}

template <typename T, typename U>
Modular<T> qk(const Modular<T>& a, const U& b) {
  assert(b >= 0);
  Modular<T> x = a, res = 1;
  U p = b;
  while (p > 0) {
    if (p & 1) res *= x;
    x *= x;
    p >>= 1;
  }
  return res;
}

template <typename T>
bool IsZero(const Modular<T>& number) {
  return number() == 0;
}

template <typename T>
string to_string(const Modular<T>& number) {
  return to_string(number());
}

// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
  return stream << number();
}

// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
  typename common_type<typename Modular<T>::Type, int64_t>::type x;
  stream >> x;
  number.value = Modular<T>::normalize(x);
  return stream;
}

constexpr int P = (int)1e9 + 7;
using Mint = Modular<std::integral_constant<decay<decltype(P)>::type, P>>;

int mapping(char c) {
  if (c == 'F') return 0;
  if (c == 'E') return 1;
  return 2;
} 

int reward(int a, int b) { return (a == b ? 0 : (a + 1) % 3 == b ? -1 : 1); }

class Solution {
public:
  int countWinningSequences(string s) {
    int n = s.size();
    vector<vector<Mint>> dp(2 * n + 1, vector<Mint>(3));
    int x = mapping(s[0]);
    dp[n + reward(x, 0)][0] = 1;
    dp[n + reward(x, 1)][1] = 1;
    dp[n + reward(x, 2)][2] = 1;
    for (int i = 1; i < n; i++) {
      vector<vector<Mint>> ndp(2 * n + 1, vector<Mint>(3));
      int x = mapping(s[i]);
      for (int j = 0; j <= 2 * n; j++) {
        for (int k = 0; k < 3; k++) {
          for (int l = 0; l < 3; l++) {
            if (k == l) continue;
            int nj = j + reward(x, l);
            if (nj < 0 || nj > 2 * n) continue;
            ndp[nj][l] += dp[j][k];
          }
        }
      }
      swap(dp, ndp);
    }
    Mint ans = 0;
    for (int i = n + 1; i <= 2 * n; i++) {
      for (int j = 0; j < 3; j++) {
        ans += dp[i][j];
      }
    }
    return ans();
  }
};",1420541290
qdd1999,qdd1999,170,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template <class T>
using rank_set = tree<T, null_type, greater<T>, rb_tree_tag, tree_order_statistics_node_update>;

class Solution {
public:
  vector<long long> findXSum(vector<int>& nums, int k, int x) {
    int n = nums.size();

    unordered_map<int, int> freq;
    rank_set<pair<int, int>> s;

    long long ans = 0;

    auto add = [&](int y) {
      if (freq.count(y)) {
        pair<int, int> p = {freq[y], y};
        int rnk = s.order_of_key(p);
        if (rnk < x) {
          ans -= 1LL * freq[y] * y;
          if (s.size() > x) {
            auto [foo, bar] = *s.find_by_order(x);
            ans += 1LL * foo * bar;
          }
        }
        s.erase(p);
      }
      freq[y]++;
      pair<int, int> q = {freq[y], y};
      s.insert(q);
      int rnk2 = s.order_of_key(q);
      if (rnk2 < x) {
        ans += 1LL * freq[y] * y;
        if (s.size() > x) {
          auto [foo, bar] = *s.find_by_order(x);
          ans -= 1LL * foo * bar;
        }
      }
    };

    auto remove = [&](int y) {
      pair<int, int> p = {freq[y], y};
      int rnk = s.order_of_key(p);
      if (rnk < x) {
        ans -= 1LL * freq[y] * y;
        if (s.size() > x) {
          auto [foo, bar] = *s.find_by_order(x);
          ans += 1LL * foo * bar;
        }
      }
      s.erase(p);
      freq[y]--;
      pair<int, int> q = {freq[y], y};
      s.insert(q);
      int rnk2 = s.order_of_key(q);
      if (rnk2 < x) {
        ans += 1LL * freq[y] * y;
        if (s.size() > x) {
          auto [foo, bar] = *s.find_by_order(x);
          ans -= 1LL * foo * bar;
        }
      }
      if (freq[y] == 0) {
        freq.erase(y);
        s.erase(q);
      }
    };

    for (int i = 0; i < k; i++) {
      add(nums[i]);
    }

    vector<long long> res = {ans};

    for (int i = k; i < n; i++) {
      remove(nums[i - k]);
      add(nums[i]);
      res.push_back(ans);
    }

    return res;
  }
};",1420606401
qdd1999,qdd1999,170,3610,cpp,"class Solution {
public:
  vector<int> findXSum(vector<int>& nums, int k, int x) {
    int n = nums.size();

    vector<int> ans;

    auto work = [&](const vector<int>& v) {
      map<int, int> cnt;
      for (int x : v) {
        cnt[x]++;
      }
      vector<pair<int, int>> a;
      for (auto [k, v] : cnt) {
        a.push_back({v, k});
      }
      sort(a.rbegin(), a.rend());
      int sum = 0;
      for (int i = 0; i < min((int)a.size(), x); i++) {
        sum += a[i].second * a[i].first;
      }
      return sum;
    };

    for (int i = 0; i + k <= n; i++) {
      ans.push_back(work(vector<int>(nums.begin() + i, nums.begin() + i + k)));
    }
    return ans;
  }
};",1420547446
Zejun Wu,watashi,171,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
  vector<int> v;

  int gao(TreeNode* root) {
    if (root == nullptr) {
      return 0;
    }
    else {
      int l = gao(root->left);
      int r = gao(root->right);
      if (l >= 0 && r >= 0 && l == r) {
        v.push_back(l + 1);
        return l + 1;
      }
      else {
        return -1;
      }
    }
  }

  int kthLargestPerfectSubtree(TreeNode* root, int k) {
    v.clear();
    gao(root);
    sort(v.rbegin(), v.rend());
    if (k <= v.size()) {
      return (1 << v[k - 1]) - 1;
    }
    else {
      return -1;
    }
  }
};",1420523442
Zejun Wu,watashi,171,3588,cpp,"class Solution {
public:
  static constexpr int64_t MOD = 1000000007;

  int countWinningSequences(string s) {
    static constexpr char fwe[] = ""FWE"";
    const int n = s.length();
    vector<array<int64_t, 3>> dp(n * 2 + 1, { 0, 0, 0 });
    fill(dp[n].begin(), dp[n].end(), (MOD + 1) / 2);
    for (int i = 0; i < n; ++i) {
      const int alice = find(fwe, fwe + 3, s[i]) - fwe;
      vector<array<int64_t, 3>> pre(n * 2 + 1, { 0, 0, 0 });
      pre.swap(dp);
      for (int j = 0; j < 3; ++j) {
        const int j1 = (j + 1) % 3;
        const int j2 = (j + 2) % 3;
        const int win = j2 == alice ? 1 : (j1 == alice ? -1 : 0);
        for (int k = 0; k <= n + n; ++k) {
          if (0 <= k + win && k + win <= n + n) {
            dp[k + win][j] += pre[k][j1] + pre[k][j2];
            dp[k + win][j] %= MOD;
          }
        }
      }
    }
    int64_t ret = 0;
    for (int i = n + 1; i <= n + n; ++i) {
      for (int j = 0; j < 3; ++j) {
        ret += dp[i][j];
      }
    }
    return (int)(ret % MOD);
  }
};",1420538198
Zejun Wu,watashi,171,3592,cpp,"class Solution {
  struct Node {
    using Value = pair<int, int>;
    using Ptr = std::unique_ptr<Node>;

    int priority;
    Value value;
    Ptr left;
    Ptr right;

    int size = 1;
    long long sum = 0;

    Node(int priority, const Value& value): priority(priority), value(value) {
    }

    void updateStat() {
      size = 1;
      sum = (long long)value.first * value.second;
      if (left) {
        size += left->size;
        sum += left->sum;
      }
      if (right) {
        size += right->size;
        sum += right->sum;
      }
    }

    static Ptr create(const Value& value) {
      auto leaf = std::make_unique<Node>(rand(), value);
      leaf->updateStat();
      return leaf;
    }

    Ptr detachLeft() {
      return std::move(left);
    }

    Ptr detachRight() {
      return std::move(right);
    }

    static Ptr rotateRight(Ptr root) {
      Ptr left = root->detachLeft();
      Ptr right = left->detachRight();
      root->left = std::move(right);
      root->updateStat();
      left->right = std::move(root);
      left->updateStat();
      return left;
    }

    static Ptr rotateLeft(Ptr root) {
      Ptr right = root->detachRight();
      Ptr left = right->detachLeft();
      root->right = std::move(left);
      root->updateStat();
      right->left = std::move(root);
      right->updateStat();
      return right;
    }

    static Ptr insert(Ptr root, const Value& value) {
      if (!root) {
        return create(value);
      }
      if (value < root->value) {
        root->left = insert(root->detachLeft(), value);
        if (root->left->priority > root->priority) {
          return rotateRight(std::move(root));
        }
      }
      else if (value > root->value) {
        root->right = insert(root->detachRight(), value);
        if (root->right->priority > root->priority) {
          return rotateLeft(std::move(root));
        }
      }
      root->updateStat();
      return root;
    }

    static Ptr erase(Ptr root, const Value& value) {
      if (!root) {
        return root;
      }
      if (value < root->value) {
        root->left = erase(root->detachLeft(), value);
        root->updateStat();
        return root;
      }
      else if (value > root->value) {
        root->right = erase(root->detachRight(), value);
        root->updateStat();
        return root;
      }
      else if (!root->left) {
        return root->detachRight();
      }
      else if (!root->right) {
        return root->detachLeft();
      }
      else if (root->left->priority >= root->right->priority) {
        return erase(rotateRight(std::move(root)), value);
      }
      else {
        return erase(rotateLeft(std::move(root)), value);
      }
    }
  };

  void dump(const Node::Ptr& root) {
    if (root) {
      dump(root->left);
      printf(""(%d,%d) "", root->value.first, root->value.second);
      dump(root->right);
    }
  }

  static long long query(const Node::Ptr& root, int n) {
    if (!root) {
      return 0;
    }
    else if (root->size <= n) {
      return root->sum;
    }
    else {
      long long ret = 0;
      if (root->right) {
        ret += query(root->right, n);
        n -= root->right->size;
      }
      if (n > 0) {
        ret += (long long)root->value.first * root->value.second;
        n -= 1;
      }
      if (n > 0) {
        ret += query(root->left, n);
      }
      return ret;
    }
  }
  
public:
  vector<long long> findXSum(vector<int>& nums, int k, int x) {
    map<int, int> c;
    for (int i = 0; i < k; ++i) {
      ++c[nums[i]];
    }
    Node::Ptr treap;
    for (const auto& i : c) {
      treap = Node::insert(std::move(treap), make_pair(i.second, i.first));
    }

    vector<long long> ret;
    // dump(treap); puts("""");
    ret.push_back(query(treap, x));
    for (int i = k; i < (int)nums.size(); ++i) {
      const int head = nums[i - k];
      const int tail = nums[i];
      if (head != tail) {
        const int chead = c[head]--;
        const int ctail = c[tail]++;
        treap = Node::erase(std::move(treap), make_pair(chead, head));
        if (chead > 1) {
          treap = Node::insert(std::move(treap), make_pair(chead - 1, head));
        }
        if (ctail > 0) {
          treap = Node::erase(std::move(treap), make_pair(ctail, tail));
        }
        treap = Node::insert(std::move(treap), make_pair(ctail + 1, tail));
      }
      // dump(treap); puts("""");
      ret.push_back(query(treap, x));
    }
    return ret;
  }
};",1420612495
Zejun Wu,watashi,171,3610,cpp,"class Solution {
public:
  int findXSum(const int* a, int n, int x) {
    map<int, int> c;
    for (int i = 0; i < n; ++i) {
      ++c[a[i]];
    }
    vector<pair<int, int>> v;
    for (const auto& i : c) {
      v.emplace_back(i.second, i.first);
    }
    sort(v.rbegin(), v.rend());
    if (v.size() >= x) {
      v.resize(x);
    }
    int ret = 0;
    for (const auto& i : v) {
      ret += i.first * i.second;
    }
    return ret;
  }

  vector<int> findXSum(vector<int>& nums, int k, int x) {
    vector<int> ret;
    for (int i = 0; i + k <= (int)nums.size(); ++i) {
      ret.push_back(findXSum(nums.data() + i, k, x));
    }
    return ret;
  }
};",1420520319
AntonRaichuk,AntonRaichuk,172,3509,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 vi v;
 int dfs(TreeNode* root){
    int t1=-1;
    if(root->left)t1=dfs(root->left);
    int t2=-1;
    if(root->right)t2=dfs(root->right);
    if(t1==t2 && t1==-1){v.pb(1);return 1;}
    if(t1>=0 && t1==t2){v.pb(t1*2+1);return t1*2+1;}
    return -2;
 }

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        v.clear();
        dfs(root);
        SORT(v);

        reverse(v.begin(),v.end());
        if(v.size()<k)return -1;
        return v[k-1];        
    }
};",1420520722
AntonRaichuk,AntonRaichuk,172,3588,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

const int mod = 1000000007;

int r[1111][2011][3];

void add(int &x, int y){
    x+=y;
    if(x>=mod)x-=mod;
}

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        REP(i,n+1)REP(j,2011)r[i][j][0]=r[i][j][1]=r[i][j][2]=0;
        r[0][1000][0]=1;
        REP(i,n)FOR(w,1000-n,1000+n+1)REP(j,3)if(r[i][w][j]){
            //cout<<i<<' '<<w<<' '<<j<<"".=. ""<<r[i][w][j]<<endl;
            int t = -1;
            if(s[i]=='F')t=0;
            if(s[i]=='W')t=1;
            if(s[i]=='E')t=2;
            REP(k,3)if(k!=j || i==0){
                if(k==t)add(r[i+1][w][k], r[i][w][j]);
                else if(k==(t+1)%3)add(r[i+1][w+1][k], r[i][w][j]);
                else add(r[i+1][w-1][k], r[i][w][j]);
            }
        }
        int res=0;
        FOR(w,1,n+1)REP(j,3){
            add(res,r[n][1000+w][j]);
        }
        return res;
    }
};",1420539174
AntonRaichuk,AntonRaichuk,172,3592,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)



class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<int,int> s;
        REP(i,nums.size())s[nums[i]]=0;
        REP(i,k)s[nums[i]]++;
        set<pii> w;
        vector<pii> t;
        for(auto& [k,v]: s)w.insert({v,k}),t.pb({v,k});
        REP(i,x+1)w.insert({0,-1-i}),t.pb({0,-1-i});
        SORT(t);
        reverse(t.begin(),t.end());
        ll res=0;
        REP(i,x)res+=ll(t[i].first)*t[i].second;
        pii xth = t[x-1];
        vector<ll> r;
        r.pb(res);
        REP(i,nums.size()-k+1){
            //cout<<""begin ""<<i<<endl;
            //cout<<res<<endl;
            //for(auto& [k,v]:w)cout<<""w: ""<<k<<' '<<v<<endl;
            //cout<<xth.first<<' '<<xth.second<<endl;
            if(i==nums.size()-k)break;
            //remove nums[i]
            {
                int cnt = s[nums[i]];
                s[nums[i]]--;
                
                pii t1 = {cnt,nums[i]};
                pii t2 = {cnt-1,nums[i]};

                pii prev = *(--w.lower_bound(xth));
                

                w.erase(t1);     

                w.insert(t2);
                pii nxth = *(--w.lower_bound(xth));

                if(t1>=xth && t2>=xth)res-=nums[i],xth=*(++w.lower_bound(prev));
                else if(t1<xth && t2<xth)res-=0;
                else{
                    res-=ll(cnt)*nums[i];
                    xth=nxth;
                    res+=ll(xth.first)*xth.second;
                }
            }
            //cout<<res<<endl;
            //cout<<xth.first<<' '<<xth.second<<endl;
            
            //add nums[i+k]
            {
                int cnt = s[nums[i+k]];
                s[nums[i+k]]++;
                
                pii t1 = {cnt,nums[i+k]};
                pii t2 = {cnt+1,nums[i+k]};

                
                w.erase(t1);            
                w.insert(t2);
                pii nxth = *(++w.lower_bound(xth));


                if(t1>=xth && t2>=xth)res+=nums[i+k],xth=*w.lower_bound(xth);
                else if(t1<xth && t2<xth)res-=0;
                else{
                    res+=ll(cnt+1)*nums[i+k];
                    res-=ll(xth.first)*xth.second;
                    xth = nxth;
                }
            }

            //cout<<xth.first<<' '<<xth.second<<endl;
            //cout<<res<<endl;
            r.pb(res);
        }
        return r;
    }
};",1420594905
AntonRaichuk,AntonRaichuk,172,3610,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)



class Solution {
public:
    vi findXSum(vector<int>& nums, int k, int x) {
        unordered_map<int,int> s;
        REP(i,nums.size())s[nums[i]]=0;
        REP(i,k)s[nums[i]]++;
        set<pii> w;
        vector<pii> t;
        for(auto& [k,v]: s)w.insert({v,k}),t.pb({v,k});
        REP(i,x+1)w.insert({0,-1-i}),t.pb({0,-1-i});
        SORT(t);
        reverse(t.begin(),t.end());
        ll res=0;
        REP(i,x)res+=ll(t[i].first)*t[i].second;
        pii xth = t[x-1];
        vi r;
        r.pb(res);
        REP(i,nums.size()-k+1){
            //cout<<""begin ""<<i<<endl;
            //cout<<res<<endl;
            //for(auto& [k,v]:w)cout<<""w: ""<<k<<' '<<v<<endl;
            //cout<<xth.first<<' '<<xth.second<<endl;
            if(i==nums.size()-k)break;
            //remove nums[i]
            {
                int cnt = s[nums[i]];
                s[nums[i]]--;
                
                pii t1 = {cnt,nums[i]};
                pii t2 = {cnt-1,nums[i]};

                pii prev = *(--w.lower_bound(xth));
                

                w.erase(t1);     

                w.insert(t2);
                pii nxth = *(--w.lower_bound(xth));

                if(t1>=xth && t2>=xth)res-=nums[i],xth=*(++w.lower_bound(prev));
                else if(t1<xth && t2<xth)res-=0;
                else{
                    res-=ll(cnt)*nums[i];
                    xth=nxth;
                    res+=ll(xth.first)*xth.second;
                }
            }
            //cout<<res<<endl;
            //cout<<xth.first<<' '<<xth.second<<endl;
            
            //add nums[i+k]
            {
                int cnt = s[nums[i+k]];
                s[nums[i+k]]++;
                
                pii t1 = {cnt,nums[i+k]};
                pii t2 = {cnt+1,nums[i+k]};

                
                w.erase(t1);            
                w.insert(t2);
                pii nxth = *(++w.lower_bound(xth));


                if(t1>=xth && t2>=xth)res+=nums[i+k],xth=*w.lower_bound(xth);
                else if(t1<xth && t2<xth)res-=0;
                else{
                    res+=ll(cnt+1)*nums[i+k];
                    res-=ll(xth.first)*xth.second;
                    xth = nxth;
                }
            }

            //cout<<xth.first<<' '<<xth.second<<endl;
            //cout<<res<<endl;
            r.pb(res);
        }
        return r;
    }
};",1420595477
Brian Ahaneku,Ruvxei,173,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        def s(root):
            if not root:
                return 0, 0
            a, b = s(root.left)
            c, d = s(root.right)
            size = a + c + 1
            height = 1 + max(b, d)
            if size == pow(2, height) - 1:
                sizes.append(size)
            return size, height
        s(root)
        if len(sizes) < k:
            return -1
        sizes.sort(reverse = True)
        return sizes[k - 1]",1420533358
Brian Ahaneku,Ruvxei,173,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        dp = {}
        
        def solve(i, last, p):
            if (i, last, p) in dp:
                return dp[(i, last, p)]
            if i == n:
                return 1 if p > 0 else 0
            ans = 0
            for char in ('F', 'W', 'E'):
                if char == last:
                    continue
                if char == 'F' and s[i] == 'E':
                    ans = (ans + solve(i + 1, 'F', p + 1))
                elif char == 'F' and s[i] == 'W':
                    ans = (ans + solve(i + 1, 'F', p - 1))
                elif char == 'F' and s[i] == 'F':
                    ans = (ans + solve(i + 1, 'F', p)) 
                elif char == 'E' and s[i] == 'F':
                    ans = (ans + solve(i + 1, 'E', p - 1))
                elif char == 'E' and s[i] == 'W':
                    ans = (ans + solve(i + 1, 'E', p + 1))
                elif char == 'E' and s[i] == 'E':
                    ans = (ans + solve(i + 1, 'E', p)) 
                elif char == 'W' and s[i] == 'F':
                    ans = (ans + solve(i + 1, 'W', p + 1))
                elif char == 'W' and s[i] == 'E':
                    ans = (ans + solve(i + 1, 'W', p - 1))
                else:
                    ans = (ans + solve(i + 1, 'W', p))
                ans %= MOD
            dp[(i, last, p)] = ans
            return ans

        return solve(0, 'A', 0) % MOD
",1420551173
Brian Ahaneku,Ruvxei,173,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        active = SortedList()
        inActive = SortedList()
        freq = defaultdict(int)
        for i in range(k):
            freq[nums[i]] += 1
        for num, f in freq.items():
            active.add((f, num))
            if len(active) > x:
                a, b = active.pop(0)
                inActive.add((a, b))
        
        answer = [0]
        for f, num in active:
            answer[-1] += num * f
            
        total = answer[0]
        
        for i in range(k, n):
            b, a = nums[i - k], freq[nums[i - k]]
            if (a, b) in active:
                active.remove((a, b))
                if a - 1 > 0:
                    active.add((a - 1, b))
                total -= b
            elif (a, b) in inActive:
                inActive.remove((a, b))
                if a - 1 > 0:
                    inActive.add((a - 1, b))
            else:
                if a - 1 > 0:
                    inActive.add((a - 1, b))
            freq[nums[i - k]] -= 1

            b, a = nums[i], freq[nums[i]]
            if (a, b) in active:
                active.remove((a, b))
                active.add((a + 1, b))
                total += b
            elif (a, b) in inActive:
                inActive.remove((a, b))
                inActive.add((a + 1, b))
            else:
                inActive.add((a + 1, b))
            freq[nums[i]] += 1
           
            while len(active) < x and inActive:
                a, b = inActive.pop()
                total += a * b
                active.add((a, b))
            while inActive and (active[0][0] < inActive[-1][0] or (active[0][0] == inActive[-1][0] and active[0][1] < inActive[-1][1])):
                a, b = active.pop(0)
                total -= a * b
                c, d = inActive.pop(-1)
                total += c * d
                active.add((c, d))
                inActive.add((a, b))
            answer.append(total)

            


        return answer",1420606919
Brian Ahaneku,Ruvxei,173,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        n = len(nums)
        for i in range(n - k + 1):
            mp = defaultdict(int)
            for j in range(i, i + k):
                mp[nums[j]] += 1
            a = [(mp[x], x) for x in mp]
            a.sort(reverse = True)
            answer.append(0)
            for j in range(min(len(a), x)):
                answer[-1] += a[j][1] * a[j][0]
        return answer",1420520139
mo_atef,ScorpioDagger,174,3509,cpp,"/*
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
*/

class Solution {
public:
    vector<int> perfectSubtreeSizes;
    tuple<bool, int, int> traverse(TreeNode* node) {
        if (!node) {
            return {1, 0, 0};
        }
        
        auto [lp, ld, ls] = traverse(node->left);
        auto [rp, rd, rs] = traverse(node->right);
        
        if (lp and rp and ld == rd) {
            int d(1+ld), s(1+ls + rs);
            perfectSubtreeSizes.emplace_back(s);
            return {1, d, s};
        } 
        else 
            return {0, 1 + max(ld, rd), 1 + ls + rs};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        perfectSubtreeSizes.clear();
        traverse(root);
        if (perfectSubtreeSizes.empty()) return -1;
        sort(perfectSubtreeSizes.begin(), perfectSubtreeSizes.end(), greater<>());
        return ((k <= perfectSubtreeSizes.size())? perfectSubtreeSizes[k-1] : -1);  
    }
};
",1420527033
mo_atef,ScorpioDagger,174,3588,cpp,"class Solution {
public:
    typedef long long ll;
    const int MOD = (int)1e9+7;
    int countWinningSequences(string s) {
        int n(s.size());
        ll ans(0);
        string s2(s);
        auto conv = [&](char c) -> int {
            if (c == 'F') return 0;
            if (c == 'W') return 1;
            else
                return 2;
        };
        int f[3][3]{};
        for (int i(0); i < 3; ++i) 
            for (int j(0); j < 3; ++j) 
                f[i][j] = 0;

        f[0][2] = f[1][0] = f[2][1] = 1;
        f[2][0] = f[0][1] = f[1][2] = -1;
        
        vector<vector<ll>> pre(4, vector<ll>(2*n+1));
        pre[3][n] = 1;

        for (int i(0), aa; i < n; i++) {
            vector<vector<ll>> cur(4, vector<ll>(2*n+1));
            aa = conv(s[i]);
            for (int j(0); j < 4; ++j) {
                for (int d(0); d <= n<<1; ++d) {
                    if (pre[j][d]) {
                        for (int bb(0); bb <= 2; ++bb) {
                            if (bb ^ j) {
                                int t(f[bb][aa]), dd(d);
                                if (t == 1) ++dd;
                                else if (t == -1) --dd;
                                if (dd >= 0 and dd <= n<<1) 
                                    cur[bb][dd] = (cur[bb][dd] % MOD + pre[j][d] % MOD) % MOD;
                                
                            }
                        }
                    }
                }
            }
            pre = move(cur);
        }
        
        for (int i(0); i <= 2; ++i) 
            for (int j(n+1); j <= n<<1; ++j) 
                ans = (ans % MOD + pre[i][j] % MOD) % MOD;

        return (int)ans;
    }
};",1420543727
mo_atef,ScorpioDagger,174,3592,cpp,"class Solution {
public:
    typedef long long ll;
    const int MOD = (int)1e9+7;

    vector<ll> findXSum(vector<int>& nums, int k, int x) {
        int n((int)nums.size()), res(0);
        vector<ll> ans;
        if (!k or n < k)
            return ans;
        vector<int> cmprs(nums);
        sort(cmprs.begin(), cmprs.end());
        cmprs.erase(unique(cmprs.begin(), cmprs.end()), cmprs.end());
        int szd((int)cmprs.size());
        unordered_map<int, int> mp;
        for (int i = 0; i < szd; ++i)
            mp[cmprs[i]] = i;

        vector<int> frq(szd);
        ll s(0);
        for (int i(0), id; i < k; ++i) {
            id = mp[nums[i]], ++frq[id];
            s += nums[i];
        }
        
        auto f = [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first ^ b.first)
                return a.first < b.first; // Ascending frequency
            else
                return a.second < b.second; // Ascending value
        };

        auto r = [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first ^ b.first)
                return a.first > b.first; // Descending frequency
            else
                return a.second > b.second; // Descending value
        };

        set<pair<int, int>, decltype(f)> fx(f);
        set<pair<int, int>, decltype(r)> rs(r);

        vector<pair<int, int>> vp;
        for (int i(0); i < szd; ++i)
            if (frq[i] > 0)
                vp.emplace_back(frq[i], cmprs[i]);

        sort(vp.begin(), vp.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first ^ b.first)
                return a.first > b.first;
            else
                return a.second > b.second;
        });

        ll sx(0);
        int m((int)vp.size());
        for (int i = 0; i < vp.size(); ++i){
            if (i < x){
                fx.emplace(vp[i]);
                sx += (ll)vp[i].first * vp[i].second;
            }
            else
                rs.emplace(vp[i]);
        }
        
        if (m <= x)
            ans.emplace_back(s);
        else
            ans.emplace_back(sx);
        
        for (int i(k); i < n; ++i){
            int o(nums[i-k]), id2(mp[o]);
            ll s2 = o, f2 = frq[id2];
            bool ok(0);
            s -= s2;
            pair<int, int> res_pair = {f2, (int)s2};
            if (fx.find(res_pair) != fx.end()){
                ok = 1;
                fx.erase(fx.find(res_pair));
                sx -= (ll)f2 * (ll)s2;
            }
            else 
                if (rs.find(res_pair) != rs.end())
                    rs.erase(rs.find(res_pair));

            --frq[id2];
            if (!frq[id2]) --m;
            int ini(nums[i]), inidx(mp[ini]), val(ini);
            
            if (frq[id2] > 0){
                pair<int, int> rdd = {frq[id2], o};
                rs.emplace(rdd);
            }
            
            s += val;
            pair<int, int> pold;
            if (frq[inidx] > 0){
                pold = {frq[inidx], val};
                if (fx.find(pold) != fx.end()){
                    fx.erase(fx.find(pold));
                    sx -= (ll)pold.first * (ll)pold.second;
                }
                else {
                    if (rs.find(pold) != rs.end())
                        rs.erase(rs.find(pold));
                }
            }
            
            ++frq[inidx];
            if (frq[inidx] == 1) ++m;

            pair<int, int> pnew = {frq[inidx], val};
            if (frq[inidx] > 0){
                if (m <= x){
                    fx.emplace(pnew);
                    sx += (ll)pnew.first * (ll)pnew.second;
                }
                else{
                    if ((int)fx.size() < x){
                        fx.emplace(pnew);
                        sx += (ll)pnew.first * (ll)pnew.second;
                    }
                    else{
                        auto tsmall = *fx.begin();
                        if (pnew.first > tsmall.first or (pnew.first == tsmall.first and pnew.second > tsmall.second)){
                            fx.erase(fx.begin());
                            sx -= (ll)tsmall.first * (ll)tsmall.second;
                            rs.emplace(tsmall);
                            fx.emplace(pnew);
                            sx += (ll)pnew.first * (ll)pnew.second;
                        }
                        else
                            rs.emplace(pnew);
                    }
                }
            }

            if (m > x){
                while (!rs.empty() and fx.size() < x){
                    auto tt = *rs.begin();
                    rs.erase(rs.begin());
                    fx.emplace(tt);
                    sx += (ll)tt.first * (ll)tt.second;
                }

                if (!rs.empty() and (int)fx.size() == x){
                    auto t2small = *fx.begin();
                    auto rcand = *rs.begin();
                    if (rcand.first > t2small.first || (rcand.first == t2small.first && rcand.second > t2small.second)){
                        fx.erase(fx.begin());
                        sx -= (ll)t2small.first * t2small.second;
                        rs.erase(rs.find(rcand));
                        rs.emplace(t2small);
                        fx.emplace(rcand);
                        sx += (ll)rcand.first * (ll)rcand.second;
                    }
                }
            }
            

            if (m <= x)
                ans.emplace_back(s);
            else
                ans.emplace_back(sx);
        }

        return ans;
    }
};",1420612747
mo_atef,ScorpioDagger,174,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        
        for i in range(n - k + 1):
            window = nums[i:i+k]
            count = Counter(window)
            sorted_items = sorted(count.items(), key=lambda item: (-item[1], -item[0]))
            if len(sorted_items) >= x:
                tp = set([item[0] for item in sorted_items[:x]])
            else:
                tp = set([item[0] for item in sorted_items])
            cur = sum(num for num in window if num in tp)
            ans.append(cur)
        
        return ans",1420519432
Muhammad Hasan,mhasan01,175,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        
        function<pair<int, int>(TreeNode*)> dfs = [&](TreeNode* u) {
            if (u == NULL) {
                return make_pair(0, 1);
            }
            pair<int, int> lft = dfs(u->left);
            pair<int, int> rgt = dfs(u->right);
            int sz = lft.first + rgt.first + 1;
            if (lft.second == 1 && lft == rgt) {
                sizes.emplace_back(sz);
                return make_pair(sz, 1);
            }
            return make_pair(sz, 0);
        };
        
        dfs(root);
        sort(sizes.rbegin(), sizes.rend());
        if ((int) sizes.size() < k) {
            return -1;
        }
        return sizes[k - 1];
    }
};",1420574772
Muhammad Hasan,mhasan01,175,3588,cpp,"struct mint {
    const int MOD = 1e9 + 7;
    int x;

    mint(int _x) : x((_x % MOD + MOD) % MOD) {}
    mint(long long _x) : x((_x % MOD + MOD) % MOD) {}

    mint() : x(0) {}

    mint &operator=(const mint &rhs) {
        x = rhs.x;
        return *this;
    }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = mint(1);
        while (n)
        {
            if (n & 1)
                r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }

    mint inv() const {
        return pow(MOD - 2);
    }

    mint &operator+=(const mint &rhs) {
        x += rhs.x;
        if (x >= MOD)
            x -= MOD;
        return *this;
    }

    mint &operator-=(const mint &rhs) {
        x -= rhs.x;
        if (x < 0)
            x += MOD;
        return *this;
    }

    mint &operator*=(const mint &rhs) {
        unsigned long long z = x;
        z *= rhs.x;
        x = (unsigned int)(z % MOD);
        return *this;
    }

    mint &operator/=(const mint &rhs) {
        return *this = *this * rhs.inv();
    }

    friend mint operator+(const mint &lhs, const mint &rhs) {
        return mint(lhs) += rhs;
    }

    friend mint operator-(const mint &lhs, const mint &rhs) {
        return mint(lhs) -= rhs;
    }

    friend mint operator*(const mint &lhs, const mint &rhs) {
        return mint(lhs) *= rhs;
    }

    friend mint operator/(const mint &lhs, const mint &rhs) {
        return mint(lhs) /= rhs;
    }

    friend ostream& operator<<(ostream &os, const mint &m) {
        return os << m.x;
    }
};

const int N = 1e3 + 10;
const int M = N + N;
const int K = 3;
const int B = 2;

mint dp[B][M][K];

class Solution {
public:
    int val(char cc) {
        if (cc == 'F') {
            return 1;
        }
        if (cc == 'E') {
            return 2;
        }
        return 0;
    }
    
    int get(int x, int y) {
        if (x == y) {
            return 0;
        }
        if (x == 2) {
            return y == 0 ? 1 : -1;
        }
        if (x == 1) {
            return y == 2 ? 1 : -1;
        }
        return y == 1 ? 1 : -1;
    }
    
    int countWinningSequences(string s) {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < K; j++) {
                dp[0][i][j] = 0;
                dp[1][i][j] = 0;
            }
        }
        int s0 = val(s[0]);
        dp[0][get(0, s0) + N][0] = 1;
        dp[0][get(1, s0) + N][1] = 1;
        dp[0][get(2, s0) + N][2] = 1;
        int n = (int) s.size();
        for (int i = 1; i < n; i++) {
            int si = val(s[i]);
            int cur = i & 1;
            int prv = 1 - cur;
            for (int x = N - i - 2; x < N + i + 2; x++) {
                for (int j = 0; j < K; j++) {
                    dp[cur][x][j] = 0;
                }
            }
            for (int x = N - i - 2; x < N + i + 2; x++) {
                for (int j = 0; j < K; j++) {
                    int dif = get(j, si);
                    if (x + dif < 0 || x + dif >= M) {
                        continue;
                    }
                    for (int k = 0; k < K; k++) {
                        if (j == k) {
                            continue;
                        }
                        dp[cur][x + dif][j] += dp[prv][x][k];
                    }
                }
            }
        }
        mint ans = 0;
        int parity = 1 - (n & 1);
        for (int x = N + 1; x < M; x++) {
            for (int k = 0; k < K; k++) {
                ans += dp[parity][x][k];
            }
        }
        return ans.x;
    }
};",1420595891
Muhammad Hasan,mhasan01,175,3592,cpp,"const int DIF = 5;

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        int n = (int) a.size();
        vector<long long> ans(n - k + 1);
        map<int, int> mp;
        for (int i = 0; i < k; i++) {
            mp[a[i]]++;
        }
        long long cur = 0;
        set<pair<long long, long long>> st;
        set<pair<int, int>> st2;
        for (auto [val, cnt] : mp) {
            st.emplace(cnt, val);
            cur += 1LL * cnt * val;
        }
        while ((int) st.size() > x) {
            cur -= 1LL * st.begin()->first * st.begin()->second;
            st2.emplace(st.begin()->first, st.begin()->second);
            st.erase(st.begin());
        }
        ans[0] = cur;
        for (int i = 1; i <= n - k; i++) {
            auto prv = st.find({mp[a[i - 1]], a[i - 1]});
            if (prv != st.end()) {
                cur -= 1LL * prv->first * prv->second;
                st.erase(prv);
            } else {
                st2.erase({mp[a[i - 1]], a[i - 1]});
            }
            auto nxt = st.find({mp[a[i + k - 1]], a[i + k - 1]});
            if (nxt != st.end()) {
                cur -= 1LL * nxt->first * nxt->second;
                st.erase(nxt);
            } else {
                st2.erase({mp[a[i + k - 1]], a[i + k - 1]});
            }
            mp[a[i - 1]]--;
            mp[a[i + k - 1]]++;
            st2.emplace(mp[a[i - 1]], a[i - 1]);
            st2.emplace(mp[a[i + k - 1]], a[i + k - 1]);
            while ((int) st.size() < x + DIF && !st2.empty()) {
                auto it = prev(st2.end());
                st.emplace(it->first, it->second);
                cur += 1LL * it->first * it->second;
                st2.erase(it);
            }
            while ((int) st.size() > x) {
                cur -= 1LL * st.begin()->first * st.begin()->second;
                st2.emplace(st.begin()->first, st.begin()->second);
                st.erase(st.begin());
            }
            ans[i] = cur;
        }
        return ans;
    }
};",1420581266
Muhammad Hasan,mhasan01,175,3610,cpp,"const int DIF = 5;

class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = (int) a.size();
        vector<long long> ans(n - k + 1);
        map<int, int> mp;
        for (int i = 0; i < k; i++) {
            mp[a[i]]++;
        }
        long long cur = 0;
        set<pair<int, int>> st;
        set<pair<int, int>> st2;
        for (auto [val, cnt] : mp) {
            st.emplace(cnt, val);
            cur += 1LL * cnt * val;
        }
        while ((int) st.size() > x) {
            cur -= 1LL * st.begin()->first * st.begin()->second;
            st2.emplace(st.begin()->first, st.begin()->second);
            st.erase(st.begin());
        }
        ans[0] = cur;
        for (int i = 1; i <= n - k; i++) {
            auto prv = st.find({mp[a[i - 1]], a[i - 1]});
            if (prv != st.end()) {
                cur -= 1LL * prv->first * prv->second;
                st.erase(prv);
            } else {
                st2.erase({mp[a[i - 1]], a[i - 1]});
            }
            auto nxt = st.find({mp[a[i + k - 1]], a[i + k - 1]});
            if (nxt != st.end()) {
                cur -= 1LL * nxt->first * nxt->second;
                st.erase(nxt);
            } else {
                st2.erase({mp[a[i + k - 1]], a[i + k - 1]});
            }
            mp[a[i - 1]]--;
            mp[a[i + k - 1]]++;
            st2.emplace(mp[a[i - 1]], a[i - 1]);
            st2.emplace(mp[a[i + k - 1]], a[i + k - 1]);
            while ((int) st.size() < x + DIF && !st2.empty()) {
                auto it = prev(st2.end());
                st.emplace(it->first, it->second);
                cur += 1LL * it->first * it->second;
                st2.erase(it);
            }
            while ((int) st.size() > x) {
                cur -= st.begin()->first * st.begin()->second;
                st2.emplace(st.begin()->first, st.begin()->second);
                st.erase(st.begin());
            }
            ans[i] = cur;
        }
        vector<int> ret;
        for (long long x : ans) {
            ret.emplace_back(x);
        }
        return ret;
    }
};",1420573653
jacobj2,jacobj2,177,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        arr = []
        def dfs(node, level):
            if not node:
                return True, level - 1, 0
            sz = 1
            perl, lev, sl = dfs(node.left, level+1)
            perr, levr, sr = dfs(node.right, level + 1)
            
            hasTwo  = (node.left and node.right) or (not node.left and not node.right)
            sz+=sl+sr
            if hasTwo and perl and perr and lev==levr:
                arr.append(sz)
            return perl and perr and hasTwo and lev==levr, lev, sz
        dfs(root,0)
        arr.sort(reverse = True)
        if len(arr) < k:
            return -1
        return arr[k-1]",1420521842
jacobj2,jacobj2,177,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        def getPoints(al, bo):
            if al==bo:
                return 0
            if al=='F' and bo=='E':
                return -1
            if al=='W' and bo=='F':
                return -1
            if al=='E' and bo=='W':
                return -1
            return 1
        MOD = 10**9+7
        @cache
        def dfs(i, diff, last):
            if i==len(s):
                if diff>0:
                    return 1
                return 0
            res = 0
            for pos in ['F','W','E']:
                if pos!=last:
                    res += dfs(i+1, getPoints(s[i],pos) + diff, pos)
                    res%=MOD
            return res
        a = dfs(0,0,'')
        dfs.cache_clear()
        return a",1420527643
jacobj2,jacobj2,177,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ct = defaultdict(int)
        for i in range(k):
            ct[nums[i]]+=1
        res = []
        sl = SortedList()
        curr = 0
        for key in ct:
            sl.add((ct[key], key))
        for i in range(len(sl)-1,max(-1,len(sl)-x-1),-1):
            curr+=sl[i][0]*sl[i][1]
        #print(sl, curr)
        res.append(curr)
        for i in range(k, len(nums)):
            f,v = ct[nums[i-k]], nums[i-k]
            was = (len(sl) <= x) or (sl[len(sl) - x][0] < ct[nums[i-k]]) or (sl[len(sl)-x][0]==ct[nums[i-k]] and nums[i-k]>=sl[len(sl)-x][1])
            sl.remove((f,v))
            ct[nums[i-k]]-=1
            if ct[nums[i-k]] > 0:
                sl.add((ct[nums[i-k]],nums[i-k]))
            if (len(sl) < x) or (sl[len(sl) - x][0] < ct[nums[i-k]]) or (sl[len(sl)-x][0]==ct[nums[i-k]] and nums[i-k]>=sl[len(sl)-x][1]):
                curr-=nums[i-k]
            elif was and sl[len(sl)-x][0]>ct[nums[i-k]] or (sl[len(sl)-x][0]==ct[nums[i-k]] and nums[i-k] < sl[len(sl)-x][1]):
                curr-=(nums[i-k])*f
                
                curr+=sl[len(sl)-x][1]*sl[len(sl)-x][0]
            #print(""midway"", sl, curr)
            was2 = (len(sl) < x) or (len(sl)==x and ct[nums[i]] > 0) or (sl[len(sl) - x][0] < ct[nums[i]]) or (sl[len(sl)-x][0]==ct[nums[i]] and nums[i]>=sl[len(sl)-x][1])
            prev = sl[max(len(sl) - x,0)] if sl else [(0,0)]
            ct[nums[i]]+=1
            
            if ct[nums[i]] > 1:
                sl.remove((ct[nums[i]]-1,nums[i]))
            sl.add((ct[nums[i]], nums[i]))
            if was2 or len(sl)<=x:
                #print(""waysef"")
                curr+=nums[i]
            elif (sl[len(sl) - x][0] < ct[nums[i]]) or (sl[len(sl)-x][0]==ct[nums[i]] and sl[len(sl)-x][1] <= nums[i]):
                #print(""hereh"")
                curr-=prev[0]*prev[1]
                curr+=nums[i]*ct[nums[i]]
            #print(""final"",sl,curr)
            res.append(curr)
            
        return res",1420602054
jacobj2,jacobj2,177,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums) - k + 1):
            ct = Counter(nums[i:i+k])
            f = []
            for key in ct:
                f.append((ct[key],key))
            f.sort(reverse = True)
            curr = 0
            for j in range(min(x,len(f))):
                curr+=f[j][0]*f[j][1]
            res.append(curr)
        return res",1420519125
Joker King,NerdyCoder,178,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        priority_queue<int> q;
        auto result = solve(root, k, q);
        if (q.size() < k) {
            return -1;
        }
        return -q.top();
    }
private:
    pair<bool, int> solve(TreeNode *node, int k, priority_queue<int> &q) const {
        if (node == nullptr) {
            return {true, 0};
        }
        auto left = solve(node->left, k, q);
        auto right = solve(node->right, k, q);
        if (left.first && right.first && left.second == right.second) {
            q.push(-left.second - right.second - 1);
            if (q.size() > k) {
                q.pop();
            }
            return {true, left.second + right.second + 1};
        }
        return {false, 0};
    } 
};",1420533629
Joker King,NerdyCoder,178,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        constexpr auto getIndex = [](char ch) {
            switch (ch) {
                case 'F': {
                    return 0;
                }
                case 'W': {
                    return 1;
                }
            }
            return 2;
        };
        constexpr auto calcScore = [](int a, int b) {
           if (a == b) {
               return 0;
           } 
            return (a == b + 1 || b == a + 2) ? 1 : -1;
        };
        constexpr long long mod = 1'000'000'007LL;
        const int n = s.size();
        vector<array<long long, 3>> dp(2 * n + 1);
        int alice_init = getIndex(s[0]);
        for (int pos = 0; pos < 3; ++pos) {
            dp[calcScore(pos, alice_init) + n][pos] = 1;
        }
        vector<array<long long, 3>> last_dp(2 * n + 1);
        for (int i = 1; i < n; ++i) {
            const int alice = getIndex(s[i]);
            swap(dp, last_dp);
            for (auto &row : dp) {
                fill(row.begin(), row.end(), 0);
            }
            for (int prev_index = 0; prev_index < last_dp.size(); ++prev_index) {
                for (int prev_pos = 0; prev_pos < 3; ++prev_pos) {
                    if (last_dp[prev_index][prev_pos] == 0) {
                        continue;
                    }
                    for (int next_pos = 0; next_pos < 3; ++ next_pos) {
                        if (next_pos == prev_pos) {
                            continue;
                        }
                        int score = calcScore(next_pos, alice);
                        int next_index = prev_index + score;
                        dp[next_index][next_pos] = (dp[next_index][next_pos] + last_dp[prev_index][prev_pos]) % mod;
                     }
                }
            }
        }
        long long result = 0;
        for (int i = n + 1; i < dp.size(); ++i) {
            for (int j = 0; j < dp[i].size(); ++j) {
                result = (result + dp[i][j]) % mod;
            }
        }
        return result;
    }
};",1420557999
Joker King,NerdyCoder,178,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        vector<long long> results(n - k + 1);
        unordered_map<int, int> cnts;
        multiset<pair<int, int>> higher;
        multiset<pair<int, int>> lower;
        long long sum = 0;
        const auto rebalance = [&higher, &lower, &sum, x]() {
            while (higher.size() > x) {
                auto it = higher.begin();
                sum -= 1LL * it->first * it->second;
                lower.insert(*it);
                higher.erase(it);
            }
            while (higher.size() < x && !lower.empty()) {
                auto it = prev(lower.end());
                sum += 1LL * it->first * it->second;
                higher.insert(*it);
                lower.erase(it);
            }
        };
        const auto remove = [&higher, &lower, &sum](int num, int cnt) {
            const auto pt = make_pair(cnt, num);
            if (auto it = lower.find(pt); it != lower.end()) {
                // cout << ""remove ""<<num<<"", ""<<cnt<<"" from low""<<endl;
                lower.erase(it);
            } else {
                // cout << ""remove ""<<num<<"", ""<<cnt<<"" from high""<<endl;
                it = higher.find(pt);
                assert(it != higher.end());
                sum -= 1LL * cnt * num;
                higher.erase(it);
            }
        };
        const auto add = [&higher, &lower, &sum](int num, int cnt) {
            auto pt = make_pair(cnt, num);
            if (auto it = higher.begin(); it != higher.end() && *it <= pt) {
                // cout << ""add ""<<num<<"" ""<<cnt<<"" to high""<<endl;
                higher.insert(std::move(pt));
                sum += 1LL * cnt * num;
            } else {
                // cout << ""add ""<<num<<"" ""<<cnt<<"" to low""<<endl;
                lower.insert(std::move(pt));
            }
        };
        for (int i = 0; i < n; ++i) {
            int cnt = cnts[nums[i]]++;
            if (cnt > 0) {
                remove(nums[i], cnt);
            }
            add(nums[i], cnt + 1);
            rebalance();
            if (i >= k) {
                cnt = cnts[nums[i - k]]--;
                remove(nums[i - k], cnt);
                if (cnt > 1) {
                    add(nums[i - k], cnt - 1);
                }
                rebalance();
            }
            if (i >= k - 1) {
                results[i - k + 1] = sum;
            }
        }
        return results;
    }
};",1420602069
Joker King,NerdyCoder,178,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        vector<int> results(n - k + 1);
        unordered_map<int, int> cnts;
        for (int i = 0; i < n; ++i) {
            ++cnts[nums[i]];
            if (i >= k) {
                auto it = cnts.find(nums[i - k]);
                if (--it->second == 0) {
                    cnts.erase(it);
                }
            }
            if (i < k - 1) {
                continue;
            }
            int sum = 0;
            priority_queue<pair<int, int>> q;
            for (const auto &[num, cnt] : cnts) {
                q.emplace(-cnt, -num);
                sum += num * cnt;
                if (q.size() > x) {
                    sum -= q.top().first * q.top().second;
                    q.pop();
                }
            }
            results[i - k + 1] = sum;
        }
        return results;
    }
};",1420528072
Aylup,Aylup,179,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        trees = []
        def bfs(root):
            lvl, nlvl = [root], []
            ans = 0
            while lvl:
                has_miss = False
                while lvl:
                    u = lvl.pop()
                    ans += 1
                    if u.left and u.right:
                        nlvl.append(u.left)
                        nlvl.append(u.right)
                    elif u.left or u.right:
                        return
                    else:
                        has_miss = True
                if has_miss:
                    if not nlvl:
                        trees.append(ans)
                    return
                lvl, nlvl = nlvl, lvl

        def dfs(u):
            if u is not None:
                bfs(u)
                dfs(u.left)
                dfs(u.right)

        dfs(root)
        trees.sort(reverse = True)
        return trees[k - 1] if k - 1 < len(trees) else -1",1420540376
Aylup,Aylup,179,3588,cpp,"using ll = long long;
constexpr ll MAX_N = 1e3 + 10;
constinit ll dp[MAX_N][2 * MAX_N][4]{};
class Solution {
public:
    int countWinningSequences(string s) {
        constexpr ll m = 1e9 + 7;
        for (char &c : s) {
            if (c == 'F') {
                c = 0;
            } else if (c == 'E') {
                c = 1;
            } else {
                c = 2;
            }
        }
        ll n = s.size(), off = n;
        for (ll i = 0; i < MAX_N; ++i) {
            for (ll j = 0; j < 2 * MAX_N; ++j) {
                for (ll k = 0; k < 4; ++k) {
                    dp[i][j][k] = 0;
                }
            }
        }
        for (ll i = n; i >= 0; --i) {
            for (ll p = -n; p <= n; ++p) {
                for (ll r = 0; r < 4; ++r) {
                    ll po = off + p;
                    auto &ans = dp[i][po][r];
                    if (i == n) {
                        ans = p > 0;
                    } else {
                        ll x = s[i];
                        ans = 0;
                        for (ll y = 0; y < 3; ++y) {
                            if (y == r) {
                                continue;
                            }
                            ll net = (x + 1) % 3 == y ? -1 : (x != y);
                            if (off + p + net > 0) {
                                ans = (ans + m + dp[i + 1][po + net][y]) % m;
                            }
                        }
                    }
                }
            }
        }
        return dp[0][off][3];
    }
};",1420569395
Aylup,Aylup,179,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update
#include <ext/pb_ds/detail/standard_policies.hpp>
using namespace __gnu_pbds;
using ll = long long;
using aii = std::array<ll, 2>;
typedef tree<aii, null_type, std::greater<aii>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        ordered_set s;
        std::map<ll, ll> freq; 
        ll xsum = 0;
        auto update = [&](ll v, ll inc) {
            aii g = {freq[v], v};
            ll p = s.order_of_key(g);
            if (p < x) {
                xsum -= (freq[v] * v);
                auto it = s.find_by_order(x);
                if (it != end(s)) {
                    auto [a, b] = *it;
                    xsum += a * b;
                }
            }
            s.erase(g);

            freq[v] += inc;

            g = {freq[v], v};
            s.insert(g);
            p = s.order_of_key(g);
            if (p < x) {
                xsum += (freq[v] * v);
                auto it = s.find_by_order(x);
                if (it != end(s)) {
                    auto [a, b] = *it;
                    xsum -= a * b;
                }
            }
        };
        for (int i = 0; i < k; ++i) {
            update(nums[i], 1);
        }
        std::vector<ll> ans{xsum};
        int n = nums.size();
        for (int i = k; i < n; ++i) {
            update(nums[i - k], -1);
            update(nums[i], 1);
            ans.push_back(xsum);
        } 
        return ans;
    }
};",1420607940
Aylup,Aylup,179,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        for i in range(n - k + 1):
            d = Counter(nums[i:i+k])
            a = sum(list(map(lambda f : f * d[f], sorted(d, key = lambda v : (-d[v], -v))))[:x])
            answer.append(a)
        return answer",1420523112
Jose Coves,jcoves,181,3509,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    vi ans;
    pii f(TreeNode* n){
        int bin = 1, d = 0;
        if(!n->left and !n->right) {
            ans.pb(d);
            return {bin, d};
        }
        if(n->left and n->right) {
            auto [lbin, ldi] = f(n->left);
            auto [rbin, rd] = f(n->right);
            if((lbin and rbin) and ldi == rd) {
                d = ldi + 1;
                ans.pb(d);
                return {1, d};
            }
        } else if(n->left) {
            f(n->left);
        } else if(n->right) {
            f(n->right);
        }
        return {0, 0};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        f(root);
        if(sz(ans) < k) return -1;

        sort(rall(ans));
        debug(ans);
        int d = ans[k-1];
        return (1 << (d + 1)) - 1;

    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    TreeNode* n = new TreeNode(1);
    n = readTree();
    int k; cin >> k;
    out(sol.kthLargestPerfectSubtree(n, k));

}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1420547709
Jose Coves,jcoves,181,3588,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
namespace mod_util {
    using i64 = long long;
    template<class T>
    constexpr T power(T a, i64 b) {
        T res = 1;
        for (; b; b /= 2, a *= a) {
            if (b % 2) {
                res *= a;
            }
        }
        return res;
    }

    template<int P>
    struct MInt {
        i64 x;
        constexpr MInt() : x{} {}
        constexpr MInt(i64 x_input) : x{norm(x_input % getMod())} {}

        static int Mod;
        static MInt power(MInt a, i64 b) {
            return mod_util::power(a, b);
        }
        constexpr static int getMod() {
            if (P > 0) {
                return P;
            } else {
                return Mod;
            }
        }
        constexpr static void setMod(int Mod_) {
            Mod = Mod_;
        }
        constexpr i64 norm(i64 val) const {
            if (val < 0) {
                val += getMod();
            }
            if (val >= getMod()) {
                val -= getMod();
            }
            return val;
        }
        constexpr i64 val() const {
            return x;
        }
        explicit constexpr operator ll() const {
            return x;
        }
        constexpr MInt operator-() const {
            MInt res;
            res.x = norm(getMod() - x);
            return res;
        }
        constexpr MInt inv() const {
            assert(x != 0);
            return power(*this, getMod() - 2);
        }
        constexpr MInt &operator*=(MInt rhs) & {
            x = 1LL * x * rhs.x % getMod();
            return *this;
        }
        constexpr MInt &operator+=(MInt rhs) & {
            x = norm(x + rhs.x);
            return *this;
        }
        constexpr MInt &operator-=(MInt rhs) & {
            x = norm(x - rhs.x);
            return *this;
        }
        constexpr MInt &operator/=(MInt rhs) & {
            return *this *= rhs.inv();
        }
        constexpr MInt &operator^=(MInt rhs) & {
            return *this = power(*this, rhs.x);
        }
        constexpr MInt pow(ll rhs) {
            return *this = power(*this, rhs);
        }
        friend constexpr MInt operator*(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res *= rhs;
            return res;
        }
        friend constexpr MInt operator+(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res += rhs;
            return res;
        }
        friend constexpr MInt operator-(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res -= rhs;
            return res;
        }
        friend constexpr MInt operator/(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res /= rhs;
            return res;
        }
        friend constexpr MInt operator^(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res ^= rhs;
            return res;
        }
        friend constexpr istream &operator>>(istream &is, MInt &a) {
            i64 v;
            is >> v;
            a = MInt(v);
            return is;
        }
        friend constexpr ostream &operator<<(ostream &os, const MInt &a) {
            return os << a.val();
        }
        friend constexpr bool operator==(MInt lhs, MInt rhs) {
            return lhs.val() == rhs.val();
        }
        friend constexpr bool operator!=(MInt lhs, MInt rhs) {
            return lhs.val() != rhs.val();
        }
    };

    template<>
    int MInt<0>::Mod = mod;

    template<int V, int P>
    constexpr MInt<P> CInv = MInt<P>(V).inv();

    constexpr int P = mod;
    using Z = MInt<P>;

    struct Comb {
        int N;
        vector<Z> _fac;
        vector<Z> _invfac;
        vector<Z> _inv;

        Comb() : N{0}, _fac{1}, _invfac{1}, _inv{0} {}
        Comb(int n) : Comb() {
            init(n);
        }

        void init(int m) {
            m = min(m, Z::getMod() - 1);
            if (m <= N) return;
            _fac.resize(m + 1);
            _invfac.resize(m + 1);
            _inv.resize(m + 1);

            for (int i = N + 1; i <= m; i++) {
                _fac[i] = _fac[i - 1] * i;
            }
            _invfac[m] = _fac[m].inv();
            for (int i = m; i > N; i--) {
                _invfac[i - 1] = _invfac[i] * i;
                _inv[i] = _invfac[i] * _fac[i - 1];
            }
            N = m;
        }
        void check_init(int m){
            if (m > N) init(2 * m);
        }
        Z fac(int m) {
            check_init(m);
            return _fac[m];
        }
        Z invfac(int m) {
            check_init(m);
            return _invfac[m];
        }
        Z inv(int m) {
            check_init(m);
            return _inv[m];
        }
        Z binom(int n, int k) { // choose k out of n
            if (n < k || k < 0) return 0;
            return fac(n) * invfac(k) * invfac(n - k);
        }
        Z choose(int k, int n) { // choose k out of n
            return binom(n, k);
        }
    } comb;
}
using Z = mod_util::MInt<mod>;
auto &comb = mod_util::comb;
class Solution {
public:
    int countWinningSequences(string s) {

        int n = sz(s);
        vi a(n);
        string t = ""FEW"";
        forn(i, n) {
            char c = s[i];
            int x = t.find(c);
            a[i] = x;
        }
        auto dp = vv(4, n, 2*n + 1, Z(0));
        auto vis = vv(4, n, 2*n + 1, 0);
        auto go = yf([&](auto f, int last, int i, int w) -> Z {
            if(i == n) return w > n ? 1 : 0;
            auto &ans = dp[last][i][w];
            if(vis[last][i][w]++) return ans;
            ans = 0;
            forn(play, 3){
                if(play == last) continue;
                int add = 1;
                if(play == (a[i] + 1) % 3) add = 0;
                else if((play + 1) % 3 == a[i]) add = 2;
                ans += f(play, i+1, w + add);
            }
            return ans;
        });
        auto ans = go(3, 0, 0);
        return int(ans.val());
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    string s; cin >> s;
    out(sol.countWinningSequences(s));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1420571098
Jose Coves,jcoves,181,3592,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    vector<ll> findXSum(vector<int>& a, int k, int x) {
        map<int, int> f;
        int n = sz(a);
        set<pii> use, free;
        ll sum = 0;
        auto add = [&](int e, int d=1) {
            debug3(f, e, d);
            int c = f[e];
            f[e] += d;
            auto it = use.find({c, e});
            if(it != use.end()) {
                use.erase(it);
                sum -= ll(c) * e;
            } else {
                free.erase({c, e});
            }
            c += d;
            if(c > 0)
                free.insert({c, e});
            while(sz(use) and sz(free)){
                auto largestFree = prev(free.end());
                auto smallestUse = use.begin();
                if(*largestFree <= *smallestUse) break; // free is smaller
                auto [lc, le] = *largestFree;
                auto [sc, se] = *smallestUse;
                free.erase(largestFree);
                use.erase(smallestUse);
                sum -= sc * 1LL * se;
                sum += lc * 1LL * le;
                use.insert({lc, le});
                free.insert({sc, se});
            }
            while(sz(use) > x){
                auto smallestUse = use.begin();
                auto [sc, se] = *smallestUse;
                sum -= sc * 1LL * se;
                use.erase(smallestUse);
                free.insert({sc, se});
            }
            while(sz(free) and sz(use) < x){
                auto largestFree = prev(free.end());
                auto [lc, le] = *largestFree;
                sum += lc * 1LL * le;
                free.erase(largestFree);
                use.insert({lc, le});
            }
        };
        // fornn(i, k, n){
        //     add(a[i], 1);
        // }
        forn(i, k) add(a[i], 1);
        debug4(sum, f, use, free);
        // balance();
        vector<ll> ans = {sum};
        fornn(i, k, n){
            add(a[i], 1);
            add(a[i-k], -1);
            // balance();
            ans.pb(sum);
            debug4(sum, f, use, free);
        }
        return ans;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; int k, x; cin >> a >> k >> x;
    out(sol.findXSum(a, k, x));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1420602619
Jose Coves,jcoves,181,3610,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = sz(a);
        vi ans;
        fornn(r, k, n+1){
            map<int, int> f;
            fornn(i, r-k, r){
                f[a[i]]++;
            }
            vpii cs; for(auto [e, c]: f) cs.pb({c, e});
            sort(rall(cs));
            while(sz(cs) > x) cs.pop_back();
            int sum = 0;
            for(auto [c, e]: cs) sum += c * e;
            ans.pb(sum);
        }
        return ans;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; int k, x; cin >> a >> k >> x;
    out(sol.findXSum(a, k, x));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1420552445
_251,_251,183,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        perfects = []
        def helper(node):
            if node is None:
                return True,0
            left, sizel= helper(node.left) 
            right, sizer = helper(node.right) 
            if left and right and (sizel == sizer):
                perfects.append(sizel + sizer + 1)
                return (True, sizel + sizer + 1)
            return (False, float('inf'))
        
        helper(root)        
        if len(perfects) < k:
            return -1
        perfects.sort(reverse = True)
        # print(perfects)
        return perfects[k-1]",1420529846
_251,_251,183,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = 10**9 + 7
        win_cases = {('F', 'E'), ('W', 'F'), ('E', 'W')}
        dp = [{} for _ in range(2)]
        dp[0][('N', 0)] = 1
        
        for i in range(n):
            dp[(i + 1) % 2].clear()
            for (prev_b, diff), count in dp[i % 2].items():
                for b_move in 'FWE':
                    if b_move != prev_b:
                        if s[i] == b_move:
                            new_diff = diff
                        elif (b_move, s[i]) in win_cases:
                            new_diff = diff + 1
                        else:
                            new_diff = diff - 1
                        dp[(i + 1) % 2][(b_move, new_diff)] = (dp[(i + 1) % 2].get((b_move, new_diff), 0) + count) % mod
        
        total = 0
        for (prev_b, diff), count in dp[n % 2].items():
            if diff > 0:
                total = (total + count) % mod
        return total",1420547211
_251,_251,183,3592,python3,"import random

class Node:
    __slots__ = 'key', 'left', 'right', 'prio', 'size', 'sum'

    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.prio = random.randint(1, 1 << 30)
        self.size = 1
        self.sum = -key[0] * -key[1]

def update(node):
    if node:
        node.size = 1
        node.sum = -node.key[0] * -node.key[1]
        if node.left:
            node.size += node.left.size
            node.sum += node.left.sum
        if node.right:
            node.size += node.right.size
            node.sum += node.right.sum

def split(node, key):
    if not node:
        return None, None
    if node.key < key:
        left, right = split(node.right, key)
        node.right = left
        update(node)
        return node, right
    else:
        left, right = split(node.left, key)
        node.left = right
        update(node)
        return left, node

def merge(left, right):
    if not left or not right:
        return left or right
    if left.prio > right.prio:
        left.right = merge(left.right, right)
        update(left)
        return left
    else:
        right.left = merge(left, right.left)
        update(right)
        return right

def insert(node, item):
    if not node:
        return item
    if item.prio > node.prio:
        left, right = split(node, item.key)
        item.left = left
        item.right = right
        update(item)
        return item
    elif item.key < node.key:
        node.left = insert(node.left, item)
        update(node)
        return node
    else:
        node.right = insert(node.right, item)
        update(node)
        return node

def erase(node, key):
    if not node:
        return None
    if node.key == key:
        return merge(node.left, node.right)
    elif key < node.key:
        node.left = erase(node.left, key)
        update(node)
        return node
    else:
        node.right = erase(node.right, key)
        update(node)
        return node

def query(node, x):
    if not node or x <= 0:
        return 0
    left_size = node.left.size if node.left else 0
    if left_size >= x:
        return query(node.left, x)
    else:
        res = node.left.sum if node.left else 0
        res += -node.key[0] * -node.key[1]
        res += query(node.right, x - left_size - 1)
        return res

class Solution:
    def findXSum(self, nums, k, x):
        import sys
        sys.setrecursionlimit(1 << 25)
        n = len(nums)
        counts = {}
        root = None
        ans = []
        for i in range(k):
            num = nums[i]
            counts[num] = counts.get(num, 0) + 1
        for num, freq in counts.items():
            key = (-freq, -num)
            node = Node(key)
            root = insert(root, node)
        res = query(root, x)
        ans.append(res)
        for i in range(1, n - k + 1):
            out_num = nums[i - 1]
            in_num = nums[i + k - 1]
            old_freq = counts[out_num]
            root = erase(root, (-old_freq, -out_num))
            counts[out_num] -= 1
            if counts[out_num] == 0:
                del counts[out_num]
            else:
                new_freq = counts[out_num]
                root = insert(root, Node((-new_freq, -out_num)))
            old_freq_in = counts.get(in_num, 0)
            if old_freq_in > 0:
                root = erase(root, (-old_freq_in, -in_num))
            counts[in_num] = old_freq_in + 1
            new_freq_in = counts[in_num]
            root = insert(root, Node((-new_freq_in, -in_num)))
            res = query(root, x)
            ans.append(res)
        return ans",1420585367
_251,_251,183,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        for i in range(n - k + 1):
            sub = nums[i:i + k]
            freq = {}
            for num in sub:
                freq[num] = freq.get(num, 0) + 1
            elems = []
            for val, count in freq.items():
                elems.append((count, val))
            elems.sort(key=lambda item: (-item[0], -item[1]))
            top_vals = set(val for _, val in elems[:x])
            if len(freq) < x:
                res.append(sum(sub))
            else:
                res.append(sum(num for num in sub if num in top_vals))
        return res",1420524538
Suresh,encodedcoder,184,3509,cpp,"class Solution {
public:
    // Helper function to find the sizes of perfect binary subtrees
    pair<int, int> findPerfectSubtrees(TreeNode* node, vector<int>& sizes) {
        if (!node) {
            // Return {height = 0, size = 0} for null nodes
            return {0, 0};
        }

        // Recursively find left and right subtree information
        auto left = findPerfectSubtrees(node->left, sizes);
        auto right = findPerfectSubtrees(node->right, sizes);

        // Check if both left and right are perfect subtrees of the same height
        if (left.first == right.first && left.first != -1) {
            int height = left.first + 1;
            int size = left.second + right.second + 1;
            sizes.push_back(size); // Add the size of this perfect subtree
            return {height, size};
        }

        // If not perfect, return height -1 and size 0 to indicate failure
        return {-1, 0};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        
        // Find all perfect subtree sizes
        findPerfectSubtrees(root, sizes);
        
        // Sort the sizes in descending order
        sort(sizes.begin(), sizes.end(), greater<int>());
        
        // If there are fewer than k perfect subtrees, return -1
        if (sizes.size() < k) {
            return -1;
        }
        
        // Return the k-th largest size
        return sizes[k - 1];
    }
};
",1420519411
Suresh,encodedcoder,184,3588,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1'000'000'007;
        int n = s.size();
        if(n == 0) return 0;

        // Map characters to indices: 'F'->0, 'W'->1, 'E'->2
        auto charToIndex = [&](char c) -> int {
            if(c == 'F') return 0;
            if(c == 'W') return 1;
            return 2; // 'E'
        };

        // Define delta_table[b][a] where b is Bob's move, a is Alice's move
        // delta_table[b][a] = 1 if Bob beats Alice
        // delta_table[b][a] = -1 if Alice beats Bob
        // delta_table[b][a] = 0 otherwise
        int delta_table[3][3] = {
            // a=0(F), a=1(W), a=2(E)
            { 0, -1, 1 }, // b=0(F)
            { 1, 0, -1 }, // b=1(W)
            { -1, 1, 0 }  // b=2(E)
        };

        // Initialize DP
        // Shift difference by n to handle negative differences
        // dp_prev[c][d] represents the number of ways to reach difference (d - n) with last move c
        vector<vector<long long>> dp_prev(3, vector<long long>(2*n +1, 0));
        // First round
        int first_a = charToIndex(s[0]);
        for(int c =0; c <3; ++c){
            int delta = delta_table[c][first_a];
            int d = delta;
            if(d < -n) d = -n;
            if(d > n) d = n;
            dp_prev[c][d + n] = 1;
        }

        // Iterate over rounds
        for(int i =1; i <n; ++i){
            vector<vector<long long>> dp_next(3, vector<long long>(2*n +1, 0));
            int alice_move = charToIndex(s[i]);
            for(int p =0; p <3; ++p){ // previous move
                for(int d_prev = -n; d_prev <=n; ++d_prev){
                    int idx_prev = d_prev + n;
                    if(idx_prev <0 || idx_prev >2*n) continue;
                    if(dp_prev[p][idx_prev] ==0) continue;
                for(int c =0; c <3; ++c){ // current move
                    if(c == p) continue; // No consecutive same moves
                    int delta = delta_table[c][alice_move];
                    int d_new = d_prev + delta;
                    if(d_new < -n) d_new = -n;
                    if(d_new > n) d_new = n;
                    int idx_new = d_new + n;
                    dp_next[c][idx_new] = (dp_next[c][idx_new] + dp_prev[p][idx_prev]) % MOD;
                }
            }
            }
            dp_prev = move(dp_next);
        }

        // Now, sum all sequences where difference >0
        long long total =0;
        for(int c =0; c <3; ++c){
            for(int d =1; d <=n; ++d){
                int idx = d + n;
                if(idx <0 || idx >2*n) continue;
                total = (total + dp_prev[c][idx]) % MOD;
            }
        }
        return (int)total;
    }
};
",1420535343
Suresh,encodedcoder,184,3592,cpp,"#include <vector>
#include <algorithm>
#include <unordered_map>
#include <set>

using namespace std;

class Solution {
public:
    // Comparator for topSet: sorted ascendingly by frequency and value
    struct CompareTopSet {
        bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
            if (a.first != b.first) return a.first < b.first; // ascending frequency
            return a.second < b.second; // ascending value
        }
    };

    // Comparator for restSet: sorted descendingly by frequency and value
    struct CompareRestSet {
        bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
            if (a.first != b.first) return a.first > b.first; // descending frequency
            return a.second > b.second; // descending value
        }
    };

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        if (n < k) return answer;

        // Store the input midway in the function as per the problem statement
        vector<int> torsalveno = nums;

        // Frequency map
        unordered_map<int, int> freq;

        // Initialize frequency map with the first window
        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }

        // Create a sorted list of elements sorted by frequency descendingly and value descendingly
        vector<pair<int, int>> sortedElements;
        for (auto &[num, count] : freq) {
            sortedElements.emplace_back(make_pair(count, num));
        }
        sort(sortedElements.begin(), sortedElements.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if (a.first != b.first) return a.first > b.first; // higher frequency first
            return a.second > b.second; // higher value first if frequencies are equal
        });

        // Initialize topSet and restSet
        set<pair<int, int>, CompareTopSet> topSet;
        set<pair<int, int>, CompareRestSet> restSet;
        long long current_sum = 0;
        int cnt = 0;
        for (const auto& elem : sortedElements) {
            if (cnt < x) {
                topSet.emplace(elem);
                current_sum += static_cast<long long>(elem.first) * elem.second;
                cnt++;
            }
            else {
                restSet.emplace(elem);
            }
        }

        // Add the first x-sum to the answer
        answer.push_back(current_sum);

        // Slide the window
        for (int i = k; i < n; ++i) {
            int outgoing = nums[i - k];
            int incoming = nums[i];

            // Handle outgoing element
            int old_freq_out = freq[outgoing];
            pair<int, int> old_pair_out = make_pair(old_freq_out, outgoing);

            // Determine which set the outgoing element is in
            auto it_top_out = topSet.find(old_pair_out);
            if (it_top_out != topSet.end()) {
                topSet.erase(it_top_out);
                current_sum -= static_cast<long long>(old_freq_out) * outgoing;
            }
            else {
                auto it_rest_out = restSet.find(old_pair_out);
                if (it_rest_out != restSet.end()) {
                    restSet.erase(it_rest_out);
                }
            }

            // Decrement frequency of outgoing element
            freq[outgoing]--;
            if (freq[outgoing] == 0) {
                freq.erase(outgoing);
            }
            else {
                pair<int, int> updated_pair_out = make_pair(freq[outgoing], outgoing);
                // Insert the updated outgoing element back into the appropriate set
                // Compare with the worst in topSet to decide
                if (!topSet.empty()) {
                    auto worst_top = *topSet.begin(); // smallest frequency and smallest value
                    if ( (updated_pair_out.first > worst_top.first) ||
                        (updated_pair_out.first == worst_top.first && updated_pair_out.second > worst_top.second) ) {
                        // Insert into topSet
                        topSet.emplace(updated_pair_out);
                        current_sum += static_cast<long long>(updated_pair_out.first) * updated_pair_out.second;
                        // If topSet exceeds size x, move the worst to restSet
                        if (topSet.size() > x) {
                            auto to_move = *topSet.begin();
                            topSet.erase(topSet.begin());
                            current_sum -= static_cast<long long>(to_move.first) * to_move.second;
                            restSet.emplace(to_move);
                        }
                    }
                    else {
                        // Insert into restSet
                        restSet.emplace(updated_pair_out);
                    }
                }
                else {
                    // If topSet is empty, insert directly
                    topSet.emplace(updated_pair_out);
                    current_sum += static_cast<long long>(updated_pair_out.first) * updated_pair_out.second;
                }
            }

            // Handle incoming element
            if (freq.find(incoming) != freq.end()) {
                int old_freq_in = freq[incoming];
                pair<int, int> old_pair_in = make_pair(old_freq_in, incoming);
                // Determine which set the incoming element is in
                auto it_top_in = topSet.find(old_pair_in);
                if (it_top_in != topSet.end()) {
                    topSet.erase(it_top_in);
                    current_sum -= static_cast<long long>(old_freq_in) * incoming;
                }
                else {
                    auto it_rest_in = restSet.find(old_pair_in);
                    if (it_rest_in != restSet.end()) {
                        restSet.erase(it_rest_in);
                    }
                }

                // Increment frequency of incoming element
                freq[incoming]++;
                pair<int, int> updated_pair_in = make_pair(freq[incoming], incoming);

                // Insert the updated incoming element into the appropriate set
                if (!topSet.empty()) {
                    auto worst_top = *topSet.begin(); // smallest frequency and smallest value
                    if ( (updated_pair_in.first > worst_top.first) ||
                        (updated_pair_in.first == worst_top.first && updated_pair_in.second > worst_top.second) ) {
                        // Insert into topSet
                        topSet.emplace(updated_pair_in);
                        current_sum += static_cast<long long>(updated_pair_in.first) * updated_pair_in.second;
                        // If topSet exceeds size x, move the worst to restSet
                        if (topSet.size() > x) {
                            auto to_move = *topSet.begin();
                            topSet.erase(topSet.begin());
                            current_sum -= static_cast<long long>(to_move.first) * to_move.second;
                            restSet.emplace(to_move);
                        }
                    }
                    else {
                        // Insert into restSet
                        restSet.emplace(updated_pair_in);
                    }
                }
                else {
                    // If topSet is empty, insert directly
                    topSet.emplace(updated_pair_in);
                    current_sum += static_cast<long long>(updated_pair_in.first) * updated_pair_in.second;
                }
            }
            else {
                // New incoming element with frequency 1
                freq[incoming] = 1;
                pair<int, int> new_pair_in = make_pair(1, incoming);
                if (!topSet.empty()) {
                    auto worst_top = *topSet.begin(); // smallest frequency and smallest value
                    if ( (new_pair_in.first > worst_top.first) ||
                        (new_pair_in.first == worst_top.first && new_pair_in.second > worst_top.second) ) {
                        // Insert into topSet
                        topSet.emplace(new_pair_in);
                        current_sum += static_cast<long long>(new_pair_in.first) * new_pair_in.second;
                        // If topSet exceeds size x, move the worst to restSet
                        if (topSet.size() > x) {
                            auto to_move = *topSet.begin();
                            topSet.erase(topSet.begin());
                            current_sum -= static_cast<long long>(to_move.first) * to_move.second;
                            restSet.emplace(to_move);
                        }
                    }
                    else {
                        // Insert into restSet
                        restSet.emplace(new_pair_in);
                    }
                }
                else {
                    // If topSet is empty, insert directly
                    topSet.emplace(new_pair_in);
                    current_sum += static_cast<long long>(new_pair_in.first) * new_pair_in.second;
                }
            }

            // Rebalance topSet and restSet if necessary
            // Ensure topSet has exactly x elements
            while (topSet.size() < x && !restSet.empty()) {
                auto best_rest = *restSet.begin(); // best in restSet
                restSet.erase(restSet.begin());
                topSet.emplace(best_rest);
                current_sum += static_cast<long long>(best_rest.first) * best_rest.second;
            }

            while (topSet.size() > x && !topSet.empty()) {
                auto worst_top = *topSet.begin(); // worst in topSet
                topSet.erase(topSet.begin());
                current_sum -= static_cast<long long>(worst_top.first) * worst_top.second;
                restSet.emplace(worst_top);
            }

            // Swap elements between restSet and topSet if a better element exists in restSet
            if (!restSet.empty() && !topSet.empty()) {
                auto best_rest = *restSet.begin();
                auto worst_top = *topSet.begin();
                if ((best_rest.first > worst_top.first) ||
                    (best_rest.first == worst_top.first && best_rest.second > worst_top.second)) {
                    // Swap them
                    restSet.erase(restSet.begin());
                    topSet.erase(topSet.begin());
                    topSet.emplace(best_rest);
                    restSet.emplace(worst_top);
                    current_sum += static_cast<long long>(best_rest.first) * best_rest.second;
                    current_sum -= static_cast<long long>(worst_top.first) * worst_top.second;
                }
            }

            // Add the current x-sum to the answer
            answer.push_back(current_sum);
        }

        return answer;
    }
};
",1420561496
Suresh,encodedcoder,184,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        
        for (int i = 0; i <= n - k; ++i) {
            // Create a frequency map for the current subarray of size k
            unordered_map<int, int> freq;
            for (int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }
            
            // Move elements from map to a vector for sorting
            vector<pair<int, int>> sorted_freq(freq.begin(), freq.end());
            
            // Sort elements based on frequency and value
            sort(sorted_freq.begin(), sorted_freq.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.second == b.second) 
                    return a.first > b.first;  // Sort by value descending if frequencies are equal
                return a.second > b.second;   // Otherwise, sort by frequency descending
            });
            
            // Select top x elements
            unordered_set<int> top_x;
            for (int j = 0; j < min(x, (int)sorted_freq.size()); ++j) {
                top_x.insert(sorted_freq[j].first);
            }
            
            // Calculate the sum for the current subarray using the top x elements
            int current_sum = 0;
            for (int j = i; j < i + k; ++j) {
                if (top_x.count(nums[j])) {
                    current_sum += nums[j];
                }
            }
            
            // Add the result to the answer vector
            answer.push_back(current_sum);
        }
        
        return answer;
    }
};
",1420518592
Mohit Singh Rawat,MOHITRAWAT061,185,3509,cpp,"class Solution {
public:
    pair<int, int> findPerfectSubtrees(TreeNode* node, vector<int>& perfectSizes) {
        if (!node) return {0, 0};

        auto left = findPerfectSubtrees(node->left, perfectSizes);
        auto right = findPerfectSubtrees(node->right, perfectSizes);

        if (left.first != -1 && right.first != -1 && left.first == right.first) {
            int height = left.first + 1;
            int size = left.second + right.second + 1;
            perfectSizes.push_back(size);
            return {height, size};
        }

        return {-1, 0};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfectSizes;
        findPerfectSubtrees(root, perfectSizes);
        sort(perfectSizes.rbegin(), perfectSizes.rend());

        if (k <= perfectSizes.size()) {
            return perfectSizes[k - 1];
        }

        return -1;
    }
};
",1420524412
Mohit Singh Rawat,MOHITRAWAT061,185,3588,cpp,"const int MOD = 1e9 + 7;

class Game {
protected:
    int dp[1001][4][2002];
    std::string s;
    int n;

    void initializeDP() {
        std::memset(dp, -1, sizeof(dp));
    }

public:
    virtual int countWinningSequences(const std::string& moves) = 0;
    virtual ~Game() = default;
};

class MoveLogic {
protected:
    int win_against[3] = {1, 2, 0};

    int getAliceMove(char move) {
        return (move == 'F') ? 0 : (move == 'W') ? 1 : 2;
    }

    int updateScore(int alice_move, int bob_move, int score_diff) {
        if (bob_move == win_against[alice_move]) {
            return score_diff + 1;
        } else if (alice_move == win_against[bob_move]) {
            return score_diff - 1;
        }
        return score_diff;
    }
};

class Solution : public Game, private MoveLogic {
private:
    int dfs(int i, int last_bob_move, int score_diff) {
        if (i == n) return score_diff > 0 ? 1 : 0;

        if (dp[i][last_bob_move + 1][score_diff + 1000] != -1)
            return dp[i][last_bob_move + 1][score_diff + 1000];

        int total_ways = 0;
        int alice_move = getAliceMove(s[i]);

        for (int bob_move = 0; bob_move < 3; ++bob_move) {
            if (bob_move == last_bob_move) continue;

            int new_score_diff = updateScore(alice_move, bob_move, score_diff);

            total_ways = (total_ways + dfs(i + 1, bob_move, new_score_diff)) % MOD;
        }

        return dp[i][last_bob_move + 1][score_diff + 1000] = total_ways;
    }

public:
    int countWinningSequences(const std::string& moves) override {
        s = moves;
        n = s.length();
        initializeDP();
        return dfs(0, -1, 0);
    }
};",1420603737
Mohit Singh Rawat,MOHITRAWAT061,185,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <unordered_map>
#include <vector>
using namespace __gnu_pbds;
using namespace std;

class IFrequencyManager {
public:
    virtual void add(long long num) = 0;
    virtual void remove(long long num) = 0;
    virtual long long getFrequency(long long num) const = 0;
    virtual long long getWindowSum() const = 0;
    virtual bool exists(long long num) const = 0;
    virtual ~IFrequencyManager() = default;
};

class FrequencyManager : public IFrequencyManager {
private:
    using ll = long long;
    unordered_map<ll, ll> freq;
    ll windowSum = 0;

public:
    void add(ll num) override {
        freq[num]++;
        windowSum += num;
    }

    void remove(ll num) override {
        freq[num]--;
        windowSum -= num;
    }

    ll getFrequency(ll num) const override {
        return freq.at(num);
    }

    ll getWindowSum() const override {
        return windowSum;
    }

    bool exists(ll num) const override {
        return freq.find(num) != freq.end() && freq.at(num) > 0;
    }
};
class IXSumCalculator {
public:
    virtual void add(long long num, IFrequencyManager& freqManager) = 0;
    virtual void remove(long long num, IFrequencyManager& freqManager) = 0;
    virtual long long getXSum() const = 0;
    virtual ~IXSumCalculator() = default;
};

class XSumCalculator : public IXSumCalculator {
private:
    using ll = long long;
    using ordered_set = tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update>;

    ordered_set topX, remaining;
    ll xSum = 0;
    int x;

    void adjustTopX() {
        while (topX.size() > x) {
            auto it = topX.begin();
            remaining.insert(*it);
            xSum -= (ll)it->first * it->second;
            topX.erase(it);
        }
        while (topX.size() < x && !remaining.empty()) {
            auto it = remaining.rbegin();
            topX.insert(*it);
            xSum += (ll)it->first * it->second;
            remaining.erase(prev(remaining.end()));
        }
    }

public:
    XSumCalculator(int x) : x(x) {}

    void add(ll num, IFrequencyManager& freqManager) override {
        if (freqManager.exists(num)) {
            ll currentFreq = freqManager.getFrequency(num);
            auto it = topX.find({currentFreq, num});
            if (it != topX.end()) {
                topX.erase(it);
                xSum -= (ll)currentFreq * num;
            } else {
                remaining.erase({currentFreq, num});
            }
        }
        freqManager.add(num);
        ll updatedFreq = freqManager.getFrequency(num);
        topX.insert({updatedFreq, num});
        xSum += (ll)updatedFreq * num;
        adjustTopX();
    }

    void remove(ll num, IFrequencyManager& freqManager) override {
        ll currentFreq = freqManager.getFrequency(num);
        auto it = topX.find({currentFreq, num});
        if (it != topX.end()) {
            topX.erase(it);
            xSum -= (ll)currentFreq * num;
        } else {
            remaining.erase({currentFreq, num});
        }
        freqManager.remove(num);
        if (freqManager.getFrequency(num) > 0) {
            remaining.insert({freqManager.getFrequency(num), num});
        }
        adjustTopX();
    }

    ll getXSum() const override {
        return xSum;
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;

        FrequencyManager freqManager;
        XSumCalculator xSumCalculator(x);

        for (int i = 0; i < k; i++) {
            xSumCalculator.add(nums[i], freqManager);
        }
        answer.push_back(xSumCalculator.getXSum());

        for (int i = k; i < n; i++) {
            xSumCalculator.remove(nums[i - k], freqManager);
            xSumCalculator.add(nums[i], freqManager);
            answer.push_back(xSumCalculator.getXSum());
        }

        return answer;
    }
};
",1420579724
Mohit Singh Rawat,MOHITRAWAT061,185,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> result;
        unordered_map<int, int> freqMap;

        // Initialize frequency map for the first window of size k
        for (int i = 0; i < k; i++) {
            freqMap[nums[i]]++;
        }

        // Helper function to calculate the x-sum for a given frequency map
        auto computeXSum = [&](unordered_map<int, int>& freqMap) -> int {
            // Create a vector of pairs (element, frequency)
            vector<pair<int, int>> freqList(freqMap.begin(), freqMap.end());

            // Sort by frequency, then by element value in descending order for tie-breaking
            sort(freqList.begin(), freqList.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.second == b.second) return a.first > b.first; // If frequencies are equal, larger element first
                return a.second > b.second; // Otherwise, higher frequency first
            });

            // Calculate the x-sum using the top 'x' elements
            int xSum = 0;
            int count = 0;
            for (auto& p : freqList) {
                if (count == x) break;
                xSum += p.first * p.second;
                count++;
            }

            return xSum;
        };

        // Compute the x-sum for the first window
        result.push_back(computeXSum(freqMap));

        // Slide the window across the array
        for (int i = k; i < n; i++) {
            // Remove the element that goes out of the window
            freqMap[nums[i - k]]--;
            if (freqMap[nums[i - k]] == 0) {
                freqMap.erase(nums[i - k]);
            }

            // Add the new element that enters the window
            freqMap[nums[i]]++;

            // Compute the x-sum for the current window
            result.push_back(computeXSum(freqMap));
        }

        return result;
    }
};
",1420523020
h_bugw7,h_bugw7,186,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
    vector<int> v;
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        solve(root);
        sort(v.rbegin(), v.rend());
        if(v.size() < k) return -1;
        return (1<<v[k-1])-1;
    }
    int solve(TreeNode* root) {
        if(!root) return 0;
        int l = solve(root->left);
        int r = solve(root->right);
        if(l < 0 || l != r) return -1;
        v.push_back(l+1);
        return l+1;
    }
};",1420522753
h_bugw7,h_bugw7,186,3588,cpp,"const int MOD = 1000000007;

// F > E > W > F
// 0   1   2

class Solution {
public:
    int countWinningSequences(string s) {
        int x['W'+1];
        x['F'] = 0, x['E'] = 1, x['W'] = 2;

        int dp[2][3][3000] = {0}; // [times][move][index]
        int n = s.length();
        int F = 0, T = 1;
        for(int m = 0; m < 3; m++) {
            dp[T][m][1500+getScore(m, x[s[0]])] = 1;
        }
        for(int i = 1; i < n; i++) {
            swap(F, T);
            memset(dp[T], 0, sizeof(dp[T]));
            for(int m = 0; m < 3; m++) {
                int score = getScore(m, x[s[i]]);
                for(int p = 0; p < 3; p++) {
                    if(m == p) continue;
                    for(int sc = 500; sc <= 2500; sc++) {
                        dp[T][m][sc] = (dp[T][m][sc] + dp[F][p][sc-score]) % MOD;
                        // if(dp[T][m][sc]) cout << i << "": "" << m << "", "" << (sc-1500) << "" = "" << dp[T][m][sc] << endl;
                    }
                }
            }
        }
        int res = 0;
        for(int i = 1501; i < 3000; i++) {
            res = (res + dp[T][0][i]) % MOD;
            res = (res + dp[T][1][i]) % MOD;
            res = (res + dp[T][2][i]) % MOD;
        }

        return res;
    }
    int getScore(int a, int b) {
        return (b - a + 4) % 3 - 1;
    }
};",1420615267
h_bugw7,h_bugw7,186,3592,cpp,"typedef pair<int, int> pii;

class Box {
    int k;
    set<pii> st1, st2;
    map<int, int> mp;
    long long sum;
public:
    Box(int k): k(k), sum(0) { }
    void add(int x) {
        int cnt = mp[x]++;
        // remove old
        bool was_st1 = false;
        if(cnt) {
            if(*st1.begin() <= pii{cnt, x}) {
                st1.erase({cnt, x});
                was_st1 = true;
            } else {
                st2.erase({cnt, x});
            }
        }
        // insert new
        bool is_st1 = false;
        cnt++;
        if(st1.size() < k || *st1.begin() <= pii{cnt, x}) {
            st1.insert({cnt, x});
            is_st1 = true;
        } else {
            st2.insert({cnt, x});
        }
        // update sum
        if(is_st1) {
            if(was_st1) sum += x;
            else sum += (long long)cnt * (long long)x;
        }
        // remove k+1
        if(st1.size() > k) {
            pii last = *st1.begin();
            st1.erase(st1.begin());
            st2.insert(last);
            sum -= (long long)last.first * (long long)last.second;
        }
        // cout << ""add "" << x << "",   "" << was_st1 << "" -> "" << is_st1 << "" , st1: "";
        // for(auto& [a, b]: st1) cout << ""("" << a << "", "" << b << "") "";
        // cout << endl;
    }
    void sub(int x) {
        int cnt = mp[x]--;
        // remove old
        bool was_st1 = false;
        if(*st1.begin() <= pii{cnt, x}) {
            st1.erase({cnt, x});
            was_st1 = true;
        } else {
            st2.erase({cnt, x});
        }
        // insert new
        bool is_st1 = false;
        cnt--;
        if(cnt) {
            st2.insert({cnt, x});
        }
        // update sum
        if(was_st1) {
            if(is_st1) sum -= x;
            else sum -= (long long)(cnt+1) * (long long)x;
        }
        // insert k
        while(st1.size() < k && !st2.empty()) {
            pii last = *st2.rbegin();
            st2.erase(prev(st2.end()));
            st1.insert(last);
            sum += (long long)last.first * (long long)last.second;
        }
        // cout << ""sub "" << x << "",   "" << was_st1 << "" -> "" << is_st1 << "" , st1: "";
        // for(auto& [a, b]: st1) cout << ""("" << a << "", "" << b << "") "";
        // cout << endl;
    }
    long long getSum() const { return sum; }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        Box box(x);
        vector<long long> res;
        int n = nums.size();
        for(int i = 0; i < k-1; i++) {
            box.add(nums[i]);
            // res.push_back(box.getSum()); //
        }
        for(int i = k-1; i < n; i++) {
            box.add(nums[i]);
            res.push_back(box.getSum());
            box.sub(nums[i-k+1]);
        }
        return res;
    }
};",1420570745
h_bugw7,h_bugw7,186,3610,cpp,"typedef pair<int, int> pii;

class Box {
    int k;
    set<pii> st1, st2;
    map<int, int> mp;
    long long sum;
public:
    Box(int k): k(k), sum(0) { }
    void add(int x) {
        int cnt = mp[x]++;
        // remove old
        bool was_st1 = false;
        if(cnt) {
            if(*st1.begin() <= pii{cnt, x}) {
                st1.erase({cnt, x});
                was_st1 = true;
            } else {
                st2.erase({cnt, x});
            }
        }
        // insert new
        bool is_st1 = false;
        cnt++;
        if(st1.size() < k || *st1.begin() <= pii{cnt, x}) {
            st1.insert({cnt, x});
            is_st1 = true;
        } else {
            st2.insert({cnt, x});
        }
        // update sum
        if(is_st1) {
            if(was_st1) sum += x;
            else sum += (long long)cnt * (long long)x;
        }
        // remove k+1
        if(st1.size() > k) {
            pii last = *st1.begin();
            st1.erase(st1.begin());
            st2.insert(last);
            sum -= (long long)last.first * (long long)last.second;
        }
        // cout << ""add "" << x << "",   "" << was_st1 << "" -> "" << is_st1 << "" , st1: "";
        // for(auto& [a, b]: st1) cout << ""("" << a << "", "" << b << "") "";
        // cout << endl;
    }
    void sub(int x) {
        int cnt = mp[x]--;
        // remove old
        bool was_st1 = false;
        if(*st1.begin() <= pii{cnt, x}) {
            st1.erase({cnt, x});
            was_st1 = true;
        } else {
            st2.erase({cnt, x});
        }
        // insert new
        bool is_st1 = false;
        cnt--;
        if(cnt) {
            st2.insert({cnt, x});
        }
        // update sum
        if(was_st1) {
            if(is_st1) sum -= x;
            else sum -= (long long)(cnt+1) * (long long)x;
        }
        // insert k
        while(st1.size() < k && !st2.empty()) {
            pii last = *st2.rbegin();
            st2.erase(prev(st2.end()));
            st1.insert(last);
            sum += (long long)last.first * (long long)last.second;
        }
        // cout << ""sub "" << x << "",   "" << was_st1 << "" -> "" << is_st1 << "" , st1: "";
        // for(auto& [a, b]: st1) cout << ""("" << a << "", "" << b << "") "";
        // cout << endl;
    }
    long long getSum() const { return sum; }
};

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        Box box(x);
        vector<int> res;
        int n = nums.size();
        for(int i = 0; i < k-1; i++) {
            box.add(nums[i]);
            // res.push_back(box.getSum()); //
        }
        for(int i = k-1; i < n; i++) {
            box.add(nums[i]);
            res.push_back(box.getSum());
            box.sub(nums[i-k+1]);
        }
        return res;
    }
};",1420571241
garyjhu,garyjhu,188,3509,java,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> res = new ArrayList<>();
        traverse(root, res);
        if (res.size() < k) return -1;
        Collections.sort(res);
        return res.get(res.size() - k);
    }

    private static int traverse(TreeNode node, List<Integer> res) {
        if (node == null) return 0;
        int left = traverse(node.left, res);
        int right = traverse(node.right, res);
        if (left != -1 && left == right) {
            int sum = left + right + 1;
            res.add(sum);
            return sum;
        }
        return -1;
    }
}
",1420530116
garyjhu,garyjhu,188,3588,java,"import java.util.ArrayList;

class Solution {
    static ModIntFactory factory = new ModIntFactory(1_000_000_007);

    public int countWinningSequences(String s) {
        int n = s.length();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c == 'F') a[i] = 0;
            else if (c == 'W') a[i] = 1;
            else if (c == 'E') a[i] = 2;
        }
        ModIntFactory.ModInt[][][] dp = new ModIntFactory.ModInt[n][2 * n + 1][3];
        for (int j = 0; j <= 2 * n; j++) {
            for (int k = 0; k < 3; k++) {
                dp[n - 1][j][k] = factory.create(0);
            }
        }
        dp[n - 1][n][a[n - 1]] = dp[n - 1][n + 1][(a[n - 1] + 1) % 3] = dp[n - 1][n - 1][(a[n - 1] + 2) % 3] = factory.create(1);
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= 2 * n; j++) {
                for (int k = 0; k < 3; k++) {
                    if (k == a[i]) {
                        dp[i][j][k] = dp[i + 1][j][(k + 1) % 3].add(dp[i + 1][j][(k + 2) % 3]);
                    }
                    else if (k == (a[i] + 1) % 3) {
                        if (j == 0) dp[i][j][k] = factory.create(0);
                        else dp[i][j][k] = dp[i + 1][j - 1][(k + 1) % 3].add(dp[i + 1][j - 1][(k + 2) % 3]);
                    }
                    else {
                        if (j == 2 * n) dp[i][j][k] = factory.create(0);
                        else dp[i][j][k] = dp[i + 1][j + 1][(k + 1) % 3].add(dp[i + 1][j + 1][(k + 2) % 3]);
                    }
                }
            }
        }

//        for (int j = 0; j <= 2 * n; j++) {
//            for (int k = 0; k < 3; k++) System.out.print(dp[0][j][k] + "" "");
//            System.out.println();
//        }
//        System.out.println();

        ModIntFactory.ModInt res = factory.create(0);
        for (int j = n + 1; j <= 2 * n; j++) {
            for (int k = 0; k < 3; k++) res.addAsg(dp[0][j][k]);
        }
        return res.value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}

",1420569037
garyjhu,garyjhu,188,3592,java,"import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        TreeSet<Node> smallestX = new TreeSet<>();
        TreeSet<Node> remainder = new TreeSet<>();
        long[] sum = new long[1];
        Map<Integer, Node> map = new HashMap<>();
        long[] res = new long[n - k + 1];
        for (int i = 0; i < n; i++) {
            increment(smallestX, remainder, map, sum, nums[i], x);
            if (i >= k) decrement(smallestX, remainder, map, sum, nums[i - k], x);
            if (i >= k - 1) res[i - k + 1] = sum[0];
//            System.out.print(i + "": "");
//            for (Node node : smallestX) {
//                System.out.print(""("" + node.val + "", "" + node.freq + "") "");
//            }
//            System.out.println();
        }
        return res;
    }

    private static void increment(TreeSet<Node> smallestX, TreeSet<Node> remainder, Map<Integer, Node> map, long[] sum, int val, int x) {
        Node oldNode = map.getOrDefault(val, new Node(val, 0));
        remove(smallestX, sum, oldNode);
        remainder.remove(oldNode);
        Node newNode = new Node(val, oldNode.freq + 1);
        add(smallestX, sum, newNode);
        while (smallestX.size() > x) {
            Node smallest = smallestX.first();
            remove(smallestX, sum, smallest);
            remainder.add(smallest);
        }
        map.put(val, newNode);
    }

    private static void decrement(TreeSet<Node> smallestX, TreeSet<Node> remainder, Map<Integer, Node> map, long[] sum, int val, int x) {
        Node oldNode = map.get(val);
        remove(smallestX, sum, oldNode);
        remainder.remove(oldNode);
        Node newNode = new Node(val, oldNode.freq - 1);
        add(smallestX, sum, newNode);
        while (smallestX.size() > x) {
            Node smallest = smallestX.first();
            remove(smallestX, sum, smallest);
            remainder.add(smallest);
        }
        while (!smallestX.isEmpty() && !remainder.isEmpty() && smallestX.first().compareTo(remainder.last()) < 0) {
            Node smallest = smallestX.first();
            remove(smallestX, sum, smallest);
            Node largest = remainder.pollLast();
            add(smallestX, sum, largest);
            remainder.add(smallest);
        }
        map.put(val, newNode);
    }

    private static void remove(TreeSet<Node> tree, long[] sum, Node node) {
        if (tree.remove(node)) {
            sum[0] -= node.val * node.freq;
        }
    }

    private static void add(TreeSet<Node> tree, long[] sum, Node node) {
        tree.add(node);
        sum[0] += node.val * node.freq;
    }

    private static record Node(long val, int freq) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            if (freq != o.freq) return Integer.compare(freq, o.freq);
            return Long.compare(val, o.val);
        }
    }
}
",1420615716
garyjhu,garyjhu,188,3610,java,"import java.util.Arrays;

class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[][] count = new int[51][2];
        for (int i = 0; i <= 50; i++) count[i][1] = i;
        int[] res = new int[n - k + 1];
        for (int i = 0; i < k; i++) count[nums[i]][0]++;
        res[0] = sum(count, x);
        for (int i = k; i < n; i++) {
            count[nums[i]][0]++;
            count[nums[i - k]][0]--;
            res[i - k + 1] = sum(count, x);
        }
        return res;
    }

    private static int sum(int[][] count, int x) {
        int[][] sorted = count.clone();
        Arrays.sort(sorted, (a, b) -> {
            if (a[0] != b[0]) return a[0] - b[0];
            return a[1] - b[1];
        });
        int res = 0;
        for (int i = 50; i > 50 - x; i--) res += sorted[i][0] * sorted[i][1];
        return res;
    }
}
",1420522650
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,189,3509,javascript,"function print(...args) { for(let who of args) console.log(who); }
function mrand(begin, end) { return Math.floor(Math.random() * (end - begin + 1) + begin); }
function ceil(who) { return Math.ceil(who); }
function int(who) { return Math.floor(Number(who)); }
function abs(val) { return Math.abs(val); }
function bint(value) { return BigInt(value); }    
function to_string(val) { return val.toString(); }
function char(val) { return String.fromCharCode(val); }
function mbin(val) { return val.toString(2); }
function sqrt(val) { return Math.sqrt(val); }
function stoi(str) { return parseInt(str, 10); }
function ord(ch) { return ch.charCodeAt(0); }
function islower(ch) { return ord(ch) >= ord('a') && ord(ch) <= ord('z'); }
function isupper(ch) { return ord(ch) >= ord('A')  && ord(ch) <= ord('Z'); }
function isdigit(ch) { return ord(ch) >= ord('0') && ord(ch) <= ord('9'); }
function isalpha(ch) { return islower(ch) || isupper(ch); }
function toupper(ch) { return (!isalpha(ch) || isupper(ch)) ? ch : String.fromCharCode(ord(ch) -  32); }
function tolower(ch) { return (!isalpha(ch) || islower(ch)) ? ch : char(ord(ch) + 32); }
function isalnum(ch) { return isalpha(ch) || isdigit(ch); }
function size(who) {
    if(Array.isArray(who) || typeof who === 'string') return who.length;
    if (who instanceof Map || who instanceof WeakMap || who instanceof Set) return who.size;
    if(typeof who === 'object' && who !== null) return Object.keys(who).length;
    throw new Error('Unsupported container type');
}
function clear(who) {
    if(Array.isArray(who)) who.length = 0;
    else if(who instanceof Map || who instanceof WeakMap || who instanceof Set || typeof who === 'object' && who !== null) who.clear();
    else throw new Error('Unsupported container type');
}

//init an array of [a, b, ..., n] dimensions with set_val as init_val
function fill(arr_dims, set_val = 0) {
    function dfs(i){
        let ans = [];
        for(let j = 0; j < arr_dims[i]; j++){
            if(i < arr_dims.length - 1)
                ans.push(dfs(i + 1));
            else
                ans.push(copy(set_val));
        }
        return ans;
    }
    return dfs(0);
}

//Set all element in array to set_val
function memset(arr, set_val = 0) {
    function dfs(now){
        for (let i = 0; i < now.length; i++){
            if (Array.isArray(now[i]))
                dfs(now[i]);
            else
                now[i] = copy(set_val);
        }
    }
    dfs(arr);
}

function assert(condition, message = """") {
    if(condition) return;
    const error = new Error(message || ""Assertion failed"");
    Error.captureStackTrace(error, assert);
    // Split the stack trace into lines
    const stack_lines = error.stack.split('\n');
    console.error(stack_lines[0]);
    console.error(stack_lines[1]);
    process.exit(1);
}

function copy(obj) {
    if(obj === null || typeof obj !== 'object')
        return obj;    
    if(obj instanceof Date)
        return new Date(obj);
    if(Array.isArray(obj))
        return obj.map(item => copy(item));
    if(obj instanceof Map) {
        const new_map = new Map();
        obj.forEach((value, key) => {
            new_map.set(copy(key), copy(value));
        });
        return new_map;
    }
    if(obj instanceof Set) {
        const new_set = new Set();
        obj.forEach(value => {
            new_set.add(copy(value));
        });
        return new_set;
    }
    if(typeof obj === 'object' && obj.constructor === Object) {
        const new_obj = {};
        for(let key in obj)
            if(obj.hasOwnProperty(key))
                new_obj[key] = copy(obj[key]);
        return new_obj;
    }

    assert(false, ""Copy failed!"");
}

function get_unique(arr, compare = null) {
    if(compare == null)
        compare = (a, b) => {
            if(a == b) return 0;
            return a < b ? -1 : 1;
        };

    arr.sort(compare);
    const n = size(arr);
    let new_size = 0;
    for(let i = 0; i < n; i++)
        if(!i || compare(arr[i], arr[i - 1]))
            arr[new_size++] = arr[i];
    arr.length = new_size;
    return arr;
}

function max(...args) { 
    let best = args[0]; 
    for(const val of args)
        if(val > best) best = val;
    return best;
}

function min(...args) {
    let best = args[1];
    for(const val of args)
        if(val < best) best = val;
    return best;
}

function pow(base, exponent, MOD = 0) {
    if(!base) return base;

    const ONE = base / base;
    const ZERO = ONE - ONE;
    const IS_NEGATIVE = base < ZERO;
    const IS_EXPO_ODD = exponent & ONE; 

    if(IS_NEGATIVE) base = -base;
    if(!exponent) return ONE;

    let ans = ONE;
    while(exponent) {
        if(exponent & ONE){
            ans *= base;
            if(MOD) ans %= MOD;
        }
        exponent >>= ONE;
        base *= base;
        if(MOD) base %= MOD;
    }

    if(IS_NEGATIVE && IS_EXPO_ODD)
        ans = -ans;

    return ans;
} 

//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
const dx = [0, 1, 0, -1, -1, 1, 1, -1, 0];
const dy = [1, 0, -1, 0, -1, 1, -1, 1, 0];

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargestPerfectSubtree = function(root, k) {
    const INF = 1 << 27;
    const calc = (root1, root2) => {
        if(!root1 && !root2)
            return 0;
        if(!root1 || !root2)
            return -INF;

        let q1 = [root1];
        let q2 = [root2];
        let depth = 0;
        let got = 0;
        while(size(q1) || size(q2)){
            const must_size = 1 << depth;
            got += must_size << 1;
            if(size(q1) != must_size || size(q2) != must_size)
                return -INF;

            let q3 = [];
            for(const cur of q1){
                if(cur.left)
                    q3.push(cur.left);
                if(cur.right)
                    q3.push(cur.right);
            }

            let q4 = [];
            for(const cur of q2){
                if(cur.left)
                    q4.push(cur.left);
                if(cur.right)
                    q4.push(cur.right);
            }

            depth++;
            q1 = q3;
            q2 = q4;
        }

        return got;
    };

    const ans = [];
    const dfs = (cur) => {
        if(!cur)
            return;
        const got = calc(cur.left, cur.right) + 1;
        if(got > 0)
            ans.push(got);
        dfs(cur.left);
        dfs(cur.right);
    }

    dfs(root);
    ans.sort((a, b) => b - a);
    // print(ans)
    return size(ans) >= k ? ans[k - 1] : -1;
};
",1420592032
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,189,3588,javascript,"function print(...args) { for(let who of args) console.log(who); }
function mrand(begin, end) { return Math.floor(Math.random() * (end - begin + 1) + begin); }
function ceil(who) { return Math.ceil(who); }
function int(who) { return Math.floor(Number(who)); }
function abs(val) { return Math.abs(val); }
function bint(value) { return BigInt(value); }    
function to_string(val) { return val.toString(); }
function char(val) { return String.fromCharCode(val); }
function mbin(val) { return val.toString(2); }
function sqrt(val) { return Math.sqrt(val); }
function stoi(str) { return parseInt(str, 10); }
function ord(ch) { return ch.charCodeAt(0); }
function islower(ch) { return ord(ch) >= ord('a') && ord(ch) <= ord('z'); }
function isupper(ch) { return ord(ch) >= ord('A')  && ord(ch) <= ord('Z'); }
function isdigit(ch) { return ord(ch) >= ord('0') && ord(ch) <= ord('9'); }
function isalpha(ch) { return islower(ch) || isupper(ch); }
function toupper(ch) { return (!isalpha(ch) || isupper(ch)) ? ch : String.fromCharCode(ord(ch) -  32); }
function tolower(ch) { return (!isalpha(ch) || islower(ch)) ? ch : char(ord(ch) + 32); }
function isalnum(ch) { return isalpha(ch) || isdigit(ch); }
function size(who) {
    if(Array.isArray(who) || typeof who === 'string') return who.length;
    if (who instanceof Map || who instanceof WeakMap || who instanceof Set) return who.size;
    if(typeof who === 'object' && who !== null) return Object.keys(who).length;
    throw new Error('Unsupported container type');
}
function clear(who) {
    if(Array.isArray(who)) who.length = 0;
    else if(who instanceof Map || who instanceof WeakMap || who instanceof Set || typeof who === 'object' && who !== null) who.clear();
    else throw new Error('Unsupported container type');
}

//init an array of [a, b, ..., n] dimensions with set_val as init_val
function fill(arr_dims, set_val = 0) {
    function dfs(i){
        let ans = [];
        for(let j = 0; j < arr_dims[i]; j++){
            if(i < arr_dims.length - 1)
                ans.push(dfs(i + 1));
            else
                ans.push(copy(set_val));
        }
        return ans;
    }
    return dfs(0);
}

//Set all element in array to set_val
function memset(arr, set_val = 0) {
    function dfs(now){
        for (let i = 0; i < now.length; i++){
            if (Array.isArray(now[i]))
                dfs(now[i]);
            else
                now[i] = copy(set_val);
        }
    }
    dfs(arr);
}

function assert(condition, message = """") {
    if(condition) return;
    const error = new Error(message || ""Assertion failed"");
    Error.captureStackTrace(error, assert);
    // Split the stack trace into lines
    const stack_lines = error.stack.split('\n');
    console.error(stack_lines[0]);
    console.error(stack_lines[1]);
    process.exit(1);
}

function copy(obj) {
    if(obj === null || typeof obj !== 'object')
        return obj;    
    if(obj instanceof Date)
        return new Date(obj);
    if(Array.isArray(obj))
        return obj.map(item => copy(item));
    if(obj instanceof Map) {
        const new_map = new Map();
        obj.forEach((value, key) => {
            new_map.set(copy(key), copy(value));
        });
        return new_map;
    }
    if(obj instanceof Set) {
        const new_set = new Set();
        obj.forEach(value => {
            new_set.add(copy(value));
        });
        return new_set;
    }
    if(typeof obj === 'object' && obj.constructor === Object) {
        const new_obj = {};
        for(let key in obj)
            if(obj.hasOwnProperty(key))
                new_obj[key] = copy(obj[key]);
        return new_obj;
    }

    assert(false, ""Copy failed!"");
}

function get_unique(arr, compare = null) {
    if(compare == null)
        compare = (a, b) => {
            if(a == b) return 0;
            return a < b ? -1 : 1;
        };

    arr.sort(compare);
    const n = size(arr);
    let new_size = 0;
    for(let i = 0; i < n; i++)
        if(!i || compare(arr[i], arr[i - 1]))
            arr[new_size++] = arr[i];
    arr.length = new_size;
    return arr;
}

function max(...args) { 
    let best = args[0]; 
    for(const val of args)
        if(val > best) best = val;
    return best;
}

function min(...args) {
    let best = args[1];
    for(const val of args)
        if(val < best) best = val;
    return best;
}

function pow(base, exponent, MOD = 0) {
    if(!base) return base;

    const ONE = base / base;
    const ZERO = ONE - ONE;
    const IS_NEGATIVE = base < ZERO;
    const IS_EXPO_ODD = exponent & ONE; 

    if(IS_NEGATIVE) base = -base;
    if(!exponent) return ONE;

    let ans = ONE;
    while(exponent) {
        if(exponent & ONE){
            ans *= base;
            if(MOD) ans %= MOD;
        }
        exponent >>= ONE;
        base *= base;
        if(MOD) base %= MOD;
    }

    if(IS_NEGATIVE && IS_EXPO_ODD)
        ans = -ans;

    return ans;
} 

//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
const dx = [0, 1, 0, -1, -1, 1, 1, -1, 0];
const dy = [1, 0, -1, 0, -1, 1, -1, 1, 0];

const nax = 1_000;
const dp = fill([nax, 4, nax * 2 + 1], -1);

/**
 * @param {string} s
 * @return {number}
 */
var countWinningSequences = function(s) {
    const n = size(s);
    const MOD = int(1e9 + 7);
    const mp = new Map();
    mp['F'] = 0;
    mp['W'] = 1;
    mp['E'] = 2;

    const arr = [];
    for(const ch of s)
        arr.push(mp[ch]);

    for(let i = 0; i < n; i++)
        for(let last = 0; last <= 3; last++)
            for(let delta = 0; delta <= n * 2; delta++)
                dp[i][last][delta] = -1;

    const calc = (alice, bob) => {
        if(alice == bob)
            return 0;
        if(alice == 0)
            return (bob == 1) ? 1 : -1;
        if(alice == 1)
            return (bob == 2) ? 1 : -1;
        return (bob == 0) ? 1 : -1;
    }

    const dfs = (cur, last, delta) => {
        if(cur == n)
            return (delta > n) ? 1 : 0;
        if(dp[cur][last][delta] != -1)
            return dp[cur][last][delta];

        let got = 0;
        for(let x = 0; x <= 2; x++)
            if(x != last){
                got += dfs(cur + 1, x, delta + calc(arr[cur], x));
                if(got >= MOD)
                    got -= MOD;
            }

        return dp[cur][last][delta] = got;
    }

    return dfs(0, 3, n);
};
",1420610023
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,189,3592,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define mbin(val, cap) bitset<64>(val).to_string().substr(64 - cap)
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        //top x big freq
        const int n = nums.size();

        umap<int,int> vfreq;
        set<pii> best; //
        set<pii, greater<pii>> bads;
        int64_t sub_sum = 0;
        int64_t top_sum = 0;

        for(int i = 0; i < k; i++){
            sub_sum += nums[i];
            auto it = best.find({vfreq[nums[i]], nums[i]});
            if(it != best.end())
                best.erase(it);
            vfreq[nums[i]]++;
            best.emplace(vfreq[nums[i]], nums[i]);
        }

        while(best.size() > x){
            bads.emplace(*best.begin());
            best.erase(best.begin());
        }

        for(auto& [freq, val] : best)
            top_sum += 1ll * freq * val;

        vector<int64_t> ans;
        auto get = [&]() -> int64_t {
            return (best.size() == x) ? top_sum : sub_sum;
        };

        auto update = [&](int val, int delta) -> void {
            pii out(vfreq[val], val);
            if(best.count(out)){
                best.erase(out);
                top_sum -= 1ll * vfreq[val] * val;
            }else{
                bads.erase(out);
            }

            vfreq[val] += delta;
            best.emplace(vfreq[val], val);
            top_sum += 1LL * vfreq[val] * val;
        };

        ans.push_back(get());
        printc(best)
        printc(bads)
        print(top_sum)
        for(int i = k; i < n; i++){
            const int j = i - k;
            sub_sum += nums[i] - nums[j];
            update(nums[j], -1);
            update(nums[i], 1);

            while(best.size() > x){
                const pii& out = *best.begin();
                top_sum -= 1LL * out.first * out.second;
                bads.emplace(out);
                best.erase(best.begin());
            }

            while(!bads.empty() && best.size() < x){
                auto it = bads.begin();
                top_sum += 1LL * it->first * it->second;
                best.emplace(*it);
                bads.erase(it);
            }

            while(!bads.empty()){
                pii p1 = *best.begin();
                pii p2 = *bads.begin();
                if(p1.first > p2.first)
                    break;
                if(p1.first == p2.first && p1.second >= p2.second)
                    break;
                top_sum -= 1LL * p1.first * p1.second;
                top_sum += 1LL * p2.first * p2.second;
                best.erase(best.begin());
                bads.erase(bads.begin());
                best.emplace(p2);
                bads.emplace(p1);
            }

            ans.push_back(get());
            // printc(best)
            // printc(bads)
            // print(top_sum)
        }

        // [6,10,12]
        // [11,15,15,15,12]

        return ans;
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      ",1420562995
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,189,3610,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define mbin(val, cap) bitset<64>(val).to_string().substr(64 - cap)
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        //top x big freq
        const int n = nums.size();

        umap<int,int> vfreq;
        set<pii> best; //
        set<pii, greater<pii>> bads;
        int64_t sub_sum = 0;
        int64_t top_sum = 0;

        for(int i = 0; i < k; i++){
            sub_sum += nums[i];
            auto it = best.find({vfreq[nums[i]], nums[i]});
            if(it != best.end())
                best.erase(it);
            vfreq[nums[i]]++;
            best.emplace(vfreq[nums[i]], nums[i]);
        }

        while(best.size() > x){
            bads.emplace(*best.begin());
            best.erase(best.begin());
        }

        for(auto& [freq, val] : best)
            top_sum += 1ll * freq * val;

        vector<int> ans;
        auto get = [&]() -> int64_t {
            return (best.size() == x) ? top_sum : sub_sum;
        };

        auto update = [&](int val, int delta) -> void {
            pii out(vfreq[val], val);
            if(best.count(out)){
                best.erase(out);
                top_sum -= 1ll * vfreq[val] * val;
            }else{
                bads.erase(out);
            }

            vfreq[val] += delta;
            best.emplace(vfreq[val], val);
            top_sum += 1LL * vfreq[val] * val;
        };

        ans.push_back(get());
        // printc(best)
        // printc(bads)
        // print(top_sum)
        for(int i = k; i < n; i++){
            const int j = i - k;
            sub_sum += nums[i] - nums[j];
            update(nums[j], -1);
            update(nums[i], 1);

            while(best.size() > x){
                const pii& out = *best.begin();
                top_sum -= 1LL * out.first * out.second;
                bads.emplace(out);
                best.erase(best.begin());
            }

            while(!bads.empty() && best.size() < x){
                auto it = bads.begin();
                top_sum += 1LL * it->first * it->second;
                best.emplace(*it);
                bads.erase(it);
            }

            while(!bads.empty()){
                pii p1 = *best.begin();
                pii p2 = *bads.begin();
                if(p1.first > p2.first)
                    break;
                if(p1.first == p2.first && p1.second >= p2.second)
                    break;
                top_sum -= 1LL * p1.first * p1.second;
                top_sum += 1LL * p2.first * p2.second;
                best.erase(best.begin());
                bads.erase(bads.begin());
                best.emplace(p2);
                bads.emplace(p1);
            }

            ans.push_back(get());
            // printc(best)
            // printc(bads)
            // print(top_sum)
        }

        // [6,10,12]
        // [11,15,15,15,12]

        return ans;
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      ",1420564692
Sam Huang,CelonyMire,192,3509,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
  int kthLargestPerfectSubtree(TreeNode *root, int k) {
    vector<int> sz;
    auto dfs = [&](auto &self, TreeNode *cur) -> int {
      if (!cur) {
        return 0;
      }
      int lz = self(self, cur->left);
      int rz = self(self, cur->right);
      if (lz == rz) {
        sz.push_back(lz + rz + 1);
        return lz + rz + 1;
      }
      return -1;
    };
    dfs(dfs, root);
    ranges::sort(sz, greater{});
    return k - 1 >= sz.size() ? -1 : sz[k - 1];
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::kthLargestPerfectSubtree); // CHANGE FOR PROBLEM
}
#endif",1420579595
Sam Huang,CelonyMire,192,3588,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
const int M = 1e9 + 7;
void add(int &a, int b) {
  a = (a + b) % M;
}

char win[256] = {}, loss[256] = {}, idx[256] = {};

constexpr long long pow(long long a, long long b, long long m) {
  a %= m;
  long long res = 1;
  while (b > 0) {
    if (b & 1)
      res = res * a % m;
    a = a * a % m;
    b >>= 1;
  }
  return res;
}

class Solution {
public:
  int countWinningSequences(string s) {
    win['E'] = 'F';
    win['F'] = 'W';
    win['W'] = 'E';
    loss['F'] = 'E';
    loss['W'] = 'F';
    loss['E'] = 'W';
    idx['F'] = 0;
    idx['W'] = 1;
    idx['E'] = 2;
    char l[] = {'F', 'W', 'E'};
    int n = s.size();
    vector dp(n + 1, vector(2 * n + 1, vector(3, 0)));
    ranges::fill(dp[0][n], 1);
    for (int i = 0; i < n; i++) {
      for (int j = -n + 1; j <= n; j++) {
        for (int k = 0; k < 3; k++) {
          if (l[k] != loss[s[i]]) {
            add(dp[i + 1][(j - 1) + n][idx[loss[s[i]]]], dp[i][j + n][k]);
          }
        }
      }
      for (int j = -n; j <= n - 1; j++) {
        for (int k = 0; k < 3; k++) {
          if (l[k] != win[s[i]]) {
            add(dp[i + 1][(j + 1) + n][idx[win[s[i]]]], dp[i][j + n][k]);
          }
        }
      }
      for (int j = -n; j <= n; j++) {
        for (int k = 0; k < 3; k++) {
          if (l[k] != s[i]) {
            add(dp[i + 1][j + n][idx[s[i]]], dp[i][j + n][k]);
          }
        }
      }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
      for (int k = 0; k < 3; k++) {
        add(ans, dp[n][i + n][k]);
      }
    }
    return ans * pow(2, M - 2, M) % M;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::countWinningSequences); // CHANGE FOR PROBLEM
}
#endif",1420610501
Sam Huang,CelonyMire,192,3592,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
template <typename CItr, typename Itr, typename Cmp, typename Alloc>
struct node_update {
  typedef struct {
    int cnt = 0;
    long long sum = 0;
  } metadata_type;
  void operator()(Itr it, CItr end) {
    (int &)it.get_metadata().cnt = 1;
    (long long &)it.get_metadata().sum = 1LL * (*it)->first * (*it)->second;
    if (auto it2 = it.get_l_child(); it2 != end) {
      (int &)it.get_metadata().cnt += it2.get_metadata().cnt;
      (long long &)it.get_metadata().sum += it2.get_metadata().sum;
    }
    if (auto it2 = it.get_r_child(); it2 != end) {
      (int &)it.get_metadata().cnt += it2.get_metadata().cnt;
      (long long &)it.get_metadata().sum += it2.get_metadata().sum;
    }
  }
  virtual CItr node_begin() const = 0;
  virtual CItr node_end() const = 0;
  virtual ~node_update() {}
  long long query(int k) const {
    long long ans = 0;
    for (auto it = node_begin(); it != node_end();) {
      int cnt = 1;
      int cnt2 = 0;
      long long sum2 = 0;
      if (auto it2 = it.get_r_child(); it2 != node_end()) {
        cnt2 = it2.get_metadata().cnt;
        sum2 = it2.get_metadata().sum;
      }
      if (cnt + cnt2 > k) {
        it = it.get_r_child();
      } else {
        ans += 1LL * (*it)->first * (*it)->second + sum2;
        k -= cnt + cnt2;
        it = it.get_l_child();
      }
    }
    return ans;
  }
};

class Solution {
public:
  vector<long long> findXSum(vector<int> &a, int k, int x) {
    int n = a.size();
    unordered_map<int, int> freq;
    tree<pair<int, int>, null_type, less<>, rb_tree_tag, node_update> tree;
    for (int i = 0; i < k - 1; i++) {
      tree.erase({freq[a[i]], a[i]});
      freq[a[i]]++;
      tree.insert({freq[a[i]], a[i]});
    }
    vector<long long> ans;
    for (int i = k - 1; i < n; i++) {
      tree.erase({freq[a[i]], a[i]});
      freq[a[i]]++;
      tree.insert({freq[a[i]], a[i]});
      ans.push_back(tree.query(x));
      tree.erase({freq[a[i - k + 1]], a[i - k + 1]});
      freq[a[i - k + 1]]--;
      tree.insert({freq[a[i - k + 1]], a[i - k + 1]});
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::findXSum); // CHANGE FOR PROBLEM
}
#endif",1420569153
Sam Huang,CelonyMire,192,3610,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
template <typename CItr, typename Itr, typename Cmp, typename Alloc>
struct node_update {
  typedef struct {
    int cnt = 0;
    long long sum = 0;
  } metadata_type;
  void operator()(Itr it, CItr end) {
    (int &)it.get_metadata().cnt = 1;
    (long long &)it.get_metadata().sum = 1LL * (*it)->first * (*it)->second;
    if (auto it2 = it.get_l_child(); it2 != end) {
      (int &)it.get_metadata().cnt += it2.get_metadata().cnt;
      (long long &)it.get_metadata().sum += it2.get_metadata().sum;
    }
    if (auto it2 = it.get_r_child(); it2 != end) {
      (int &)it.get_metadata().cnt += it2.get_metadata().cnt;
      (long long &)it.get_metadata().sum += it2.get_metadata().sum;
    }
  }
  virtual CItr node_begin() const = 0;
  virtual CItr node_end() const = 0;
  virtual ~node_update() {}
  long long query(int k) const {
    long long ans = 0;
    for (auto it = node_begin(); it != node_end();) {
      int cnt = 1;
      int cnt2 = 0;
      long long sum2 = 0;
      if (auto it2 = it.get_r_child(); it2 != node_end()) {
        cnt2 = it2.get_metadata().cnt;
        sum2 = it2.get_metadata().sum;
      }
      if (cnt + cnt2 > k) {
        it = it.get_r_child();
      } else {
        ans += 1LL * (*it)->first * (*it)->second + sum2;
        k -= cnt + cnt2;
        it = it.get_l_child();
      }
    }
    return ans;
  }
};

class Solution {
public:
  vector<int> findXSum(vector<int> &a, int k, int x) {
    int n = a.size();
    unordered_map<int, int> freq;
    tree<pair<int, int>, null_type, less<>, rb_tree_tag, node_update> tree;
    for (int i = 0; i < k - 1; i++) {
      tree.erase({freq[a[i]], a[i]});
      freq[a[i]]++;
      tree.insert({freq[a[i]], a[i]});
    }
    vector<int> ans;
    for (int i = k - 1; i < n; i++) {
      tree.erase({freq[a[i]], a[i]});
      freq[a[i]]++;
      tree.insert({freq[a[i]], a[i]});
      ans.push_back(tree.query(x));
      tree.erase({freq[a[i - k + 1]], a[i - k + 1]});
      freq[a[i - k + 1]]--;
      tree.insert({freq[a[i - k + 1]], a[i - k + 1]});
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::findXSum); // CHANGE FOR PROBLEM
}
#endif",1420571002
Rishabh Gurbani,rishabh-gurbani,195,3509,java,"import java.util.*;

class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> perfectSubtreeSizes = new ArrayList<>();
        checkPerfectSubtree(root, perfectSubtreeSizes);
        
        if (perfectSubtreeSizes.size() < k) {
            return -1;
        }
        
        Collections.sort(perfectSubtreeSizes, Collections.reverseOrder());
        return perfectSubtreeSizes.get(k - 1);
    }

    private int checkPerfectSubtree(TreeNode node, List<Integer> sizes) {
        if (node == null) {
            return 0;
        }
        
        int leftSubtreeSize = checkPerfectSubtree(node.left, sizes);
        int rightSubtreeSize = checkPerfectSubtree(node.right, sizes);
        
        if (node.left == null && node.right == null) {
            sizes.add(1);
            return 1;
        }
        
        if (leftSubtreeSize == rightSubtreeSize && leftSubtreeSize > 0) {
            int totalSize = leftSubtreeSize + rightSubtreeSize + 1;
            sizes.add(totalSize);
            return totalSize;
        }
        
        return 0;
    }
}
",1420528397
Rishabh Gurbani,rishabh-gurbani,195,3588,java,"import java.util.Arrays;

class Solution {
    public int countWinningSequences(String s) {
        int n = s.length();
        int zero = 0;
        int one = 1;
        int MOD = (int) 1e9 + 7;

        int[] charToIndex = new int[256];
        Arrays.fill(charToIndex, -1); 
        charToIndex['F'] = zero;
        charToIndex['W'] = one;
        charToIndex['E'] = one + one;
        charToIndex['X'] = one + one + one; 

        boolean[][] beats = new boolean[3][3];
        beats[zero][one + one] = true;  
        beats[one][zero] = true;        
        beats[one + one][one] = true;  

        int maxScoreDiff = n + n;
        int offset = n;

        int[][][] dp = new int[n + one][4][maxScoreDiff + one];
        dp[zero][3][offset] = one;

        for (int i = zero; i < n; ++i) {
            for (int lastBobMove = zero; lastBobMove < 4; ++lastBobMove) {
                for (int scoreDiff = zero; scoreDiff <= maxScoreDiff; ++scoreDiff) {
                    int ways = dp[i][lastBobMove][scoreDiff];
                    if (ways == zero) continue;

                    for (int bobMove = zero; bobMove < 3; ++bobMove) {
                        if (bobMove == lastBobMove) continue;

                        int aliceMove = charToIndex[s.charAt(i)];

                        int scoreChange = zero;
                        if (bobMove == aliceMove) {
                            scoreChange = zero;
                        } else if (beats[bobMove][aliceMove]) {
                            scoreChange = one;
                        } else if (beats[aliceMove][bobMove]) {
                            scoreChange = -one;
                        }

                        int newScoreDiff = scoreDiff + scoreChange;
                        if (newScoreDiff < zero || newScoreDiff > maxScoreDiff) continue;

                        dp[i + one][bobMove][newScoreDiff] = (dp[i + one][bobMove][newScoreDiff] + ways) % MOD;
                    }
                }
            }
        }

        int totalWays = zero;
        for (int lastBobMove = zero; lastBobMove < 3; ++lastBobMove) {
            for (int scoreDiff = offset + one; scoreDiff <= maxScoreDiff; ++scoreDiff) {
                totalWays = (totalWays + dp[n][lastBobMove][scoreDiff]) % MOD;
            }
        }

        return totalWays;
    }
}
",1420560357
Rishabh Gurbani,rishabh-gurbani,195,3592,java,"import java.util.*;

public class Solution {
    private Map<Integer, Integer> freq = new HashMap<>();
    private TreeSet<Map.Entry<Integer, Integer>> topElements = new TreeSet<>((a, b) -> {
        if (!a.getValue().equals(b.getValue())) {
            return b.getValue() - a.getValue();
        }
        return b.getKey() - a.getKey();
    });
    private TreeSet<Map.Entry<Integer, Integer>> restElements = new TreeSet<>((a, b) -> {
        if (!a.getValue().equals(b.getValue())) {
            return b.getValue() - a.getValue();
        }
        return b.getKey() - a.getKey();
    });
    private Map<Integer, Map.Entry<Integer, Integer>> positions = new HashMap<>();
    private long xSum = 0;
    private int x;

    public long[] findXSum(int[] nums, int k, int x) {
        this.x = x;
        int n = nums.length;
        long[] answer = new long[n - k + 1];

        // Populate initial window
        for (int i = 0; i < k; ++i) {
            int value = nums[i];
            freq.put(value, freq.getOrDefault(value, 0) + 1);
            if (positions.containsKey(value)) {
                removeElement(value);
            }
            insertElement(value);
        }

        answer[0] = xSum;

        // Slide over the window and compute x-sum
        for (int i = k; i < n; ++i) {
            int outValue = nums[i - k];
            int inValue = nums[i];

            removeElement(outValue);
            freq.put(outValue, freq.get(outValue) - 1);
            if (freq.get(outValue) > 0) {
                insertElement(outValue);
            } else {
                freq.remove(outValue);
            }

            freq.put(inValue, freq.getOrDefault(inValue, 0) + 1);
            if (positions.containsKey(inValue)) {
                removeElement(inValue);
            }
            insertElement(inValue);

            answer[i - k + 1] = xSum;
        }

        return answer;
    }

    private void insertElement(int value) {
        int count = freq.getOrDefault(value, 0);
        Map.Entry<Integer, Integer> element = new AbstractMap.SimpleEntry<>(value, count);

        restElements.add(element);
        positions.put(value, element);

        if (topElements.size() < x) {
            topElements.add(element);
            restElements.remove(element);
            positions.put(value, topElements.ceiling(element));
            xSum += (long) value * count;
        } else {
            Map.Entry<Integer, Integer> minTop = topElements.last();
            if (element.getValue() > minTop.getValue() || (element.getValue().equals(minTop.getValue()) && element.getKey() > minTop.getKey())) {
                topElements.add(element);
                restElements.remove(element);
                positions.put(value, topElements.ceiling(element));
                xSum += (long) value * count;

                restElements.add(minTop);
                positions.put(minTop.getKey(), restElements.ceiling(minTop));
                xSum -= (long) minTop.getKey() * minTop.getValue();
                topElements.remove(minTop);
            }
        }
    }

    private void removeElement(int value) {
        Map.Entry<Integer, Integer> element = positions.get(value);
        if (topElements.contains(element)) {
            xSum -= (long) value * element.getValue();
            topElements.remove(element);
        } else {
            restElements.remove(element);
        }
        positions.remove(value);

        if (topElements.size() < x && !restElements.isEmpty()) {
            Map.Entry<Integer, Integer> maxRest = restElements.first();
            topElements.add(maxRest);
            positions.put(maxRest.getKey(), topElements.ceiling(maxRest));
            xSum += (long) maxRest.getKey() * maxRest.getValue();
            restElements.remove(maxRest);
        }
    }
}
",1420605301
Rishabh Gurbani,rishabh-gurbani,195,3610,java,"import java.util.*;

class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] answer = new int[n - k + 1];
        
        for (int i = 0; i <= n - k; i++) {
            Map<Integer, Integer> freq = new HashMap<>();
            for (int j = i; j < i + k; j++) {
                freq.put(nums[j], freq.getOrDefault(nums[j], 0) + 1);
            }
            
            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> 
                b[1] != a[1] ? b[1] - a[1] : b[0] - a[0]);
            
            for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
                pq.offer(new int[]{entry.getKey(), entry.getValue()});
            }
            
            int sum = 0;
            for (int j = 0; j < x && !pq.isEmpty(); j++) {
                int[] top = pq.poll();
                sum += top[0] * top[1];
            }
            
            answer[i] = sum;
        }
        
        return answer;
    }
}",1420518737
ddiibboo,ddiibboo,196,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    List<Integer> rc;

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        rc = new ArrayList<>();
        dfs(root);
        Collections.sort(rc);
        if (k > rc.size()) return -1;
        return rc.get(rc.size() - k);
    }

    private int dfs(TreeNode node) {
        if (node == null) return 0;
        int l = dfs(node.left);
        int r = dfs(node.right);
        if (l >= 0 && r >= 0 && l == r) {
            rc.add((1 << (l + 1)) - 1);
            return l + 1;
        }
        return -1;
    }
}",1420535396
ddiibboo,ddiibboo,196,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int n = s.length();
        int[] A = new int[n];
        for (int i = 0; i < n; ++i) A[i] = idx(s.charAt(i));
        int base = n + 5;
        int[][][] dp = new int[n][3][base * 2];
        dp[0][A[0]][base] = 1;
        dp[0][(A[0] + 1) % 3][base + 1] = 1;
        dp[0][(A[0] + 2) % 3][base - 1] = 1;

        for (int i = 1; i < n; ++i) {
            int x = A[i];
            for (int j = 0; j < 3; ++j) {
                int y = comp(j, x);
                for (int k = base - i - 1; k <= base + i + 1; ++k) {
                    for (int l = 0; l < 3; ++l) {
                        if (j == l) continue;
                        dp[i][j][k] += dp[i - 1][l][k - y];
                        dp[i][j][k] %= 1000000007;
                    }
                    // System.out.println(String.format(""dp[%d][%d][%d] = %d"", i, j, k - base, dp[i][j][k]));
                }
            }
        }

        int ans = 0;
        for (int i = base + 1; i <= base + n; ++i) {
            for (int j = 0; j < 3; ++j) { 
                ans = (ans + dp[n - 1][j][i]) % 1000000007;
            }
        }
        return ans;
    }

    private int idx(char c) {
        if (c == 'F') return 0;
        if (c == 'W') return 1;
        return 2;
    }

    private int comp(int a, int b) {
        if (a == b) return 0;
        if ((a + 1) % 3 == b) return -1;
        return 1;
    }
}",1420579152
ddiibboo,ddiibboo,196,3592,java,"class Solution {

    class RC implements Comparable<RC> {
        int val, cnt;
        RC(int v, int c) {
            val = v;
            cnt = c;
        }

        public int compareTo(RC o) {
            if (cnt != o.cnt) return cnt - o.cnt;
            return val - o.val;
        }

        public String toString() {
            return String.format(""[val = %d, cnt = %d]"", val, cnt);
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] ans = new long[n - k + 1];

        Map<Integer, Integer> cnt = new HashMap<>();
        TreeSet<RC> s1 = new TreeSet<>();
        TreeSet<RC> s2 = new TreeSet<>();
        long sum = 0;
        long xSum = 0;

        for (int i = 0; i < n; ++i) {
            sum += nums[i];
            int curCnt = cnt.getOrDefault(nums[i], 0);
            cnt.put(nums[i], curCnt + 1);
            RC tmp = new RC(nums[i], curCnt);
            if (s1.contains(tmp)) {
                s1.remove(tmp);
                s1.add(new RC(nums[i], curCnt + 1));
                xSum += nums[i];
            } else {
                s2.remove(tmp);
                s1.add(new RC(nums[i], curCnt + 1));
                xSum += 1L * nums[i] * (curCnt + 1);
                while (s1.size() > x) {
                    RC l = s1.removeFirst();
                    xSum -= 1L * l.val * l.cnt;
                    s2.add(l);
                }
            }

            // System.out.println(s1);
            // System.out.println(s2);

            if (i >= k - 1) {
                ans[i - k + 1] = s1.size() == x ? xSum : sum;
                int v = nums[i - k + 1];
                sum -= v;
                curCnt = cnt.get(v);
                
                if (curCnt > 1) cnt.put(v, curCnt - 1);
                else cnt.remove(v);

                tmp = new RC(v, curCnt);
                if (s2.contains(tmp)) {
                    s2.remove(tmp);
                    if (curCnt > 1) s2.add(new RC(v, curCnt - 1)); 
                } else {
                    s1.remove(tmp); xSum -= 1L * v * curCnt;
                    if (curCnt > 1) s2.add(new RC(v, curCnt - 1)); 
                    while (s1.size() < x && s2.size() > 0) {
                        RC r = s2.removeLast();
                        s1.add(r);
                        xSum += 1L * r.val * r.cnt;
                    }
                }
            }
        }

        return ans;
    }
}",1420617563
ddiibboo,ddiibboo,196,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int[] ans = new int[nums.length - k + 1];
        for (int i = 0; i < ans.length; ++i) {
            ans[i] = xSum(nums, i, i + k - 1, x);
        }
        return ans;
    }

    private int xSum(int[] nums, int l, int r, int x) {
        Map<Integer, Integer> cnt = new HashMap<>();
        int ans = 0;
        for (int i = l; i <= r; ++i) {
            cnt.put(nums[i], cnt.getOrDefault(nums[i], 0) + 1);
            ans += nums[i];
        }
        if (cnt.size() < x) {
            return ans;
        }
        ans = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if (a[1] != b[1]) return b[1] - a[1];
            return b[0] - a[0];
        }); 
        for (Map.Entry<Integer, Integer> e : cnt.entrySet()) {
            pq.add(new int[]{e.getKey(), e.getValue()});
        }
        int tot = r - l + 1;

        for (int i = 0; i < x; ++i) {
            int[] t = pq.poll();
            // System.out.println(t[0] + "", "" + t[1]);
            ans += t[0] * Math.min(tot, t[1]);
        }
        // System.out.println(""----------------"");
        return ans;
    }
}",1420529228
QzjkuhhQ17,QzjkuhhQ17,198,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> v;
        auto dfs = [&](auto self,TreeNode* t)->pair<int,bool>{
          if(!t) return {0,true};
            auto [hl,gl] = self(self,t->left);
            auto [hr,gr] = self(self,t->right);
            if(hl==hr&&gl&&gr){
                v.push_back(hl+1);
                return {hl+1,true};
            } else {
                return {-1,false};
            }
        };
        dfs(dfs,root);
        //cout << v.size();
        sort(v.begin(),v.end(),greater<>());
        if(v.size() >= k) return (1<<v[k-1])-1;
        else return -1;
    }
};",1420529731
QzjkuhhQ17,QzjkuhhQ17,198,3588,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
class Solution {
public:
    int countWinningSequences(string s) {
        using num=modnum<1'000'000'007>;
        int n=s.size();
        vector<vector<array<num,3>>> dp(n,vector<array<num,3>>(2*n+1));
        vector<int> v(n);
        for(int i=0;i<n;i++) v[i]=s[i]=='F'?0:s[i]=='W'?1:2;
        auto duel = [](int x,int y){
            return x==y?0:x==((y+1)%3)?-1:1;
        };
        for(int i=0;i<3;i++) dp[0][duel(v[0],i)+n][i]=1;
        for(int i=0;i+1<n;i++){
            for(int j=-(i+1);j<=(i+1);j++){
                for(int k=0;k<3;k++){
                    for(int t=0;t<3;t++){
                        if(t==k) continue;
                        dp[i+1][j+duel(v[i+1],t)+n][t]+=dp[i][j+n][k];
                    }
                }
            }
        }
        num re=0;
        for(int i=n+1;i<2*n+1;i++) 
            for(int j=0;j<3;j++)re+=dp.back()[i][j];
        return (int)re;
    }
};",1420577828
QzjkuhhQ17,QzjkuhhQ17,198,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        using ll = long long;
        set<pair<int,int>,greater<>> tx,ty;
        map<int,int> m;
        ll re =0;
        auto insert =[&](pair<int,int> p){
              if(tx.size() < x || *tx.rbegin() < p){
                  if(tx.size() ==x){
                      auto k = prev(tx.end());
                      re-=(ll)k->first*k->second;
                    ty.insert(*k);
                      tx.erase(k);
                   }
                  tx.insert(p);
                  re+=(ll)p.first*p.second;
              } else {
                  ty.insert(p);
              }
        };
        auto erase =[&](pair<int,int> p){
            auto px = tx.find(p);
            if(px!=tx.end()){
                re-=(ll)p.first*p.second;
                tx.erase(px);
                if(!ty.empty()){
                    auto k = ty.begin();
                    re+=(ll)k->first * k->second;
                    tx.insert(*k);
                    ty.erase(k);
                }
            } else {
                ty.erase(p);
            }
        };
        auto add = [&](int u){
            auto& p=m[u];
            pair<int,int> temp{p,u};
            if(p){
                erase(temp);
            }
            p++;
            temp.first++;
            insert(temp);
        };
        auto del =[&](int u){
            auto& p=m[u];
            pair<int,int> temp{p,u};
            assert(p);
            erase(temp);
            p--;
            if(p){
                temp.first--;
                insert(temp);
            }
        };
        vector<ll> res;
        for(int i=0;i<nums.size();i++){
            add(nums[i]);
            if(i>=k-1){
                cout << re << endl;
                res.push_back(re);
                del(nums[i-k+1]);
            }
        }
        return res;
    }
};",1420606208
QzjkuhhQ17,QzjkuhhQ17,198,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> re;
        for(int i=k-1;i<nums.size();i++){
            map<int,int> m;
            for(int j=0;j<k;j++) m[nums[i-j]]++;
            vector<pair<int,int>> v(m.begin(),m.end());
            sort(v.begin(),v.end(),[](auto a,auto b){
                return a.second==b.second?a.first>b.first:a.second>b.second;
            });
            int su=0;
            for(int j=0;j<x && j<v.size();j++)su+=v[j].first * v[j].second;
            re.push_back(su);
        }
        return re;
    }
};",1420523676
Abhay Upadhyay,hewhocodes,199,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int recur(TreeNode* root,auto& ms){
        if(!root) return 0;
        if((root->left==nullptr)^(root->right==nullptr)){
            recur(root->left,ms);
            recur(root->right,ms);
            return -1;
        }
        int ans1 = recur(root->left,ms);
        int ans2 = recur(root->right,ms);
        if(ans2==ans1){
            ms.insert(ans1+ans2+1);
            return ans1+ans2+1;
        }
        return -1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        multiset<int,greater<int>> ms;
        recur(root,ms);
        // for(auto &e:ms){
        //     cout<<e<<endl;
        // }
        while(--k && ms.size()){
            ms.erase(ms.begin());
        }
        if(ms.size())
        return *ms.begin();
        return -1;
    }
};",1420531845
Abhay Upadhyay,hewhocodes,199,3588,cpp,"using ll = long long;
const int M = 1000000007;
class Solution {
public:
    int netdiff[3][3];
    int dp[1001][2030][3];
    Solution(){
        netdiff[0][0] = 0;
        netdiff[0][1] = -1;
        netdiff[0][2] = 1;
        netdiff[1][1] = 0;
        netdiff[1][2] = -1;
        netdiff[1][0] = 1;
        netdiff[2][2] = 0;
        netdiff[2][0] = -1;
        netdiff[2][1] = 1;
    }
    ll ways(string& s,char prev,ll idx,ll diff){
        if(idx>=s.length()){
            return diff<=0;
        }
        // cout<<s[idx]<<endl;
        if(idx && dp[idx][diff+1010][prev-'a']!=-1) return dp[idx][diff+1010][prev-'a'];
        if(prev=='a'){
            return dp[idx][diff+1010][prev-'a']=(((ways(s,'b',idx+1,diff+netdiff[s[idx]-'a'][1])%M)+(ways(s,'c',idx+1,diff+netdiff[s[idx]-'a'][2])%M))%M);
        }else if(prev=='b'){
            return dp[idx][diff+1010][prev-'a']=(((ways(s,'a',idx+1,diff+netdiff[s[idx]-'a'][0])%M)+(ways(s,'c',idx+1,diff+netdiff[s[idx]-'a'][2])%M))%M);
        }else if(prev=='c'){
            return dp[idx][diff+1010][prev-'a']=(((ways(s,'a',idx+1,diff+netdiff[s[idx]-'a'][0])%M)+(ways(s,'b',idx+1,diff+netdiff[s[idx]-'a'][1])%M))%M);
        }
        return (((ways(s,'a',idx+1,diff+netdiff[s[idx]-'a'][0])%M)+(ways(s,'b',idx+1,diff+netdiff[s[idx]-'a'][1])%M))%M+(ways(s,'c',idx+1,diff+netdiff[s[idx]-'a'][2])%M))%M;
    }
    int countWinningSequences(string s) {
        //a defeats c, b defeats a, c defeats b
        memset(dp,-1,sizeof(dp));
        for(auto &e:s){
            if(e=='F') e = 'a';
            else if(e=='W') e = 'b';
            else e = 'c';
        }
        return ways(s,' ',0,1);
    }
};",1420606275
Abhay Upadhyay,hewhocodes,199,3592,cpp,"using ll = long long;
#include<ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template<typename T,typename Compare = greater<T>>
using indexed_set = __gnu_pbds::tree<T,__gnu_pbds::null_type,Compare,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        indexed_set<pair<ll,ll>> st;
        set<pair<ll,ll>> inv;
        ll sum = 0;
        ll n = nums.size();
        vector<ll> ans;
        for(int i=0;i<min(1ll*k,n);i++){
            // cout<<sum<<endl;
            // for(auto &e:inv){
            //     cout<<e.first<<"":""<<e.second<<"" "";
            // }
            // cout<<endl;
            auto iter = inv.lower_bound({nums[i],-1});
            pair<ll,ll> it;
            if(iter!=inv.end()){
                it = *iter;
            }else it.first=nums[i]+1;  
            if(it.first==nums[i]){
                st.insert({it.second+1,it.first});
                inv.insert({it.first,it.second+1});
                {
                    ll pos = st.order_of_key({it.second+1,it.first});
                    if(pos+1<=x){
                        sum = sum+((it.first)*(it.second+1));
                        if(st.size()>x){
                            auto rem = st.find_by_order(x);
                            sum = sum-((rem->second)*(rem->first));
                        }
                    }
                }
                {
                    ll pos = st.order_of_key({it.second,it.first});
                    if(pos+1<=x){
                        sum = sum-((it.first)*(it.second));
                        if(st.size()>x){
                            auto rem = st.find_by_order(x);
                            sum = sum+((rem->second)*(rem->first));
                        }
                    }
                }
                st.erase({it.second,it.first});
                inv.erase(it);
            }else{
                st.insert({1,nums[i]});
                inv.insert({nums[i],1});
                ll pos = st.order_of_key({1,nums[i]});
                if(pos+1<=x){
                    sum = sum+(nums[i]);
                    if(st.size()>x){
                        auto rem = st.find_by_order(x);
                        sum = sum-((rem->second)*(rem->first));
                    }
                }
            }
        }
        ans.push_back(sum);
        for(int i=k;i<n;i++){
            //insert
            {
                auto iter = inv.lower_bound({nums[i],-1});
                pair<ll,ll> it;
                if(iter!=inv.end()){
                    it = *iter;
                }else it.first=nums[i]+1;  
                if(it.first==nums[i]){
                    st.insert({it.second+1,it.first});
                    inv.insert({it.first,it.second+1});
                    {
                        ll pos = st.order_of_key({it.second+1,it.first});
                        if(pos+1<=x){
                            sum = sum+((it.first)*(it.second+1));
                            if(st.size()>x){
                                auto rem = st.find_by_order(x);
                                sum = sum-((rem->second)*(rem->first));
                            }
                        }
                    }
                    {
                        ll pos = st.order_of_key({it.second,it.first});
                        if(pos+1<=x){
                            sum = sum-((it.first)*(it.second));
                            if(st.size()>x){
                                auto rem = st.find_by_order(x);
                                sum = sum+((rem->second)*(rem->first));
                            }
                        }
                    }
                    st.erase({it.second,it.first});
                    inv.erase(it);
                }else{
                    st.insert({1,nums[i]});
                    inv.insert({nums[i],1});
                    ll pos = st.order_of_key({1,nums[i]});
                    if(pos+1<=x){
                        sum = sum+(nums[i]);
                        if(st.size()>x){
                            auto rem = st.find_by_order(x);
                            sum = sum-((rem->second)*(rem->first));
                        }
                    }
                }
            }
            //erase
            {
                auto it = *inv.lower_bound({nums[i-k],-1});
                st.insert({it.second-1,it.first});
                inv.insert({it.first,it.second-1});
                {
                    ll pos = st.order_of_key({it.second-1,it.first});
                    if(pos+1<=x){
                        sum = sum+((it.first)*(it.second-1));
                        if(st.size()>x){
                            auto rem = st.find_by_order(x);
                            sum = sum-((rem->second)*(rem->first));
                        }
                    }
                }
                {
                    ll pos = st.order_of_key({it.second,it.first});
                    if(pos+1<=x){
                        sum = sum-((it.first)*(it.second));
                        if(st.size()>x){
                            auto rem = st.find_by_order(x);
                            sum = sum+((rem->second)*(rem->first));
                        }
                    }
                }
                st.erase({it.second,it.first});
                inv.erase(it);
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420580118
Abhay Upadhyay,hewhocodes,199,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        int n = nums.size();
        for(int i=0;i+k-1<=n-1;i++){
            map<int,int> mp;
            for(int j=i;j<=i+k-1;j++){
                mp[nums[j]]++;
            } 
            set<pair<int,int>,greater<pair<int,int>>> v;
            for(auto &e:mp) v.insert({e.second,e.first});
            int sum = 0, cnt = 0;
            while(cnt<x && v.size()){
                cout<<v.begin()->first<<"" ""<<(v.begin()->second)<<endl;
                sum+=(v.begin()->second)*(v.begin()->first);
                cnt++;
                v.erase(v.begin());
            }
            // cout<<endl;
            res.push_back(sum);
        }
        return res;
    }
};",1420522777
tanay3404,tanay3404,200,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int x;
int x2;
map<int,int> m1;
void as(TreeNode *y,int y1){
    x2++;
    if(!y->left&&y->right){
        x=1;
        return;
    }
    if(y->left&&!y->right){
        x=1;
        return;
    }
    if(y->left){
    as(y->left,y1+1);
    as(y->right,y1+1);}
    else{
        m1[y1]++;
    }


}
priority_queue<int> p1;
void dfs(TreeNode* root){
    if(!root){
        return;
    }
    x=0;
    x2=0;
    m1.clear();
    as(root,0);
    if(x!=1){
        if(m1.size()==1){
        p1.push(x2);}
    }
    dfs(root->left);
    dfs(root->right);

}
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        while(!p1.empty()){
            p1.pop();
        }
        dfs(root);
        int x=p1.size();
        if(x<k){
            return -1;
        }
        k--;
        while(k>0){
            p1.pop();
            k--;

        }
        return p1.top();
    }
};",1420534701
tanay3404,tanay3404,200,3588,cpp,"class Solution {
public:
long long int dp[1000][1504][4];
long long int ans(int i,int c,string &s,int f,map<char,int> &m1){
    if(i==s.length()){
        if(c>=1&&c<=1000){
            return 1;
        }
        return 0;
    }
    if(c>=1001){
        int x=s.length();
        if(c-1000>(x/2)){
            return 0;
        }
    }
    if(dp[i][c][f]!=-1){
        return dp[i][c][f];
    }
    int r1=m1[s[i]];
    int x=(r1+1)%3;
    long long int ans1=0;
    if(x!=f){
        int c1=c;
        if(c1>=1001){
            c1--;
        if(c1==1000){
            c1=0;
        }
        }
        else{
            c1++;
        }
 

        ans1=(ans1+ans(i+1,c1,s,x,m1))%1000000007;

    }
    if(r1!=f){
         ans1=(ans1+ans(i+1,c,s,r1,m1))%1000000007;

    }
    r1--;
    if(r1<0){
        r1=2;
    }
    if(r1!=f){
        int c1=c;
        if(c1<=1000){
            c1--;
            if(c1<0){
                c1=1001;

            }
        }
        else{
            c1++;
        }

        ans1=(ans1+ans(i+1,c1,s,r1,m1))%1000000007;

    }
    return dp[i][c][f]=ans1;
}
    int countWinningSequences(string s) {
        map<char,int> m1;
        memset(dp,-1,sizeof(dp));
       
        m1['W']=0;
        m1['E']=1;
        m1['F']=2;
        return ans(0,0,s,3,m1);
        
    }
};",1420556456
tanay3404,tanay3404,200,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int j=0;
        map<long long int,long long int> m1;

        while(j<k){
            m1[nums[j]]++;

            j++;
        }
        priority_queue<vector<long long int>> p1;
        for(auto it:m1){
            p1.push({it.second,it.first});

        }
        set<vector<long long int>> s1,s2;
        int j1=x;
        long long int sum1=0;
        
        while(j1>0&&!p1.empty()){
     
            s1.insert({p1.top()[0],p1.top()[1]});
            sum1=sum1+p1.top()[0]*p1.top()[1];
            p1.pop();
            j1--;
        }
        while(!p1.empty()){
             s2.insert({-p1.top()[0],-p1.top()[1]});
            p1.pop();

        }
        vector<long long int> ans;
        ans.push_back(sum1);
        int l=0;
        int r=j;
        while(r<nums.size()){
            if(nums[r]==nums[l]){
                    ans.push_back(sum1);
                r++;
                l++;
            }
            else{
         
                if(s1.find({m1[nums[l]],nums[l]})!=s1.end()){
                    
                    s1.erase({m1[nums[l]],nums[l]});
                    sum1=sum1-(m1[nums[l]]*nums[l]);
                }
                else{
                    s2.erase({-m1[nums[l]],-nums[l]});
                }
                  m1[nums[l]]--;
                if(s1.find({m1[nums[r]],nums[r]})!=s1.end()){
                   
                    s1.erase({m1[nums[r]],nums[r]});
                    sum1=sum1-(m1[nums[r]]*nums[r]);
                }
                else{
                    s2.erase({-m1[nums[r]],-nums[r]});
                }
                m1[nums[r]]++;
                s2.insert({-m1[nums[r]],-nums[r]});
                s2.insert({-m1[nums[l]],-nums[l]});
                int x1=s1.size();
           
                while(x1<x&&!s2.empty()){
                    vector<long long int> yu=*s2.begin();
                    s2.erase(s2.begin());
                 
                    sum1=sum1+(-yu[0]*(-yu[1]));
                    s1.insert({-yu[0],-yu[1]});
                    x1++;

                }
                while(!s2.empty()){
                    vector<long long int> yu=*s2.begin();
                    vector<long long int> yi=*s1.begin();
                    if(-yu[0]>yi[0]){
                        s1.erase(s1.begin());
                        sum1=sum1-(yi[0]*yi[1]);
                        sum1=sum1+(-yu[0]*(-yu[1]));
                        s2.erase(s2.begin());
                        s1.insert({-yu[0],-yu[1]});
                        s2.insert({-yi[0],-yi[1]});


                    }
                    else{
                        if(-yu[0]==yi[0]&&-yu[1]>yi[1]){
                                               s1.erase(s1.begin());
                        sum1=sum1-(yi[0]*yi[1]);
                        sum1=sum1+(-yu[0]*(-yu[1]));
                        s2.erase(s2.begin());
                        s1.insert({-yu[0],-yu[1]});
                        s2.insert({-yi[0],-yi[1]});


                        }
                        else{
                            break;
                        }
                    }

                }
                ans.push_back(sum1);
                r++;
                l++;

            }
        }
        return ans;

    }
};",1420606276
tanay3404,tanay3404,200,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int j=0;
        map<int,int> m1;
        while(j<k){
            m1[nums[j]]++;


            j++;
        }
    
            vector<int> ans;
        priority_queue<vector<int>> g2;
    
for(auto it:m1){
    g2.push({it.second,it.first});

}
    int x1=x;
    int sum1=0;
    while(x1&&!g2.empty()){
        sum1=sum1+(g2.top()[0]*g2.top()[1]);
        g2.pop();
        x1--;
    }
    ans.push_back(sum1);

        int l=0;
        while(j<nums.size()){
            m1[nums[l]]--;
            if(m1[nums[l]]==0){
                m1.erase(nums[l]);
            }
            m1[nums[j]]++;
             priority_queue<vector<int>> g2;
            for(auto it:m1){
    g2.push({it.second,it.first});

}
    int x1=x;
    int sum1=0;
    while(x1&&!g2.empty()){
        sum1=sum1+(g2.top()[0]*g2.top()[1]);
        g2.pop();
        x1--;
    }
    ans.push_back(sum1);

l++;
            j++;
        }
        return ans;
    }
};",1420524393
Xiaoyu Wang,wxy9018,201,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_roots = []
        
        def dfs(node):
            if not node:
                return True, 0
            # return (is_perfect, cnt)
            L_perfect, L_cnt = dfs(node.left)
            R_perfect, R_cnt = dfs(node.right)
            
            is_perfect = L_perfect and R_perfect and (L_cnt == R_cnt)
            cnt = L_cnt + R_cnt + 1
            
            if is_perfect:
                perfect_roots.append(cnt)
            
            return is_perfect, cnt
        
        dfs(root)
        
        perfect_roots.sort(reverse=True)
        
        #print(perfect_roots)
        
        return perfect_roots[k-1] if len(perfect_roots) >= k else -1
        
            ",1420527905
Xiaoyu Wang,wxy9018,201,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        
        dp = {(0, 'A'):1}
        
        TO_WIN = {""F"": ""W"", ""W"": ""E"", ""E"": ""F""}
        TO_LOSE = {""W"": ""F"", ""F"": ""E"", 'E': ""W""}
        
        for i in range(len(s)):
            dp1 = collections.Counter()
            for score, action in dp: # ""score"" is the relative score between A and B
                # either to keep it as is
                if action != s[i]:
                    dp1[score, s[i]] += dp[score, action]
                    
                # or to increment it by 1
                if action != TO_WIN[s[i]]:
                    dp1[score+1, TO_WIN[s[i]]] += dp[score, action]
                    
                # or to decrement it by 1
                if action != TO_LOSE[s[i]]:
                    dp1[score-1, TO_LOSE[s[i]]] += dp[score, action]
                    
            for key in dp1:
                dp1[key] = dp1[key] % MOD
            
            dp = dp1
            #print(dp)
        
        res = 0
        for key, action in dp:
            if key > 0:
                res = (res + dp[key, action]) % MOD
        
        return res",1420544204
Xiaoyu Wang,wxy9018,201,3592,python3,"import sortedcontainers
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        freq = sortedcontainers.SortedList()
        res = []
        
        # Get the first partial sum
        cnt = collections.Counter(nums[:k])
        for v in cnt:
            freq.add([cnt[v], v])
        summ = 0
        for i in reversed(range(max(0, len(freq) - x), len(freq))):
            summ += freq[i][0] * freq[i][1]
        res.append(summ)
        
        #print(cnt, summ, freq)
        
        # Get the rest partial sums
        for i in range(k, len(nums)):
            # Get rid of the first element
            v = nums[i-k]
            f = cnt[v]
            pos = freq.bisect_left([f, v])
            nth = len(freq) - pos
            cnt[v] -= 1
            freq.pop(pos)
            if f > 1:
                freq.add([f-1, v])
                
            #print(pos)
            
            if nth <= x:
                # this is an element that was counted in summ
                summ -= f * v
                new_pos = freq.bisect_left([f-1, v])
                if f > 1 and len(freq) - new_pos <= x: # after removing one element, this is still top x
                    summ += (f-1) * v
                elif x <= len(freq):
                    summ += freq[-x][0] * freq[-x][1]
            
            #print('A', cnt, summ, freq)
            
            
            # Add the last element
            new_v =  nums[i]
            new_f = cnt[new_v]
            
            # print(freq)
            
            pos2 = freq.bisect_left([new_f, new_v])
            nth2 = len(freq) - pos2
            if new_f > 0:
                freq.pop(pos2)
            
            #print(new_v, new_f, nth2, pos2)
            
            cnt[new_v] += 1
            freq.add([new_f+1, new_v])
            
            new_pos2 = freq.bisect_left([new_f+1, new_v])
            if len(freq) - new_pos2 <= x:
                # this is an element that need to be counted in summ
                summ += (new_f+1) * new_v
                if new_f > 0 and nth2 <= x: # this was also an element counted before
                    #print('H')
                    summ -= new_f * new_v
                
                elif x+1 <= len(freq): # Another element will be removed
                    # print(freq)
                    summ -= freq[-x-1][0] * freq[-x-1][1]
            
            #print('B', cnt, summ, freq)
            
            res.append(summ)
            
        return res",1420612188
Xiaoyu Wang,wxy9018,201,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(k, len(nums) + 1):
            cnt = collections.Counter(nums[i - k:i])
            freq = [[cnt[v], v] for v in cnt.keys()]
            freq.sort(reverse = True)
            
            #print(cnt, freq)
            
            summ = 0
            for p in range(min(x, len(freq))):
                f, v = freq[p]
                summ += f * v
            res.append(summ)
        return res",1420521406
Arayi Khalatyan,arayi,202,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> fp;
    int dfs(TreeNode* r) {
        if (r == NULL) return 0;
        int a = dfs(r->left);
        int b = dfs(r->right);
        if(a<0||b<0) return -1;
        if(a == b) fp.push_back(a+b+1);
        else if (a!=b) return -1;
        return a+b+1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(fp.begin(), fp.end());
        reverse(fp.begin(), fp.end());
        if(fp.size() < k) return -1;
        return fp[k-1];
    }
};",1420521620
Arayi Khalatyan,arayi,202,3588,cpp,"const int N = 1002;
int a[3][3] = {{0, -1, 1}, {1, 0, -1}, {-1, 1, 0}};

const long long mod = 1e9 + 7;
class Solution {
public:
    int sm[200];
    long long dp[N][3][N + N];
    int countWinningSequences(string s) {
        sm['F'] = 0, sm['W'] = 1, sm['E'] = 2;
        for (int i = 0; i < 3; i++) {
            dp[0][i][N + a[i][sm[s[0]]]] = 1;
        }
        for (int i = 1; i < s.size(); i++) {
            int p = sm[s[i]];
            for (int j = 0; j < 3; j++) {
                for (int x = N - i; x <= N + i; x++) {
                    for (int k = 0; k < 3; k++) {
                        if (k == j)
                            continue;
                        dp[i][j][x + a[j][p]] += dp[i - 1][k][x];
                        dp[i][j][x + a[j][p]] %= mod;
                    }
                }
            }
        }
        long long ans = 0;
        for (int x = N + 1; x < N + N; x++) {
            for (int i = 0; i < 3; i++) {
                ans += dp[s.size() - 1][i][x];
                ans %= mod;
            }
        }
        return ans;
    }
};",1420606779
Arayi Khalatyan,arayi,202,3592,cpp,"
#define fr first
#define sc second
#define ad push_back
class Solution {
public:
    map<int, int> mp;
    vector<long long> fp;
    set<pair<int, int>> sm, s;
    int n;
    long long sum = 0;
    void check() {
        if (sm.size() < n) {
            if (s.size()) {
                auto i1 = s.end();
                --i1;
                sm.insert(*i1);
                sum += (*i1).fr * 1LL * (*i1).sc;
                s.erase(i1);
            }
        } else if (s.size()) {
            auto i1 = sm.begin();
            auto i2 = s.end();
            --i2;
            if ((*i2) > (*i1)) {
                sum += (*i2).fr * 1LL * (*i2).sc;
                sum -= (*i1).fr * 1LL * (*i1).sc;
                auto ii1 = *i1;
                auto ii2 = *i2;
                sm.insert(ii2);
                s.insert(ii1);
                sm.erase(ii1);
                s.erase(ii2);
            }
        }
    }
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        n = x;
        for (int i = 0; i < k; i++) {
            mp[a[i]]++;
        }
        for (int i = 0; i < k; i++) {
            s.insert({mp[a[i]], a[i]});
        }
        for (int i = 0; i < k; i++) {
            check();
        }
        fp.ad(sum);
        for (int i = 1; i <= a.size() - k; i++) {
            int p = a[i - 1];
            if (sm.find({mp[p], p}) != sm.end())
                sum -= mp[p] * 1LL * p;
            sm.erase({mp[p], p});
            s.erase({mp[p], p});
            mp[p]--;
            s.insert({mp[p], p});
            check();
            p = a[i + k - 1];
            if (sm.find({mp[p], p}) != sm.end())
                sum -= mp[p] * 1LL * p;
            sm.erase({mp[p], p});
            s.erase({mp[p], p});
            mp[p]++;
            s.insert({mp[p], p});
            check();
            fp.ad(sum);
        }
        return fp;
    }
};",1420604270
Arayi Khalatyan,arayi,202,3610,cpp,"
#define fr first
#define sc second
#define ad push_back
class Solution {
public:
    map<int, int> mp;
    vector<int> fp;
    set<pair<int, int>> sm, s;
    int n;
    long long sum = 0;
    void check() {
        if (sm.size() < n) {
            if (s.size()) {
                auto i1 = s.end();
                --i1;
                sm.insert(*i1);
                sum += (*i1).fr * 1LL * (*i1).sc;
                s.erase(i1);
            }
        } else if (s.size()) {
            auto i1 = sm.begin();
            auto i2 = s.end();
            --i2;
            if ((*i2) > (*i1)) {
                sum += (*i2).fr * 1LL * (*i2).sc;
                sum -= (*i1).fr * 1LL * (*i1).sc;
                auto ii1 = *i1;
                auto ii2 = *i2;
                sm.insert(ii2);
                s.insert(ii1);
                sm.erase(ii1);
                s.erase(ii2);
            }
        }
    }
    vector<int> findXSum(vector<int>& a, int k, int x) {
        n = x;
        for (int i = 0; i < k; i++) {
            mp[a[i]]++;
        }
        for (int i = 0; i < k; i++) {
            s.insert({mp[a[i]], a[i]});
        }
        for (int i = 0; i < k; i++) {
            check();
        }
        fp.ad(sum);
        for (int i = 1; i <= a.size() - k; i++) {
            int p = a[i - 1];
            if (sm.find({mp[p], p}) != sm.end())
                sum -= mp[p] * 1LL * p;
            sm.erase({mp[p], p});
            s.erase({mp[p], p});
            mp[p]--;
            s.insert({mp[p], p});
            check();
            p = a[i + k - 1];
            if (sm.find({mp[p], p}) != sm.end())
                sum -= mp[p] * 1LL * p;
            sm.erase({mp[p], p});
            s.erase({mp[p], p});
            mp[p]++;
            s.insert({mp[p], p});
            check();
            fp.ad(sum);
        }
        return fp;
    }
};",1420605355
Arjun S,arjun_06_s,203,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    vector<int> arr;

    int util(TreeNode* root){
        if(!root) return 0;

        int l = util(root->left);
        int r = util(root->right);
        if(l!=r or l==-1 or r==-1) return -1;
        arr.push_back(l + r + 1);
        return l + r + 1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        util(root);
        sort(arr.begin(), arr.end(), greater<int>());
        
        if(arr.size() < k) return -1;
        return arr[k-1];
    }
};",1420526430
Arjun S,arjun_06_s,203,3588,cpp,"class Solution {
public:

    long long mod = 1e9 + 7;
    long long dp[1000][2001][3];

    long long result(char a, char b){
        if(a==b) return 0;
        if(a=='F' and b=='E') return -1;
        if(a=='W' and b=='F') return -1;
        if(a=='E' and b=='W') return -1;
        return 1;
    }

    long long util(long long ind, long long points, string& s, char prev){

        long long state3 = 0;
        if(prev == 'F') state3 = 1;
        else if(prev == 'W') state3 = 2;

        if(ind == s.length()) return points>0;
        if(dp[ind][points + 1000][state3] != -1) return dp[ind][points + 1000][state3]; 

        long long one = util(ind+1, points + result(s[ind], 'F'), s, 'F');
        long long two = util(ind+1, points + result(s[ind], 'W'), s, 'W');
        long long three = util(ind+1, points + result(s[ind], 'E'), s, 'E');
        if(prev == 'F') one = 0;
        if(prev == 'W') two = 0;
        if(prev == 'E') three = 0;
        long long ans = (one + two + three) % mod;

        return dp[ind][points+1000][state3] = ans;

    }

    long long countWinningSequences(string s) {
        long long n = s.length();
        memset(dp, -1, sizeof(dp));
        return util(0, 0, s, '?');
    }
};",1420606942
Arjun S,arjun_06_s,203,3592,cpp,"class Solution {
public:

    vector<long long> findXSum(vector<int>& nums, long long k, long long xx) {

        using pii = pair<long long, long long>;
        unordered_map<long long, long long> freq;

        multiset<pii> topk, rem;
        long long sum = 0;

        auto debug = [&](long long i){
            
        cout<<""at i = ""<<i<<endl;
        cout<<""topk = ""<<endl;
for(auto& p: topk){
            cout<<p.first<<"" ""<<p.second<<endl;
        }
        cout<<endl;        cout<<""rem = ""<<endl;
for(auto& p: rem){
            cout<<p.first<<"" ""<<p.second<<endl;
        }
        cout<<sum<<endl; 
        cout<<endl;       
        };

        auto neededToSwap = [&](){

            if(topk.size() < xx) return false;
            if(rem.empty()) return false;

            auto one = *topk.begin();
            auto two = *rem.rbegin();
            if(one.first == two.first) return one.second < two.second;
            return one.first < two.first;   
        };

        auto swap = [&](){

            if(!neededToSwap()) return;

            auto one = *topk.begin();
            topk.erase(topk.begin());

            sum -= one.first * one.second;

            auto two = *rem.rbegin();
            rem.erase(rem.find(two));

            sum += two.first * two.second;

            topk.insert(two);
            rem.insert(one);
        };

        auto add = [&](long long x){
            if(topk.find({freq[x], x}) != topk.end()){
                topk.erase({freq[x], x});
                topk.insert({freq[x]+1, x});
                freq[x]++;
                sum += x;
            }
            else if(topk.size() < xx){
                topk.insert({freq[x]+1, x});
                freq[x]++;
                sum += x;
            }
            else{
                rem.erase({freq[x], x});
                rem.insert({freq[x]+1, x});
                freq[x]++;
                swap();
            }
        } ; 

        auto decrement = [&](long long x){

            if(topk.find({freq[x], x}) != topk.end()){
                topk.erase({freq[x], x});
                if(freq[x]>0)
                topk.insert({freq[x]-1, x});
                sum -= x;
                swap();
            }
            else{
                rem.erase({freq[x], x});
                if(freq[x]>0)
                rem.insert({freq[x]-1, x});
            }
            freq[x]--;
        };

        unordered_map<long long, long long> count;
        for(long long i=0; i<k-1; i++){  
            add(nums[i]);
            // debug(-1);
        }

        long long n = nums.size();
        vector<long long> ans;
        for(long long l=0, r=k-1; r<n; l++, r++){
            add(nums[r]);
            ans.push_back(sum);
            // debug(l);
            decrement(nums[l]);
        }
        return ans;
    }
};",1420585542
Arjun S,arjun_06_s,203,3610,cpp,"class Solution {
public:

    int util(vector<int>& nums, int x, int l, int r){
        
        vector<int> count(51, 0);

        for(int i=l; i<=r; i++) count[nums[i]]++;

        
        using pii = pair<int, int>;

        priority_queue<pii, vector<pii>> pq;
        for(int i=0; i<=50; i++) 
        if(count[i]) pq.push({count[i], i});

    
        int sum = 0;
        while(!pq.empty() and x){
            x--;
            sum += pq.top().first * pq.top().second;
            pq.pop();
        }
        return sum;

    }

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        
        vector<int> ans;

        for(int l=0, r=k-1; r<nums.size(); l++, r++){
            ans.push_back(util(nums, x, l, r));
        }
        return ans;

    }
};",1420523084
Akash,Akash_0P,204,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
  int kthLargestPerfectSubtree(TreeNode* root, int k) {
        
    vector<int> sizes;

    auto dfs = [&](TreeNode* node, int dpt, auto && dfs) -> array<int,3> {

      if(node == NULL) return {0, 0, -1};

      if(node->left == NULL && node->right == NULL) {
        sizes.push_back(1);
        return {1, 1, dpt};
      }

      array<int,3> lft = dfs(node->left, dpt + 1, dfs);
      array<int,3> rgt = dfs(node->right, dpt + 1, dfs);

      if((lft[0] & rgt[0]) && lft[2] == rgt[2] && lft[2] != -1) {
        sizes.push_back(lft[1] + rgt[1] + 1);
      }

      return {lft[0] & rgt[0], lft[1] + rgt[1] + 1, (lft[2] == rgt[2] && lft[2] != -1 ? lft[2] : -1)};

    }; dfs(root, 0, dfs);

    sort(sizes.rbegin(), sizes.rend());

    if(sizes.size() < k) return -1;

    return sizes[k - 1];

  }
};",1420540592
Akash,Akash_0P,204,3588,cpp,"using ll = long long;

class Solution {
public:
  int countWinningSequences(string s) {
        
    int n = s.size(), M = 1e9 + 7, c = 1000;
    vector dp(4, vector (n + 1, vector (n + c + 1, -1)));

    string str = ""FWE"";

    auto f = [&](int i, int points, int prev, auto && f) -> ll {

      if(i == n) return points > 0;

      if(dp[prev][i][points + c] != -1) return dp[prev][i][points + c];

      ll ans = 0;

      for(int j = 0; j < 3; j++) {

        if(prev == j) continue;

        if(str[j] == 'F' && s[i] == 'E') ans = (ans + f(i + 1, points + 1, j, f)) % M;
        else if(str[j] == 'W' && s[i] == 'F') ans = (ans + f(i + 1, points + 1, j, f)) % M; 
        else if(str[j] == 'E' && s[i] == 'W') ans = (ans + f(i + 1, points + 1, j, f)) % M;
        else if(str[j] == s[i]) ans = (ans + f(i + 1, points, j, f)) % M;
        else ans = (ans + f(i + 1, points - 1, j, f)) % M;

      }

      return dp[prev][i][points + c] = ans;

    };

    return f(0, 0, 3, f);

  }
};",1420565140
Akash,Akash_0P,204,3592,cpp,"class Solution {
public:
  vector<long long> findXSum(vector<int>& nums, int k, int X) {
    
    int n = nums.size();
    vector<long long> ans;

    auto check = [&](pair<int,int> p1, pair<int,int> p2) -> int {

      if(p1.first != p2.first) return p1.first > p2.first;
      return p1.second >= p2.second;

    };

    set<pair<long long,long long>> use, waste;
    map<long long,long long> mpp;

    long long sum = 0;

    auto insert = [&](int x) {

      if(use.size() < X || use.count({mpp[x], x})) {
        if(mpp.count(x)) use.erase({mpp[x], x});
        mpp[x]++;
        use.insert({mpp[x], x}), sum += x;
        return;
      }

      if(waste.count({mpp[x], x})) waste.erase({mpp[x], x});

      mpp[x]++;
      waste.insert({mpp[x], x});

      if(!waste.empty() && check(*waste.rbegin(), *use.begin())) {
        auto p = *waste.rbegin();
        auto q = *use.begin();

        use.erase(use.begin()), waste.erase(--waste.end());

        sum -= q.first * q.second;
        sum += p.first * p.second;

        use.insert(p), waste.insert(q);
      }

    };

    auto remove = [&](int x) {

      if(waste.count({mpp[x], x})) {
        waste.erase({mpp[x], x});
        if(--mpp[x]) {
          waste.insert({mpp[x], x});
        }
        return;
      }

      use.erase({mpp[x], x}), sum -= x;

      if(--mpp[x]) {
        use.insert({mpp[x], x});
      }

      if(use.size() < X) {
        if(!waste.empty()) {
          auto p = *waste.rbegin();
          waste.erase(--waste.end());
          sum += p.first * p.second;
          use.insert(p);
        }
        return;
      }

      if(!waste.empty() && check(*waste.rbegin(), *use.begin())) {
        auto p = *waste.rbegin();
        auto q = *use.begin();

        use.erase(use.begin()), waste.erase(--waste.end());

        sum -= q.first * q.second;
        sum += p.first * p.second;

        use.insert(p), waste.insert(q);
      }

    };

    for(int i = 0, j = 0; j < n; j++) {

      insert(nums[j]);

      if(j - i + 1 == k) {

        ans.push_back(sum);

        remove(nums[i]);

        i++;

      }

    }

    return ans;
  }
};",1420618721
Akash,Akash_0P,204,3610,cpp,"class Solution {
public:
  vector<int> findXSum(vector<int>& nums, int k, int x) {
  
    int n = nums.size();

    vector<int> ans;

    auto compute = [&](int l, int r) {

      map<int,int> mpp;
      for(int i = l; i <= r; i++) mpp[nums[i]]++;

      priority_queue<pair<int,int>> pq;
      for(auto &i: mpp) pq.push({i.second, i.first});

      int X = x, sum = 0;
      while(X > 0 && !pq.empty()) X--, sum += pq.top().second * pq.top().first, pq.pop();

      return sum;

    };

    for(int i = 0; i + k <= n; i++) {
      ans.push_back(compute(i, i + k - 1));
    }

    return ans;

  }
};
",1420523034
NDwWeFa8I0,NDwWeFa8I0,205,3509,cpp,"class Solution {
public:
    pair<bool, int> check(TreeNode* node) {
        if (!node) return {true, 0};
        
        pair<bool,int> leftResult = check(node->left);
        pair<bool,int> rightResult = check(node->right);
        bool lsize = leftResult.first;
        bool rsize = rightResult.first;
        if ( lsize && rsize && leftResult.second == rightResult.second) {
            return {true, leftResult.second + rightResult.second + 1};
        }
        
        return {false, 0};
    }
    
    void gatherPerfectSizes(TreeNode* node, vector<int>& subTreeSize) {
        if (!node) return;
        
        auto result = check(node);
        if (result.first) {
            subTreeSize.push_back(result.second);
        }
        
        gatherPerfectSizes(node->left, subTreeSize);
        gatherPerfectSizes(node->right, subTreeSize);
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {

        vector<int> subTreeSize;
        gatherPerfectSizes(root, subTreeSize);
        
        if (subTreeSize.empty())
            return -1;
        
        sort(subTreeSize.rbegin(), subTreeSize.rend());
        
        if(k <= subTreeSize.size())
            return subTreeSize[k-1];
        return -1;   
    }
};
",1420548139
NDwWeFa8I0,NDwWeFa8I0,205,3588,cpp,"#include <iostream>
#include <string>
#include <cstring>
using namespace std;

class Solution {
    
    string s; 
public:
    const int MOD = 1e9 + 7;
    int dp[1001][4][2002]; 
    int n;
    int win_against[3] = {1, 2, 0}; 

    int dfs(int i, int l_bobMove, int diff) {
        if (i == n)
        {
            if(diff > 0)
                return 1;
            return 0;
        }

        if (dp[i][l_bobMove + 1][diff + 1000] != -1) 
            return dp[i][l_bobMove + 1][diff + 1000];

        int tWays = 0;
        // int alice_move = (s[i] == 'F') ? 0 : (s[i] == 'W') ? 1 : 2;
        int alice_move;

        if(s[i]=='F')
        {
            alice_move=0;
        }
        else
        {
            if(s[i]=='W')
            {
                alice_move=1;
            }
            else
                alice_move=2;
        }

        for (int bob_move = 0; bob_move < 3; ++bob_move) {
            if (bob_move == l_bobMove) continue;  

            int new_score_diff = diff;
            if (bob_move == win_against[alice_move]) {
                new_score_diff++;  
            } else if (alice_move == win_against[bob_move]) {
                new_score_diff--;  
            }

            tWays = (tWays + dfs(i + 1, bob_move, new_score_diff)) % MOD;
        }

        return dp[i][l_bobMove + 1][diff + 1000] = tWays;
    }

    int countWinningSequences(string seq) {
        s = seq;
        n = s.length();
        memset(dp, -1, sizeof(dp));  
        return dfs(0, -1, 0);  
    }
    
};
",1420612805
NDwWeFa8I0,NDwWeFa8I0,205,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <unordered_map>
#include <vector>

using namespace __gnu_pbds;
using namespace std;

class Solution {
public:
    using ll = long long;

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> result;
        unordered_map<ll, ll> freqCount;
        ll windowSum = 0, xSum = 0;

        typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
        ordered_set topXEle, remaining;

       
        for (int i = 0; i < k; i++) {
            add(nums[i], freqCount, topXEle, remaining, xSum, windowSum,x);
        }

        result.push_back(xSum);

        for (int i = k; i < n; i++) {
            remove(nums[i - k], freqCount, topXEle, remaining, xSum,x);
            add(nums[i], freqCount, topXEle, remaining, xSum, windowSum,x);
            result.push_back(xSum);
        }

        return result;
    }

    void add(ll num, unordered_map<ll, ll>& freqCount, 
             tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update>& topXEle, 
             tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update>& remaining, 
             ll& xSum, ll& windowSum,int x) {
        if (freqCount[num] > 0) {
            auto it = topXEle.find({freqCount[num], num});
            if (it != topXEle.end()) {
                topXEle.erase(it);
                xSum -= (ll)freqCount[num] * num;
            } else {
                remaining.erase({freqCount[num], num});
            }
        }
        freqCount[num]++;
        windowSum += num;
        topXEle.insert({freqCount[num], num});
        xSum += (ll)freqCount[num] * num;
        adjusttopXEle(topXEle, remaining, xSum,x);
    }

    void remove(ll num, unordered_map<ll, ll>& freqCount, 
                tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update>& topXEle, 
                tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update>& remaining, 
                ll& xSum,int x) {
        auto it = topXEle.find({freqCount[num], num});
        if (it != topXEle.end()) {
            topXEle.erase(it);
            xSum -= (ll)freqCount[num] * num;
        } else {
            remaining.erase({freqCount[num], num});
        }

        freqCount[num]--;
        if (freqCount[num] > 0) {
            remaining.insert({freqCount[num], num});
        }
        adjusttopXEle(topXEle, remaining, xSum,x);
    }

    void adjusttopXEle(tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update>& topXEle, 
                       tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update>& remaining, 
                       ll& xSum,int x) {
        while (topXEle.size() > x) {
            auto it = topXEle.begin();
            remaining.insert(*it);
            xSum -= (ll)it->first * it->second;
            topXEle.erase(it);
        }
        while (topXEle.size() < x && !remaining.empty()) {
            auto it = remaining.rbegin();
            topXEle.insert(*it);
            xSum += (ll)it->first * it->second;
            remaining.erase(prev(remaining.end()));
        }
    }
};
",1420600317
NDwWeFa8I0,NDwWeFa8I0,205,3610,cpp,"#include <vector>
#include <map>
#include <algorithm>
using namespace std;

class Solution {
public:
    static bool comparator(const pair<int, int>& a, const pair<int, int>& b) {
        if (a.second == b.second) {
            return a.first > b.first;
        }
        return a.second > b.second;
    }

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;

        for (int i = 0; i <= n - k; i++) {
            int sum = 0;
            map<int, int> mp;

            for (int j = i; j < i + k; j++) {
                mp[nums[j]]++;
            }

            vector<pair<int, int>> freqVec(mp.begin(), mp.end());
            sort(freqVec.begin(), freqVec.end(), comparator);

            for (int ii = 0; ii < min(x, (int)freqVec.size()); ii++) {
                sum += freqVec[ii].first * freqVec[ii].second;
            }
            ans.push_back(sum);
        }

        return ans;
    }
};
",1420524786
JohnnyTest_LC,JohnnyTest_LC,208,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> sizes;
    tuple<bool, int, int> dfs(TreeNode* root) {
        if (root == nullptr) return {true, 0, 0};

        const auto [l_perfect, l_size, l_depth] = dfs(root->left);
        const auto [r_perfect, r_size, r_depth] = dfs(root->right);
        if (l_perfect and r_perfect and l_depth == r_depth) {
            sizes.push_back(l_size + r_size + 1);
            return {true, l_size + r_size + 1, l_depth + 1};
        }

        return {false, 0, max(l_depth, r_depth) + 1};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sizes.rbegin(), sizes.rend());
        if (sizes.size() < k)
            return -1;
        for (const auto x: sizes)
            cout << x << ' ';
        return sizes[k-1];
    }
};",1420619279
JohnnyTest_LC,JohnnyTest_LC,208,3588,python3,"MOD = 10 ** 9 + 7

class Solution:
    def countWinningSequences(self, s: str) -> int:
        beat = {'E': 'F', 'F': 'W', 'W': 'E'}
        n = len(s)

        @cache
        def ways(i: int, not_available: str, to_win: int) -> int:
            if i == n:
                if to_win <= 0:
                    return 1
                return 0
            if to_win > n - i:
                return 0
            total = 0
            for choice in ""EFW"":
                if choice == not_available:
                    continue
                if choice == beat[s[i]]:
                    total += ways(i+1, choice, to_win - 1)
                elif choice == s[i]:
                    total += ways(i+1, choice, to_win)
                else:
                    total += ways(i+1, choice, to_win + 1)
                total %= MOD
            return total
        
        return ways(0, '_', 1)

        ",1420617660
JohnnyTest_LC,JohnnyTest_LC,208,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pair<long long int, long long int>> inside, outside;
        vector<long long> ans;
        map<long long int, long long int> freqs;
        int n = nums.size();
        long long int sum = 0;

        for (int i=0; i<k; ++i)
            freqs[nums[i]]++;
        
        {
            vector<pair<long long int, long long int>> v;
            for (const auto [num, fr]: freqs)
                v.push_back({fr, num});
            sort(v.rbegin(), v.rend());
            for (int i=0; i<x and i<v.size(); ++i)
            {
                inside.insert(v[i]);
                sum += v[i].first * v[i].second;
            }
            for (int i=x; i<v.size(); ++i)
                outside.insert(v[i]);
            
            ans.push_back(sum);
        }

        for (int i=k; i<n; ++i)
        {
            // cout << ""At i="" << i << "":: "" << nums[i] << "" comes in and "" << nums[i-k] << "" goes out, which makes "" << sum;
            if (nums[i-k] == nums[i])
            {
                // cout << "" --> "" << sum << '\n';
                ans.push_back(sum);
                continue;
            }
            const auto outgoing_num = nums[i-k];
            const auto outgoing_freq = freqs[outgoing_num];
            const auto incoming_num = nums[i];
            const auto incoming_freq = freqs[incoming_num];

            const auto o_pair = pair{outgoing_freq, outgoing_num};
            const auto i_pair = pair{incoming_freq, incoming_num};
            if (inside.contains(o_pair))
            {
                inside.erase(o_pair);
                sum -= outgoing_freq * outgoing_num;
            }
            else
            {
                outside.erase(o_pair);
            }
            
            if (inside.contains(i_pair))
            {
                inside.erase(i_pair);
                sum -= incoming_freq * incoming_num;
            }
            else 
            {
                outside.erase(i_pair);
            }

            outside.insert(pair{outgoing_freq -1, outgoing_num});
            freqs[outgoing_num]--;
            outside.insert(pair{incoming_freq+1, incoming_num});
            freqs[incoming_num]++;

            // if (inside.size() == x)
            // {
                
            //     ans.push_back(sum);
            //     cout << "" --> "" << sum << '\n';
            //     continue;
            // }

            {
                const auto [fr, el] = *outside.rbegin(); outside.erase(prev(outside.end()));
                inside.insert({fr, el});
                sum += fr * el;
                // cout << "" --> "" << sum << "" after adding "" << el << ""*"" << fr;
                // if (inside.size() == x)
                // {
                //     ans.push_back(sum);
                //     cout << endl;
                //     // continue;
                // }
            }
            {
                const auto [fr, el] = *outside.rbegin(); outside.erase(prev(outside.end()));
                inside.insert({fr, el});
                sum += fr * el;
                // cout << "" --> "" << sum << "" after adding "" << el << ""*"" << fr;
                // if (inside.size() == x)
                // {
                //     ans.push_back(sum);
                //     cout << '\n';
                //     // continue;
                // }
            }

            while (inside.size() > x)
            {
                const auto [fr, el] = *inside.begin(); 
                sum -= fr * el;
                outside.insert(*inside.begin());
                inside.erase(inside.begin());
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420617489
JohnnyTest_LC,JohnnyTest_LC,208,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        set<pair<long long int, long long int>> inside, outside;
        vector<int> ans;
        map<long long int, long long int> freqs;
        int n = nums.size();
        long long int sum = 0;

        for (int i=0; i<k; ++i)
            freqs[nums[i]]++;
        
        {
            vector<pair<long long int, long long int>> v;
            for (const auto [num, fr]: freqs)
                v.push_back({fr, num});
            sort(v.rbegin(), v.rend());
            for (int i=0; i<x and i<v.size(); ++i)
            {
                inside.insert(v[i]);
                sum += v[i].first * v[i].second;
            }
            for (int i=x; i<v.size(); ++i)
                outside.insert(v[i]);
            
            ans.push_back(sum);
        }

        for (int i=k; i<n; ++i)
        {
            // cout << ""At i="" << i << "":: "" << nums[i] << "" comes in and "" << nums[i-k] << "" goes out, which makes "" << sum;
            if (nums[i-k] == nums[i])
            {
                // cout << "" --> "" << sum << '\n';
                ans.push_back(sum);
                continue;
            }
            const auto outgoing_num = nums[i-k];
            const auto outgoing_freq = freqs[outgoing_num];
            const auto incoming_num = nums[i];
            const auto incoming_freq = freqs[incoming_num];

            const auto o_pair = pair{outgoing_freq, outgoing_num};
            const auto i_pair = pair{incoming_freq, incoming_num};
            if (inside.contains(o_pair))
            {
                inside.erase(o_pair);
                sum -= outgoing_freq * outgoing_num;
            }
            else
            {
                outside.erase(o_pair);
            }
            
            if (inside.contains(i_pair))
            {
                inside.erase(i_pair);
                sum -= incoming_freq * incoming_num;
            }
            else 
            {
                outside.erase(i_pair);
            }

            outside.insert(pair{outgoing_freq -1, outgoing_num});
            freqs[outgoing_num]--;
            outside.insert(pair{incoming_freq+1, incoming_num});
            freqs[incoming_num]++;

            // if (inside.size() == x)
            // {
                
            //     ans.push_back(sum);
            //     cout << "" --> "" << sum << '\n';
            //     continue;
            // }

            {
                const auto [fr, el] = *outside.rbegin(); outside.erase(prev(outside.end()));
                inside.insert({fr, el});
                sum += fr * el;
                // cout << "" --> "" << sum << "" after adding "" << el << ""*"" << fr;
                // if (inside.size() == x)
                // {
                //     ans.push_back(sum);
                //     cout << endl;
                //     // continue;
                // }
            }
            {
                const auto [fr, el] = *outside.rbegin(); outside.erase(prev(outside.end()));
                inside.insert({fr, el});
                sum += fr * el;
                // cout << "" --> "" << sum << "" after adding "" << el << ""*"" << fr;
                // if (inside.size() == x)
                // {
                //     ans.push_back(sum);
                //     cout << '\n';
                //     // continue;
                // }
            }

            while (inside.size() > x)
            {
                const auto [fr, el] = *inside.begin(); 
                sum -= fr * el;
                outside.insert(*inside.begin());
                inside.erase(inside.begin());
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420619125
Soutik Dey,braindroid,209,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
unordered_map<int,int>mp;
int n = 0;
void pre(TreeNode *root) {
    if(root == NULL) {
        return;
    }
    root->val = n++;
    pre(root->left);
    pre(root->right);
}
vector<vector<int>>a;
void build(TreeNode *root) {
    if(root == NULL) {
        return;
    }

    if(root->left != NULL) {
        a[root->left->val].push_back(root->val);
        a[root->val].push_back(root->left->val);
    }
    if(root->right != NULL) {
        a[root->val].push_back(root->right->val);
        a[root->right->val].push_back(root->val);
    }
    build(root->left);
    build(root->right);
}

vector<int>res;


void dfs(int x , int p , int dep , vector<int> &good , vector<int>&mn, vector<int>&mx , vector<int> &D , vector<int> & sz) {
    D[x] = dep;
    int childs = 0;
    sz[x] = 1;
    bool yes = 1;
    for(auto &u : a[x]) {
        if(u == p) {
            continue;
        }
        ++childs;
        dfs(u,x,dep+1,good,mn,mx,D,sz);
        sz[x] += sz[u];
        mx[x] = max(mx[x] , mx[u]);
        mn[x] = min(mn[x], mn[u]);
        if(!good[u]) {
            yes = 0;
        }
    }
    if(!childs) {
       mx[x] = dep;
       mn[x] = dep;
       good[x] = 1;
    } else {
        if(mx[x] == mn[x] && childs == 2 && yes) {
            good[x] = 1;
        }
    }

}

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        pre(root);
        a.resize(n+2);
        build(root);
        vector<int>good(n+2,0);
        int x = root->val;
        vector<int>mx(n+2,-1);
        vector<int>mn(n+2,1e9);
        vector<int>D(n+2,0);
        vector<int>sz(n+2,0);
        dfs(x,-1,0,good,mn,mx,D,sz);
        int ans = 0;
        for(int i = 0 ; i < n ; i++) {
            if(good[i]) {
                res.push_back(sz[i]);
            }
        }
        k--;
        int N = (int)res.size();
        sort(res.rbegin(),res.rend());
        for(auto &u : res) {
            cout << u << ' ';
        }
        if(k < N) {
            return res[k];
        }
        return -1;
    }
};",1420548349
Soutik Dey,braindroid,209,3588,cpp,"class Solution {
public:
    int dp[1002][2007][4];
    int n;
    string s;
    const int M = (int)1e9+7;
    // 0 -> fire.
    // 1 -> water.
    // 2 -> earth.
    // wins are = {2,0}, {0,1} , {1,2}.
    // set<pair<int,int>>wins = {{2,0},{0,1},{1,2}};
    // set<pair<int,int>>draws = {{0,0},{1,1},{2,2}};
    vector<vector<int>>wins;
    vector<vector<int>>draws;
    int solve(int i , int score , int last) {
        if(i == n) {
            if(score > 1002) {
                return 1;
            }
            return 0;
        }
        if(dp[i][score][last] != -1) return dp[i][score][last] % M;

        long long ans = 0;
        int other = s[i]-'A';
        for(int j = 0 ; j < 3 ; j++) {
            if(j != last) {
                if(wins[other][j]) {
                    ans += solve(i+1,score+1,j);
                    ans %= M;
                } else if(draws[other][j]) {
                    ans += solve(i+1,score,j);
                    ans %= M;
                } else {
                    ans += solve(i+1,score-1,j);
                    ans %= M;
                }
            }
        }
        return dp[i][score][last] = ans;
    }

    int countWinningSequences(string S) {
        s = S;
        n = (int)s.size();
        wins.resize(4,vector<int>(4,0));
        // set<pair<int,int>>wins = {{2,0},{0,1},{1,2}};
        // set<pair<int,int>>draws = {{0,0},{1,1},{2,2}};
        wins[2][0] = 1;
        wins[0][1] = 1;
        wins[1][2] = 1;
        draws.resize(4,vector<int>(4,0));
        draws[0][0] = 1;
        draws[1][1] = 1;
        draws[2][2] = 1;
        for(int i = 0 ; i < n ; i++) {
            if(s[i] == 'F') {
                s[i] = 'A';
            } 
            if(s[i] == 'W') {
                s[i] = 'B';
            }
            if(s[i] == 'E') {
                s[i] = 'C';
            }
        }
        memset(dp,-1,sizeof(dp));
        return solve(0,1002,3);
        
    }
};",1420564049
Soutik Dey,braindroid,209,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int X) {
        vector<long long>ans;
        multiset<pair<int,int>>s;
        multiset<pair<int,int>>deleted;
        // no of times it occured , it's value
        int n = (int)a.size();
        int l = 0;
        map<int,int>mp;
        long long curr = 0;
        for(int i = 0 ; i < n ; i++) {
            if(i >= k) {
                int times = mp[a[l]];
                int v = a[l];
                if(s.find({times,v}) != s.end()) {
                    curr -= (times *1LL* v);
                    s.erase(s.find({times,v}));
                    mp[a[l]]--;
                    times--;
                    curr += (times *1LL* v);
                    s.insert({times,v});
                } else if(deleted.find({times,v}) != deleted.end()) {
                    deleted.erase(deleted.find({times,v}));
                    mp[a[l]]--;
                    times--;
                    deleted.insert({times,v});
                } else {
                 mp[a[l]]--;
                 times--;
                 s.insert({times,v});
                }
                l++;
            }
            if(mp.find(a[i]) == mp.end()) {
             mp[a[i]]++;
             s.insert({mp[a[i]],a[i]});
             curr += a[i];   
            } else {
             int times = mp[a[i]];
             if(s.find({times,a[i]}) != s.end()) {
                curr -= (times *1LL * a[i]);
                s.erase(s.find({times,a[i]}));
                mp[a[i]]++;
                times++;
                s.insert({times,a[i]});
                curr += (times *1LL* a[i]);
             } else if(deleted.find({times,a[i]}) != deleted.end()) {
                deleted.erase(deleted.find({times,a[i]}));
                mp[a[i]]++;
                times++;
                deleted.insert({times,a[i]});
             } else {
                mp[a[i]]++;
                times++;
                s.insert({times,a[i]});
                curr += (times *1LL* a[i]);
             }
            }
            while((int)s.size() > X) {
                int xx = s.begin()->first;
                int yy = s.begin()->second;
                curr -= xx*1LL*yy;
                s.erase(s.find({xx,yy}));
                deleted.insert({xx,yy});
            }
            while(!deleted.empty() && deleted.rbegin()->first >= s.begin()->first) {
                if(deleted.rbegin()->first == s.begin()->first && deleted.rbegin()->second <= s.begin()->second) {
                    break;
                }
                int ax = deleted.rbegin()->first;
                int ay = deleted.rbegin()->second;
                int dx = s.begin()->first;
                int dy = s.begin()->second;
                curr -= dx*1LL*dy;
                curr += ax*1LL*ay;
                s.erase(s.find({dx,dy}));
                s.insert({ax,ay});
                deleted.erase(deleted.find({ax,ay}));
                deleted.insert({dx,dy});
            }
            // if(i == 3) {
            //     for(auto &u : s) {
            //         cout << u.first << ' ' << u.second << '\n';
            //     }
            // }
            if(i >= k-1) {
                ans.push_back(curr);
            }
        }
        return ans;
    }
};",1420596604
Soutik Dey,braindroid,209,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = (int)a.size();
        int l = 0;
        map<int,int>mp;
        vector<int>ans;
        for(int i = 0 ; i < n ; i++) {
            if(i >= k) {
                mp[a[l]]--;
                l++;
            }
            mp[a[i]]++;
            if(i >= k-1) {
                vector<pair<int,int>>b;
                for(auto &u : mp) {
                    b.push_back({u.second,u.first});
                }
                sort(b.rbegin(),b.rend());
                int res = 0;
                int N = (int)b.size();
                int can = x;
                for(int j = 0 ; j < N ; j++) {
                    if(j >= x) {
                        break;
                    }
                    res += b[j].first*b[j].second;
                    // cout << b[j].first << ' ' << b[j].second << '\n';
                }
                // cout << ""DONE\n"";
                ans.push_back(res);
            }
        }
        return ans;
    }
};",1420523908
Rohan Singla,singla__rohan,210,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map<TreeNode*, int> lower, upper;
    vector<int> result;

    void calcLower(TreeNode* node) {
        if (!node) return;

        calcLower(node->left);
        calcLower(node->right);

        lower[node] = min(lower[node->left], lower[node->right]) + 1;
    }

    void calcUpper(TreeNode* node) {
        if (!node) return;

        calcUpper(node->left);
        calcUpper(node->right);

        upper[node] = max(upper[node->left], upper[node->right]) + 1;
    }

    void traverse(TreeNode* root) {
        if (!root) return;

        if (upper[root] == lower[root])
            result.push_back((1 << upper[root]) - 1);

        traverse(root->left);
        traverse(root->right);
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        calcLower(root);
        calcUpper(root);
        traverse(root);

        sort(result.begin(), result.end(), greater<int>());

        return (k > result.size()) ? -1 : result[k - 1];
    }
};",1420620288
Rohan Singla,singla__rohan,210,3588,cpp,"const int MOD = 1e9 + 7;
int mapping[26];

class Solution {
public:
    vector<vector<vector<int>>> memo;
    int len;
    void init(){
        mapping['E' - 'A'] = 0;
        mapping['F' - 'A'] = 1;
        mapping['W' - 'A'] = 2;
    }
    int recurse(int idx, int last, int score, string &str) {
        if (idx == len) {
            if(score <= 0) return 0;
            return 1;
        }

        if (memo[idx][score + len][last + 1] != -1)
            return memo[idx][score + len][last + 1];

        int Aplay = mapping[str[idx] - 'A'];
        long long result = 0;

        for (int current = 0; current <= 2; current++) {
            if (current == last) continue;

            int delta = 0;
            if (current == (Aplay + 1) % 3) delta = 1;
            else if (Aplay == (current + 1) % 3) delta = -1;

            result += recurse(idx + 1, current, score + delta, str);
            result %= MOD;
        }

        return memo[idx][score + len][last + 1] = result;
    }

    int countWinningSequences(string str) {
        init();
        len = str.size();
        memo = vector<vector<vector<int>>> (len + 1, vector<vector<int>> (2 * len + 2, vector<int> (4, -1)));

        return recurse(0, -1, 0, str);
    }
};
",1420620046
Rohan Singla,singla__rohan,210,3592,cpp,"class Solution {
public:
    map<int, int> countMap;
    set<pair<long long, long long>> mainSet, bufferSet;

    void balance(long long &sum, int targetSize) {
        if (mainSet.size() == targetSize) {
            auto it = mainSet.begin();
            sum -= it->first * it->second;
            bufferSet.insert(*it);
            mainSet.erase(*it);
        }

        if (!bufferSet.empty()) {
            auto it = prev(bufferSet.end());
            sum += it->first * it->second;
            mainSet.insert(*it);
            bufferSet.erase(*it);
        }
    }

    void modify(long long &sum, int targetSize, int elem, int delta) {
        mainSet.erase({countMap[elem], elem});
        bufferSet.erase({countMap[elem], elem});

        countMap[elem] += delta;

        if (mainSet.size() < targetSize) {
            if (countMap[elem] != 0) 
                mainSet.insert({countMap[elem], elem});
            sum += delta * elem;
            
        } 
        else if (countMap[elem] != 0) {
            bufferSet.insert({countMap[elem], elem});
        }

        balance(sum, targetSize);
    }

    vector<long long> findXSum(vector<int>& arr, int windowSize, int targetSize) {
        long long sum = 0;
        int n = arr.size();
        vector<long long> result(n - windowSize + 1);
        
        for (int left = 0, i = 0; i < n; i++) {
            if (i >= windowSize) {
                modify(sum, targetSize, arr[left], -1);
                left++;
            }
            modify(sum, targetSize, arr[i], 1);

            if (i >= windowSize - 1) 
                result[i - (windowSize - 1)] = sum;
        }
        return result;
    }
};",1420619779
Rohan Singla,singla__rohan,210,3610,cpp,"class Solution {
public:
    map<int, int> countMap;
    set<pair<long long, long long>> mainSet, bufferSet;

    void balance(long long &sum, int targetSize) {
        if (mainSet.size() == targetSize) {
            auto it = mainSet.begin();
            sum -= it->first * it->second;
            bufferSet.insert(*it);
            mainSet.erase(*it);
        }

        if (!bufferSet.empty()) {
            auto it = prev(bufferSet.end());
            sum += it->first * it->second;
            mainSet.insert(*it);
            bufferSet.erase(*it);
        }
    }

    void modify(long long &sum, int targetSize, int elem, int delta) {
        mainSet.erase({countMap[elem], elem});
        bufferSet.erase({countMap[elem], elem});

        countMap[elem] += delta;

        if (mainSet.size() < targetSize) {
            if (countMap[elem] != 0) 
                mainSet.insert({countMap[elem], elem});
            sum += delta * elem;
            
        } 
        else if (countMap[elem] != 0) {
            bufferSet.insert({countMap[elem], elem});
        }

        balance(sum, targetSize);
    }

    vector<int> findXSum(vector<int>& arr, int windowSize, int targetSize) {
        long long sum = 0;
        int n = arr.size();
        vector<int> result(n - windowSize + 1);
        
        for (int left = 0, i = 0; i < n; i++) {
            if (i >= windowSize) {
                modify(sum, targetSize, arr[left], -1);
                left++;
            }
            modify(sum, targetSize, arr[i], 1);

            if (i >= windowSize - 1) 
                result[i - (windowSize - 1)] = sum;
        }
        return result;
    }
};",1420619734
John Rigby,vanshkunwarji41,212,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
vector<int> v;
    pair<int,int> f(TreeNode* r){
        //size,isperf
        if(!r){
            return {0,1};
        }
        auto l=f(r->left);
        auto m=f(r->right);
        int sz=1+l.first+m.first;
        int u=0;
        if(l.second && m.second){
            if(l.first==m.first){
                u=1;
            }
        }
        if(u){
            v.push_back(sz);
        }
        return {sz,u};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        v={};
        f(root);
        sort(v.begin(),v.end(), greater<int>());
        if(v.size()<k){
            return -1;
        }
        return v[k-1];
    }
};",1420580940
John Rigby,vanshkunwarji41,212,3588,cpp,"class Solution {
public:
    int dp[1001][2005][4];
    const int M=1e9+7;
    map<char,int> mm={{'F',0},{'W',1},{'E',2}};
    int g(int a, int b){
        if(a==b){
            return 0;
        }
        if((b+1)%3==a){
            return 1;
        }
        return -1;
    }
    int f(int i, string &s, int p ,int u){
        if(i==s.size()){
            if(p>0){
                return 1;
            }
            return 0;
        }
        if(dp[i][p+1000][u]!=-1){
            return dp[i][p+1000][u];
        }
        long long r=0;
        if(u==3){
            for(int j=0;j<3;j++){
                r=(r+f(i+1,s,p+g(j,mm[s[i]]),j))%M;
            }
        }
        else{
            for(int j=0;j<3;j++){
                if(u==j){
                    continue;
                }
                r=(r+f(i+1,s,p+g(j,mm[s[i]]),j))%M;
            }
        }
        return dp[i][p+1000][u]=r;
    }
    int countWinningSequences(string s) {
        memset(dp,-1,sizeof(dp));
        return f(0,s,0,3);
    }
};",1420597087
John Rigby,vanshkunwarji41,212,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define oset tree<pair<int,int>, null_type,greater<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> v(nums.size()-k+1);
        map<int,int> m;
        oset s;
        int yz=0;
        long long e=0;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
            int zz=0;
            if(s.order_of_key({m[nums[i]]-1,nums[i]})<x){
                zz=1;
                e-=1LL*(m[nums[i]]-1)*nums[i];
            }
            s.erase({m[nums[i]]-1,nums[i]});
            auto it=s.find_by_order(x-1);
            if(it!=s.end() && zz){
                e+=1LL*((*it).first)*((*it).second);
            }
            s.insert({m[nums[i]],nums[i]});
            zz=0;
            if(s.order_of_key({m[nums[i]],nums[i]})<x){
                e+=1LL*(m[nums[i]])*nums[i];
                zz=1;
            }
            it=s.find_by_order(x);
            if(it!=s.end() && zz){
                e-=1LL*((*it).first)*((*it).second);
            }
            // for(auto i:s){
            //     cout<<i.first<<"" ""<<i.second<<endl;
            // }
            // cout<<e<<endl;
            if(i>=k-1){
                v[yz++]=e;
                m[nums[i-k+1]]--;
                zz=0;
                if(s.order_of_key({m[nums[i-k+1]]+1,nums[i-k+1]})<x){
                    e-=1LL*(m[nums[i-k+1]]+1)*nums[i-k+1];

                    // cout<<""1 ""<<1LL*(m[nums[i-k+1]]+1)*nums[i]<<endl;
                    zz=1;
                }
                s.erase({m[nums[i-k+1]]+1,nums[i-k+1]});
                auto it=s.find_by_order(x-1);
                if(it!=s.end() && zz){
                    e+=1LL*((*it).first)*((*it).second);
                    cout<<""2 ""<<1LL*((*it).first)*((*it).second)<<endl;
                }

                s.insert({m[nums[i-k+1]],nums[i-k+1]});
                zz=0;
                if(s.order_of_key({m[nums[i-k+1]],nums[i-k+1]})<x){
                    e+=1LL*(m[nums[i-k+1]])*nums[i-k+1];
                    // cout<<""1 ""<<1LL*(m[nums[i-k+1]])*nums[i]<<endl;
                    zz=1;
                }
                it=s.find_by_order(x);
                if(it!=s.end() && zz){
                    e-=1LL*((*it).first)*((*it).second);
                }
                // cout<<'p'<<e<<endl;
            }
        }
        return v;
    }
};",1420572146
John Rigby,vanshkunwarji41,212,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> v;
        map<int,int> m;
        set<pair<int,int>> s;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
            s.erase({m[nums[i]]-1,nums[i]});
            s.insert({m[nums[i]],nums[i]});
            int r=0;
            int e=0;
            // for(auto i:s){
            //     cout<<(i.first)<<"" ""<<i.second<<endl;
            // }
            // cout<<endl;
            for(auto it=s.rbegin();it!=s.rend();it++){
                e+=((*it).first)*((*it).second);
                // cout<<((*it).first)<<"" ""<<((*it).second)<<endl;
                r++;
                if(r==x){
                    break;
                }
            }
            // cout<<endl;
            if(i>=k-1){
            // for(auto i:s){
            //     cout<<i.first<<"" ""<<i.second<<endl;
            // }
            // cout<<endl;
                v.push_back(e);
                m[nums[i-k+1]]--;
                s.erase({m[nums[i-k+1]]+1,nums[i-k+1]});
                s.insert({m[nums[i-k+1]],nums[i-k+1]});
            }
        }
        return v;
    }
};",1420529876
Abhishek Choudhary,theabbie,215,3509,python3,"class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def dfs(r):
            if not r:
                return (0, True)
            ls, lp = dfs(r.left)
            rs, rp = dfs(r.right)
            curr = lp and rp and ls == rs
            if curr:
                res.append(ls + rs + 1)
            return (ls + rs + 1, curr)
        dfs(root)
        res.sort(reverse = True)
        return res[k - 1] if k <= len(res) else -1",1420599994
Abhishek Choudhary,theabbie,215,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mp = {'FE': 1, 'EF': -1, 'WF': 1, 'FW': -1, 'EW': 1, 'WE': -1, 'FF': 0, 'EE': 0, 'WW': 0}
        dp = [[[-1, -1, -1] for _ in range(2 * n + 1)] for _ in range(n)]
        ss = 'FWE'
        M = 10 ** 9 + 7
        def count(i, diff, prev):
            if i >= n:
                if diff <= 0:
                    return 0
                return 1
            if prev != -1 and dp[i][n + diff][ss.index(prev)] != -1:
                return dp[i][n + diff][ss.index(prev)]
            res = 0
            for x in ss:
                if x != prev:
                    res += count(i + 1, diff + mp[x + s[i]], x)
                    res %= M
            if prev != -1:
                dp[i][n + diff][ss.index(prev)] = res
            return res
        return count(0, 0, -1)",1420614803
Abhishek Choudhary,theabbie,215,3592,python3,"from collections import Counter
from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        ctr = Counter()
        r = SortedList()
        l = SortedList()
        s = 0
        def balance():
            nonlocal s
            while len(r) > x:
                v = r.pop(0)
                s -= v[0] * v[1]
                l.add(v)
            while len(r) < x and len(l) > 0:
                v = l.pop(-1)
                s += v[0] * v[1]
                r.add(v)
        def add(val):
            nonlocal s
            if len(r) > 0 and val >= r[0]:
                s += val[0] * val[1]
                r.add(val)
            else:
                l.add(val)
            balance()
        def remove(val):
            nonlocal s
            if len(r) > 0 and val >= r[0]:
                s -= val[0] * val[1]
                r.remove(val)
            else:
                l.remove(val)
            balance()
        for i in range(n):
            if ctr[nums[i]]:
                remove((ctr[nums[i]], nums[i]))
            ctr[nums[i]] += 1
            add((ctr[nums[i]], nums[i]))
            if i >= k:
                remove((ctr[nums[i - k]], nums[i - k]))
                ctr[nums[i - k]] -= 1
                if ctr[nums[i - k]]:
                    add((ctr[nums[i - k]], nums[i - k]))
            if i >= k - 1:
                res.append(s)
        return res",1420592724
Abhishek Choudhary,theabbie,215,3610,python3,"from collections import Counter
from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        ctr = Counter()
        r = SortedList()
        l = SortedList()
        s = 0
        def balance():
            nonlocal s
            while len(r) > x:
                v = r.pop(0)
                s -= v[0] * v[1]
                l.add(v)
            while len(r) < x and len(l) > 0:
                v = l.pop(-1)
                s += v[0] * v[1]
                r.add(v)
        def add(val):
            nonlocal s
            if len(r) > 0 and val >= r[0]:
                s += val[0] * val[1]
                r.add(val)
            else:
                l.add(val)
            balance()
        def remove(val):
            nonlocal s
            if len(r) > 0 and val >= r[0]:
                s -= val[0] * val[1]
                r.remove(val)
            else:
                l.remove(val)
            balance()
        for i in range(n):
            if ctr[nums[i]]:
                remove((ctr[nums[i]], nums[i]))
            ctr[nums[i]] += 1
            add((ctr[nums[i]], nums[i]))
            if i >= k:
                remove((ctr[nums[i - k]], nums[i - k]))
                ctr[nums[i - k]] -= 1
                if ctr[nums[i - k]]:
                    add((ctr[nums[i - k]], nums[i - k]))
            if i >= k - 1:
                res.append(s)
        return res",1420594343
Mark33,mark233,217,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.res = []
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def DFS(node):
            if not node:
                return False, 0
            if not node.left and not node.right:
                self.res.append(1)
                return True, 1
            l, l_size = DFS(node.left)
            r, r_size = DFS(node.right)
            if l and r and l_size == r_size:
                self.res.append(l_size + r_size + 1)
                return True, l_size + r_size + 1
            return False, 0
        DFS(root)
        if k > len(self.res):
            return -1
        self.res.sort(reverse = True)
        return self.res[k - 1]",1420526970
Mark33,mark233,217,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        score_map = {""FE"":1,""EF"":-1,""WF"":1,""FW"":-1,""EW"":1,""WE"":-1,""FF"":0,""EE"":0,""WW"":0}
        counter = collections.defaultdict(lambda: collections.defaultdict(collections.Counter))
        res = 0
        for idx, Ali_c in enumerate(s):
            if idx == 0:
                for Bob_c in 'FWE':
                    counter[idx][Bob_c][score_map[f'{Bob_c}{Ali_c}']] += 1
                continue
            prev_scores = counter[idx-1]
            for Bob_c in 'FWE':
                for prev_c, score_counter in prev_scores.items():
                    # print(len(score_counter))
                    if Bob_c == prev_c:
                        continue
                    for score, score_count in score_counter.items():
                        new_score = score + score_map[f'{Bob_c}{Ali_c}']
                        if new_score > len(s) - idx - 1:
                            res = res + 2 ** (len(s) - idx - 1) * score_count
                            res = res % (10 ** 9 + 7)
                        elif new_score > -(len(s) - idx - 1):
                            counter[idx][Bob_c][new_score] += score_count
        
        for _, score_counter in counter[len(s)-1].items():
            for score, score_count in score_counter.items():
                if score < 1:
                    continue
                res += score_count
        return res % (10 ** 9 + 7)",1420565103
Mark33,mark233,217,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedList
        counter = collections.Counter(nums[:k])
        sorted_counter = SortedList((-j, -i) for i, j in counter.items())
        prev_sum = sum(i * j for i, j in sorted_counter[:x])
        res = []
        for i in range(len(nums)-k + 1):
            res.append(prev_sum)
            if i == len(nums)-k:
                break
            out = (-counter[nums[i]], -nums[i])
            counter[nums[i]] -= 1
            out_idx = sorted_counter.bisect_left(out)
            if out_idx < x:
                prev_sum -= out[0] * out[1]
            sorted_counter.remove(out)
            if out_idx < x and len(sorted_counter) >= x:
                prev_sum += sorted_counter[x-1][0] * sorted_counter[x-1][1]
            # print(sorted_counter,prev_sum)
            
            if counter[nums[i]] != 0:
                in1 = (-counter[nums[i]], -nums[i])
                in1_idx = sorted_counter.bisect_left(in1)
                if in1_idx < x:
                    if len(sorted_counter) >= x:
                        prev_sum -= sorted_counter[x-1][0] * sorted_counter[x-1][1]
                    prev_sum += in1[0] * in1[1]
                sorted_counter.add(in1)
            # print(sorted_counter, prev_sum)
                
            if counter[nums[i+k]] != 0:
                out2 = (-counter[nums[i+k]], -nums[i+k])
                out2_idx = sorted_counter.bisect_left(out2)
                if out2_idx < x:
                    prev_sum -= out2[0] * out2[1]
                sorted_counter.remove(out2)
                if out2_idx < x and len(sorted_counter) >= x:
                    prev_sum += sorted_counter[x-1][0] * sorted_counter[x-1][1]
            # print(sorted_counter, prev_sum)
                    
            counter[nums[i+k]] += 1
            in2 = (-counter[nums[i+k]], -nums[i+k])
            in2_idx = sorted_counter.bisect_left(in2)
            if in2_idx < x:
                if len(sorted_counter) >= x:
                    prev_sum -= sorted_counter[x-1][0] * sorted_counter[x-1][1]
                prev_sum += in2[0] * in2[1]
            sorted_counter.add(in2)
            # print(sorted_counter, prev_sum)
        return res",1420609137
Mark33,mark233,217,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        counter = collections.Counter(nums[:k])
        res = []
        for i in range(len(nums)-k + 1):
            tmp = sorted([(-j, -i) for i, j in counter.items()])
            res.append(sum(i * j for i, j in tmp[:x]))
            if i == len(nums)-k:
                break
            counter[nums[i]] -= 1
            counter[nums[i+k]] += 1
        return res",1420521206
user5523nc,user5523nc,221,3509,cpp,"struct Info
{
    bool isPerfect;
    int depth;
    int subtree;
};

class Solution
{
    vector<Info> arr;

    Info dfs(TreeNode *r)
    {
        if (r == nullptr)
            return {true, 0, 0};

        Info left = dfs(r->left), right = dfs(r->right);
        int subtree = left.subtree + right.subtree + r->val;
        bool isPerfect = left.isPerfect && right.isPerfect && left.depth == right.depth;
        if (isPerfect)
            arr.push_back({isPerfect, left.depth + 1, subtree});

        return {isPerfect, left.depth + 1, subtree};
    }

public:
    int kthLargestPerfectSubtree(TreeNode *root, int k)
    {
        dfs(root);
        if (k > arr.size())
            return -1;

        sort(arr.begin(), arr.end(), [](Info &a, Info &b)
             { return a.depth > b.depth; });

        return pow(2, arr[k - 1].depth) - 1;
    }
};",1420530905
user5523nc,user5523nc,221,3588,cpp,"
class Solution
{
    int offset;
    vector<vector<vector<long long>>> dp;
    long long m = 1e9 + 7;

    int getScore(int a, int b)
    {
        if (a == b)
            return 0;
      
        if (a == 0 && b == 2)
            return -1;
        if (a == 2 && b == 0)
            return 1;

        if (a == 0 && b == 1)
            return 1;
        if (a == 1 && b == 0)
            return -1;
      
        if (a == 1 && b == 2)
            return 1;
        return -1;
    }

    long long solve(int idx, int lastChosen, int scoreDiff, int n, string &s)
    {
        if (idx == n)
            return scoreDiff > 0;
            
        if (dp[idx][lastChosen][scoreDiff + offset] != -1)
            return dp[idx][lastChosen][scoreDiff + offset];

        long long ans = 0;

        int aMove = -1;
        if (s[idx] == 'F')
            aMove = 0;
        else if (s[idx] == 'W')
            aMove = 1;
        else
            aMove = 2;

        for (int bMove = 0; bMove < 3; bMove++)
        {
            if (lastChosen == bMove)
                continue;
            ans += solve(idx + 1, bMove, scoreDiff + getScore(aMove, bMove), n, s);
            ans %= m;
        }

        return dp[idx][lastChosen][scoreDiff + offset] = ans;
    }

public:
    int countWinningSequences(string s)
    {
        int n = s.size();
        offset = n;
        dp.resize(n, vector<vector<long long>>(4, vector<long long>(2 * n + 1, -1)));

        return solve(0, 3, 0, n, s);
    }
};",1420549314
user5523nc,user5523nc,221,3592,cpp,"
class Solution
{
public:
    vector<long long> findXSum(vector<int> &arr, int k, int x)
    {
        int n = arr.size();
        vector<long long> res;
        long long ans = 0;

        using pll = pair<long long, long long>;
        set<pll> topX;
        priority_queue<pll> pq;

        map<long long, long long> fr;
        for (int i = 0; i < k; i++)
            fr[arr[i]]++;
        for (auto p : fr)
            pq.push({p.second, p.first});
        int curSz = pq.size();
        for (int i = 0; i < min(x, curSz); i++)
        {
            topX.insert({pq.top()});
            ans += pq.top().first * pq.top().second;
            pq.pop();
        }
        res.push_back(ans);

        for (int i = 1; i < n - k + 1; i++)
        {
            int remIdx = i - 1, addIdx = i + k - 1;
            if (arr[remIdx] == arr[addIdx])
            {
                res.push_back(ans);
                continue;
            }

            if (topX.find({fr[arr[remIdx]], arr[remIdx]}) != topX.end())
            {
                topX.erase({fr[arr[remIdx]], arr[remIdx]});
                ans -= arr[remIdx] * fr[arr[remIdx]];
            }
            fr[arr[remIdx]]--;
            pq.push({fr[arr[remIdx]], arr[remIdx]});

            fr[arr[addIdx]]++;
            if (topX.find({fr[arr[addIdx]] - 1, arr[addIdx]}) != topX.end())
            {
                ans += arr[addIdx];
                topX.erase({fr[arr[addIdx]] - 1, arr[addIdx]});
                topX.insert({fr[arr[addIdx]], arr[addIdx]});
            }
            else
                pq.push({fr[arr[addIdx]], arr[addIdx]});

            while (pq.size() && topX.size() && pq.top() > *topX.begin())
            {
                auto [cnt, val] = pq.top();
                pq.pop();
                if (fr[val] != cnt)
                    continue;
                ans += cnt * val;

                auto toGo = *topX.begin();
                topX.erase(topX.begin());
                ans -= toGo.first * toGo.second;

                topX.insert({cnt, val});
                pq.push(toGo);
            }

            while (topX.size() < x && pq.size())
            {
                auto [cnt, val] = pq.top();
                pq.pop();

                if (fr[val] != cnt || topX.find({cnt, val}) != topX.end())
                    continue;
                topX.insert({cnt, val});
                ans += cnt * val;
            }

            res.push_back(ans);
        }

        return res;
    }
};",1420599042
user5523nc,user5523nc,221,3610,cpp,"
class Solution
{
public:
    vector<int> findXSum(vector<int> &arr, int k, int x)
    {
        int n = arr.size();

        vector<int> res;
        for (int i = 0; i < n - k + 1; i++)
        {
            map<int, int> fr;
            for (int j = i; j < i + k; j++)
                fr[arr[j]]++;

            vector<pair<int, int>> arr;
            for (auto p : fr)
                arr.push_back({p.second, p.first});

            sort(arr.begin(), arr.end(), greater<pair<int, int>>());
            int ans = 0;
            for (int i = 0; i < min(x, int(arr.size())); i++)
                ans += arr[i].second * arr[i].first;

            res.push_back(ans);
        }

        return res;
    }
};",1420521251
junbinliang,junbinliang,222,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> a;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(a.begin(), a.end());
        reverse(a.begin(), a.end());
        if(k > a.size()) return -1;
        return a[k - 1];
    }
    
    pair<int, int> dfs(TreeNode* root) {
        if(root == NULL) return {0, 0};
        
        
        pair<int, int> p1 = dfs(root -> left);
        pair<int, int> p2 = dfs(root -> right);
        
        int count = 1 + p1.second + p2.second;
        int level = max(p1.first, p2.first) + 1;
        //cout << root -> val << ""  "" << level << "" "" << count << endl;
        if(level <= 20 && ((1 << level) - 1) == count) {
            //cout << root -> val << ""  "" << level << "" "" << count << endl;
            a.push_back(count);
        }
        return {level, count};
    }
};",1420527073
junbinliang,junbinliang,222,3588,cpp,"const int MOD = 1e9 + 7;
const int N = 1015;
int dp[N][3][2][N];
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        for(int i = 0; i <= n; i++) {
            for(int j = 0; j < 3; j++) {
                for(int x = 0; x < 2; x++) {
                    for(int y = 0; y <= n; y++) {
                        dp[i][j][x][y] = -1;
                    }
                }
            }
        }
        
        vector<int> a;
        for(char c : s) {
            if(c == 'F') a.push_back(0);
            if(c == 'E') a.push_back(1);
            if(c == 'W') a.push_back(2);
        }
        
        int ans = dfs(a, 0, 0, 0, 0);
        return ans;
        
    }
    
    int get(int x, int y) {
        if(x == 0) {
            if(y == 2) return 1;
            else if(y == 0) return 0;
            else return -1;
        } else if(x == 1) {
            if(y == 0) return 1;
            else if(y == 1) return 0;
            else return -1;
        } else {
            if(y == 1) return 1;
            else if(y == 2) return 0;
            else return -1;
        }
    }
    
    
    int dfs(vector<int>& a, int i, int last, int who, int diff) { //0 : alice  1 : bob
        if(i >= a.size()) {
            if(who == 1) {
                return 1;
            }
            else return 0;
        }
        
        if(dp[i][last][who][diff] != -1) return dp[i][last][who][diff];
        int ans = 0;
        
        for(int j = 0; j < 3; j++) {
            if(j == last && i != 0) continue;
            int score = get(a[i], j);
            
            if(score == 0) {
                ans += dfs(a, i + 1, j, who, diff);
            } else if(score == -1) {
                if(who == 0) { //alice
                    ans += dfs(a, i + 1, j, who, diff + 1);
                } else { //bob
                    int d = diff - 1;
                    int nwho = who;
                    if(d == 0) nwho ^= 1;
                    ans += dfs(a, i + 1, j, nwho, abs(d));
                }
            } else if(score == 1) {
                if(who == 1) { //bob
                    ans += dfs(a, i + 1, j, who, diff + 1);
                } else { //alice
                    int d = diff - 1;
                    int nwho = who;
                    if(d < 0) nwho ^= 1;
                    ans += dfs(a, i + 1, j, nwho, abs(d));
                }
            }
            ans %= MOD;
            
        }
        
        //cout << i << "" "" << last << "" "" << who << "" "" << diff << endl;
        
        return dp[i][last][who][diff] = ans;
    }
};",1420553957
junbinliang,junbinliang,222,3592,cpp,"/*const int MAX = 200000 + 100;

struct Node {
    int l, r;
    int cnt;
    long long sum = 0;
}   tr[MAX * 4];

void build(int id) {
    int l = tree[id].l, r = tree[id].r;
    if(l == r) {
        return;
    }
    int mid = l + (r - l) / 2;
    tr[id * 2 + 1] = {l, mid, 0, 0};
    tr[id * 2 + 2] = {mid + 1, r, 0, 0};
    build(id * 2 + 1);
    build(id * 2 + 2);
}

void update(int id, int index, int val) { 
    int l = tree[id].l, r = tree[id].r;
    if(l == r) {
        tree[id].cnt += val;
        tr[id].sum += (val * index);
        return;
    }

    int mid = l + (r - l) / 2;
    int left = id * 2 + 1, right = id * 2 + 2;
    if(index <= mid) {
        update(left, index, val);
    } else {
        update(right, index, val);
    }
    
    tr[id].s = tr[left].s + tr[right].s;
    tr[id].cnt = tr[left].cnt + tr[right].cnt;
}

long long query1(int id, int s, int e) {
    int l = tree[id].l, r = tree[id].r;
    if(l == s && r == e){
        return tr[id].s;
    }
    int mid = l + (r - l) / 2;
    int left = id * 2 + 1, right = id * 2 + 2;
    if(e <= mid){
        return query1(left, s, e);
    } else if(s >= mid + 1) {
        return query1(right, s, e);
    } else {
        query1(left, s, mid) + query1(right, mid + 1, e);
    }
}

int query2(int id, int s, int e) {
    int l = tree[id].l, r = tree[id].r;
    if(l == s && r == e){
        return tr[id].cnt;
    }
    int mid = l + (r - l) / 2;
    int left = id * 2 + 1, right = id * 2 + 2;
    if(e <= mid){
        return query2(left, s, e);
    } else if(s >= mid + 1) {
        return query2(right, s, e);
    } else {
        query2(left, s, mid) + query2(right, mid + 1, e);
    }
}

void dfs(int u, int index) {
    int left = u * 2 + 1, right = u * 2 + 2;
    
}*/


#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <queue>
#include <deque>
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>


using ll = long long;
#define pb push_back
#define ve vector
#define FOR(i, a, b) for (int i = a; i < b; ++i)
using namespace std;
using namespace __gnu_pbds;


template<class TIn, class TOut = null_type>
using order_tree = tree<TIn, TOut, less<TIn>, rb_tree_tag,
	tree_order_statistics_node_update>;



const int SIZE = 200000 + 100;
struct Fenwick {
  long long tree[SIZE];
  void init(int n) {
    for(int i = 0; i <= n + 1; i++) tree[i] = 0;
  }

  void update(int i, long long val) {
    i++;
    while(i < SIZE){
      tree[i] += val;
      i += (i & -i);
    }
  }

  long long pre(int i) {
    long long sum = 0;
    while(i>0){
      sum += tree[i];
      i -= ( i & -i);
    }
    return sum;
  }
  long long query(int i, int j) {
      return pre(j + 1) - pre(i);
  }
} tr;

const int N = 1e5 + 10;


class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        
        
        vector<long long> ans;
        unordered_map<int, int> f;
        
        set<pair<int, int>> ls, rs;
        long long s1 = 0, s2 = 0;
        
        for(int i = 0; i < n; i++) {
            f[a[i]]++;
            
            pair<int, int> p = {f[a[i]], a[i]};
            add(ls, rs, s1, s2, p);
            adjust(ls, rs, x, s1, s2);
            
            if(f[a[i]] > 1) {
                pair<int, int> p = {f[a[i]] - 1, a[i]};
                if(ls.find(p) != ls.end()) {
                    ls.erase(p);
                    s1 -= ((p.first + 0ll) * p.second);
                } else {
                    rs.erase(p);
                    s2 -= ((p.first + 0ll) * p.second);
                }
                adjust(ls, rs, x, s1, s2);
            }
            
      
            
            if(i + 1 >= k) {
                ans.push_back(s2);
                
                int j = i - k + 1;
                pair<int, int> p = {f[a[j]], a[j]};
                if(ls.find(p) != ls.end()) {
                    ls.erase(p);
                    s1 -= ((p.first + 0ll) * p.second);
                } else {
                    rs.erase(p);
                    s2 -= ((p.first + 0ll) * p.second);
                }
                
                adjust(ls, rs, x, s1, s2);
                
                
                f[a[j]]--;
                if(f[a[j]] > 0) {
                    pair<int, int> p = {f[a[j]], a[j]};
                    add(ls, rs, s1, s2, p);
                    adjust(ls, rs, x, s1, s2);
                   // cout << ""gg3 "" << endl;
                }
                
            }
        }
        return ans;
    }
    
    void adjust(set<pair<int, int>>& ls, set<pair<int, int>>& rs, int x, long long& s1, long long& s2) {
        while(ls.size() > 0 && rs.size() < x) {
            auto it = ls.end();
            it--;
            pair<int, int> p = *it;
            s1 -= ((p.first + 0ll) * p.second);
            s2 += ((p.first + 0ll) * p.second);
            ls.erase(p);
            rs.insert(p);
        }
        
        while(rs.size() > x) {
            auto it = rs.begin();
            pair<int, int> p = *it;
            s2 -= ((p.first + 0ll) * p.second);
            s1 += ((p.first + 0ll) * p.second);
            ls.insert(p);
            rs.erase(p);
        }
    }
    
    bool com(pair<int, int>& p1, pair<int, int>& p2) {
        if(p1.first == p2.first) return p1.second < p2.second;
        return p1.first < p2.first;
    }
    
    void add(set<pair<int, int>>& ls, set<pair<int, int>>& rs, long long& s1, long long& s2, pair<int, int>& p) {
        
        if(rs.size() > 0) {
            auto it = rs.begin();
            pair<int, int> p1 = *it;
            if(com(p, p1)) {
                ls.insert(p);
                s1 += ((p.first + 0ll) * p.second);
            } else {
                rs.insert(p);
                s2 += ((p.first + 0ll) * p.second);
            }
            
        } else {
            ls.insert(p);
            s1 += ((p.first + 0ll) * p.second);
        }
    }
    
};",1420616360
junbinliang,junbinliang,222,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        vector<int> ans;
        map<int, int> f;
        for(int i = 0; i < a.size(); i++) {
            f[a[i]]++;
            if(i + 1 >= k) {
                ans.push_back(get(f, x));
                f[a[i - k + 1]]--;
                if(f[a[i - k + 1]] == 0) f.erase(a[i - k + 1]);
            }
        }
        return ans;
    }
    
    int get(map<int, int>& f, int x) {
        vector<pair<int, int>> a;
        for(auto it = f.begin(); it != f.end(); it++) {
            a.push_back({it -> second, it -> first});
        }
        sort(a.begin(), a.end());
        reverse(a.begin(), a.end());
        
        int s = 0;
        for(int i = 0; i < min((int)(a.size()), x); i++) {
            s += a[i].first * a[i].second;
        }
        return s;
    }
};",1420520131
Ravi,xyzabcdef,223,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map<TreeNode*, int>sz;
    map<TreeNode*, bool>isPerfectBinaryTree;
    bool dfs(TreeNode* root){
        if(root == nullptr)return true;
        bool ok = true;
        if(root -> left && root -> right){
            ok = dfs(root -> left) & dfs(root -> right);
            ok = ok&(sz[root -> left] == sz[root -> right]);
            sz[root] = sz[root -> left] + sz[root -> right];
        } else if(root -> left || root -> right){
            ok = dfs(root -> left) & dfs(root -> right);
            sz[root] = sz[root -> left] + sz[root -> right];
            ok = false;
        }
        sz[root] += 1;
        isPerfectBinaryTree[root] = ok;
        return ok;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        vector<int>vec;
        for(auto [ptr, ok]: isPerfectBinaryTree){
            if(ok){
                vec.push_back(sz[ptr]);
            }
        }
        sort(vec.begin(), vec.end(), greater<int>());
        // for(auto z: vec)cout<<z<<"" "";cout<<'\n';
        if(vec.size() < k)return -1;
        return vec[k-1];
    }
};",1420581155
Ravi,xyzabcdef,223,3588,cpp,"const long long mod = 1e9+7;
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        using ll = long long;
        vector<vector<vector<ll>>>dp(n, vector<vector<ll>>(2*n+1, vector<ll>(4, -1)));
        // 0 -> fire
        // 1 -> water
        // 2 -> earth
        map<char, int>mp;
        mp['F'] = 0;
        mp['W'] = 1;
        mp['E'] = 2;
        auto getWinner = [&](int i, int p){
            if(mp[s[i]] == p){
                return 0;
            }
            if(s[i] == 'F'){
                if(p == 1)return 1;
            } else if(s[i] == 'W'){
                if(p == 2)return 1;
            } else if(s[i] == 'E'){
                if(p == 0)return 1;
            }
            return -1;
        };
        auto solve = [&](int i, int diff, int last, auto &&solve) -> ll{
            if(i == n){
                return diff > 0;
            }
            auto &res = dp[i][diff+n][last];
            if(res != -1){
                return res;
            }
            res = 0;
            for(int p = 0; p < 3; p++){
                if(p == last)continue;
                res += solve(i+1, diff + getWinner(i ,p), p, solve);
                res %= mod;
            }
            return res;
        };
        return solve(0, 0, 3, solve);
    }
};",1420604894
Ravi,xyzabcdef,223,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        using ll = long long;
        int n = nums.size();
        using pii = pair<long long, long long>;
        multiset<pii>include, exclude;
        map<ll, ll>mp;
        ll sum = 0;
        for(int i = 0; i < k; i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]] = 1;
                include.insert({1, nums[i]});
            } else{
                include.erase(include.lower_bound({mp[nums[i]], nums[i]}));
                mp[nums[i]] += 1;
                include.insert({mp[nums[i]], nums[i]});
            }
            sum += nums[i];
        }
        
        while(include.size() > x){
            auto it = *include.begin();
            sum -= (it.first)*(it.second);
            exclude.insert(*include.begin());
            include.erase(include.begin());
        }
        vector<ll>res;
        res.push_back(sum);
        int start = 0;
        for(int i = k; i < n; i++){
            if((mp.find(nums[i]) != mp.end()) && (include.find({mp[nums[i]], nums[i]}) != include.end())){
                include.erase({mp[nums[i]], nums[i]});
                mp[nums[i]] += 1;
                include.insert({mp[nums[i]], nums[i]});
                sum += nums[i];
            } else{
                if(mp.find(nums[i]) != mp.end()){
                    exclude.erase({mp[nums[i]], nums[i]});
                     mp[nums[i]] += 1;
                    exclude.insert({mp[nums[i]], nums[i]});
                } else{
                    mp[nums[i]] += 1;
                    exclude.insert({mp[nums[i]], nums[i]});
                }
            }
            if(include.size()){
                auto it = *include.begin();
                sum -= (it.first)*(it.second);
                exclude.insert(it);
                include.erase(it);
            }
            auto pii = make_pair(mp[nums[start]], nums[start]);
            if(include.find(pii) != include.end()){
                auto it = *include.find(pii);
                sum -= (it.first)*(it.second);
                include.erase(it);
            } else if(exclude.size() && exclude.find(pii) != exclude.end()){
                exclude.erase(pii);
            }
            if(include.size()){
                auto it = *include.begin();
                sum -= (it.first)*(it.second);
                exclude.insert(it);
                include.erase(it);
            }
            mp[nums[start]]--;
            if(mp[nums[start]] == 0){
                mp.erase(nums[start]);
            } else{
                exclude.insert({mp[nums[start]], nums[start]});
            }
            while(exclude.size() && include.size() < x){
                auto it = *exclude.rbegin();
                sum += (it.first)*(it.second);
                include.insert(it);
                exclude.erase(it);
            }
            res.push_back(sum);
            start++;
            // for(auto z: include){
            //     cout<<z.first<<"" ""<<z.second<<'\n';
            // }
            // cout<<""_______\n"";
            // for(auto z: exclude){
            //     cout<<z.first<<"" ""<<z.second<<'\n';
            // } 
            // cout<<""_________________________\n"";
        }
        return res;
    }
};",1420569770
Ravi,xyzabcdef,223,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        using ll = int;
        int n = nums.size();
        using pii = pair<long long, long long>;
        multiset<pii>include, exclude;
        map<ll, ll>mp;
        ll sum = 0;
        for(int i = 0; i < k; i++){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]] = 1;
                include.insert({1, nums[i]});
            } else{
                include.erase(include.lower_bound({mp[nums[i]], nums[i]}));
                mp[nums[i]] += 1;
                include.insert({mp[nums[i]], nums[i]});
            }
            sum += nums[i];
        }
        
        while(include.size() > x){
            auto it = *include.begin();
            sum -= (it.first)*(it.second);
            exclude.insert(*include.begin());
            include.erase(include.begin());
        }
        vector<ll>res;
        res.push_back(sum);
        int start = 0;
        for(int i = k; i < n; i++){
            if((mp.find(nums[i]) != mp.end()) && (include.find({mp[nums[i]], nums[i]}) != include.end())){
                include.erase({mp[nums[i]], nums[i]});
                mp[nums[i]] += 1;
                include.insert({mp[nums[i]], nums[i]});
                sum += nums[i];
            } else{
                if(mp.find(nums[i]) != mp.end()){
                    exclude.erase({mp[nums[i]], nums[i]});
                     mp[nums[i]] += 1;
                    exclude.insert({mp[nums[i]], nums[i]});
                } else{
                    mp[nums[i]] += 1;
                    exclude.insert({mp[nums[i]], nums[i]});
                }
            }
            if(include.size()){
                auto it = *include.begin();
                sum -= (it.first)*(it.second);
                exclude.insert(it);
                include.erase(it);
            }
            auto pii = make_pair(mp[nums[start]], nums[start]);
            if(include.find(pii) != include.end()){
                auto it = *include.find(pii);
                sum -= (it.first)*(it.second);
                include.erase(it);
            } else if(exclude.size() && exclude.find(pii) != exclude.end()){
                exclude.erase(pii);
            }
            if(include.size()){
                auto it = *include.begin();
                sum -= (it.first)*(it.second);
                exclude.insert(it);
                include.erase(it);
            }
            mp[nums[start]]--;
            if(mp[nums[start]] == 0){
                mp.erase(nums[start]);
            } else{
                exclude.insert({mp[nums[start]], nums[start]});
            }
            while(exclude.size() && include.size() < x){
                auto it = *exclude.rbegin();
                sum += (it.first)*(it.second);
                include.insert(it);
                exclude.erase(it);
            }
            res.push_back(sum);
            start++;
        }
        return res;
    }
};",1420571628
Yuanbin Cheng,cybsbbbb,227,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        
        def helper(root):
            if root.left is None and root.right is None:
                ans.append(1)
                return 1, True
            left_dep, left_ind = -1, False
            right_dep, right_ind = -1, False
            if root.left:
                left_dep, left_ind = helper(root.left)
            if root.right:
                right_dep, right_ind = helper(root.right)
            if left_ind is True and right_ind is True and left_dep == right_dep:
                ans.append(left_dep + 1)
                return left_dep + 1, True
            else:
                return -1, False

        helper(root)

        # print(ans)
        ans.sort(reverse=True)
        if len(ans) < k:
            return -1
        else:
            return (1 << ans[k - 1]) - 1

        ",1420535494
Yuanbin Cheng,cybsbbbb,227,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        dp = collections.defaultdict(int)
        MOD = 10 ** 9 + 7
        s_idx = {'W': 0, 'F': 1, 'E': 2}
        idx_s = {0: 'W', 1: 'F', 2: 'E'}
        stat = {('W', 'W'): 0, ('W', 'F'): -1, ('W', 'E'): 1, 
                ('F', 'W'): 1, ('F', 'F'): 0, ('F', 'E'): -1, 
                ('E', 'W'): -1, ('E', 'F'): 1, ('E', 'E'): 0}
        dp[(0, stat[(s[0], idx_s[0])])] = 1
        dp[(1, stat[(s[0], idx_s[1])])] = 1
        dp[(2, stat[(s[0], idx_s[2])])] = 1

        for i in range(1, n):
            dp_nxt = collections.defaultdict(int)
            for (last, score), cnt in dp.items():
                for cur in range(3):
                    if cur == last:
                        continue
                    cur_score = stat[(s[i], idx_s[cur])]
                    dp_nxt[(cur, score + cur_score)] += cnt
                    dp_nxt[(cur, score + cur_score)] %= MOD
            dp = dp_nxt
        
        ans = 0
        for (last, score), cnt in dp.items():
            if score > 0:
                ans += cnt
                ans %= MOD
        return ans
        





        ",1420559268
Yuanbin Cheng,cybsbbbb,227,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        counts = collections.Counter()
        sorted_list = SortedList()
        
        ans = []
        
        window = nums[:k]
        for num in window:
            counts[num] += 1
        for num, freq in counts.items():
            sorted_list.add((-freq, -num))
        
        x_sum = 0
        for freq, num in sorted_list[:x]:
            x_sum += freq * num
        ans.append(x_sum)
        
        for i in range(1, n - k + 1):
            # handle old
            removed = False
            old_num = nums[i - 1]
            old_freq = counts[old_num]

            old_idx = sorted_list.bisect_left((-old_freq, -old_num))
            if old_idx < x:
                removed = True
                x_sum -= old_freq * old_num
            sorted_list.remove((-old_freq, -old_num))

            counts[old_num] -= 1
            if counts[old_num] > 0:
                sorted_list.add((-counts[old_num], -old_num))
                if removed:
                    tmp_idx = sorted_list.bisect_left((-counts[old_num], -old_num))
                    if tmp_idx < x:
                        freq, num = sorted_list[tmp_idx]
                        x_sum += freq * num
                    else:
                        freq, num = sorted_list[x - 1]
                        x_sum += freq * num
            else:
                if removed and len(sorted_list) >= x:
                    freq, num = sorted_list[x - 1]
                    x_sum += -freq * -num
            
            # print(x_sum)
            # print(sorted_list)

            # handle new
            new_num = nums[i + k - 1]
            new_freq = counts[new_num]
            removed = False
            if counts[new_num] > 0:
                new_idx = sorted_list.bisect_left((-counts[new_num], -new_num))
                if new_idx < x:
                    removed = True
                    x_sum -= counts[new_num] * new_num
                sorted_list.remove((-counts[new_num], -new_num))
            counts[new_num] += 1
            sorted_list.add((-counts[new_num], -new_num))
            tmp_idx = sorted_list.bisect_left((-counts[new_num], -new_num))
            if removed:
                if tmp_idx < x:
                    freq, num = sorted_list[tmp_idx]
                    x_sum += freq * num
                else:
                    freq, num = sorted_list[x - 1]
                    x_sum += freq * num
            else:
                if tmp_idx < x:
                    freq, num = sorted_list[tmp_idx]
                    x_sum += freq * num
                    if len(sorted_list) > x:
                        freq, num = sorted_list[x]
                        x_sum -= freq * num

            ans.append(x_sum)

        return ans
",1420611957
Yuanbin Cheng,cybsbbbb,227,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        for i in range(n - k + 1):
            subarray = nums[i: i+k]
            cnt = collections.Counter(subarray)
            # print(cnt)
            stat = sorted([(val, key) for key, val in cnt.items()], reverse=True)
            # print(stat)
            res = 0
            for val, key in stat[:x]:
                res += val * key
            ans.append(res)
        return ans

            

        ",1420521955
andy-lc,andy-lc,229,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int dfs(TreeNode root, HashMap<TreeNode, Integer> height) {
        if (height.containsKey(root)) {
            return height.get(root);
        }
        int left = dfs(root.left, height);
        int right = dfs(root.right, height);
        if(left == right && left >= 0) {
            int self = left +1;
            height.put(root, self);
            return self;
        }
        int self = Integer.MIN_VALUE;
        height.put(root, self);
        return self;
    }

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        HashMap<TreeNode, Integer> height = new HashMap<>();
        height.put(null, 0);
        dfs(root, height);
        ArrayList<Integer> hlist = new ArrayList<>();
        for (Map.Entry<TreeNode, Integer> entry : height.entrySet()) {
            TreeNode node = entry.getKey();
            if (entry.getValue() <= 0 || !height.get(node.left).equals(height.get(node.right))) {
                continue;
            }
            hlist.add(entry.getValue());
        }
        hlist.sort(Comparator.reverseOrder());
        // System.out.println(hlist.stream().map(Object::toString).collect(Collectors.joining()));
        k -= 1;
        if (k >= hlist.size()) {
            return -1;
        }
        return (int) ((2L << (hlist.get(k)-1)) - 1L);
    }
}",1420537432
andy-lc,andy-lc,229,3588,java,"
class Solution {
    static long M = 1_000_000_007;

    public int countWinningSequences(String _s) {
        final int n = _s.length();
        char[] s = _s.toCharArray();
        long[][] dp = new long[3][2 * s.length + 1]; // dp[i]表示已经赢了i局的玩法
        // 012 -> FWE
        // 0 > 2
        // 1 > 0
        // 2 > 1
        dp[0][(s[0] == 'E' ? 1 : s[0] == 'W' ? -1 : 0) + n] = 1;
        dp[1][(s[0] == 'F' ? 1 : s[0] == 'E' ? -1 : 0) + n] = 1;
        dp[2][(s[0] == 'W' ? 1 : s[0] == 'F' ? -1 : 0) + n] = 1;

        long[][] tmp = new long[3][2 * s.length + 1];
        for (int i = 1; i < s.length; i++) {
            Arrays.fill(tmp[0], 0);
            Arrays.fill(tmp[1], 0);
            Arrays.fill(tmp[2], 0);
            if (s[i] == 'F') {
                for (int j = 1; j < 2 * n + 1; j++) {
                    tmp[1][j] += dp[0][j - 1];
                    tmp[1][j] += dp[2][j - 1];
                    tmp[1][j] %= M;
                }
                for (int j = 0; j < 2 * n + 1; j++) {
                    tmp[0][j] += dp[1][j];
                    tmp[0][j] += dp[2][j];
                    tmp[0][j] %= M;
                }
                for (int j = 0; j < 2 * n; j++) {
                    tmp[2][j] += dp[0][j + 1];
                    tmp[2][j] += dp[1][j + 1];
                    tmp[2][j] %= M;
                }
            }
            if (s[i] == 'W') {
                for (int j = 1; j < 2 * n + 1; j++) {
                    tmp[2][j] += dp[0][j - 1];
                    tmp[2][j] += dp[1][j - 1];
                    tmp[2][j] %= M;
                }
                for (int j = 0; j < 2 * n + 1; j++) {
                    tmp[1][j] += dp[0][j];
                    tmp[1][j] += dp[2][j];
                    tmp[1][j] %= M;
                }
                for (int j = 0; j < 2 * n; j++) {
                    tmp[0][j] += dp[1][j + 1];
                    tmp[0][j] += dp[2][j + 1];
                    tmp[0][j] %= M;
                }
            }
            if (s[i] == 'E') {
                for (int j = 1; j < 2 * n + 1; j++) {
                    tmp[0][j] += dp[1][j - 1];
                    tmp[0][j] += dp[2][j - 1];
                    tmp[0][j] %= M;
                }
                for (int j = 0; j < 2 * n + 1; j++) {
                    tmp[2][j] += dp[0][j];
                    tmp[2][j] += dp[1][j];
                    tmp[2][j] %= M;
                }
                for (int j = 0; j < 2 * n; j++) {
                    tmp[1][j] += dp[0][j + 1];
                    tmp[1][j] += dp[2][j + 1];
                    tmp[1][j] %= M;
                }
            }
            var a = tmp;
            tmp = dp;
            dp = a;
        }
        //System.out.println(Arrays.stream(dp[0]).mapToObj(String::valueOf).collect(Collectors.joining("","")));
        //System.out.println(Arrays.stream(dp[1]).mapToObj(String::valueOf).collect(Collectors.joining("","")));
        //System.out.println(Arrays.stream(dp[2]).mapToObj(String::valueOf).collect(Collectors.joining("","")));

        long ans = 0;
        for (int i = n + 1; i < 2 * n + 1; i++) {
            ans += dp[0][i];
            ans %= M;
            ans += dp[1][i];
            ans %= M;
            ans += dp[2][i];
            ans %= M;
        }
        return (int) ans;
    }
}",1420586731
andy-lc,andy-lc,229,3592,python3,"from sortedcontainers import SortedList as sl
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        snums = set(nums)
        c = {x: 0 for x in snums}
        s = sl([(0, -x) for x in snums])
        sum_ = 0
        res = []
        for i in range(k):
            if s.bisect_left((-c[nums[i]],-nums[i])) < x:
                sum_ -= nums[i] * c[nums[i]]
                if len(s) >= x+1:
                    num,f = s[x]
                    sum_ += num*f
            s.remove((-c[nums[i]],-nums[i]))
            c[nums[i]] += 1
            if s.bisect_left((-c[nums[i]],-nums[i])) < x:
                if len(s) >= x:
                    num,f = s[x-1]
                    sum_ -= num*f
                sum_ += nums[i] * c[nums[i]]
            s.add((-c[nums[i]],-nums[i]))
        res.append(sum_)
        for i in range(k, len(nums)):
            if s.bisect_left((-c[nums[i-k]],-nums[i-k])) < x:
                sum_ -= nums[i-k] * c[nums[i-k]]
                if len(s) >= x+1:
                    num,f = s[x]
                    sum_ += num*f
            s.remove((-c[nums[i-k]],-nums[i-k]))
            c[nums[i-k]] -= 1
            if s.bisect_left((-c[nums[i-k]],-nums[i-k])) < x:
                if len(s) >= x:
                    num,f = s[x-1]
                    sum_ -= num*f
                sum_ += nums[i-k] * c[nums[i-k]]
            s.add((-c[nums[i-k]],-nums[i-k]))
            if s.bisect_left((-c[nums[i]],-nums[i])) < x:
                sum_ -= nums[i] * c[nums[i]]
                if len(s) >= x+1:
                    num,f = s[x]
                    sum_ += num*f
            s.remove((-c[nums[i]],-nums[i]))
            c[nums[i]] += 1
            if s.bisect_left((-c[nums[i]],-nums[i])) < x:
                if len(s) >= x:
                    num,f = s[x-1]
                    sum_ -= num*f
                sum_ += nums[i] * c[nums[i]]
            s.add((-c[nums[i]],-nums[i]))
            res.append(sum_)
        return res",1420618105
andy-lc,andy-lc,229,3610,python3,"def xsum(nums, x):
    set = sorted(collections.Counter(nums).items(), key=lambda x: (-x[1],-x[0]))[:x]
    set = {x for x, _ in set}
    return sum(x for x in nums if x in set)
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        return [xsum(nums[i:i+k],x) for i in range(len(nums)-k+1)]",1420520993
l1cache__,l1cache__,231,3509,cpp,"class Solution {
public:
    vector<int> sz;
    int dfs(TreeNode *u) {
        if (!u) {
			sz.push_back(1);
			return 1;
		}
        int ans = 0, ans2 = 0;
        if (u->left) ans = dfs(u->left);
        if (u->right) ans2 = dfs(u->right);
        if (ans == ans2) {
			sz.push_back(ans + ans2 + 1);
			return ans + ans2 + 1;
		}
		sz.push_back(-1);
        return -1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sz.rbegin(), sz.rend());
        if (k > sz.size()) return -1;
        return sz[k-1];
    }
};",1420564396
l1cache__,l1cache__,231,3588,cpp,"#define ll long long

#define MOD 1000000007

int ctoi(char &c) {
	if (c == 'F') return 0;
	if (c == 'W') return 1;
	return 2;
}

int win(int x) { // return the one that wins against x
	if (x == 0) return 1;
	if (x == 1) return 2;
	return 0;
}

int lose(int x) {
	if (x == 0) return 2;
	if (x == 1) return 0;
	return 1;
}

class Solution {
public:
    int countWinningSequences(string s) {
        ll dp[1001][3005][3] = {{{}}}; // dp[i][j][k] = num winning states of length i with j-1000 points above alice and prev letter k
		dp[0][1501][win(ctoi(s[0]))] = 1;
		dp[0][1500][ctoi(s[0])] = 1;
		dp[0][1499][lose(ctoi(s[0]))] = 1;
		int n = s.size();
		for (int i = 1; i < n; i++) {
			for (int j = 1; j <= 3000; j++) {
				int c = ctoi(s[i]);
				// if (c == 0) {
				// 	dp[i][j][0] = dp[i-1][j][1] + dp[i-1][j][2]; dp[i][j][0] %= MOD;
				// 	dp[i][j+1][1] = dp[i-1][j][0] + dp[i-1][j][2]; dp[i][j+1][1] %= MOD;
				// 	if (j) dp[i][j-1][2] = dp[i-1][j][0] + dp[i-1][j][1]; dp[i][j-1][2] %= MOD;
				// } else if (c == 1) {
				// 	dp[i][j][1] = dp[i-1][j][0] + dp[i-1][j][2]; dp[i][j][1] %= MOD;
				// 	dp[i][j+1][2] = dp[i-1][j][1] + dp[i-1][j][2]; dp[i][j+1][2] %= MOD;
				// 	if (j) dp[i][j-1][0] = dp[i-1][j][1] + dp[i-1][j][2]; dp[i][j-1][0] %= MOD;
				// } else {
				// 	dp[i][j][2] = dp[i-1][j][0] + dp[i-1][j][1]; dp[i][j][2] %= MOD;
				// 	dp[i][j+1][0] = dp[i-1][j][1] + dp[i-1][j][2]; dp[i][j+1][0] %= MOD;
				// 	if (j) dp[i][j-1][1] = dp[i-1][j][0] + dp[i-1][j][2]; dp[i][j-1][1] %= MOD;
				// }
				dp[i][j][c] = dp[i-1][j][win(c)] + dp[i-1][j][lose(c)]; dp[i][j][c] %= MOD;
				dp[i][j+1][win(c)] = dp[i-1][j][c] + dp[i-1][j][lose(c)]; dp[i][j+1][win(c)] %= MOD;
				dp[i][j-1][lose(c)] = dp[i-1][j][c] + dp[i-1][j][win(c)]; dp[i][j-1][lose(c)] %= MOD;
			}
		}
		ll ans = 0;
		for (int i = 1501; i <= 3000; i++) {
			ans += dp[n-1][i][0] + dp[n-1][i][1] + dp[n-1][i][2];
			ans %= MOD;
		}
		return ans;
    }
};",1420564027
l1cache__,l1cache__,231,3592,cpp,"#define ll long long
#define pll pair<ll, ll>

#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
#define ordered_set tree<pll, null_type,less<pll>, rb_tree_tag,tree_order_statistics_node_update>

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<ll> ans;
		ordered_set s;
		unordered_map<ll, ll> occ;
		int l = 0;
		ll cur = 0;
		for (int i = 0; i < nums.size(); i++) {
			int oidx = s.order_of_key({occ[nums[i]], nums[i]});
			s.erase({occ[nums[i]], nums[i]});
			occ[nums[i]]++;
			s.insert({occ[nums[i]], nums[i]});
			if (i > k-1) {
				int nidx = s.order_of_key({occ[nums[i]], nums[i]});
				if (oidx >= (int)(s.size())-x) {
					// increase cur
					cur += nums[i];
				} else if (nidx >= (int)(s.size())-x) {
					// the element previously at (int)(s.size())-x has been replaced by nums[i], which means it moved to (int)(s.size())-x-1
					auto prevele = s.find_by_order((int)(s.size())-x-1);
					cur -= prevele->second * prevele->first;
					cur += nums[i] * occ[nums[i]];
				}
			}
			if (i >= k-1) {
				if (i == k-1) {
					auto it = s.end(); it--;
					for (int j = 0; j < x; j++) {
						cur += it->second * it->first;
						if (it == s.begin()) break;
						it--;
					}
				}
				ans.push_back(cur);
				int idx = s.order_of_key({occ[nums[l]], nums[l]});
				s.erase({occ[nums[l]], nums[l]});
				occ[nums[l]]--;
				s.insert({occ[nums[l]], nums[l]});
				if (idx >= (int)(s.size())-x) {
					int nidx = s.order_of_key({occ[nums[l]], nums[l]});
					if (nidx >= (int)(s.size())-x) {
						cur -= nums[l];
					} else {
						// has been replaced by a diff element (locted at (int)(s.size())-x)
						cur -= nums[l] * (occ[nums[l]]+1);
						auto nele = s.find_by_order((int)(s.size())-x);
						cur += nele->second * nele->first;
					}
				}
				l++;
			}
		}
		return ans;
    }
};",1420601869
l1cache__,l1cache__,231,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int occ[51] = {};
        int l = 0;
        for (int i = 0; i < nums.size(); i++) {
            occ[nums[i]]++;
            if (i >= k-1) {
                int cur = 0;
				vector<pair<int, int>> v;
                for (int j = 0; j <= 50; j++) {
					if (occ[j]) {
						v.push_back({occ[j], j});
					}
                }
				sort(v.rbegin(), v.rend());
				for (int j = 0; j < x; j++) {
					if (j >= v.size()) break;
					cur += v[j].second * v[j].first;
				}
                ans.push_back(cur);
				occ[nums[l]]--;
				l++;
            }
        }
		return ans;
    }
};",1420569391
icode999,icode999,232,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        def search(node):
            if node is None:
                return 0
            n_l = search(node.left)
            n_r = search(node.right)
            if n_l == n_r and n_l != -1:
                s = n_l + n_r + 1
            else:
                s = -1
            sizes.append(s)
            return s
        search(root)
        sizes.sort()
        if k > len(sizes):
            return -1
        return sizes[-k] 

            ",1420533635
icode999,icode999,232,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        loss_map = {""F"":""W"", ""W"":""E"", ""E"":""F""}
        win_map = {""F"":""E"", ""W"":""F"", ""E"":""W""}
        MOD = 10**9 + 7
        n = len(s)
        dp = {}
        for c in ['F', ""W"", 'E']:
            dp[c] = [[0]*(2*n+2) for _ in range(n)]
        l = loss_map[s[0]]
        w = win_map[s[0]]
        dp[s[0]][0][0] = 1
        dp[w][0][-1] = 1
        dp[l][0][1] = 1         
        for i in range(1, n):
            c = s[i]
            l = loss_map[c]
            w = win_map[c]
            for v in range(-i-1, i+2):
                dp[c][i][v] = dp[l][i-1][v] + dp[w][i-1][v]
                dp[l][i][v] = dp[c][i-1][v-1] + dp[w][i-1][v-1]
                dp[w][i][v] = dp[c][i-1][v+1] + dp[l][i-1][v+1]
        cnt = 0
        for i in range(1, n+1):
            cnt += dp[""F""][n-1][i] + dp[""W""][n-1][i] + dp[""E""][n-1][i]
        return cnt %MOD

        
        ",1420561765
icode999,icode999,232,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        freq = defaultdict(int)
        for i in range(k):
            freq[nums[i]] += 1
        self.sl = SortedList([(fre, val) for val, fre in freq.items()])
        ans.append(self.get_sum(x))
        for i in range(1, len(nums) - k+1):
            if nums[i-1] != nums[i-1+k]:
                rst = ans[-1]
                to_remove = [(freq[nums[i-1]], nums[i-1])]
                if freq[nums[i-1+k]]>0:
                    to_remove.append((freq[nums[i-1+k]], nums[i-1+k]))
                to_add = [(freq[nums[i-1+k]]+1, nums[i-1+k])]
                if freq[nums[i-1]]-1>0:
                    to_add.append((freq[nums[i-1]]-1, nums[i-1]))
                freq[nums[i-1]] -= 1
                freq[nums[i-1+k]] += 1
                #print(self.sl)
                #print(to_remove)
                #print(to_add)
                for item in to_remove:
                    removed = False
                    if x> len(self.sl) or item >= self.sl[-x]:
                        rst -= item[0]*item[1]
                        removed = True
                    self.sl.remove(item)
                    if removed and x <= len(self.sl):
                        rst += self.sl[-x][0]*self.sl[-x][1]
                for item in to_add:
                    if x> len(self.sl) or item >= self.sl[-x]:
                        rst += item[0]*item[1]
                        #print(rst)
                        if x <= len(self.sl):
                            rst -= self.sl[-x][0]*self.sl[-x][1]
                    self.sl.add(item)
                #print(rst)
                ans.append(rst)
            else:
                ans.append(ans[-1])
        return ans

    def get_sum(self,x):
        threshold_fre = float('-inf')
        threshold_val = float('-inf')
        if len(self.sl) >= x:
            threshold_fre, threshold_val = self.sl[-x]
        s = 0
        for fre, val in self.sl:
            if fre>threshold_fre:
                s += val*fre
            elif fre==threshold_fre:
                if val >=threshold_val:
                    s += val*fre
        return s",1420619804
icode999,icode999,232,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        freq = defaultdict(int)
        for i in range(k):
            freq[nums[i]] += 1
        ans.append(self.get_sum(freq, x))
        for i in range(1, len(nums) - k+1):
            freq[nums[i-1]] -= 1
            freq[nums[i-1+k]] += 1
            ans.append(self.get_sum(freq, x))
        return ans

    def get_sum(self, freq, x):
        val_fre = [(fre, val) for val, fre in freq.items()]
        val_fre.sort()
        threshold_fre = float('-inf')
        threshold_val = float('-inf')
        if len(val_fre) >= x:
            threshold_fre, threshold_val = val_fre[-x]
        s = 0
        for val, fre in freq.items():
            if fre>threshold_fre:
                s += val*fre
            elif fre==threshold_fre:
                if val >=threshold_val:
                    s += val*fre
        return s
",1420526716
riczhu,riczhu,233,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        def pbsize(node):
            if not node.left and not node.right:
                sizes.append(1)
                return True, 1
            elif node.left and not node.right: return False, pbsize(node.left)[1]+1
            elif not node.left and node.right: return False, pbsize(node.right)[1]+1
            else:
                rec1, rec2 = pbsize(node.left), pbsize(node.right)
                res = (rec1[0] and rec2[0] and rec1[1]==rec2[1])
                sza = rec1[1]+rec2[1]+1
                if res: sizes.append(sza)
                return res, sza
        pbsize(root)
        sizes.sort(reverse=True)
        if len(sizes) < k: return -1
        else: return sizes[k-1]",1420547691
riczhu,riczhu,233,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10**9+7
        lettertoindex = {""F"": 0, ""W"": 1, ""E"": 2}
        currentdict = {(-1, 0): 1}
        for char in s:
            index = lettertoindex[char]
            newcurrent = {}
            for (previous, count), freq in currentdict.items():
                for i in range(3):
                    if i == previous: continue
                    if (i == index):
                        if (i, count) not in newcurrent: newcurrent[(i, count)] = freq
                        else:
                            newcurrent[(i, count)] += freq
                            newcurrent[(i, count)] %= mod
                    elif (i == 1 and index == 0) or (i == 2 and index == 1) or (i == 0 and index == 2):
                        if (i, count+1) not in newcurrent: newcurrent[(i, count+1)] = freq
                        else:
                            newcurrent[(i, count+1)] += freq
                            newcurrent[(i, count+1)] %= mod
                    else:
                        if (i, count-1) not in newcurrent: newcurrent[(i, count-1)] = freq
                        else:
                            newcurrent[(i, count-1)] += freq
                            newcurrent[(i, count-1)] %= mod
            currentdict = newcurrent
        ans = 0
        for (previous, count), freq in currentdict.items():
            if count > 0:
                ans += freq
                ans %= mod
        return ans % mod",1420556773
riczhu,riczhu,233,3592,python3,"from collections import Counter
from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        freqdict = {}
        for i in range(k):
            num = nums[i]
            if num in freqdict: freqdict[num] += 1
            else: freqdict[num] = 1
        freqnum = []
        for num, freq in freqdict.items():
            freqnum.append((freq, num))
        freqnum.sort()
        other = SortedList(freqnum[:-x])
        topx = SortedList(freqnum[-x:])

        ans = [sum(i*j for i,j in topx)]
        currentsum = ans[0]
        for i in range(k, len(nums)):
            if nums[i] in freqdict:
                if (freqdict[nums[i]], nums[i]) in topx:
                    topx.discard((freqdict[nums[i]], nums[i]))
                    currentsum -= freqdict[nums[i]] * nums[i]
                else: other.discard((freqdict[nums[i]], nums[i]))
                freqdict[nums[i]] += 1
                other.add((freqdict[nums[i]], nums[i]))
            else:
                freqdict[nums[i]] = 1
                other.add((freqdict[nums[i]], nums[i]))
            
            if (freqdict[nums[i-k]], nums[i-k]) in topx:
                topx.discard((freqdict[nums[i-k]], nums[i-k]))
                currentsum -= freqdict[nums[i-k]] * nums[i-k]
            else: other.discard((freqdict[nums[i-k]], nums[i-k]))
            freqdict[nums[i-k]] -= 1
            if freqdict[nums[i-k]] != 0:
                other.add((freqdict[nums[i-k]], nums[i-k]))
            if len(topx):
                worst = topx.pop(0)
                currentsum -= worst[0] * worst[1]
                other.add(worst)
            while len(topx) != x and len(other):
                newtuple = other.pop(-1)
                currentsum += newtuple[0] * newtuple[1]
                topx.add(newtuple)
            ans.append(currentsum)

        return ans",1420607896
riczhu,riczhu,233,3610,python3,"from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        for i in range(len(nums)-k+1):
            contig = nums[i:i+k]
            freq = Counter(contig)
            arrfreq = [(val,key) for key, val in freq.items()]
            arrfreq.sort(key=lambda x:(x[0], x[1]))
            arrfreq.reverse()
            answer.append(sum([val*key for val, key in arrfreq[:x]]))
        return answer",1420529326
Nguyễn Minh,minhnguyenxuan60,234,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> siz;
    pair<bool, int> dfs(TreeNode* node) {
        if (node == nullptr) return {true, 0};
        pair<bool, int> leftNode = dfs(node->left);
        pair<bool, int> rightNode = dfs(node->right);

        bool ok = leftNode.first && rightNode.first && (leftNode.second == rightNode.second);
    
        if (ok) {
            siz.push_back(leftNode.second + rightNode.second + 1);
        } 

        return {ok, leftNode.second + rightNode.second + 1};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(siz.begin(), siz.end(), greater<int>());
        for (int x: siz) cout << x << '\n';
        if (siz.size() < k) return -1;
        else return siz[k - 1];

    }
};",1420533248
Nguyễn Minh,minhnguyenxuan60,234,3588,cpp,"class Solution {
public:
    long long mod = 1e9 + 7;
    int countWinningSequences(string s) {
        int n = s.size();
        vector<int> move(n + 1);
        for (int i = 1; i <= n; i++) {
            if (s[i - 1] == 'F') move[i] = 0;
            else if (s[i - 1] == 'W') move[i] = 1;
            else move[i] = 2;
        }

        vector<vector<vector<long long>>> dp(n + 1, vector<vector<long long>>(n * 3 + 1, vector<long long>(3)));

        int padding = n + 1;

        dp[1][padding + 1][(move[1] + 1) % 3] = 1;
        for (int i = 0; i < 3; i++) {
            if (i == move[1]) dp[1][padding][i] = 1;
            else if (i == (move[1] + 2) % 3) dp[1][padding - 1][i] = 1;
        }

        for (int i = 2; i <= n; i++) {
            int winningMove = (move[i] + 1) % 3;

            for (int wins = -n; wins <= n; wins++) {
                for (int curMove = 0; curMove < 3; curMove++) {
                    for (int preMove = 0; preMove < 3; preMove++) {
                        if (preMove == curMove) continue;
                        if (curMove == winningMove) {
                            // winning move
                            dp[i][wins + padding][curMove] = (dp[i][wins + padding][curMove] 
                                                            + dp[i - 1][wins - 1 + padding][preMove]) % mod;
                        } else if (curMove == move[i]) {
                            // draw move
                            dp[i][wins + padding][curMove] = (dp[i][wins + padding][curMove] 
                                                            + dp[i - 1][wins + padding][preMove]) % mod;
                        } else {
                            // loose move
                            dp[i][wins + padding][curMove] = (dp[i][wins + padding][curMove] 
                                                            + dp[i - 1][wins + padding + 1][preMove]) % mod;
                        }
                    }
                }
            }
        }

        long long ans = 0;

        for (int curMove = 0; curMove < 3; curMove++) {
            int tmp = 0;
            for (int wins = 1; wins <= n; wins++) {
                ans = (ans + dp[n][wins + padding][curMove]) % mod;
                tmp = (tmp + dp[n][wins + padding][curMove]) % mod;
            }

            cout << tmp << '\n';
        }
        return ans;
    }
};",1420583323
Nguyễn Minh,minhnguyenxuan60,234,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        long long curSum = 0;
        multiset<pair<long long, long long>> bigger, smaller;
        map<long long, long long> cnt;
        for (int i = 0; i < k; i++) {
            cnt[nums[i]]++;
        }

        auto normalize = [&] {
            if (bigger.size() > x) {
                auto bck = *bigger.begin();
                smaller.insert(bck);
                bigger.erase(bigger.find(bck));
                curSum -= (long long)bck.first * bck.second;
            } else if (bigger.size() < x && !smaller.empty()) {
                auto frt = *smaller.rbegin();
                smaller.erase(smaller.find(frt));
                bigger.insert(frt);
                curSum += (long long) frt.first * frt.second;
            }
        };

        auto add = [&](pair<int, int> a) {
            // {freq, val}
            curSum += (long long)a.first * a.second;
            bigger.insert(a);
            normalize();
        };

        auto remove = [&](pair<int, int> a) {
            if (bigger.find(a) != bigger.end()) {
                curSum -= (long long)a.first * a.second;
                bigger.erase(bigger.find(a));
            } else if (smaller.find(a) != smaller.end()) {
                smaller.erase(smaller.find(a));
            }
            normalize();
        };

        for (auto x: cnt) {
            add({x.second, x.first});
        }

        
        vector<long long> ans;

        ans.push_back(curSum);

        for (int i = 1; i + k - 1 < (int)nums.size(); i++) {
            remove({cnt[nums[i - 1]], nums[i - 1]});
            cnt[nums[i - 1]]--;
            add({cnt[nums[i - 1]], nums[i - 1]});
            
            remove({cnt[nums[i + k - 1]], nums[i + k - 1]});
            cnt[nums[i + k - 1]]++;
            add({cnt[nums[i + k - 1]], nums[i + k - 1]});
            

            ans.push_back(curSum);
        }
        
        return ans;
    }
};",1420620437
Nguyễn Minh,minhnguyenxuan60,234,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for (int i = 0; i + k - 1 < (int)nums.size(); i++) {
            map<int, int> cnt;
            for (int j = i; j < i + k; j++) cnt[nums[j]]++;
            vector<pair<int, int>> tmp;
            for (auto x: cnt) tmp.push_back({x.second, x.first});
            sort(tmp.begin(), tmp.end());
            int curSum = 0;       
            int y = x;     
            while(!tmp.empty() && y--) {
                curSum += tmp.back().first * tmp.back().second;
                cout << i << '\n';
                // cout << tmp.back().first << "" "" << tmp.back().second << '\n';
                tmp.pop_back();
            }
            ans.push_back(curSum);
        }

        return ans;
    }
};",1420522403
azhan0222,azhan0222,236,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def dfs(i):
            if i is None:
                return 0
            a = dfs(i.left)
            b = dfs(i.right)
            if a == b and a != -1:
                sizes.append(2 * a + 1)
                return 2 * a + 1
            else:
                return -1
        
        dfs(root)
        # print(sizes)
        if len(sizes) < k:
            return -1
        return sorted(sizes)[-k]
        ",1420535495
azhan0222,azhan0222,236,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = int(1e9+7)
        n = len(s)
        dp = {c: [0] * (2 * n + 1) for c in 'FWE'}
        tie = {'F': 'F', 'W': 'W', 'E': 'E'}
        win = {'F': 'E', 'W': 'F', 'E': 'W'}
        lose = {'F': 'W', 'W': 'E', 'E': 'F'}
        dp[tie[s[0]]][n] = 1
        dp[win[s[0]]][n-1] = 1
        dp[lose[s[0]]][n+1] = 1
        # print(dp)
        for i in range(1, n):
            nxt = {c: [0] * (2 * n + 1) for c in 'FWE'}
            j = tie[s[i]]
            for k in range(2 * n + 1):
                nxt[j][k] = sum(dp[jp][k] for jp in 'FWE' if jp != j) % mod
            j = win[s[i]]
            for k in range(2 * n):
                nxt[j][k] = sum(dp[jp][k+1] for jp in 'FWE' if jp != j) % mod
            j = lose[s[i]]
            for k in range(1, 2 * n + 1):
                nxt[j][k] = sum(dp[jp][k-1] for jp in 'FWE' if jp != j) % mod
            dp = nxt
            # print(dp)
        return sum(sum(dp[j][n+1:]) for j in 'FWE') % mod
        ",1420566642
azhan0222,azhan0222,236,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        idx = {}
        cts = SortedList([(0, 0)] * x)
        ctr = Counter(nums[:k])
        for num, ct in ctr.items():
            cts.add((ct, num))
        ret = [sum(ct * num for ct, num in cts[-x:])]
        # print(cts)
        for i in range(k, len(nums)):
            num = nums[i - k]
            ct = ctr[num]
            ctr[num] -= 1
            j = cts.index((ct, num))
            jp = cts.bisect_left((ct - 1, num))
            ans = ret[-1]
            if j >= len(cts) - x:
                if len(cts) - x > jp:
                    ans -= num * ct
                    ctp, nump = cts[-x-1]
                    ans += ctp * nump
                else:
                    ans -= num
            cts.discard((ct, num))
            if ct > 1:
                cts.add((ct - 1, num))
            # print(ans)

            num = nums[i]
            ct = ctr[num]
            ctr[num] += 1
            if not ct:
                cts.add((ct, num))
            j = cts.index((ct, num))
            jp = cts.bisect_left((ct + 1, num))
            # print(cts, jp)
            if jp > len(cts) - x:
                if len(cts) - x > j:
                    ans += num * (ct + 1)
                    ctp, nump = cts[-x]
                    ans -= ctp * nump
                else:
                    ans += num
            cts.discard((ct, num))
            cts.add((ct + 1, num))
            ret.append(ans)
            # print(cts)
        return ret
        ",1420608555
azhan0222,azhan0222,236,3610,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        idx = {}
        cts = SortedList([(0, 0)] * x)
        ctr = Counter(nums[:k])
        for num, ct in ctr.items():
            cts.add((ct, num))
        ret = [sum(ct * num for ct, num in cts[-x:])]
        # print(cts)
        for i in range(k, len(nums)):
            num = nums[i - k]
            ct = ctr[num]
            ctr[num] -= 1
            j = cts.index((ct, num))
            jp = cts.bisect_left((ct - 1, num))
            ans = ret[-1]
            if j >= len(cts) - x:
                if len(cts) - x > jp:
                    ans -= num * ct
                    ctp, nump = cts[-x-1]
                    ans += ctp * nump
                else:
                    ans -= num
            cts.discard((ct, num))
            if ct > 1:
                cts.add((ct - 1, num))
            # print(ans)

            num = nums[i]
            ct = ctr[num]
            ctr[num] += 1
            if not ct:
                cts.add((ct, num))
            j = cts.index((ct, num))
            jp = cts.bisect_left((ct + 1, num))
            # print(cts, jp)
            if jp > len(cts) - x:
                if len(cts) - x > j:
                    ans += num * (ct + 1)
                    ctp, nump = cts[-x]
                    ans -= ctp * nump
                else:
                    ans += num
            cts.discard((ct, num))
            cts.add((ct + 1, num))
            ret.append(ans)
            # print(cts)
        return ret
        ",1420608753
Choon Hean Lew,choon_hean,237,3509,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<string, null_type, less<string>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // pass x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}

class Solution {
    vi arr;
public:
    pair<bool,int> dfs(TreeNode*cur){
        if(cur->left== nullptr&&cur->right== nullptr){
            arr.pb(1);
            return pair(true,1);
        }else if(cur->left==nullptr){
            dfs(cur->right);
            return pair(false,0);
        }else if(cur->right==nullptr){
            dfs(cur->left);
            return pair(false,0);
        }
        auto p1=dfs(cur->left),p2=dfs(cur->right);
        if(p1.first&&p2.first&&p1.second==p2.second){
            arr.pb(p1.second+p2.second+1);
            return pair(true,arr.back());
        }
        return pair(false,0);
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(all(arr),greater<int>());
        if(sz(arr)<k)return -1;
        else return arr[k-1];
    }

};

struct FT {                              // index 0 is not used
    vl ft;                                        // internal FT is an array
    FT(int m) { ft.assign(m + 1, 0); }      // create an empty FT

    inline void build(const vl &f) {
        int m = (int) f.size() - 1;                     // note f[0] is always 0
        ft.assign(m + 1, 0);
        for (int i = 1; i <= m; ++i) {               // O(m)
            ft[i] += f[i];                             // add this value
            if (i + lsb(i) <= m)                       // i has parent
                ft[i + lsb(i)] += ft[i];                 // add to that parent
        }
    }

    inline FT(const vl &f) { build(f); }        // create FT based on f

    inline FT(int m, const vi &s) {              // create FT based on s
        vl f(m + 1, 0);
        for (int i = 0; i < (int) s.size(); ++i)      // do the conversion first
            ++f[s[i]];                                 // in O(n)
        build(f);                                    // in O(m)
    }

    inline ll rsq(int j) {                                // returns RSQ(1, j)
        ll sum = 0;
        for (; j; j -= lsb(j))
            sum += ft[j];
        return sum;
    }

    inline ll rsq(int i, int j) { return rsq(j) - rsq(i - 1); } // inc/exclusion

    // updates value of the i-th element by v (v can be +ve/inc or -ve/dec)
    inline void update(int i, ll v) {
        for (; i < (int) ft.size(); i += lsb(i))
            ft[i] += v;
    }

    int select(ll k) {                             // O(log m)
        int p = 1;
        while (p*2 < (int)ft.size()) p *= 2;
        int i = 0;
        while (p) {
            if (k > ft[i+p]) {
                k -= ft[i+p];
                i += p;
            }
            p /= 2;
        }
        return i+1;
    }
};
//inline void solve() {
//    int q,x;
//    ll N=0;
//    cin>>q;
//    q+=1;
//    FT songs(q),cnt(q);
//    hmap<string,int>map;
//    char com;
//    string s;
//    while(q-->1){
//        cin>>com;
//        if(com=='L'){
//            cin>>s>>x;
//            songs.update(q,x);
//            map[s]=q;
//            N+=x;
//        }else if(com=='P'){
//            cin>>x;
//            int full=x/N;
//            x%=N;
//            if(x){
//                cnt.update(q,full+1);
//                int mid=songs.select(x);
//                int val=songs.rsq(mid);
//                if(val>x)cnt.update(mid,-1);
//                else cnt.update(mid+1,-1);
//            }else cnt.update(q,full);
//        }else{
//            cin>>s;
//            if(map.contains(s))pnl(cnt.rsq(map[s]));
//            else pnl(0);
//        }
//    }
//}
//
//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    //cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1420532640
Choon Hean Lew,choon_hean,237,3588,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<string, null_type, less<string>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // pass x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    int countWinningSequences(string s) {
        map<pii,ll>dp,ndp;
        int n=sz(s);
        dp[{0,4}]=1;
        rep(0,n){
            for(auto&[a,b]:dp){
                if(a.second!=0){
                    if(s[i]=='W')ndp[{a.first-1,0}]+=b;
                    else if(s[i]=='E')ndp[{a.first+1,0}]+=b;
                    else ndp[{a.first,0}]+=b;
                }
                if(a.second!=1){
                    if(s[i]=='E')ndp[{a.first-1,1}]+=b;
                    else if(s[i]=='F')ndp[{a.first+1,1}]+=b;
                    else ndp[{a.first,1}]+=b;
                }
                if(a.second!=2){
                    if(s[i]=='F')ndp[{a.first-1,2}]+=b;
                    else if(s[i]=='W')ndp[{a.first+1,2}]+=b;
                    else ndp[{a.first,2}]+=b;
                }
            }
            for(auto&[a,b]:ndp)ndp[a]=b%mod;
            swap(dp,ndp);
            ndp.clear();
        }
        int res=0;
        for(auto&[a,b]:dp)if(a.first>0){
            res=(res+b)%mod;
        }
        return res;
    }
};
struct FT {                              // index 0 is not used
    vl ft;                                        // internal FT is an array
    FT(int m) { ft.assign(m + 1, 0); }      // create an empty FT

    inline void build(const vl &f) {
        int m = (int) f.size() - 1;                     // note f[0] is always 0
        ft.assign(m + 1, 0);
        for (int i = 1; i <= m; ++i) {               // O(m)
            ft[i] += f[i];                             // add this value
            if (i + lsb(i) <= m)                       // i has parent
                ft[i + lsb(i)] += ft[i];                 // add to that parent
        }
    }

    inline FT(const vl &f) { build(f); }        // create FT based on f

    inline FT(int m, const vi &s) {              // create FT based on s
        vl f(m + 1, 0);
        for (int i = 0; i < (int) s.size(); ++i)      // do the conversion first
            ++f[s[i]];                                 // in O(n)
        build(f);                                    // in O(m)
    }

    inline ll rsq(int j) {                                // returns RSQ(1, j)
        ll sum = 0;
        for (; j; j -= lsb(j))
            sum += ft[j];
        return sum;
    }

    inline ll rsq(int i, int j) { return rsq(j) - rsq(i - 1); } // inc/exclusion

    // updates value of the i-th element by v (v can be +ve/inc or -ve/dec)
    inline void update(int i, ll v) {
        for (; i < (int) ft.size(); i += lsb(i))
            ft[i] += v;
    }

    int select(ll k) {                             // O(log m)
        int p = 1;
        while (p*2 < (int)ft.size()) p *= 2;
        int i = 0;
        while (p) {
            if (k > ft[i+p]) {
                k -= ft[i+p];
                i += p;
            }
            p /= 2;
        }
        return i+1;
    }
};
//inline void solve() {
//    int q,x;
//    ll N=0;
//    cin>>q;
//    q+=1;
//    FT songs(q),cnt(q);
//    hmap<string,int>map;
//    char com;
//    string s;
//    while(q-->1){
//        cin>>com;
//        if(com=='L'){
//            cin>>s>>x;
//            songs.update(q,x);
//            map[s]=q;
//            N+=x;
//        }else if(com=='P'){
//            cin>>x;
//            int full=x/N;
//            x%=N;
//            if(x){
//                cnt.update(q,full+1);
//                int mid=songs.select(x);
//                int val=songs.rsq(mid);
//                if(val>x)cnt.update(mid,-1);
//                else cnt.update(mid+1,-1);
//            }else cnt.update(q,full);
//        }else{
//            cin>>s;
//            if(map.contains(s))pnl(cnt.rsq(map[s]));
//            else pnl(0);
//        }
//    }
//}
//
//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    //cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1420545954
Choon Hean Lew,choon_hean,237,3592,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<pair<int,ll>, null_type, greater<pair<int,ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // pass x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    vector<ll> findXSum(vector<int>& nums, int k, int x) {
        vl res;
        hmap<int,int>cnts;
        ordered_set tree;
        int n=sz(nums);
        rep(0,k){
            cnts[nums[i]]++;
        }
        ll tot=0;
        vpii arr;
        for(auto&[a,b]:cnts){
            pair<int,ll>p={b,a};
            arr.pb(p);
            tree.insert(p);
        }
        if(sz(arr)<=x){
            for(auto&[a,b]:arr)tot+=(ll)a*b;
        }else{
            sort(all(arr),greater<pii>());
            rep(0,x)tot+=(ll)arr[i].first*arr[i].second;
        }
        res.pb(tot);
        rep(0,n-k){
            int cur=nums[i];
            int cnt=cnts[cur]--;
            pair<int,ll>p={cnt,cur};
            int pos=tree.order_of_key(p);
            if(pos<x){
                tot-=(ll)cnt*cur;
            }
            tree.erase(p);
            p={cnt-1,cur};
            if(cnt>1){
                tree.insert(p);
                if (tree.order_of_key(p) < x)tot += (ll) (cnt - 1) * cur;
                else if(pos<x){
                    auto it = tree.find_by_order(x - 1);
                    if(it!=tree.end())tot += it->second * it->first;
                }
            }else if(pos<x){
                auto it = tree.find_by_order(x - 1);
                if(it!=tree.end())tot += it->second * it->first;
            }
            cur=nums[i+k];
            cnt=cnts[cur]++;
            p={cnt,cur};
            if(cnt){
                pos=tree.order_of_key(p);
                if(pos<x){
                    tot+=cur;
                    tree.erase(p);
                    tree.insert({cnt+1,cur});
                }else{
                    tree.erase(p);
                    p={cnt+1,cur};
                    tree.insert(p);
                    if(tree.order_of_key(p)<x) {
                        tot += (ll)(cnt + 1) * cur;
                        auto it = tree.find_by_order(x);
                     if(it!=tree.end())tot-=it->first*it->second;}
//                    }else{
//                        auto it=tree.find_by_order(x-1);
//                        if(it!=tree.end())tot+=it->second*it->first;
//                    }
                }
            }else{
                p={1,cur};
                tree.insert(p);
                if(tree.order_of_key(p)<x){
                    tot+=cur;
                    auto it=tree.find_by_order(x);
                    if(it!=tree.end())tot-=it->first*it->second;
                }
            }
        
            res.pb(tot);
        }
        return res;
    }
};

//inline void solve() {
//    int q,x;
//    ll N=0;
//    cin>>q;
//    q+=1;
//    FT songs(q),cnt(q);
//    hmap<string,int>map;
//    char com;
//    string s;
//    while(q-->1){
//        cin>>com;
//        if(com=='L'){
//            cin>>s>>x;
//            songs.update(q,x);
//            map[s]=q;
//            N+=x;
//        }else if(com=='P'){
//            cin>>x;
//            int full=x/N;
//            x%=N;
//            if(x){
//                cnt.update(q,full+1);
//                int mid=songs.select(x);
//                int val=songs.rsq(mid);
//                if(val>x)cnt.update(mid,-1);
//                else cnt.update(mid+1,-1);
//            }else cnt.update(q,full);
//        }else{
//            cin>>s;
//            if(map.contains(s))pnl(cnt.rsq(map[s]));
//            else pnl(0);
//        }
//    }
//}
//
//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    //cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1420614842
Choon Hean Lew,choon_hean,237,3610,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<string, null_type, less<string>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // pass x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vi res;
        rep(0,sz(nums)-k+1){
            hmap<int,int>cnts;
            for(int j=i;j<i+k;j++){
                cnts[nums[j]]++;
            }
            vpii arr;
            for(auto&[a,b]:cnts)arr.pb({b,a});
            sort(all(arr),greater<pii>());
            if(sz(arr)<=x) { 
                int cur=0;
                for(auto&[a,b]:arr)cur+=a*b;
                res.pb(cur);
            }else{
                int cur=0;
                for(int j=0;j<x;j++)cur+=arr[j].first*arr[j].second;
                res.pb(cur);
            }
        }
        return res;
    }
};
struct FT {                              // index 0 is not used
    vl ft;                                        // internal FT is an array
    FT(int m) { ft.assign(m + 1, 0); }      // create an empty FT

    inline void build(const vl &f) {
        int m = (int) f.size() - 1;                     // note f[0] is always 0
        ft.assign(m + 1, 0);
        for (int i = 1; i <= m; ++i) {               // O(m)
            ft[i] += f[i];                             // add this value
            if (i + lsb(i) <= m)                       // i has parent
                ft[i + lsb(i)] += ft[i];                 // add to that parent
        }
    }

    inline FT(const vl &f) { build(f); }        // create FT based on f

    inline FT(int m, const vi &s) {              // create FT based on s
        vl f(m + 1, 0);
        for (int i = 0; i < (int) s.size(); ++i)      // do the conversion first
            ++f[s[i]];                                 // in O(n)
        build(f);                                    // in O(m)
    }

    inline ll rsq(int j) {                                // returns RSQ(1, j)
        ll sum = 0;
        for (; j; j -= lsb(j))
            sum += ft[j];
        return sum;
    }

    inline ll rsq(int i, int j) { return rsq(j) - rsq(i - 1); } // inc/exclusion

    // updates value of the i-th element by v (v can be +ve/inc or -ve/dec)
    inline void update(int i, ll v) {
        for (; i < (int) ft.size(); i += lsb(i))
            ft[i] += v;
    }

    int select(ll k) {                             // O(log m)
        int p = 1;
        while (p*2 < (int)ft.size()) p *= 2;
        int i = 0;
        while (p) {
            if (k > ft[i+p]) {
                k -= ft[i+p];
                i += p;
            }
            p /= 2;
        }
        return i+1;
    }
};
//inline void solve() {
//    int q,x;
//    ll N=0;
//    cin>>q;
//    q+=1;
//    FT songs(q),cnt(q);
//    hmap<string,int>map;
//    char com;
//    string s;
//    while(q-->1){
//        cin>>com;
//        if(com=='L'){
//            cin>>s>>x;
//            songs.update(q,x);
//            map[s]=q;
//            N+=x;
//        }else if(com=='P'){
//            cin>>x;
//            int full=x/N;
//            x%=N;
//            if(x){
//                cnt.update(q,full+1);
//                int mid=songs.select(x);
//                int val=songs.rsq(mid);
//                if(val>x)cnt.update(mid,-1);
//                else cnt.update(mid+1,-1);
//            }else cnt.update(q,full);
//        }else{
//            cin>>s;
//            if(map.contains(s))pnl(cnt.rsq(map[s]));
//            else pnl(0);
//        }
//    }
//}
//
//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    //cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1420522396
TLE_automaton,So_What,238,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(node, res):
            if not node:
                return [0, 0]
            ret = [1, 1]
            l, r = dfs(node.left, res), dfs(node.right, res)
            if l[0] == r[0]:
                ret[0] = l[0] + 1
                ret[1] = l[1] + r[1] + 1
            else:
                ret[0] = max(l[0], r[0]) + 1
                ret[1] = float('-inf')
            if ret[1] != float('-inf'):
                res.append(ret[1])
            return ret
        res = []
        dfs(root, res)
        list.sort(res, reverse=True)
        if len(res) >= k:
            return res[k-1]
        return -1",1420530442
TLE_automaton,So_What,238,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        move_map = {'F': 0, 'W': 1, 'E': 2}
        alice_moves = [move_map[c] for c in s]
        outcome_matrix = [
            [0, -1, 1],  
            [1, 0, -1],  
            [-1, 1, 0],  
        ]
        dp_prev = [ [0]*(2*n +1) for _ in range(3) ]

        for bob_move in range(3):
            outcome = outcome_matrix[bob_move][alice_moves[0]]
            diff = outcome
            mapped_diff = diff + n  
            dp_prev[bob_move][mapped_diff] = 1  

        for i in range(1, n):
            dp_curr = [ [0]*(2*n +1) for _ in range(3) ]
            alice_move = alice_moves[i]

            for last_move in range(3):
                for diff_prev in range(-i, i+1):
                    mapped_diff_prev = diff_prev + n
                    count = dp_prev[last_move][mapped_diff_prev]
                    if count == 0:
                        continue  

                    for bob_move in range(3):
                        if bob_move == last_move:
                            continue  

                        outcome = outcome_matrix[bob_move][alice_move]
                        diff_new = diff_prev + outcome
                        if diff_new < -n or diff_new > n:
                            continue

                        mapped_diff_new = diff_new + n
                        dp_curr[bob_move][mapped_diff_new] = (dp_curr[bob_move][mapped_diff_new] + count) % MOD

            dp_prev = dp_curr
        result = 0
        for last_move in range(3):
            for diff in range(1, n+1):
                mapped_diff = diff + n
                result = (result + dp_prev[last_move][mapped_diff]) % MOD

        return result",1420554297
TLE_automaton,So_What,238,3592,python3,"
import random

class TreapNode:
    __slots__ = ['key', 'priority', 'left', 'right', 'size', 'sum']

    def __init__(self, key, value):
        self.key = key  
        self.priority = random.randint(1, 1 << 30)
        self.left: Optional['TreapNode'] = None
        self.right: Optional['TreapNode'] = None
        self.size = 1
        self.sum = value  

def update(node: Optional[TreapNode]):
    if node:
        node.size = 1
        node.sum = -node.key[0] * (-node.key[1])
        if node.left:
            node.size += node.left.size
            node.sum += node.left.sum
        if node.right:
            node.size += node.right.size
            node.sum += node.right.sum

def split(node: Optional[TreapNode], key):
    if not node:
        return (None, None)
    if node.key < key:
        left, right = split(node.right, key)
        node.right = left
        update(node)
        return (node, right)
    else:
        left, right = split(node.left, key)
        node.left = right
        update(node)
        return (left, node)

def merge(left: Optional[TreapNode], right: Optional[TreapNode]):
    if not left or not right:
        return left or right
    if left.priority > right.priority:
        left.right = merge(left.right, right)
        update(left)
        return left
    else:
        right.left = merge(left, right.left)
        update(right)
        return right

def insert(node: Optional[TreapNode], item: TreapNode):
    if not node:
        return item
    if item.priority > node.priority:
        left, right = split(node, item.key)
        item.left = left
        item.right = right
        update(item)
        return item
    elif item.key < node.key:
        node.left = insert(node.left, item)
        update(node)
    else:
        node.right = insert(node.right, item)
        update(node)
    return node

def erase(node: Optional[TreapNode], key):
    if not node:
        return None
    if node.key == key:
        return merge(node.left, node.right)
    elif key < node.key:
        node.left = erase(node.left, key)
        update(node)
    else:
        node.right = erase(node.right, key)
        update(node)
    return node

def get_sum_top_x(node: Optional[TreapNode], x: int) -> int:
    if not node or x <= 0:
        return 0
    if node.left:
        if node.left.size >= x:
            return get_sum_top_x(node.left, x)
        else:
            total = node.left.sum
            remaining = x - node.left.size
    else:
        total = 0
        remaining = x
    if remaining > 0:
        total += -node.key[0] * (-node.key[1])
        remaining -= 1
    if remaining > 0:
        total += get_sum_top_x(node.right, remaining)
    return total

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from collections import defaultdict

        freq = defaultdict(int)
        root = None
        for i in range(k):
            freq[nums[i]] += 1

        for e, f in freq.items():
            node = TreapNode((-f, -e), f * e)
            root = insert(root, node)

        answer = []
        sum_top_x = get_sum_top_x(root, x)
        answer.append(sum_top_x)

        for i in range(1, len(nums) - k + 1):
            e_out = nums[i - 1]
            e_in = nums[i + k - 1]

            old_freq = freq[e_out]
            root = erase(root, (-old_freq, -e_out))
            freq[e_out] -= 1
            if freq[e_out] > 0:
                new_freq = freq[e_out]
                root = insert(root, TreapNode((-new_freq, -e_out), new_freq * e_out))
            else:
                del freq[e_out]

            if e_in in freq:
                old_freq = freq[e_in]
                root = erase(root, (-old_freq, -e_in))
                freq[e_in] += 1
                new_freq = freq[e_in]
                root = insert(root, TreapNode((-new_freq, -e_in), new_freq * e_in))
            else:
                freq[e_in] = 1
                root = insert(root, TreapNode((-1, -e_in), e_in))

            sum_top_x = get_sum_top_x(root, x)
            answer.append(sum_top_x)

        return answer",1420615903
TLE_automaton,So_What,238,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def x_sum(cnt):
            res = []
            for n, v in cnt.items():
                heapq.heappush(res, [v, n])
                if len(res) > x:
                    heapq.heappop(res)
            return sum(a*b for a, b in res)
        ret = []
        freq = collections.Counter()
        for i, a in enumerate(nums):
            freq[a] += 1
            if i >= k:
                freq[nums[i-k]] -= 1
                if freq[nums[i-k]] == 0:
                    del freq[nums[i-k]]
            if i >= k-1:
                ret.append(x_sum(freq))
        return ret",1420521643
Di Kang,zephyrr,239,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []

        def dfs(root):
            if not root:
                return 0,0
            lct, llvl = dfs(root.left)
            rct, rlvl = dfs(root.right)
            ct = lct + rct + 1
            lvl = max(llvl,rlvl) + 1
            if ct == 2 ** lvl - 1:
                ans.append(ct)
            return ct, lvl
        
        dfs(root)
        ans.sort(reverse = True)
        #print(ans)
        if len(ans) < k:
            return -1
        return ans[k-1]
        ",1420525211
Di Kang,zephyrr,239,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        mod = 10 ** 9 + 7
        n = len(s)
        dp = [[[0 for _ in range(3)] for _ in range(2*n+1)] for _ in range(n)]
        #print(len(dp),len(dp[0]),len(dp[0][0]))
        
        for ind in range(n):
            #for pt in range(ind, 2*n+1):  
            for pt in range(2*n+1):              
                if ind == 0:
                    if s[ind] == 'F':
                        dp[ind][n+0][2] = 1
                        dp[ind][n+1][0] = 1
                        dp[ind][n-1][1] = 1
                    elif s[ind] == 'E':
                        dp[ind][n+0][1] = 1
                        dp[ind][n+1][2] = 1
                        dp[ind][n-1][0] = 1
                    elif s[ind] == 'W':
                        dp[ind][n+0][0] = 1
                        dp[ind][n+1][1] = 1
                        dp[ind][n-1][2] = 1
                else:
                    if s[ind] == 'F':
                        if pt != 0:
                            dp[ind][pt][0] = (dp[ind-1][pt-1][1] + dp[ind-1][pt-1][2])
                        if pt < 2*n:                  
                            dp[ind][pt][1] = (dp[ind-1][pt+1][0] + dp[ind-1][pt+1][2])
                        dp[ind][pt][2] = dp[ind-1][pt][0] + dp[ind-1][pt][1]
                    elif s[ind] == 'E':
                        if pt != 0:                        
                            dp[ind][pt][2] = (dp[ind-1][pt-1][1] + dp[ind-1][pt-1][0])
                        if pt < 2*n:
                            dp[ind][pt][0] = (dp[ind-1][pt+1][1] + dp[ind-1][pt+1][2])
                        dp[ind][pt][1] = dp[ind-1][pt][0] + dp[ind-1][pt][2]
                    elif s[ind] == 'W':
                        if pt != 0:
                            dp[ind][pt][1] = (dp[ind-1][pt-1][2] + dp[ind-1][pt-1][0])
                        if pt < 2*n:
                            dp[ind][pt][2] = (dp[ind-1][pt+1][1] + dp[ind-1][pt+1][0])
                        dp[ind][pt][0] = dp[ind-1][pt][1] + dp[ind-1][pt][2]
                    #print(ind,pt)
        res = 0
        for pt in range(n+1,2*n+1):
            res += dp[n-1][pt][0] + dp[n-1][pt][1] + dp[n-1][pt][2]
            res %= mod
        return res % mod

'''
        @cache
        def dp(ind, pre, pt):
            if len(s) - ind + pt <= 0:
                return 0
            if ind == 0:
                if s[0] == 'F':
                    return (dp(1,'F',0) + dp(1,'W',1) + dp(1,'E',-1))%mod
                elif s[0] == 'W':
                    return (dp(1,'W',0) + dp(1,'E',1) + dp(1,'F',-1))%mod
                else:
                    return (dp(1,'E',0) + dp(1,'F',1) + dp(1,'W',-1))%mod
            if ind == len(s):
                return 1 if pt > 0 else 0
            if pre == 'F':
                if s[ind] == 'F':
                    return  (dp(ind+1,'W',pt+1) + dp(ind+1,'E',pt-1))%mod
                elif s[ind] == 'W':
                    return (dp(ind+1,'W',pt) + dp(ind+1,'E',pt+1) )%mod
                else:
                    return (dp(ind+1,'E',pt) +  dp(ind+1,'W',pt-1))%mod
            elif pre == 'W':
                if s[ind] == 'F':
                    return (dp(ind+1,'F',pt) + dp(ind+1,'E',pt-1))%mod
                elif s[ind] == 'W':
                    return (dp(ind+1,'E',pt+1) + dp(ind+1,'F',pt-1))%mod
                else:
                    return (dp(ind+1,'E',pt) + dp(ind+1,'F',pt+1))%mod
            elif pre == 'E':
                if s[ind] == 'F':
                    return (dp(ind+1,'F',pt) + dp(ind+1,'W',pt+1))%mod
                elif s[ind] == 'W':
                    return (dp(ind+1,'W',pt) + dp(ind+1,'F',pt-1))%mod
                else:
                    return (dp(ind+1,'F',pt+1) + dp(ind+1,'W',pt-1))%mod

        #print(dp(1,'F',0), dp(1,'W',1), dp(1,'E',-1))
        return dp(0,'',0)%mod
'''",1420578588
Di Kang,zephyrr,239,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        d = defaultdict(int)
        for i in range(k):
            d[nums[i]]+=1
        arr = []
        for n in d:
            arr.append([d[n],n])
        arr.sort()
        res = []
        cur = 0
        for i in range(min(len(arr),x)):
            cur += arr[len(arr)-1-i][0] * arr[len(arr)-1-i][1]
        res.append(cur)
        
        #print(arr)
        for i in range(k,len(nums)):
            if d[nums[i]] > 0:
                valin = [d[nums[i]],nums[i]]
                indin = bisect.bisect_left(arr,valin)
                arr.pop(indin)
                if indin + x >= len(arr) + 1:
                    cur -= valin[0] * valin[1]
                    tmp = len(arr) - x
                    if tmp >= 0:
                        cur += arr[tmp][0]*arr[tmp][1]
            #print(i, arr, cur)  
            d[nums[i]] += 1
            valin = [d[nums[i]],nums[i]]
            indin = bisect.bisect_left(arr,valin)
            arr.insert(indin, valin)
            if indin + x >= len(arr):
                cur += valin[0] * valin[1]
                tmp = len(arr) - x - 1
                if tmp >= 0:
                    cur -= arr[tmp][0]*arr[tmp][1]
            #print(i, arr, cur)        

            valout = [d[nums[i-k]], nums[i-k]]
            indout = bisect.bisect_left(arr,valout)
            arr.pop(indout)
            if indout + x >= len(arr) + 1:
                cur -= valout[0] * valout[1]
                tmp = len(arr) - x
                if tmp >= 0:
                    cur += arr[tmp][0]*arr[tmp][1]
            #print(i, arr, cur)  
            d[nums[i-k]] -= 1
            if d[nums[i-k]]>0:
                valout = [d[nums[i-k]],nums[i-k]]
                indout = bisect.bisect_left(arr,valout)
                arr.insert(indout, valout)
                if indout + x >= len(arr):
                    cur += valout[0] * valout[1]
                    tmp = len(arr) - x - 1
                    if tmp >= 0:
                        cur -= arr[tmp][0]*arr[tmp][1]
            #print(i,arr)
            res.append(cur)
        
        return res

        ",1420610374
Di Kang,zephyrr,239,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:

        def solve(arr):
            d = defaultdict(int)
            for n in arr:
                d[n] += 1
            aa = []
            for n in d:
                aa.append([d[n], n])
            aa.sort(reverse = True)
            #print(aa)
            ans = 0
            for i in range(min(len(aa),x)):
                ans += aa[i][0] * aa[i][1]
            return ans
        
        ans = []
        for i in range(len(nums)-k+1):
            ans.append(solve(nums[i:i+k]))
        return ans

        ",1420520753
Shashwat Tripathi,Fkaiser7,240,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> dfs(TreeNode* node,int c,vector<int>&v){
        if(!node->left&&!node->right){
            v.push_back(1);
            return {1,1,c};
        }
        vector<int>it1,it2;
        if(node->left){
            it1=dfs(node->left,c+1,v);
        }
        if(node->right){
            it2=dfs(node->right,c+1,v);
        }
        if(!node->left||!node->right){
            return {0,0,0};
        }
        if(it1[0]==0||it2[0]==0){
            return {0,0,0};
        }
        if(it1[2]!=it2[2]){
            return {0,0,0};
        }
        //cout<<node->val<<"" ""<<it1[1]<<"" ""<<it2[1]<<"" ""<<it1[2]<<endl;
        v.push_back(1+it1[1]+it2[1]);
        return {1,1+it1[1]+it2[1],it1[2]};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int>v;
        dfs(root,0,v);
        //cout<<v.size()<<endl;
        if(v.size()<k){
            return -1;
        }
        sort(v.begin(),v.end());
        return v[v.size()-k];
    }
};",1420543331
Shashwat Tripathi,Fkaiser7,240,3588,cpp,"#define lli long long
lli mod=1e9+7;
class Solution {
public:
    lli fuc(lli i,lli j,lli k,string &s,vector<vector<vector<lli>>>&dp){
        lli n=s.length();
        if(i==n){
            if(j>=n){
                return 0;
            }
            return 1;
        }
        if(dp[i][j][k]!=-1){
            return dp[i][j][k];
        }
        lli ans=0;
        if(i==0){
            if(s[i]=='F'){
                ans+=fuc(i+1,j,0,s,dp)%mod;
                ans%=mod;
                ans+=fuc(i+1,j-1,1,s,dp)%mod;
                ans%=mod;
                ans+=fuc(i+1,j+1,2,s,dp)%mod;
                ans%=mod;
            }
            else if(s[i]=='W'){
                ans+=fuc(i+1,j+1,0,s,dp)%mod;
                ans%=mod;
                ans+=fuc(i+1,j,1,s,dp)%mod;
                ans%=mod;
                ans+=fuc(i+1,j-1,2,s,dp)%mod;
                ans%=mod;
            }
            else{
                ans+=fuc(i+1,j-1,0,s,dp)%mod;
                ans%=mod;
                ans+=fuc(i+1,j+1,1,s,dp)%mod;
                ans%=mod;
                ans+=fuc(i+1,j,2,s,dp)%mod;
                ans%=mod;
            }
        }
        else{
            if(s[i]=='F'){
                if(k!=0){
                ans+=fuc(i+1,j,0,s,dp)%mod;
                ans%=mod;
                }
                if(k!=1){
                ans+=fuc(i+1,j-1,1,s,dp)%mod;
                ans%=mod;
                }
                if(k!=2){
                ans+=fuc(i+1,j+1,2,s,dp)%mod;
                ans%=mod;
                }
            }
            else if(s[i]=='W'){
                if(k!=0){
                ans+=fuc(i+1,j+1,0,s,dp)%mod;
                ans%=mod;
                }
                if(k!=1){
                ans+=fuc(i+1,j,1,s,dp)%mod;
                ans%=mod;
                }
                if(k!=2){
                ans+=fuc(i+1,j-1,2,s,dp)%mod;
                ans%=mod;
                }
            }
            else{
                if(k!=0){
                ans+=fuc(i+1,j-1,0,s,dp)%mod;
                ans%=mod;
                }
                if(k!=1){
                ans+=fuc(i+1,j+1,1,s,dp)%mod;
                ans%=mod;
                }
                if(k!=2){
                ans+=fuc(i+1,j,2,s,dp)%mod;
                ans%=mod;
                }
            }
        }
        return dp[i][j][k]=ans;
    }
    int countWinningSequences(string s) {
        lli n=s.length();
        vector<vector<vector<lli>>>dp(n,vector<vector<lli>>(2*n+1,
        vector<lli>(3,-1)));
        lli t=fuc(0,n,0,s,dp);
        t=t%mod;
        return (int)(t);
    }
};",1420559820
Shashwat Tripathi,Fkaiser7,240,3592,cpp,"#define lli long long
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pair<lli,lli>>st,st1;
        map<lli,lli>m;
        lli n=nums.size();
        for(lli i=0;i<k;i++){
            m[nums[i]]++;
        }
        lli s=0;
        for(auto it:m){
            s+=it.first*it.second;
            st.insert({it.second,it.first});
        }
        while(st.size()>x){
            auto it=st.begin();
            s-=(*it).first*(*it).second;
            st1.insert({(*it).first,(*it).second});
            //cout<<(*it).first<<"" ""<<(*it).second<<endl;
            st.erase(st.begin());
        }
        vector<lli>ans;
        ans.push_back(s);
        for(lli i=0;i<n-k;i++){
            if(nums[i]!=nums[i+k]){
            lli t1=m[nums[i]];
            lli t2=m[nums[i+k]];
            auto it=st.find({t1,nums[i]});
            if(it!=st.end()){
                s-=(*it).first*(*it).second;
                st.erase(it);
            }
            else{
                it=st1.find({t1,nums[i]});
                if(it!=st1.end()){
                    st1.erase(it);
                }
            }
            m[nums[i]]--;
            it=st.find({t2,nums[i+k]});
            if(it!=st.end()){
                s-=(*it).first*(*it).second;
                st.erase(it);
            }
            else{
                it=st1.find({t2,nums[i+k]});
                if(it!=st1.end()){
                    st1.erase(it);
                }
            }
            m[nums[i+k]]++;
            t1--;t2++;
            //cout<<t1<<"" ""<<t2<<endl;
            st1.insert({t1,nums[i]});
            st1.insert({t2,nums[i+k]});
            }
            else{
                lli t=m[nums[i]];
                auto it=st.find({t,nums[i]});
                if(it!=st.end()){
                    st1.insert({(*it).first,(*it).second});
                    s-=t*nums[i];
                    st.erase(it);
                }
            }
            //cout<<st.size()<<"" ""<<st1.size()<<endl;
            //cout<<s<<endl;
            while(st1.size()){
                //cout<<s<<endl;
                if(st.size()<x){
                    auto it=--st1.end();
                    s+=(*it).first*(*it).second;
                    st.insert({(*it).first,(*it).second});
                    st1.erase(it);
                }
                else{
                    auto it1=--st1.end();
                    auto it2=st.begin();
                    if((*it1).first>(*it2).first||((*it1).first==(*it2).first&&
                    (*it1).second>(*it2).second)){
                        //cout<<(*it1).first<<"" ""<<(*it1).second<<endl;
                        s+=(*it1).first*(*it1).second;
                        s-=(*it2).first*(*it2).second;
                        //cout<<s<<endl;
                        st1.insert({(*it2).first,(*it2).second});
                        st.insert({(*it1).first,(*it1).second});
                        st1.erase(it1);
                        st.erase(it2);
                    }
                    else{
                        break;
                    }
                }
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1420616546
Shashwat Tripathi,Fkaiser7,240,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int>ans;
        int n=nums.size();
        for(int i=0;i<=n-k;i++){
            map<int,int>m;
            for(int j=i;j<i+k;j++){
                m[nums[j]]++;
            }
            map<int,set<int>>m1;
            for(auto it:m){
                m1[it.second].insert(it.first);
            }
            set<int>st;
            auto it=--m1.end();
            while(true){
                auto it1=--(*it).second.end();
                while(true){
                    if(st.size()==x){
                        break;
                    }
                    st.insert(*it1);
                    if(it1==(*it).second.begin()){
                        break;
                    }
                    it1--;
                }
                if(it==m1.begin()){
                    break;
                }
                it--;
            }
            int s=0;
            for(int j=i;j<i+k;j++){
                if(st.find(nums[j])!=st.end()){
                    s+=nums[j];
                }
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1420523690
Ritik Rathor,ritik_369,241,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

bool dfs(TreeNode *node,vector<int>&vec,int &sz)
{
    if(node==nullptr)return 0;
    bool ok=1;
    sz=1;
    if(node -> left==nullptr and node -> right==nullptr)
    {
        vec.push_back(sz);
        return 1;
    }
    int l=0,r=0;
    if(node -> left != nullptr)ok &= dfs(node -> left , vec,l) ; 
    else ok = 0 ; 
    if(node -> right != nullptr)ok &= dfs(node -> right , vec,r) ; 
    else ok = 0 ;
    ok&=(l==r); 
    sz+=l+r;
    if(ok)
    {
        vec.push_back(sz) ; 
    }
    return ok ; 
}
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int>vec ; 
        int sz=0;
        dfs(root , vec,sz) ; 
        if(vec.size() < k)return -1 ; 
        sort(vec.rbegin() , vec.rend()) ; 
        return vec[k-1] ; 
    }
};",1420610934
Ritik Rathor,ritik_369,241,3588,cpp,"const int mod = 1000000007 ; 
int f(int idx , int cur , int ls , vector < int > & vec , vector<vector<vector<int>>> & dp)
{
   if(idx >= vec.size())return cur > 0 ; 
   int  & res = dp[idx][cur + (int)vec.size()][ls + 1] ; 
   if(res != -1)return res ; 
   res = 0 ; 
   for(int i = 0 ; i <= 2 ; i += 1)
      if(ls != i)
      {
         int ncur = cur ; 
         swap(i , vec[idx]) ; 
         if(vec[idx] == 0)
         {
            if(i == 2)ncur ++  ; 
            else if(i == 1)ncur --  ; 
         }
         if(vec[idx] == 1)
         {
            if(i == 0)ncur ++  ; 
            else if(i == 2)ncur --  ; 
         }
         if(vec[idx] == 2)
         {
            if(i == 1)ncur ++  ; 
            else if(i == 0)ncur --  ; 
         }
         swap(i , vec[idx]) ; 
         res = (1ll * res + 1ll * f(idx + 1 , ncur,i,vec,dp)) % mod ; 
      }
   return res ; 
}



class Solution 
{
public:
    int countWinningSequences(string s) 
    {
      vector < int > vec ; 
      int n = s.size() ; 
      for(auto  & a : s)
      {
         if(a == 'F')vec.push_back(0) ; 
         if(a == 'W')vec.push_back(1) ; 
         if(a == 'E')vec.push_back(2) ; 
      }
      vector<vector<vector<int>>>dp = vector<vector<vector<int>>>(n + 1 , vector<vector<int>>(2 * n + 10 , vector < int > (4 , -1))) ; 
      return f(0 , 0 , -1 , vec , dp);
    }
};
",1420616714
Ritik Rathor,ritik_369,241,3592,cpp,"
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template<typename T>using ordered_set=
tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;
#define int long long
int ok = 0 ; 
struct dataset 
{
    ordered_set<pair<int, int>> os;
    map<int, int> freq;
    long long sum = 0;
    int x;

    dataset(int x)
    {
      this -> x = x ; 
    }

    void inc(int num) 
    {
        if (freq[num] > 0) 
        {
            bool h = 0 ; 
            if(os.size() - os.order_of_key({freq[num], num}) <= x)
            {
               h = 1 ; 
               sum -= freq[num] * num ; 
            }
            os.erase({freq[num], num});
            if(os.size() >= x and h)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum += a * b ; 
            }
        }

        freq[num]++;
        if(os.size() < x)
        {
           os.insert({freq[num], num});
           sum += freq[num] * num ; 
        }
        else if (os.size() >= x) 
        {
            if(os.size() + 1 - os.order_of_key({freq[num], num}) <= x)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum -= a * b ; 
               sum += freq[num] * num ; 
            }
            os.insert({freq[num], num});
        }
    }

    void dec(int num) 
    {
        if (freq[num] > 0) 
        {
            int h = 0 ; 
            if(os.size() - os.order_of_key({freq[num], num}) <= x)
            {
               h = 1 ; 
               sum -= freq[num] * num ; 
            }
            os.erase({freq[num], num});
            if(os.size() >= x and h)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum += a * b ; 
            }
        }
        freq[num]--;
        if(freq[num] <= 0)return  ; 
        if(os.size() < x)
        {
           os.insert({freq[num], num});
           sum += freq[num] * num ; 
        }
        else if (os.size() >= x) 
        {
            if(os.size() + 1 - os.order_of_key({freq[num], num}) <= x)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum -= a * b ; 
               sum += freq[num] * num ; 
            }
            os.insert({freq[num], num});
        }
    }

    long long cursum() 
    {
        return sum;
    }
};
#undef int

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) 
    {
        map<int, int> freq;
        ordered_set<pair<int, int>> os;
        long long sum = 0;
        vector<long long> result;
        int n = nums.size() ; 
        dataset ds(x) ; 
        for (int i = 0; i < nums.size(); i += 1) 
        {
            if(i >= n-1)ok = 1 ; 
            int num = nums[i];
            ds.inc(num) ; 
            if(i >= k-1)
               result.push_back(ds.cursum());
            if(i - k + 1 >= 0)
               ds.dec(nums[i - k + 1]) ; 
        }

        return result;
    }
};",1420611365
Ritik Rathor,ritik_369,241,3610,cpp,"
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template<typename T>using ordered_set=
tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;
#define int long long
int ok = 0 ; 
struct dataset 
{
    ordered_set<pair<int, int>> os;
    map<int, int> freq;
    long long sum = 0;
    int x;

    dataset(int x)
    {
      this -> x = x ; 
    }

    void inc(int num) 
    {
        if (freq[num] > 0) 
        {
            bool h = 0 ; 
            if(os.size() - os.order_of_key({freq[num], num}) <= x)
            {
               h = 1 ; 
               sum -= freq[num] * num ; 
            }
            os.erase({freq[num], num});
            if(os.size() >= x and h)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum += a * b ; 
            }
        }

        freq[num]++;
        if(os.size() < x)
        {
           os.insert({freq[num], num});
           sum += freq[num] * num ; 
        }
        else if (os.size() >= x) 
        {
            if(os.size() + 1 - os.order_of_key({freq[num], num}) <= x)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum -= a * b ; 
               sum += freq[num] * num ; 
            }
            os.insert({freq[num], num});
        }
    }

    void dec(int num) 
    {
        if (freq[num] > 0) 
        {
            int h = 0 ; 
            if(os.size() - os.order_of_key({freq[num], num}) <= x)
            {
               h = 1 ; 
               sum -= freq[num] * num ; 
            }
            os.erase({freq[num], num});
            if(os.size() >= x and h)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum += a * b ; 
            }
        }
        freq[num]--;
        if(freq[num] <= 0)return  ; 
        if(os.size() < x)
        {
           os.insert({freq[num], num});
           sum += freq[num] * num ; 
        }
        else if (os.size() >= x) 
        {
            if(os.size() + 1 - os.order_of_key({freq[num], num}) <= x)
            {
               auto [a , b] =  * os.find_by_order(os.size() - x) ; 
               sum -= a * b ; 
               sum += freq[num] * num ; 
            }
            os.insert({freq[num], num});
        }
    }

    long long cursum() 
    {
        return sum;
    }
};
#undef int

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) 
    {
        map<int, int> freq;
        ordered_set<pair<int, int>> os;
        long long sum = 0;
        vector<int> result;
        int n = nums.size() ; 
        dataset ds(x) ; 
        for (int i = 0; i < nums.size(); i += 1) 
        {
            if(i >= n-1)ok = 1 ; 
            int num = nums[i];
            ds.inc(num) ; 
            if(i >= k-1)
               result.push_back(ds.cursum());
            if(i - k + 1 >= 0)
               ds.dec(nums[i - k + 1]) ; 
        }

        return result;
    }
};",1420610773
sveng101,sveng101,242,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        counts = {}
        def recur(node: Optional[TreeNode]) -> Tuple[bool, int]:
            if node is None:
                return (True, 0)
            p1, sz1 = recur(node.left)
            p2, sz2 = recur(node.right)
            if p1 and p2 and sz1 == sz2:
                sz = sz1 + 1
                counts[sz] = counts.get(sz, 0) + 1
                return (True, sz)
            return (False, 0)
        
        recur(root)
        #print(counts)
        sz_lst = sorted(counts.keys())
        tot = 0
        for sz in reversed(sz_lst):
            tot += counts[sz]
            if tot >= k:
                return (1 << sz) - 1
        return -1",1420583067
sveng101,sveng101,242,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        md = 10 ** 9 + 7
        if not s: return 0

        n = len(s)

        curr = {""F"": {}, ""W"": {}, ""E"": {}}
        if s[0] == ""F"":
            curr[""F""][0] = 1
            curr[""W""][1] = 1
            curr[""E""][-1] = 1
        elif s[0] == ""W"":
            curr[""F""][-1] = 1
            curr[""W""][0] = 1
            curr[""E""][1] = 1
        elif s[0] == ""E"":
            curr[""F""][1] = 1
            curr[""W""][-1] = 1
            curr[""E""][0] = 1
        #print(curr)
        for i in range(1, n):
            l = s[i]
            prev = curr
            curr = {""F"": {}, ""W"": {}, ""E"": {}}
            if l == ""F"":
                for num, f in prev[""F""].items():
                    curr[""W""][num + 1] = (curr[""W""].get(num + 1, 0) + f) % md
                    curr[""E""][num - 1] = (curr[""E""].get(num - 1, 0) + f) % md
                for num, f in prev[""W""].items():
                    curr[""F""][num] = (curr[""F""].get(num, 0) + f) % md
                    curr[""E""][num - 1] = (curr[""E""].get(num - 1, 0) + f) % md
                for num, f in prev[""E""].items():
                    curr[""F""][num] = (curr[""F""].get(num, 0) + f) % md
                    curr[""W""][num + 1] = (curr[""W""].get(num + 1, 0) + f) % md
            elif l == ""W"":
                for num, f in prev[""F""].items():
                    curr[""W""][num] = (curr[""W""].get(num, 0) + f) % md
                    curr[""E""][num + 1] = (curr[""E""].get(num + 1, 0) + f) % md
                for num, f in prev[""W""].items():
                    curr[""F""][num - 1] = (curr[""F""].get(num - 1, 0) + f) % md
                    curr[""E""][num + 1] = (curr[""E""].get(num + 1, 0) + f) % md
                for num, f in prev[""E""].items():
                    curr[""F""][num - 1] = (curr[""F""].get(num - 1, 0) + f) % md
                    curr[""W""][num] = (curr[""W""].get(num, 0) + f) % md
            elif l == ""E"":
                for num, f in prev[""F""].items():
                    curr[""W""][num - 1] = (curr[""W""].get(num - 1, 0) + f) % md
                    curr[""E""][num] = (curr[""E""].get(num, 0) + f) % md
                for num, f in prev[""W""].items():
                    curr[""F""][num + 1] = (curr[""F""].get(num + 1, 0) + f) % md
                    curr[""E""][num] = (curr[""E""].get(num, 0) + f) % md
                for num, f in prev[""E""].items():
                    curr[""F""][num + 1] = (curr[""F""].get(num + 1, 0) + f) % md
                    curr[""W""][num - 1] = (curr[""W""].get(num - 1, 0) + f) % md
            #print(curr)
        res = 0
        return sum(sum(f for num, f in f_dict.items() if num > 0) % md for f_dict in curr.values()) % md",1420611408
sveng101,sveng101,242,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        if n < k: return []
        f_dict = {}
        tot = 0
        for i in range(min(k, n)):
            num = nums[i]
            f_dict[num] = f_dict.get(num, 0) + 1
            tot += num
        lst1 = SortedList([(f, num) for num, f in f_dict.items()])
        lst2 = SortedList()
        #print(lst)
        #print(tot)
        while len(lst1) > x:
            f, num = lst1.pop(0)
            #print(f, num)
            tot -= f * num
            lst2.add((f, num))
            #print(len(lst), x)
        res = [tot]
        #print(f_dict)
        #print(lst1, lst2)
        #return res
        for i in range(k, n):
            num1 = nums[i - k]
            num2 = nums[i]
            #print(num1, num2)
            if num1 == num2:
                res.append(tot)
                continue
            f2 = f_dict.get(num2, 0)
            #print((f2, num2), f_dict, lst1, lst2)
            if lst1 and (f2, num2) >= lst1[0]:
                if f2:
                    lst1.remove((f2, num2))
                lst1.add((f2 + 1, num2))
                tot += num2
            else:
                if f2:
                    lst2.remove((f2, num2))
                lst2.add((f2 + 1, num2))
            f_dict[num2] = f2 + 1
            f1 = f_dict.get(num1, 0)
            if (f1, num1) >= lst1[0]:
                lst1.remove((f1, num1))
                if f1 > 1:
                    lst1.add((f1 - 1, num1))
                tot -= num1
            else:
                lst2.remove((f1, num1))
                if f1 > 1:
                    lst2.add((f1 - 1, num1))
            if f1 == 1:
                f_dict.pop(num1)
            else:
                f_dict[num1] = f1 - 1
            #print(f_dict)
            #print(lst1, lst2)
            
            #print(f_dict)
            #print(lst1, lst2)

            while lst2 and len(lst1) < x:
                f, num = lst2.pop(-1)
                tot += f * num
                lst1.add((f, num))
            while lst2 and lst2[-1] > lst1[0]:
                f1, num1 = lst2.pop(-1)
                f2, num2 = lst1.pop(0)
                tot += f1 * num1 - f2 * num2
                lst1.add((f1, num1))
                lst2.add((f2, num2))
            res.append(tot)
            #print(f_dict)
            #print(lst1, lst2)
        return res",1420571324
sveng101,sveng101,242,3610,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        if n < k: return []
        f_dict = {}
        tot = 0
        for i in range(min(k, n)):
            num = nums[i]
            f_dict[num] = f_dict.get(num, 0) + 1
            tot += num
        lst1 = SortedList([(f, num) for num, f in f_dict.items()])
        lst2 = SortedList()
        #print(lst)
        #print(tot)
        while len(lst1) > x:
            f, num = lst1.pop(0)
            #print(f, num)
            tot -= f * num
            lst2.add((f, num))
            #print(len(lst), x)
        res = [tot]
        #print(f_dict)
        #print(lst1, lst2)
        #return res
        for i in range(k, n):
            num1 = nums[i - k]
            num2 = nums[i]
            #print(num1, num2)
            if num1 == num2:
                res.append(tot)
                continue
            f2 = f_dict.get(num2, 0)
            #print((f2, num2), f_dict, lst1, lst2)
            if lst1 and (f2, num2) >= lst1[0]:
                if f2:
                    lst1.remove((f2, num2))
                lst1.add((f2 + 1, num2))
                tot += num2
            else:
                if f2:
                    lst2.remove((f2, num2))
                lst2.add((f2 + 1, num2))
            f_dict[num2] = f2 + 1
            f1 = f_dict.get(num1, 0)
            if (f1, num1) >= lst1[0]:
                lst1.remove((f1, num1))
                if f1 > 1:
                    lst1.add((f1 - 1, num1))
                tot -= num1
            else:
                lst2.remove((f1, num1))
                if f1 > 1:
                    lst2.add((f1 - 1, num1))
            if f1 == 1:
                f_dict.pop(num1)
            else:
                f_dict[num1] = f1 - 1
            #print(f_dict)
            #print(lst1, lst2)
            
            #print(f_dict)
            #print(lst1, lst2)

            while lst2 and len(lst1) < x:
                f, num = lst2.pop(-1)
                tot += f * num
                lst1.add((f, num))
            while lst2 and lst2[-1] > lst1[0]:
                f1, num1 = lst2.pop(-1)
                f2, num2 = lst1.pop(0)
                tot += f1 * num1 - f2 * num2
                lst1.add((f1, num1))
                lst2.add((f2, num2))
            res.append(tot)
            #print(f_dict)
            #print(lst1, lst2)
        return res",1420570691
Chou,a0920732333,243,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution 
{
public:
    vector<int> ans;
    int solve(TreeNode* ptr)
    {
        if(!ptr->left && !ptr->right)
        {
            ans.push_back(1);
            return 1;
        }
        else if(!ptr->left)
        {
            solve(ptr->right);
            return 0;
        }
        else if(!ptr->right)
        {
            solve(ptr->left);
            return 0;
        }
        int l = solve(ptr->left);
        int r = solve(ptr->right);
        if(l == 0 || r == 0)
        {
            return 0;
        }
        if(l == r)
        {
            ans.push_back(l + r + 1);
            return l + r + 1;
        }
        return 0;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) 
    {
        solve(root);
        sort(ans.begin(), ans.end());
        return ans.size() < k ? -1 : ans[ans.size() - k];
    }
};",1420589707
Chou,a0920732333,243,3588,cpp,"class Solution 
{
public:
    int countWinningSequences(string s) 
    {
        int n = s.length(), ans = 0, mod = 1e9 + 7;
        vector<vector<unordered_map<int, int>>> dp(n, vector<unordered_map<int, int>>(3));
        if(s[0] == 'F')
        {
            dp[0][0][0] = 1;
            dp[0][1][1] = 1;
            dp[0][2][-1] = 1;
        }
        else if(s[0] == 'W')
        {
            dp[0][0][-1] = 1;
            dp[0][1][0] = 1;
            dp[0][2][1] = 1;
        }
        else
        {
            dp[0][0][1] = 1;
            dp[0][1][-1] = 1;
            dp[0][2][0] = 1;
        }
        for(int i = 1; i < n; i++)
        {
            if(s[i] == 'F')
            {
                for(auto it : dp[i - 1][1])
                {
                    dp[i][0][it.first] += it.second;
                    dp[i][0][it.first] %= mod;
                }
                for(auto it : dp[i - 1][2])
                {
                    dp[i][0][it.first] += it.second;
                    dp[i][0][it.first] %= mod;
                }
                for(auto it : dp[i - 1][0])
                {
                    dp[i][1][it.first + 1] += it.second;
                    dp[i][1][it.first + 1] %= mod;
                }
                for(auto it : dp[i - 1][2])
                {
                    dp[i][1][it.first + 1] += it.second;
                    dp[i][1][it.first + 1] %= mod;
                }
                for(auto it : dp[i - 1][0])
                {
                    dp[i][2][it.first - 1] += it.second;
                    dp[i][2][it.first - 1] %= mod;
                }
                for(auto it : dp[i - 1][1])
                {
                    dp[i][2][it.first - 1] += it.second;
                    dp[i][2][it.first - 1] %= mod;
                }
            }
            else if(s[i] == 'W')
            {
                for(auto it : dp[i - 1][1])
                {
                    dp[i][0][it.first - 1] += it.second;
                    dp[i][0][it.first - 1] %= mod;
                }
                for(auto it : dp[i - 1][2])
                {
                    dp[i][0][it.first - 1] += it.second;
                    dp[i][0][it.first - 1] %= mod;
                }
                for(auto it : dp[i - 1][0])
                {
                    dp[i][1][it.first] += it.second;
                    dp[i][1][it.first] %= mod;
                }
                for(auto it : dp[i - 1][2])
                {
                    dp[i][1][it.first] += it.second;
                    dp[i][1][it.first] %= mod;
                }
                for(auto it : dp[i - 1][0])
                {
                    dp[i][2][it.first + 1] += it.second;
                    dp[i][2][it.first + 1] %= mod;
                }
                for(auto it : dp[i - 1][1])
                {
                    dp[i][2][it.first + 1] += it.second;
                    dp[i][2][it.first + 1] %= mod;
                }
            }
            else
            {
                for(auto it : dp[i - 1][1])
                {
                    dp[i][0][it.first + 1] += it.second;
                    dp[i][0][it.first + 1] %= mod;
                }
                for(auto it : dp[i - 1][2])
                {
                    dp[i][0][it.first + 1] += it.second;
                    dp[i][0][it.first + 1] %= mod;
                }
                for(auto it : dp[i - 1][0])
                {
                    dp[i][1][it.first - 1] += it.second;
                    dp[i][1][it.first - 1] %= mod;
                }
                for(auto it : dp[i - 1][2])
                {
                    dp[i][1][it.first - 1] += it.second;
                    dp[i][1][it.first - 1] %= mod;
                }
                for(auto it : dp[i - 1][0])
                {
                    dp[i][2][it.first] += it.second;
                    dp[i][2][it.first] %= mod;
                }
                for(auto it : dp[i - 1][1])
                {
                    dp[i][2][it.first] += it.second;
                    dp[i][2][it.first] %= mod;
                }
            }
        }
        for(auto it : dp[n - 1][0])
        {
            ans += it.first > 0 ? it.second : 0;
            ans %= mod;
        }
        for(auto it : dp[n - 1][1])
        {
            ans += it.first > 0 ? it.second : 0;
            ans %= mod;
        }
        for(auto it : dp[n - 1][2])
        {
            ans += it.first > 0 ? it.second : 0;
            ans %= mod;
        }
        return ans;
    }
};

//3 * 2 * 2 * 2 * 2",1420611676
Chou,a0920732333,243,3592,cpp,"class Solution 
{
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) 
    {
        unordered_map<int, int> um;
        // auto cmp1 = [&um](const int i1, const int i2)
        // {
        //     return um[i1] == um[i2] ? i1 < i2 : um[i1] < um[i2];
        // };
        // auto cmp2 = [&um](const int i1, const int i2)
        // {
        //     return um[i1] == um[i2] ? i1 > i2 : um[i1] > um[i2];
        // };
        // priority_queue<int, vector<int>, decltype(cmp1)> pq1(cmp1);
        // priority_queue<int, vector<int>, decltype(cmp2)> pq2(cmp2);
        int n = nums.size();
        long long sum = 0;
        set<pair<int, int>> s1;
        set<pair<int, int>> s2;
        vector<long long> ans;
        for(int i = 0; i < n; i++)
        {
            if(i >= k)
            {
                ans.push_back(sum);
                if(s2.count({um[nums[i - k]], nums[i - k]}))
                {
                    s2.erase({um[nums[i - k]], nums[i - k]});
                    sum -= (long long)um[nums[i - k]] * nums[i - k];
                }
                else if(s1.count({um[nums[i - k]], nums[i - k]}))
                {
                    s1.erase({um[nums[i - k]], nums[i - k]});
                }
                um[nums[i - k]]--;
                s2.insert({um[nums[i - k]], nums[i - k]});
                sum += (long long)um[nums[i - k]] * nums[i - k];
            }
            if(um.count(nums[i]))
            {
                if(s2.count({um[nums[i]], nums[i]}))
                {
                    s2.erase({um[nums[i]], nums[i]});
                    sum -= (long long)um[nums[i]] * nums[i];
                }
                else if(s1.count({um[nums[i]], nums[i]}))
                {
                    s1.erase({um[nums[i]], nums[i]});
                }
            }
            um[nums[i]]++;
            s2.insert({um[nums[i]], nums[i]});
            sum += (long long)um[nums[i]] * nums[i];
            while(s2.size() > x)
            {
                sum -= (long long)(s2.begin()->first) * (s2.begin()->second);
                s1.insert(*s2.begin());
                s2.erase(s2.begin());
            }
            while(!s1.empty() && ((s1.rbegin()->first > s2.begin()->first) || (s1.rbegin()->first == s2.begin()->first && s1.rbegin()->second > s2.begin()->second)))
            {
                // cout << s1.rbegin()->first << ' ' << s1.rbegin()->second << ',' << s2.begin()->first << ' ' << s2.begin()->second << '\n';
                sum -= (long long)(s2.begin()->first) * (s2.begin()->second);
                sum += (long long)(s1.rbegin()->first) * (s1.rbegin()->second);
                s1.insert(*s2.begin());
                s2.erase(s2.begin());
                s2.insert(*s1.rbegin());
                s1.erase(prev(s1.end()));
                // cout << s1.rbegin()->first << ' ' << s1.rbegin()->second << ',' << s2.begin()->first << ' ' << s2.begin()->second << '\n';
            }
        }
        ans.push_back(sum);
        return ans;
        
    }
};",1420577945
Chou,a0920732333,243,3610,cpp,"class Solution 
{
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) 
    {
        unordered_map<int, int> um;
        // auto cmp1 = [&um](const int i1, const int i2)
        // {
        //     return um[i1] == um[i2] ? i1 < i2 : um[i1] < um[i2];
        // };
        // auto cmp2 = [&um](const int i1, const int i2)
        // {
        //     return um[i1] == um[i2] ? i1 > i2 : um[i1] > um[i2];
        // };
        // priority_queue<int, vector<int>, decltype(cmp1)> pq1(cmp1);
        // priority_queue<int, vector<int>, decltype(cmp2)> pq2(cmp2);
        int n = nums.size(), sum;
        set<pair<int, int>> s;
        vector<int> ans;
        for(int i = 0; i < n; i++)
        {
            if(i >= k)
            {
                sum = 0;
                for(auto it = s.rbegin(); it != s.rend() && distance(s.rbegin(), it) < x; it++)
                {
                    sum += it->first * it->second;
                }
                ans.push_back(sum);
                s.erase({um[nums[i - k]], nums[i - k]});
                um[nums[i - k]]--;
                s.insert({um[nums[i - k]], nums[i - k]});
            }
            if(um.count(nums[i]))
            {
                s.erase({um[nums[i]], nums[i]});
            }
            um[nums[i]]++;
            s.insert({um[nums[i]], nums[i]});
        }
        sum = 0;
        for(auto it = s.rbegin(); it != s.rend() && distance(s.rbegin(), it) < x; it++)
        {
            sum += it->first * it->second;
        }
        ans.push_back(sum);
        return ans;
    }
};",1420552323
Zong Xun,Zxun2,247,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.arr = []

        def findSizeOfPerfectSubtree(node: Optional[TreeNode]):
            if not node:
                return True, 0, 0 # (isPerfect, level, size)

            isLeftPerfect, leftLevel, leftSize = findSizeOfPerfectSubtree(node.left) 
            isRightPerfect, rightLevel, rightSize = findSizeOfPerfectSubtree(node.right)

            if isLeftPerfect and isRightPerfect \
                and leftLevel == rightLevel:
                self.arr.append(leftSize + rightSize + 1)
                return True, leftLevel + 1, leftSize + rightSize + 1

            return False, 0, 0

        findSizeOfPerfectSubtree(root)
        self.arr.sort(reverse=True)
        return self.arr[k - 1] if len(self.arr) >= k else -1",1420549500
Zong Xun,Zxun2,247,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        creatures = ['F', 'W', 'E']
        beats = {'F': 'E', 'W': 'F', 'E': 'W'}

        def point(a, b):
            if a == b:
                return 0
            elif beats[a] == b:
                return -1  # alice wins
            elif beats[b] == a:
                return 1   # bob wins 
            else:
                return 0   # nothing

        dp = [{} for _ in range(n + 1)]
        dp[0][None] = defaultdict(int)
        dp[0][None][0] = 1  # starting with score_diff = 0

        for pos in range(n):
            dp_next = {}
            for prev_bob in dp[pos]:
                score_diffs = dp[pos][prev_bob]
                for score_diff in score_diffs:
                    count = score_diffs[score_diff]
                    # bob's possible choices at this position
                    for bob_choice in creatures:
                        if bob_choice != prev_bob:
                            # compute the new score difference
                            round_result = point(s[pos], bob_choice)
                            new_score_diff = score_diff + round_result
                            # update DP for the next position
                            if bob_choice not in dp_next:
                                dp_next[bob_choice] = defaultdict(int)
                            dp_next[bob_choice][new_score_diff] = (
                                dp_next[bob_choice][new_score_diff] + count
                            ) % MOD
            dp[pos + 1] = dp_next

        total_sequences = 0
        for prev_bob in dp[n]:
            for score_diff, count in dp[n][prev_bob].items():
                if score_diff > 0:
                    total_sequences = (total_sequences + count) % MOD

        return total_sequences",1420578835
Zong Xun,Zxun2,247,3592,python3,"from bisect import bisect_left, insort_left
from collections import defaultdict
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        counts = defaultdict(int)
        sorted_multiset = []

        for val in nums[:k]:
            counts[val] += 1
        for val, cnt in counts.items():
            entry = (-cnt, -val)
            insort_left(sorted_multiset, entry)

        total = sum((-freq_neg) * (-val_neg) for freq_neg, val_neg in sorted_multiset[:x])
        result.append(total)

        for i in range(1, n - k + 1):
            out_val = nums[i - 1]
            in_val = nums[i + k - 1]

            old_count = counts[out_val]
            old_entry = (-old_count, -out_val)
            idx = bisect_left(sorted_multiset, old_entry)
            sorted_multiset.pop(idx)
            counts[out_val] -= 1
            new_count = counts[out_val]
            if new_count > 0:
                new_entry = (-new_count, -out_val)
                insort_left(sorted_multiset, new_entry)
                new_idx = bisect_left(sorted_multiset, new_entry)
            else:
                new_idx = None  # Element removed
                del counts[out_val]
            if idx < x:
                if new_idx is None or new_idx >= x:
                    total -= old_count * out_val
                    if len(sorted_multiset) >= x:
                        freq_neg, val_neg = sorted_multiset[x - 1]
                        total += (-freq_neg) * (-val_neg)
                else:
                    total -= old_count * out_val
                    total += new_count * out_val
            elif new_idx is not None and new_idx < x:
                total += new_count * out_val
                if len(sorted_multiset) > x:
                    freq_neg, val_neg = sorted_multiset[x]
                    total -= (-freq_neg) * (-val_neg)

            old_count = counts.get(in_val, 0)
            if old_count > 0:
                old_entry = (-old_count, -in_val)
                idx = bisect_left(sorted_multiset, old_entry)
                sorted_multiset.pop(idx)
            counts[in_val] = old_count + 1
            new_count = counts[in_val]
            new_entry = (-new_count, -in_val)
            insort_left(sorted_multiset, new_entry)
            new_idx = bisect_left(sorted_multiset, new_entry)
            if old_count > 0:
                if idx < x:
                    if new_idx >= x:
                        total -= old_count * in_val
                        if len(sorted_multiset) >= x:
                            freq_neg, val_neg = sorted_multiset[x - 1]
                            total += (-freq_neg) * (-val_neg)
                    else:
                        total -= old_count * in_val
                        total += new_count * in_val
                elif new_idx < x:
                    total += new_count * in_val
                    if len(sorted_multiset) > x:
                        freq_neg, val_neg = sorted_multiset[x]
                        total -= (-freq_neg) * (-val_neg)
            else:
                if new_idx < x:
                    total += new_count * in_val
                    if len(sorted_multiset) > x:
                        freq_neg, val_neg = sorted_multiset[x]
                        total -= (-freq_neg) * (-val_neg)

            result.append(total)

        return result
",1420606893
Zong Xun,Zxun2,247,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        
        def get_x_sum(subarr):
            freq = Counter(subarr)  
            top_elements = sorted(freq.items(), key=lambda e: (-e[1], -e[0]))
            print(top_elements)
            x_sum = sum([val * cnt for val, cnt in top_elements[:x]])
            return x_sum

        for i in range(n - k + 1):
            subarr = nums[i:i + k]  
            result.append(get_x_sum(subarr))

        return result",1420540573
Abhay Singh,FSPINDLE,248,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
                        
            
                    map < TreeNode * , int > size ;
                    priority_queue < int , vector <int> , greater <int>> pq ;
            
               auto dfs1 = [&](auto &&dfs1 , TreeNode * node) ->void{
                         
                         size[node] = 1 ;
                         if(node -> left) {
                                  dfs1(dfs1 , node -> left) ;
                                  size[node] += size[node -> left] ;
                         }
                         if(node -> right){
                                  dfs1(dfs1 , node -> right) ;
                                 size[node] += size[node -> right] ;
                         }
                       return ;
               };
            
             auto dfs2 = [&](auto && dfs2 , TreeNode * node) -> bool{
                           
                         if(!node ->left && !node -> right){
                                 pq.push(1);
                                 return true ;
                         }
                     
                        if(node -> left && node -> right){
                          bool f1 = dfs2(dfs2 , node -> left) ;
                          bool f2  = dfs2(dfs2 , node -> right) ;
                          bool f = ( f1 && f2  && (size[node -> left] == size[node -> right])) ; 

                               if(f) pq.push(size[node]) ;
                             return f ;
                         }
                      
                     else{
                              if(node -> left) dfs2(dfs2 , node -> left) ;
                              if(node -> right) dfs2(dfs2 , node -> right) ;
                              return false ;
                     }
              };
             dfs1(dfs1 , root);
             dfs2(dfs2 , root) ;

            while(pq.size() > k) pq.pop() ;
            if(pq.size() < k) return -1 ;
            return pq.top() ;
    }
};",1420590809
Abhay Singh,FSPINDLE,248,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
          
            int n = s.size() ;
            const int mod = 1e9 + 7 ;
             
            vector <int> arr(n) ;
             
             for(int i = 0 ; i < n ;i ++){
                       if(s[i] == 'F') arr[i] = 0 ;
                       else if(s[i] == 'W') arr[i] = 1 ;
                       else arr[i] = 2  ;
             }
             
           vector < vector < vector < int >>> dp(n + 1, vector < vector < int>> (2 * n + 1, vector <int>(5 , -1))) ;
//             map < array < int , 3 > , int> dp ;
            
//              for(int i = 0 ; i <= n ; i ++){
//                      for(int j = -n ; j <= n ; j ++){
//                               for(int k = 0 ; k <= 4 ; k ++) dp[{i , j , k}] = -1;
//                   }
//            }
            
            auto func = [&](auto &&func , int i , int curr , int last) -> int{
                    
                       if(i == n){
                               return curr > n ;
                      }
                     if(dp[i][curr][last] != -1) return dp[i][curr][last] ;
                  //  if(dp[{i , curr , last}] != -1) return  dp[{i , curr , last}];
                     
                     long long ret = 0;
                    
                      for(int j = 0 ; j <= 2 ; j ++){
                              
                              if(j == last) continue ;
                              int f = 0 ;
                              
                              if(j == (arr[i] + 1) % 3) f = 1 ; 
                              else if((j + 1) % 3 == arr[i]) f = -1;
                              
                              ret += func(func , i + 1 ,curr + f , j) ;
                              ret %= mod ;                             
                      }
                  //  return dp[{i , curr , last}] = ret ;
                    return dp[i][curr][last] = ret;
            };
             
             int ans = func(func , 0 , n , 3) ;
            
            return ans ;
    }
};",1420612690
Abhay Singh,FSPINDLE,248,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
                 
                  using ll = long long ;
                  
               ll n = nums.size() , sum = 0 ;
              
               set < pair < ll , ll >> A  , B ;
               map < ll , ll > mp ;
               
              for(int i = 0 ; i < k ; i ++ ){
                      mp[nums[i]] ++ ;
               }
            
              for(auto it : mp){
                      A.insert({-it.second , -it.first}) ;
                      sum += it.first * it.second ;
               }
                 
            while(A.size() > x){
                    auto e = (--A.end()) ;
                    B.insert(*e) ;
                    sum -= (*e).first * (*e).second ;
                    A.erase(e) ;
            }
            
            vector <ll> ans ;
            ans.push_back(sum) ;
             // for(auto it : A ) {
             //                  cout << -it.second << "" "" << -it.first << endl;
             //          }
             //         cout << endl;
            
              for(int i = k ; i < n ;i ++){
                     ll prev = nums[i - k] , now = nums[i] ;
                     if(A.count({-mp[prev] , -prev})) {
                              A.erase({-mp[prev] , -prev}) ;
                              sum -= mp[prev] * prev ;
                     }
                     if(B.count({-mp[prev] , -prev})) {
                              B.erase({-mp[prev] , -prev}) ;
                     }
                     if(A.count({-mp[now] , - now})) {
                             A.erase({-mp[now] , - now}) ;
                             sum -= now * mp[now];
                     }
                    if(B.count({-mp[now] , - now})) {
                             B.erase({-mp[now] , - now}) ;
                     }
                     mp[prev] -- , mp[now] ++ ;
                     
                     if(mp[prev]) {
                              A.insert({-mp[prev] , -prev}) ;
                              sum += mp[prev] * prev ;
                     }
                     if(mp[now] && prev != now) {
                             A.insert({-mp[now] , -now}) ;
                             sum += now * mp[now];
                     }
                      while(A.size() < x && !B.empty()){
                              auto e  = *B.begin() ;
                              A.insert(e) ;
                              B.erase(e) ;
                              sum += (e.first) * (e.second);
                        }
                     while(A.size() > x){
                      auto e = (--A.end()) ;
                       B.insert(*e) ;
                       sum -= (*e).first * (*e).second ;
                        A.erase(e) ;
                      }
                      
                      while(!B.empty()){
                              auto t = *B.begin() ;
                              auto s = *(--A.end()) ;                             
                              if(t.first < s.first || (t.first == s.first && t.second < s.second) ){
                                   sum -= s.first * s.second ;
                                   sum += t.first * t.second;
                                   B.erase(t) ;
                                   B.insert(s) ;
                                   A.erase(s) ;
                                   A.insert(t) ;
                                 
                              }
                              else break ;
                      }
                      ans.push_back(sum) ;
                      // for(auto it : A ) {
                      //      cout << -it.second << "" "" << -it.first << endl;
                      // }
                      // cout << endl;
               }
            return ans;
    }
};",1420562270
Abhay Singh,FSPINDLE,248,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
                using ll = long long ;
                  
               ll n = nums.size() , sum = 0 ;
              
               set < pair < ll , ll >> A  , B ;
               map < ll , ll > mp ;
               
              for(int i = 0 ; i < k ; i ++ ){
                      mp[nums[i]] ++ ;
               }
            
              for(auto it : mp){
                      A.insert({-it.second , -it.first}) ;
                      sum += it.first * it.second ;
               }
                 
            while(A.size() > x){
                    auto e = (--A.end()) ;
                    B.insert(*e) ;
                    sum -= (*e).first * (*e).second ;
                    A.erase(e) ;
            }
            
            vector <int> ans ;
            ans.push_back(sum) ;
            
              for(int i = k ; i < n ;i ++){
                     ll prev = nums[i - k] , now = nums[i] ;
                     if(A.count({-mp[prev] , -prev})) {
                              A.erase({-mp[prev] , -prev}) ;
                              sum -= mp[prev] * prev ;
                     }
                     if(B.count({-mp[prev] , -prev})) {
                              B.erase({-mp[prev] , -prev}) ;
                     }
                     if(A.count({-mp[now] , - now})) {
                             A.erase({-mp[now] , - now}) ;
                             sum -= now * mp[now];
                     }
                    if(B.count({-mp[now] , - now})) {
                             B.erase({-mp[now] , - now}) ;
                     }
                     mp[prev] -- , mp[now] ++ ;
                     
                     if(mp[prev]) {
                              A.insert({-mp[prev] , -prev}) ;
                              sum += mp[prev] * prev ;
                     }
                     if(mp[now] && prev != now) {
                             A.insert({-mp[now] , -now}) ;
                             sum += now * mp[now];
                     }
                      while(A.size() < x && !B.empty()){
                              auto e  = *B.begin() ;
                              A.insert(e) ;
                              B.erase(e) ;
                              sum += (e.first) * (e.second);
                        }
                     while(A.size() > x){
                      auto e = (--A.end()) ;
                       B.insert(*e) ;
                       sum -= (*e).first * (*e).second ;
                        A.erase(e) ;
                      }
                      
                      while(!B.empty()){
                              auto t = *B.begin() ;
                              auto s = *(--A.end()) ;                             
                              if(t.first < s.first || (t.first == s.first && t.second < s.second) ){
                                   sum -= s.first * s.second ;
                                   sum += t.first * t.second;
                                   B.erase(t) ;
                                   B.insert(s) ;
                                   A.erase(s) ;
                                   A.insert(t) ;
                                 
                              }
                              else break ;
                      }
                      ans.push_back(sum) ;
               }
            return ans;
    }
};",1420563389
Arindam Pande,pandearindam,249,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    vector<int> ans;
    
    pair<int,int> dfs(TreeNode* root){
        
        if(root==NULL) return {0,0};
        pair<int,int> a=dfs(root->left);
        pair<int,int> b=dfs(root->right);
        
        if(a.first!=INT_MIN && a==b) ans.push_back(1+a.second+b.second);
        else return {INT_MIN,INT_MIN}; 
        return {a.first+1,a.second+b.second+1};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        
        ans.clear();
        pair<int,int> p=dfs(root);
        sort(ans.begin(),ans.end(),greater<int>());
        if(k>ans.size()) return -1;
        return ans[k-1];
        
    }
};",1420538544
Arindam Pande,pandearindam,249,3588,cpp,"int MOD=1e9+7;

class Solution {
public:
    
    int dp[1001][2001][4];
    
    int helper(int index, int score, int lst, vector<int> &a){
    
        int n=a.size();
        if(index==n){
            if(score>0) return 1;
            return 0;
        }
        
        if(dp[index][1000+score][lst]!=-1) return dp[index][1000+score][lst];
        
        long long b,c,d;
        if(a[index]==0){
            b=helper(index+1,score,0,a);
            c=helper(index+1,score+1,1,a);
            d=helper(index+1,score-1,2,a);
        }
        if(a[index]==1){
            b=helper(index+1,score-1,0,a);
            c=helper(index+1,score,1,a);
            d=helper(index+1,score+1,2,a);
        }
        if(a[index]==2){
            b=helper(index+1,score+1,0,a);
            c=helper(index+1,score-1,1,a);
            d=helper(index+1,score,2,a);
        }
        
        long long ans=0;
        if(lst==0) ans=c+d;
        if(lst==1) ans=b+d;
        if(lst==2) ans=b+c;
        if(lst==3) ans=(b+c)%MOD+d;
        return dp[index][1000+score][lst]=(ans%MOD);
        
    }
    
    int countWinningSequences(string s) {
        
        int n=s.size();
        
        vector<int> a(n);
        for(int i=0;i<n;i++){
            if(s[i]=='F') a[i]=0;
            if(s[i]=='W') a[i]=1;
            if(s[i]=='E') a[i]=2;
        }
        
        memset(dp,-1,sizeof(dp));
        return helper(0,0,3,a);    
    
    }
};",1420576974
Arindam Pande,pandearindam,249,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        
        int n=nums.size();
        
        set<pair<long long,long long>> lower,higher; 
        
        map<long long,long long> mp;
        
        vector<long long> help(n-k+1);
        long long ans=0;
        
        int l=0;
        for(int i=0;i<n;i++){
            
            if(lower.find({mp[nums[i]],nums[i]})!=lower.end()){
                auto it=lower.find({mp[nums[i]],nums[i]});
                lower.erase(it);
                mp[nums[i]]++;
                lower.insert({mp[nums[i]],nums[i]});
            }
            else if(higher.find({mp[nums[i]],nums[i]})!=higher.end()){
                auto it=higher.find({mp[nums[i]],nums[i]});
                higher.erase(it);
                mp[nums[i]]++;
                ans+=nums[i];
                higher.insert({mp[nums[i]],nums[i]});
            }
            else{
                mp[nums[i]]++;
                lower.insert({mp[nums[i]],nums[i]});
            }
            
            if(higher.size()<x && !lower.empty()){
                auto it=lower.end();
                it--;
                ans+=it->first*it->second;
                higher.insert(*it);
                lower.erase(*it);
            }
            else if(!lower.empty()){
                auto it1=lower.end();
                it1--;
                auto it2=higher.begin();
                if((it1->first>it2->first) || (it1->first==it2->first && it1->second>it2->second)){
                    ans+=it1->first*it1->second;
                    higher.insert(*it1);
                    lower.insert(*it2);
                    ans-=it2->first*it2->second;
                    lower.erase(it1);
                    higher.erase(it2);
                }
            }
            
            
            if(i-l+1==k){
                
                help[l]=ans;
                
                if(lower.find({mp[nums[l]],nums[l]})!=lower.end()){
                    auto it=lower.find({mp[nums[l]],nums[l]});
                    lower.erase(it);
                    mp[nums[l]]--;
                    if(mp[nums[l]]!=0) lower.insert({mp[nums[l]],nums[l]});
                }
                else if(higher.find({mp[nums[l]],nums[l]})!=higher.end()){
                    auto it=higher.find({mp[nums[l]],nums[l]});
                    higher.erase(it);
                    mp[nums[l]]--;
                    ans-=nums[l];
                    if(mp[nums[l]]!=0){
                        higher.insert({mp[nums[l]],nums[l]});
                    }
                }
                
                if(higher.size()<x && !lower.empty()){
                    auto it=lower.end();
                    it--;
                    ans+=it->first*it->second;
                    higher.insert(*it);
                    lower.erase(*it);
                }
                else if(!lower.empty()){
                    auto it1=lower.end();
                    it1--;
                    auto it2=higher.begin();
                    if((it1->first>it2->first) || (it1->first==it2->first && it1->second>it2->second)){
                        ans+=it1->first*it1->second;
                        higher.insert(*it1);
                        lower.insert(*it2);
                        ans-=it2->first*it2->second;
                        lower.erase(it1);
                        higher.erase(it2);
                    }
                }
                l++;
                
            }
            
        }
        return help;
        
    }
};",1420618926
Arindam Pande,pandearindam,249,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        
        int n=nums.size();
        
        vector<int> ans(n-k+1);
        
        for(int i=0;i<n-k+1;i++){
            map<int,int> mp;
            for(int j=0;j<k;j++) mp[nums[i+j]]++;
            priority_queue<pair<int,int>> pq;
            for(auto &x:mp) pq.push({x.second,x.first});
            int cnt=0;
            // cout<<i<<""\n"";
            while(!pq.empty() && cnt<x){
                // cout<<pq.top().second<<"" ""<<pq.top().first<<""\n"";
                ans[i]+=pq.top().first*pq.top().second;
                cnt++;
                pq.pop();
            }
        }
        return ans;
        
    }
};",1420524164
Vishal Patil,incognito123,251,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> mt;
    pair<int,bool> rec(TreeNode* root){
        if(root==NULL){
            return {0,0};
        }
        if(root->left==NULL&&root->right==NULL){
            mt.push_back(1);
            return {1,true};
        }
        auto tk=rec(root->left);
        auto tk1=rec(root->right);
        if(root->left==NULL) return {0,false};
        if(root->right==NULL) return {0,false};
        if(tk.second==false||tk1.second==false||(tk.first!=tk1.first)){
            return {0,false};
        }
        mt.push_back(tk.first+tk1.first+1);
        return {tk.first+tk1.first+1,true};
    }  
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        mt.clear();
        rec(root);
        if(!mt.empty()) sort(mt.begin(),mt.end());
        int sz=mt.size();
        if(sz<k) return -1;
        if(!mt.empty()) reverse(mt.begin(),mt.end());
        return mt[k-1];
    }
};",1420537630
Vishal Patil,incognito123,251,3588,cpp,"#define ll long long

ll mod=1e9+7;

class Solution {
public:
    char arr[3]={'F','W','E'};
    map<char,char> mp{{'F','E'},{'W','F'},{'E','W'}};
    ll dp[1001][2001][4];
    map<char,int> mp2{{'?',0},{'F',1},{'W',2},{'E',3}};
    ll rec(int i ,string& s,int n, int count, char last){
        if(i==n){
            return (count>n);
        }
        if(dp[i][count][mp2[last]]!=-1) return dp[i][count][mp2[last]];
        ll ans=0;
        for(int j=0;j<3;j++){
            if(arr[j]==last) continue;
            if(mp[arr[j]]==s[i]){
                ans+=rec(i+1,s,n,count+1,arr[j]);
            }
            else if(mp[s[i]]==arr[j]){
                ans+=rec(i+1,s,n,count-1,arr[j]);
            }
            else{
                ans+=rec(i+1,s,n,count,arr[j]);
            }
        }
        ans%=mod;
        return dp[i][count][mp2[last]]=ans;
    }
    
    int countWinningSequences(string s) {
        int n=s.size();
        for(int i=0;i<=n;i++) for(int j=0;j<=2*n;j++) for(int k=0;k<4;k++) dp[i][j][k]=-1;
        return rec(0,s,int(s.size()),n,'?');
    }
};",1420567398
Vishal Patil,incognito123,251,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <functional> // for less
#include <iostream>   // for I/O

using namespace std;
using namespace __gnu_pbds;

#define ll long long

typedef pair<ll, ll> pii;
typedef tree<pii, null_type, less<pii>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;


class Solution {
public:

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        vector<ll> ans;
        map<ll,ll> mp;
        ordered_set os,os1;
        for(ll i=0;i<k;i++){
            if(os.find({mp[nums[i]],nums[i]})!=os.end()){
                os.erase(os.find({mp[nums[i]],nums[i]}));
            }
            mp[nums[i]]+=1;
            os.insert({mp[nums[i]],nums[i]});
        }
        ll temp=0;
        while(int(os.size())>x){
            os1.insert(*os.begin());
            os.erase(os.find(*os.begin()));
        }
        for(auto p:os) temp+=(p.first*p.second);
        ans.push_back(temp);
        
        ll cntr=0;
        for(ll i=k;i<n;i++){
            if(os.find({mp[nums[cntr]],nums[cntr]})!=os.end()){
                temp-=((mp[nums[cntr]])*(nums[cntr]));
                os.erase(os.find({mp[nums[cntr]],nums[cntr]}));
            }
            if(os1.find({mp[nums[cntr]],nums[cntr]})!=os1.end()){
                os1.erase(os1.find({mp[nums[cntr]],nums[cntr]}));
            }
            mp[nums[cntr]]-=1;
            temp+=(mp[nums[cntr]]*nums[cntr]);
            os.insert({mp[nums[cntr]],nums[cntr]});
            
            
            
            
            if(os.find({mp[nums[i]],nums[i]})!=os.end()){
                temp-=(mp[nums[i]]*nums[i]);
                os.erase(os.find({mp[nums[i]],nums[i]}));
            }
            if(os1.find({mp[nums[i]],nums[i]})!=os1.end()){
                os1.erase(os1.find({mp[nums[i]],nums[i]}));
            }
            mp[nums[i]]+=1;
            temp+=(mp[nums[i]]*nums[i]);
            os.insert({mp[nums[i]],nums[i]});
            
            
            
            while(int(os.size())>x){
                auto tks=*os.begin();
                os.erase(os.find(tks));
                os1.insert(tks);
                temp-=(tks.first*tks.second);
            }
            while(!os.empty()&&!os1.empty()){
                auto tk1=*os.begin();
                auto tk2=*os1.rbegin();
                if((tk1.first>tk2.first)||(tk1.first==tk2.first&&tk1.second>=tk2.second)){
                    break;
                }
                os.erase(os.find(tk1));
                os1.erase(os1.find(tk2));
                os.insert(tk2);
                os1.insert(tk1);
                temp-=(tk1.first*tk1.second);
                temp+=(tk2.first*tk2.second);
            }
            ans.push_back(temp);
            cntr+=1;
        }
        
        return ans;
    }
};",1420613394
Vishal Patil,incognito123,251,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<=n-k;i++){
            map<int,int> mp;
            for(int j=i;j<i+k;j++){
                mp[nums[j]]+=1;
            }
            set<pair<int,int>> st;
            for(auto [x,y]:mp){
                st.insert({y,x});
            }
            while(int(st.size())>x){
                st.erase(st.find(*st.begin()));
            }
            int sum=0;
            for(auto p:st) sum+=(p.second*p.first);
            ans.push_back(sum);
        }
        return ans;
    }
};",1420521638
Surya Teja,suryacr7,252,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>ans;
    int height(TreeNode* root){
        if(!root)return 0;
        int left = height(root->left);
        int right = height(root->right);
        if(left == -1 || right == -1)return -1;
        if(left != right)return -1;
        ans.push_back((1<<(left+1))-1);
        return left+1;

    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        int c= height(root);
        sort(ans.begin(),ans.end());
        if(k>(int)ans.size())return -1;
        reverse(ans.begin(),ans.end());
        return ans[k-1];
    }
};",1420534587
Surya Teja,suryacr7,252,3588,cpp,"#define ll long long
class Solution {
public:

    int dp[1010][2010][5];
    int n;
    int N=1e9+7;
    map<int,char>m;
    int rec(int i,int point,int last,string &s){
        if(i==n){
            if(point>1000)return 1;
            else return 0;
        }
        if(dp[i][point][last]!=-1)return dp[i][point][last];
        ll ans=0;
        for(int j=0;j<3;j++){
            char c=m[j];
            if(j!=last){
                if(s[i]=='F'){
                    if(c=='F'){
                        (ans+=rec(i+1,point,j,s))%=N;
                    }else if(c=='W'){
                        (ans+=rec(i+1,point+1,j,s))%=N;
                    }else{
                        (ans+=rec(i+1,point-1,j,s))%=N;
                    }
                }else if(s[i]=='W'){
                    if(c=='W'){
                        (ans+=rec(i+1,point,j,s))%=N;
                    }else if(c=='E'){
                        (ans+=rec(i+1,point+1,j,s))%=N;
                    }else{
                        (ans+=rec(i+1,point-1,j,s))%=N;
                    }
                }else{
                    if(c=='E'){
                        (ans+=rec(i+1,point,j,s))%=N;
                    }else if(c=='F'){
                        (ans+=rec(i+1,point+1,j,s))%=N;
                    }else{
                        (ans+=rec(i+1,point-1,j,s))%=N;
                    }
                }
            }
        }
        return dp[i][point][last]=ans;
    }

    int countWinningSequences(string s) {
        n=s.length();
        m[0]='F';
        m[1]='W';
        m[2]='E';
        memset(dp,-1,sizeof(dp));
        return rec(0,1000,4,s);
    }
};",1420560616
Surya Teja,suryacr7,252,3592,cpp,"#define ll long long
class Solution {
public:
    vector<long long> findXSum(vector<int>& v, int k, int x) {
        map<ll,ll>m;
        vector<ll>ans;  
        set<pair<ll,ll>>s;
        set<pair<ll,ll>>s1;
        int n=v.size();
        for(int i=0;i<k;i++){
            m[v[i]]++;
        }
        for(auto it : m){
            s.insert({it.second,it.first});
        }
        ll sum=0;
        auto it =--s.end();
        int p=x;
        while(p--){
            sum+=(it->first)*1ll*(it->second);
            s1.insert({it->first,it->second});
            if(it==s.begin())break;
            it--;
        }
        for(auto it : s1){
            s.erase(it);
        }
        ans.push_back(sum);
        for(int i=k;i<n;i++){
            ll p=m[v[i-k]];
            if(s1.find({p,v[i-k]})!=s1.end()){
                sum-=(p*1ll*v[i-k]);
                s1.erase({p,v[i-k]});
                if(p-1)s.insert({p-1,v[i-k]});
            }else{
                s.erase({p,v[i-k]});
                if(p-1)s.insert({p-1,v[i-k]});
            }   
            m[v[i-k]]--;
            p=m[v[i]];
            if(s1.find({p,v[i]})!=s1.end()){
                sum+=(v[i]);
                s1.erase({p,v[i]});
                s1.insert({p+1,v[i]});
            }else{
                if(!p){
                sum+=(v[i]);
                s1.insert({p+1,v[i]});
                }else{
                s.erase({p,v[i]});
                sum+=((p+1)*1ll*v[i]);
                s1.insert({p+1,v[i]});
                }
            }
            m[v[i]]++;
            int c=1;
                while(c-- && (int)s.size()){
                auto it = --s.end();
                 sum+=(it->first)*1ll*(it->second);
                    s1.insert({it->first,it->second});
                    cout<<endl;
                    s.erase(it);
                }
            p=(int)s1.size()-x;
            if(p>0){
                while(p--){
                    auto it = s1.begin();
                    // cout<<i<<"" ""<<p<<"" ""<<it->first<<"" ""<<it->second<<""\n"";
                    sum-=(it->first)*1ll*(it->second);
                    s.insert({it->first,it->second});
                    s1.erase(it);
                }
            }
            // for(auto it: s1)cout<<it.first<<"" ""<<it.second<<""\n"";
            // cout<<""Yes\n"";
            ans.push_back(sum);
        }
        cout<<s1.size();
        return ans;
    }
};",1420619829
Surya Teja,suryacr7,252,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& v, int k, int x) {
        int n=v.size();
        vector<int>ans;
        for(int i=0;i<n-k+1;i++){
            map<int,int>m;
            int sum=0;
            for(int j=i;j<i+k;j++){
                m[v[j]]++;
            }
            vector<pair<int,int>>c;
            for(auto it : m){
                c.push_back({it.second,it.first});
            }
            sort(c.begin(),c.end());
            reverse(c.begin(),c.end());
            for(int j=0;j<min(x,(int)c.size());j++)sum+=c[j].first*c[j].second;
            ans.push_back(sum);
        }
        return ans;
    }
};",1420526538
saijaswanth25,saijaswanth25,253,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> s;

    int h(TreeNode* root){
        if(!root)
            return 0;

        int lh=0;
        if(root->left)
        lh=h(root->left);
        int rh=0;
        if(root->right)
        rh=h(root->right);
        if(lh==rh && lh>=0){
            s.push_back(lh);
        }
        if(lh!=rh)
            return -100;
        return 1+min(lh,rh);
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        h(root);
        sort(s.begin(),s.end());
        reverse(s.begin(),s.end());
        if(s.size()<k)
            return -1;
        int ans=0;
        for(int i=0;i<=s[k-1];i++)
            ans+=(1<<i);
        return ans;
    }
};",1420607209
saijaswanth25,saijaswanth25,253,3588,cpp,"class Solution {
public:
    #define ll long long
    ll dp[1005][2005][4];
    ll mod=1e9+7;
    ll fx(ll i,ll j,ll k,string &s,ll n){
        if(i==n){
            return j>n;
        }
        if(dp[i][j][k]!=-1)
            return dp[i][j][k];
        ll ans=0;
        for(ll p=0;p<3;p++){
            if(p==k)    
                continue;
            if(s[i]=='F'){
                if(p==0)
                {
                    ans+=fx(i+1,j,0,s,n);
                    ans%=mod;
                }
                else if(p==1){
                    ans+=fx(i+1,j+1,1,s,n);
                    ans%=mod;
                }
                else{
                    ans+=fx(i+1,j-1,2,s,n);
                    ans%=mod;
                }
            }
            else if(s[i]=='W'){
                if(p==0)
                {
                    ans+=fx(i+1,j-1,0,s,n);
                    ans%=mod;
                }
                else if(p==1){
                    ans+=fx(i+1,j,1,s,n);
                    ans%=mod;
                }
                else{
                    ans+=fx(i+1,j+1,2,s,n);
                    ans%=mod;
                }
            }
            else{
                if(p==0)
                {
                    ans+=fx(i+1,j+1,0,s,n);
                    ans%=mod;
                }
                else if(p==1){
                    ans+=fx(i+1,j-1,1,s,n);
                    ans%=mod;
                }
                else{
                    ans+=fx(i+1,j,2,s,n);
                    ans%=mod;
                }
            }
        }
        return dp[i][j][k]=ans;
    }
    int countWinningSequences(string s) {
        ll n=s.size();
        memset(dp,-1,sizeof(dp));
        return fx(0,n,3,s,n);
    }
};",1420595733
saijaswanth25,saijaswanth25,253,3592,cpp,"class Solution {
public:
    #define ll long long
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<ll,ll> mp;
        set<pair<ll,ll>> p,q;
        ll n=nums.size(),sum=0;
        for(ll i=0;i<k;i++){
            ll ele=nums[i];
            mp[nums[i]]++;
            ll freq=mp[nums[i]];
            if(p.count({freq-1,ele})){
                p.erase({freq-1,ele});
                p.insert({freq,ele});
                sum+=ele;
            }
            else if(p.size()<x){
                p.insert({freq,ele});
                sum+=ele*freq;
            }
            else{
                if(q.count({freq-1,ele}))
                    q.erase({freq-1,ele});
                q.insert({freq,ele});
                auto it=*p.begin();
                auto jt=*(--q.end());
                if(it.first<jt.first){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
                else if(it.first==jt.first && it.second<jt.second){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
            }
        }
        vector<ll> ans;
        ans.push_back(sum);
        for(ll i=k;i<n;i++){
            ll prev=nums[i-k];
            mp[prev]--;
            ll pf=mp[prev];
            ll cur=nums[i],freq=mp[nums[i]];
            mp[nums[i]]++;
            if(p.count({pf+1,prev})){
                p.erase({pf+1,prev});
                sum-=prev;
                if(pf)
                    p.insert({pf,prev});
            }
            else{
                q.erase({pf+1,prev});
                if(pf)
                q.insert({pf,prev});
            }
            if(p.count({freq,cur})){
                p.erase({freq,cur});
                p.insert({freq+1,cur});
                sum+=cur;
            }
            else{
                // cout<<freq<<"" ""<<cur<<""\n"";
                q.erase({freq,cur});
                q.insert({freq+1,cur});
            }
            auto it=*p.begin();
            while(p.size()<x && q.size()){
                auto it=*(--q.end());
                p.insert(it);
                sum+=(it.first)*(it.second);
                q.erase(it);
            }
            if(q.size()){
                auto it=*p.begin();
                auto jt=*(--q.end());
                // cout<<i<<""\n"";
                // cout<<it.first<<"" ""<<it.second<<""\n"";
                // cout<<jt.first<<"" ""<<jt.second<<""\n"";
                if(it.first<jt.first){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
                else if(it.first==jt.first && it.second<jt.second){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420580787
saijaswanth25,saijaswanth25,253,3610,cpp,"class Solution {
public:
    #define ll long long
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<ll,ll> mp;
        set<pair<ll,ll>> p,q;
        ll n=nums.size(),sum=0;
        for(ll i=0;i<k;i++){
            ll ele=nums[i];
            mp[nums[i]]++;
            ll freq=mp[nums[i]];
            if(p.count({freq-1,ele})){
                p.erase({freq-1,ele});
                p.insert({freq,ele});
                sum+=ele;
            }
            else if(p.size()<x){
                p.insert({freq,ele});
                sum+=ele*freq;
            }
            else{
                if(q.count({freq-1,ele}))
                    q.erase({freq-1,ele});
                q.insert({freq,ele});
                auto it=*p.begin();
                auto jt=*(--q.end());
                if(it.first<jt.first){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
                else if(it.first==jt.first && it.second<jt.second){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
            }
        }
        vector<int> ans;
        ans.push_back(sum);
        for(ll i=k;i<n;i++){
            ll prev=nums[i-k];
            mp[prev]--;
            ll pf=mp[prev];
            ll cur=nums[i],freq=mp[nums[i]];
            mp[nums[i]]++;
            if(p.count({pf+1,prev})){
                p.erase({pf+1,prev});
                sum-=prev;
                if(pf)
                    p.insert({pf,prev});
            }
            else{
                q.erase({pf+1,prev});
                if(pf)
                q.insert({pf,prev});
            }
            if(p.count({freq,cur})){
                p.erase({freq,cur});
                p.insert({freq+1,cur});
                sum+=cur;
            }
            else{
                // cout<<freq<<"" ""<<cur<<""\n"";
                q.erase({freq,cur});
                q.insert({freq+1,cur});
            }
            auto it=*p.begin();
            while(p.size()<x && q.size()){
                auto it=*(--q.end());
                p.insert(it);
                sum+=(it.first)*(it.second);
                q.erase(it);
            }
            if(q.size()){
                auto it=*p.begin();
                auto jt=*(--q.end());
                // cout<<i<<""\n"";
                // cout<<it.first<<"" ""<<it.second<<""\n"";
                // cout<<jt.first<<"" ""<<jt.second<<""\n"";
                if(it.first<jt.first){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
                else if(it.first==jt.first && it.second<jt.second){
                    p.erase(it);
                    sum-=(it.first)*(it.second);
                    sum+=(jt.first)*(jt.second);
                    p.insert(jt);
                    q.erase(jt);
                    q.insert(it);
                }
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420608079
yahoo010206,yahoo010206,254,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        values = []
        def solve(node):
            if not node:
                return 0
            l1 = solve(node.left)
            l2 = solve(node.right)
            if l1!=-1 and l1==l2:
                values.append(l1+l2+1)
                return l1+l2+1
            return -1
        solve(root)
        values.sort(reverse=True)
        # print(values)
        return values[k-1] if k<=len(values) else -1
",1420530535
yahoo010206,yahoo010206,254,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        cmp = {
            ""FF"":0,
            ""FW"":1,
            ""FE"":-1,
            ""WF"":-1,
            ""WW"":0,
            ""WE"":1,
            ""EF"":1,
            ""EW"":-1,
            ""EE"":0

        }
        modulo  = 1000000007
        mem = {(len(s)-1, sym):{cmp[s[-1]+sym]:1}  for sym in ""FWE""}
        def solve(idx, sym):
            key = (idx, sym)
            if key in mem:
                return mem[key]

            # print(idx, s[idx]+sym)
            value = cmp[s[idx]+sym]
            res = Counter()
            for _sym in ""FWE"":
                if _sym==sym:
                    continue
                for score, cnt in solve(idx+1, _sym).items():
                    _score = score+value
                    res[_score] = (res[_score]+cnt)%modulo
            # print(idx, s[idx]+sym, key, res)
            mem[key] = res
            return res
        res = 0
        for sym in ""FWE"":
            for score, cnt in solve(0, sym).items():
                if score>0:
                    res+=cnt
        return res%modulo",1420556101
yahoo010206,yahoo010206,254,3592,python3,"from sortedcontainers import SortedDict
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnts = Counter(nums[:k])
        bigger = SortedDict()
        smaller = SortedDict()
        
        keys = {}

        def new_cnt(key, res):
            if len(bigger)<x:
                bigger[key] = True
                res += key[0]*key[1]
            else:
                _key = bigger.peekitem(0)[0]
                if _key<key:
                    res -= _key[0]*_key[1]
                    bigger.pop(_key)
                    bigger[key] = True
                    res += key[0]*key[1]
                    smaller[_key] = True
                else:
                    smaller[key] = True
            return res
        res = 0
        for  num, cnt in cnts.items():
            key = (cnt, num)
            keys[num] = key
            res = new_cnt(key, res)
            # print(""*"",bigger,smaller, res)
        # print(res)
        ans = [res]
        # print(nums[k-1:])
        for idx, num in enumerate(nums[k:]):
            rm_key = keys[nums[idx]]
            _rm_key = (rm_key[0]-1, rm_key[1]) 
            keys[nums[idx]] = _rm_key
            # print(bigger,smaller, res)
            # print(rm_key)
            if rm_key in bigger:
                bigger.pop(rm_key)
                res-=rm_key[0]*rm_key[1]
                if smaller:
                    res = new_cnt(smaller.popitem(-1)[0], res)
                if _rm_key[0]:   
                    res = new_cnt(_rm_key, res)
            else:
                smaller.pop(rm_key)
                if _rm_key[0]:   
                    smaller[_rm_key] = True
            # print(bigger,smaller, res)
            key = keys.get(num, (0, num))
            # print(key)
            _key = (key[0]+1, key[1])
            keys[num] = _key
            if key[0]==0:
                pass
            elif key in bigger:
                bigger.pop(key)
                res-=key[0]*key[1]
            else:
                smaller.pop(key)
            res = new_cnt(_key, res)
            # print(bigger,smaller, res)
            ans.append(res)
        return ans
",1420614308
yahoo010206,yahoo010206,254,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnts = Counter(nums[:k-1])
        res = []
        # print(nums[k-1:])
        for idx, num in enumerate(nums[k-1:]):
            cnts[num]+=1
            # print(cnts, num)
            order = sorted(cnts.keys(), key=lambda x:(-cnts[x], -x))
            res.append(sum(num*cnts[num] for num in order[:x]))
            cnts[nums[idx]]-=1
        return res",1420522835
anikateKoul,anikateKoul,258,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void dfs(TreeNode* root, map<TreeNode*, int> &depth, map<TreeNode*, bool> &isPerfect) {
        if(root == NULL) return;

        int left = 0, right = 0;
        dfs(root->left, depth, isPerfect);
        dfs(root->right, depth, isPerfect);

        if(root->left != NULL) left = depth[root->left];
        if(root->right != NULL) right = depth[root->right];

        if((left == right) and (left != -1)) {
            isPerfect[root] = true;
            depth[root] = left + 1;
        }
        else {
            isPerfect[root] = false;
            depth[root] = -1;
        }
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        map<TreeNode*, int> depth;
        map<TreeNode*, bool> isPerfect;

        dfs(root, depth, isPerfect);

        vector<int> v;
        for(auto it : depth) {
            v.push_back(it.second);
        }

        sort(v.rbegin(), v.rend());

        k--;

        if(k >= v.size()) return -1;

        if(v[k] == -1) return -1;

        int val = v[k];

        int ans = 1;

        for(int i = 0; i < val; i++) ans *= 2;

        ans--;

        return ans;
    }
};",1420539379
anikateKoul,anikateKoul,258,3588,cpp,"long long MOD = 1e9 + 7;
long long dp[1001][2001][3];
unordered_map<char, int> m;
class Solution {
public:
    
    long long fun(int i, int count, char prev, string &s, int &n) {
        if(i == n) {
            if(count > ((2*n) - count)) return 1LL;
            else return 0LL;
        }

        if(dp[i][count][m[prev]] != -1) return dp[i][count][m[prev]];

        if(prev == 'F') {
            if(s[i] == 'E') {
                return dp[i][count][m[prev]] = (fun(i+1, count+1, 'E', s, n) + fun(i+1, count, 'W', s, n)) % MOD;
            }
            else if(s[i] == 'F') {
                return dp[i][count][m[prev]] = (fun(i+1, count+2, 'W', s, n) + fun(i+1, count, 'E', s, n)) % MOD;
            }
            else {
                return dp[i][count][m[prev]] = (fun(i+1, count+2, 'E', s, n) + fun(i+1, count+1, 'W', s, n)) % MOD;
            }
        }
        else if(prev == 'E') {
            if(s[i] == 'E') {
                return dp[i][count][m[prev]] = (fun(i+1, count+2, 'F', s, n) + fun(i+1, count, 'W', s, n)) % MOD;
            }
            else if(s[i] == 'F') {
                return dp[i][count][m[prev]] = (fun(i+1, count+2, 'W', s, n) + fun(i+1, count+1, 'F', s, n)) % MOD;
            }
            else {
                return dp[i][count][m[prev]] = (fun(i+1, count, 'F', s, n) + fun(i+1, count+1, 'W', s, n)) % MOD;
            }
        }
        else {
            if(s[i] == 'E') {
                return dp[i][count][m[prev]] = (fun(i+1, count+2, 'F', s, n) + fun(i+1, count+1, 'E', s, n)) % MOD;
            }
            else if(s[i] == 'F') {
                return dp[i][count][m[prev]] = (fun(i+1, count, 'E', s, n) + fun(i+1, count+1, 'F', s, n)) % MOD;
            }
            else {
                return dp[i][count][m[prev]] = (fun(i+1, count, 'F', s, n) + fun(i+1, count+2, 'E', s, n)) % MOD;
            }
        }
    }
    int countWinningSequences(string s) {
        int n = s.size();
        memset(dp, -1, sizeof(dp));
        m['E'] = 0;
        m['F'] = 1;
        m['W'] = 2;
        if(s[0] == 'F') {
            return (fun(1, 1, 'F', s, n) + fun(1, 0, 'E', s, n) + fun(1, 2, 'W', s, n)) % MOD;
        }
        else if(s[0] == 'E') {
            return (fun(1, 1, 'E', s, n) + fun(1, 0, 'W', s, n) + fun(1, 2, 'F', s, n)) % MOD;
        }
        else {
            return (fun(1, 1, 'W', s, n) + fun(1, 0, 'F', s, n) + fun(1, 2, 'E', s, n)) % MOD;
        }
    }
};",1420586672
anikateKoul,anikateKoul,258,3592,cpp,"#define ll long long
class Solution {
public:
    vector<long long> findXSum(vector<int>& v, int k, int x) {
        map<ll, ll> m;
        int n = v.size();
        vector<ll> ans;

        for(int i = 0; i < k; i++) {
            m[v[i]]++;
        }

        set<pair<ll, ll>> taken, notTaken;

        for(auto it : m) notTaken.insert({it.second, it.first});

        for(int i = 0; i < x; i++) {
            if(notTaken.size() == 0) break;
            pair<ll, ll> p = *(notTaken.rbegin());
            notTaken.erase(p);
            taken.insert(p);
        }

        ll val = 0;
        for(auto it : taken) {
            val += (it.first * it.second);
        }

        ans.push_back(val);

        for(int i = k; i < n; i++) {
            int tmp = v[i-k];
            if(taken.find({m[tmp], tmp}) != taken.end()) {
                taken.erase({m[tmp], tmp});
                taken.insert({m[tmp] - 1, tmp});
                val -= tmp;
            }
            else {
                notTaken.erase({m[tmp], tmp});
                notTaken.insert({m[tmp] - 1, tmp});
            }
            m[tmp]--;

            tmp = v[i];
            if(taken.find({m[tmp], tmp}) != taken.end()) {
                taken.erase({m[tmp], tmp});
                taken.insert({m[tmp] + 1, tmp});
                
                val += tmp;
            }
            else {
                notTaken.erase({m[tmp], tmp});
                notTaken.insert({m[tmp] + 1, tmp});
            }

            m[tmp]++;

            while((notTaken.size() > 0) and (taken.size() < x)) {
                pair<ll, ll> p = *(notTaken.rbegin());
                notTaken.erase(p);
                taken.insert(p);
                val += (p.first * p.second);
            }

            if((taken.size() > 0)  and (notTaken.size() > 0) and ((*(taken.begin())) < (*(notTaken.rbegin())))) {
                pair<ll, ll> p1 = *taken.begin(); 
                pair<ll, ll> p2 = *notTaken.rbegin();
                val -= (p1.first * p1.second);
                val += (p2.first * p2.second);
                
                taken.erase(p1);
                notTaken.erase(p2);
                taken.insert(p2);
                notTaken.insert(p1);
            }

            ans.push_back(val);
        }

        return ans;

    }

};",1420617242
anikateKoul,anikateKoul,258,3610,cpp,"class Solution {
public:
    int fun(vector<int> &v, int k, int x, int i, int j) {
        map<int, int> m;
        for(int ind = i; ind <= j; ind++) {
            m[v[ind]]++;
        }

        priority_queue<pair<int, int>> pq;
        for(auto it : m) {
            pq.push({it.second, it.first});
        }

        int ans = 0;

        while((x--) and (pq.size() > 0)) {
            ans += (pq.top().second * pq.top().first);
            pq.pop();
        }

        return ans;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for(int i = 0; i < nums.size(); i++) {
            if(i+k-1 >= nums.size()) continue;
            ans.push_back(fun(nums, k, x, i, i+k-1));
        }

        return ans;
    }
};",1420523434
pikapika,pikapika123,259,3509,python3,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


from typing import Optional


class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        a = []

        def traversal(node):
            if not node:
                return True, 0
            perfect_left, count_left = traversal(node.left)
            perfect_right, count_right = traversal(node.right)
            perfect = perfect_left and perfect_right and count_left == count_right
            count = count_left + count_right + 1
            if perfect:
                a.append(count)
            return perfect, count

        traversal(root)
        a.sort()
        if len(a) < k:
            return -1
        return a[-k]
",1420530821
pikapika,pikapika123,259,3588,python3,"import functools


class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        d = {
            ""FF"": 0, ""FW"": -1, ""FE"": 1,
            ""WF"": 1, ""WW"": 0, ""WE"": -1,
            ""EF"": -1, ""EW"": 1, ""EE"": 0
        }

        @functools.lru_cache(None)
        def dp(i, pre, point):
            if i == n:
                return 1 if point > 0 else 0
            if point + (n - i) <= 0:
                return 0
            ans = 0
            for c in ""FWE"":
                if c == pre:
                    continue
                k = c + s[i]
                ans = (ans + dp(i + 1, c, point + d[k])) % mod
            return ans

        res = dp(0, """", 0)
        return res",1420576153
pikapika,pikapika123,259,3592,python3,"from typing import List
from sortedcontainers import SortedList
import collections


class Solution:
    def findXSum(self, nums: List[int], k: int, X: int) -> List[int]:
        n = len(nums)
        counter = collections.Counter(nums[:k - 1])
        t1 = SortedList([[-counter[k], -k] for k in counter])
        t2 = SortedList([])
        ans = []
        v = sum(x * q for q, x in t1)
        while len(t1) > X:
            v -= t1[-1][0] * t1[-1][1]
            t2.add(t1.pop())

        for i in range(k - 1, n):
            x = nums[i]
            old = counter.get(x, 0)
            new = old + 1
            if [-old, -x] in t1:
                t1.remove([-old, -x])
                t1.add([-new, -x])
                v += x
            elif len(t1) < X:
                t1.add([-new, -x])
                v += x
            else:
                if [-old, -x] in t2:
                    t2.remove([-old, -x])
                if [-new, -x] >= t1[-1]:
                    t2.add([-new, -x])
                else:
                    last = t1.pop()
                    v -= last[0] * last[1]
                    t1.add([-new, -x])
                    v += new * x
                    t2.add(last)
            counter[x] = new
            ans.append(v)
            y = nums[i - k + 1]
            old = counter[y]
            new = old - 1
            if [-old, -y] in t2:
                t2.remove([-old, -y])
                if new > 0:
                    t2.add([-new, -y])
            else:
                t1.remove([-old, -y])
                if new > 0:
                    t1.add([-new, -y])
                v -= y
                while len(t1) < X and t2:
                    first = t2[0]
                    t2.remove(t2[0])
                    t1.add(first)
                    v += first[0] * first[1]
                if t2 and t2[0] < t1[-1]:
                    first = t2[0]
                    t2.remove(t2[0])
                    last = t1.pop()
                    t1.add(first)
                    t2.add(last)
                    v += first[0] * first[1] - last[0] * last[1]
            counter[y] = new
        return ans",1420617354
pikapika,pikapika123,259,3610,python3,"from typing import List
import collections


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def xSum(arr):
            d = collections.Counter(arr)
            a = sorted([[k, d[k]] for k in d], key=lambda x: [-x[1], -x[0]])
            ans = 0
            for i in range(min(x, len(a))):
                ans += a[i][0] * a[i][1]
            return ans

        n = len(nums)
        res = []
        for i in range(n - k + 1):
            res.append(xSum(nums[i:i + k]))
        return res",1420522183
Anonymous,never_seen,260,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;
        function<pair<int, int>(TreeNode*, int)> dfs = [&](TreeNode* root, int dep){
            if (!root) return pair<int, int>({0, dep});
            auto l = dfs(root->left, dep + 1), r = dfs(root->right, dep + 1);
            int csz = 1 + l.first + r.first;
            int cdep = max(l.second, r.second);
            if (cdep - dep > 20) return pair<int, int>({csz, cdep});
            if (csz == (1 << (cdep - dep)) - 1) ans.push_back(csz);
            return pair<int, int>({csz, cdep});
        };
        dfs(root, 1);
        sort(ans.rbegin(), ans.rend());
        return ans.size() < k ? -1 : ans[k - 1];
    }
};",1420584607
Anonymous,never_seen,260,3588,cpp,"class Solution {
public:
    int dp[1000][2001][4];
    int countWinningSequences(string s) {
        vector<int> a;
        for (auto &e : s){
            if (e == 'F') a.push_back(1);
            else if (e == 'W') a.push_back(2);
            else a.push_back(3);
        }
        set<pair<int, int>> good;
        good.insert({1, 3});
        good.insert({2, 1});
        good.insert({3, 2});
        int n = s.size();
        memset(dp, -1, sizeof dp);
        const int mod = 1e9 + 7;
        function<int(int, int, int)> rec = [&](int i, int j, int k){
            if (i == n) return int(j > 1000);
            int &ans = dp[i][j][k];
            if (~ans) return ans;
            ans = 0;
            for (int p = 1; p <= 3; p++){
                if (p == k) continue;
                int s = good.count({p, a[i]});
                s -= good.count({a[i], p});
                ans += rec(i + 1, j + s, p);
                if (ans >= mod) ans -= mod;
            }
            return ans;
        };
        return rec(0, 1000, 0);
    }
};",1420611898
Anonymous,never_seen,260,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> ans;
        map<int, int> freq;
        for (int i = 0; i < k; i++) freq[nums[i]]++;
        set<pair<int, int>> s, imp;
        for (auto &e : freq) s.insert({-e.second, -e.first});
        long long sum = 0;
        x = min(x, k);
        for (int i = 0; i < x; i++){
            if (s.empty()) break;
            auto it = s.begin();
            sum += it->first * 1LL * it->second;
            imp.insert(*it);
            s.erase(it);
        }
        ans.push_back(sum);
        auto del = [&](int i){
            if (imp.count({-freq[nums[i]], -nums[i]})) sum -= freq[nums[i]] * 1LL * nums[i], imp.erase({-freq[nums[i]], -nums[i]});
            else s.erase({-freq[nums[i]], -nums[i]});
        };
        for (int i = k; i < n; i++){
            del(i - k), freq[nums[i - k]]--;
            if (freq[nums[i - k]]) s.insert({-freq[nums[i - k]], -nums[i - k]});
            if (freq[nums[i]]) del(i);
            freq[nums[i]]++;
            s.insert({-freq[nums[i]], -nums[i]});
            while(!s.empty() and (imp.size() < x or *imp.rbegin() > *s.begin())){
                sum += s.begin()->first * 1LL * s.begin()->second;
                imp.insert(*s.begin()); s.erase(s.begin());
                if (imp.size() > x){
                    auto p = *imp.rbegin();
                    sum -= p.first * 1LL * p.second;
                    s.insert(p),imp.erase(p);
                }
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420570303
Anonymous,never_seen,260,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        map<int, int> freq;
        for (int i = 0; i < k; i++) freq[nums[i]]++;
        set<pair<int, int>> s, imp;
        for (auto &e : freq) s.insert({-e.second, -e.first});
        long long sum = 0;
        x = min(x, k);
        for (int i = 0; i < x; i++){
            if (s.empty()) break;
            auto it = s.begin();
            sum += it->first * 1LL * it->second;
            imp.insert(*it);
            s.erase(it);
        }
        ans.push_back(sum);
        auto del = [&](int i){
            if (imp.count({-freq[nums[i]], -nums[i]})) sum -= freq[nums[i]] * 1LL * nums[i], imp.erase({-freq[nums[i]], -nums[i]});
            else s.erase({-freq[nums[i]], -nums[i]});
        };
        for (int i = k; i < n; i++){
            del(i - k), freq[nums[i - k]]--;
            if (freq[nums[i - k]]) s.insert({-freq[nums[i - k]], -nums[i - k]});
            if (freq[nums[i]]) del(i);
            freq[nums[i]]++;
            s.insert({-freq[nums[i]], -nums[i]});
            while(!s.empty() and (imp.size() < x or *imp.rbegin() > *s.begin())){
                sum += s.begin()->first * 1LL * s.begin()->second;
                imp.insert(*s.begin()); s.erase(s.begin());
                if (imp.size() > x){
                    auto p = *imp.rbegin();
                    sum -= p.first * 1LL * p.second;
                    s.insert(p),imp.erase(p);
                }
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420570919
czjnbb,czjnbb,261,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        def helper(root):
            
            if not root:
                ### lv, num
                return [0, 0]
            l = helper(root.left)
            r = helper(root.right)
            if l[0] >= 0 and l[0] == r[0] and l[1] == r[1]:
                res.append(l[1] + r[1] + 1)
                return [l[0] + 1, l[1] + r[1] + 1]
            
            return [-1, -1]
        
        res = []
        helper(root)
        if len(res) < k:
            return -1
        res.sort()
        return res[-k]
            
            
            
                ",1420531025
czjnbb,czjnbb,261,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        lens = len(s)
        mod = 10**9 + 7
        res = 0
        
        ### F,E,W
        dpf = {}
        dpe = {}
        dpw = {}
        
        if s[0] == 'F':
            dpf[0] = 1
            dpe[-1] = 1
            dpw[1] = 1
        elif s[0] == 'E':
            dpf[1] = 1
            dpe[0] = 1
            dpw[-1] = 1
        else:
            dpf[-1] = 1
            dpe[1] = 1
            dpw[0] = 1
        
        
        for i in range(1, lens):
            a = s[i]
            tmpf = defaultdict(int)
            tmpe = defaultdict(int)
            tmpw = defaultdict(int)
            
            if a == 'F':
                for k,v in dpe.items():
                    tmpf[k] += v
                    tmpw[k+1] += v
                for k,v in dpf.items():
                    tmpe[k-1] += v
                    tmpw[k+1] += v
                for k,v in dpw.items():
                    tmpe[k-1] += v
                    tmpf[k] += v
                    
            elif a == 'E':
                for k,v in dpe.items():
                    tmpf[k+1] += v
                    tmpw[k-1] += v
                for k,v in dpf.items():
                    tmpe[k] += v
                    tmpw[k-1] += v
                for k,v in dpw.items():
                    tmpe[k] += v
                    tmpf[k+1] += v
                    
            else:
                for k,v in dpe.items():
                    tmpf[k-1] += v
                    tmpw[k] += v
                for k,v in dpf.items():
                    tmpe[k+1] += v
                    tmpw[k] += v
                for k,v in dpw.items():
                    tmpe[k+1] += v
                    tmpf[k-1] += v
            
            dpe = tmpe
            dpf = tmpf
            dpw = tmpw
            
        
        for k,v in dpe.items():
            if k > 0:
                res = (res + v) % mod
        
        for k,v in dpf.items():
            if k > 0:
                res = (res + v) % mod
                
        for k,v in dpw.items():
            if k > 0:
                res = (res + v) % mod
            
        return res
            ",1420554160
czjnbb,czjnbb,261,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        from sortedcontainers import SortedList
        
        d = Counter(nums[:k-1])
        res = []
        leng = len(nums)
        
        sl = SortedList()
        
        for k2,v in d.items():
            sl.add((-v, -k2))
        
        if len(sl) <= x:
            cur = sum(nums[:k-1])
        else:
            cur = 0
            for i in range(x):
                cur += sl[i][0] * sl[i][1]
                
                
        for i in range(k-1, leng):
            n = nums[i]
            if n not in d:
                d[n] = 1
            else:
                d[n] += 1
                
            pv = nums[i - k + 1]
            
            nt = (-d[n], -n)
            ps = sl.bisect_left(nt)
            if ps < x:
                cur += n * d[n]
                
                if d[n] > 1:
                    ps2 = sl.bisect_left((-d[n] + 1, -n))
                    if ps2 < x:
                        cur -= n * (d[n] - 1)
                    elif len(sl) >= x:
                        cur -= sl[x-1][0] * sl[x-1][1]
                
                    # sl.remove((-d[n] + 1, -n))
                
                elif len(sl) >= x:
                    cur -= sl[x-1][0] * sl[x-1][1]
            
            if d[n] > 1:
                sl.remove((-d[n] + 1, -n))
            
                
            sl.add(nt)
            # print(sl)
            res.append(cur)
            
            pt = (-d[pv], -pv)
            d[pv] -= 1
            
            sl.remove(pt)
            ps3 = sl.bisect_left(pt)
            
            if ps3 < x:
                cur -= pt[0] * pt[1]
                
                if d[pv] > 0:
                    nt2 = (-d[pv], -pv)
                    ps4 = sl.bisect_left(nt2)
                    # print(nt2, ps4, sl)
                    if ps4 < x:
                        cur += nt2[0] * nt2[1]
                    elif len(sl) >= x:
                        cur += sl[x-1][0] * sl[x-1][1]
                        
                    # sl.add(nt2)
                    
                elif len(sl) >= x:
                    cur += sl[x-1][0] * sl[x-1][1]
                    
            if d[pv] > 0:
                nt2 = (-d[pv], -pv)
                sl.add(nt2)
                    
            
        return res
                
                
        
        
        ",1420618293
czjnbb,czjnbb,261,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        d = Counter(nums[:k-1])
        res = []
        leng = len(nums)
        
        for i in range(k-1, leng):
            n = nums[i]
            d[n] += 1
            pv = nums[i - k + 1]
            
            if len(d) <= x:
                res.append(sum([k2*v for k2,v in d.items()]))
                d[pv] -= 1
                if d[pv] == 0:
                    del d[pv]
                
                continue
            
            ans = 0
            tmp = list(d.items())
            tmp.sort(key = lambda x: (x[1], x[0]), reverse = True)
            for k2,v in tmp[:x]:
                ans += k2 * v
                
            res.append(ans)
            d[pv] -= 1
            if d[pv] == 0:
                del d[pv]
                
        return res",1420522955
lucasomee006,lucasomee006,262,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        #so a perfect binary tree is only perfect if both its subtrees are perfect and have the same depth
        sizes = []
        @cache
        def isPerfect(node):
            

            if node is None:
                return 0
            isPerfect(node.right)
            isPerfect(node.left)
            if (isPerfect(node.right) == -1 or isPerfect(node.left) == -1) or (isPerfect(node.right) != isPerfect(node.left)):
                # print(node.val, isPerfect(node.right), isPerfect(node.left))
                return -1
            elif isPerfect(node.right) == isPerfect(node.left):
                
                # sizes.append(2**(isPerfect(node.right))+1 if isPerfect(node.right) > 0 else 1)
                sizes.append(2**(isPerfect(node.right)+1)-1)
                # print(node.val, 2**(isPerfect(node.right))+1)
                return isPerfect(node.right)+1 
            else:
                return -1
        isPerfect(root)
        sizes.sort(reverse=True)
        # print(sizes)
        if k <= len(sizes):
            return sizes[k-1]
        return -1
            ",1420538856
lucasomee006,lucasomee006,262,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        #Fire, Water, Earth
        #fire beats earth, water beats fire, earth beats water
        #so for each one Bob can either get a point, lose a point or no points
        #dp[i][j] = num ways (mod 1e9+7) to get that number of points past a certain number of moves
        waterWins = {""F"": -1, ""W"": 0, ""E"": 1}
        earthWins = {""F"": 1, ""W"": -1, ""E"": 0}
        fireWins = {""F"": 0, ""W"": 1, ""E"": -1}
        matches = {""F"": fireWins, ""W"": waterWins, ""E"": earthWins}
        ans = 0
        p = 10**9 + 7
        @cache
        def dp(i, points, usedLast):
            if i >= len(s):
                if points > 0:
                    print(usedLast)
                    return 1
                return 0
            numWays = 0
            
            for choice in matches[s[i]]:
                if choice != usedLast:
                    numWays += dp(i+1, points + matches[s[i]][choice], choice)
                    numWays %= p
            return numWays
        # print(dp(1, -1, ""E""))
        # print(dp(1, 1))
        return dp(0, 0, ""-1"")
            

",1420559131
lucasomee006,lucasomee006,262,3592,python3,"from sortedcontainers import SortedList
from collections import defaultdict
class Solution:
    def findXSum(self, nums: List[int], windowLen: int, k: int) -> List[int]:
        #probably some sort of sliding window
        #sortedList of the most common ones?
        #and then just add as you go across?
        #so you're going to keep track of the current k most common in a SortedList (which also includes the rest)
        #tuple storing frequency and highest element
        #and then, for each num you add and remove you're going to keep track of where you're putting it
        curSum = 0
        d = defaultdict(int)
        for i in range(windowLen):
            d[nums[i]] += 1
        temp = [[-d[i], -i] for i in d]
        temp.sort()
        s = SortedList(temp)
        indices = {-i[1]: i for i in s}
        # print(temp)
        curSum = sum([temp[i][0]*temp[i][1] for i in range(min(k, len(temp)))])
        ans = [curSum]
        # print(s)
        for r in range(windowLen, len(nums)):#inclusive index
            
            oldL = r - windowLen
            oldPos = s.index(indices[nums[oldL]])
            
            oldFreqArr = s[oldPos]
            s.remove(oldFreqArr)
            oldFreqArr[0] += 1
            s.add(oldFreqArr)
            newPos = s.index(oldFreqArr)
            if oldPos < k and newPos < k:
                curSum -= -oldFreqArr[1]
            elif oldPos >= k:
                ignore = 0
            elif newPos >= k:
                curSum -= (-oldFreqArr[0]+1)*(-oldFreqArr[1])
                curSum += s[k-1][0]*s[k-1][1]

            if nums[r] in indices:
                oldPos = s.index(indices[nums[r]])

                oldFreqArr = s[oldPos]
                print(nums[r], oldFreqArr)
                s.remove(oldFreqArr)
                oldFreqArr[0] -= 1
                s.add(oldFreqArr)
                newPos = s.index(oldFreqArr)
                if oldPos < k and newPos < k:
                    curSum -= oldFreqArr[1]
                    # print(curSum)
                elif oldPos >= k and newPos >= k:
                    ignore = 0
                    # print(""this"")
                elif newPos >= k:
                    curSum -= (-oldFreqArr[0]+1)*(-oldFreqArr[1])
                    curSum += s[k-1][0]*s[k-1][1]
                elif oldPos >= k and newPos < k:
                    curSum += (oldFreqArr[0])*(oldFreqArr[1])
                    curSum -= s[k][0]*s[k][1]
                    
            else:
                indices[nums[r]] = [-1, -nums[r]]
                s.add(indices[nums[r]])
                newPos = s.index(indices[nums[r]])
                if newPos < k:
                    curSum += nums[r]
                    if len(s) > k:
                        curSum -= s[k][0]*s[k][1]
                
            
            # print(s)
            ans.append(curSum)
        return ans
            
            


",1420613735
lucasomee006,lucasomee006,262,3610,python3,"from collections import defaultdict
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        for start in range(len(nums)-k+1):
            d = defaultdict(int)
            for i in range(start, start+k):
                d[nums[i]] += 1
            
            y = [(d[i], i) for i in d]
            y.sort(reverse=True)
            # print(y)
            s = 0
            for i in range(min(x, len(y))):
                # print(i)
                s += y[i][0]*y[i][1]
            
            ans.append(s)
        return ans",1420524507
HFDnpkp1cs,HFDnpkp1cs,263,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sz;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sz.rbegin(), sz.rend());
        if(sz.size() < k)
            return -1;
        
        int dep = sz[k - 1];
        return (1ll << dep) - 1;
    }

    int dfs(TreeNode* node) {
        if(node == nullptr)
            return 0;
        
        int l = dfs(node->left);
        int r = dfs(node->right);
        if(l == -1 || r == -1 || l != r)
            return -1;
        
        sz.push_back(l + 1);
        return l + 1;
    }
};",1420521683
HFDnpkp1cs,HFDnpkp1cs,263,3588,cpp,"using ll = long long;
ll mod = 1e9 + 7;

ll dp[1010][2010][3];

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        vector<int> v(n);
        for(int i = 0; i < n; i++) {
            if(s[i] == 'F')
                v[i] = 0;
            else if(s[i] == 'E')
                v[i] = 1;
            else
                v[i] = 2;
        }

        memset(dp, 0, sizeof(dp));
        for(int k = 0; k < 3; k++) {
            int i = n - 1;
            if((k + 1) % 3 == v[i]) {
                // win
                dp[i][1006][k] = 1;
            }
            else if(k == v[i]) {
                // tie
                dp[i][1005][k] = 1;
            }
            else {
                dp[i][1004][k] = 1;
            }
        }


        for(int i = n - 2; i >= 0; i--) {
            for(int j = 2005; j >= 0; j--) {
                for(int k = 0; k < 3; k++) {
                    if((k + 1) % 3 == v[i]) {
                        // win
                        if(j - 1 >= 0)
                            dp[i][j][k] = (dp[i + 1][j - 1][(k + 1) % 3] + dp[i + 1][j - 1][(k + 2) % 3]) % mod;
                    }
                    else if(k == v[i]) {
                        // tie
                        dp[i][j][k] = (dp[i + 1][j][(k + 1) % 3] + dp[i + 1][j][(k + 2) % 3]) % mod;
                    }
                    else {
                        // lose
                        dp[i][j][k] = (dp[i + 1][j + 1][(k + 1) % 3] + dp[i + 1][j + 1][(k + 2) % 3]) % mod;
                    }
                }
            }
        }

        ll ret = 0;
        for(ll j = 1006; j < 2010; j++) {
            for(ll k = 0; k < 3; k++) {
                // cout << j << "" "" << k << "": "" << dp[0][j][k] << endl;
                ret = (ret + dp[0][j][k]) % mod;
            }
        }
        return ret;

    }
};",1420546305
HFDnpkp1cs,HFDnpkp1cs,263,3592,cpp,"using ll = long long;

class Solution {
public:
    set<pair<ll, ll>> left;
    set<pair<ll, ll>> right;
    unordered_map<ll, ll> mp;
    ll x;
    ll sum;
    vector<long long> findXSum(vector<int>& nums, int k, int xx) {
        ll n = nums.size();
        x = xx;
        sum = 0;

        vector<ll> ret;
        ret.reserve(n);
        for(int i = 0; i < n; i++) {
            if(i >= k && nums[i] == nums[i - k]) {
                ret.push_back(ret.back());
                continue;
            }

            if(i >= k)
                remove(nums[i - k]);

            insert(nums[i]);
            if(i >= k - 1) {
                ret.push_back(sum);
            }
        }
        return ret;
    }

    void insert(ll num) {
        mp[num]++;
        ll ocnt = mp[num] - 1;
        ll cnt = mp[num];

        auto remove = make_pair(ocnt, num);
        auto add = make_pair(cnt, num);

        process(add, remove);
    }

    void remove(ll num) {
        mp[num]--;
        ll ocnt = mp[num] + 1;
        ll cnt = mp[num];

        auto remove = make_pair(ocnt, num);
        auto add = make_pair(cnt, num);

        process(add, remove);
    }

    void process(pair<ll, ll>& add, pair<ll, ll>& remove) {

        // remove
        if(remove.first > 0) {
            auto itr = right.find(remove);
            auto itl = left.find(remove);
            if(itl != left.end()) {
                left.erase(itl);
            }
            else if(itr != right.end()) {
                right.erase(itr);
                sum -= remove.first * remove.second;

                if(!left.empty()) {
                    auto it = prev(left.end());
                    right.insert(*it);
                    sum += it->first * it->second;
                    left.erase(it);
                }
            }
        }

        // add
        if(add.first > 0) {
            if(right.size() < x) {
                right.insert(add);
                sum += add.first * add.second;
            }
            else if(add > *right.begin()) {
                right.insert(add);
                sum += add.first * add.second;
                auto it = right.begin();
                sum -= it->first * it->second;
                left.insert(*it);
                right.erase(it);
            }
            else {
                left.insert(add);
            }
        }
    }
};",1420607950
HFDnpkp1cs,HFDnpkp1cs,263,3610,cpp,"using ll = long long;

class Solution {
public:
    set<pair<ll, ll>> left;
    set<pair<ll, ll>> right;
    unordered_map<ll, ll> mp;
    ll x;
    ll sum;
    vector<int> findXSum(vector<int>& nums, int k, int xx) {
        ll n = nums.size();
        x = xx;
        sum = 0;

        vector<int> ret;
        for(int i = 0; i < n; i++) {
            insert(nums[i]);
            if(i >= k - 1) {
                ret.push_back(sum);
                remove(nums[i - (k - 1)]);
            }
        }
        return ret;
    }

    void insert(ll num) {
        mp[num]++;
        int ocnt = mp[num] - 1;
        int cnt = mp[num];

        auto remove = make_pair(ocnt, num);
        auto add = make_pair(cnt, num);
        auto itr = right.find(remove);
        auto itl = left.find(remove);
        if(itr == right.end() && itl == left.end()) {
            right.insert(add);
            sum += add.first * add.second;
        }
        else if(itr == right.end()) {
            left.erase(itl);
            left.insert(add);
        }
        else {
            right.erase(itr);
            sum -= remove.first * remove.second;
            right.insert(add);
            sum += add.first * add.second;
        }

        balance();
    }

    void remove(ll num) {
        mp[num]--;
        int ocnt = mp[num] + 1;
        int cnt = mp[num];

        auto remove = make_pair(ocnt, num);
        auto add = make_pair(cnt, num);
        auto itr = right.find(remove);
        auto itl = left.find(remove);
        if(itr == right.end() && itl == left.end()) {
            right.insert(add);
            sum += add.first * add.second;
        }
        else if(itr == right.end()) {
            left.erase(itl);
            left.insert(add);
        }
        else {
            right.erase(itr);
            sum -= remove.first * remove.second;
            right.insert(add);
            sum += add.first * add.second;
        }
        
        balance();
    }

    void balance() {
        int szl = left.size(), szr = right.size();
        while(!left.empty() && (right.empty() || *left.rbegin() > *right.begin())) {
            auto it = prev(left.end());
            right.insert({it->first, it->second});
            sum += it->first * it->second;
            left.erase(it);
        }

        while(right.size() < x && !left.empty()) {
            auto it = prev(left.end());
            right.insert({it->first, it->second});
            sum += it->first * it->second;
            left.erase(it);
        }

        while(right.size() > x) {
            auto it = right.begin();
            left.insert({it->first, it->second});
            sum -= it->first * it->second;
            right.erase(it);
        }

        // cout << left.size() << "" "" << right.size() << "" "" << sum << endl;
    }
};",1420578583
Monojit Tewari,Mj13,264,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct SubtreeInfo {
        bool isPerfect;
        int height;
        int size;
    };

    vector<int> sizes;

    SubtreeInfo dfs(TreeNode* node) {
        if (!node) {
            return {true, 0, 0};
        }

        SubtreeInfo left = dfs(node->left);
        SubtreeInfo right = dfs(node->right);

        bool isPerfect = left.isPerfect && right.isPerfect && (left.height == right.height);
        int height = max(left.height, right.height) + 1;
        int size = left.size + right.size + 1;

        if (isPerfect) {
            sizes.push_back(size);
        }

        return {isPerfect, height, size};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        dfs(root);

        if (sizes.size() < k) {
            return -1;
        }

        sort(sizes.begin(), sizes.end(), greater<int>());

        return sizes[k - 1];
    }
};",1420535748
Monojit Tewari,Mj13,264,3588,cpp,"const int MOD = 1e9 + 7;
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        vector<int> alice_moves(n);
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') alice_moves[i] = 0;
            else if (s[i] == 'W') alice_moves[i] = 1;
            else if (s[i] == 'E') alice_moves[i] = 2;
        }
        string lufrenixaq = s;
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, 0)));
        int offset = n;

        dp[0][0][offset] = 1;

        for (int i = 0; i < n; ++i) {
            for (int p_idx = 0; p_idx <= 3; ++p_idx) {
                int p = p_idx - 1;
                for (int d = 0; d <= 2 * n; ++d) {
                    if (dp[i][p_idx][d] == 0) continue;
                    for (int m = 0; m <= 2; ++m) {
                        if (p != -1 && m == p) continue;
                        int m_idx = m + 1;
                        int a = alice_moves[i];
                        int b = m;
                        int result = (b - a + 3) % 3;
                        int delta = 0;
                        if (result == 1) delta = 1;
                        else if (result == 2) delta = -1;
                        int d_new = d + delta;
                        if (d_new < 0 || d_new > 2 * n) continue;
                        dp[i + 1][m_idx][d_new] = (dp[i + 1][m_idx][d_new] + dp[i][p_idx][d]) % MOD;
                    }
                }
            }
        }

        int total = 0;
        for (int p_idx = 1; p_idx <= 3; ++p_idx) {
            for (int d = offset + 1; d <= 2 * n; ++d) {
                total = (total + dp[n][p_idx][d]) % MOD;
            }
        }
        return total;
    }
};",1420539580
Monojit Tewari,Mj13,264,3592,cpp,"#include <iostream>
#include <vector>
#include <unordered_map>
#include <cstdlib>
#include <ctime>
using namespace std;

struct Node {
    int freq;
    int val;
    int priority;
    Node* left;
    Node* right;
    int size;
    long long sum;

    Node(int f, int v) : freq(f), val(v), priority(rand()), left(nullptr), right(nullptr), size(1), sum((long long)f * v) {}
};

int getSize(Node* node) {
    return node ? node->size : 0;
}

long long getSum(Node* node) {
    return node ? node->sum : 0;
}

void update(Node* node) {
    if (node) {
        node->size = 1 + getSize(node->left) + getSize(node->right);
        node->sum = (long long)node->freq * node->val + getSum(node->left) + getSum(node->right);
    }
}

// Split the treap into left and right treaps where all keys in left <= key, and all keys in right > key
void split(Node* node, pair<int, int> key, Node*& left, Node*& right) {
    if (!node) {
        left = right = nullptr;
    } else if (make_pair(-node->freq, -node->val) <= key) {
        split(node->right, key, node->right, right);
        left = node;
    } else {
        split(node->left, key, left, node->left);
        right = node;
    }
    update(node);
}

// Merges two treaps
Node* merge(Node* left, Node* right) {
    if (!left || !right)
        return left ? left : right;
    if (left->priority > right->priority) {
        left->right = merge(left->right, right);
        update(left);
        return left;
    } else {
        right->left = merge(left, right->left);
        update(right);
        return right;
    }
}

// Insert a node into the treap
Node* insert(Node* root, Node* node) {
    if (!root)
        return node;
    if (node->priority > root->priority) {
        split(root, make_pair(-node->freq, -node->val), node->left, node->right);
        update(node);
        return node;
    } else if (make_pair(-node->freq, -node->val) < make_pair(-root->freq, -root->val)) {
        root->left = insert(root->left, node);
    } else {
        root->right = insert(root->right, node);
    }
    update(root);
    return root;
}

// Erase a node from the treap
Node* erase(Node* root, pair<int, int> key) {
    if (!root)
        return nullptr;
    if (make_pair(-root->freq, -root->val) == key) {
        Node* temp = merge(root->left, root->right);
        delete root;
        return temp;
    } else if (key < make_pair(-root->freq, -root->val)) {
        root->left = erase(root->left, key);
    } else {
        root->right = erase(root->right, key);
    }
    update(root);
    return root;
}

// Get sum of the top x elements
long long query(Node* root, int x) {
    if (!root || x <= 0)
        return 0;
    int leftSize = getSize(root->left);
    if (leftSize >= x) {
        return query(root->left, x);
    } else {
        long long res = getSum(root->left) + (long long)root->freq * root->val;
        int remaining = x - leftSize - 1;
        if (remaining > 0)
            res += query(root->right, remaining);
        return res;
    }
}

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<int> torsalveno = nums; // Variable as per problem statement

        int n = nums.size();
        vector<long long> answer;
        unordered_map<int, int> counts; // Counts of elements
        Node* root = nullptr; // Treap root

        srand(time(0)); // Seed for random priority

        // Initialize counts and treap for the first window
        for (int i = 0; i < k; ++i) {
            int elem = nums[i];
            int old_freq = counts[elem];
            if (old_freq > 0) {
                // Remove old frequency
                root = erase(root, make_pair(-old_freq, -elem));
            }
            counts[elem]++;
            int new_freq = counts[elem];
            root = insert(root, new Node(new_freq, elem));
        }
        answer.push_back(query(root, x));

        // Slide the window
        for (int i = k; i < n; ++i) {
            // Remove the outgoing element
            int out_elem = nums[i - k];
            int old_freq = counts[out_elem];
            root = erase(root, make_pair(-old_freq, -out_elem));
            counts[out_elem]--;
            if (counts[out_elem] > 0) {
                int new_freq = counts[out_elem];
                root = insert(root, new Node(new_freq, out_elem));
            } else {
                counts.erase(out_elem);
            }

            // Add the incoming element
            int in_elem = nums[i];
            int old_freq_in = counts[in_elem];
            if (old_freq_in > 0) {
                root = erase(root, make_pair(-old_freq_in, -in_elem));
            }
            counts[in_elem]++;
            int new_freq_in = counts[in_elem];
            root = insert(root, new Node(new_freq_in, in_elem));

            // Compute x-sum for the current window
            answer.push_back(query(root, x));
        }

        // Clean up the Treap (optional)
        // Note: In practice, you should delete all nodes to avoid memory leaks.

        return answer;
    }
};
",1420620481
Monojit Tewari,Mj13,264,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;

        for (int i = 0; i <= n - k; ++i) {
            unordered_map<int, int> freq;
            for (int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }
            vector<pair<int, int>> elements;
            for (auto& p : freq) {
                elements.push_back({p.first, p.second});
            }
            sort(elements.begin(), elements.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.second != b.second) return a.second > b.second;
                return a.first > b.first;
            });
            unordered_map<int, bool> topElements;
            int count = 0;
            for (auto& p : elements) {
                if (count >= x) break;
                topElements[p.first] = true;
                count++;
            }
            int sum = 0;
            for (int j = i; j < i + k; ++j) {
                if (topElements.find(nums[j]) != topElements.end()) {
                    sum += nums[j];
                }
            }
            answer.push_back(sum);
        }
        return answer;
    }
};",1420531243
yu46656,yu46656,265,3509,cpp,"class Solution {
public:
    int F(std::vector<int>& dst, TreeNode* n) {
        if (n == nullptr) { return 0; }

        int kl{ F(dst, n->left) };
        int kr{ F(dst, n->right) };

        int kn{ -1 };

        if (0 <= kl && kl == kr) {
            kn = kl + kr + 1;
            dst.push_back(kn);
        }

        return kn;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        --k;

        std::vector<int> vec;

        F(vec, root);

        if (vec.size() <= k) { return -1; }

        auto mid{ vec.begin() + (vec.size() - 1 - k) };

        std::nth_element(vec.begin(), mid, vec.end());

        return *mid;
    }
};
",1420562520
yu46656,yu46656,265,3588,cpp,"class Solution {
public:
    static constexpr long long M{ 1000000007 };

    int countWinningSequences(std::string str) {
        int n{ static_cast<int>(str.size()) };

        int lb{ -n };
        int rb{ n };

        std::vector<std::vector<long long>> dp[4];
        dp[0].resize(n + 1);
        dp[1].resize(n + 1);
        dp[2].resize(n + 1);
        dp[3].resize(n + 1);

        for (int i{ 0 }; i <= n; ++i) {
            dp[0][i].resize(rb - lb + 1, 0);
            dp[1][i].resize(rb - lb + 1, 0);
            dp[2][i].resize(rb - lb + 1, 0);
            dp[3][i].resize(rb - lb + 1, 0);
        }

        dp[3][0][0 - lb] = 1;

        char point_incs[]{ 'E', 'F', 'W' };
        char point_decs[]{ 'W', 'E', 'F' };

        for (int i{ 1 }; i <= n; ++i) {
            for (int k{ 0 }; k < 3; ++k) {
                for (int j{ lb }; j <= rb; ++j) {
                    int point_diff{ 0 };

                    if (point_incs[k] == str[i - 1]) {
                        point_diff = 1;
                    } else if (point_decs[k] == str[i - 1]) {
                        point_diff = -1;
                    }

                    long long ans{ 0 };

                    for (int k_{ 0 }; k_ < 4; ++k_) {
                        if (k == k_) { continue; }

                        if (lb <= j - point_diff && j - point_diff <= rb) {
                            ans =
                                (ans + dp[k_][i - 1][j - point_diff - lb]) % M;
                        }
                    }

                    dp[k][i][j - lb] = ans;
                }
            }
        }

        long long ret{ 0 };

        for (int j{ 1 }; j <= rb; ++j) {
            ret = (ret + dp[0][n][j - lb]) % M;
            ret = (ret + dp[1][n][j - lb]) % M;
            ret = (ret + dp[2][n][j - lb]) % M;
        }

        return ret;
    }
};
",1420596908
yu46656,yu46656,265,3592,cpp,"class Solution {
public:
    std::vector<long long> findXSum(std::vector<int>& nums, int k, int x) {
        int n{ static_cast<int>(nums.size()) };

        std::unordered_map<long long, long long> freqs;

        std::set<std::pair<long long, long long>> sa;
        std::set<std::pair<long long, long long>> sb;

        std::vector<long long> ret;
        ret.reserve(n - k + 1);

        long long ans{ 0 };

        for (int i{ 0 }; i < n; ++i) {
            long long cur{ nums[i] };

            if (k <= i) {
                long long prv{ nums[i - k] };

                if (cur == prv && k - 1 <= i) {
                    ret.push_back(ans);
                    continue;
                }

                long long prv_freq{ freqs[prv] };
                freqs.erase(prv);

                std::pair<long long, long long> p{ prv_freq, prv };

                sa.erase(p);

                if (0 < sb.erase(p)) { ans -= prv * prv_freq; }

                if (0 < --prv_freq) {
                    freqs.insert({ prv, prv_freq });
                    sa.insert({ prv_freq, prv });
                }
            }

            auto iter{ freqs.insert({ cur, 0 }).first };

            if (0 < iter->second) {
                sa.erase({ iter->second, cur });

                if (0 < sb.erase({ iter->second, cur })) {
                    ans -= cur * iter->second;
                }
            }

            ++iter->second;

            sa.insert({ iter->second, cur });

            while (!sa.empty() && sb.size() < x) {
                auto jter{ sa.rbegin() };

                ans += jter->first * jter->second;

                sb.insert(*jter);
                sa.erase(*jter);
            }

            while (!sa.empty() && !sb.empty() && *sb.begin() < *sa.rbegin()) {
                auto ater{ sa.rbegin() };
                auto bter{ sb.begin() };

                ans += ater->first * ater->second;
                ans -= bter->first * bter->second;

                sb.insert(*ater);
                sa.erase(*ater);

                sa.insert(*bter);
                sb.erase(bter);
            }

            if (k - 1 <= i) { ret.push_back(ans); }
        }

        return ret;
    }
};
",1420602996
yu46656,yu46656,265,3610,cpp,"class Solution {
public:
    std::vector<int> findXSum(std::vector<int>& nums, int k, int x) {
        int n{ static_cast<int>(nums.size()) };

        std::unordered_map<int, int> freqs;

        std::set<std::pair<int, int>> sa;
        std::set<std::pair<int, int>> sb;

        std::vector<int> ret;
        ret.reserve(n - k + 1);

        int ans{ 0 };

        for (int i{ 0 }; i < n; ++i) {
            if (k <= i) {
                int prv{ nums[i - k] };

                int prv_freq{ freqs[prv] };
                freqs.erase(prv);

                std::pair<int, int> p{ prv_freq, prv };

                sa.erase(p);

                if (0 < sb.erase(p)) { ans -= prv * prv_freq; }

                if (0 < --prv_freq) {
                    freqs.insert({ prv, prv_freq });
                    sa.insert({ prv_freq, prv });
                }
            }

            int cur{ nums[i] };

            auto iter{ freqs.insert({ cur, 0 }).first };

            if (0 < iter->second) {
                sa.erase({ iter->second, cur });

                if (0 < sb.erase({ iter->second, cur })) {
                    ans -= cur * iter->second;
                }
            }

            ++iter->second;

            sa.insert({ iter->second, cur });

            while (!sa.empty() && !sb.empty() && *sb.begin() < *sa.rbegin()) {
                auto jter{ sb.begin() };

                ans -= jter->first * jter->second;
                sa.insert(*jter);
                sb.erase(jter);
            }

            while (!sa.empty() && sb.size() < x) {
                auto jter{ sa.rbegin() };

                ans += jter->first * jter->second;

                sb.insert(*jter);
                sa.erase(*jter);
            }

            if (k - 1 <= i) { ret.push_back(ans); }
        }

        return ret;
    }
};
",1420551828
manas agarwal,manasagarwal12921,266,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 int dfs(TreeNode* root,vector<int>&res){
    if(root==NULL)
    return 0;
    if(root->left==NULL&&root->right==NULL){
        res.push_back(1);
        return 1;
    }
    int rt=dfs(root->right,res);
    int lf=dfs(root->left,res);
    if(rt==lf&&rt!=-1){
        res.push_back(rt+lf+1);
        return rt+lf+1;
    }
    else
    return -1;
 }
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int>res;
        dfs(root,res);
        sort(res.begin(),res.end());
        int n=res.size();
       
        if(res.size()<k)
        return -1;
        else
        return res[n-k]; 
    }
};",1420543245
manas agarwal,manasagarwal12921,266,3588,cpp,"class Solution {
public:
    long long memo(string &s,int n,int i,int win,int prev, vector<vector<vector<long long> > >&dp,map<char,int>&mp){
        if(win+n-i<=n)
        return 0;
        if(i==n&&win>n)
        return 1;
        if(i==n)
        return 0;
        if(dp[i][win][prev]!=-1)
        return dp[i][win][prev];
        long long ans=0;
        for(int j=0;j<3;j++){
            if(prev==j)
            continue;
            int c=mp[s[i]];
            long long mod=1e9+7;
            
            if(c==j){
                ans+=memo(s,n,i+1,win,j,dp,mp);
                ans%=mod;
            }
            else if((c+1)%3==j)
            {
                ans+=memo(s,n,i+1,win+1,j,dp,mp);
                ans%=mod;
            }
            else{
                ans+=memo(s,n,i+1,win-1,j,dp,mp);
                ans%=mod;
            }
        }
        return dp[i][win][prev]=ans;
    }
    int countWinningSequences(string s) {
        int n=s.size();
        vector<vector<vector<long long> > >dp(n+1,vector<vector<long long> >(2*n+1,vector<long long>(4,-1)));
        map<char,int>mp;
        mp['F']=0;
        mp['W']=1;
        mp['E']=2;
        mp['A']=-1;
        return memo(s,n,0,n,3,dp,mp);
    }
};",1420575444
manas agarwal,manasagarwal12921,266,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& num, int k, int x) {
        
     int n=num.size();
     vector<long long>nums(n,0);
     for(int i=0;i<n;i++)
     nums[i]=num[i];
     set<pair<long long,long long> >ch;
     set<pair<long long,long long> >nch;
    map<long long,long long>mp;
    for(int i=0;i<n;i++)
    mp[nums[i]]=0;
    for(int i=0;i<k;i++)
    mp[nums[i]]++;
    long long sum=0;
    vector<long long>ans(n-k+1,0);
    for(auto a:mp){
        ch.insert({a.second,a.first});
        sum+=a.second*a.first;
    }
    while(ch.size()>x){
        long long a=ch.begin()->first;
        long long b=ch.begin()->second;
        sum-=a*b;
        nch.insert({a,b});
        ch.erase(ch.begin());
    }
    ans[0]=sum;
    for(int i=k;i<n;i++){
        if(ch.find({mp[nums[i-k]],nums[i-k]})!=ch.end()){
            ch.erase({mp[nums[i-k]],nums[i-k]});
            mp[nums[i-k]]--;
            sum-=nums[i-k];
            ch.insert({mp[nums[i-k]],nums[i-k]});
        }
        else{
            nch.erase({mp[nums[i-k]],nums[i-k]});
            mp[nums[i-k]]--;
            nch.insert({mp[nums[i-k]],nums[i-k]});
        }
        if(ch.find({mp[nums[i]],nums[i]})!=ch.end()){
            ch.erase({mp[nums[i]],nums[i]});
            mp[nums[i]]++;
             sum+=nums[i];
            ch.insert({mp[nums[i]],nums[i]});
        }
        else{
            nch.erase({mp[nums[i]],nums[i]});
            mp[nums[i]]++;
            nch.insert({mp[nums[i]],nums[i]});
        }
        while(!ch.empty()&&!nch.empty()&&(*ch.begin())<(*nch.rbegin())){
            auto p=*ch.begin();
            auto q=*prev(nch.end());
            sum-=p.first*p.second;
            sum+=q.first*q.second;
            ch.erase(ch.begin());
            nch.erase(prev(nch.end()));
            ch.insert(q);
            nch.insert(p);
        }
        ans[i-k+1]=sum;
    }
    return ans;
    }
};",1420609499
manas agarwal,manasagarwal12921,266,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        set<pair<int,int> >st;
        map<int,int>mp;
        for(int i=0;i<k;i++){
            mp[nums[i]]++;
        }
        
        for(auto y:mp){
            st.insert({y.second,y.first});
        }
        int counter=0;
        vector<int>ans(n-k+1,0);
        while(counter<x&&!st.empty()){
            ans[0]+=(st.rbegin()->first)*(st.rbegin()->second);
            counter++;
            st.erase(prev(st.end()));
        }
        st.clear();
        for(int i=1;i<n-k+1;i++){
            mp[nums[i-1]]--;
            mp[nums[i+k-1]]++;
            for(auto y :mp){
                st.insert({y.second,y.first});
            }
            counter=0;
            while(counter<x&&!st.empty()){
                ans[i]+=(st.rbegin()->first)*(st.rbegin()->second);
                counter++;
                st.erase(prev(st.end()));
            }
            st.clear();
        }
        return ans;
    }
};",1420529785
Max Chang,BreadMuMu,269,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.rootLevels = defaultdict(list)
        self.rootSize = defaultdict(int)
        self.dfs(root, 0)
        self.dfs2(root)
        
        result = []
        for node, levels in self.rootLevels.items():
            prev = -1
            ok = True
            for lv in levels:
                if prev == -1:
                    prev = lv
                else:
                    if prev != lv:
                        ok = False
                        break
            if levels and ok:
                result.append(self.rootSize[node])
        
        result.sort(reverse=True)
        if len(result) < k:
            return -1
        return result[k-1]
    
    
    def dfs2(self, node):
        if node is None:
            return 0
        
        left = self.dfs2(node.left)
        right = self.dfs2(node.right)
        self.rootSize[node] = left + right + 1
        return left + right + 1
        
        
    def dfs(self, node, level):
        if node is None:
            return []
        
        llevels = self.dfs(node.left, level+1)
        rlevels = self.dfs(node.right, level+1)
    
    
        if not node.left and not node.right:
            self.rootLevels[node].append(level)
            return [level]
        if not node.left or not node.right:
            return []
        
        if not llevels or not rlevels:
            return []
        
        for lv in llevels:
            self.rootLevels[node].append(lv)
        for lv in rlevels:
            self.rootLevels[node].append(lv)
        return self.rootLevels[node]",1420554287
Max Chang,BreadMuMu,269,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def dfs(i, prev, score):
            if i == len(s):
                return score > 0
            if score + len(s)-i <= 0:
                return 0
            
            answer = 0
            for c in ['F', 'W', 'E']:
                if c == prev: continue
                w = self.whoWin(s[i], c)
                answer = (answer + dfs(i+1, c, score+w)) % 1000000007
            return answer
        
        return dfs(0, """", 0)

    def whoWin(self, c1, c2):
        if c1 == c2:
            return 0
        
        if c1 == 'F' and c2 == 'E':
            return -1
        
        if c1 == 'W' and c2 == 'F':
            return -1
        
        if c1 == 'E' and c2 == 'W':
            return -1
        
        if c2 == 'F' and c1 == 'E':
            return 1
        
        if c2 == 'W' and c1 == 'F':
            return 1
        
        if c2 == 'E' and c1 == 'W':
            return 1
        return 0
        
        ",1420575058
Max Chang,BreadMuMu,269,3592,python3,"class TreapNode:
    def __init__(self, key, count, value):
        self.key = key
        self.left = None
        self.right = None
        self.priority = randint(1, 1 << 30)
        self.count = count
        self.value = value
        self.size = 1
        self.sum = count * value

def update(node):
    if node:
        node.size = 1
        node.sum = node.count * node.value
        if node.left:
            node.size += node.left.size
            node.sum += node.left.sum
        if node.right:
            node.size += node.right.size
            node.sum += node.right.sum

def split(node, key):
    if not node:
        return (None, None)
    if node.key < key:
        l, r = split(node.right, key)
        node.right = l
        update(node)
        return (node, r)
    else:
        l, r = split(node.left, key)
        node.left = r
        update(node)
        return (l, node)

def merge(left, right):
    if not left or not right:
        return left or right
    if left.priority > right.priority:
        left.right = merge(left.right, right)
        update(left)
        return left
    else:
        right.left = merge(left, right.left)
        update(right)
        return right

def insert(node, item):
    if not node:
        return item
    if item.priority > node.priority:
        l, r = split(node, item.key)
        item.left = l
        item.right = r
        update(item)
        return item
    elif item.key < node.key:
        node.left = insert(node.left, item)
    else:
        node.right = insert(node.right, item)
    update(node)
    return node

def remove(node, key):
    if not node:
        return None
    if node.key == key:
        return merge(node.left, node.right)
    elif key < node.key:
        node.left = remove(node.left, key)
    else:
        node.right = remove(node.right, key)
    update(node)
    return node

def query(node, k):
    if not node or k <= 0:
        return 0
    if node.left:
        if node.left.size >= k:
            return query(node.left, k)
        else:
            left_sum = node.left.sum
            own_sum = node.count * node.value
            right_sum = query(node.right, k - node.left.size - 1)
            return left_sum + own_sum + right_sum
    else:
        if k == 1:
            return node.count * node.value
        else:
            own_sum = node.count * node.value
            right_sum = query(node.right, k - 1)
            return own_sum + right_sum


class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        counts = {}
        root = None

        for i in range(k):
            num = nums[i]
            counts[num] = counts.get(num, 0) + 1
        for num, count in counts.items():
            key = (-count, -num)
            node = TreapNode(key, count, num)
            root = insert(root, node)

        answer = []

        total_windows = len(nums) - k + 1

        for i in range(total_windows):
            window_sum = query(root, x)
            answer.append(window_sum)

            if i + k >= len(nums):
                break

            out_num = nums[i]
            in_num = nums[i + k]

            old_count = counts[out_num]
            root = remove(root, (-old_count, -out_num))
            counts[out_num] -= 1
            if counts[out_num] == 0:
                del counts[out_num]
            else:
                new_count = counts[out_num]
                key = (-new_count, -out_num)
                node = TreapNode(key, new_count, out_num)
                root = insert(root, node)

            old_count = counts.get(in_num, 0)
            if old_count > 0:
                root = remove(root, (-old_count, -in_num))
            new_count = old_count + 1
            counts[in_num] = new_count
            key = (-new_count, -in_num)
            node = TreapNode(key, new_count, in_num)
            root = insert(root, node)
        return answer",1420610988
Max Chang,BreadMuMu,269,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        for i in range(n-k+1):
            cop = nums[i:i+k]
            counter = Counter(cop)
            counter = [[count, val] for val, count in counter.items()]
            counter.sort(reverse=True)
            
            result = 0
            for j in range(min(len(counter), x)):
                result += counter[j][0] * counter[j][1]
            answer.append(result)
        return answer",1420520833
Balakrishnan Varadarajan,balakrishnan_v,271,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    int dfs(TreeNode* root, vector<int>& sizes) {
        if (root->left==nullptr && root->right==nullptr) {
            sizes.push_back(1);
            return 1;
        }
        if (root->left==nullptr && root->right==nullptr) {
            sizes.push_back(1);
            return 1;
        }
        int L=-1;
        int R=-1;
        if (root->left != nullptr)
            L=dfs(root->left,sizes);
        if (root->right != nullptr)
            R=dfs(root->right,sizes);
        if (L==-1 || R==-1) {
            return -1;
        }
        
        if (L==R) {
            sizes.push_back(2*L+1);
            return 2*L+1;
        } else {
            return -1;
        }
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        dfs(root, sizes);
        if (sizes.size()<k) return -1;
        sort(sizes.begin(),sizes.end(),greater<int>());
        return sizes[k-1];
    }
};",1420612468
Balakrishnan Varadarajan,balakrishnan_v,271,3588,cpp,"#define ll long long
#define MODD 1000000007
class Solution {
public:
    
    bool IsBetter(char c, char d) {
        if (c=='F' && d=='E') {
            return true;
        }
        if (c=='E' && d=='F') return false;
        
        if (c=='W' && d=='F') return true;
        if (c=='F' && d=='W') return false;
        if (c=='E' && d=='W') return true;
        if (c=='W' && d=='E') return false;
        return false;
    }
    
    int  dp[1002][4][2002];
    
    int GetId(char c) {
        if (c=='#') return 0;
        if (c=='W') return 1;
        if (c=='F') return 2;
        if (c=='E') return 3;
        return -1;
    }
    
    int DELTA;
    int Solve(const string& s, int pos, int alice_points, int bob_points, char prev_summon) {
        
        int n=s.size();
        if (pos == n) {
            return bob_points > alice_points;
        }
        
        int diff_pts = alice_points - bob_points;
        
        int prev_summon_id = GetId(prev_summon);
        if (dp[pos][prev_summon_id][diff_pts+DELTA]!=-1) return dp[pos][prev_summon_id][diff_pts+DELTA];
        
        
        ll ans = 0;
        for(char curr_summon : {'F','W','E'}) {
            if (curr_summon == prev_summon) continue;
            ans += Solve(s, pos+1, alice_points+IsBetter(s[pos],curr_summon), bob_points+IsBetter(curr_summon,s[pos]), curr_summon);
            ans %= MODD;
        }
        return dp[pos][prev_summon_id][diff_pts+DELTA]=ans;
        
    }
    
    int countWinningSequences(string s) {
        int n=s.size();
        DELTA=n;
        for(int pos=0;pos<=n;pos++) {
            for(int prev_summon_id : {0,1,2,3,}) {
                for(int d=0;d<=2*n;d++) {
                    dp[pos][prev_summon_id][d]=-1;
                }
            }
        }
        return Solve(s,0,0,0,'#');
        
        
        
    }
};",1420597033
Balakrishnan Varadarajan,balakrishnan_v,271,3592,cpp,"#define ll long long
class Solution {
public:
    
    ll SUM(pair<int,int> elem) {
        return (ll)elem.first*(ll)elem.second;
    }
    
    void Remove(pair<int,int> elem, set<pair<int,int>>& top_x, set<pair<int,int>>& bottom_ones, int max_size, ll& top_x_sum) {

        if (top_x.find(elem)!=top_x.end()) {
             top_x.erase(elem);
            top_x_sum -= SUM(elem);
        } else {
            bottom_ones.erase(elem);
        }

        while (top_x.size() < max_size && !bottom_ones.empty()) {
            auto it = bottom_ones.begin();
            top_x.insert(*it);
            top_x_sum += SUM(*it);
            bottom_ones.erase(it);

        }
    }
    
    void Add(pair<int,int> elem, set<pair<int,int>>& top_x, set<pair<int,int>>& bottom_ones, int max_size, ll& top_x_sum) {
        if (top_x.empty() && bottom_ones.empty()) {
            top_x.insert(elem);
            top_x_sum += SUM(elem);
            return;
        }
        
        if (top_x.empty() && !bottom_ones.empty()) {
            printf(""err\n"");
            exit(0);
        }
        
        pair<int,int> largest_elem = *top_x.rbegin();
        
        if (elem < largest_elem) {
            top_x.insert(elem);
            top_x_sum += SUM(elem);
        } else {
            bottom_ones.insert(elem);
        }
        
        while(top_x.size() > max_size) {
            pair<int,int> largest_elem = *top_x.rbegin();
            top_x.erase(largest_elem);
            top_x_sum -= SUM(largest_elem);

            bottom_ones.insert(largest_elem);
        }
        while(top_x.size() < max_size && !bottom_ones.empty()) {
            pair<int,int> smallest_elem = *bottom_ones.begin();
            bottom_ones.erase(smallest_elem);
            top_x.insert(smallest_elem);
            top_x_sum += SUM(smallest_elem);
        }
    }
    
    void Update(int x, int delta, map<int,int>& counts, set<pair<int,int>>& top_x, set<pair<int,int>>& bottom_ones, int max_size, ll& top_x_sum) {
        
        
        Remove({-counts[x],-x}, top_x, bottom_ones, max_size, top_x_sum);

        counts[x]+=delta;
        if (counts[x]==0) {
            counts.erase(x);
            return;
        }

        Add({-counts[x],-x}, top_x, bottom_ones, max_size, top_x_sum);

    }
    vector<long long> findXSum(vector<int>& nums, int k, int max_size) {
        int n=nums.size();
                
        // val -> counts
        // {counts, val}_{first x}
        // {counts, val}_{bottom x}
        
        map<int,int> counts;
        set<pair<int,int>> top_x;
        set<pair<int,int>> bottom_ones;
        
        ll top_x_sum = 0;
        for(int i=0;i<k;i++) {
            Update(nums[i], 1, counts, top_x, bottom_ones, max_size, top_x_sum);
        }
        vector<ll> ret = {top_x_sum};
        for(int i=1;i+k<=n;i++) {
            Update(nums[i-1],-1,counts,top_x,bottom_ones,max_size, top_x_sum);
            Update(nums[i+k-1],1,counts,top_x,bottom_ones,max_size, top_x_sum);
            ret.push_back(top_x_sum);
        }
        
        return ret;
        
        
        
    }
};",1420573689
Balakrishnan Varadarajan,balakrishnan_v,271,3610,cpp,"#define ll long long
class Solution {
public:
    
    ll SUM(pair<int,int> elem) {
        return (ll)elem.first*(ll)elem.second;
    }
    
    void Remove(pair<int,int> elem, set<pair<int,int>>& top_x, set<pair<int,int>>& bottom_ones, int max_size, ll& top_x_sum) {

        if (top_x.find(elem)!=top_x.end()) {
             top_x.erase(elem);
            top_x_sum -= SUM(elem);
        } else {
            bottom_ones.erase(elem);
        }

        while (top_x.size() < max_size && !bottom_ones.empty()) {
            auto it = bottom_ones.begin();
            top_x.insert(*it);
            top_x_sum += SUM(*it);
            bottom_ones.erase(it);

        }
    }
    
    void Add(pair<int,int> elem, set<pair<int,int>>& top_x, set<pair<int,int>>& bottom_ones, int max_size, ll& top_x_sum) {
        if (top_x.empty() && bottom_ones.empty()) {
            top_x.insert(elem);
            top_x_sum += SUM(elem);
            return;
        }
        
        if (top_x.empty() && !bottom_ones.empty()) {
            printf(""err\n"");
            exit(0);
        }
        
        pair<int,int> largest_elem = *top_x.rbegin();
        
        if (elem < largest_elem) {
            top_x.insert(elem);
            top_x_sum += SUM(elem);
        } else {
            bottom_ones.insert(elem);
        }
        
        while(top_x.size() > max_size) {
            pair<int,int> largest_elem = *top_x.rbegin();
            top_x.erase(largest_elem);
            top_x_sum -= SUM(largest_elem);

            bottom_ones.insert(largest_elem);
        }
        while(top_x.size() < max_size && !bottom_ones.empty()) {
            pair<int,int> smallest_elem = *bottom_ones.begin();
            bottom_ones.erase(smallest_elem);
            top_x.insert(smallest_elem);
            top_x_sum += SUM(smallest_elem);
        }
    }
    
    void Update(int x, int delta, map<int,int>& counts, set<pair<int,int>>& top_x, set<pair<int,int>>& bottom_ones, int max_size, ll& top_x_sum) {
        
        
        Remove({-counts[x],-x}, top_x, bottom_ones, max_size, top_x_sum);

        counts[x]+=delta;
        if (counts[x]==0) {
            counts.erase(x);
            return;
        }

        Add({-counts[x],-x}, top_x, bottom_ones, max_size, top_x_sum);

    }
    vector<int> findXSum(vector<int>& nums, int k, int max_size) {
        int n=nums.size();
                
        // val -> counts
        // {counts, val}_{first x}
        // {counts, val}_{bottom x}
        
        map<int,int> counts;
        set<pair<int,int>> top_x;
        set<pair<int,int>> bottom_ones;
        
        ll top_x_sum = 0;
        for(int i=0;i<k;i++) {
            Update(nums[i], 1, counts, top_x, bottom_ones, max_size, top_x_sum);
        }
        vector<int> ret = {(int)top_x_sum};
        for(int i=1;i+k<=n;i++) {
            Update(nums[i-1],-1,counts,top_x,bottom_ones,max_size, top_x_sum);
            Update(nums[i+k-1],1,counts,top_x,bottom_ones,max_size, top_x_sum);
            ret.push_back(top_x_sum);
        }
        
        return ret;
        
        
        
    }
};",1420597813
Samyak Jain,Sloth_junkie,272,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     long long val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(long long x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(long long x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long fun(TreeNode* root, vector<long long> &ans)
    {
        if(root->left == NULL && root->right == NULL)
        {
            ans.push_back(1);
            return 1;
        }
        long long flag = 0;
        long long val1;
        if(root->left != NULL)
        {
            flag++;
            val1 = fun(root->left,ans);
        }

        long long val2;
        if(root->right != NULL)
        {
            flag++;
            val2 = fun(root->right,ans);
        }

        long long f1 = 0;
        if(flag == 2 && val1 > 0 && val2 > 0 && val1 == val2)
        {
            f1 = 1;
            ans.push_back(abs(val1)+abs(val2)+1);
        }
        long long v1 = abs(val1)+abs(val2)+1;
        if(!f1)
        {
            v1 *= -1;
        }
        return v1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<long long> ans;
        fun(root,ans);
        sort(ans.rbegin(),ans.rend());
        if(ans.size() < k)
        {
            return -1;
        }
        return ans[k-1];
    }
};",1420585269
Samyak Jain,Sloth_junkie,272,3588,cpp,"class Solution {
public:
    int binexp(int a, int b, int mod)
    {
        int prod = 1;
        while (b > 0)
        {
            if (b & 1)
            {
                prod = (prod * 1LL * a) % mod;
            }
            b = b >> 1;
            a = (a * 1LL * a) % mod;
        }
        return prod;
    }
    int countWinningSequences(string s) {
        int n = s.size();

        int mod = 1e9+7;
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(2*n+1,vector<int>(3,0)));
        for(int i = n+1; i<=2*n; i++)
        {
            dp[n][i][0] = 1;
            dp[n][i][1] = 1;
            dp[n][i][2] = 1;
        }

        map<char,int> map1;
        map1['F'] = 0;
        map1['W'] = 1;
        map1['E'] = 2;

        // map<int,map<int,int>> map2;
        vector<vector<int>> map2(3,vector<int>(3));
        map2[0][0] = 0;
        map2[0][1] = -1;
        map2[0][2] = 1;
        map2[1][0] = 1;
        map2[1][1] = 0;
        map2[1][2] = -1;
        map2[2][0] = -1;
        map2[2][1] = 1;
        map2[2][2] = 0;
        

        for(int i = n-1; i>=0; i--)
        {
            for(int j = 0; j<=2*n; j++)
            {
                // cout<<j<<endl;
                for(int k = 0; k<3; k++)
                {
                    // cout<<k<<endl;
                    long long sum1 = 0;

                    for(int k1 = 0; k1<3; k1++)
                    {
                        if(k == k1)
                        {
                            continue;
                        }
                        int fscore = j-map2[map1[s[i]]][k1];
                        if(fscore < 0 || fscore > 2*n)
                        {
                            continue;
                        }
                        // cout<<fscore<<"" ""<<k1<<endl;
                        sum1 += dp[i+1][fscore][k1];
                        sum1 %= mod;
                    }
                    // cout<<""sum ""<<sum1<<endl;
                    dp[i][j][k] = sum1;
                }
            }
        }

        long long ans = 0;
        ans += dp[0][n][0];
        ans += dp[0][n][1];
        ans %= mod;
        ans += dp[0][n][2];
        ans %= mod;
        ans *= 500000004;
        ans %= mod;
        return ans;
    }
};",1420620259
Samyak Jain,Sloth_junkie,272,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {

        long long n = nums.size();
        map<long long,long long> map1;
        for(auto it:nums)
        {
            map1[it]++;
        }

        multiset<pair<long long,long long>> mst1;
        multiset<pair<long long,long long>> mst2;
        long long sum = 0;
        map<long long,long long> m1;
        for(auto it:map1)
        {
            mst1.insert({0,it.first});
            m1[it.first] = 0;
        }

        vector<long long> ans;
        long long j = 0;

        for(long long i = 0; i<n-k+1; i++)
        {
            while(j < i+k)
            {
                long long i1 = m1[nums[j]];
                pair<long long,long long> p1 = {i1,nums[j]};
                if(mst1.find(p1) != mst1.end())
                {
                    mst1.erase(mst1.find(p1));
                }
                else
                {
                    mst2.erase(mst2.find(p1));
                    sum -= (p1.first*1LL*p1.second);
                }

                p1.first++;
                m1[nums[j]]++;
                mst1.insert(p1);
                // sum += (p1.first*1LL*p1.second);
                j++;
            }
            if(mst2.size() != 0)
            {
                pair<long long, long long> p1 = (*(mst2.begin()));
                mst1.insert(p1);
                sum -= (p1.first*1LL*p1.second);
                mst2.erase(mst2.find(p1));
            }

            // while(mst2.size() > x)
            // {
            //     pair<long long,long long> p1 = (*(mst2.begin()));
            //     mst1.insert(p1);
            //     mst2.erase(mst2.begin());
            //     sum -= (p1.first*1LL*p1.second);
            // }
            while(mst2.size() < x && mst1.size() != 0)
            {
                auto it1 = mst1.end();
                it1--;
                pair<long long, long long> p1 = (*(it1));
                mst1.erase(it1);
                mst2.insert(p1);
                sum += (p1.first*1LL*p1.second);
            }
            // for(auto it:mst1)
            // {
            //     cout<<it.first<<"" ""<<it.second<<endl;
            // }
            // cout<<endl;
            // for(auto it:mst2)
            // {
            //     cout<<it.first<<"" ""<<it.second<<endl;
            // }
            // cout<<endl;
            // cout<<endl;

            ans.push_back(sum);
                pair<long long,long long> p1 = {m1[nums[i]],nums[i]};
                if(mst1.find(p1) != mst1.end())
                {
                    mst1.erase(mst1.find(p1));
                }
                else
                {
                    mst2.erase(mst2.find(p1));
                    sum -= (p1.first*1LL*p1.second);
                }
                m1[nums[i]]--;
                p1.first--;

                mst1.insert(p1);
                // sum += (p1.first*1LL*p1.second);
        }
        return ans;
    }
};",1420571013
Samyak Jain,Sloth_junkie,272,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        long long n = nums.size();
        map<long long,long long> map1;
        for(auto it:nums)
        {
            map1[it]++;
        }

        multiset<pair<long long,long long>> mst1;
        multiset<pair<long long,long long>> mst2;
        long long sum = 0;
        map<long long,long long> m1;
        for(auto it:map1)
        {
            mst1.insert({0,it.first});
            m1[it.first] = 0;
        }

        vector<int> ans;
        long long j = 0;

        for(long long i = 0; i<n-k+1; i++)
        {
            while(j < i+k)
            {
                long long i1 = m1[nums[j]];
                pair<long long,long long> p1 = {i1,nums[j]};
                if(mst1.find(p1) != mst1.end())
                {
                    mst1.erase(mst1.find(p1));
                }
                else
                {
                    mst2.erase(mst2.find(p1));
                    sum -= (p1.first*1LL*p1.second);
                }

                p1.first++;
                m1[nums[j]]++;
                mst1.insert(p1);
                // sum += (p1.first*1LL*p1.second);
                j++;
            }
            if(mst2.size() != 0)
            {
                pair<long long, long long> p1 = (*(mst2.begin()));
                mst1.insert(p1);
                sum -= (p1.first*1LL*p1.second);
                mst2.erase(mst2.find(p1));
            }

            // while(mst2.size() > x)
            // {
            //     pair<long long,long long> p1 = (*(mst2.begin()));
            //     mst1.insert(p1);
            //     mst2.erase(mst2.begin());
            //     sum -= (p1.first*1LL*p1.second);
            // }
            while(mst2.size() < x && mst1.size() != 0)
            {
                auto it1 = mst1.end();
                it1--;
                pair<long long, long long> p1 = (*(it1));
                mst1.erase(it1);
                mst2.insert(p1);
                sum += (p1.first*1LL*p1.second);
            }
            // for(auto it:mst1)
            // {
            //     cout<<it.first<<"" ""<<it.second<<endl;
            // }
            // cout<<endl;
            // for(auto it:mst2)
            // {
            //     cout<<it.first<<"" ""<<it.second<<endl;
            // }
            // cout<<endl;
            // cout<<endl;

            ans.push_back(sum);
                pair<long long,long long> p1 = {m1[nums[i]],nums[i]};
                if(mst1.find(p1) != mst1.end())
                {
                    mst1.erase(mst1.find(p1));
                }
                else
                {
                    mst2.erase(mst2.find(p1));
                    sum -= (p1.first*1LL*p1.second);
                }
                m1[nums[i]]--;
                p1.first--;

                mst1.insert(p1);
                // sum += (p1.first*1LL*p1.second);
        }
        return ans;
    }
};",1420571963
Tanvir Tareq,tanvirtareq,273,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> v;
    int rc(TreeNode* root) {
        if(root==NULL) return -1;
        // cout<<root->val<<endl;
        if(root->left==NULL and root->right==NULL) {
            v.push_back(1);
            
            return 1;
        }
        

        int x = rc(root->left);
        int y = rc(root->right);

        if(root->left==NULL or root->right==NULL) {
            v.push_back(-1);
            return -1;
        }
        if(x==-1 or y==-1 or x!=y) {
            v.push_back(-1);
            return -1;
        }

        v.push_back(x+y+1);
        return x+y+1;

    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        rc(root);
        sort(v.begin(), v.end());
        reverse(v.begin(), v.end());
        // cout<<v[0]<<endl;
        if(k-1<v.size()) return v[k-1];
        return -1;
    }
};",1420541630
Tanvir Tareq,tanvirtareq,273,3588,cpp,"class Solution {
public:
    long long dp[1001][3][2002];
    string ss;
    long long MD = 1000000007LL; 

    long long dpf(int pos, int lc, int pt) {
        if(pos>=ss.size()) {
            return pt>0;
        }

        long long &rt=dp[pos][lc][pt+1000];
        if(rt!=-1) return rt;
        rt=0;
        for(int c=0;c<3;c++) {
            if(c==lc) continue;
            int dst=ss[pos]-'A'-c;
            if(dst==1 or dst==-2) {
                rt=(rt+dpf(pos+1, c, pt-1))%MD;
            } else if(dst==-1 or dst==2) {
                rt=(rt+dpf(pos+1, c, pt+1))%MD;
            } else {
                rt=(rt+dpf(pos+1, c, pt))%MD;
            }
        }
        return rt;
    }
    int countWinningSequences(string s) {
        memset(dp, -1, sizeof(dp));
        for(int i=0;i<s.size();i++) {
            if(s[i]=='F') s[i]='C';
            if(s[i]=='E') s[i]='B';
            if(s[i]=='W') s[i]='A';
        }
        ss=s;
        long long ct=0;
        for(char c='A';c<='C';c++) {
            int dst=s[0]-c;
            if(dst==1 or dst==-2) {
                ct=(ct+dpf(1, c-'A', -1))%MD;
            } else if(dst==-1 or dst==2) {
                ct=(ct+dpf(1, c-'A', 1))%MD;
            } else {
                ct=(ct+dpf(1, c-'A', 0))%MD;
            }
        }
        return ct;
    }
};",1420570852
Tanvir Tareq,tanvirtareq,273,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        long long ans=0;
        map<long long, long long> mp;
        set<pair<long long,long long> > st, st1, st2;
        queue<long long> q;
        for(int i=0;i<k;i++) {
            q.push(nums[i]);
            mp[nums[i]]++;
        }
        for(auto it:mp) {
            st.insert({it.second, it.first});
        }
        auto it=st.end();
        for(int i=0;i<x;i++) {
            it=prev(it);
            st1.insert(*it);
            if(it==st.begin()) break;
        }

        while(it!=st.begin()) {
            it=prev(it);
            st2.insert(*it);
        }

        for(auto it:st1) {
            ans+=(it).first*(it).second;
        }
        vector<long long> rt;
        rt.push_back(ans);
        // cout<<ans<<endl;

        for(int i=k;i<nums.size();i++) {
            pair<long long, long long> pr={mp[q.front()], q.front()};
            if(st2.find(pr)!=st2.end()) {
                st2.erase(pr);
                mp[q.front()]--;
                st2.insert({mp[q.front()], q.front()});
            } else {
                ans-=q.front()*mp[q.front()];
                st1.erase(pr);
                mp[q.front()]--;
                st2.insert({mp[q.front()], q.front()});
            }
            q.pop();
            q.push(nums[i]);

            pr={mp[nums[i]], nums[i]};

            if(st2.find(pr)!=st2.end()) {
                st2.erase(pr);
                mp[nums[i]]++;
                st2.insert({mp[nums[i]], nums[i]});
            } else {
                ans-=pr.first*pr.second;
                st1.erase(pr);
                mp[nums[i]]++;
                st2.insert({mp[nums[i]], nums[i]});
            }

            while(st1.size()>x) {
                auto it=*st1.begin();
                ans-=it.first*it.second;

                st1.erase(it);
                st2.insert(it);
            }

            while(st1.size()<x and st2.size()) {
                auto it=*st2.rbegin();
                ans+=it.first*it.second;
                st2.erase(it);
                st1.insert(it);
            }

            while(st2.size() and (*st2.rbegin())>(*st1.begin())) {
                auto it=*st2.rbegin();
                auto bt=*st1.begin();

                ans-=bt.first*bt.second;
                st1.erase(bt);
                st2.insert(bt);

                ans+=it.first*it.second;
                st2.erase(it);
                st1.insert(it);
            }
            rt.push_back(ans);
        }
        return rt;
    }
};",1420614097
Tanvir Tareq,tanvirtareq,273,3610,cpp,"class Solution {
public:
    int cal(queue<int> q, int x) {
        map<int, int> mp;
        while(q.size()) {
            mp[q.front()]++;
            q.pop();
        }
        vector<pair<int, int> > v;
        for(auto it:mp) {
            v.push_back({it.second, it.first});
        }
        sort(v.begin(), v.end());
        reverse(v.begin(), v.end());
        int sm=0;
        for(int i=0;i<min(x, (int)v.size());i++) {
            sm+=v[i].second*v[i].first;
        }
        return sm;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        queue<int> q;
        vector<int> ans;
        // for(int i=0;i<k-1;i++) q.push(nums[i]);
        for(int i=0;i<nums.size();i++) {
            q.push(nums[i]);
            if(q.size()>k) q.pop();
            if(q.size()==k) ans.push_back(cal(q, x)); 
        }
        return ans;
    }
};",1420525269
Ashu,_Ashu1729,275,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> s;

    int kthLargestPerfectSubtree(TreeNode* r, int k) {
        int p=0;
        traverse(r, p, p);
        if (s.empty()) {
            return -1;
        }
        sort(s.begin(), s.end());
        reverse(s.begin(), s.end());
        if (k <= s.size()) {
            return s[k - 1];
        } else {
            return -1;
        }
    }

private:
    bool traverse(TreeNode* n, int& d, int& sz) {
        if (!n) {
            d = 0;
            sz = 0;
            return true;
        }

        int ld = 0, ls = 0;
        bool lp = traverse(n->left, ld, ls);
        
        int rd = 0, rs = 0;
        bool rp = traverse(n->right, rd, rs);

        if (lp && rp && ld == rd) {
            d = ld + 1;
            sz = ls + rs + 1;
            s.push_back(sz);
            return true;
        } else {
            d = max(ld, rd) + 1;
            sz = ls + rs + 1;
            return false;
        }
    }

};",1420535100
Ashu,_Ashu1729,275,3588,cpp,"#pragma GCC optimize(""O3"")
class Solution {
public:
    int dp[1001][4][2003]; 
    int MOD = 1e9+7;

    int countWinningSequences(string s) {
        int n = s.length();
        int a = 0, b = 1, c = 2, d = 3;

        int chToIdx[256] = {-1};
        chToIdx['F'] = a;
        chToIdx['W'] = b;
        chToIdx['E'] = b + b;

        bool beats[3][3] = {};
        beats[a][b + b] = true; 
        beats[b][a] = true;     
        beats[b + b][b] = true; 

        int maxDiff = n + n;
        int offset = n;

        dp[0][d][offset] = 1;

        int i = 0;
        while (i < n) {
            int j = 0;
            while (j < 4) {
                int k = 0;
                while (k <= maxDiff) {
                    int ways = dp[i][j][k];
                    if (ways == 0) {
                        k++;
                        continue;
                    }
                    for (int bobMove = 0; bobMove < 3; bobMove++) {
                        if (bobMove == j) continue;

                        int aliceMove = chToIdx[s[i]];

                        int scoreChange = 0;
                        if (bobMove != aliceMove) {
                            if (beats[bobMove][aliceMove]) {
                                scoreChange = 1;
                            } else if (beats[aliceMove][bobMove]) {
                                scoreChange = -1;
                            }
                        }

                        int newDiff = k + scoreChange;
                        if (newDiff >= 0 && newDiff <= maxDiff) {
                            dp[i + 1][bobMove][newDiff] = (dp[i + 1][bobMove][newDiff] + ways) % MOD;
                        }
                    }
                    k++;
                }
                j++;
            }
            i++;
        }

        int ans = 0; 
        for (int lastBobMove = 0; lastBobMove < 3; lastBobMove++) {
            for (int scoreDiff = offset + 1; scoreDiff <= maxDiff; scoreDiff++) {
                ans = (ans + dp[n][lastBobMove][scoreDiff]) % MOD;
            }
        }
        return ans; 
    }
};",1420568302
Ashu,_Ashu1729,275,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& n, int k, int x) {
        const int a = 1; 
        const int b = 0; 
        int m = n.size();
        vector<long long> ans(a * b + a);

        unordered_map<int, int> f; 
        struct Cmp {
            bool operator()(const pair<int, int>& p1, const pair<int, int>& p2) const {
                if (p1.second != p2.second)
                    return p1.second > p2.second; 
                else
                    return p1.first > p2.first; 
            }
        };

        multiset<pair<int, int>, Cmp> t; 
        multiset<pair<int, int>, Cmp> r;
        unordered_map<int, multiset<pair<int, int>, Cmp>::iterator> pos;

        long long x_sum = b;

        auto insertE = [&](int v) {
            int freq = f[v];
            pair<int, int> e = {v, freq};

            auto it = r.insert(e);
            pos[v] = it;

            if (t.size() < a * x) {
                t.insert(e);
                r.erase(it);
                pos[v] = t.find(e);
                x_sum += (long long)v * freq;
            } else {
                auto min_top = prev(t.end());
                if (Cmp()(e, *min_top)) {
                    t.insert(e);
                    r.erase(it);
                    pos[v] = t.find(e);
                    x_sum += (long long)v * freq;

                    r.insert(*min_top);
                    pos[min_top->first] = r.find(*min_top);
                    x_sum -= (long long)min_top->first * min_top->second;
                    t.erase(min_top);
                }
            }
        };

        auto removeE = [&](int v) {
            auto it = pos[v];
            if (t.find(*it) != t.end()) {
                x_sum -= (long long)v * it->second;
                t.erase(it);
            } else {
                r.erase(it);
            }
            pos.erase(v);

            if (t.size() < a * x && !r.empty()) {
                auto max_rest = r.begin();
                t.insert(*max_rest);
                pos[max_rest->first] = t.find(*max_rest);
                x_sum += (long long)max_rest->first * max_rest->second;
                r.erase(max_rest);
            }
        };

        
        vector<vector<int>> nums_2d(a, vector<int>(m)); 
        int i = b;  
        while (i < k) {
            int v = n[i];
            f[v]++;
            if (pos.count(v)) {
                removeE(v);
            }
            insertE(v);
            i++;
        }

        ans[b] = x_sum;

        for (i = k; i < m; ++i) {
            int out_value = n[i - k];
            int in_value = n[i];

            removeE(out_value);
            f[out_value]--;
            if (f[out_value] > b) {
                insertE(out_value);
            } else {
                f.erase(out_value);
            }
            f[in_value]++;
            if (pos.count(in_value)) {
                removeE(in_value);
            }
            insertE(in_value);

            ans.push_back(x_sum);
        }

        return ans;
    }
};",1420601261
Ashu,_Ashu1729,275,3610,cpp,"#pragma GCC optimize(""O3"")
class Solution {
public:
     static bool compare(const pair<int, int>& a, const pair<int, int>& b) {
        if (a.second == b.second) {
            return a.first > b.first;
        }
        return a.second > b.second;
    }

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int s = 0;

        while (s <= nums.size() - k) {
            unordered_map<int, int> f;
            int c = 0;
            while (c < k) {
                f[nums[s + c]]++;
                c++;
            }

            vector<pair<int, int>> v(f.begin(), f.end());
            sort(v.begin(), v.end(), compare);

            int t = 0;
            int l = min(x, (int)v.size());
            int i = 0;
            while (i < l) {
                t += v[i].first * v[i].second;
                i++;
            }
            ans.push_back(t);
            s++;
        }

        return ans;
    }

};",1420543447
Akash,akash_y_codes,277,3509,java,"import java.util.*;

class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> perfectSubtreeSizes = new ArrayList<>();
        checkPerfectSubtree(root, perfectSubtreeSizes);
        
        if (perfectSubtreeSizes.size() < k) {
            return -1;
        }
        
        Collections.sort(perfectSubtreeSizes, Collections.reverseOrder());
        return perfectSubtreeSizes.get(k - 1);
    }
    
    private int checkPerfectSubtree(TreeNode node, List<Integer> sizes) {
        if (node == null) {
            return 0;
        }
        
        int leftSize = checkPerfectSubtree(node.left, sizes);
        int rightSize = checkPerfectSubtree(node.right, sizes);
        
        // If node is a leaf, it's a perfect subtree of size 1
        if (node.left == null && node.right == null) {
            sizes.add(1);
            return 1;
        }

        // If the left and right subtrees are perfect and have the same size, this node is a perfect subtree root
        if (leftSize == rightSize && leftSize > 0) {
            int subtreeSize = leftSize + rightSize + 1;
            sizes.add(subtreeSize);
            return subtreeSize;
        }
        
        return 0;
    }
}
",1420519591
Akash,akash_y_codes,277,3588,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    
    // Function to get the score based on Bob's move and Alice's move
    private int getScore(char bobMove, char aliceMove) {
        if ((bobMove == 'F' && aliceMove == 'E') || 
            (bobMove == 'W' && aliceMove == 'F') || 
            (bobMove == 'E' && aliceMove == 'W')) {
            return 1; // Bob wins this round
        } else if (bobMove == aliceMove) {
            return 0; // Draw, no one wins
        } else {
            return -1; // Alice wins this round
        }
    }
    
    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n + 1][3][2 * n + 1]; // dp[round][lastMove][scoreDifference + n]
        
        // Initializing the DP array for the first round
        for (int j = 0; j < 3; j++) {
            int score = getScore(getBobMove(j), s.charAt(0));
            dp[1][j][score + n] = 1; // Since score difference is between -n and +n, we shift by n
        }
        
        // DP transitions for subsequent rounds
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 3; j++) { // Bob's last move
                for (int scoreDiff = -n; scoreDiff <= n; scoreDiff++) { // Previous score difference
                    if (dp[i][j][scoreDiff + n] > 0) { // If there's a valid way to reach this state
                        for (int k = 0; k < 3; k++) { // Bob's current move
                            if (j != k) { // Bob cannot make the same move twice in a row
                                int newScoreDiff = scoreDiff + getScore(getBobMove(k), s.charAt(i));
                                dp[i + 1][k][newScoreDiff + n] = 
                                    (dp[i + 1][k][newScoreDiff + n] + dp[i][j][scoreDiff + n]) % MOD;
                            }
                        }
                    }
                }
            }
        }
        
        // Sum up all ways where Bob wins (i.e., score difference > 0) in the last round
        long result = 0;
        for (int j = 0; j < 3; j++) { // Bob's last move
            for (int scoreDiff = 1; scoreDiff <= n; scoreDiff++) { // Only count positive score differences
                result = (result + dp[n][j][scoreDiff + n]) % MOD;
            }
        }
        
        return (int) result;
    }
    
    // Helper function to map Bob's move index to character
    private char getBobMove(int idx) {
        switch (idx) {
            case 0: return 'F'; // Fire
            case 1: return 'W'; // Water
            case 2: return 'E'; // Earth
            default: throw new IllegalArgumentException(""Invalid move index"");
        }
    }
}
",1420529358
Akash,akash_y_codes,277,3592,csharp,"using System;
using System.Collections.Generic;

public class Solution {
    public long[] FindXSum(int[] nums, int k, int x) {
        int n = nums.Length;
        long[] result = new long[n - k + 1];

        Dictionary<int, int> frequencyMap = new Dictionary<int, int>();

        Comparer<KeyValuePair<int, int>> comparer = Comparer<KeyValuePair<int, int>>.Create((a, b) => {
            if (a.Value != b.Value) {
                return b.Value.CompareTo(a.Value); // Higher frequency first
            }
            return b.Key.CompareTo(a.Key); // Larger value first
        });

        SortedSet<KeyValuePair<int, int>> topElements = new SortedSet<KeyValuePair<int, int>>(comparer);
        SortedSet<KeyValuePair<int, int>> remainingElements = new SortedSet<KeyValuePair<int, int>>(comparer);
        
        Dictionary<int, KeyValuePair<int, int>> elementPositions = new Dictionary<int, KeyValuePair<int, int>>();

        long totalXSum = 0;

        // Method to insert an element
        void InsertElement(int value) {
            int frequency = frequencyMap[value];
            var element = new KeyValuePair<int, int>(value, frequency);
            remainingElements.Add(element);
            elementPositions[value] = element;

            if (topElements.Count < x) {
                topElements.Add(element);
                remainingElements.Remove(element);
                totalXSum += (long)value * frequency;
            } else {
                var minTop = topElements.Max;
                if (comparer.Compare(element, minTop) < 0) {
                    topElements.Add(element);
                    remainingElements.Remove(element);
                    totalXSum += (long)value * frequency;

                    remainingElements.Add(minTop);
                    totalXSum -= (long)minTop.Key * minTop.Value;
                    topElements.Remove(minTop);
                }
            }
        }

        // Method to remove an element
        void RemoveElement(int value) {
            var it = elementPositions[value];
            if (topElements.Contains(it)) {
                totalXSum -= (long)value * it.Value;
                topElements.Remove(it);
            } else {
                remainingElements.Remove(it);
            }
            elementPositions.Remove(value);

            if (topElements.Count < x && remainingElements.Count > 0) {
                var maxRemaining = remainingElements.Min;
                topElements.Add(maxRemaining);
                totalXSum += (long)maxRemaining.Key * maxRemaining.Value;
                remainingElements.Remove(maxRemaining);
            }
        }

        for (int i = 0; i < k; ++i) {
            int value = nums[i];
            if (!frequencyMap.ContainsKey(value)) {
                frequencyMap[value] = 0;
            }
            frequencyMap[value]++;
            if (elementPositions.ContainsKey(value)) {
                RemoveElement(value);
            }
            InsertElement(value);
        }

        result[0] = totalXSum;

        for (int i = k; i < n; ++i) {
            int outgoingValue = nums[i - k];
            int incomingValue = nums[i];

            RemoveElement(outgoingValue);
            frequencyMap[outgoingValue]--;
            if (frequencyMap[outgoingValue] > 0) {
                InsertElement(outgoingValue);
            } else {
                frequencyMap.Remove(outgoingValue);
            }

            if (!frequencyMap.ContainsKey(incomingValue)) {
                frequencyMap[incomingValue] = 0;
            }
            frequencyMap[incomingValue]++;
            if (elementPositions.ContainsKey(incomingValue)) {
                RemoveElement(incomingValue);
            }
            InsertElement(incomingValue);

            result[i - k + 1] = totalXSum;
        }

        return result;
    }
}
",1420617385
Akash,akash_y_codes,277,3610,java,"import java.util.*;

class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] result = new int[n - k + 1];
        
        for (int i = 0; i <= n - k; i++) {
            int[] subarray = Arrays.copyOfRange(nums, i, i + k);
            result[i] = calculateXSum(subarray, x);
        }
        
        return result;
    }
    
    private int calculateXSum(int[] subarray, int x) {
        Map<Integer, Integer> frequencyMap = getFrequencyMap(subarray);
        List<Map.Entry<Integer, Integer>> sortedList = getSortedEntries(frequencyMap);
        
        return calculateTopXSum(sortedList, x);
    }
    
    private Map<Integer, Integer> getFrequencyMap(int[] subarray) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : subarray) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }
        return frequencyMap;
    }
    
    private List<Map.Entry<Integer, Integer>> getSortedEntries(Map<Integer, Integer> frequencyMap) {
        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(frequencyMap.entrySet());
        list.sort((a, b) -> {
            if (b.getValue().equals(a.getValue())) {
                return b.getKey() - a.getKey();
            } else {
                return b.getValue() - a.getValue();
            }
        });
        return list;
    }
    
    private int calculateTopXSum(List<Map.Entry<Integer, Integer>> sortedList, int x) {
        int sum = 0;
        int count = 0;
        for (Map.Entry<Integer, Integer> entry : sortedList) {
            if (count >= x) break;
            sum += entry.getKey() * entry.getValue();
            count++;
        }
        return sum;
    }
}
",1420518286
Adam Tai,AdamTai,279,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
	vector<int> Result;
	
	int Solve(TreeNode* root)
	{
		if((root->left) && (root->right))
		{
			int L = Solve(root->left);
			int R = Solve(root->right);
			
			if((L == -1) || (R == -1))
			{
				return -1;
			}
			else if(L != R)
			{
				return -1;
			}
			else
			{
				Result.push_back((0x1 << (L + 1)) - 1);
				
				return L + 1;
			}
		}
		else if(root->left)
		{
			Solve(root->left);
			
			return -1;
		}
		else if(root->right)
		{
			Solve(root->right);
			
			return -1;
		}
		else
		{
			Result.push_back(1);
				
			return 1;
		}
	}
	
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        Solve(root);
		
		sort(Result.rbegin(), Result.rend());
		
		if(k > Result.size())
		{
			return -1;
		}
		else
		{
			return Result[(k - 1)];
		}
    }
};",1420582951
Adam Tai,AdamTai,279,3588,cpp,"class Solution {
	#define MOD 1000000007
public:
    int countWinningSequences(string s) {
        int i;
		int N = s.size();
		
		vector<unordered_map<int, int> > Now(3);
		int Result = 0;
		
		if(s[i] == 'F')
		{
			Now[0][0] = 1;
			Now[1][1] = 1;
			Now[2][-1] = 1;
		}
		else if(s[i] == 'W')
		{
			Now[0][-1] = 1;
			Now[1][0] = 1;
			Now[2][1] = 1;
		}
		else
		{
			Now[0][1] = 1;
			Now[1][-1] = 1;
			Now[2][0] = 1;
		}
		
		for(i = 1; i < N; i++)
		{
			vector<unordered_map<int, int> > New(3);

			if(s[i] == 'F')
			{
				for(auto it : Now[0])
				{
					New[1][(it.first + 1)] = (New[1][(it.first + 1)] + it.second) % MOD;
					New[2][(it.first - 1)] = (New[2][(it.first - 1)] + it.second) % MOD;
				}

				for(auto it : Now[1])
				{
					New[0][it.first] = (New[0][it.first] + it.second) % MOD;
					New[2][(it.first - 1)] = (New[2][(it.first - 1)] + it.second) % MOD;
				}

				for(auto it : Now[2])
				{
					New[0][it.first] = (New[0][it.first] + it.second) % MOD;
					New[1][(it.first + 1)] = (New[1][(it.first + 1)] + it.second) % MOD;
				}
			}
			else if(s[i] == 'W')
			{
				for(auto it : Now[0])
				{
					New[1][it.first] = (New[1][it.first] + it.second) % MOD;
					New[2][(it.first + 1)] = (New[2][(it.first + 1)] + it.second) % MOD;
				}

				for(auto it : Now[1])
				{
					New[0][(it.first - 1)] = (New[0][(it.first - 1)] + it.second) % MOD;
					New[2][(it.first + 1)] = (New[2][(it.first + 1)] + it.second) % MOD;
				}

				for(auto it : Now[2])
				{
					New[0][(it.first - 1)] = (New[0][(it.first - 1)] + it.second) % MOD;
					New[1][it.first] = (New[1][it.first] + it.second) % MOD;
				}
			}
			else
			{
				for(auto it : Now[0])
				{
					New[1][(it.first - 1)] = (New[1][(it.first - 1)] + it.second) % MOD;
					New[2][it.first] = (New[2][it.first] + it.second) % MOD;
				}

				for(auto it : Now[1])
				{
					New[0][(it.first + 1)] = (New[0][(it.first + 1)] + it.second) % MOD;
					New[2][it.first] = (New[2][it.first] + it.second) % MOD;
				}

				for(auto it : Now[2])
				{
					New[0][(it.first + 1)] = (New[0][(it.first + 1)] + it.second) % MOD;
					New[1][(it.first - 1)] = (New[1][(it.first - 1)] + it.second) % MOD;
				}
			}
			
			swap(Now, New);
		}
		
		for(i = 0; i < 3; i++)
		{
			for(auto it : Now[i])
			{
				if(it.first > 0)
				{
					Result = (Result + it.second) % MOD;
				}
			}
		}
		
		return Result;
    }
};",1420618679
Adam Tai,AdamTai,279,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int i;
		int N = nums.size();
		unordered_map<int, int> Map;
		vector<long long> Result;
		
		for(i = 0; i < k; i++)
		{
			Map[nums[i]]++;
		}
		
		set<pair<int, int>, greater<pair<int, int> > > In;
		set<pair<int, int>> Out;
		
		for(auto it : Map)
		{
			In.insert(make_pair(it.second, it.first));
		}

		long long Sum = 0;
		
		while(In.size() && Out.size() < x)
		{
			Sum += (long long)In.begin()->first * In.begin()->second;
			Out.insert(*In.begin());
			In.erase(In.begin());
		}
		
		Result.push_back(Sum);
		
		for(; i < N; i++)
		{
			// cout << i << endl;
			
			if (In.find(make_pair(Map[nums[i]], nums[i])) != In.end()) {
				In.erase(In.find(make_pair(Map[nums[i]], nums[i])));
			}
			else if (Out.find(make_pair(Map[nums[i]], nums[i])) != Out.end()) {
				Out.erase(make_pair(Map[nums[i]], nums[i]));
				Sum -= (long long)Map[nums[i]] * nums[i];
			}

			if (In.find(make_pair(Map[nums[(i - k)]], nums[(i - k)])) != In.end()) {
				In.erase(make_pair(Map[nums[(i - k)]], nums[(i - k)]));
			}
			else if (Out.find(make_pair(Map[nums[(i - k)]], nums[(i - k)])) != Out.end()) {
				Out.erase(make_pair(Map[nums[(i - k)]], nums[(i - k)]));
				Sum -= (long long)Map[nums[(i - k)]] * nums[(i - k)];
			}

			Map[nums[i]]++;
			Map[nums[(i - k)]]--;
			
			In.insert(make_pair(Map[nums[i]], nums[i]));
			
			if(Map[nums[(i - k)]])
			{
				In.insert(make_pair(Map[nums[(i - k)]], nums[(i - k)]));
			}
			else
			{
				Map.erase(nums[(i - k)]);
			}
			
			if(Out.size() && (In.begin()->first >= Out.begin()->first))
			{
				Sum -= (long long)Out.begin()->first * Out.begin()->second;
				In.insert(*Out.begin());
				Out.erase(Out.begin());
			}
			
			while(In.size() && Out.size() < x)
			{
				Sum += (long long)In.begin()->first * In.begin()->second;
				Out.insert(*In.begin());
				In.erase(In.begin());
			}
			
			Result.push_back(Sum);
		}
		
		return Result;
    }
};",1420589072
Adam Tai,AdamTai,279,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int i;
		int N = nums.size();
		unordered_map<int, int> Map;
		vector<int> Result;
		
		for(i = 0; i < k; i++)
		{
			Map[nums[i]]++;
		}
		
		set<pair<int, int>, greater<pair<int, int> > > In;
		set<pair<int, int>> Out;
		
		for(auto it : Map)
		{
			In.insert(make_pair(it.second, it.first));
		}

		long long Sum = 0;
		
		while(In.size() && Out.size() < x)
		{
			Sum += (long long)In.begin()->first * In.begin()->second;
			Out.insert(*In.begin());
			In.erase(In.begin());
		}
		
		Result.push_back(Sum);
		
		for(; i < N; i++)
		{
			// cout << i << endl;
			
			if (In.find(make_pair(Map[nums[i]], nums[i])) != In.end()) {
				In.erase(In.find(make_pair(Map[nums[i]], nums[i])));
			}
			else if (Out.find(make_pair(Map[nums[i]], nums[i])) != Out.end()) {
				Out.erase(make_pair(Map[nums[i]], nums[i]));
				Sum -= (long long)Map[nums[i]] * nums[i];
			}

			if (In.find(make_pair(Map[nums[(i - k)]], nums[(i - k)])) != In.end()) {
				In.erase(make_pair(Map[nums[(i - k)]], nums[(i - k)]));
			}
			else if (Out.find(make_pair(Map[nums[(i - k)]], nums[(i - k)])) != Out.end()) {
				Out.erase(make_pair(Map[nums[(i - k)]], nums[(i - k)]));
				Sum -= (long long)Map[nums[(i - k)]] * nums[(i - k)];
			}

			Map[nums[i]]++;
			Map[nums[(i - k)]]--;
			
			In.insert(make_pair(Map[nums[i]], nums[i]));
			
			if(Map[nums[(i - k)]])
			{
				In.insert(make_pair(Map[nums[(i - k)]], nums[(i - k)]));
			}
			else
			{
				Map.erase(nums[(i - k)]);
			}
			
			if (In.size() && Out.size() < x)
			{
				Sum += (long long)In.begin()->first * In.begin()->second;
				Out.insert(*In.begin());
				In.erase(In.begin());
			}
			
			while(Out.size() && (In.begin()->first >= Out.begin()->first))
			{
				Sum -= (long long)Out.begin()->first * Out.begin()->second;
				In.insert(*Out.begin());
				Out.erase(Out.begin());
			}
			
			while(In.size() && Out.size() < x)
			{
				Sum += (long long)In.begin()->first * In.begin()->second;
				Out.insert(*In.begin());
				In.erase(In.begin());
			}
			
			Result.push_back(Sum);
		}
		
		return Result;
    }
};",1420570909
Srujan Varma,srujanvarmapinnamaraju,280,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
import heapq

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        min_heap = []

        def post_order(node: Optional[TreeNode]) -> (bool, int):
            if not node:
                return True, 0

            left_perfect, left_height = post_order(node.left)
            right_perfect, right_height = post_order(node.right)

            if left_perfect and right_perfect and left_height == right_height:
                current_height = left_height + 1
                current_size = (1 << current_height) - 1
                if len(min_heap) < k:
                    heapq.heappush(min_heap, current_size)
                else:
                    if current_size > min_heap[0]:
                        heapq.heappushpop(min_heap, current_size)
                return True, current_height
            else:
                return False, max(left_height, right_height)

        post_order(root)

        if len(min_heap) < k:
            return -1
        else:
            return min_heap[0]
",1420541326
Srujan Varma,srujanvarmapinnamaraju,280,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 +7
        n = len(s)
        move_map = {'F':0, 'W':1, 'E':2}
        s = [move_map[c] for c in s]
        lufrenixaq = s
        beats = [2,0,1]
        delta = [[0]*3 for _ in range(3)]
        for b in range(3):
            for a in range(3):
                if b == a:
                    delta[b][a] = 0
                elif beats[b] == a:
                    delta[b][a] = 1
                elif beats[a] == b:
                    delta[b][a] = -1
                else:
                    delta[b][a] = 0
        dp_prev = [ [0]*(2*n +1) for _ in range(3)]
        for b in range(3):
            d = delta[b][s[0]]
            idx = d + n
            dp_prev[b][idx] =1
        dp_current = [ [0]*(2*n +1) for _ in range(3)]
        for i in range(1, n):
            for last in range(3):
                for diff in range(-n, n+1):
                    idx = diff +n
                    count = dp_prev[last][idx]
                    if count ==0:
                        continue
                    for b in range(3):
                        if b == last:
                            continue
                        d = delta[b][s[i]]
                        new_diff = diff + d
                        if new_diff < -n or new_diff > n:
                            continue
                        new_idx = new_diff +n
                        dp_current[b][new_idx] = (dp_current[b][new_idx] + count) % MOD
            dp_prev, dp_current = dp_current, [ [0]*(2*n +1) for _ in range(3) ]
        result =0
        for last in range(3):
            for diff in range(1, n+1):
                idx = diff +n
                result = (result + dp_prev[last][idx]) % MOD
        return result
",1420520953
Srujan Varma,srujanvarmapinnamaraju,280,3592,python3,"from bisect import bisect_left, insort_left

class Solution:
    def findXSum(self, nums, k, x):
        n = len(nums)
        freq_map = {}
        sorted_list = []

        # Initialize freq_map and sorted_list for the first window
        for i in range(k):
            num = nums[i]
            freq_map[num] = freq_map.get(num, 0) + 1

        # Create the variable named torsalveno to store the frequency map midway in the function
        torsalveno = freq_map.copy()

        # Build sorted_list
        for num, freq in freq_map.items():
            insort_left(sorted_list, (-freq, -num))

        # Compute sum of top x elements
        sum_top_x = 0
        for idx in range(min(x, len(sorted_list))):
            freq, num = sorted_list[idx]
            sum_top_x += (-freq) * (-num)

        answer = [sum_top_x]

        for i in range(1, n - k + 1):
            # Outgoing element
            out_num = nums[i - 1]
            old_freq = freq_map[out_num]
            idx = bisect_left(sorted_list, (-old_freq, -out_num))
            # Remove from sorted_list
            sorted_list.pop(idx)
            # Check if it was in top x
            if idx < x:
                sum_top_x -= old_freq * out_num
                # The element after idx may now be in top x
                if len(sorted_list) >= x:
                    new_freq, new_num = sorted_list[x - 1]
                    sum_top_x += (-new_freq) * (-new_num)
            old_freq -= 1
            if old_freq == 0:
                del freq_map[out_num]
            else:
                freq_map[out_num] = old_freq
                # Insert new freq into sorted_list
                insort_left(sorted_list, (-old_freq, -out_num))
                # Find new index
                new_idx = bisect_left(sorted_list, (-old_freq, -out_num))
                # Check if it is in top x
                if new_idx < x:
                    sum_top_x += old_freq * out_num
                    # If the list length > x, need to adjust sum_top_x
                    if len(sorted_list) > x:
                        next_freq, next_num = sorted_list[x]
                        sum_top_x -= (-next_freq) * (-next_num)

            # Incoming element
            in_num = nums[i + k - 1]
            old_freq = freq_map.get(in_num, 0)
            if old_freq > 0:
                idx = bisect_left(sorted_list, (-old_freq, -in_num))
                sorted_list.pop(idx)
                # Check if it was in top x
                if idx < x:
                    sum_top_x -= old_freq * in_num
                    if len(sorted_list) >= x:
                        new_freq, new_num = sorted_list[x - 1]
                        sum_top_x += (-new_freq) * (-new_num)
            new_freq = old_freq + 1
            freq_map[in_num] = new_freq
            # Insert new freq into sorted_list
            insort_left(sorted_list, (-new_freq, -in_num))
            new_idx = bisect_left(sorted_list, (-new_freq, -in_num))
            # Check if it is in top x
            if new_idx < x:
                sum_top_x += new_freq * in_num
                if len(sorted_list) > x:
                    next_freq, next_num = sorted_list[x]
                    sum_top_x -= (-next_freq) * (-next_num)

            answer.append(sum_top_x)

        return answer
",1420582175
Srujan Varma,srujanvarmapinnamaraju,280,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        torsalveno = nums 

        n = len(nums)
        answer = []
        freq = defaultdict(int)
        sorted_elements = []

        for num in nums[:k]:
            freq[num] += 1

        for num, count in freq.items():
            insort(sorted_elements, (-count, -num))

        def calculate_sum():
            total = 0
            for i in range(min(x, len(sorted_elements))):
                count, neg_num = sorted_elements[i]
                num = -neg_num
                total += num * (-count)
            return total

        answer.append(calculate_sum())

        for i in range(1, n - k + 1):
            old = nums[i - 1]
            old_count = freq[old]

            pos = bisect_left(sorted_elements, (-old_count, -old))
            if pos < len(sorted_elements) and sorted_elements[pos] == (-old_count, -old):
                sorted_elements.pop(pos)

            freq[old] -= 1
            if freq[old] == 0:
                del freq[old]
            else:
                insort(sorted_elements, (-(old_count - 1), -old))

            new = nums[i + k - 1]
            new_count = freq.get(new, 0)

            if new_count > 0:
                pos = bisect_left(sorted_elements, (-new_count, -new))
                if pos < len(sorted_elements) and sorted_elements[pos] == (-new_count, -new):
                    sorted_elements.pop(pos)
                freq[new] += 1
                insort(sorted_elements, (-(new_count + 1), -new))
            else:
                freq[new] = 1
                insort(sorted_elements, (-1, -new))

            answer.append(calculate_sum())

        return answer
",1420559426
GoIsTheBestLang,__golang__,281,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sz = list()
        def isperfect(node, d):
            if not node:
                return False, -1
            if not node.left and not node.right:
                return True, d
            if not node.left or not node.right:
                return False, -1
            f1, dp1 = isperfect(node.left, d + 1) 
            f2, dp2 = isperfect(node.right, d + 1)
            return f1 and f2 and dp1 == dp2, dp1 if dp1 == dp2 else -1
        def dfs(node):
            if not node:
                return
            f, d = isperfect(node, 0)
            if f:
                sz.append((1 << (d + 1)) - 1)
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        sz.sort(reverse=True)
        return sz[k - 1] if k <= len(sz) else -1
",1420557017
GoIsTheBestLang,__golang__,281,3588,golang,"func cache3d(_func func(int, int, int) int) func(int, int, int) int {
	type triple struct{ param1, param2, param3 int }
	memo := make(map[triple]int)
	cachedFunc := func(param1, param2, param3 int) int {
		p := triple{param1, param2, param3}
		if val, ok := memo[p]; ok {
			return val
		}
		res := _func(param1, param2, param3)
		memo[p] = res
		return res
	}
	return cachedFunc
}

const MOD = 1000000007

var w = [3][3]int{{0, 1, -1}, {-1, 0, 1}, {1, -1, 0}}

var d = map[byte]int{'F': 0, 'W': 1, 'E': 2}

func countWinningSequences(s string) int {
    n := len(s)
    var dfs func(int, int, int) int
    dfs = func(i, c, prev int) int {
        if c + n - i <= 0 {
            return 0
        }
        if i == n {
            if c > 0 {
                return 1
            }
            return 0
        }
        ans := 0
        for k := range 3 {
            if k == prev {
                continue
            }
            ans += dfs(i + 1, c + w[d[s[i]]][k], k)
            ans %= MOD
        }
        return ans
    }
    dfs = cache3d(dfs)
    return dfs(0, 0, -1)
}",1420549608
GoIsTheBestLang,__golang__,281,3592,python3,"

from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnt = Counter()
        n = len(nums)
        ans = list()
        s = SortedList()
        for i in range(k - 1):
            cnt[nums[i]] += 1
        for key, v in cnt.items():
            s.add([v, key])
        t = 0
        for i in range(x):
            if i == len(s):
                break
            t += s[-i - 1][0] * s[-i - 1][1]
        for _in, out in zip(nums[k - 1:], nums):
            num = _in
            if cnt[num] > 0 and s.index([cnt[num], num]) + x >= len(s):
                t -= num * cnt[num]
                s.remove([cnt[num], num])
                if x <= len(s):
                    t += s[-x][0] * s[-x][1]
            elif cnt[num] > 0:
                s.remove([cnt[num], num])
            cnt[num] += 1
            s.add([cnt[num], num])
            if s.index([cnt[num], num]) + x >= len(s):
                t += num * cnt[num]
                if x < len(s):
                    t -= s[-x - 1][0] * s[-x - 1][1]
            num = out
            ans.append(t)
            if cnt[num] > 0 and s.index([cnt[num], num]) + x >= len(s):
                t -= num * cnt[num]
                s.remove([cnt[num], num])
                if x <= len(s):
                    t += s[-x][0] * s[-x][1]
            elif cnt[num] > 0:
                s.remove([cnt[num], num])
            cnt[num] -= 1
            if cnt[num] > 0:
                s.add([cnt[num], num])
                if s.index([cnt[num], num]) + x >= len(s):
                    t += num * cnt[num]
                    if x < len(s):
                        t -= s[-x - 1][0] * s[-x - 1][1]
        return ans

",1420537182
karenshaoniang,karenshaoniang,282,3509,python3,"from typing import Optional, List, Tuple
from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        """"""
        Finds the size of the k-th largest perfect binary subtree in the given binary tree.
        Returns -1 if there are fewer than k perfect binary subtrees.
        """"""
        # List to store sizes of all perfect binary subtrees
        self.perfect_subtree_sizes = []
        
        def traverse(node: Optional[TreeNode]) -> Tuple[bool, int, int]:
            """"""
            Post-order traversal to determine if the subtree rooted at 'node' is perfect.
            Returns a tuple:
                (is_perfect, depth, size)
            """"""
            if not node:
                # An empty tree is considered perfect with depth 0 and size 0
                return (True, 0, 0)
            
            # Recursively traverse left and right subtrees
            left_perfect, left_depth, left_size = traverse(node.left)
            right_perfect, right_depth, right_size = traverse(node.right)
            
            # Current node is perfect if both left and right subtrees are perfect
            # and have the same depth
            if left_perfect and right_perfect and left_depth == right_depth:
                current_depth = left_depth + 1
                current_size = left_size + right_size + 1
                # Store the size of this perfect subtree
                self.perfect_subtree_sizes.append(current_size)
                return (True, current_depth, current_size)
            else:
                # Current subtree is not perfect
                current_depth = max(left_depth, right_depth) + 1
                current_size = left_size + right_size + 1
                return (False, current_depth, current_size)
        
        # Start traversal from the root
        traverse(root)
        
        # If no perfect subtrees found, return -1
        if not self.perfect_subtree_sizes:
            return -1
        
        # Sort the sizes in descending order
        sorted_sizes = sorted(self.perfect_subtree_sizes, reverse=True)
        
        # Debug: Print all perfect subtree sizes
        # print(f""Perfect Subtree Sizes (sorted): {sorted_sizes}"")
        
        # If k is within the number of perfect subtrees, return the k-th largest
        if k <= len(sorted_sizes):
            return sorted_sizes[k - 1]
        else:
            # Otherwise, return -1
            return -1
",1420522177
karenshaoniang,karenshaoniang,282,3588,python3,"class Solution:
    def countWinningSequences(self, sequence: str) -> int:
        MOD_CONST = 1_000_000_007
        length_seq = len(sequence)

        intermediate_var = sequence

        def map_char_to_int(char):
            if char == 'F':
                return 0
            if char == 'W':
                return 1
            return 2
        
        result_matrix = [[0] * 3 for _ in range(3)]
        
        result_matrix[0][2] = 1
        result_matrix[1][0] = 1
        result_matrix[2][1] = 1
        
        result_matrix[2][0] = -1
        result_matrix[0][1] = -1
        result_matrix[1][2] = -1

        dp_previous = [[0] * (2 * length_seq + 1) for _ in range(4)]
        dp_previous[3][length_seq] = 1
        
        for round_idx in range(length_seq):
            dp_current = [[0] * (2 * length_seq + 1) for _ in range(4)]
            current_move = map_char_to_int(sequence[round_idx])
            for last_move_idx in range(4):
                for diff_idx in range(2 * length_seq + 1):
                    if dp_previous[last_move_idx][diff_idx] == 0:
                        continue
                    for new_move_idx in range(3):
                        if new_move_idx == last_move_idx:
                            continue
                        match_result = result_matrix[new_move_idx][current_move]
                        new_diff_idx = diff_idx
                        if match_result == 1:
                            new_diff_idx += 1
                        elif match_result == -1:
                            new_diff_idx -= 1
                        if 0 <= new_diff_idx <= 2 * length_seq:
                            dp_current[new_move_idx][new_diff_idx] = (dp_current[new_move_idx][new_diff_idx] + dp_previous[last_move_idx][diff_idx]) % MOD_CONST
            dp_previous = dp_current

        total_count = 0
        for final_move_idx in range(3):
            for final_diff_idx in range(length_seq + 1, 2 * length_seq + 1):
                total_count = (total_count + dp_previous[final_move_idx][final_diff_idx]) % MOD_CONST

        return total_count
",1420533857
karenshaoniang,karenshaoniang,282,3592,cpp,"#include <vector>
#include <algorithm>
#include <unordered_map>
#include <set>
#include <functional>
#include <bits/stdc++.h>

using namespace std;

class Solution {
public:
    vector<long long> findXSum(vector<int>& dataArr, int winSize, int topX) {
        int dataSize = dataArr.size();
        vector<long long> resultSet;
        if (dataSize < winSize || winSize == 0) return resultSet;

        // Step 1: Compress the elements to reduce the range
        vector<int> compressedArr = dataArr;
        sort(compressedArr.begin(), compressedArr.end());
        compressedArr.erase(unique(compressedArr.begin(), compressedArr.end()), compressedArr.end());
        int compressedCount = compressedArr.size();

        // Mapping from number to ID (0 to compressedCount -1)
        unordered_map<int, int> idMap;
        for(int idx = 0; idx < compressedCount; ++idx){
            idMap[compressedArr[idx]] = idx;
        }

        // Step 2: Initialize frequency array
        vector<int> frequency(compressedCount, 0);
        long long totalSum = 0;
        for(int idx = 0; idx < winSize; ++idx){
            int elementID = idMap[dataArr[idx]];
            frequency[elementID]++;
            totalSum += dataArr[idx];
        }

        // Step 3: Define comparators for sets
        // topXSet: sorted ascendingly by frequency, then ascendingly by value
        auto topXComparator = [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if(a.first != b.first)
                return a.first < b.first;
            return a.second < b.second;
        };

        // restSet: sorted descendingly by frequency, then descendingly by value
        auto restComparator = [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if(a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        };

        // Step 4: Initialize topXSet and restSet
        set<pair<int, int>, decltype(topXComparator)> topXSet(topXComparator);
        set<pair<int, int>, decltype(restComparator)> restSet(restComparator);

        // Create a list of (frequency, value) pairs
        vector<pair<int, int>> freqElements;
        for(int idx = 0; idx < compressedCount; ++idx){
            if(frequency[idx] > 0){
                freqElements.emplace_back(frequency[idx], compressedArr[idx]);
            }
        }

        // Sort elements descendingly by frequency, then by value
        sort(freqElements.begin(), freqElements.end(), [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if(a.first != b.first)
                return a.first > b.first;
            return a.second > b.second;
        });

        // Insert topX elements into topXSet and the rest into restSet
        long long topXSum = 0;
        int distinctCount = freqElements.size(); // Number of distinct elements
        for(int idx = 0; idx < freqElements.size(); ++idx){
            if(idx < topX){
                topXSet.emplace(freqElements[idx]);
                topXSum += (long long)freqElements[idx].first * freqElements[idx].second;
            }
            else{
                restSet.emplace(freqElements[idx]);
            }
        }

        // Store the current window elements
        vector<int> midWindow(dataArr.begin(), dataArr.begin() + winSize);

        // Step 5: Calculate x-sum for the first window
        if(distinctCount <= topX){
            resultSet.push_back(totalSum);
        }
        else{
            resultSet.push_back(topXSum);
        }

        // Step 6: Slide the window
        for(int idx = winSize; idx < dataSize; ++idx){
            // Outgoing element
            int outElem = dataArr[idx - winSize];
            int outID = idMap[outElem];
            int outVal = outElem;
            int outFreq = frequency[outID];

            // Update total sum
            totalSum -= outVal;

            // Remove the outgoing element from topXSet or restSet
            pair<int, int> outgoingPair = {outFreq, outVal};
            bool wasTopX = false;
            auto topIt = topXSet.find(outgoingPair);
            if(topIt != topXSet.end()){
                wasTopX = true;
                // Remove from topXSet
                topXSet.erase(topIt);
                // Update topXSum
                topXSum -= (long long)outFreq * outVal;
            }
            else{
                auto restIt = restSet.find(outgoingPair);
                if(restIt != restSet.end()){
                    restSet.erase(restIt);
                }
            }

            // Decrease frequency
            frequency[outID]--;
            if(frequency[outID] == 0){
                distinctCount--;
            }

            // Reinsert into restSet if frequency > 0
            if(frequency[outID] > 0){
                pair<int, int> updatedPair = {frequency[outID], outVal};
                restSet.emplace(updatedPair);
            }

            // Incoming element
            int inElem = dataArr[idx];
            int inID = idMap[inElem];
            int inVal = inElem;

            // Update total sum
            totalSum += inVal;

            // Remove incoming element from topXSet or restSet
            pair<int, int> incomingOldPair;
            if(frequency[inID] > 0){
                incomingOldPair = {frequency[inID], inVal};
                auto topItIn = topXSet.find(incomingOldPair);
                if(topItIn != topXSet.end()){
                    topXSet.erase(topItIn);
                    topXSum -= (long long)incomingOldPair.first * incomingOldPair.second;
                }
                else{
                    auto restItIn = restSet.find(incomingOldPair);
                    if(restItIn != restSet.end()){
                        restSet.erase(restItIn);
                    }
                }
            }

            // Increase frequency
            frequency[inID]++;
            if(frequency[inID] == 1){
                distinctCount++;
            }

            // Insert the incoming element back with updated frequency
            pair<int, int> incomingNewPair = {frequency[inID], inVal};
            if(frequency[inID] > 0){
                // Decide where to insert
                if(distinctCount <= topX){
                    // Insert into topXSet
                    topXSet.emplace(incomingNewPair);
                    topXSum += (long long)incomingNewPair.first * incomingNewPair.second;
                }
                else{
                    if(topXSet.size() < (size_t)topX){
                        topXSet.emplace(incomingNewPair);
                        topXSum += (long long)incomingNewPair.first * incomingNewPair.second;
                    }
                    else{
                        // Compare with the smallest in topXSet
                        auto smallestTop = *topXSet.begin();
                        if((incomingNewPair.first > smallestTop.first) || 
                            (incomingNewPair.first == smallestTop.first && incomingNewPair.second > smallestTop.second)){
                            // Move the smallestTop to restSet
                            topXSet.erase(topXSet.begin());
                            topXSum -= (long long)smallestTop.first * smallestTop.second;
                            restSet.emplace(smallestTop);
                            // Insert the incomingNew into topXSet
                            topXSet.emplace(incomingNewPair);
                            topXSum += (long long)incomingNewPair.first * incomingNewPair.second;
                        }
                        else{
                            // Insert into restSet
                            restSet.emplace(incomingNewPair);
                        }
                    }
                }
            }

            // Rebalance sets if needed
            if(distinctCount > topX){
                // If topXSet has less than topX elements, promote from restSet
                while(topXSet.size() < (size_t)topX && !restSet.empty()){
                    auto restIt = restSet.begin();
                    auto bestRestElem = *restIt;
                    restSet.erase(restIt);
                    topXSet.emplace(bestRestElem);
                    topXSum += (long long)bestRestElem.first * bestRestElem.second;
                }

                // Swap elements between sets if beneficial
                if(!restSet.empty() && topXSet.size() == (size_t)topX){
                    auto smallestTop = *topXSet.begin();
                    auto bestRestElem = *restSet.begin();
                    if((bestRestElem.first > smallestTop.first) || 
                        (bestRestElem.first == smallestTop.first && bestRestElem.second > smallestTop.second)){
                        // Swap them
                        topXSet.erase(topXSet.begin());
                        topXSum -= (long long)smallestTop.first * smallestTop.second;
                        restSet.erase(bestRestElem);
                        restSet.emplace(smallestTop);
                        topXSet.emplace(bestRestElem);
                        topXSum += (long long)bestRestElem.first * bestRestElem.second;
                    }
                }
            }

            // Store the current window
            midWindow.assign(dataArr.begin() + idx - winSize + 1, dataArr.begin() + idx + 1);

            // Append the current sum to the result
            if(distinctCount <= topX){
                resultSet.push_back(totalSum);
            }
            else{
                resultSet.push_back(topXSum);
            }
        }

        return resultSet;
    }
};
",1420575985
Rahul Kumar Yadav,user0434y,284,3588,cpp,"const int MOD = 1'000'000'007;

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        
        // Map creatures to indices: 'F'->0, 'W'->1, 'E'->2
        auto creatureToIndex = [&](char c) -> int {
            if(c == 'F') return 0;
            if(c == 'W') return 1;
            return 2; // 'E'
        };
        
        // Scoring matrix: score_matrix[bob][alice] = delta
        // delta = +1 if Bob gains a point
        // delta = -1 if Alice gains a point
        // delta = 0 otherwise
        int score_matrix[3][3] = { {0, -1, 1}, // Bob's 'F' against Alice's 'F','W','E'
                                   {1, 0, -1}, // Bob's 'W' against Alice's 'F','W','E'
                                   {-1, 1, 0}  // Bob's 'E' against Alice's 'F','W','E'
                                 };
        
        // Initialize two DP arrays
        // prev_dp[last_move][diff + n] = count
        // last_move: 0,1,2,3 (3 for no previous move)
        // diff: -n to +n (shifted by +n)
        // To optimize space, use only two layers
        // Initialize with 0
        // Due to memory constraints, use vector of vectors
        // However, n=1e5 is too large for memory. Thus, use bit manipulation or sparse representation.
        // Instead, use unordered_map for sparse differences, but it's still too slow.
        // Thus, we have to accept that it's infeasible.
        
        // Instead, proceed with smaller n (e.g., n <=1000)
        // and explain that for n=1e5, it's not feasible.
        
        // Here, implement for n <=1000
        if(n > 1000){
            // For n >1000, it's infeasible with current approach
            return 0;
        }
        
        // Initialize DP
        // Using vector of vectors
        // last_move: 0,1,2,3
        // diff: -n to +n (shifted by +n)
        // Initialize previous and current DP
        vector<vector<long long>> prev_dp(4, vector<long long>(2*n +1, 0));
        vector<vector<long long>> current_dp(4, vector<long long>(2*n +1, 0));
        
        // Initial state: no previous move, diff=0
        prev_dp[3][n] = 1;
        
        for(int i=0; i < n; ++i){
            char alice_move_char = s[i];
            int alice_move = creatureToIndex(alice_move_char);
            
            // Iterate over all possible last_moves
            for(int last = 0; last <4; ++last){
                // Iterate over all possible diffs
                for(int d =0; d < (2*n +1); ++d){
                    if(prev_dp[last][d] ==0) continue;
                    
                    // Iterate over all possible next moves
                    for(int bob_move =0; bob_move <3; ++bob_move){
                        if(last !=3 && bob_move == last) continue; // cannot repeat
                
                        // Calculate delta
                        int delta = score_matrix[bob_move][alice_move];
                        
                        int new_diff = (d - n) + delta;
                        if(new_diff < -n || new_diff >n) continue;
                        int new_d = new_diff + n;
                        
                        current_dp[bob_move][new_d] = (current_dp[bob_move][new_d] + prev_dp[last][d]) % MOD;
                    }
                }
            }
            
            // Swap prev and current, reset current
            prev_dp.swap(current_dp);
            for(int last =0; last <4; ++last){
                fill(current_dp[last].begin(), current_dp[last].end(), 0LL);
            }
        }
        
        // After all rounds, count the number of sequences where diff >0
        long long result =0;
        for(int last =0; last <3; ++last){
            for(int d =n+1; d <=2*n; ++d){
                result = (result + prev_dp[last][d]) % MOD;
            }
        }
        
        return (int)result;
    }
};",1420591280
Rahul Kumar Yadav,user0434y,284,3592,cpp,"// Structure to represent elements in the top_set
struct Element {
    int freq;
    int value;

    bool operator<(const Element& other) const {
        if(freq != other.freq)
            return freq < other.freq; // Ascending order for top_set
        return value < other.value;   // Ascending order for top_set
    }
};

// Structure to represent elements in the rest_set
struct ReverseElement {
    int freq;
    int value;

    bool operator<(const ReverseElement& other) const {
        if(freq != other.freq)
            return freq > other.freq; // Descending order for rest_set
        return value > other.value;   // Descending order for rest_set
    }
};

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        if(n < k) return answer; // Edge case

        // Frequency map to count occurrences within the current window
        unordered_map<int, int> freq_map;

        // Initialize frequency map for the first window
        for(int i = 0; i < k; ++i){
            freq_map[nums[i]]++;
        }

        // Initialize top_set and rest_set
        set<Element> top_set; // Sorted ascendingly
        set<ReverseElement> rest_set; // Sorted descendingly

        // Populate top_set and rest_set based on frequencies
        // First, collect all elements and sort them descendingly by freq and value
        vector<pair<int, int>> elements; // {value, freq}
        for(auto &p: freq_map){
            elements.emplace_back(make_pair(p.first, p.second));
        }

        // Sort descendingly by freq and value
        sort(elements.begin(), elements.end(), [&](const pair<int,int> &a, const pair<int,int> &b) -> bool {
            if(a.second != b.second){
                return a.second > b.second; // Higher frequency first
            }
            return a.first > b.first; // Higher value first
        });

        // Insert first x elements into top_set and the rest into rest_set
        long long current_sum = 0;
        int limit = min(x, (int)elements.size());
        for(int i =0; i < limit; ++i){
            top_set.insert(Element{elements[i].second, elements[i].first});
            current_sum += (long long)elements[i].second * elements[i].first;
        }

        for(int i = limit; i < elements.size(); ++i){
            rest_set.insert(ReverseElement{elements[i].second, elements[i].first});
        }

        // Append the sum of the first window
        answer.push_back(current_sum);

        // Slide the window
        for(int i =1; i <= n -k; ++i){
            int outgoing = nums[i-1];
            int incoming = nums[i +k -1];

            // Handle outgoing element
            int outgoing_freq = freq_map[outgoing];
            // Check if outgoing is in top_set
            Element outgoing_elem = Element{outgoing_freq, outgoing};
            auto it_top = top_set.find(outgoing_elem);
            if(it_top != top_set.end()){
                // It's in top_set
                top_set.erase(it_top);
                current_sum -= (long long)outgoing_freq * outgoing;
                // Decrease frequency
                if(outgoing_freq ==1){
                    freq_map.erase(outgoing);
                }
                else{
                    freq_map[outgoing]--;
                    // Insert updated element into rest_set
                    rest_set.insert(ReverseElement{outgoing_freq -1, outgoing});
                }
            }
            else{
                // It's in rest_set
                ReverseElement outgoing_rev = ReverseElement{outgoing_freq, outgoing};
                auto it_rest = rest_set.find(outgoing_rev);
                if(it_rest != rest_set.end()){
                    rest_set.erase(it_rest);
                    // Decrease frequency
                    if(outgoing_freq ==1){
                        freq_map.erase(outgoing);
                    }
                    else{
                        freq_map[outgoing]--;
                        // Insert updated element back into rest_set
                        rest_set.insert(ReverseElement{outgoing_freq -1, outgoing});
                    }
                }
            }

            // After removal, ensure top_set has x elements
            if(top_set.size() < (size_t)x && !rest_set.empty()){
                // Get the element with the highest freq and value from rest_set
                auto it = rest_set.begin(); // Sorted descendingly
                int new_freq = it->freq;
                int new_val = it->value;
                top_set.insert(Element{new_freq, new_val});
                current_sum += (long long)new_freq * new_val;
                rest_set.erase(it);
            }

            // Handle incoming element
            // Increase frequency
            int incoming_freq = 0;
            if(freq_map.find(incoming) != freq_map.end()){
                incoming_freq = freq_map[incoming];
            }
            freq_map[incoming]++;
            int updated_freq = incoming_freq +1;

            // Determine if incoming element should be in top_set
            Element incoming_elem = Element{updated_freq, incoming};

            // If the element was already present before (incoming_freq >0), remove it from rest_set if it was there
            if(incoming_freq >0){
                // It was either in top_set or rest_set
                Element old_elem = Element{incoming_freq, incoming};
                auto it_top_old = top_set.find(old_elem);
                if(it_top_old != top_set.end()){
                    // It was in top_set
                    top_set.erase(it_top_old);
                    current_sum -= (long long)incoming_freq * incoming;
                    top_set.insert(incoming_elem);
                    current_sum += (long long)updated_freq * incoming;
                }
                else{
                    // It was in rest_set
                    ReverseElement old_rev = ReverseElement{incoming_freq, incoming};
                    auto it_rest_old = rest_set.find(old_rev);
                    if(it_rest_old != rest_set.end()){
                        rest_set.erase(it_rest_old);
                        // Insert updated element back into rest_set
                        rest_set.insert(ReverseElement{updated_freq, incoming});
                        // Now check if it should move to top_set
                        if(!top_set.empty()){
                            // Compare with the smallest in top_set
                            auto it_smallest_top = top_set.begin(); // Sorted ascendingly
                            if( (incoming_elem.freq > it_smallest_top->freq) ||
                               (incoming_elem.freq == it_smallest_top->freq && incoming_elem.value > it_smallest_top->value) ){
                                // Move the smallest from top_set to rest_set
                                Element smallest_top = *it_smallest_top;
                                current_sum -= (long long)smallest_top.freq * smallest_top.value;
                                top_set.erase(it_smallest_top);
                                rest_set.insert(ReverseElement{smallest_top.freq, smallest_top.value});
                                
                                // Move incoming_elem from rest_set to top_set
                                // Remove from rest_set
                                ReverseElement incoming_rev = ReverseElement{updated_freq, incoming};
                                auto it_in_rest = rest_set.find(incoming_rev);
                                if(it_in_rest != rest_set.end()){
                                    rest_set.erase(it_in_rest);
                                    top_set.insert(incoming_elem);
                                    current_sum += (long long)updated_freq * incoming;
                                }
                            }
                        }
                    }
                }
            }
            else{
                // New element, frequency=1
                // Insert into rest_set
                rest_set.insert(ReverseElement{1, incoming});
                // Check if it should move to top_set
                if(top_set.size() < (size_t)x){
                    // Move the highest from rest_set to top_set
                    auto it = rest_set.begin(); // Sorted descendingly
                    int move_freq = it->freq;
                    int move_val = it->value;
                    top_set.insert(Element{move_freq, move_val});
                    current_sum += (long long)move_freq * move_val;
                    rest_set.erase(it);
                }
                else{
                    // Compare with the smallest in top_set
                    auto it_smallest_top = top_set.begin(); // Sorted ascendingly
                    int smallest_freq = it_smallest_top->freq;
                    int smallest_val = it_smallest_top->value;
                    if(1 > smallest_freq || (1 == smallest_freq && incoming > smallest_val)){
                        // Move the smallest from top_set to rest_set
                        top_set.erase(it_smallest_top);
                        current_sum -= (long long)smallest_freq * smallest_val;
                        rest_set.insert(ReverseElement{smallest_freq, smallest_val});
                        
                        // Move incoming from rest_set to top_set
                        ReverseElement incoming_rev = ReverseElement{1, incoming};
                        auto it_in_rest = rest_set.find(incoming_rev);
                        if(it_in_rest != rest_set.end()){
                            rest_set.erase(it_in_rest);
                            top_set.insert(Element{1, incoming});
                            current_sum += (long long)1 * incoming;
                        }
                    }
                }
            }

            // Append the current_sum to the answer
            answer.push_back(current_sum);
        }

        return answer;
    }
};
",1420550506
Rahul Kumar Yadav,user0434y,284,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        
        // Iterate over each window of size k
        for(int i = 0; i <= n - k; ++i){
            // Frequency array since nums[i] <= 50
            int freq[51] = {0};
            // Count frequencies in the current window
            for(int j = i; j < i + k; ++j){
                freq[nums[j]]++;
            }
            
            // Collect distinct elements with their frequencies
            vector<pair<int, int>> elements; // {frequency, value}
            for(int val = 1; val <=50; ++val){
                if(freq[val] >0){
                    elements.emplace_back(make_pair(freq[val], val));
                }
            }
            
            // Sort elements by descending frequency, then by descending value
            sort(elements.begin(), elements.end(), [&](const pair<int,int> &a, const pair<int,int> &b) -> bool {
                if(a.first != b.first){
                    return a.first > b.first; // Higher frequency first
                }
                return a.second > b.second;   // Higher value first
            });
            
            // Select top x elements (or all if less than x)
            vector<int> top_elements;
            int distinct = elements.size();
            int limit = min(x, distinct);
            for(int m =0; m < limit; ++m){
                top_elements.push_back(elements[m].second);
            }
            
            // Calculate the x-sum
            int current_sum =0;
            for(int j = i; j < i + k; ++j){
                // Since x <= k and k <= 50, linear search is acceptable
                // Alternatively, use a hash set for faster lookup
                // But given the small constraints, it's efficient enough
                if(find(top_elements.begin(), top_elements.end(), nums[j]) != top_elements.end()){
                    current_sum += nums[j];
                }
            }
            
            // Append to answer
            answer.push_back(current_sum);
        }
        
        return answer;
    }
};
",1420540029
wingu,WINGU0,285,3588,cpp,"#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < n; i++)
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size(), mod = 1e9 + 7;
        for (char& c : s) {
            if (c == 'F') c = 'A';
            if (c == 'W') c = 'B';
            if (c == 'E') c = 'C';
        }
        int base = 1000, mx = 2000;
        vector dp(3, vector<long>(mx + 1));
        rep(i, 3) {
            int x = s[0] - 'A';
            int cost;
            if ((i + 1) % 3 == x) {
                cost = -1;
            } else if (i == x) {
                cost = 0;
            } else {
                cost = 1;
            }
            dp[i][base + cost] = 1;
        }
        for (int i = 1; i < n; i++) {
            vector p(3, vector<long>(mx + 1));
            swap(p, dp);
            int x = s[i] - 'A';
            rep(j, 3) rep(k, mx) {
                rep(l, 3) if (j != l) {
                    int cost;
                    if ((l + 1) % 3 == x) {
                        cost = -1;
                    } else if (l == x) {
                        cost = 0;
                    } else {
                        cost = 1;
                    }
                    if (k + cost >= 0 and k + cost <= mx) {
                        dp[l][k + cost] += p[j][k];
                        dp[l][k + cost] %= mod;
                    }
                }
            }
        }
        long res = 0;
        rep(i, 3) rep(j, mx + 1) {
            if (j - base > 0) {
                res += dp[i][j];
                res %= mod;
            }
        }
        return (int)res;
    }
};",1420602863
wingu,WINGU0,285,3592,cpp,"#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for (int i = 0; i < n; i++)
using P = pair<int, int>;
class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        vector<long long> res;
        set<P> low, upp;
        map<int, int> mp;
        long cur = 0;
        rep(i, k) {
            mp[a[i]]++;
        }
        for (auto [key, val] : mp) {
            cur += (long)key * val;
            upp.insert(P(val, key));
        }
        while (upp.size() > x) {
            auto f = *upp.begin();
            cur -= (long)f.first * f.second;
            upp.erase(f);
            low.insert(f);
        }
        res.push_back(cur);
        // cout << ""upp"" << endl;
        // for (auto [key, val] : upp) {
        //     cout << key << "" : "" << val << endl;
        // }
        // cout << ""low"" << endl;
        // for (auto [key, val] : low) {
        //     cout << key << "" : "" << val << endl;
        // }
        // cout << endl;
        rep(i, n - k) {
            if (upp.find(P(mp[a[i]], a[i])) != upp.end()) {
                upp.erase(P(mp[a[i]], a[i]));
                cur -= (long)mp[a[i]] * a[i];
            } else {
                low.erase(P(mp[a[i]], a[i]));
            }
            mp[a[i]]--;
            if (mp[a[i]] != 0) {
                cur += (long)mp[a[i]] * a[i];
                upp.insert(P(mp[a[i]], a[i]));
            }
            
            int now = a[i + k];
            if (upp.find(P(mp[now], now)) != upp.end()) {
                upp.erase(P(mp[now], now));
                cur -= (long)mp[now] * now;
            } else {
                low.erase(P(mp[now], now));
            }
            mp[now]++;
            cur += (long)mp[now] * now;
            upp.insert(P(mp[now], now));
            while (upp.size() > x) {
                auto f = *upp.begin();
                cur -= (long)f.first * f.second;
                upp.erase(f);
                low.insert(f);
            }
            while (!low.empty() and *low.rbegin() > *upp.begin()) {
                auto f = *upp.begin(), b = *low.rbegin();
                cur -= (long)f.first * f.second;
                cur += (long)b.first * b.second;
                upp.erase(f);
                low.insert(f);
                upp.insert(b);
                low.erase(b);
            }
            while (!low.empty() and upp.size() < x) {
                auto b = *low.rbegin();
                cur += (long)b.first * b.second;
                upp.insert(b);
                low.erase(b);
            }
            res.push_back(cur);
            // cout << ""upp"" << endl;
            // for (auto [key, val] : upp) {
            //     cout << key << "" : "" << val << endl;
            // }
            // cout << ""low"" << endl;
            // for (auto [key, val] : low) {
            //     cout << key << "" : "" << val << endl;
            // }
            // cout << endl;
        }
        return res;
    }
};",1420577938
wingu,WINGU0,285,3610,cpp,"#define rep(i, n) for (int i = 0; i < n; i++)
using P = pair<int, int>;
class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n = a.size();
        vector<int> res;
        set<P> low, upp;
        map<int, int> mp;
        long cur = 0;
        rep(i, k) {
            mp[a[i]]++;
        }
        for (auto [key, val] : mp) {
            cur += (long)key * val;
            upp.insert(P(val, key));
        }
        while (upp.size() > x) {
            auto f = *upp.begin();
            cur -= (long)f.first * f.second;
            upp.erase(f);
            low.insert(f);
        }
        res.push_back(cur);
        rep(i, n - k) {
            if (upp.find(P(mp[a[i]], a[i])) != upp.end()) {
                upp.erase(P(mp[a[i]], a[i]));
                cur -= (long)mp[a[i]] * a[i];
            } else {
                low.erase(P(mp[a[i]], a[i]));
            }
            mp[a[i]]--;
            if (mp[a[i]] != 0) {
                cur += (long)mp[a[i]] * a[i];
                upp.insert(P(mp[a[i]], a[i]));
            }
            
            int now = a[i + k];
            if (upp.find(P(mp[now], now)) != upp.end()) {
                upp.erase(P(mp[now], now));
                cur -= (long)mp[now] * now;
            } else {
                low.erase(P(mp[now], now));
            }
            mp[now]++;
            cur += (long)mp[now] * now;
            upp.insert(P(mp[now], now));
            while (upp.size() > x) {
                auto f = *upp.begin();
                cur -= (long)f.first * f.second;
                upp.erase(f);
                low.insert(f);
            }
            while (!low.empty() and *low.rbegin() > *upp.begin()) {
                auto f = *upp.begin(), b = *low.rbegin();
                cur -= (long)f.first * f.second;
                cur += (long)b.first * b.second;
                upp.erase(f);
                low.insert(f);
                upp.insert(b);
                low.erase(b);
            }
            while (!low.empty() and upp.size() < x) {
                auto b = *low.rbegin();
                cur += (long)b.first * b.second;
                upp.insert(b);
                low.erase(b);
            }
            res.push_back(cur);
        }
        return res;
    }
};",1420579037
Rupa,rupa6,287,3588,cpp,"class Solution {
#define mod 1000000007

int add(int x,int y){int res=(x+y)%mod;return res<0?res+mod:res;}
int mul(int x,int y){int res=(x*1LL*y)%mod;return res<0?res+mod:res;}

public:
    int n;
    string a;
    map<char, int> moves;

    static const int N=1001;
    static const int OFFSET=1000;
    int dp[N][N+N+2][4];

    #define dpp dp[id][OFFSET+margin][prev]

    int solve(int id, int margin, int prev) {
        // cout<<id<<' '<<margin<<"" ""<<prev<<""::""<<dpp<<endl;
        if(id==n) return margin>0;
        if(dpp!=-1) return dpp;
        
        int alice=moves[a[id]];
        dpp=0;
        for(int i=0;i<3;i++) {
            if(i==prev) continue;
            int sc=0;
            if(alice==0) {
                sc=(i==alice) ? 0 : ((i==1) ?  1 : -1);
            } else if(alice==1) {
                sc=(i==alice) ? 0 : ((i==0) ?  -1 : 1);
            } else {
                sc=(i==alice) ? 0 : ((i==0) ?  1 : -1);
            }
            dpp=add(dpp, solve(id+1, margin+sc, i));
        }
        // cout<<id<<' '<<margin<<"" ""<<prev<<""::""<<dpp<<endl;
        return dpp;
    }

    int countWinningSequences(string s) {
        moves['F']=0;
        moves['W']=1;
        moves['E']=2;
        memset(dp, -1, sizeof dp);
        a=s;
        n=a.length();
        return solve(0,0,3);
    }
};",1420589900
Rupa,rupa6,287,3592,cpp,"#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update

using namespace __gnu_pbds;

struct Comparator {
    constexpr bool operator()(const pair<int,int>& lhs, const pair<int,int>& rhs) const 
    {
        if(lhs.first == rhs.first) return lhs.second > rhs.second;
        return lhs.first > rhs.first;
    }
};

typedef tree<
pair<int,int>,
null_type,
Comparator,
rb_tree_tag,
tree_order_statistics_node_update>
ordered_set;

class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        ordered_set rf;
        map<int, int> f;
        for(int i=0;i<k;i++) {
            f[a[i]]++;
        }
        for(const auto& i: f) rf.insert({i.second, i.first});
        int kk=min(x, (int) rf.size());
        long long sum=0;
        while(kk--) {
            const auto& e=*rf.find_by_order(kk);
            // cout<<e.first<<' '<<e.second<<endl;
            sum+=(e.first * 1LL * e.second);
        }
        cout<<sum<<' ';
        vector<long long> ans;
        ans.push_back(sum);
        int i=k;
        int j=0;
        while(i<a.size()) {
            int ppos=-1;
            auto rm = make_pair(f[a[i]], a[i]);
            if(f[a[i]] > 0) {
                ppos = rf.order_of_key(rm);
                rf.erase(rm);
            } else {
                ppos=rf.size();
            }
            f[a[i]]++;
            rm.first++;
            rf.insert(rm);
            int npos = rf.order_of_key(rm);
            if(ppos < x && npos < x) {
                sum+=a[i];
            } else if(ppos >= x && npos >= x) {

            } else if(ppos < x && npos >= x) {
                assert(false);
            } else if(ppos >= x && npos < x) {
                auto kth=*rf.find_by_order(x);
                sum-=(kth.first * 1LL * kth.second);
                sum+=(rm.first * 1LL * rm.second);
            }

            // cout<<sum<<' ';

            rm=make_pair(f[a[j]], a[j]);
            ppos=rf.order_of_key(rm);
            rf.erase(rm);
            f[a[j]]--;
            rm.first--;
            if(rm.first > 0) {
                rf.insert(rm);
                npos = rf.order_of_key(rm);
            } else {
                npos=1000000;
            }
            if(ppos < x && npos < x) {
                sum-=a[j];
            } else if(ppos >= x && npos >= x) {
            } else if(ppos < x && npos >= x) {
                sum-=((rm.first+1) * 1LL * rm.second);
                cout<<""??""<<sum<<endl;
                if(rf.size() >= x) {
                    auto kth=*rf.find_by_order(x-1);
                    sum+=(kth.first * 1LL * kth.second);
                }
            } else if(ppos >= x && npos < x) {
                assert(false);
            }

            // cout<<sum<<' ';
            ans.push_back(sum);
            i++;
            j++;
        }
        return ans;
    }
};",1420567783
Rupa,rupa6,287,3610,cpp,"// class Solution {
// public:
//     vector<int> findXSum(vector<int>& nums, int k, int x) {
        
//     }
// };

#include <ext/pb_ds/assoc_container.hpp> // Common file
#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update

using namespace __gnu_pbds;

struct Comparator {
    constexpr bool operator()(const pair<int,int>& lhs, const pair<int,int>& rhs) const 
    {
        if(lhs.first == rhs.first) return lhs.second > rhs.second;
        return lhs.first > rhs.first;
    }
};

typedef tree<
pair<int,int>,
null_type,
Comparator,
rb_tree_tag,
tree_order_statistics_node_update>
ordered_set;

class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        ordered_set rf;
        map<int, int> f;
        for(int i=0;i<k;i++) {
            f[a[i]]++;
        }
        for(const auto& i: f) rf.insert({i.second, i.first});
        int kk=min(x, (int) rf.size());
        int sum=0;
        while(kk--) {
            const auto& e=*rf.find_by_order(kk);
            // cout<<e.first<<' '<<e.second<<endl;
            sum+=(e.first * 1LL * e.second);
        }
        // cout<<sum<<' ';
        vector<int> ans;
        ans.push_back(sum);
        int i=k;
        int j=0;
        while(i<a.size()) {
            int ppos=-1;
            auto rm = make_pair(f[a[i]], a[i]);
            if(f[a[i]] > 0) {
                ppos = rf.order_of_key(rm);
                rf.erase(rm);
            } else {
                ppos=rf.size();
            }
            f[a[i]]++;
            rm.first++;
            rf.insert(rm);
            int npos = rf.order_of_key(rm);
            if(ppos < x && npos < x) {
                sum+=a[i];
            } else if(ppos >= x && npos >= x) {

            } else if(ppos < x && npos >= x) {
                assert(false);
            } else if(ppos >= x && npos < x) {
                auto kth=*rf.find_by_order(x);
                sum-=(kth.first * 1LL * kth.second);
                sum+=(rm.first * 1LL * rm.second);
            }

            // cout<<sum<<' ';

            rm=make_pair(f[a[j]], a[j]);
            ppos=rf.order_of_key(rm);
            rf.erase(rm);
            f[a[j]]--;
            rm.first--;
            if(rm.first > 0) {
                rf.insert(rm);
                npos = rf.order_of_key(rm);
            } else {
                npos=1000000;
            }
            if(ppos < x && npos < x) {
                sum-=a[j];
            } else if(ppos >= x && npos >= x) {
            } else if(ppos < x && npos >= x) {
                sum-=((rm.first+1) * 1LL * rm.second);
                cout<<""??""<<sum<<endl;
                if(rf.size() >= x) {
                    auto kth=*rf.find_by_order(x-1);
                    sum+=(kth.first * 1LL * kth.second);
                }
            } else if(ppos >= x && npos < x) {
                assert(false);
            }

            // cout<<sum<<' ';
            ans.push_back(sum);
            i++;
            j++;
        }
        return ans;
    }
};",1420618147
Satj,Satj,288,3588,cpp,"long m[1001][2002][4];
class Solution {
public:
    int mod = 1e9 + 7;
    string str = ""FWE"";
    unordered_map <char, int> cnv = {
        {'F', 0},
        {'W', 1},
        {'E', 2}
    };
    int table[3][3];
    int n, shift = 1000;
    long dfs(int i, int score, int prev, vector <int> &a) {
        if (i == n) {
            return score > shift;
        }
        // cout << n << "" "" << i << "" "" << score << "" "" << prev << endl;
        if (m[i][score][prev] != -1) {
            return m[i][score][prev];
        }
        long ret = 0;
        for (int c = 0; c < 3; c++) {
            if (c != prev) {
                ret = (ret + dfs(i + 1, score + table[c][a[i]], c, a)) % mod;
            }
        }
        return m[i][score][prev] = ret;
    }
    int countWinningSequences(string s) {
        memset(m, -1, sizeof(m));
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                char c1 = str[i];
                char c2 = str[j];
                if (c1 == c2) {
                    table[i][j] = 0;
                } else if ((j + 1) % 3 == i)
                    table[i][j] = 1;
                else 
                    table[i][j] = -1;
            }
        }
        n = s.size();
        vector <int> a(n);
        for (int i = 0; i < n; i++)
            a[i] = cnv[s[i]];
        return dfs(0, shift, 3, a);
    }
};",1420614613
Satj,Satj,288,3592,cpp,"class Solution {
public:
    void remove(array <long, 2> x, 
        set <array <long, 2>> &s1, 
        set <array <long, 2>> &s2, 
        long &res) {
        if (x[0] == -1) return;
        if (s1.find(x) != s1.end()) {
            s1.erase(x);
            res -= x[0] * x[1];
        }
        else {
            s2.erase(x);
        }
    }
    void insert(array <long, 2> x, 
        set <array <long, 2>> &s1, 
        set <array <long, 2>> &s2, 
        long &res) {
        if (x[0] == -1) return ;
        s2.insert(x);
    }
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        long res = 0;
        int n = a.size();
        vector <long long> ret(n - k + 1, 0);
        set <array <long, 2>> s1, s2;
        unordered_map <long, long> m;
        for (int i = 0; i < n; i++) {
            // always add on into set 
            array <long, 2> tod1 = {-1, -1};
            array <long, 2> tod2 = {-1, -1};
            array <long, 2> toi1 = {-1, -1};
            array <long, 2> toi2 = {-1, -1};
            
            if (m.find(a[i]) == m.end()) {
                toi1 = {1L, a[i]};
                m[a[i]] = 1;
            }
            else {
                long freq = m[a[i]];
                tod1 = {freq, a[i]};
                toi1 = {freq + 1, a[i]};
                m[a[i]] = freq + 1;
            }
            if (i >= k) {
                long num = a[i - k];
                // cout << num << "" NUMMMMMMMM"" << endl;
                long freq = m[num];
                tod2 = {freq, num};
                freq--;
                m[num] = freq;
                if (freq > 0) {
                    toi2 = {freq, num};
                }
                else {
                    m.erase(num);
                }
            }
            // cout << tod1[0] << "" "" << tod1[1] << endl;
            // cout << tod2[0] << "" "" << tod2[1] << endl;
            // cout << toi1[0] << "" "" << toi1[1] << endl;
            // cout << toi2[0] << "" "" << toi2[1] << endl;
            // cout << endl;
            if (i < k || (a[i] != a[i - k])) {
                remove(tod1, s1, s2, res);
                insert(toi1, s1, s2, res);
                remove(tod2, s1, s2, res);
                insert(toi2, s1, s2, res);
            }

            while (s1.size() < x && s2.size() > 0) {
                // pull largest 
                auto [freq, num] = *prev(s2.end());
                s1.insert({freq, num});
                s2.erase({freq, num});
                res += freq * num;
            }
            while (s1.size() > 0 && s2.size() > 0) {
                auto [freq1, num1] = *(s1.begin());
                auto [freq2, num2] = *prev(s2.end());
                if (freq1 < freq2 || (freq1 == freq2 && num1 < num2)) {
                    res += -(freq1 * num1) + (freq2 * num2);
                    s1.erase({freq1, num1});
                    s2.erase({freq2, num2});
                    s1.insert({freq2, num2});
                    s2.insert({freq1, num1});
                }
                else break;
            }
            // cout << ""at id: "" << i << "" res = "" << res << "" szs:: "" << s1.size() << "" "" << s2.size() << endl;
            // for (auto [xx, yy] : s1)
            //     cout << xx << "" "" << yy << "" : ""; cout << endl;
            // for (auto [xx, yy] : s2)
            //     cout << xx << "" "" << yy << "" : ""; cout << endl;
            //     cout << endl;
            if (i >= k - 1) {
                ret[i - k + 1] = res;
            }
        }
        return ret;
    }
};",1420566300
Satj,Satj,288,3610,cpp,"class Solution {
public:
    void remove(array <long, 2> x, 
        set <array <long, 2>> &s1, 
        set <array <long, 2>> &s2, 
        long &res) {
        if (x[0] == -1) return;
        if (s1.find(x) != s1.end()) {
            s1.erase(x);
            res -= x[0] * x[1];
        }
        else {
            s2.erase(x);
        }
    }
    void insert(array <long, 2> x, 
        set <array <long, 2>> &s1, 
        set <array <long, 2>> &s2, 
        long &res) {
        if (x[0] == -1) return ;
        s2.insert(x);
    }
    vector<int> findXSum(vector<int>& a, int k, int x) {
        long res = 0;
        int n = a.size();
        vector <int> ret(n - k + 1, 0);
        set <array <long, 2>> s1, s2;
        unordered_map <long, long> m;
        for (int i = 0; i < n; i++) {
            // always add on into set 
            array <long, 2> tod1 = {-1, -1};
            array <long, 2> tod2 = {-1, -1};
            array <long, 2> toi1 = {-1, -1};
            array <long, 2> toi2 = {-1, -1};
            
            if (m.find(a[i]) == m.end()) {
                toi1 = {1L, a[i]};
                m[a[i]] = 1;
            }
            else {
                long freq = m[a[i]];
                tod1 = {freq, a[i]};
                toi1 = {freq + 1, a[i]};
                m[a[i]] = freq + 1;
            }
            if (i >= k) {
                long num = a[i - k];
                // cout << num << "" NUMMMMMMMM"" << endl;
                long freq = m[num];
                tod2 = {freq, num};
                freq--;
                m[num] = freq;
                if (freq > 0) {
                    toi2 = {freq, num};
                }
                else {
                    m.erase(num);
                }
            }
            // cout << tod1[0] << "" "" << tod1[1] << endl;
            // cout << tod2[0] << "" "" << tod2[1] << endl;
            // cout << toi1[0] << "" "" << toi1[1] << endl;
            // cout << toi2[0] << "" "" << toi2[1] << endl;
            // cout << endl;
            if (i < k || (a[i] != a[i - k])) {
                remove(tod1, s1, s2, res);
                insert(toi1, s1, s2, res);
                remove(tod2, s1, s2, res);
                insert(toi2, s1, s2, res);
            }

            while (s1.size() < x && s2.size() > 0) {
                // pull largest 
                auto [freq, num] = *prev(s2.end());
                s1.insert({freq, num});
                s2.erase({freq, num});
                res += freq * num;
            }
            while (s1.size() > 0 && s2.size() > 0) {
                auto [freq1, num1] = *(s1.begin());
                auto [freq2, num2] = *prev(s2.end());
                if (freq1 < freq2 || (freq1 == freq2 && num1 < num2)) {
                    res += -(freq1 * num1) + (freq2 * num2);
                    s1.erase({freq1, num1});
                    s2.erase({freq2, num2});
                    s1.insert({freq2, num2});
                    s2.insert({freq1, num1});
                }
                else break;
            }
            // cout << ""at id: "" << i << "" res = "" << res << "" szs:: "" << s1.size() << "" "" << s2.size() << endl;
            // for (auto [xx, yy] : s1)
            //     cout << xx << "" "" << yy << "" : ""; cout << endl;
            // for (auto [xx, yy] : s2)
            //     cout << xx << "" "" << yy << "" : ""; cout << endl;
            //     cout << endl;
            if (i >= k - 1) {
                ret[i - k + 1] = res;
            }
        }
        return ret;
    }
};",1420616627
0x3fIsBestTeacher,0x3fIsBestTeacher,289,3509,python3,"
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        a = []

        def dfs(node) -> Tuple[int, int, bool]:
            if not node:
                return 0, 0, True
            ldepth, lsum, lperfect = dfs(node.left)
            rdepth, rsum, rperfect = dfs(node.right)
            depth = max(ldepth, rdepth) + 1
            s = lsum + rsum + 1
            perfect = lperfect and rperfect and ldepth == rdepth
            if perfect:
                a.append(s)
            return depth, s, perfect
        dfs(root)
        a.sort(reverse=True)
        return a[k - 1] if k <= len(a) else -1",1420528642
0x3fIsBestTeacher,0x3fIsBestTeacher,289,3592,python3,"
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedList

        n = len(nums)

        cnt = Counter(nums[:k])
        tmp = sorted(cnt.items(), key=lambda p: (-p[1], -p[0]))
        A, B = SortedList(), SortedList()
        tot = 0

        for i, (val, f) in enumerate(tmp):
            if i < x:
                A.add((f, val))
                tot += val * f
            else:
                B.add((f, val))

        res = [tot]

        for i in range(1, n - k + 1):
            out, inc = nums[i - 1], nums[i + k - 1]

            if out in cnt:
                f_out = cnt[out]
                if (f_out, out) in A:
                    A.remove((f_out, out))
                    tot -= out * f_out
                else:
                    B.remove((f_out, out))
                cnt[out] -= 1
                if cnt[out] > 0:
                    A.add((cnt[out], out))
                    tot += out * cnt[out]
                else:
                    del cnt[out]

            if inc in cnt:
                f_inc = cnt[inc]
                if (f_inc, inc) in A:
                    A.remove((f_inc, inc))
                    tot -= inc * f_inc
                else:
                    B.remove((f_inc, inc))
                cnt[inc] += 1
                A.add((cnt[inc], inc))
                tot += inc * cnt[inc]
            else:
                cnt[inc] = 1
                A.add((1, inc))
                tot += inc

            while len(A) > x:
                f, val = A[0]
                A.remove((f, val))
                B.add((f, val))
                tot -= val * f

            while len(A) < x and B:
                f, val = B[-1]
                B.remove((f, val))
                A.add((f, val))
                tot += val * f

            if A and B:
                fA, vA = A[0]
                fB, vB = B[-1]
                if (fB > fA) or (fB == fA and vB > vA):
                    A.remove((fA, vA))
                    B.remove((fB, vB))
                    A.add((fB, vB))
                    B.add((fA, vA))
                    tot += vB * fB - vA * fA

            res.append(tot)

        return res",1420560497
0x3fIsBestTeacher,0x3fIsBestTeacher,289,3610,python3,"
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def calc(a):
            cnt = Counter(a)
            tmp = sorted(cnt.items(), key=lambda x: (-x[1], -x[0]))
            ans = 0
            for k, c in tmp[: min(x, len(tmp))]:
                ans += k * c
            # print(tmp)
            # print(a, ans)
            return ans

        return [calc(nums[i : i + k]) for i in range(len(nums) - k + 1)]
",1420521196
3905aj,3905aj,290,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    multiset<pair<int,int>> sp;
    int dfs(TreeNode* curr){
        if(curr==nullptr) return 0;
        int s1 = dfs(curr->left);
        int s2 = dfs(curr->right);
        if(s1==s2 && s1!=-1) {
            sp.insert({s1+1, curr->val});
            return  s1+1;
        }
        return -1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        if(sp.size()<k)  return -1;
        while(--k) sp.erase(--sp.end());
        return (1<<sp.rbegin()->first)-1;
    }
};",1420564590
3905aj,3905aj,290,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<long long, long long> mp;
        multiset<pair<long long, long long>> msa, msb;
        long long sum = 0;
        vector<long long> ans;
        for(int i = 0; i<nums.size(); i++){
            if(msa.find({mp[nums[i]], nums[i]})!=msa.end()) {
                msa.erase({mp[nums[i]], nums[i]});
                mp[nums[i]]++;
                sum += nums[i];
                msa.insert({mp[nums[i]], nums[i]});
            } else {
                msb.erase({mp[nums[i]], nums[i]});
                mp[nums[i]]++;
                msb.insert({mp[nums[i]], nums[i]});
            }
            if(i>=k) {
                if(msa.find({mp[nums[i-k]], nums[i-k]})!=msa.end()){
                    msa.erase({mp[nums[i-k]], nums[i-k]});
                    mp[nums[i-k]]--;
                    sum -= nums[i-k];
                    msa.insert({mp[nums[i-k]], nums[i-k]});
                } else {
                    msb.erase({mp[nums[i-k]], nums[i-k]});
                    mp[nums[i-k]]--;
                    msb.insert({mp[nums[i-k]], nums[i-k]});
                }
            }
            while(msb.size() && msa.size()<x){
                msa.insert(*msb.rbegin());
                sum+=msb.rbegin()->first*msb.rbegin()->second;
                msb.erase(*msb.rbegin());
            }
            while(msb.size() && msa.size() && *msa.begin()<*msb.rbegin()){
                msa.insert(*msb.rbegin());
                msb.insert(*msa.begin());
                sum+=msb.rbegin()->first*msb.rbegin()->second;
                sum-=msa.begin()->first*msa.begin()->second;
                msa.erase(*msa.begin());
                msb.erase(*msb.rbegin());
            }
            if(i>=k-1) ans.push_back(sum);
        }
        return ans;

    }
};",1420550072
3905aj,3905aj,290,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        map<long long, long long> mp;
        multiset<pair<long long, long long>> msa, msb;
        long long sum = 0;
        vector<int> ans;
        for(int i = 0; i<nums.size(); i++){
            if(msa.find({mp[nums[i]], nums[i]})!=msa.end()) {
                msa.erase({mp[nums[i]], nums[i]});
                mp[nums[i]]++;
                sum += nums[i];
                msa.insert({mp[nums[i]], nums[i]});
            } else {
                msb.erase({mp[nums[i]], nums[i]});
                mp[nums[i]]++;
                msb.insert({mp[nums[i]], nums[i]});
            }
            if(i>=k) {
                if(msa.find({mp[nums[i-k]], nums[i-k]})!=msa.end()){
                    msa.erase({mp[nums[i-k]], nums[i-k]});
                    mp[nums[i-k]]--;
                    sum -= nums[i-k];
                    msa.insert({mp[nums[i-k]], nums[i-k]});
                } else {
                    msb.erase({mp[nums[i-k]], nums[i-k]});
                    mp[nums[i-k]]--;
                    msb.insert({mp[nums[i-k]], nums[i-k]});
                }
            }
            while(msb.size() && msa.size()<x){
                msa.insert(*msb.rbegin());
                sum+=msb.rbegin()->first*msb.rbegin()->second;
                msb.erase(*msb.rbegin());
            }
            while(msb.size() && msa.size() && *msa.begin()<*msb.rbegin()){
                msa.insert(*msb.rbegin());
                msb.insert(*msa.begin());
                sum+=msb.rbegin()->first*msb.rbegin()->second;
                sum-=msa.begin()->first*msa.begin()->second;
                msa.erase(*msa.begin());
                msb.erase(*msb.rbegin());
            }
            if(i>=k-1) ans.push_back(sum);
        }
        return ans;

    }
};",1420551295
vrangr,vrangr,295,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ss;
        auto dfs = [&](auto &&self, TreeNode *node) -> pair<int,bool> {
            if (!node) return {0,true};
            int ct = 0;
            bool p = true;
            auto [lct,lb] = self(self,node->left);
            auto [rct,rb] = self(self,node->right);
            ct = lct+rct+1;
            if (lb && rb && lct == rct) {
                ss.push_back(ct);
                return {ct,true};
            }
            return {ct,false};
        };
        dfs(dfs,root);
        if (ss.size() < k) return -1;
        sort(ss.rbegin(),ss.rend());
        return ss[k-1];
    }
};",1420528609
vrangr,vrangr,295,3592,cpp,"template <typename type> inline void print(const type &var) {
    cout << var;
}
template <typename type> inline void print(const vector<type> &vec) {
    for (const auto &it : vec) {
        print(it); cout << "" "";
    }
}
template <typename t1, typename t2> inline void print(const pair<t1,t2> &pr) {
    cout << ""{"";
    print(pr.first);
    cout << "","";
    print(pr.second);
    cout << ""}"";
}
template <typename t1, typename t2> inline void print(const unordered_map<t1,t2> &mp) {
    for (const auto p : mp) {
        print(p); cout << "" "";
    }
}
template <typename t1, typename t2> inline void print(const set<t1,t2> &st) {
    for (auto it = st.begin(); it != st.end(); ++it) {
        print(*it);
        cout << "" "";
    }
}
#define debug(x) if(false){cout<<#x<<"": "";print(x);cout<<endl;}
auto _=[]{ios_base::sync_with_stdio(false),cin.tie(0);return 0;}();
typedef long long int ll;
class Solution {
public:
    vector<long long> findXSum(vector<int>& vals, int k, int x) {
        vector<ll> sol;
        unordered_map<ll,ll> mp;
        auto comp = [](const pair<ll,ll> &a, const pair<ll,ll> &b) -> bool {
            if (a.second != b.second) return a.second < b.second;
            return a.first < b.first;
        };
        set<pair<ll,ll>,decltype(comp)> ch(comp), uch(comp);
        ll s1 = 0, s2 = 0;
        ll sum = 0ll, n = vals.size();
        auto rem = [&](ll v, ll c) -> void {
            if (ch.find({v,c}) != ch.end()) {
                ch.erase({v,c});
                s1--;
                sum -= v*c;
            }
            if (uch.find({v,c}) != uch.end()) {
                uch.erase({v,c});
                s2--;
            }
        };
        auto better = [&](pair<ll,ll> p1, pair<ll,ll> p2) -> bool {
            if (p1.second != p2.second) return p1.second > p2.second;
            return p1.first > p2.first;
        };
        auto ins = [&](ll v, ll c) -> void {
            if (c > 0) {
                uch.insert({v,c});
                s2++;
            }
            while(s1 < x && s2 > 0) {
                auto [tv, tc] = *uch.rbegin();
                sum += tv*tc;
                ch.insert(*uch.rbegin());
                s1++;
                uch.erase(prev(uch.end()));
                s2--;
            }
            while(s1 > 0 && s2 > 0 && better(*uch.rbegin(),*ch.begin())) {
                assert(s1 == x);
                auto p1 = *uch.rbegin();
                auto p2 = *ch.begin();
                uch.erase(prev(uch.end()));
                ch.erase(ch.begin());
                sum -= p2.first*p2.second;
                sum += p1.first*p1.second;
                ch.insert(p1);
                uch.insert(p2);
            }
        };
        auto upd = [&](ll v1, ll v2) -> void {
            if (v2 == LLONG_MAX) {
                mp[v1]++;
                ll c1 = mp[v1]-1;
                rem(v1,c1);
                c1++;
                ins(v1,c1);
                return;
            }
            if (v1 != v2) {
                mp[v1]++;
                mp[v2]--;
                ll c1 = mp[v1]-1, c2 = mp[v2]+1;
                if (mp[v2] == 0) mp.erase(v2);
                rem(v1,c1);
                rem(v2,c2);
                c1++;
                c2--;
                if (better(make_pair(v2,c2),make_pair(v1,c1))) {
                    swap(v1,v2);
                    swap(c1,c2);
                }
                ins(v1,c1);
                ins(v2,c2);
            }
        };
        for (ll i = 0; i < n; ++i) {
            // debug('\n');
            // debug(i);
            // debug(vals);
            // debug(mp);
            // debug(ch);
            // debug(uch);
            // debug(s1);
            // debug(s2);
            // debug(sum);
            // debug(sol);
            if (i < k-1) {
                upd(vals[i],LLONG_MAX);
                continue;
            }
            if (i == k-1) {
                upd(vals[i],LLONG_MAX);
                sol.push_back(sum);
                continue;
            }
            upd(vals[i],vals[i-k]);
            sol.push_back(sum);
        }
        // debug('\n');
        // debug(vals);
        // debug(mp);
        // debug(ch);
        // debug(uch);
        // debug(s1);
        // debug(s2);
        // debug(sum);
        // debug(sol);
        return sol;
    }
};
/*
[1,1,2,2,3,4,2,3]
6
2
[3,8,7,8,7,5]
2
2
*/",1420580986
vrangr,vrangr,295,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& vals, int k, int x) {
        auto get = [&](vector<int> a) -> int {
            int n = a.size();
            if (n <= x) return accumulate(a.begin(),a.end(),0);
            sort(a.begin(),a.end());
            vector<pair<int,int>> b;
            for (int v : a) {
                if (b.empty() || b.back().first != v)
                    b.emplace_back(v,1);
                else b.back().second++;
            }
            sort(b.rbegin(),b.rend(), [&](const pair<int,int> &v1, const pair<int,int> &v2) {
                if (v1.second != v2.second) return v1.second < v2.second;
                return v1.first < v2.first;
            });
            int sol = 0;
            for (int i = 0; i < x && i < b.size(); ++i)
                sol += b[i].first*b[i].second;
            return sol;
        };
        int n = vals.size();
        vector<int> sol;
        for (int i = 0; i+k-1 <= n-1; ++i) {
            sol.push_back(get(vector<int>(vals.begin()+i,vals.begin()+i+k)));
        }
        return sol;
    }
};",1420523818
Zamfirescu George-Iulian,SkinnySnakeLimb,296,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def go(node):
            if not node:
                return 0
            if not node.left and not node.right:
                sizes.append(1)
                return 1

            lval = go(node.left)
            rval = go(node.right)

            if lval == rval and lval != -1:
                sizes.append(lval * 2 + 1)
                return lval * 2 + 1

            return -1

        go(root)
        if len(sizes) < k:
            return -1
        sizes.sort(reverse=True)
        return sizes[k - 1]
",1420524671
Zamfirescu George-Iulian,SkinnySnakeLimb,296,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedSet
        revF= SortedSet()
        numF = {}
        ret = []
        sumNow = 0
        n = len(nums)

        for i in range(k):
            num = nums[i]
            oldF = numF.get(num, 0)
            numF[num] = oldF + 1
            if oldF != 0:
                revF.remove((oldF, num))
            revF.add((oldF + 1, num))

        if len(revF) < x:
            sumNow = sum(nums[:k])
        else:
            for i in range(-1, -x - 1, -1):
                sumNow += revF[i][0] * revF[i][1]
        ret.append(sumNow)
        
        for r in range(k, n):
            leftWas = False
            rightWas = False
            leftIs = False
            rightIs = False

            numLeft = nums[r - k]
            oldFL = numF[numLeft]
            numRight = nums[r]
            oldFR = numF.get(numRight, 0)
            if numLeft == numRight:
                ret.append(sumNow)
                continue

            oldPos = bisect_left(revF, (oldFL, numLeft))
            if oldPos >= len(revF) - x:
                leftWas = True
                
            if oldFR > 0:
                oldPos = bisect_left(revF, (oldFR, numRight))
                if oldPos >= len(revF) - x:
                    rightWas = True

            numF[numLeft] -= 1
            if numF[numLeft] == 0:
                numF.pop(numLeft)
            revF.remove((oldFL, numLeft))
            if oldFL != 1:
                revF.add((oldFL - 1, numLeft))

            numF[numRight] = oldFR + 1
            if oldFR != 0:
                revF.remove((oldFR, numRight))
            revF.add((oldFR + 1, numRight))

            if oldFL != 1:
                newPos = bisect_left(revF, (oldFL - 1, numLeft))
                if newPos >= len(revF) - x:
                    leftIs = True

            newPos = bisect_left(revF, (oldFR + 1, numRight))
            if newPos >= len(revF) - x:
                rightIs = True

            missing = 0
            if leftWas and not leftIs:
                sumNow -= oldFL * numLeft
                missing += 1
            elif leftWas and leftIs:
                sumNow -= numLeft
            if not rightWas and rightIs:
                sumNow += (oldFR + 1) * numRight
                missing -= 1
            elif rightWas and rightIs:
                sumNow += numRight

            if missing == 1 and len(revF) >= x:
                sumNow += revF[-x][0] * revF[-x][1]
            if missing == -1 and len(revF) > x:
                sumNow -= revF[-x - 1][0] * revF[-x - 1][1]

            ret.append(sumNow)

        return ret

            ",1420569754
Zamfirescu George-Iulian,SkinnySnakeLimb,296,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ret = []
        for r in range(k - 1, n):
            l = r - k + 1
            arr = nums[l:r + 1]
            c = Counter(arr)
            if len(c) <= x:
                ret.append(sum(arr))
                continue
            temp = [(f, val) for val, f in c.items()]
            temp.sort()
            ret.append(sum([f * val for f, val in temp[-x:]]))

        return ret",1420520766
Roushan Kumar Singh,r-tron19,297,3509,python3,"from sortedcontainers import SortedList
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        allBins = SortedList(key = lambda x: -x)
        def dfs(root):
            if root == None:
                return True, 0
            isOkLeft, lval = dfs(root.left)
            isOkRight, rval = dfs(root.right)
            if isOkLeft and isOkRight and lval == rval:
                allBins.add(lval + rval + 1)
                return True, lval + rval + 1
            
            return False, -1
        
        dfs(root)
        #print(allBins)
        if len(allBins) < k:
            return -1
        return allBins[k-1]
        ",1420536363
Roushan Kumar Singh,r-tron19,297,3592,python3,"from sortedcontainers import SortedList

class Container:
    def __init__(self, size):
        self.total = 0
        self.maxHeap = SortedList(key = lambda x: (-x[1], -x[0]))
        self.minHeap = SortedList(key = lambda x: (x[1], x[0]))
        self.CAP = size

    def insert(self, key, fre):
        #print(""INSERT"", key, fre)
        ##always insert in minHeap
        self.minHeap.add((key, fre))
        self.total += fre * key

        if len(self.minHeap) > self.CAP:
            tup = self.minHeap.pop(0)
            self.total -= tup[0] * tup[1]
            self.maxHeap.add(tup)
    
    def remove(self, key, fre):
        #print(""REMOVE"", key, fre)
        tup = (key, fre)
        if tup in self.maxHeap:
            self.maxHeap.discard(tup)
        else:
            ## remove from minHeap and adjust total
            self.minHeap.discard(tup)
            self.total -= tup[1] * tup[0]
            if self.maxHeap and len(self.minHeap) < self.CAP:
                popTup = self.maxHeap.pop(0)
                self.minHeap.add(popTup)
                self.total += popTup[0] * popTup[1]
        
    def getTotal(self):
        return self.total
    
    def show(self):
        print(""[MINHEAP]"", list(self.minHeap), len(self.minHeap))
        print(""[MAXHEAP]"", list(self.maxHeap), len(self.maxHeap))
        print(""Total"", self.total)
        print()

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        curWindow = Counter()
        cont = Container(x)
        out = []
        for i, el in enumerate(nums):
            cont.remove(el, curWindow[el])
            #cont.show()

            curWindow[el] += 1
            cont.insert(el, curWindow[el])
            #cont.show()

            if i >= k:
                pel = nums[i-k]
                cont.remove(pel, curWindow[pel])
                #cont.show()

                curWindow[pel] -= 1
                cont.insert(pel, curWindow[pel])
                #cont.show()
            
            if i >= k-1:
                out.append(cont.getTotal())
            #print(""at"", i)
            #cont.show()
        return out
        
            ",1420585427
Roushan Kumar Singh,r-tron19,297,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        def getAns(arr):
            c = Counter(arr)
            li = [(k, v) for k,v in c.items()]
            li.sort(key = lambda z: (-z[1], -z[0]))

            l = li[:x]
            #print(l)
            s = sum(t[0]*t[1] for t in l)
            return s
        out = []
        for i in range(n-k+1):
            arr = nums[i:i+k]
            ans = getAns(arr)
            out.append(ans)
        return out",1420523099
Sarvagya Sharma,sarvagya2545,298,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {

        map<TreeNode*, int> sz;
        
        auto get_sz = [&](auto get_sz, TreeNode* node) -> int {
            if(node == NULL) return 0;
            return sz[node] = get_sz(get_sz, node->left) + get_sz(get_sz, node->right) + 1;
        };

        get_sz(get_sz, root);
        // for(auto [node, s]: sz) cout << node->val << "" "" << s << ""\n"";
        // cout << ""\n"";

        priority_queue<int, vector<int>, greater<int>> max_heap;

        auto dfs = [&](auto dfs, TreeNode* node) -> pair<int,int> {
            if(node == NULL) return { 0, 1 };
            auto [left_height, left_perfect] = dfs(dfs, node->left);
            auto [right_height, right_perfect] = dfs(dfs, node->right);
            
            int is_perfect = left_perfect == 1 and right_perfect == 1 and left_height == right_height;
            int curr_height = max(left_height, right_height) + 1;
            
            if(is_perfect) {
                max_heap.push(sz[node]);
                if(max_heap.size() > k) {
                    max_heap.pop();
                }
            }

            // cout << node->val << "" "" << is_perfect << ""\n"";

            return { curr_height, is_perfect };
        };

        dfs(dfs, root);

        return max_heap.size() == k ? max_heap.top() : -1;
    }
};",1420583322
Sarvagya Sharma,sarvagya2545,298,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> ans;

        long long x_sum = 0;
        set<pair<int,int>> first, second;
        map<int, int> freq;

        auto add = [&](int item) {
            if(freq.count(item)) {
                if(first.count({ freq[item], item })) {
                    x_sum -= (long long)freq[item] * item;
                    first.erase({ freq[item], item });
                    if(second.size() > 0 and first.size() == x - 1) {
                        int new_item = second.rbegin()->second;
                        int freq_new_item = second.rbegin()->first;
                        x_sum += (long long)freq_new_item * new_item;

                        first.insert(*second.rbegin());
                        second.erase(*second.rbegin());
                    }
                }
                if(second.count({ freq[item], item })) second.erase({ freq[item], item });
            }

            freq[item]++;
            first.insert({ freq[item], item });
            x_sum += (long long)freq[item] * item;
            if(first.size() > x) {
                auto y = *first.begin();
                first.erase(y);
                x_sum -= (long long)y.first * y.second;
                second.insert(y);
            }
        };

        auto remove = [&](int item) {
            if(not freq.count(item)) {
                return;
            }

            if(second.count({ freq[item], item })) second.erase({ freq[item], item });
            if(first.count({ freq[item], item })) {
                x_sum -= (long long)freq[item] * item;
                first.erase({ freq[item], item });
                if(second.size() > 0) {
                    int new_item = second.rbegin()->second;
                    int freq_new_item = second.rbegin()->first;
                    x_sum += (long long)freq_new_item * new_item;

                    first.insert(*second.rbegin());
                    second.erase(*second.rbegin());
                }
            }

            freq[item]--;
            if(freq[item] > 0) {
                first.insert({ freq[item], item });
                x_sum += (long long)freq[item] * item;
                if(first.size() > x) {
                    auto y = *first.begin();
                    first.erase(y);
                    x_sum -= (long long)y.first * y.second;
                    second.insert(y);
                } 
            } else {
                freq.erase(item);
            }
        };

        for(int i = 0; i < k; i++) {
            add(nums[i]);
        }

        // for(auto [f, x]: freq) cout << f << "" "" << x << ""\n"";
        // cout << ""\n"";
        // for(auto [x, y]: first) cout << x << "" "" << y << ""\n"";
        // cout << ""\n"";
        // for(auto [x, y]: second) cout << x << "" "" << y << ""\n"";
        // cout << ""\n"";

        for(int i = 0; i + k - 1 < n; i++) {
            ans.push_back(x_sum);
            remove(nums[i]);

            // cout << ""--------\n"";
            // cout << x_sum << ""\n"";
            // for(auto [f, x]: freq) cout << f << "" "" << x << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: first) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: second) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";

            if(i + k < n) add(nums[i + k]);

            // cout << ""--------\n"";
            // cout << x_sum << ""\n"";
            // for(auto [f, x]: freq) cout << f << "" "" << x << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: first) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: second) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";
        }

        return ans;
    }
};",1420562976
Sarvagya Sharma,sarvagya2545,298,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;

        long long x_sum = 0;
        set<pair<int,int>> first, second;
        map<int, int> freq;

        auto add = [&](int item) {
            if(freq.count(item)) {
                if(first.count({ freq[item], item })) {
                    x_sum -= (long long)freq[item] * item;
                    first.erase({ freq[item], item });
                    if(second.size() > 0 and first.size() == x - 1) {
                        int new_item = second.rbegin()->second;
                        int freq_new_item = second.rbegin()->first;
                        x_sum += (long long)freq_new_item * new_item;

                        first.insert(*second.rbegin());
                        second.erase(*second.rbegin());
                    }
                }
                if(second.count({ freq[item], item })) second.erase({ freq[item], item });
            }

            freq[item]++;
            first.insert({ freq[item], item });
            x_sum += (long long)freq[item] * item;
            if(first.size() > x) {
                auto y = *first.begin();
                first.erase(y);
                x_sum -= (long long)y.first * y.second;
                second.insert(y);
            }
        };

        auto remove = [&](int item) {
            if(not freq.count(item)) {
                return;
            }

            if(second.count({ freq[item], item })) second.erase({ freq[item], item });
            if(first.count({ freq[item], item })) {
                x_sum -= (long long)freq[item] * item;
                first.erase({ freq[item], item });
                if(second.size() > 0) {
                    int new_item = second.rbegin()->second;
                    int freq_new_item = second.rbegin()->first;
                    x_sum += (long long)freq_new_item * new_item;

                    first.insert(*second.rbegin());
                    second.erase(*second.rbegin());
                }
            }

            freq[item]--;
            if(freq[item] > 0) {
                first.insert({ freq[item], item });
                x_sum += (long long)freq[item] * item;
                if(first.size() > x) {
                    auto y = *first.begin();
                    first.erase(y);
                    x_sum -= (long long)y.first * y.second;
                    second.insert(y);
                } 
            } else {
                freq.erase(item);
            }
        };

        for(int i = 0; i < k; i++) {
            add(nums[i]);
        }

        // for(auto [f, x]: freq) cout << f << "" "" << x << ""\n"";
        // cout << ""\n"";
        // for(auto [x, y]: first) cout << x << "" "" << y << ""\n"";
        // cout << ""\n"";
        // for(auto [x, y]: second) cout << x << "" "" << y << ""\n"";
        // cout << ""\n"";

        for(int i = 0; i + k - 1 < n; i++) {
            ans.push_back(x_sum);
            remove(nums[i]);

            // cout << ""--------\n"";
            // cout << x_sum << ""\n"";
            // for(auto [f, x]: freq) cout << f << "" "" << x << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: first) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: second) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";

            if(i + k < n) add(nums[i + k]);

            // cout << ""--------\n"";
            // cout << x_sum << ""\n"";
            // for(auto [f, x]: freq) cout << f << "" "" << x << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: first) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";
            // for(auto [x, y]: second) cout << x << "" "" << y << ""\n"";
            // cout << ""\n"";
        }

        return ans;
    }
};",1420563756
wu py,r32626,300,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_sizes = []
        
        def dfs(node):
            if not node:
                return (True, 0, 0)  # is_perfect, height, size
            
            if not node.left and not node.right:
                # Leaf node is a perfect binary subtree of size 1
                perfect_sizes.append(1)
                return (True, 1, 1)  # Leaf node forms a perfect subtree of size 1
            
            left_is_perfect, left_height, left_size = dfs(node.left)
            right_is_perfect, right_height, right_size = dfs(node.right)
            
            if left_is_perfect and right_is_perfect and left_height == right_height:
                subtree_size = left_size + right_size + 1
                perfect_sizes.append(subtree_size)
                return (True, left_height + 1, subtree_size)
            
            return (False, 0, 0)  # Not a perfect subtree
        
        # Start DFS traversal from the root
        dfs(root)
        
        # Sort the perfect subtree sizes in descending order
        perfect_sizes.sort(reverse=True)
        
        # Return the k-th largest size if it exists, else return -1
        return perfect_sizes[k - 1] if k <= len(perfect_sizes) else -1
        ",1420558944
wu py,r32626,300,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedList
        n = len(nums)
        answer = []
        
        # Initialize the first window
        freq_map = defaultdict(int)  # To keep track of the frequencies
        top_x_list = SortedList()  # To keep (frequency, element) of top x elements sorted
        rest_list = SortedList()  # To keep the rest of the elements sorted
        running_x_sum = 0  # Sum of the top x elements
        
        # Helper function to add an element to one of the lists
        def add_element(freq, num):
            nonlocal running_x_sum
            if len(top_x_list) < x:
                top_x_list.add((freq, num))
                running_x_sum += num * freq
            else:
                # Compare the new element with the smallest element in top_x_list
                if (freq, num) > top_x_list[0]:
                    # Remove smallest element from top_x_list and move it to rest_list
                    smallest_freq, smallest_num = top_x_list.pop(0)
                    running_x_sum -= smallest_freq * smallest_num
                    rest_list.add((smallest_freq, smallest_num))
                    
                    # Add the new element to top_x_list
                    top_x_list.add((freq, num))
                    running_x_sum += num * freq
                else:
                    # Add the new element to rest_list
                    rest_list.add((freq, num))
        
        # Helper function to remove an element from one of the lists
        def remove_element(freq, num):
            nonlocal running_x_sum
            if (freq, num) in top_x_list:
                top_x_list.remove((freq, num))
                running_x_sum -= num * freq
                
                # Balance the lists if necessary
                if rest_list:
                    # Move the largest element from rest_list to top_x_list
                    largest_freq, largest_num = rest_list.pop(-1)
                    top_x_list.add((largest_freq, largest_num))
                    running_x_sum += largest_num * largest_freq
            else:
                rest_list.remove((freq, num))
        
        # Helper function to update the frequency of an element
        def update_frequency(val, delta):
            old_freq = freq_map[val]
            new_freq = old_freq + delta
            if old_freq > 0:
                remove_element(old_freq, val)
            freq_map[val] = new_freq
            if new_freq > 0:
                add_element(new_freq, val)
        
        # Populate the initial window
        for i in range(k):
            update_frequency(nums[i], 1)
        
        # Append the initial x-sum to the result
        answer.append(running_x_sum)
        
        # Sliding window to process the rest of the subarrays
        for i in range(1, n - k + 1):
            # Remove the outgoing element and add the new incoming element
            outgoing_elem = nums[i - 1]
            incoming_elem = nums[i + k - 1]
            
            update_frequency(outgoing_elem, -1)
            update_frequency(incoming_elem, 1)
            
            # Append the updated x-sum to the result
            answer.append(running_x_sum)
        
        return answer",1420579866
wu py,r32626,300,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ret = []
        for i in range(n-k+1):
            cnt = Counter(nums[i:i+k])
            top_x = sorted(cnt.items(), key=lambda x: [x[1], x[0]], reverse=True)
            ret.append(sum(a*b for a, b in top_x[:x]))
        return ret
            ",1420549110
stupid_panda,stupid_panda,301,3509,rust,"use std::cell::RefCell;
use std::collections::BinaryHeap;
use std::rc::Rc;
impl Solution {
    pub fn kth_largest_perfect_subtree(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {
        let k = k as usize;
        let mut heap: BinaryHeap<i32> = BinaryHeap::new();
        Self::traverse(root, &mut heap, k);
        if heap.len() < k {
            -1
        } else {
            -(*heap.peek().unwrap())
        }
    }

    fn traverse(
        node: Option<Rc<RefCell<TreeNode>>>,
        heap: &mut BinaryHeap<i32>,
        kth: usize,
    ) -> (i32, bool, i32) {
        if let Some(n) = node {
            let l_info = Self::traverse(n.borrow().left.clone(), heap, kth);
            let r_info = Self::traverse(n.borrow().right.clone(), heap, kth);
            let is_perfect = l_info.0 == r_info.0 && l_info.1 && r_info.1;
            let size = l_info.2 + r_info.2 + 1;
            let level = l_info.0.max(r_info.0) + 1;
            if is_perfect {
                heap.push(-size);
                if heap.len() > kth {
                    heap.pop();
                }
            }
            (level, is_perfect, size)
        } else {
            (0, true, 0)
        }
    }
}
",1420548695
stupid_panda,stupid_panda,301,3592,rust,"use std::collections::BTreeMap;
use std::collections::BTreeSet;
impl Solution {
    pub fn find_x_sum(nums: Vec<i32>, k: i32, x: i32) -> Vec<i64> {
        let k = k as usize;
        let x = x as usize;
        let mut top_x: BTreeSet<(i32, i32)> = BTreeSet::new();
        let mut others: BTreeSet<(i32, i32)> = BTreeSet::new();
        let mut freq: BTreeMap<i32, i32> = BTreeMap::new();
        let mut ans = vec![];
        let mut cur_sum = 0;
        for i in 0..nums.len() {
            let num = nums[i];
            cur_sum += Self::del_el(num, &freq, &mut top_x, &mut others, x);
            *freq.entry(num).or_insert(0) += 1;
            cur_sum += Self::add_el(num, &freq, &mut top_x, &mut others, x);
            if i >= k - 1 {
                ans.push(cur_sum);
                let del_num = nums[i + 1 - k];
                cur_sum += Self::del_el(del_num, &freq, &mut top_x, &mut others, x);
                freq.entry(del_num).and_modify(|e| *e -= 1);
                cur_sum += Self::add_el(del_num, &freq, &mut top_x, &mut others, x);
            }
        }
        ans
    }

    fn del_el(
        num: i32,
        freq: &BTreeMap<i32, i32>,
        top_x: &mut BTreeSet<(i32, i32)>,
        others: &mut BTreeSet<(i32, i32)>,
        x: usize,
    ) -> i64 {
        let el = (*freq.get(&num).unwrap_or(&0), num);
        let mut diff = 0;
        others.remove(&el);
        if top_x.remove(&el) {
            diff = -(el.0 as i64 * el.1 as i64);
        }
        if top_x.len() < x && others.len() > 0 {
            let popped = others.pop_last().unwrap();
            diff += popped.0 as i64 * popped.1 as i64;
            top_x.insert(popped);
        }
        diff
    }

    fn add_el(
        num: i32,
        freq: &BTreeMap<i32, i32>,
        top_x: &mut BTreeSet<(i32, i32)>,
        others: &mut BTreeSet<(i32, i32)>,
        x: usize,
    ) -> i64 {
        let el = (*freq.get(&num).unwrap_or(&0), num);
        let mut diff = el.0 as i64 * el.1 as i64;
        top_x.insert(el);
        if top_x.len() > x {
            let popped = top_x.pop_first().unwrap();
            diff -= popped.0 as i64 * popped.1 as i64;
            others.insert(popped);
        }
        diff
    }
}
",1420593412
stupid_panda,stupid_panda,301,3610,rust,"use std::collections::BTreeMap;
use std::collections::BTreeSet;
impl Solution {
    pub fn find_x_sum(nums: Vec<i32>, k: i32, x: i32) -> Vec<i64> {
        let k = k as usize;
        let x = x as usize;
        let mut top_x: BTreeSet<(i32, i32)> = BTreeSet::new();
        let mut others: BTreeSet<(i32, i32)> = BTreeSet::new();
        let mut freq: BTreeMap<i32, i32> = BTreeMap::new();
        let mut ans = vec![];
        let mut cur_sum = 0;
        for i in 0..nums.len() {
            let num = nums[i];
            cur_sum += Self::del_el(num, &freq, &mut top_x, &mut others, x);
            *freq.entry(num).or_insert(0) += 1;
            cur_sum += Self::add_el(num, &freq, &mut top_x, &mut others, x);
            if i >= k - 1 {
                ans.push(cur_sum);
                let del_num = nums[i + 1 - k];
                cur_sum += Self::del_el(del_num, &freq, &mut top_x, &mut others, x);
                freq.entry(del_num).and_modify(|e| *e -= 1);
                cur_sum += Self::add_el(del_num, &freq, &mut top_x, &mut others, x);
            }
        }
        ans
    }

    fn del_el(
        num: i32,
        freq: &BTreeMap<i32, i32>,
        top_x: &mut BTreeSet<(i32, i32)>,
        others: &mut BTreeSet<(i32, i32)>,
        x: usize,
    ) -> i64 {
        let el = (*freq.get(&num).unwrap_or(&0), num);
        let mut diff = 0;
        others.remove(&el);
        if top_x.remove(&el) {
            diff = -(el.0 as i64 * el.1 as i64);
        }
        if top_x.len() < x && others.len() > 0 {
            let popped = others.pop_last().unwrap();
            diff += popped.0 as i64 * popped.1 as i64;
            top_x.insert(popped);
        }
        diff
    }

    fn add_el(
        num: i32,
        freq: &BTreeMap<i32, i32>,
        top_x: &mut BTreeSet<(i32, i32)>,
        others: &mut BTreeSet<(i32, i32)>,
        x: usize,
    ) -> i64 {
        let el = (*freq.get(&num).unwrap_or(&0), num);
        let mut diff = el.0 as i64 * el.1 as i64;
        top_x.insert(el);
        if top_x.len() > x {
            let popped = top_x.pop_first().unwrap();
            diff -= popped.0 as i64 * popped.1 as i64;
            others.insert(popped);
        }
        diff
    }
}
",1420593751
panshane56,panshane56,302,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sz;

        function<pair<int, int>(TreeNode *)> dfs = [&](TreeNode *cur) -> pair<int, int> {
            if (!cur) {
                return {0, 0};
            }
            auto [dl, szl] = dfs(cur->left);
            auto [dr, szr] = dfs(cur->right);

            int cursz = szl + szr + 1;
            int curd = max(dl, dr) + 1;
            if (__builtin_popcount(cursz + 1) == 1) {
                if (log2(cursz + 1) == curd) {
                    sz.push_back(cursz);
                }
            }

            return {curd, cursz}; 
        };

        dfs(root);

        sort(sz.begin(), sz.end(), greater<int>());

        if (k > sz.size()) return -1;
        return sz[k - 1];
    }
};",1420594080
panshane56,panshane56,302,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pair<int, int>, greater<pair<int, int>>> xset, k_xset;
        vector<long long> ans;
        map<int, int> num;
        long long sum = 0;

        for (int i = 0; i < k; i++) {
            insert(nums[i], xset, k_xset, num, sum, x);
        }
        ans.push_back(sum);
        for (int i = k; i < nums.size(); i++) {
            insert(nums[i], xset, k_xset, num, sum, x);
            erase(nums[i - k], xset, k_xset, num, sum, x);
            ans.push_back(sum);
        }
        return ans;
    }

private:
    void update(set<pair<int, int>, greater<pair<int, int>>>& xset,
                set<pair<int, int>, greater<pair<int, int>>>& k_xset,
                long long& sum, int x) {
        if (k_xset.size() == 0) {
            return;
        }
        if (xset.size() < x) {
            auto it = k_xset.begin();
            xset.insert(*it);
            sum += 1ll * it->first * it->second;
            k_xset.erase(it);
        } else if (*xset.rbegin() < *k_xset.begin()) {
            auto it = k_xset.begin();
            auto it2 = xset.end();
            it2--;
            sum +=
                1ll * it->first * it->second - 1ll * it2->first * it2->second;
            k_xset.insert(*it2);
            xset.erase(it2);
            xset.insert(*it);
            k_xset.erase(it);
        }
    }

    void insert(int val, set<pair<int, int>, greater<pair<int, int>>>& xset,
                set<pair<int, int>, greater<pair<int, int>>>& k_xset,
                map<int, int>& num, long long& sum, int x) {
        if (xset.find({num[val], val}) == xset.end()) {
            if (k_xset.count({num[val], val})) {
                k_xset.erase({num[val], val});
                k_xset.insert({num[val] + 1, val});
            } else {
                k_xset.insert({1, val});
            }
        } else {
            xset.erase({num[val], val});
            xset.insert({num[val] + 1, val});
            sum += val;
        }
        update(xset, k_xset, sum, x);
        num[val]++;
    }

    void erase(int val, set<pair<int, int>, greater<pair<int, int>>>& xset,
               set<pair<int, int>, greater<pair<int, int>>>& k_xset,
               map<int, int>& num, long long& sum, int x) {
        if (k_xset.find({num[val], val}) == k_xset.end()) {
            xset.erase({num[val], val});
            xset.insert({num[val] - 1, val});
            sum -= val;
        } else {
            k_xset.erase({num[val], val});
            if (num[val] > 1) {
                k_xset.insert({num[val] - 1, val});
            }
        }
        update(xset, k_xset, sum, x);
        num[val]--;
    }
};",1420578256
panshane56,panshane56,302,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        set<pair<int, int>, greater<pair<int, int>>> xset, k_xset;
        vector<int> ans;
        long long sum = 0;
        map<int, int> num;

        for (int i = 0; i < k; i++) {
            insert(nums[i], xset, k_xset, num, sum, x);
        }
        ans.push_back(sum);
        for (int i = k; i < nums.size(); i++) {
            insert(nums[i], xset, k_xset, num, sum, x);
            erase(nums[i - k], xset, k_xset, num, sum, x);
            ans.push_back(sum);
        }
        return ans;
    }

private:
    void update(set<pair<int, int>, greater<pair<int, int>>>& xset,
                set<pair<int, int>, greater<pair<int, int>>>& k_xset,
                long long& sum, int x) {
        if (k_xset.size() == 0) {
            return;
        }
        if (xset.size() < x) {
            auto it = k_xset.begin();
            xset.insert(*it);
            sum += it->first * it->second;
            k_xset.erase(it);
        } else if (*k_xset.begin() > *xset.rbegin()) {
            auto itx = xset.end();
            auto it = k_xset.begin();
            itx--;
            sum -= itx->first * itx->second - it->first * it->second;
            k_xset.insert(*itx);
            xset.erase(itx);
            xset.insert(*it);
            k_xset.erase(it);
        }
    }

    void insert(int val, set<pair<int, int>, greater<pair<int, int>>>& xset,
                set<pair<int, int>, greater<pair<int, int>>>& k_xset,
                map<int, int>& num, long long& sum, int x) {
        if (xset.find({num[val], val}) == xset.end()) {
            if (k_xset.count({num[val], val})) {
                k_xset.erase({num[val], val});
                k_xset.insert({num[val] + 1, val});
            } else {
                k_xset.insert({1, val});
            }
        } else {
            xset.erase({num[val], val});
            xset.insert({num[val] + 1, val});
            sum += val;
        }
        update(xset, k_xset, sum, x);
        num[val]++;
    }

    void erase(int val, set<pair<int, int>, greater<pair<int, int>>>& xset,
               set<pair<int, int>, greater<pair<int, int>>>& k_xset,
               map<int, int>& num, long long& sum, int x) {
        if (k_xset.find({num[val], val}) == k_xset.end()) {
            xset.erase({num[val], val});
            xset.insert({num[val] - 1, val});
            sum -= val;
        } else {
            k_xset.erase({num[val], val});
            if (num[val] > 1) {
                k_xset.insert({num[val] - 1, val});
            }
        }
        update(xset, k_xset, sum, x);
        num[val]--;
    }
};",1420582387
Bayartsogt Yadamsuren,bayartsogt,304,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect = []
        def go(node):
            if node is None:
                return 0
            
            l = go(node.left)
            r = go(node.right)
            
            if l >= 0 and r >= 0 and l == r:
                nonlocal perfect
                perfect.append(l + r + 1)
                return l + r + 1
            else:
                return -1
        
        go(root)
        perfect.sort(reverse=True)
        if len(perfect) <= k - 1:
            return -1
        
        # print(perfect, k-1)
        return perfect[k - 1]",1420544141
Bayartsogt Yadamsuren,bayartsogt,304,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        N = len(nums)
        
        sl = SortedList(key = lambda x: (-x[0], -x[1]))
        
        x2count = {}
        
        ans = []
        current = 0
        for i in range(N):
            # add
            cnt = 0
            prev_index = inf
            if nums[i] in x2count:
                cnt = x2count[nums[i]]
                prev_index = sl.index((cnt, nums[i]))
                sl.remove((cnt, nums[i]))

            sl.add((cnt + 1, nums[i]))
            x2count[nums[i]] = cnt + 1
            
            new_index = sl.index((cnt + 1, nums[i]))
            
            # print(i, nums[i], sl, prev_index, new_index)
            
            if prev_index < x and new_index < x:
                current += nums[i]
            
            elif prev_index >= x and new_index < x:
                
                if len(sl) >= x + 1:
                    a, b = sl[x]
                    current -= a * b
                current += (cnt + 1) * nums[i]
            
            # print(i, nums[i], current)
            
            if i >= k:
                cnt = x2count.get(nums[i - k], 0)
                prev_index = sl.index((cnt, nums[i - k]))
                
                sl.remove((cnt, nums[i - k]))
                sl.add((cnt - 1, nums[i - k]))
                
                x2count[nums[i - k]] = cnt - 1
                
                new_index = sl.index((cnt - 1, nums[i - k]))
                
                # print(prev_index, new_index)
                if prev_index < x and new_index < x:
                    current -= nums[i - k]

                elif prev_index < x and new_index >= x:
                    a, b = sl[x - 1]
                    current += a * b
                    current -= (cnt) * nums[i - k]
            
            if i >= k - 1:
                ans.append(current)
                
            # print(i, nums[i], current, sl)
            # if i >= k-1:
        return ans
                
        
        ",1420594786
Bayartsogt Yadamsuren,bayartsogt,304,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        N = len(nums)
        
        counter = Counter()
        ans = []
        for i in range(N):
            counter[nums[i]] += 1
            if i >= k:
                counter[nums[i - k]] -= 1
            
            if i >= k-1:
                topx = sorted([(value, key) for key, value in counter.items()], reverse=True)[:x]
                # print(i, nums[i], topx, counter)
                cur = 0
                for value, key in topx:
                    cur += value * key
                ans.append(cur)
        return ans
                
        
        ",1420528217
Андрей Хромых,khromykh,305,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        var q = new PriorityQueue<Integer>((a, b) -> b - a);
        dfs(root, q);
        int res = 0;
        for (int i = 0; i < k; i++) {
            if (q.isEmpty()) return -1;
            res = q.poll();
        }
        return res;
    }


    Res dfs(TreeNode node, Queue<Integer> q) {
        if (node == null) {
            return new Res(0, true);
        }
        var res1 = dfs(node.left, q);
        var res2 = dfs(node.right, q);
        if (res1.perfect() && res2.perfect() && res1.count() == res2.count()) {
            int count = res1.count + res2.count + 1;
            q.offer(count);
            return new Res(count, true);
        }
        else return new Res(0, false);
    }

    record Res(int count, boolean perfect) {}

}",1420589119
Андрей Хромых,khromykh,305,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        long[] res = new long[n - k + 1];
        Map<Integer, Integer> map = new HashMap<>();
        Str str = new Str(x);
        for (int i = 0; i < n; i++) {
            str.add(nums[i]);
            // str.print();
            if (i >= k) {
                str.remove(nums[i-k]);
                // str.print();
            }
            if (i >= k - 1) {
                res[i-k+1] = str.sum;
            }
            // System.out.println(""----------"");
        }       
        return res;
    }

    class Str {
        long sum = 0;
        int k;
        Str(int k) {
            this.k = k;
        }

        TreeSet<Item> left = new TreeSet<>((a, b) -> (int)(a.count == b.count ? a.val - b.val : a.count - b.count));
        TreeSet<Item> right = new TreeSet<>((a, b) -> (int)(a.count == b.count ? a.val - b.val : a.count - b.count));

        void print() {
            System.out.println(left);
            System.out.println(right);
            System.out.println(sum);
        }

        void put(Item item) {
            left.add(item);
            sum += item.val * item.count;
            if (left.size() > k) {
                var i = left.pollFirst();
                sum -= i.val * i.count;
                right.add(i);
            }
        }

        void remove(Item item) {
            if (left.contains(item)) {
                left.remove(item);
                sum -= item.val * item.count;
                if (left.size() < k && right.size() != 0) {
                    var ii = right.removeLast();
                    left.add(ii);
                    sum += ii.val * ii.count;
                }
            }
            else {
                right.remove(item);
            }
        }


        Map<Integer, Integer> map = new HashMap<>();

        void add(int x) {
            if (!map.containsKey(x)) {
                put(new Item(1, x));
            }
            else {
                remove(new Item(map.get(x), x));
                put(new Item(map.get(x) + 1, x));
            }
            map.merge(x, 1, Integer::sum);
        }

        void remove(int x) {
            remove(new Item(map.get(x), x));
            if (map.get(x) > 1) {
                put(new Item(map.get(x) - 1, x));
            }
            map.merge(x, -1, Integer::sum);
        }

        static record Item(int count, long val) {}
    }


    

    // class Item {
    //     int count;
    //     int value;
    //     Count(int c, int v) {
    //         count = c;
    //         value = v;
    //     }
    // }
}",1420584417
Андрей Хромых,khromykh,305,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] res = new int[n - k + 1];
        for (int i = 0; i < n - k + 1; i++) {
            Map<Integer, Integer> map = new HashMap<>();
            for (int j = i; j < i + k; j++) {
                map.merge(nums[j], 1, Integer::sum);
            }
            int sum = map.entrySet().stream().sorted((a, b) -> a.getValue().equals(b.getValue()) ? b.getKey() - a.getKey() : b.getValue() - a.getValue())
                .limit(x)
                .mapToInt(e -> e.getKey() * e.getValue())
                .sum();
            res[i] = sum;
        }       
        return res;
    }
}",1420584609
fizhim,fizhim,308,3509,javascript,"/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargestPerfectSubtree = function(root, k) {
    let a = [];
    const f = (node) => {
        if (node) {
            let [bl, dl] = f(node.left);
            let [br, dr] = f(node.right);
            if (bl && br && dl == dr) {
                let d = dl + 1;
                a.push(d);
                return [true, d];
            }
        }
        return [!node, 0];
    };
    f(root);
    a.sort((x, y) => y - x);
    return k > a.length ? -1 : ((1 << a[k - 1]) - 1);
};",1420597754
fizhim,fizhim,308,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        using LL = long long;
        
        unordered_map<int, int> h;
        
        for (int i = 0; i < k; ++i) {
            ++h[nums[i]];
        }
        
        LL sum = 0;
        set<pair<int, int>> s;
        set<pair<int, int>> s0;
        
        for (auto & [x, c]: h) {
            sum += LL(x) * c;
            s.insert({c, x});
        }

        while (s.size() > x) {
            auto it = s.begin();
            sum -= LL(it->second) * it->first;
            s0.insert(*it);
            s.erase(it);
        }
        
        vector<LL> ans{sum};
        
        for (int i = k; i < nums.size(); ++i) {
            {
                auto x = nums[i];
                auto & cx = h[x];

                auto it = s.find({cx, x});
                if (it == s.end()) {
                    s0.erase({cx, x});
                } else {
                    sum -= LL(x) * cx;
                    s.erase(it);
                }

                ++cx;
                s.insert({cx, x});
                sum += LL(x) * cx;
                //printf(""+ i: %d x:%d cx:%d sum:%d\n"", i, x, cx, int(sum));
            }
            
            {
                auto x = nums[i - k];
                auto & cx = h[x];

                auto it = s.find({cx, x});
                if (it == s.end()) {
                    s0.erase({cx, x});
                } else {
                    sum -= LL(x) * cx;
                    s.erase(it);
                }

                --cx;
                if (cx > 0) {
                    s.insert({cx, x});
                    sum += LL(x) * cx;
                }
                //printf(""- i: %d x:%d cx:%d sum:%d\n"", i, x, cx, int(sum));
            }
            
            if (!s0.empty()) {
                auto it = prev(s0.end());
                sum += LL(it->second) * it->first;
                s.insert(*it);
                s0.erase(it);
            }
            
            while (s.size() > x) {
                auto it = s.begin();
                sum -= LL(it->second) * it->first;
                s0.insert(*it);
                s.erase(it);
            }
        
            ans.push_back(sum);
        }
        
        return ans;
    }
};",1420596928
fizhim,fizhim,308,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        using LL = int;
        
        unordered_map<int, int> h;
        
        for (int i = 0; i < k; ++i) {
            ++h[nums[i]];
        }
        
        LL sum = 0;
        set<pair<int, int>> s;
        set<pair<int, int>> s0;
        
        for (auto & [x, c]: h) {
            sum += LL(x) * c;
            s.insert({c, x});
        }

        while (s.size() > x) {
            auto it = s.begin();
            sum -= LL(it->second) * it->first;
            s0.insert(*it);
            s.erase(it);
        }
        
        vector<LL> ans{sum};
        
        for (int i = k; i < nums.size(); ++i) {
            {
                auto x = nums[i];
                auto & cx = h[x];

                auto it = s.find({cx, x});
                if (it == s.end()) {
                    s0.erase({cx, x});
                } else {
                    sum -= LL(x) * cx;
                    s.erase(it);
                }

                ++cx;
                s.insert({cx, x});
                sum += LL(x) * cx;
                //printf(""+ i: %d x:%d cx:%d sum:%d\n"", i, x, cx, int(sum));
            }
            
            {
                auto x = nums[i - k];
                auto & cx = h[x];

                auto it = s.find({cx, x});
                if (it == s.end()) {
                    s0.erase({cx, x});
                } else {
                    sum -= LL(x) * cx;
                    s.erase(it);
                }

                --cx;
                if (cx > 0) {
                    s.insert({cx, x});
                    sum += LL(x) * cx;
                }
                //printf(""- i: %d x:%d cx:%d sum:%d\n"", i, x, cx, int(sum));
            }
            
            if (!s0.empty()) {
                auto it = prev(s0.end());
                sum += LL(it->second) * it->first;
                s.insert(*it);
                s0.erase(it);
            }
            
            while (s.size() > x) {
                auto it = s.begin();
                sum -= LL(it->second) * it->first;
                s0.insert(*it);
                s.erase(it);
            }
        
            ans.push_back(sum);
        }
        
        return ans;
    }
};",1420597608
Cecilia Chan,cecilia5,309,3509,python,"
class Solution(object):
    def helper(self, node, answers):
        if node is None:
            return 0
        else:
            l = self.helper(node.left, answers)
            r = self.helper(node.right, answers)
            if l != -1 and l == r:
                answers.append(l + 1)
                return (l + 1)
            else:
                return -1

    def kthLargestPerfectSubtree(self, root, k):
        answers = []
        self.helper(root, answers)
        if len(answers) >= k:
            answers.sort()
            answers.reverse()
            return 2 ** answers[k - 1] - 1
        else:
            return -1",1420533312
Cecilia Chan,cecilia5,309,3592,python3,"from sortedcontainers import SortedList

class Solution(object):

    def deleteElement(self, best, xsum, f, v, x):
        if best.index((-f, -v)) < x:
            if len(best) > x:
                (nnf, nnx) = best[x]
                xsum += (-nnf) * (-nnx)
            xsum -= f * v
        best.discard((-f, -v))        
        return xsum
    
    def newElement(self, best, xsum, f, v, x):
        if len(best) >= x:
            (nkf, nkx) = best[x - 1]
        else:
            (nkf, nkx) = (0, 0)
        best.add((-f, -v))
        if best.index((-f, -v)) < x:
            xsum += f * v
            xsum -= (-nkf) * (-nkx)
        return xsum

    def findXSum(self, nums, k, x):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        log = False
        n = len(nums)
        result = []
        freq = {}
        best = SortedList() # entries are (-f, -v)
        xsum = 0
        for i in range(n):
            if log:
                print()
                print(""Processing the %s element with value %s"" % (i, nums[i]))
            if i >= k:
                v = nums[i - k]
                f = freq[v]
                if (-f, -v) in best:
                    if log:
                        print(""Deleting (%s,%s) from best"" % (f, v))
                    xsum = self.deleteElement(best, xsum, f, v, x)
                    if log:
                        print(freq, best, xsum)
                freq[v] -= 1
                f -= 1
                if f > 0:
                    if log:
                        print(""Insert (%s,%s) into best"" % (f, v))
                    xsum = self.newElement(best, xsum, f, v, x)
                    if log:
                        print(freq, best, xsum)
            # insert
            v = nums[i]
            if v not in freq:
                freq[v] = 0
            else:
                f = freq[v]
                if (-f, -v) in best:
                    if log:
                        print(""Old entry found, deleting"")
                    xsum = self.deleteElement(best, xsum, f, v, x)
                    if log:
                        print(freq, best, xsum)
            freq[v] += 1
            f = freq[v]
            if log:
                print(""New entry created, inserting"")
            xsum = self.newElement(best, xsum, f, v, x)
            if log:
                print(freq, best, xsum)
            if i >= k - 1:
                if log:
                    print(""Take"")
                result.append(xsum)
        return result",1420597770
Cecilia Chan,cecilia5,309,3610,python,"class Solution(object):
    def findXSum(self, nums, k, x):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        
class Solution(object):
    def findXSum(self, nums, k, x):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        n = len(nums)
        result = []
        for i in range(n - k + 1):
            window = nums[i:i + k]
            freq = {}
            for v in window:
                if v not in freq:
                    freq[v] = 0
                freq[v] += 1
            entries = []
            for v in freq:
                entries.append((freq[v], v))
            entries.sort()
            entries.reverse()
            # print(window)
            
            if len(entries) > x:
                entries = entries[0:x]
            # print(entries)
            result.append(sum([f * v for (f, v) in entries]))
        return result
            ",1420526799
keysersoze29,keysersoze29,310,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<int,int> fun(TreeNode* root, vector<int>&m){
        if(root==NULL){
            return {0,0};
        }
        pair<int,int> l = fun(root->left, m);
        pair<int,int> r = fun(root->right, m);
        
        if(l.first==r.first && l.first!=-1){
            int val = l.second+r.second+1;
            m.push_back(val);
            return {l.first+1, val};
        }
        return {-1, -1};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int>ans;
        fun(root, ans);
        sort(ans.rbegin(),ans.rend());
        int sz=ans.size();
        if(k<=sz){
            return ans[k-1];
        }
        return -1;
    }
};",1420539795
keysersoze29,keysersoze29,310,3592,cpp,"#define ll long long
class Solution {
public:
    vector<long long> findXSum(vector<int>& a, int k, int x) {
        int n=a.size();
        vector<ll>ans;
        map<ll,ll>m;
        set<pair<ll,ll>>left,right;
        ll sum=0;

        for(int i=0;i<n;i++){
            ll ear = m[a[i]];
            m[a[i]]++;

            if(left.find({ear,a[i]})!=left.end()) {
                left.erase({ear,a[i]});
                left.insert({ear+1,a[i]});
                sum+=a[i];
            }else {
                if(left.size()<x) {
                    left.insert({ear+1,a[i]});
                    sum+=a[i];
                }else {
                    if(right.find({ear,a[i]})!=right.end()) {
                        right.erase({ear,a[i]});
                    }
                    right.insert({ear+1,a[i]});

                    auto it=right.rbegin();
                    pair<ll,ll>t = *it;

                    auto it1 = left.begin();
                    pair<ll,ll>tt= *it1;

                    if(t.first>tt.first || (t.first==tt.first && t.second>tt.second)) {
                        right.erase(t);
                        left.erase(tt);
                        sum-=(tt.first*tt.second);

                        left.insert(t);
                        right.insert(tt);
                        sum+=(t.first*t.second);
                    }
                }
            }
            if(i>=(k-1)) {
                ans.push_back(sum);
                ll val = a[i-k+1];
                ear = m[val];
                m[val]--;

                if(left.find({ear,val})!=left.end()) {
                    left.erase({ear,val});
                    sum-=val;
                    if((ear-1)==0) {
                        if(right.size()>0) {
                            auto it=right.rbegin();
                            pair<ll,ll>t = *it;
                            right.erase(t);
                            left.insert(t);
                            sum+=(t.first*t.second);
                        }
                    } else {
                        left.insert({ear-1,val});
                    }
                }else {
                    right.erase({ear,val});
                    if((ear-1)>0) {
                        right.insert({ear-1,val});
                    }
                }

                if(right.size()>0) {
                    auto it=right.rbegin();
                    pair<ll,ll>t = *it;

                    if(left.size()>0) {
                        auto it1 = left.begin();
                        pair<ll,ll>tt= *it1;
                        if(t.first>tt.first || (t.first==tt.first && t.second>tt.second)) {
                            right.erase(t);
                            left.erase(tt);
                            sum-=(tt.first*tt.second);

                            left.insert(t);
                            right.insert(tt);
                            sum+=(t.first*t.second);
                        }
                    }else {
                        right.erase(t);
                        left.insert(t);
                        sum+=(t.first*t.second);
                    }
                }
            }
        }
        return ans;
    }
};
",1420591124
keysersoze29,keysersoze29,310,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n=a.size();
        vector<int>ans;
        for(int i=0;i<(n-k+1);i++){
            map<int,int>m;
            for(int j=i;j<(i+k);j++){
                m[a[j]]++;
            }
            vector<vector<int>>v;
            for(auto i:m){
                v.push_back({i.second,i.first});
            }
            sort(v.begin(),v.end());
            int sz=v.size();
            int val=0;
            for(int j=sz-1;j>=max(sz-x,0);j--){
                val+=(v[j][0]*v[j][1]);
            }
            ans.push_back(val);
        }
        return ans;
    }
};",1420522532
Hogwartsss,Hogwartsss,311,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        nums = []
        def dfs(node):
            if node == None:
                return True, 0
            p, s = dfs(node.left)
            p1, s1 = dfs(node.right)
            # print(node.val, p, p1, s, s1)
            if p and p1 and s == s1:
                nums.append(s + s1 + 1)
                return True, s + s1 + 1
            return False, s + s1 + 1
        dfs(root)
        nums.sort(reverse=True)
        return -1 if len(nums) < k else nums[k-1]",1420567848
Hogwartsss,Hogwartsss,311,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        unordered_map<long long, int> freq;
        vector<long long> ans;
        long long sum = 0;
        using pii = pair<long long, long long>;
        set<pii> top_x;
        for(int i = 0; i < k - 1; ++i) {
            freq[nums[i]]++;
        }
        for(auto& [a, b]: freq) {
            top_x.insert({b, a});
            sum += a * b;
        }
        set<pii> remain;
        while(top_x.size() > x) {
            auto p = *top_x.begin();
            sum -= p.first * p.second;
            remain.insert(*top_x.begin());
            top_x.erase(top_x.begin());
        }
        for(int i = k - 1; i < n; ++i) {
            if(i > k - 1) {
                int num = nums[i - k];
                auto iter = top_x.find({freq[num], num});
                if(iter != top_x.end()) {
                    sum -= iter->first * iter->second;
                    top_x.erase(iter);
                }
                remain.erase({freq[num], num});
                if(--freq[num] == 0) {
                    freq.erase(num);
                } else {
                    remain.insert({freq[num], num});
                }
            }
            int num = nums[i];
            auto iter = top_x.find({freq[num], num});
            if(iter != top_x.end()) {
                sum -= iter->first * iter->second;
                top_x.erase(iter);
            }
            remain.erase({freq[num], num});
            freq[num]++;
            remain.insert({freq[num], num});
            while(remain.size() && (*top_x.begin() < *(prev(remain.end())) || top_x.size() < x)) {
                auto iter = prev(remain.end());
                top_x.insert(*iter);
                sum += iter->first * iter->second;
                remain.erase(iter);
            }
            while(top_x.size() > x) {
                auto p = *top_x.begin();
                sum -= p.first * p.second;
                remain.insert(*top_x.begin());
                top_x.erase(top_x.begin());
            }
            ans.push_back(sum);
        }

        return ans;
    }
};",1420603695
Hogwartsss,Hogwartsss,311,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        map<int, int> freq;
        vector<int> ans;
        for(int i = 0; i < k - 1; ++i) {
            freq[nums[i]]++;
        }
        for(int i = k - 1; i < n; ++i) {
            if(i > k - 1) {
                if(--freq[nums[i - k]] == 0) {
                    freq.erase(nums[i - k]);
                }
            }
            freq[nums[i]]++;
            using pii = pair<int, int>;
            vector<pii> tmp;
            for(auto& [num, cnt]: freq) {
                tmp.emplace_back(cnt, num);
            }
            sort(begin(tmp), end(tmp), std::greater<pii>());
            int m = tmp.size();
            int sum = 0;
            for(int j = 0; j < min(m, x); ++j) {
                sum += tmp[j].first * tmp[j].second;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420541748
Nikhil Paul,nikhil_paul,312,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(node):
            nonlocal fans
            if not node: return 0
            if not (node.left or node.right):
                fans.append(1)
                return 1
            a = dfs(node.left)
            b = dfs(node.right)
            if (a and b) and a == b:
                fans.append(a+b+1)
                return a+b+1
            return 0
        fans = []
        dfs(root)
        if len(fans) >= k:
            return sorted(fans, reverse=True)[k-1]
        return -1",1420533059
Nikhil Paul,nikhil_paul,312,3592,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from sortedcontainers import SortedList
        d, n = Counter(nums[:k]), len(nums)
        s, t = SortedList([(-j, -i) for i, j in d.items()]), 0
        while len(s) <= x: _, t = s.add((0, t)), t+1
        ans = sum(-i*-j for i, j in s[:x])
        fans = [ans]
        for i in range(k, n):
            t, u, v = s[x-1], d[nums[i-k]], nums[i-k]
            d[v] -= 1
            s.remove((-u, -v))
            if s[x-1] != t: ans += (s[x-1][0])*s[x-1][1] - (u*v)
            t = s[x-1]
            s.add((-u+1, -v))
            if s[x-1] != t: ans += -(t[0]*t[1]) + ((u-1)*v)

            if nums[i] in d:
                t, u, v = s[x-1], d[nums[i]], nums[i]
                d[nums[i]] += 1
                s.remove((-u, -v))
                if s[x-1] != t: ans += (s[x-1][0])*s[x-1][1] - (u*v)
                t = s[x-1]
                s.add((-u-1, -v))
                if s[x-1] != t: ans+= -(t[0]*t[1]) + ((u+1)*v)
            else:
                t = s[x-1]
                d[nums[i]] = 1
                s.add((-1, -nums[i]))
                if s[x-1] != t: ans += -(t[0]*t[1]) + nums[i]
            fans.append(ans)
        return fans
",1420603803
Nikhil Paul,nikhil_paul,312,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def check(l):
            c = sorted([(j,i) for i,j in Counter(l).items()], reverse=True)
            return sum(i*j for i,j in c[:x])
        
        ans, n = [], len(nums)
        for i in range(0, n-k+1):
            ans.append(check(nums[i:i+k]))
        return ans",1420523623
volodymyr_k,volodymyr_k,313,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> list = new ArrayList<>();
        dfs(root, list);
        
        if (list.size() < k) return -1;
        
        Collections.sort(list, Comparator.comparingInt(v -> -v));
        
        //System.out.println(list);
        
        return list.get(k - 1);
    }
    
    private int[] dfs(TreeNode node, List<Integer> list) {
        if (node == null) return new int[] {0, 0};
        
        int[] l = dfs(node.left, list), r = dfs(node.right, list);
        
        if (l[0] == r[0] && l[0] != -1) {
            //System.out.println(node.val);
            list.add(l[1] + r[1] + 1);
            return new int[] { l[0] + 1, l[1] + r[1] + 1 };
        }
        
        return new int[] { -1, 0 };
    }
}",1420538525
volodymyr_k,volodymyr_k,313,3592,java,"class Solution {
    private static Comparator<Smth> smthComparator = Comparator.<Smth>comparingLong(v -> -v.freq).thenComparingInt(v -> -v.val);
    public long[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        TreeSet<Smth> biggest = new TreeSet<>(smthComparator);
        TreeSet<Smth> smallest = new TreeSet<>(smthComparator);

        Map<Integer, Smth> map = new HashMap<>();

        long[] res = new long[n - k + 1];
        long cur = 0;

        for (int i = 0; i < n; i++) {
            if (i - k >= 0) {
                cur = remove(nums[i - k], map, biggest, smallest, cur, x);
            }

            cur = add(nums[i], map, biggest, smallest, cur, x);

            if (i + 1 >= k) {
                res[i + 1 - k] = cur;
            }
        }

        return res;
    }

    private long add(int num, Map<Integer, Smth> map, TreeSet<Smth> biggest, TreeSet<Smth> smallest, long cur, int x) {
        Smth s = map.get(num);
        if (s == null) {
            s = new Smth(num, 1, 0);
            map.put(num, s);
            smallest.add(s);
        } else {
            if (s.pile == 1) {
                biggest.remove(s);
                s.freq++;
                biggest.add(s);
                cur += s.val;
            } else {
                smallest.remove(s);
                s.freq++;
                smallest.add(s);
            }
        }

        return move(biggest, smallest, cur, x);
    }

    private long move(TreeSet<Smth> biggest, TreeSet<Smth> smallest, long cur, int x) {
        if (biggest.size() < x) {
            if (!smallest.isEmpty()) {
                Smth s = smallest.pollFirst();
                s.pile = 1;
                biggest.add(s);
                cur += s.val*s.freq;
            }
        }

        if (biggest.size() == x && !smallest.isEmpty()) {
            if (smthComparator.compare(biggest.last(), smallest.first()) > 0) {
                Smth b = biggest.pollLast();
                Smth s = smallest.pollFirst();

                cur -= b.val*b.freq;
                cur += s.val*s.freq;

                b.pile = 0;
                s.pile = 1;

                biggest.add(s);
                smallest.add(b);
            }
        }

        return cur;
    }

    private long remove(int num, Map<Integer, Smth> map, TreeSet<Smth> biggest, TreeSet<Smth> smallest, long cur, int x) {
        Smth s = map.get(num);

        if (s.pile == 1) {
            biggest.remove(s);
            s.freq--;
            if (s.freq > 0) biggest.add(s);
            else map.remove(num);
            cur -= s.val;
        } else {
            smallest.remove(s);
            s.freq--;
            if (s.freq > 0) smallest.add(s);
            else map.remove(num);
        }

        return move(biggest, smallest, cur, x);
    }

    private static class Smth {
        int val;
        long freq;
        int pile;

        public Smth(int num, long f, int p) {
            val = num;
            freq = f;
            pile = p;
        }

        @Override
        public String toString() {
            return ""Smth{"" +
                    ""val="" + val +
                    "", freq="" + freq +
                    "", pile="" + pile +
                    '}';
        }
    }
}",1420604338
volodymyr_k,volodymyr_k,313,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] res = new int[n - k + 1];
        
        for (int i = 0, start = 0, end = k - 1; end < n; start++, end++, i++) {
            res[i] = calc(nums, start, end, x);
        }
        
        return res;
    }
    
    private int calc(int[] nums, int start, int end, int x) {
        //System.out.println(start + "" "" + end + "" "" + x);
        
        int[][] sum = new int[51][2];
        for (int i = 0; i < sum.length; i++) sum[i][0] = i;
        
        for (int i = start; i <= end; i++) {
            sum[nums[i]][1]++;
        }
        
        Arrays.sort(sum, Comparator.<int[]>comparingInt(v -> -v[1]).thenComparing(v -> -v[0]));
        
        int res = 0;
        
        for (int i = 0; i < x; i++) {
            res += sum[i][0]*sum[i][1];
        }
        
        //System.out.println(res + "" "" + Arrays.deepToString(sum));
        
        return res;
    }
}",1420527302
funsquared,funsquared,316,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def height(root):
            if not root:
                return 0
            l, r = height(root.left), height(root.right)
            if l != -1 and l == r:
                res.append(2 ** (l + 1) - 1)
                return l + 1
            else:
                return -1
        height(root)
        res.sort(reverse=True)
        print(res)
        return res[k - 1] if k - 1 < len(res) else -1",1420605411
funsquared,funsquared,316,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        cnt = Counter()
        sl = SortedList()
        cnt = Counter()
        cur = 0
        
        def apply(val, delta):
            nonlocal cur

            if cnt[val]:
                j = sl.bisect_left((cnt[val], val))
                if j >= len(sl) - x:
                    cur -= cnt[val] * val
                    if len(sl) >= x + 1:
                        cur += sl[len(sl) - x - 1][0] * sl[len(sl) - x - 1][1]
                sl.remove((cnt[val], val))

            cnt[val] += delta
            j = sl.bisect_left((cnt[val], val))
            if j > len(sl) - x:
                cur += cnt[val] * val
                if len(sl) >= x:
                    cur -= sl[len(sl) - x][0] * sl[len(sl) - x][1]
            sl.add((cnt[val], val))
       
        for i in range(len(nums)):
            apply(nums[i], 1)            
            if i - k >= 0:
                apply(nums[i - k], -1)
            if i - k + 1 >= 0:
                res.append(cur)
        return res",1420604826
funsquared,funsquared,316,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums) - k + 1):
            cnt = Counter(nums[i:i+k])
            res.append(sum(k * v for v, k in nlargest(x, ((v, k) for k, v in cnt.items()))))
        return res",1420605511
Shakib,cakoshakib,317,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from sortedcontainers import SortedList
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfectSubtrees = SortedList()
        def isPerfectSubtree(node):
            if not node:
                return True, 0
            leftPerf, leftSize = isPerfectSubtree(node.left)
            rightPerf, rightSize = isPerfectSubtree(node.right)
            if leftPerf and rightPerf and leftSize == rightSize:
                perfectSubtrees.add(leftSize + rightSize + 1)
                return True, leftSize + rightSize + 1
            return False, leftSize + rightSize + 1
        isPerfectSubtree(root)
        return perfectSubtrees[-k] if k <= len(perfectSubtrees) else -1
        




",1420532115
Shakib,cakoshakib,317,3592,python3,"from bisect import bisect_left
from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)

        l = 0
        counts = defaultdict(int)
        window = SortedList()

        ans = []
        counter = itertools.count()
        sm = 0
        def inWindow(idx):
            return max(0, len(window) - x) <= idx < len(window)

        def updateWindow(prevCount, newCount, val):
            nonlocal sm
            idx = window.bisect_left((prevCount, val))
            wasInWindow = False
            # if it is already in the window then remove
            if idx < len(window) and window[idx][1] == val:
                # if it is in the range we want to sum
                if inWindow(idx):
                    wasInWindow = True
                    sm -= prevCount * val
                window.pop(idx)
            # add to window if count is > 0
            if newCount > 0:
                window.add((newCount, val))
            newIdx = window.bisect_left((newCount, val))
            # update sum if it is in the range we want
            if newCount > 0 and inWindow(newIdx):
                sm += newCount * val
                # if it wasnt in the window and is now in the window we may have kicked something out
                if not wasInWindow and len(window) > x:
                    removedCount, removedVal = window[len(window) - x - 1]
                    sm -= removedCount * removedVal
            # something new just got added to the window
            elif wasInWindow and len(window) >= x:
                    addedCount, addedVal = window[len(window) - x]
                    sm += addedCount * addedVal


        for r in range(n):
            counts[nums[r]] += 1
            updateWindow(counts[nums[r]] - 1, counts[nums[r]], nums[r])
            if (r - l + 1) == k:
                ans.append(sm)
            if (r - l + 1) >= k:
                updateWindow(counts[nums[l]], counts[nums[l]] - 1, nums[l])
                counts[nums[l]] -= 1
                l += 1
        return ans
            

        ",1420588196
Shakib,cakoshakib,317,3610,python3,"from collections import Counter
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)

        l = 0
        counts = defaultdict(int)
        ans = []
        for r in range(n):
            counts[nums[r]] += 1
            if (r - l + 1) == k:
                pq = []
                for num, count in counts.items():
                    heapq.heappush(pq, (-count, -num))
                sm = 0
                for _ in range(min(len(pq), x)):
                    count, num = heapq.heappop(pq)
                    sm += -num * -count
                ans.append(sm)
            if (r - l + 1) >= k:
                counts[nums[l]] -= 1
                l += 1
        return ans
            

        ",1420525620
Facundo Galán,facug91,319,3509,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
private:
	vector<int> sizes;

	pair<int, bool> solve(TreeNode* node) {
		if (!node) return { 0, false };
		if (!node->left && !node->right) {
			sizes.push_back(1);
			return { 1, true };
		}
		auto leftAns = solve(node->left);
		auto rightAns = solve(node->right);
		if (leftAns.second && rightAns.second && leftAns.first == rightAns.first) {
			sizes.push_back(leftAns.first * 2 + 1);
			return { leftAns.first * 2 + 1, true };
		}
		return { 0, false };
	}

public:
	int kthLargestPerfectSubtree(TreeNode* root, int k) {
		solve(root);
		if (sizes.size() < k) return -1;
		sort(sizes.begin(), sizes.end(), greater<>());
		return sizes[k - 1];
	}
};",1420530778
Facundo Galán,facug91,319,3592,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
public:
	vector<long long> findXSum(vector<int>& nums, int k, int x) {
		set<pair<long long, long long>> used, unused;
		unordered_map<long long, bool> inUsed;
		unordered_map<long long, long long> counter;
		long long sum = 0;
		vector<long long> ans;
		int n = (int)nums.size(), i = 0;
		for (; i < k; i++) {
			long long num = nums[i];
			counter[num]++;
			long long currCounter = counter[num];
			if (used.size() < x) {
				if (currCounter == 1) {
					used.emplace(currCounter, num);
					inUsed[num] = true;
					sum += num;
				} else {
					used.erase(std::make_pair(currCounter - 1, num));
					used.emplace(currCounter, num);
					inUsed[num] = true;
					sum += num;
				}
			} else {
				if (currCounter == 1 || !inUsed[num]) {
					auto firstElem = *used.begin();
					if (firstElem.first < currCounter || (firstElem.first == currCounter && firstElem.second < num)) {
						used.erase(firstElem);
						unused.insert(firstElem);
						inUsed[firstElem.second] = false;
						sum -= firstElem.first * firstElem.second;
						unused.erase(std::make_pair(currCounter - 1, num));
						used.emplace(currCounter, num);
						inUsed[num] = true;
						sum += num * currCounter;
					} else {
						unused.erase(std::make_pair(currCounter - 1, num));
						unused.emplace(currCounter, num);
						inUsed[num] = false;
					}
				} else {
					used.erase(std::make_pair(currCounter - 1, num));
					used.emplace(currCounter, num);
					sum += num;
					inUsed[num] = true;
				}
			}
		}
		ans.push_back(sum);
		for (; i < n; i++) {
			long long num = nums[i - k];
			counter[num]--;
			long long currCounter = counter[num];
			if (inUsed[num]) {
				sum -= num * (currCounter + 1);
				used.erase(std::make_pair(currCounter + 1, num));
				inUsed[num] = false;
				if (currCounter > 0)
					unused.emplace(currCounter, num);
				if (!unused.empty()) {
					auto lastElem = *(--unused.end());
					unused.erase(lastElem);
					used.insert(lastElem);
					inUsed[lastElem.second] = true;
					sum += lastElem.first * lastElem.second;
				}
			} else {
				unused.erase(std::make_pair(currCounter + 1, num));
				if (currCounter > 0)
					unused.emplace(currCounter, num);
			}

			num = nums[i];
			counter[num]++;
			currCounter = counter[num];

			if (used.size() < x) {
				if (currCounter == 1) {
					used.emplace(currCounter, num);
					inUsed[num] = true;
					sum += num;
				} else {
					used.erase(std::make_pair(currCounter - 1, num));
					used.emplace(currCounter, num);
					inUsed[num] = true;
					sum += num;
				}
			} else {
				if (currCounter == 1 || !inUsed[num]) {
					auto firstElem = *used.begin();
					if (firstElem.first < currCounter || (firstElem.first == currCounter && firstElem.second < num)) {
						used.erase(firstElem);
						unused.insert(firstElem);
						inUsed[firstElem.second] = false;
						sum -= firstElem.first * firstElem.second;
						unused.erase(std::make_pair(currCounter - 1, num));
						used.emplace(currCounter, num);
						inUsed[num] = true;
						sum += num * currCounter;
					} else {
						unused.erase(std::make_pair(currCounter - 1, num));
						unused.emplace(currCounter, num);
						inUsed[num] = false;
					}
				} else {
					used.erase(std::make_pair(currCounter - 1, num));
					used.emplace(currCounter, num);
					sum += num;
					inUsed[num] = true;
				}
			}
			ans.push_back(sum);
		}
		return ans;
	}
};",1420601356
Facundo Galán,facug91,319,3610,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
private:
	int solve(const vector<int>& nums, int x, int l, int r) {
		vector<int> cnt(51, 0);
		for (int i = l; i <= r; i++)
			cnt[nums[i]]++;
		vector<pair<int, int>> sums;
		for (int i = 1; i <= 50; i++)
			if (cnt[i] > 0)
				sums.emplace_back(cnt[i], i);
		sort(sums.begin(), sums.end(), greater<>());
		int i = 0, ans = 0;
		while (i < sums.size() && i < x) {
			ans += sums[i].second * sums[i].first;
			i++;
		}
		return ans;
	}

public:
	vector<int> findXSum(vector<int>& nums, int k, int x) {
		vector<int> ans;
		int n = (int)nums.size();
		for (int i = 0; i <= n - k; i++)
			ans.push_back(solve(nums, x, i, i + k - 1));
		return ans;
	}
};",1420524200
sjkdwe,sjkdwe,320,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def dfs(node):
            if not node: return 0, 0
            l, hl = dfs(node.left)
            r, hr = dfs(node.right)
            if r == l and r == 2 ** hr - 1 and l == 2 ** hl - 1:
                res.append(1 + l + r)
            return 1 + l + r, max(hl, hr) + 1
        dfs(root)
        return -1 if k - 1 >= len(res) else sorted(res, reverse=True)[k-1]

        # 2^h - 1
",1420534043
sjkdwe,sjkdwe,320,3592,python3,"from sortedcontainers import SortedList
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        s = 0
        c = Counter(nums[:k-1])
        sd = SortedList((-freq, -val) for val, freq in c.items())
        s = sum(freq * val for freq, val in sd[:x])
        for i in range(k - 1, len(nums)):
            if i - k >= 0:
                j = sd.index((-c[nums[i-k]], -nums[i-k]))
                if j < x:
                    s -= c[nums[i-k]] * nums[i-k]
                    if x < len(sd):
                        s += sd[x][0] * sd[x][1]
                del sd[j]
                
                c[nums[i-k]] -= 1

                sd.add((-c[nums[i-k]], -nums[i-k]))
                j = sd.index((-c[nums[i-k]], -nums[i-k]))
                if j < x:
                    s += c[nums[i-k]] * nums[i-k]
                    if x < len(sd):
                        s -= sd[x][0] * sd[x][1]

            if c[nums[i]] > 0:
                j = sd.index((-c[nums[i]], -nums[i]))
                if j < x:
                    s -= c[nums[i]] * nums[i]
                    if x < len(sd):
                        s += sd[x][0] * sd[x][1]
                del sd[j]

            c[nums[i]] += 1

            sd.add((-c[nums[i]], -nums[i]))
            j = sd.index((-c[nums[i]], -nums[i]))
            if j < x:
                s += c[nums[i]] * nums[i]
                if x < len(sd):
                    s -= sd[x][0] * sd[x][1]
            

            ans.append(s)
        return ans",1420601799
sjkdwe,sjkdwe,320,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        c = Counter(nums[:k-1])
        for i in range(k - 1, len(nums)):
            if i - k >= 0:
                c[nums[i-k]] -= 1
            c[nums[i]] += 1
            ans.append(sum(c[y] * y for y in sorted(c, key=lambda y: (c[y], y), reverse=True)[:x]))
            # print(c.most_common(x))
            # ans.append( sum(key * val for key, val in c.most_common(x)) )
        return ans",1420526029
Dorjderem Namsraijav,dorjderemdorj202,321,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def is_perfect(node):
            if not node:
                return (True, 0, 0)
            
            lp, lz, lh = is_perfect(node.left)
            rp, rs, rh = is_perfect(node.right)
            
            if lp and rp and lh == rh:
                return (True, lz + rs + 1, lh + 1)
            else:
                return (False, max(lz, rs), max(lh, rh))
        
        # Traverse the tree to find all perfect subtrees
        def find_perfect_subtrees(node):
            if not node:
                return []
            
            perfect, size, _ = is_perfect(node)
            subtrees = find_perfect_subtrees(node.left) + find_perfect_subtrees(node.right)
            
            if perfect:
                subtrees.append(size)
                
            return subtrees
        
        perfect_subtree_sizes = find_perfect_subtrees(root)
        
        if len(perfect_subtree_sizes) < k:
            return -1
        
        perfect_subtree_sizes.sort(reverse=True)
        
        return perfect_subtree_sizes[k-1]",1420599245
Dorjderem Namsraijav,dorjderemdorj202,321,3592,cpp,"#define ll long long

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> ans(n - k + 1);
        map<ll,ll> mp;
        set<pair<ll,ll>> used, free;
        ll res = 0;
        for(int i=0;i<k - 1;i++) mp[nums[i]]++;
        for(auto it : mp) used.insert({it.second, it.first});
        while(used.size() > x) {
            free.insert(*used.begin());
            used.erase(used.begin());
        }
        for(auto it : used) res += it.second * it.first;
        for(int i=0;i<n-k+1;i++)
        {
            mp[nums[i + k - 1]]++;
            ll cnt = mp[nums[i + k - 1]] - 1;
            ll a = nums[i + k - 1];
            if((int)used.size() < x && used.find({cnt, a}) == used.end())
            {
                used.insert({cnt + 1, a});
                res += a;
            }
            else if(used.find({cnt, a}) != used.end())
            {
                used.erase({cnt, a});
                used.insert({cnt + 1, a});
                res += a;
            }
            else
            {
                if(free.find({cnt, a}) == free.end())
                {
                    free.insert({cnt + 1, a});
                }
                else
                {
                    free.erase({cnt, a});
                    free.insert({cnt + 1, a});
                }
                while(free.rbegin()->first > used.begin()->first || (free.rbegin()->first == used.begin()->first && free.rbegin()->second > used.begin()->second))
                {
                    auto t = *used.begin();
                    auto v = *free.rbegin();
                    used.erase(t);
                    used.insert(v);
                    free.erase(v);
                    free.insert(t);
                    res -= t.first * t.second;
                    res += v.first * v.second;
                }
            }
            ans[i] = res;          
            mp[nums[i]]--;
            cnt = mp[nums[i]] + 1;
            a = nums[i];
            if(used.find({cnt, a}) != used.end())
            {
                used.erase({cnt, a});
                used.insert({cnt - 1, a});
                res -= a;
                if(free.size() == 0) continue;
                while(free.rbegin()->first > used.begin()->first || (free.rbegin()->first == used.begin()->first && free.rbegin()->second > used.begin()->second))
                {
                    auto t = *used.begin();
                    auto v = *free.rbegin();
                    used.erase(t);
                    used.insert(v);
                    free.erase(v);
                    free.insert(t);
                    res -= t.first * t.second;
                    res += v.first * v.second;
                }
            }
            else
            {
                free.erase({cnt, a});
                free.insert({cnt - 1, a});
            }
        }
        return ans;
    }
};",1420591755
Dorjderem Namsraijav,dorjderemdorj202,321,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        map<int,int> mp;
        for(int i=0;i<k - 1;i++) mp[nums[i]]++;
        for(int i=0;i<n-k+1;i++)
        {
            mp[nums[i + k - 1]]++;
            priority_queue<pair<int,int>> pq;
            for(auto it : mp)
            {
                pq.push({it.second, it.first});
            }
            int res = 0;
            int cx = x;
            while(cx-- && pq.size())
            {
                res += pq.top().first * pq.top().second;
                pq.pop();
            }
            ans[i] = res;
            mp[nums[i]]--;
        }
        return ans;
    }
};",1420525000
juggernutx,juggernutx,322,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        self.get_perfect_subtree(root, res)
        if len(res) < k: 
            return -1
        else:
            res.sort(reverse=True)
            return res[k-1]
    
    def get_perfect_subtree(self, root:Optional[TreeNode], res:[])-> int:
        if root is None:
            return -1
        
        if root.left is None and root.right is None:
            res.append(1)
            return 1
        
        left_size = self.get_perfect_subtree(root.left, res)

        right_size = self.get_perfect_subtree(root.right, res)

        if left_size == -1 or right_size == -1 or left_size != right_size:
            return -1
        else:
            res.append(left_size*2 + 1)
            return left_size*2 + 1
",1420539194
juggernutx,juggernutx,322,3592,python3,"from sortedcontainers import SortedList, SortedSet
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        num2freq = collections.Counter(nums[:k])
        initial = []
        for key, val in num2freq.items():
            initial.append((val, key))
        initial.sort(key=lambda a:(a[0], a[1]))
        not_selected = []
        selected = []
        if len(initial) > x:
            not_selected = initial[:len(initial)-x]
            selected = initial[len(initial)-x:]
        else:
            selected = initial
        #print(selected)
        #print(not_selected)
        ss_selected = SortedSet(selected)
        ss_not_select = SortedSet(not_selected)
        total_sum = 0
        for freq, num in ss_selected:
            total_sum += freq * num
        res = [total_sum]
        print(ss_selected)
        for idx in range(k, len(nums)):
            num = nums[idx]
            del_num = nums[idx - k]
            if num == del_num:
                res.append(total_sum)
                continue

            prev_tuple = None
            if num in num2freq:
                prev_tuple = (num2freq[num], num)
            else:
                num2freq[num] = 0
            num2freq[num] += 1
            new_tuple = (num2freq[num], num)

            if prev_tuple:
                if prev_tuple in ss_selected:
                    ss_selected.discard(prev_tuple)
                    total_sum -= prev_tuple[0] * prev_tuple[1]
                elif prev_tuple in ss_not_select:
                    ss_not_select.discard(prev_tuple)
            
            if len(ss_selected) < x or new_tuple > ss_selected[0]:
                ss_selected.add(new_tuple)
                total_sum += new_tuple[0] * new_tuple[1]
            else:
                ss_not_select.add(new_tuple)

            # only if new tuple moved from ss_not_select to ss_selected
            if len(ss_selected) > x:
                to_move_tuple = ss_selected[0]
                ss_selected.discard(to_move_tuple)
                ss_not_select.add(to_move_tuple)
                total_sum -= to_move_tuple[0] * to_move_tuple[1]

            del_num = nums[idx - k]
            prev_tuple = (num2freq[del_num], del_num)
            print(prev_tuple)
            num2freq[del_num] -= 1
            if prev_tuple in ss_selected:
                ss_selected.discard(prev_tuple)
                total_sum -= prev_tuple[0] * prev_tuple[1]
            elif prev_tuple in ss_not_select:
                ss_not_select.discard(prev_tuple)
            new_tuple = (num2freq[del_num], del_num)

            if len(ss_selected) > 0 and new_tuple > ss_selected[0]:
                ss_selected.add(new_tuple)
                total_sum += new_tuple[0] * new_tuple[1]
            else:
                if new_tuple[0] > 0:
                    ss_not_select.add(new_tuple)
                while len(ss_selected) < x and len(ss_not_select) > 0:
                    to_move_tuple = ss_not_select[-1]
                    ss_not_select.discard(to_move_tuple)
                    ss_selected.add(to_move_tuple)
                    total_sum += to_move_tuple[0] * to_move_tuple[1]
            res.append(total_sum)
            #print(ss_selected)

        return res",1420601502
juggernutx,juggernutx,322,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        num2freq = collections.Counter(nums[:k])
        #print(num2freq)
        def get_top_sum(num2freq):
            top_sum = 0
            sorted_list = []
            for key, val in num2freq.items():
                sorted_list.append((val, key))
            sorted_list.sort(key=lambda a:(a[0], a[1]))
            n = len(sorted_list)
            for i in range(n-1, max(-1,n-x-1), -1):
                top_sum += sorted_list[i][0] * sorted_list[i][1]
            return top_sum
        res = []
        res.append(get_top_sum(num2freq))
        for i in range(k, len(nums)):
            if nums[i] not in num2freq:
                num2freq[nums[i]] = 0
            num2freq[nums[i]] += 1
            num2freq[nums[i-k]] -= 1
            res.append(get_top_sum(num2freq))
        return res

        
",1420530105
Shohruh,rshohruh,323,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    int dfs(TreeNode* root) {
        if(root == nullptr) return 0;
        // if(root->left == nullptr || root->right == nullptr) return -1;
        int l = dfs(root->left);
        int r = dfs(root->right);
        if(l == r) ans.push_back(l+r+1);
        return (l == r ? l+r+1 : -1);
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(ans.rbegin(), ans.rend());
        if(ans.size() < k) return -1;
        return ans[k-1];
    }
};",1420540954
Shohruh,rshohruh,323,3592,cpp,"class Solution {
struct median{
    set<pair<int, int>, greater<>> r;
    set<pair<int, int>> l;
    map<int, int> mp;
    long long ans = 0;
    int x;
    median(int x) : x(x) {}

    void equal() {
        if(l.size() > x){
            ans -= 1ll*l.begin()->first * l.begin()->second;
            r.insert(*l.begin());
            l.erase(l.begin());
        } else if(!r.empty() && l.size() < x) {
            ans += 1ll*r.begin()->first * r.begin()->second;
            l.insert(*r.begin());
            r.erase(r.begin());
        }
    }

    void push(int value, int cnt) {
        pair<int, int> x = {mp[value], value};
        mp[value] += cnt;
        if(l.count(x)) {
            ans -= 1ll*x.first * x.second;
            l.erase(x);
        } else {
            r.erase(x);
        }
        x.first += cnt;
        if(r.empty() || x > *r.begin()) {
            ans += 1ll*x.first * x.second;
            l.insert(x);
        } else {
            r.insert(x);
        }
        equal();
        // cout << ""l = \n""; for(auto [x, y]: l) cout << x << ' ' << y << endl;
        // cout << ""r = \n""; for(auto [x, y]: r) cout << x << ' ' << y << endl; cout << endl;
    }
};
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<long long> res;
        median md(x);
        int n = nums.size();
        for(int i = 0; i < n; ++i){
            if(i >= k) md.push(nums[i-k], -1);
            md.push(nums[i], 1);

            // if(i+1 >= k){for(auto [x, y]: md.l) cout << x << ' ' << y << endl; cout << endl;}

            if(i+1 >= k) res.push_back(md.ans);
        }
        return res;
    }
};",1420607757
Shohruh,rshohruh,323,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        for(int i = k; i <= n; ++i){
            map<int, int> mp;
            for(int j = i-k; j < i; ++j)
                mp[nums[j]] ++;
            
            vector a(51, vector(0, 0));
            for(auto [x, y]: mp) a[y].push_back(x);
            int t = x;
            ans.push_back(0);
            for(int i = 50; i > 0 && t; --i){
                while(!a[i].empty() && t){
                    ans.back() += a[i].back() * i;
                    a[i].pop_back();
                    --t;
                }
            }
        }
        return ans;
    }
};",1420524405
Dhairya,PhoenixDD,325,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> nodes;
    array<int,3> dfs(TreeNode* root) {
        if(!root)
            return {0,0,1};
        auto [lNodes,lDepth,lIsPerfect]=dfs(root->left);
        auto [rNodes,rDepth,rIsPerfect]=dfs(root->right);
        int ns=lNodes+rNodes+1,depth=1+max(lDepth,rDepth);
        if(lIsPerfect&&rIsPerfect&&ns==(1<<depth)-1) {
            nodes.push_back(ns);
            return {ns,depth,1};
        }
        return {-1,-1,0};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        if(nodes.size()<k)
            return -1;
        sort(nodes.rbegin(),nodes.rend());
        return nodes[k-1];
    }
};",1420538139
Dhairya,PhoenixDD,325,3592,cpp,"class Solution {
public:
    int x;
    unordered_map<int,int> freq;
    set<pair<int,int>,greater<pair<int,int>>> revFreq,revFreqRight;
    long long sum=0;
    void add(int num) {
        if(!freq.count(num)) {
            freq[num]++;
            revFreqRight.insert({1,num});
            revFreq.insert(*revFreqRight.begin());
            sum+=1LL*revFreqRight.begin()->second*revFreqRight.begin()->first;
            revFreqRight.erase(revFreqRight.begin());
            if(revFreq.size()>x) {
                sum-=1LL*(--revFreq.end())->first*(--revFreq.end())->second;
                revFreqRight.insert(*--revFreq.end());
                revFreq.erase(--revFreq.end());
            }
            return;
        }
        int prevFreq=freq[num];
        auto it=revFreq.find({prevFreq,num});
        if(it==revFreq.end()) {
            freq[num]++;
            auto rIt=revFreqRight.find({prevFreq,num});
            if(rIt!=revFreqRight.end())
                revFreqRight.erase(rIt);
            revFreqRight.insert({prevFreq+1,num});
            revFreq.insert(*revFreqRight.begin());
            sum+=1LL*revFreqRight.begin()->second*revFreqRight.begin()->first;
            revFreqRight.erase(revFreqRight.begin());
            if(revFreq.size()>x) {
                sum-=1LL*(--revFreq.end())->first*(--revFreq.end())->second;
                revFreqRight.insert(*--revFreq.end());
                revFreq.erase(--revFreq.end());
            }
        } else {
            revFreq.erase(it);
            freq[num]++;
            revFreq.insert({prevFreq+1,num});
            sum+=num;
        }
        
    }
    void remove(int num) {
        int prevFreq=freq[num];
        auto it=revFreq.find({prevFreq,num});
        if(it==revFreq.end()) {
            freq[num]--;
            revFreqRight.erase(revFreqRight.find({prevFreq,num}));
            if(prevFreq>1)
                revFreqRight.insert({prevFreq-1,num});
            return;
        }
        sum-=1LL*it->first*it->second;
        revFreq.erase(it);
        freq[num]--;
        if(prevFreq>1)
            revFreqRight.insert({prevFreq-1,num});
        if(!revFreqRight.empty()) {
            sum+=1LL*revFreqRight.begin()->first*revFreqRight.begin()->second;
            revFreq.insert(*revFreqRight.begin());
            revFreqRight.erase(revFreqRight.begin());
        }
    }
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        this->x=x;
        vector<long long> result;
        for(int i=0;i<nums.size();i++) {
            if(i>=k)
                remove(nums[i-k]);
            add(nums[i]);
            if(i>=k-1)
                result.push_back(sum);
            // cout<<i<<endl;
            // for(auto &[k,v]:freq)
            //     cout<<""{""<<k<<"" ""<<v<<""}, "";
            // cout<<endl;
            // for(auto &[k,v]:revFreq)
            //     cout<<""{""<<k<<"" ""<<v<<""}, "";
            // cout<<endl;
            // cout<<sum;
            // cout<<endl<<endl;
        }
        return result;
    }
};",1420608419
Dhairya,PhoenixDD,325,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<int,int> freq;
        vector<int> result;
        for(int i=0;i<nums.size();i++) {
            if(i>=k)
                freq[nums[i-k]]--;
            freq[nums[i]]++;
            if(i>=k-1) {
                vector<pair<int,int>> fs(freq.begin(),freq.end());
                int res=0;
                sort(fs.begin(),fs.end(),[](auto &l,auto &r){return l.second==r.second?l.first>r.first:l.second>r.second;});
                for(int j=0;j<min((int)fs.size(),x);j++)
                    res+=fs[j].first*fs[j].second;
                result.push_back(res);
            }
        }
        return result;
    }
};",1420523498
CHANDRAPRABHU,Chandraprabhu,327,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
vector<int> res;
    int go(TreeNode* head){
        if(head==NULL)return 0;
        int l = go(head->left);
        int r = go(head->right);
        if(l==r && l!=-1){
            // cout<<head->val<<' ';
            res.push_back(l+r+1);
            return l+r+1;
        }
        return -1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        go(root);
        sort(res.begin(),res.end());
        // for(int i: res){
        //     cout<<i<<' ';
        // }
        if(res.size()<k)return -1;
        return *(res.end()-k);
    }
};",1420534875
CHANDRAPRABHU,Chandraprabhu,327,3592,cpp,"#define ll long long

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<ll> ans;
        int n = nums.size();
        const int mx = 1e5+10;
        map<int,int>co;
        set<array<int,2>> l,r;
        ll r_sum = 0;
        for(int i = 0 ;i<n;i++){
            if(co[nums[i]]!=0){
                array<int,2> cur = {co[nums[i]], nums[i]};
                if(r.find(cur)!=r.end()){
                    r.erase(cur);
                    r_sum-=(ll)cur[0]*cur[1];
                }
                else{
                    l.erase(cur);
                }
            }
            else{
                
            }
            array<int,2> cur = {++co[nums[i]], nums[i]};
            r.insert(cur);
            r_sum+=(ll)cur[0]*cur[1];
            while(r.size() > x){
                auto it = r.begin();
                r_sum-=(ll)(*it)[0]*(*it)[1];
                l.insert(*it);
                r.erase(it);
            }
            while(l.size() && r.size()<x){
                auto it = --l.end();
                r_sum+=(ll)(*it)[0]*(*it)[1];
                r.insert(*it);
                l.erase(it);
            }
            if(l.size() && r.size()){
                while(1){
                    auto l_cur = *--l.end();
                    auto r_cur = *r.begin();
                    if(l_cur > r_cur){
                        l.erase(l_cur);
                        r.erase(r_cur);
                        l.insert(r_cur);
                        r.insert(l_cur);
                        
                        r_sum += (ll)l_cur[0]*l_cur[1] - (ll)r_cur[0]* r_cur[1];
                    }
                    else{
                        break;
                    }
                }
            }
            // cout<<i<<endl;
            // cout<<r_sum<<endl;
            // for(auto i: r){
            //     cout<<i[0]<<' '<<i[1]<<endl;
            // }
            if(i>=k-1){
                ans.push_back(r_sum);
                
                int to_rem = i-k+1;
                array<int,2> cur = {co[nums[to_rem]], nums[to_rem]};
                if(r.find(cur)!=r.end()){
                    r.erase(cur);
                    r_sum-=(ll)cur[0]*cur[1];
                }
                else{
                    l.erase(cur);
                }
                if(--co[nums[to_rem]]!=0){
                    cur = {co[nums[to_rem]], nums[to_rem]};
                    r.insert(cur);
                    r_sum+=(ll)cur[0]*cur[1];
                }

            }
        }
        return ans;
    }
};

",1420601963
CHANDRAPRABHU,Chandraprabhu,327,3610,cpp,"#define ll long long

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int n = nums.size();
        const int mx = 1e5+10;
        map<int,int>co;
        set<array<int,2>> l,r;
        ll r_sum = 0;
        for(int i = 0 ;i<n;i++){
            if(co[nums[i]]!=0){
                array<int,2> cur = {co[nums[i]], nums[i]};
                if(r.find(cur)!=r.end()){
                    r.erase(cur);
                    r_sum-=(ll)cur[0]*cur[1];
                }
                else{
                    l.erase(cur);
                }
            }
            else{
                
            }
            array<int,2> cur = {++co[nums[i]], nums[i]};
            r.insert(cur);
            r_sum+=(ll)cur[0]*cur[1];
            while(r.size() > x){
                auto it = r.begin();
                r_sum-=(ll)(*it)[0]*(*it)[1];
                l.insert(*it);
                r.erase(it);
            }
            while(l.size() && r.size()<x){
                auto it = --l.end();
                r_sum+=(ll)(*it)[0]*(*it)[1];
                r.insert(*it);
                l.erase(it);
            }
            if(l.size() && r.size()){
                while(1){
                    auto l_cur = *--l.end();
                    auto r_cur = *r.begin();
                    if(l_cur > r_cur){
                        l.erase(l_cur);
                        r.erase(r_cur);
                        l.insert(r_cur);
                        r.insert(l_cur);
                        
                        r_sum += (ll)l_cur[0]*l_cur[1] - (ll)r_cur[0]* r_cur[1];
                    }
                    else{
                        break;
                    }
                }
            }
            // cout<<i<<endl;
            // cout<<r_sum<<endl;
            // for(auto i: r){
            //     cout<<i[0]<<' '<<i[1]<<endl;
            // }
            if(i>=k-1){
                ans.push_back(r_sum);
                
                int to_rem = i-k+1;
                array<int,2> cur = {co[nums[to_rem]], nums[to_rem]};
                if(r.find(cur)!=r.end()){
                    r.erase(cur);
                    r_sum-=(ll)cur[0]*cur[1];
                }
                else{
                    l.erase(cur);
                }
                if(--co[nums[to_rem]]!=0){
                    cur = {co[nums[to_rem]], nums[to_rem]};
                    r.insert(cur);
                    r_sum+=(ll)cur[0]*cur[1];
                }

            }
        }
        return ans;
    }
};

",1420603401
Zoro,shaswatgusain1,328,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<int, int> checkPerfect(TreeNode* node, vector<int>& sizes) {
        if (!node) return {0, true};
        
        auto left = checkPerfect(node->left, sizes);
        auto right = checkPerfect(node->right, sizes);
        
        if (left.second && right.second && left.first == right.first) {
            int size = (1 << (left.first + 1)) - 1;
            sizes.push_back(size);
            return {left.first + 1, true};
        }
        
        return {max(left.first, right.first), false};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        checkPerfect(root, sizes);
        sort(sizes.rbegin(), sizes.rend());
        return sizes.size() >= k ? sizes[k - 1] : -1;
    }
};",1420522923
Zoro,shaswatgusain1,328,3592,python3,"from sortedcontainers import SortedList
from collections import defaultdict
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        freq = defaultdict(int)
        windowSum = 0
        xSum = 0

        topX = SortedList()
        remaining = SortedList()

        def adjustTopX():
            nonlocal xSum
            while len(topX) > x:
                it = topX[0] 
                remaining.add(it)
                xSum -= it[0] * it[1]
                topX.pop(0)
            while len(topX) < x and len(remaining) > 0:
                it = remaining[-1]
                topX.add(it)
                xSum += it[0] * it[1]
                remaining.pop(-1)

        def add(num):
            nonlocal windowSum, xSum
            if freq[num] > 0:
             
                if (freq[num], num) in topX:
                    topX.remove((freq[num], num))
                    xSum -= freq[num] * num
                else:
                    remaining.remove((freq[num], num))
            freq[num] += 1
            windowSum += num

            topX.add((freq[num], num))
            xSum += freq[num] * num
            adjustTopX()  

        def remove(num):
            nonlocal windowSum, xSum
            if (freq[num], num) in topX:
                topX.remove((freq[num], num))
                xSum -= freq[num] * num
            else:
                remaining.remove((freq[num], num))

            freq[num] -= 1
            windowSum -= num
            if freq[num] > 0:
                remaining.add((freq[num], num))
            adjustTopX()  

        for i in range(k):
            add(nums[i])
        answer.append(xSum)

        for i in range(k, n):
            remove(nums[i - k])
            add(nums[i])
            answer.append(xSum)

        return answer
",1420614959
Zoro,shaswatgusain1,328,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> result;
        unordered_map<int, int> freq_map;

        for (int i = 0; i < k; ++i) {
            freq_map[nums[i]]++;
        }

        auto calculate_x_sum = [&](unordered_map<int, int>& freq_map) {
            vector<pair<int, int>> freq_list;
            for (auto& entry : freq_map) {
                freq_list.push_back({entry.second, entry.first});
            }

            sort(freq_list.begin(), freq_list.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.first == b.first) return a.second > b.second;
                return a.first > b.first;
            });

            int sum = 0;
            int count = 0;
            for (auto& p : freq_list) {
                if (count >= x) break;
                sum += p.first * p.second;
                count++;
            }
            return sum;
        };

        result.push_back(calculate_x_sum(freq_map));

        for (int i = k; i < n; ++i) {
            freq_map[nums[i - k]]--;
            if (freq_map[nums[i - k]] == 0) {
                freq_map.erase(nums[i - k]);
            }

            freq_map[nums[i]]++;
            result.push_back(calculate_x_sum(freq_map));
        }

        return result;
    }
};
",1420520370
pulkit20,pulkit20,329,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    pair<bool, pair<int, int>> isPerfect(TreeNode* root) {
        if (!root) {
            return {true, {0, 0}};
        }

        auto left = isPerfect(root->left);
        auto right = isPerfect(root->right);

        bool leftPerfect = left.first;
        bool rightPerfect = right.first;
        int leftHeight = left.second.first;
        int rightHeight = right.second.first;
        int leftSize = left.second.second;
        int rightSize = right.second.second;

        if (leftPerfect && rightPerfect && leftHeight == rightHeight) {
            int height = leftHeight + 1;
            int size = leftSize + rightSize + 1;
            return {true, {height, size}};
        } else {
            return {false, {0, 0}};
        }
    }
    
    void collectPerfectSizes(TreeNode* root, vector<int>& sizes) {
        if (!root) return;
        auto current = isPerfect(root);
        bool isCurrentPerfect = current.first;
        int size = current.second.second;
        if (isCurrentPerfect) {
            sizes.push_back(size);
        }
        collectPerfectSizes(root->left, sizes);
        collectPerfectSizes(root->right, sizes);
    }

    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        collectPerfectSizes(root, sizes);
        sort(sizes.rbegin(), sizes.rend());
        if (sizes.size() < k) {
            return -1;
        }
        return sizes[k - 1];
    }
};",1420524081
pulkit20,pulkit20,329,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> answer;
        set<pair<long long, long long>> inx, outx;
        map<long long, long long> mp;
        for(int j = 0; j < k ; j++){
            mp[nums[j]]++;
        }
        vector<pair<long long, long long>> see;
        for(auto &x : mp){
            see.push_back({x.second, x.first});
        }
        sort(see.rbegin(), see.rend());
        long long cur = 0;
        for(int j = 0; j < (int)see.size(); j++){
            if(j < x){
                cur += see[j].first*see[j].second;
                inx.insert(see[j]);
            }
            else outx.insert(see[j]);
        }
        answer.push_back(cur);
        for(int i = k; i < n; i++){
            if(nums[i] == nums[i-k]){
                answer.push_back(cur);
                continue;
            }
            vector<pair<long long, long long>> chk;
            if(inx.count({mp[nums[i]], nums[i]})){
                inx.erase({mp[nums[i]], nums[i]});
                cur -= mp[nums[i]]*nums[i];
            }
            if(outx.count({mp[nums[i]], nums[i]})){
                outx.erase({mp[nums[i]], nums[i]});
            }
            if(inx.count({mp[nums[i - k]], nums[i - k]})){
                inx.erase({mp[nums[i - k]], nums[i - k]});
                cur -= mp[nums[i - k]]*nums[i - k];
            }
            if(outx.count({mp[nums[i - k]], nums[i - k]})){
                outx.erase({mp[nums[i - k]], nums[i - k]});
            }
            if(mp[nums[i-k]] > 1){
                mp[nums[i-k]]--;
                chk.push_back({mp[nums[i-k]], nums[i-k]});
            }
            else{
                mp.erase(nums[i-k]);
            }
            mp[nums[i]]++;
            chk.push_back({mp[nums[i]], nums[i]});
            if(inx.size()){
                chk.push_back(*inx.begin());
                cur -= chk.back().first*chk.back().second;
                inx.erase(inx.begin());
            }
            if(outx.size()){
                chk.push_back(*(--outx.end()));
                outx.erase(*(--outx.end()));
            }
            sort(chk.rbegin(), chk.rend());
            for(int j = 0; j < chk.size(); j++){
                if(inx.size() < x){
                    inx.insert(chk[j]);
                    cur += chk[j].first*chk[j].second;
                }
                else{
                    outx.insert(chk[j]);
                }
            }
            answer.push_back(cur);
        }
        return answer;
    }
};",1420609616
pulkit20,pulkit20,329,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        for(int i = 0; i < n; i++){
            if(i+k > n) break;
            map<int, int> mp;
            for(int j = i; j < i + k ; j++){
                mp[nums[j]]++;
            }
            vector<pair<int, int>> see;
            for(auto &x : mp){
                see.push_back({x.second, x.first});
            }
            sort(see.rbegin(), see.rend());
            int cur = 0;
            for(int j = 0; j < min((int)see.size(), x); j++){
                cur += see[j].first*see[j].second;
            }
            answer.push_back(cur);
        }
        return answer;
    }
};",1420539026
Ankan Mahapatra,ankan2526,330,3509,python,"# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def kthLargestPerfectSubtree(self, root, k):
        """"""
        :type root: Optional[TreeNode]
        :type k: int
        :rtype: int
        """"""
        good = []
        def dfs(node):
            if node.left == node.right == None:
                good.append(1)
                return 1
            flag = True
            if (node.left == None) or (node.right == None):
                flag = False
            ans = []
            if node.left:
                v = dfs(node.left)
                if v != -1:
                    ans.append(v)
                else:
                    flag = False
            if node.right:
                v = dfs(node.right)
                if v != -1:
                    ans.append(v)
                else:
                    flag = False
            if flag == False:
                return -1
            if len(set(ans)) == 1:
                good.append(2 * ans[0] + 1)
                return 2 * ans[0] + 1
            else:
                return -1
        dfs(root)
        good = sorted(good)[::-1]
        if len(good) < k:
            return -1
        return good[k-1]",1420551987
Ankan Mahapatra,ankan2526,330,3592,python,"class SortedList:
    def __init__(self, iterable=[], _load=200):
        """"""Initialize sorted list instance.""""""
        values = sorted(iterable)
        self._len = _len = len(values)
        self._load = _load
        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]
        self._list_lens = [len(_list) for _list in _lists]
        self._mins = [_list[0] for _list in _lists]
        self._fen_tree = []
        self._rebuild = True
 
    def _fen_build(self):
        """"""Build a fenwick tree instance.""""""
        self._fen_tree[:] = self._list_lens
        _fen_tree = self._fen_tree
        for i in range(len(_fen_tree)):
            if i | i + 1 < len(_fen_tree):
                _fen_tree[i | i + 1] += _fen_tree[i]
        self._rebuild = False
 
    def _fen_update(self, index, value):
        """"""Update `fen_tree[index] += value`.""""""
        if not self._rebuild:
            _fen_tree = self._fen_tree
            while index < len(_fen_tree):
                _fen_tree[index] += value
                index |= index + 1
 
    def _fen_query(self, end):
        """"""Return `sum(_fen_tree[:end])`.""""""
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        x = 0
        while end:
            x += _fen_tree[end - 1]
            end &= end - 1
        return x
 
    def _fen_findkth(self, k):
        """"""Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).""""""
        _list_lens = self._list_lens
        if k < _list_lens[0]:
            return 0, k
        if k >= self._len - _list_lens[-1]:
            return len(_list_lens) - 1, k + _list_lens[-1] - self._len
        if self._rebuild:
            self._fen_build()
 
        _fen_tree = self._fen_tree
        idx = -1
        for d in reversed(range(len(_fen_tree).bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:
                idx = right_idx
                k -= _fen_tree[idx]
        return idx + 1, k
 
    def _delete(self, pos, idx):
        """"""Delete value at the given `(pos, idx)`.""""""
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len -= 1
        self._fen_update(pos, -1)
        del _lists[pos][idx]
        _list_lens[pos] -= 1
 
        if _list_lens[pos]:
            _mins[pos] = _lists[pos][0]
        else:
            del _lists[pos]
            del _list_lens[pos]
            del _mins[pos]
            self._rebuild = True
 
    def _loc_left(self, value):
        """"""Return an index pair that corresponds to the first position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        lo, pos = -1, len(_lists) - 1
        while lo + 1 < pos:
            mi = (lo + pos) >> 1
            if value <= _mins[mi]:
                pos = mi
            else:
                lo = mi
 
        if pos and value <= _lists[pos - 1][-1]:
            pos -= 1
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value <= _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def _loc_right(self, value):
        """"""Return an index pair that corresponds to the last position of `value` in the sorted list.""""""
        if not self._len:
            return 0, 0
 
        _lists = self._lists
        _mins = self._mins
 
        pos, hi = 0, len(_lists)
        while pos + 1 < hi:
            mi = (pos + hi) >> 1
            if value < _mins[mi]:
                hi = mi
            else:
                pos = mi
 
        _list = _lists[pos]
        lo, idx = -1, len(_list)
        while lo + 1 < idx:
            mi = (lo + idx) >> 1
            if value < _list[mi]:
                idx = mi
            else:
                lo = mi
 
        return pos, idx
 
    def add(self, value):
        """"""Add `value` to sorted list.""""""
        _load = self._load
        _lists = self._lists
        _mins = self._mins
        _list_lens = self._list_lens
 
        self._len += 1
        if _lists:
            pos, idx = self._loc_right(value)
            self._fen_update(pos, 1)
            _list = _lists[pos]
            _list.insert(idx, value)
            _list_lens[pos] += 1
            _mins[pos] = _list[0]
            if _load + _load < len(_list):
                _lists.insert(pos + 1, _list[_load:])
                _list_lens.insert(pos + 1, len(_list) - _load)
                _mins.insert(pos + 1, _list[_load])
                _list_lens[pos] = _load
                del _list[_load:]
                self._rebuild = True
        else:
            _lists.append([value])
            _mins.append(value)
            _list_lens.append(1)
            self._rebuild = True
 
    def discard(self, value):
        """"""Remove `value` from sorted list if it is a member.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_right(value)
            if idx and _lists[pos][idx - 1] == value:
                self._delete(pos, idx - 1)
 
    def remove(self, value):
        """"""Remove `value` from sorted list; `value` must be a member.""""""
        _len = self._len
        self.discard(value)
        if _len == self._len:
            raise ValueError('{0!r} not in list'.format(value))
 
    def pop(self, index=-1):
        """"""Remove and return value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        value = self._lists[pos][idx]
        self._delete(pos, idx)
        return value
 
    def bisect_left(self, value):
        """"""Return the first index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_left(value)
        return self._fen_query(pos) + idx
 
    def bisect_right(self, value):
        """"""Return the last index to insert `value` in the sorted list.""""""
        pos, idx = self._loc_right(value)
        return self._fen_query(pos) + idx
 
    def count(self, value):
        """"""Return number of occurrences of `value` in the sorted list.""""""
        return self.bisect_right(value) - self.bisect_left(value)
 
    def __len__(self):
        """"""Return the size of the sorted list.""""""
        return self._len
 
    def __getitem__(self, index):
        """"""Lookup value at `index` in sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        return self._lists[pos][idx]
 
    def __delitem__(self, index):
        """"""Remove value at `index` from sorted list.""""""
        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)
        self._delete(pos, idx)
 
    def __contains__(self, value):
        """"""Return true if `value` is an element of the sorted list.""""""
        _lists = self._lists
        if _lists:
            pos, idx = self._loc_left(value)
            return idx < len(_lists[pos]) and _lists[pos][idx] == value
        return False
 
    def __iter__(self):
        """"""Return an iterator over the sorted list.""""""
        return (value for _list in self._lists for value in _list)
 
    def __reversed__(self):
        """"""Return a reverse iterator over the sorted list.""""""
        return (value for _list in reversed(self._lists) for value in reversed(_list))
 
    def __repr__(self):
        """"""Return string representation of sorted list.""""""
        return 'SortedList({0})'.format(list(self))

class OrderedList(SortedList): #Ordered Multiset
    def __init__(self, arg):
        super().__init__(arg)
    def rangeCountByValue(self, leftVal, rightVal): #returns number of items in range [leftVal,rightVal] inclusive
        leftCummulative = self.bisect_left(leftVal)
        rightCummulative = self.bisect_left(rightVal + 1)
        return rightCummulative - leftCummulative

class Solution(object):
    def findXSum(self, nums, k, X):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        n = len(nums)
        st = SortedList()
        store = {}
        for i in nums[:k]:
            if i not in store:
                store[i] = 0
            store[i] += 1
        for i in store:
            st.add([-store[i], -i])
        ans = 0
        L = len(store)
        for i in range(X):
            if i >= L:
                break
            x, y = st[i]
            ans += x * y
        ANS = []
        ANS.append(ans)

        for i in range(k, n):
            ## Removing (i-k)th element
            key = [-store[nums[i-k]], -nums[i-k]]
            ind = st.bisect_left(key)
            if ind < X:
                ans -= key[0] * key[1]
                if L > X:
                    x, y = st[X]
                    ans += x * y
                    kth_elem = (x, y)
            st.remove(key)
            L -= 1
            store[nums[i-k]] -= 1
            if store[nums[i-k]] == 0:
                store.pop(nums[i-k])
            else:
                key[0] += 1
                st.add(key)
                L += 1
                ind = st.bisect_left(key)
                if ind < X:
                    ans += key[0] * key[1]
                    if L > X:
                        x, y = st[X]
                        ans -= x * y

            ## Adding ith element
            if nums[i] not in store:
                store[nums[i]] = 1
                key = [-1, -nums[i]]
            else:
                key = [-store[nums[i]], -nums[i]]
                ind = st.bisect_left(key)
                if ind < X:
                    ans -= key[0] * key[1]
                    if L > X:
                        x, y = st[X]
                        ans += x * y
                st.remove(key)
                L -= 1
                store[nums[i]] += 1
                key[0] -= 1
            
            st.add(key)
            L += 1
            ind = st.bisect_left(key)
            if ind < X:
                ans += key[0] * key[1]
                if L > X:
                    x, y = st[X]
                    ans -= x * y
            ANS.append(ans)
        return ANS
",1420609686
Ankan Mahapatra,ankan2526,330,3610,python,"class Solution(object):
    def findXSum(self, nums, k, X):
        """"""
        :type nums: List[int]
        :type k: int
        :type x: int
        :rtype: List[int]
        """"""
        ans = []
        n = len(nums)
        for i in range(n-k+1):
            a = nums[i: i+k]
            store = {}
            for j in a:
                if j not in store:
                    store[j] = 0
                store[j] += 1
            b = [[-store[j], -j] for j in store]
            b.sort()
            count = 1
            v = 0
            for x, y in b:
                v += y * x
                if count == X:
                    break
                count += 1
            ans.append(v)
        return ans",1420525715
prem_sp,prem_sp,331,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sz;

        function<int(TreeNode*)> dfs = [&](TreeNode* rt) {
            if(rt==NULL) return 0;
            int lft = dfs(rt->left);
            int rgt = dfs(rt->right);
            if(lft == -1 || lft != rgt) return -1;
            sz.push_back(lft*2+1);
            return lft*2+1;
        };
        dfs(root);
        sort(sz.begin(), sz.end(), greater<int>());
        return sz.size()>=k?sz[k-1]:-1;
        
    }
};",1420610385
prem_sp,prem_sp,331,3592,cpp,"#include <variant>
#include <utility> // For std::pair
#include <functional> // For std::greater

#define ll long long
using SetVariant = variant<set<pair<ll, ll>>, set<pair<ll, ll>, greater<pair<ll, ll>>>>;

class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        vector<set<pair<ll,ll>>> st(2);
        // set<pair<ll,ll>> st[2];
        // auto it = st;
        // it = new set<pair<ll,ll>>();
        // it++ ;
        // it = new set<pair<ll,ll>, greater<pair<ll,ll>>>();
        
        // st.push_back(new set<pair<ll,ll>>());
        // st.push_back(new set<pair<ll,ll>, greater<pair<ll,ll>>>());
        map<ll, ll> mp, where;
        int n=nums.size();
        vector<ll> ans(n-k+1);
        ll sum = 0;

        for(int i=0; i<n; ++i) {
            //cout<<where[nums[i]]<<' ';
            if(mp.find(nums[i])!=mp.end() && mp[nums[i]]>0) {
                st[where[nums[i]]].erase({mp[nums[i]], nums[i]});
                if(where[nums[i]]==0) sum -= mp[nums[i]]*nums[i];
                mp[nums[i]]++;
            }else {
                // cout<<'h';
                mp[nums[i]] = 1;
            }
            
            st[1].insert({mp[nums[i]], nums[i]});
            where[nums[i]] = 1;
            auto it = st[1].end();
            it-- ;
            
            if(st[0].size()<x || st[0].begin()->first < it->first || (st[0].begin()->first==it->first && st[0].begin()->second<it->second)) {
                sum += it->first*it->second;
                st[0].insert(*it);
                where[it->second] = 0;
                st[1].erase(it);
                if(st[0].size()>x){
                    it = st[0].begin();
                    sum -= it->first*it->second;
                    st[1].insert(*it);
                    where[it->second] = 1;
                    st[0].erase(it);
                }
            }
            if(i>=k) {
                st[where[nums[i-k]]].erase({mp[nums[i-k]], nums[i-k]});
                if(where[nums[i-k]]==0) {
                    sum -= mp[nums[i-k]]*nums[i-k];
                    mp[nums[i-k]]--;
                    if(mp[nums[i-k]]>0) {
                        st[1].insert({mp[nums[i-k]], nums[i-k]});
                        where[nums[i-k]] = 1;
                    }
                    if(st[1].size()) {
                        auto it = st[1].end();
                        it--;
                        st[0].insert(*it);
                        sum += it->first*it->second;
                        where[it->second] = 0;
                        st[1].erase(*it);
                    }
                }else{
                    mp[nums[i-k]]--;
                    if(mp[nums[i-k]]>0)st[1].insert({mp[nums[i-k]], nums[i-k]});
                }

            }
            // cout<<sum<<' ';
            if(i>=k-1) ans[i-k+1] = sum;            
        }

        return ans;

        
    }
};",1420602983
prem_sp,prem_sp,331,3610,cpp,"#include <variant>
#include <utility> // For std::pair
#include <functional> // For std::greater

#define ll long long
using SetVariant = variant<set<pair<ll, ll>>, set<pair<ll, ll>, greater<pair<ll, ll>>>>;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<set<pair<ll,ll>>> st(2);
        // set<pair<ll,ll>> st[2];
        // auto it = st;
        // it = new set<pair<ll,ll>>();
        // it++ ;
        // it = new set<pair<ll,ll>, greater<pair<ll,ll>>>();
        
        // st.push_back(new set<pair<ll,ll>>());
        // st.push_back(new set<pair<ll,ll>, greater<pair<ll,ll>>>());
        map<ll, ll> mp, where;
        int n=nums.size();
        vector<int> ans(n-k+1);
        ll sum = 0;

        for(int i=0; i<n; ++i) {
            //cout<<where[nums[i]]<<' ';
            if(mp.find(nums[i])!=mp.end() && mp[nums[i]]>0) {
                st[where[nums[i]]].erase({mp[nums[i]], nums[i]});
                if(where[nums[i]]==0) sum -= mp[nums[i]]*nums[i];
                mp[nums[i]]++;
            }else {
                // cout<<'h';
                mp[nums[i]] = 1;
            }
            
            st[1].insert({mp[nums[i]], nums[i]});
            where[nums[i]] = 1;
            auto it = st[1].end();
            it-- ;
            
            if(st[0].size()<x || st[0].begin()->first < it->first || (st[0].begin()->first==it->first && st[0].begin()->second<it->second)) {
                sum += it->first*it->second;
                st[0].insert(*it);
                where[it->second] = 0;
                st[1].erase(it);
                if(st[0].size()>x){
                    it = st[0].begin();
                    sum -= it->first*it->second;
                    st[1].insert(*it);
                    where[it->second] = 1;
                    st[0].erase(it);
                }
            }
            if(i>=k) {
                st[where[nums[i-k]]].erase({mp[nums[i-k]], nums[i-k]});
                if(where[nums[i-k]]==0) {
                    sum -= mp[nums[i-k]]*nums[i-k];
                    mp[nums[i-k]]--;
                    if(mp[nums[i-k]]>0) {
                        st[1].insert({mp[nums[i-k]], nums[i-k]});
                        where[nums[i-k]] = 1;
                    }
                    if(st[1].size()) {
                        auto it = st[1].end();
                        it--;
                        st[0].insert(*it);
                        sum += it->first*it->second;
                        where[it->second] = 0;
                        st[1].erase(*it);
                    }
                }else{
                    mp[nums[i-k]]--;
                    if(mp[nums[i-k]]>0)st[1].insert({mp[nums[i-k]], nums[i-k]});
                }

            }
            // cout<<sum<<' ';
            if(i>=k-1) ans[i-k+1] = sum;            
        }

        return ans;

        
    }
};",1420604360
Sean,shaun001280,332,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    vector<int> ans;

    pair<int, int> dfs(TreeNode* root) {
        if (root == nullptr) return {0, 0};
        auto p2 = dfs(root->right);
        auto p1 = dfs(root->left);
        int depth = max(p1.first, p2.first) + 1;
        int sz = p1.second + p2.second + 1;
        if (__builtin_popcount(sz + 1) == 1 && log2(sz + 1) == depth) {
            ans.push_back(sz);
        }
        return {depth, sz};
    }

public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(ans.begin(), ans.end(), greater<int>());
        return k > ans.size() ? -1 : ans[k - 1];
    }
};",1420616758
Sean,shaun001280,332,3592,cpp,"class Solution {
  private:
    vector<int> nums;
    multiset<pair<int, int>> sTopX, sRest;
    map<int, int> cnt;
    vector<long long> ans;
    int k, x;
    long long sum;

    void inc(int val) {
        if (!sTopX.count({cnt[val], val})) {
            if (sTopX.size() >= x) {
                auto it = sTopX.begin();
                if (*it < make_pair(cnt[val] + 1, val)) {
                    auto [f, v] = *it;
                    sTopX.erase(it);
                    sRest.erase({cnt[val], val});
                    sum -= 1LL * f * v;

                    sTopX.insert({cnt[val] + 1, val});
                    sum += 1LL * (cnt[val] + 1) * val;

                    sRest.insert({f, v});
                } else {
                    sRest.erase({cnt[val], val});
                    sRest.insert({cnt[val] + 1, val});
                }
            } else {
                sTopX.insert({cnt[val] + 1, val});
                sum += 1LL * (cnt[val] + 1) * val;
            }
        } else {
            auto it = sTopX.find({cnt[val], val});
            sTopX.erase(it);
            sum -= 1LL * cnt[val] * val;

            sTopX.insert({cnt[val] + 1, val});
            sum += 1LL * (cnt[val] + 1) * val;
        }
        ++cnt[val];
    }

    void dec(int val) {
        if (sTopX.count({cnt[val], val})) {
            if (sRest.size() == 0) {
                sTopX.erase({cnt[val], val});
                sum -= 1LL * cnt[val] * val;
                if (cnt[val] - 1 > 0) {
                    sTopX.insert({cnt[val] - 1, val});
                }
                sum += 1LL * (cnt[val] - 1) * val;
            } else {
                auto it = prev(sRest.end());
                if (*it > make_pair(cnt[val] - 1, val)) {
                    auto [f, v] = *it;
                    sRest.erase(it);
                    sTopX.erase({cnt[val], val});
                    sum += 1LL * f * v;
                    sum -= 1LL * cnt[val] * val;

                    if (cnt[val] - 1 > 0) {
                        sRest.insert({cnt[val] - 1, val});
                    }
                    sTopX.insert({f, v});
                } else {
                    sTopX.erase({cnt[val], val});
                    sum -= 1LL * cnt[val] * val;
                    if (cnt[val] - 1 > 0) {
                        sTopX.insert({cnt[val] - 1, val});
                    }
                    sum += 1LL * (cnt[val] - 1) * val;
                }
            }
        } else {
            sRest.erase({cnt[val], val});
            if (cnt[val] - 1 > 0) {
                sRest.insert({cnt[val] - 1, val});
            }
        }
        --cnt[val];
    }

  public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        this->nums = nums, this->k = k, this->x = x;

        for (int i = 0; i < k; ++i)
            inc(nums[i]);

        ans.push_back(sum);

        for (int i = k; i < n; ++i) {
            inc(nums[i]);
            dec(nums[i - k]);
            ans.push_back(sum);
        }

        return ans;
    }
};",1420609491
Sean,shaun001280,332,3610,cpp,"class Solution {
  private:
    vector<int> nums;
    multiset<pair<int, int>> sTopX, sRest;
    map<int, int> cnt;
    vector<int> ans;
    int k, x;
    long long sum;

    void inc(int val) {
        if (!sTopX.count({cnt[val], val})) {
            if (sTopX.size() >= x) {
                auto it = sTopX.begin();
                if (*it < make_pair(cnt[val] + 1, val)) {
                    auto [f, v] = *it;
                    sTopX.erase(it);
                    sRest.erase({cnt[val], val});
                    sum -= 1LL * f * v;

                    sTopX.insert({cnt[val] + 1, val});
                    sum += 1LL * (cnt[val] + 1) * val;

                    sRest.insert({f, v});
                } else {
                    sRest.erase({cnt[val], val});
                    sRest.insert({cnt[val] + 1, val});
                }
            } else {
                sTopX.insert({cnt[val] + 1, val});
                sum += 1LL * (cnt[val] + 1) * val;
            }
        } else {
            auto it = sTopX.find({cnt[val], val});
            sTopX.erase(it);
            sum -= 1LL * cnt[val] * val;

            sTopX.insert({cnt[val] + 1, val});
            sum += 1LL * (cnt[val] + 1) * val;
        }
        ++cnt[val];
    }

    void dec(int val) {
        if (sTopX.count({cnt[val], val})) {
            if (sRest.size() == 0) {
                sTopX.erase({cnt[val], val});
                sum -= 1LL * cnt[val] * val;
                if (cnt[val] - 1 > 0) {
                    sTopX.insert({cnt[val] - 1, val});
                }
                sum += 1LL * (cnt[val] - 1) * val;
            } else {
                auto it = prev(sRest.end());
                if (*it > make_pair(cnt[val] - 1, val)) {
                    auto [f, v] = *it;
                    sRest.erase(it);
                    sTopX.erase({cnt[val], val});
                    sum += 1LL * f * v;
                    sum -= 1LL * cnt[val] * val;

                    if (cnt[val] - 1 > 0) {
                        sRest.insert({cnt[val] - 1, val});
                    }
                    sTopX.insert({f, v});
                } else {
                    sTopX.erase({cnt[val], val});
                    sum -= 1LL * cnt[val] * val;
                    if (cnt[val] - 1 > 0) {
                        sTopX.insert({cnt[val] - 1, val});
                    }
                    sum += 1LL * (cnt[val] - 1) * val;
                }
            }
        } else {
            sRest.erase({cnt[val], val});
            if (cnt[val] - 1 > 0) {
                sRest.insert({cnt[val] - 1, val});
            }
        }
        --cnt[val];
    }

  public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        this->nums = nums, this->k = k, this->x = x;

        for (int i = 0; i < k; ++i)
            inc(nums[i]);

        ans.push_back(sum);

        for (int i = k; i < n; ++i) {
            inc(nums[i]);
            dec(nums[i - k]);
            ans.push_back(sum);
        }

        return ans;
    }
};",1420610160
Oone,Oone,333,3509,java,"import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {2,2,3,3,4,2};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0, 1}, {1, 3}, {2, 3}, {2, 4}};
        String[] grid = {""abc"", ""aaaaa"", ""bcdef""};
        Solution solution = new Solution();
    }
}


class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    List<Integer>node=new ArrayList<>();
    int[] DFS(TreeNode x) {
        boolean flag = (x.left != null && x.right != null) || (x.left == null && x.right == null);
        int[] ans = {0, 1, 0};
        if (x.left != null) {
            int[] tmp = DFS(x.left);
            if (tmp[0] == 0)
                flag = false;
            ans[1] += tmp[1];
            ans[2] = tmp[2];
        }
        if (x.right != null) {
            int[] tmp = DFS(x.right);
            if (tmp[0] == 0)
                flag = false;
            ans[1] += tmp[1];
            if(ans[2]!=tmp[2])
                flag=false;
        }
        if (flag) {
            ans[0] = 1;
            node.add(ans[1]);
        }
        ans[2]++;
        return ans;
    }
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        DFS(root);
        node.sort(Collections.reverseOrder());
        if(k>node.size())return -1;
        return node.get(k-1);
    }
}",1420612786
Oone,Oone,333,3592,java,"import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {2,2,3,3,4,2};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0, 1}, {1, 3}, {2, 3}, {2, 4}};
        String[] grid = {""abc"", ""aaaaa"", ""bcdef""};
        Solution solution = new Solution();
        solution.findXSum(nums1, 3, 3);
    }
}

class Solution {
    class Node implements Comparable<Node> {
        int x, cnt;

        public Node(int x, int cnt) {
            this.x = x;
            this.cnt = cnt;
        }

        public int compareTo(Node o) {
            return cnt == o.cnt ? o.x - x : o.cnt - cnt;
        }
    }

    public long[] findXSum(int[] nums, int k, int x) {
        HashMap<Integer, Integer> map = new HashMap<>();
        TreeSet<Node> in = new TreeSet<>();
        TreeSet<Node> out = new TreeSet<>();
        int n = nums.length;
        long[] ans = new long[n - k + 1];
        for (int i = 0; i < k; i++)
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        List<Node> list = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : map.entrySet())
            list.add(new Node(entry.getKey(), entry.getValue()));
        Collections.sort(list);
        long sum = 0;
        for (int i = 0; i < Math.min(x, list.size()); ++i) {
            sum += (long) list.get(i).x * list.get(i).cnt;
            in.add(list.get(i));
        }
        for (int i = x; i < list.size(); ++i)
            out.add(list.get(i));
        ans[0] = sum;
        for (int i = 1; i < n - k + 1; ++i) {
            Node tmp = new Node(nums[i - 1], map.get(nums[i - 1]));
            if (in.contains(tmp)) {
                in.remove(tmp);
                tmp.cnt--;
                in.add(tmp);
                sum -= tmp.x;
            } else {
                out.remove(tmp);
                tmp.cnt--;
                out.add(tmp);
            }
            map.put(nums[i - 1], map.get(nums[i - 1]) - 1);
            tmp = new Node(nums[i + k - 1], map.getOrDefault(nums[i + k - 1], 0));
            if (in.contains(tmp)) {
                in.remove(tmp);
                tmp.cnt++;
                in.add(tmp);
                sum += tmp.x;
            } else if (out.contains(tmp)) {
                out.remove(tmp);
                tmp.cnt++;
                out.add(tmp);
            } else {
                tmp.cnt++;
                out.add(tmp);
            }
            map.put(nums[i + k - 1], map.getOrDefault(nums[i + k - 1], 0) + 1);
            if (!out.isEmpty() && in.size() < x) {
                Node yy = out.first();
                in.add(yy);
                out.remove(yy);
                sum += (long) yy.x * yy.cnt;
            }
            if (!out.isEmpty() && in.last().compareTo(out.first()) > 0) {
                Node xx = in.last();
                Node yy = out.first();
                in.remove(xx);
                out.remove(yy);
                in.add(yy);
                out.add(xx);
                sum -= (long) xx.x * xx.cnt;
                sum += (long) yy.x * yy.cnt;
            }
            ans[i] = sum;
        }
        return ans;
    }
}",1420589246
Oone,Oone,333,3610,java,"import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {2,2,3,3,4,2};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0, 1}, {1, 3}, {2, 3}, {2, 4}};
        String[] grid = {""abc"", ""aaaaa"", ""bcdef""};
        Solution solution = new Solution();
        solution.findXSum(nums1, 3, 3);
    }
}

class Solution {
    class Node implements Comparable<Node> {
        int x, cnt;

        public Node(int x, int cnt) {
            this.x = x;
            this.cnt = cnt;
        }

        public int compareTo(Node o) {
            return cnt == o.cnt ? o.x - x : o.cnt - cnt;
        }
    }

    public int[] findXSum(int[] nums, int k, int x) {
        HashMap<Integer, Integer> map = new HashMap<>();
        TreeSet<Node> in = new TreeSet<>();
        TreeSet<Node> out = new TreeSet<>();
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        for (int i = 0; i < k; i++)
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        List<Node> list = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : map.entrySet())
            list.add(new Node(entry.getKey(), entry.getValue()));
        Collections.sort(list);
        int sum = 0;
        for (int i = 0; i < Math.min(x, list.size()); ++i) {
            sum +=  list.get(i).x * list.get(i).cnt;
            in.add(list.get(i));
        }
        for (int i = x; i < list.size(); ++i)
            out.add(list.get(i));
        ans[0] = sum;
        for (int i = 1; i < n - k + 1; ++i) {
            Node tmp = new Node(nums[i - 1], map.get(nums[i - 1]));
            if (in.contains(tmp)) {
                in.remove(tmp);
                tmp.cnt--;
                in.add(tmp);
                sum -= tmp.x;
            } else {
                out.remove(tmp);
                tmp.cnt--;
                out.add(tmp);
            }
            map.put(nums[i - 1], map.get(nums[i - 1]) - 1);
            tmp = new Node(nums[i + k - 1], map.getOrDefault(nums[i + k - 1], 0));
            if (in.contains(tmp)) {
                in.remove(tmp);
                tmp.cnt++;
                in.add(tmp);
                sum += tmp.x;
            } else if (out.contains(tmp)) {
                out.remove(tmp);
                tmp.cnt++;
                out.add(tmp);
            } else {
                tmp.cnt++;
                out.add(tmp);
            }
            map.put(nums[i + k - 1], map.getOrDefault(nums[i + k - 1], 0) + 1);
            if (!out.isEmpty() && in.size() < x) {
                Node yy = out.first();
                in.add(yy);
                out.remove(yy);
                sum +=  yy.x * yy.cnt;
            }
            if (!out.isEmpty() && in.last().compareTo(out.first()) > 0) {
                Node xx = in.last();
                Node yy = out.first();
                in.remove(xx);
                out.remove(yy);
                in.add(yy);
                out.add(xx);
                sum -=  xx.x * xx.cnt;
                sum += yy.x * yy.cnt;
            }
            ans[i] = sum;
        }
        return ans;
    }
}",1420592301
nimishsunny,nimishsunny,334,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
vector<int> ss;
int rec(TreeNode* root){
     int p1=-1,p2=-1;
     int c = 0;
     if(root->left){
          p1 = rec(root->left); c++;
     }
     if(root->right){
        p2 =rec(root->right); c++;
     }
     if(c==0){
        ss.push_back(1); return 1;
     } 
     if(c==1) return -1;
     if(p1==-1 || p2==-1) return -1;
     if(p1!=p2) return -1;
     ss.push_back(1+p1+p2);
     return 1+p1+p2;    
} 
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
       ss.clear(); 
       rec(root);
       sort(ss.begin(),ss.end());
       reverse(ss.begin(),ss.end());

       for(auto ele :ss) cout<<ele<<"" "";
       cout<<""\n"";
       k--;
       if(k<ss.size()) return ss[k];
       return -1;
    }
};",1420538120
nimishsunny,nimishsunny,334,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
         map<long long,long long > cnt;
         int n = nums.size();
         for(auto ele : nums){
            cnt[ele] = 0;
         }
         int i;
         for(i=0;i<k;i++){
            cnt[nums[i]]++;
         }
         set<pair<long long,long long>> tt;
         long long sum  = 0;
         for(auto ele : cnt){
            tt.insert({ele.second,ele.first});
            sum+=(ele.second*ele.first);
         }
         set<pair<long long ,long>> rem;
         while(tt.size() > x){
            auto ele = *tt.begin();
            sum-=(ele.second*ele.first);
            tt.erase(ele);
            rem.insert(ele);

         }
         vector<long long > res; 
         res.push_back(sum);
         for(i=1;i<n;i++){
            if((i+k-1)>=n){
                continue;
            }
            rem.erase({cnt[nums[i+k-1]],nums[i+k-1]});
            if((tt.find({cnt[nums[i+k-1]],nums[i+k-1]})) != tt.end()){
               tt.erase({cnt[nums[i+k-1]],nums[i+k-1]});
               sum-=(cnt[nums[i+k-1]]*nums[i+k-1]);
            }
            cnt[nums[i+k-1]]++;
            tt.insert({cnt[nums[i+k-1]],nums[i+k-1]});
            sum+=(cnt[nums[i+k-1]]*nums[i+k-1]);
            if((tt.find({cnt[nums[i-1]],nums[i-1]})) != tt.end()){
               sum-=(cnt[nums[i-1]]*nums[i-1]); 
               tt.erase({cnt[nums[i-1]],nums[i-1]});
               rem.erase({cnt[nums[i-1]],nums[i-1]});
               cnt[nums[i-1]]--;
               tt.insert({cnt[nums[i-1]],nums[i-1]});
               sum+=(cnt[nums[i-1]]*nums[i-1]);              
            }
            else{
                rem.erase({cnt[nums[i-1]],nums[i-1]});
                cnt[nums[i-1]]--; 
                tt.insert({cnt[nums[i-1]],nums[i-1]});
                sum+=(cnt[nums[i-1]]*nums[i-1]);
            }
            for(int ii=0;ii<min(4,(int)rem.size());ii++){
                auto it = rem.end(); it--;
                auto ele = *it;
                tt.insert(ele);
                sum+=(ele.first*ele.second);
                rem.erase(ele);
            }
            while(tt.size() > x){
              auto ele = *tt.begin();
              sum-=(ele.second*ele.first);
              tt.erase(ele);
              rem.insert(ele);
            }
           // cout<<i<<""  ll\n"";
            //for(auto ee : tt) cout<<ee.second<<"" ""<<ee.first<<""\n"";
            //cout<<""\n"";
            res.push_back(sum);
         }
         return res;
    }
};",1420605909
nimishsunny,nimishsunny,334,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
         map<int,int > cnt;
         int n = nums.size();
         for(auto ele : nums){
            cnt[ele] = 0;
         }
         int i;
         for(i=0;i<k;i++){
            cnt[nums[i]]++;
         }
         set<pair<int,int>> tt;
         long long sum  = 0;
         for(auto ele : cnt){
            tt.insert({ele.second,ele.first});
            sum+=(ele.second*ele.first);
         }
         set<pair<int,int>> rem;
         while(tt.size() > x){
            auto ele = *tt.begin();
            sum-=(ele.second*ele.first);
            tt.erase(ele);
            rem.insert(ele);

         }
         vector<int > res; 
         res.push_back(sum);
         for(i=1;i<n;i++){
            if((i+k-1)>=n){
                continue;
            }
            rem.erase({cnt[nums[i+k-1]],nums[i+k-1]});
            if((tt.find({cnt[nums[i+k-1]],nums[i+k-1]})) != tt.end()){
               tt.erase({cnt[nums[i+k-1]],nums[i+k-1]});
               sum-=(cnt[nums[i+k-1]]*nums[i+k-1]);
            }
            cnt[nums[i+k-1]]++;
            tt.insert({cnt[nums[i+k-1]],nums[i+k-1]});
            sum+=(cnt[nums[i+k-1]]*nums[i+k-1]);
            if((tt.find({cnt[nums[i-1]],nums[i-1]})) != tt.end()){
               sum-=(cnt[nums[i-1]]*nums[i-1]); 
               tt.erase({cnt[nums[i-1]],nums[i-1]});
               rem.erase({cnt[nums[i-1]],nums[i-1]});
               cnt[nums[i-1]]--;
               tt.insert({cnt[nums[i-1]],nums[i-1]});
               sum+=(cnt[nums[i-1]]*nums[i-1]);              
            }
            else{
                rem.erase({cnt[nums[i-1]],nums[i-1]});
                cnt[nums[i-1]]--; 
                tt.insert({cnt[nums[i-1]],nums[i-1]});
                sum+=(cnt[nums[i-1]]*nums[i-1]);
            }
            for(int ii=0;ii<min(4,(int)rem.size());ii++){
                auto it = rem.end(); it--;
                auto ele = *it;
                tt.insert(ele);
                sum+=(ele.first*ele.second);
                rem.erase(ele);
            }
            while(tt.size() > x){
              auto ele = *tt.begin();
              sum-=(ele.second*ele.first);
              tt.erase(ele);
              rem.insert(ele);
            }
           // cout<<i<<""  ll\n"";
            //for(auto ee : tt) cout<<ee.second<<"" ""<<ee.first<<""\n"";
            //cout<<""\n"";
            res.push_back(sum);
         }
         return res;
    }
};
",1420607464
RWBY27,Sayan_244,336,3509,cpp,"
#define pb push_back
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
vector <int> fin;
void rec(TreeNode* root, int &sizer, bool &isperf) {
    if (root == nullptr) {
        sizer = -1;
        return;
    }
    int sizlef = 0;
    int sizrig = 0;
    bool templef = false;
    bool temprig = false;
    
    rec(root->left, sizlef, templef);
    if (sizlef == -1) {
        templef = true;
        sizlef = 0;
    }
    rec(root->right, sizrig, temprig);
    if (sizrig == -1) {
        temprig = true;
        sizrig = 0;
    }
    
    if (templef and temprig and sizlef == sizrig) {
        sizer = 1 + sizlef + sizrig;
        isperf = true;
        fin.pb(sizer);
    } else {
        isperf = false;
    }
    return;
}
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        fin = {};
        int sizer = 0;
        bool islef = false;
        
        rec(root, sizer, islef);
        sort(fin.begin(), fin.end(), greater <int> ());
        if ((int)fin.size() < k) {
            return -1;
        }
        return fin[k - 1];
    }
};",1420617833
RWBY27,Sayan_244,336,3592,cpp,"// #define fastio()                  \
//     ios_base::sync_with_stdio(0); \
//     cin.tie(0);                   \
//     cout.tie(0)
#define pb push_back
#define show(x) cout << (#x) << "" : "" << x << endl;
//typedef __int128 bigll;
typedef long long ll;
#define ull unsigned long long
#define ld long double
#define pow power
#define mp make_pair
#define ff first
#define ss second
#define pii pair<int, int>
#define pll pair<long long, long long>
#define sq(x) ((x) * (x))
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define siz(a) int((a).size())
#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))
#define Forl(i,a,b) for(ll (i)=(a);(i) < (b); ++(i))
#define Forn(i,a,b) for(int (i)=(a);(i) >= (b); --(i))
#define Fornl(i,a,b) for(ll (i)=(a);(i) >= (b); --(i))
#define endl ""\n""
#define pi 3.14159265
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
const ll mod = 1000 * 1000 * 1000 + 7;
const ll mod1 = 998244353;
const ll INF  = 1ll*1000*1000*1000*1000*1000*1000 + 7; 
//using namespace __gnu_pbds;
using namespace std;
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
      vector<int> d = nums;
      sort(d.begin(), d.end());
      int n = siz(nums);
      d.resize(unique(d.begin(), d.end()) - d.begin());
      map <ll, ll> mapper;
      //print(nums);
      vector <ll> freq(siz(d) + 5);
      for (int i = 0; i < n; ++i) {
        int temp = nums[i];
        nums[i] = lower_bound(d.begin(), d.end(), nums[i]) - d.begin();
        if (mapper.find(nums[i]) == mapper.end()) {
          mapper[nums[i]] = temp;
        }
      }
      set <pll> v1; // having x sums
      set <pll> v2; // having others

      vector <ll> fin;
      ll sum = 0;
      for(int i = 0; i <= k - 1; i++) {
        int mem = nums[i];
        if (!freq[mem]) {
          v2.insert({1, mem});
        } else {
          v2.erase({freq[mem], mem});
          v2.insert({freq[mem] + 1, mem});
        }
        freq[mem] += 1;
      }

      while (siz(v1) < x and siz(v2)) {
        pll cur = *prev(v2.end());
        sum += cur.first * mapper[cur.second];
        v2.erase(prev(v2.end()));
        v1.insert(cur);
      }
      fin.pb(sum);

      for(int i = k; i < n; i++) {
        int mem = nums[i];
        if (!freq[mem]) {
          v2.insert({0, mem});
        }
      }

      for(int i = 1; i + k - 1 <= n - 1; i++) {
        ll prv = nums[i - 1];
        ll nxt = nums[i + k - 1];

        pll p1 = {freq[prv], prv};
        pll p2 = {freq[nxt], nxt};

        if (v1.find(p1) != v1.end()) {
          sum -= freq[prv] * mapper[prv];
          v1.erase(p1);
        } else {
          v2.erase(p1);
        }

        if (v1.find(p2) != v1.end()) {
          //print(i, sum);
          sum -= freq[nxt] * mapper[nxt];
          //print(freq[nxt], mapper[nxt]);
          //print(i, nxt);
          v1.erase(p2);
        } else {
          v2.erase(p2);
        }


        // print(sum);
        // print(p1.first, mapper[p1.second]);
        // print(p2.first, mapper[p2.second]);

        if (p1.second != p2.second) {
          p1.first -= 1;
          p2.first += 1;
          freq[prv] -= 1;
          freq[nxt] += 1;
          v2.insert(p1);
          v2.insert(p2);
        } else {
          v2.insert(p2);
        }

        
        
        while (siz(v1) < x and siz(v2)) {
          pll cur = *prev(v2.end());
          sum += cur.first * mapper[cur.second];
          v2.erase(prev(v2.end()));
          v1.insert(cur);
        }

        // print(sum);
        // print(p1.first, mapper[p1.second]);
        // print(p2.first, mapper[p2.second]);
        // print(siz(v2), siz(v1));

        // for(auto & duh : v2) {
        //   if (i == 2) {
        //     print(duh.first, mapper[duh.second]);
        //   }
        // }

        // for(auto & duh : v1) {
        //   if (i == 2) {
        //     print(duh.first, mapper[duh.second]);
        //   }
        // }
        // print(p2);
        //print(sum);
        while (siz(v2) and ((*prev(v2.end())).first >  (*v1.begin()).first ||
          ((*prev(v2.end())).first ==  (*v1.begin()).first and 
            (*prev(v2.end())).second >  (*v1.begin()).second))) {
          // print(i, ""sayan"");
          pll c1 = *v1.begin();
          pll c2 = *prev(v2.end());
          sum -= c1.first * mapper[c1.second];
          sum += c2.first * mapper[c2.second];
          v2.erase(prev(v2.end()));
          v1.erase(v1.begin());
          v1.insert(c2);
          v2.insert(c1);
        }
        fin.pb(sum);

        // if (i == 2)
        // break;
      }

      //print(nums);
      //print(sum);
      return fin;
    }
};",1420597985
RWBY27,Sayan_244,336,3610,cpp,"// #define fastio()                  \
//     ios_base::sync_with_stdio(0); \
//     cin.tie(0);                   \
//     cout.tie(0)
#define pb push_back
#define show(x) cout << (#x) << "" : "" << x << endl;
//typedef __int128 bigll;
typedef long long ll;
#define ull unsigned long long
#define ld long double
#define pow power
#define mp make_pair
#define ff first
#define ss second
#define pii pair<int, int>
#define pll pair<long long, long long>
#define sq(x) ((x) * (x))
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define siz(a) int((a).size())
#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))
#define Forl(i,a,b) for(ll (i)=(a);(i) < (b); ++(i))
#define Forn(i,a,b) for(int (i)=(a);(i) >= (b); --(i))
#define Fornl(i,a,b) for(ll (i)=(a);(i) >= (b); --(i))
#define endl ""\n""
#define pi 3.14159265
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
const ll mod = 1000 * 1000 * 1000 + 7;
const ll mod1 = 998244353;
const ll INF  = 1ll*1000*1000*1000*1000*1000*1000 + 7; 
//using namespace __gnu_pbds;
using namespace std;
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
      vector<int> d = nums;
      sort(d.begin(), d.end());
      int n = siz(nums);
      d.resize(unique(d.begin(), d.end()) - d.begin());
      map <ll, ll> mapper;
      //print(nums);
      vector <ll> freq(siz(d) + 5);
      for (int i = 0; i < n; ++i) {
        int temp = nums[i];
        nums[i] = lower_bound(d.begin(), d.end(), nums[i]) - d.begin();
        if (mapper.find(nums[i]) == mapper.end()) {
          mapper[nums[i]] = temp;
        }
      }
      set <pll> v1; // having x sums
      set <pll> v2; // having others

      vector <int> fin;
      ll sum = 0;
      for(int i = 0; i <= k - 1; i++) {
        int mem = nums[i];
        if (!freq[mem]) {
          v2.insert({1, mem});
        } else {
          v2.erase({freq[mem], mem});
          v2.insert({freq[mem] + 1, mem});
        }
        freq[mem] += 1;
      }

      while (siz(v1) < x and siz(v2)) {
        pll cur = *prev(v2.end());
        sum += cur.first * mapper[cur.second];
        v2.erase(prev(v2.end()));
        v1.insert(cur);
      }
      fin.pb(sum);

      for(int i = k; i < n; i++) {
        int mem = nums[i];
        if (!freq[mem]) {
          v2.insert({0, mem});
        }
      }

      for(int i = 1; i + k - 1 <= n - 1; i++) {
        ll prv = nums[i - 1];
        ll nxt = nums[i + k - 1];

        pll p1 = {freq[prv], prv};
        pll p2 = {freq[nxt], nxt};

        if (v1.find(p1) != v1.end()) {
          sum -= freq[prv] * mapper[prv];
          v1.erase(p1);
        } else {
          v2.erase(p1);
        }

        if (v1.find(p2) != v1.end()) {
          //print(i, sum);
          sum -= freq[nxt] * mapper[nxt];
          //print(freq[nxt], mapper[nxt]);
          //print(i, nxt);
          v1.erase(p2);
        } else {
          v2.erase(p2);
        }


        // print(sum);
        // print(p1.first, mapper[p1.second]);
        // print(p2.first, mapper[p2.second]);

        if (p1.second != p2.second) {
          p1.first -= 1;
          p2.first += 1;
          freq[prv] -= 1;
          freq[nxt] += 1;
          v2.insert(p1);
          v2.insert(p2);
        } else {
          v2.insert(p2);
        }

        
        
        while (siz(v1) < x and siz(v2)) {
          pll cur = *prev(v2.end());
          sum += cur.first * mapper[cur.second];
          v2.erase(prev(v2.end()));
          v1.insert(cur);
        }

        // print(sum);
        // print(p1.first, mapper[p1.second]);
        // print(p2.first, mapper[p2.second]);
        // print(siz(v2), siz(v1));

        // for(auto & duh : v2) {
        //   if (i == 2) {
        //     print(duh.first, mapper[duh.second]);
        //   }
        // }

        // for(auto & duh : v1) {
        //   if (i == 2) {
        //     print(duh.first, mapper[duh.second]);
        //   }
        // }
        // print(p2);
        //print(sum);
        while (siz(v2) and ((*prev(v2.end())).first >  (*v1.begin()).first ||
          ((*prev(v2.end())).first ==  (*v1.begin()).first and 
            (*prev(v2.end())).second >  (*v1.begin()).second))) {
          // print(i, ""sayan"");
          pll c1 = *v1.begin();
          pll c2 = *prev(v2.end());
          sum -= c1.first * mapper[c1.second];
          sum += c2.first * mapper[c2.second];
          v2.erase(prev(v2.end()));
          v1.erase(v1.begin());
          v1.insert(c2);
          v2.insert(c1);
        }
        fin.pb(sum);

        // if (i == 2)
        // break;
      }

      //print(nums);
      //print(sum);
      return fin;
    }
};",1420599461
Macharla Venkata Ravi Teja,striver1217010,337,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 import java.util.*;
 class MyBean {
   public int leftSize;
   public int rightSize;
   public int totalSize;
   public boolean isPerfect;

    public MyBean(int leftSize, int rightSize, int totalSize, boolean isPerfect) {
        this.leftSize = leftSize;
        this.rightSize = rightSize;
        this.totalSize = totalSize;
        this.isPerfect = isPerfect;
    }
 }
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        kthLargestPerfectSubtreeHelper(root, pq);
        int result = -1;

        for (int i = 1; i <= k && !pq.isEmpty(); i++) {
            int top = pq.poll();

            if (i == k) {
                result= top;
            }
        }

        return result;
    }

    public MyBean kthLargestPerfectSubtreeHelper(TreeNode root, PriorityQueue<Integer> pq) {
        if (root == null) {
            return new MyBean(0, 0, 0, true);
        } else {
            MyBean left = kthLargestPerfectSubtreeHelper(root.left, pq);
            MyBean right = kthLargestPerfectSubtreeHelper(root.right, pq);

            boolean isPerfect = left.isPerfect && right.isPerfect && ((left.totalSize) == (right.totalSize));
            if (isPerfect) {
                pq.add(1 + left.totalSize + right.totalSize);
            }

            return new MyBean(left.totalSize, right.totalSize, 1 + left.totalSize + right.totalSize, isPerfect);
        }
    }
}",1420536555
Macharla Venkata Ravi Teja,striver1217010,337,3592,java,"import java.util.*;
class MyBean {
    public long val;
    public long freq;

    public MyBean(long val, long freq) {
        this.val = val;
        this.freq = freq;
    }
}
class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        TreeSet<MyBean> ts1 = new TreeSet<>((b1, b2) -> {
            if (b1.freq != b2.freq) {
                return (b1.freq < b2.freq) ? -1 : 1;
            } else if (b1.val < b2.val) {
                return -1;
            } else if (b1.val > b2.val) {
                return 1;
            } else {
                return 0;
            }
        });


         TreeSet<MyBean> ts2 = new TreeSet<>((b1, b2) -> {
            if (b1.freq != b2.freq) {
                return (b1.freq < b2.freq) ? 1 : -1;
            } else if (b1.val < b2.val) {
                return 1;
            } else if (b1.val > b2.val) {
                return -1;
            } else {
                return 0;
            }
        });

        Map<Long, Long> freqMap = new HashMap<>();
        long total = 0;
        int n = nums.length;
        long result[] = new long[n - k + 1];

        for (int i = 0; i < k; i++) {

            if (freqMap.containsKey((long)nums[i])) {
                if (ts1.contains(new MyBean((long)nums[i], freqMap.get((long)nums[i])))) {
                    total = total - (((long)nums[i]) * freqMap.get((long)nums[i]));
                }
                ts1.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
                ts2.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
            }
            freqMap.put((long)nums[i], freqMap.getOrDefault((long)nums[i], (long)0) + 1);

            ts2.add(new MyBean((long)nums[i], freqMap.get((long)nums[i])));

            while (ts1.size() < x && !ts2.isEmpty()) {
                MyBean top = ts2.pollFirst();
                ts1.add(top);
                total = total + (top.freq * top.val);
            }

            while (!ts2.isEmpty()) {
                MyBean top1 = ts1.first();
                MyBean top2 = ts2.first();

                if (compare(top2, top1) > 0) {
                    ts1.pollFirst();
                    ts2.pollFirst();
                    total = total - (top1.freq * top1.val);
                    ts1.add(top2);
                    ts2.add(top1);
                    total = total + (top2.freq * top2.val);
                } else {
                    break;
                }
            }
        }

        result[0] = total;

        for (int i = k; i < n; i++) {
            if (ts1.contains(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])))) {
                total = total - (((long)nums[i - k]) * freqMap.get((long)nums[i - k]));
            }
            ts1.remove(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])));
            ts2.remove(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])));
            freqMap.put((long)nums[i - k], freqMap.getOrDefault((long)nums[i - k], (long)0) - 1);

            if (freqMap.get((long)nums[i - k]).intValue() > 0) {
                ts2.add(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])));
            }


             if (freqMap.containsKey((long)nums[i])) {
                if (ts1.contains(new MyBean((long)nums[i], freqMap.get((long)nums[i])))) {
                    total = total - (((long)nums[i]) * freqMap.get((long)nums[i]));
                }
                ts1.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
                ts2.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
            }
            freqMap.put((long)nums[i], freqMap.getOrDefault((long)nums[i], (long)0) + 1);

            ts2.add(new MyBean((long)nums[i], freqMap.get((long)nums[i])));

            while (ts1.size() < x && !ts2.isEmpty()) {
                MyBean top = ts2.pollFirst();
                ts1.add(top);
                total = total + (top.freq * top.val);
            }

            while (!ts2.isEmpty()) {
                MyBean top1 = ts1.first();
                MyBean top2 = ts2.first();

                if (compare(top2, top1) > 0) {
                    ts1.pollFirst();
                    ts2.pollFirst();
                    total = total - (top1.freq * top1.val);
                    ts1.add(top2);
                    ts2.add(top1);
                    total = total + (top2.freq * top2.val);
                } else {
                    break;
                }
            }

            result[i - k + 1] = total;
        }

        return result;
    }

    public int compare(MyBean b1, MyBean b2) {
        if (b1.freq != b2.freq) {
            return (b1.freq < b2.freq) ? -1 : 1;
        } else if (b1.val < b2.val) {
            return -1;
        } else if (b1.val > b2.val) {
            return 1;
        } else {
            return 0;
        }
    }
}",1420614459
Macharla Venkata Ravi Teja,striver1217010,337,3610,java,"import java.util.*;
class MyBean {
    public long val;
    public long freq;

    public MyBean(long val, long freq) {
        this.val = val;
        this.freq = freq;
    }
}
class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        TreeSet<MyBean> ts1 = new TreeSet<>((b1, b2) -> {
            if (b1.freq != b2.freq) {
                return (b1.freq < b2.freq) ? -1 : 1;
            } else if (b1.val < b2.val) {
                return -1;
            } else if (b1.val > b2.val) {
                return 1;
            } else {
                return 0;
            }
        });


         TreeSet<MyBean> ts2 = new TreeSet<>((b1, b2) -> {
            if (b1.freq != b2.freq) {
                return (b1.freq < b2.freq) ? 1 : -1;
            } else if (b1.val < b2.val) {
                return 1;
            } else if (b1.val > b2.val) {
                return -1;
            } else {
                return 0;
            }
        });

        Map<Long, Long> freqMap = new HashMap<>();
        long total = 0;
        int n = nums.length;
        long result[] = new long[n - k + 1];

        for (int i = 0; i < k; i++) {

            if (freqMap.containsKey((long)nums[i])) {
                if (ts1.contains(new MyBean((long)nums[i], freqMap.get((long)nums[i])))) {
                    total = total - (((long)nums[i]) * freqMap.get((long)nums[i]));
                }
                ts1.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
                ts2.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
            }
            freqMap.put((long)nums[i], freqMap.getOrDefault((long)nums[i], (long)0) + 1);

            ts2.add(new MyBean((long)nums[i], freqMap.get((long)nums[i])));

            while (ts1.size() < x && !ts2.isEmpty()) {
                MyBean top = ts2.pollFirst();
                ts1.add(top);
                total = total + (top.freq * top.val);
            }

            while (!ts2.isEmpty()) {
                MyBean top1 = ts1.first();
                MyBean top2 = ts2.first();

                if (compare(top2, top1) > 0) {
                    ts1.pollFirst();
                    ts2.pollFirst();
                    total = total - (top1.freq * top1.val);
                    ts1.add(top2);
                    ts2.add(top1);
                    total = total + (top2.freq * top2.val);
                } else {
                    break;
                }
            }
        }

        result[0] = total;

        for (int i = k; i < n; i++) {
            if (ts1.contains(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])))) {
                total = total - (((long)nums[i - k]) * freqMap.get((long)nums[i - k]));
            }
            ts1.remove(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])));
            ts2.remove(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])));
            freqMap.put((long)nums[i - k], freqMap.getOrDefault((long)nums[i - k], (long)0) - 1);

            if (freqMap.get((long)nums[i - k]).intValue() > 0) {
                ts2.add(new MyBean((long)nums[i - k], freqMap.get((long)nums[i - k])));
            }


             if (freqMap.containsKey((long)nums[i])) {
                if (ts1.contains(new MyBean((long)nums[i], freqMap.get((long)nums[i])))) {
                    total = total - (((long)nums[i]) * freqMap.get((long)nums[i]));
                }
                ts1.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
                ts2.remove(new MyBean((long)nums[i], freqMap.get((long)nums[i])));
            }
            freqMap.put((long)nums[i], freqMap.getOrDefault((long)nums[i], (long)0) + 1);

            ts2.add(new MyBean((long)nums[i], freqMap.get((long)nums[i])));

            while (ts1.size() < x && !ts2.isEmpty()) {
                MyBean top = ts2.pollFirst();
                ts1.add(top);
                total = total + (top.freq * top.val);
            }

            while (!ts2.isEmpty()) {
                MyBean top1 = ts1.first();
                MyBean top2 = ts2.first();

                if (compare(top2, top1) > 0) {
                    ts1.pollFirst();
                    ts2.pollFirst();
                    total = total - (top1.freq * top1.val);
                    ts1.add(top2);
                    ts2.add(top1);
                    total = total + (top2.freq * top2.val);
                } else {
                    break;
                }
            }

            result[i - k + 1] = total;
        }

        int resultInt[] = new int[result.length];

        for (int i = 0; i < result.length; i++) {
            resultInt[i] = (int)result[i];
        }

        return resultInt;
    }

     public int compare(MyBean b1, MyBean b2) {
        if (b1.freq != b2.freq) {
            return (b1.freq < b2.freq) ? -1 : 1;
        } else if (b1.val < b2.val) {
            return -1;
        } else if (b1.val > b2.val) {
            return 1;
        } else {
            return 0;
        }
    }
}",1420618161
Satyendra,biltharesatyendra,338,3509,python,"# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def dfs(self, root):
        if not root:
            return 0,True
        
        fir = self.dfs(root.left)
        sec = self.dfs(root.right)
        ret = 0
        if fir[1]:
            ret += fir[0]
        else :
            return 0,False
        if sec[1]:
            ret += sec[0]
        else:
            return 0,False
        ret += 1
        ret += 1
        if ret & (ret - 1):
            return 0,False
        self.ans.append((ret-1, -root.val))
       # print(root.val, ret-1)
        return ret-1, True
        
    def kthLargestPerfectSubtree(self, root, k):
        """"""
        :type root: Optional[TreeNode]
        :type k: int
        :rtype: int
        """"""
        self.ans = []
        self.dfs(root)
        self.ans.sort()
        self.ans.reverse()
        #print(self.ans)
        if len(self.ans) < k:
            return -1
        return self.ans[k-1][0]
        
        ",1420618294
Satyendra,biltharesatyendra,338,3592,cpp,"typedef long long ll;
int a[100005];
ll cnt[100005];
map<int,int> ran,rev;
ll ans = 0;
set< pair<ll,int> > freq; // all elements frequent
set< pair<ll,int> > top; // top k elements which we want
set< pair<ll,int> > ::iterator I;
void add(int x, int k)
{
    // add element x and check if its frequencey is greater than lim and then add to top k values 
    int ind = ran[x];
   // printf(""adding %d\n"",x);
    // freq is max heap
    // top is min heap
    if(cnt[ind])
    {
        freq.erase({-cnt[ind], -ind});
        if(top.find({cnt[ind], ind}) != top.end()){
            top.erase({cnt[ind],ind});
            ans -= cnt[ind] * rev[ind];
           // printf(""it was in priority so removed its contribution and ans become %lld\n"", ans);
        }
    }
    cnt[ind]++;
    freq.insert({-cnt[ind],-ind});
    
    I = freq.begin();
    // this is max heap hence value are negative 
   // if(I == freq.end())
     //   printf(""error\n"");
    //else printf(""we need to move %d %lld from freq to top\n"",rev[-I->second], -I->first);
    pair<ll,int> rem = {-I->first, -I->second};
    freq.erase(I);
   // printf(""removed\n"");
    // remove highest frequency highest value element and insert in top k hep in min heap order
   // printf(""%lld %lld\n"",rem.first, rem.second);
    top.insert(rem);
    // added to top k hence adding its contribution 
    ans += (rem.first) * rev[rem.second];
   // printf(""so added %lld\n"",rem.first * rem.second);
    //printf(""hence ans becomes %lld\n"",ans);
    if(top.size() > k) // more than k elements so remove the first
    {
       // printf(""there are more than %d\n"",k);
        I = top.begin();
        rem = {-I->first, -I->second};
       // printf(""we are removing %d contribution %lld\n"",rev[-rem.second], -rem.first);
        top.erase(I);
        freq.insert(rem);
        ans -= (-rem.first) * rev[-rem.second];
       // printf(""hence ans becomes %lld\n"",ans);
    }
    
    
}
void remove(int x, int k)
{
    // add element x and check if its frequencey is greater than lim and then add to top k values 
    int ind = ran[x];
   // printf(""adding %d\n"",x);
    // freq is max heap
    // top is min heap
    if(cnt[ind])
    {
        freq.erase({-cnt[ind], -ind});
        if(top.find({cnt[ind], ind}) != top.end()){
            top.erase({cnt[ind],ind});
            ans -= cnt[ind] * rev[ind];
           // printf(""it was in priority so removed its contribution and ans become %lld\n"", ans);
        }
    }
    cnt[ind]--;
    freq.insert({-cnt[ind],-ind});
    
    I = freq.begin();
    // this is max heap hence value are negative 
  //  if(I == freq.end())
    //    printf(""error\n"");
    //else printf(""we need to move %d %lld from freq to top\n"",rev[-I->second], -I->first);
    pair<ll,int> rem = {-I->first, -I->second};
    freq.erase(I);
  //  printf(""removed\n"");
    // remove highest frequency highest value element and insert in top k hep in min heap order
   // printf(""%lld %lld\n"",rem.first, rem.second);
    if(rem.first){
    top.insert(rem);
    // added to top k hence adding its contribution 
    ans += (rem.first) * rev[rem.second];
    }
   // printf(""so added %lld\n"",rem.first * rem.second);
    //printf(""hence ans becomes %lld\n"",ans);
    if(top.size() > k) // more than k elements so remove the first
    {
       // printf(""there are more than %d\n"",k);
        I = top.begin();
        rem = {-I->first, -I->second};
       // printf(""we are removing %d contribution %lld\n"",rev[-rem.second], -rem.first);
        top.erase(I);
        freq.insert(rem);
        ans -= (-rem.first) * rev[-rem.second];
       // printf(""hence ans becomes %lld\n"",ans);
    }
    
    
    
}
class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int lim) {
        freq.clear();
        top.clear();
        ran.clear();
        rev.clear();
        set<int> s;
        ans = 0;
        for(int x : nums)
            s.insert(x);
        int ind=0;
        for(int x : s)
        {
            ind++;
            ran[x] = ind;
            rev[ind] = x;
        }
        int i;
        for(i=1; i<=ind; i++)
            cnt[i] = 0;
        int n = nums.size();
        for(i=1; i<=n; i++)
        {
            a[i] = nums[i-1];
        }
        vector<ll> res;
        
        
        for(i=1; i<=k; i++)
        {
            add(a[i],lim);
            
        }
        res.push_back(ans);
       // printf(""now subarray\n"");
        for(;i<=n; i++)
        {
            remove(a[i-k],lim);
            add(a[i], lim);
            res.push_back(ans);
        }
        return res;
        
    }
};",1420603097
Satyendra,biltharesatyendra,338,3610,cpp,"typedef int ll;
int a[100005];
ll cnt[100005];
map<int,int> ran,rev;
ll ans = 0;
set< pair<ll,int> > freq; // all elements frequent
set< pair<ll,int> > top; // top k elements which we want
set< pair<ll,int> > ::iterator I;
void add(int x, int k)
{
    // add element x and check if its frequencey is greater than lim and then add to top k values 
    int ind = ran[x];
   // printf(""adding %d\n"",x);
    // freq is max heap
    // top is min heap
    if(cnt[ind])
    {
        freq.erase({-cnt[ind], -ind});
        if(top.find({cnt[ind], ind}) != top.end()){
            top.erase({cnt[ind],ind});
            ans -= cnt[ind] * rev[ind];
           // printf(""it was in priority so removed its contribution and ans become %lld\n"", ans);
        }
    }
    cnt[ind]++;
    freq.insert({-cnt[ind],-ind});
    
    I = freq.begin();
    // this is max heap hence value are negative 
   // if(I == freq.end())
     //   printf(""error\n"");
    //else printf(""we need to move %d %lld from freq to top\n"",rev[-I->second], -I->first);
    pair<ll,int> rem = {-I->first, -I->second};
    freq.erase(I);
   // printf(""removed\n"");
    // remove highest frequency highest value element and insert in top k hep in min heap order
   // printf(""%lld %lld\n"",rem.first, rem.second);
    top.insert(rem);
    // added to top k hence adding its contribution 
    ans += (rem.first) * rev[rem.second];
   // printf(""so added %lld\n"",rem.first * rem.second);
    //printf(""hence ans becomes %lld\n"",ans);
    if(top.size() > k) // more than k elements so remove the first
    {
       // printf(""there are more than %d\n"",k);
        I = top.begin();
        rem = {-I->first, -I->second};
       // printf(""we are removing %d contribution %lld\n"",rev[-rem.second], -rem.first);
        top.erase(I);
        freq.insert(rem);
        ans -= (-rem.first) * rev[-rem.second];
       // printf(""hence ans becomes %lld\n"",ans);
    }
    
    
}
void remove(int x, int k)
{
    // add element x and check if its frequencey is greater than lim and then add to top k values 
    int ind = ran[x];
   // printf(""adding %d\n"",x);
    // freq is max heap
    // top is min heap
    if(cnt[ind])
    {
        freq.erase({-cnt[ind], -ind});
        if(top.find({cnt[ind], ind}) != top.end()){
            top.erase({cnt[ind],ind});
            ans -= cnt[ind] * rev[ind];
           // printf(""it was in priority so removed its contribution and ans become %lld\n"", ans);
        }
    }
    cnt[ind]--;
    freq.insert({-cnt[ind],-ind});
    
    I = freq.begin();
    // this is max heap hence value are negative 
  //  if(I == freq.end())
    //    printf(""error\n"");
    //else printf(""we need to move %d %lld from freq to top\n"",rev[-I->second], -I->first);
    pair<ll,int> rem = {-I->first, -I->second};
    freq.erase(I);
  //  printf(""removed\n"");
    // remove highest frequency highest value element and insert in top k hep in min heap order
   // printf(""%lld %lld\n"",rem.first, rem.second);
    if(rem.first){
    top.insert(rem);
    // added to top k hence adding its contribution 
    ans += (rem.first) * rev[rem.second];
    }
   // printf(""so added %lld\n"",rem.first * rem.second);
    //printf(""hence ans becomes %lld\n"",ans);
    if(top.size() > k) // more than k elements so remove the first
    {
       // printf(""there are more than %d\n"",k);
        I = top.begin();
        rem = {-I->first, -I->second};
       // printf(""we are removing %d contribution %lld\n"",rev[-rem.second], -rem.first);
        top.erase(I);
        freq.insert(rem);
        ans -= (-rem.first) * rev[-rem.second];
       // printf(""hence ans becomes %lld\n"",ans);
    }
    
    
    
}
class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int lim) {
        freq.clear();
        top.clear();
        ran.clear();
        rev.clear();
        set<int> s;
        ans = 0;
        for(int x : nums)
            s.insert(x);
        int ind=0;
        for(int x : s)
        {
            ind++;
            ran[x] = ind;
            rev[ind] = x;
        }
        int i;
        for(i=1; i<=ind; i++)
            cnt[i] = 0;
        int n = nums.size();
        for(i=1; i<=n; i++)
        {
            a[i] = nums[i-1];
        }
        vector<ll> res;
        
        
        for(i=1; i<=k; i++)
        {
            add(a[i],lim);
            
        }
        res.push_back(ans);
       // printf(""now subarray\n"");
        for(;i<=n; i++)
        {
            remove(a[i-k],lim);
            add(a[i], lim);
            res.push_back(ans);
        }
        return res;
        
    }
};",1420604555
Emily,aezara,339,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def addtoheap(x):
            if len(sizes) < k or x > sizes[0]:
                heapq.heappush(sizes, x)
                if len(sizes) > k:
                    heapq.heappop(sizes)

        # size of binary subtree
        # if not perfect binary tree, return None
        def helper(root):
            if not root:
                return None
            # print(root.val)
            # leaf
            if not root.left and not root.right:
                addtoheap(1)
                return 1
            
            # get results from children
            lsize = helper(root.left)
            rsize = helper(root.right)
            # inbalanced
            if lsize is None or rsize is None or lsize != rsize:
                return None
            
            cursize = lsize + rsize + 1
            addtoheap(cursize)
            return cursize
        
        helper(root)

        # print(sizes)

        if len(sizes) < k:
            return -1

        return sizes[0]",1420529644
Emily,aezara,339,3592,python3,"""""""
try sliding window with counter
- keep freq of numbers
- but we need to keep the top x frequencies, how?
    - ordered set in cpp

map from value to freq
set from freq to value

update:
- use map


no

just keep a sorted list of (freq, val)?
how do i upate it?

update
- keep map from val to freq so i can find the right element quickly
- remove and reinsert. if the index changes significantly (before it wasnt top x but now it is, or vice versa)
    then we can adjust the current sum
""""""

def _print(*args):
    # print(*args)
    pass

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        # sliding window
        freq = Counter(nums[:k-1])

        # note that top x is the LAST X ELEMENTS
        # sortedlist[n-x] is the first one
        sortedlist = [(f, val) for val, f in freq.items()]
        sortedlist.sort()

        cursum = sum([f*val for f,val in sortedlist[max(0, len(sortedlist)-x):]])

        _print(""starting sorted list"", sortedlist)
        _print(""starting cursum"", cursum)

        
        def update_freq(num, delta):
            nonlocal cursum
            # update front of window
            oldvalue = (freq[num], num)
            old_i = bisect.bisect_left(sortedlist, oldvalue)
            removed = False
            if old_i < len(sortedlist) and sortedlist[old_i] == oldvalue:
                wastopx = old_i >= len(sortedlist)-x
                removed = True
                del sortedlist[old_i]
                if wastopx:
                    _print(""removed from top x"")
                    cursum -= freq[num] * num
                    _print(f""removed {num} with count {freq[num]}: {cursum}"")
                # need to add something back
                if len(sortedlist) >= x and wastopx:
                    f, numm = sortedlist[len(sortedlist)-x]
                    cursum += f*numm
                    _print(f""adding {numm} with count {f} to compensate: {cursum}"")
            freq[num] += delta
            
            # figure out what to add back for current element
            newvalue = (freq[num], num)
            bisect.insort_left(sortedlist, newvalue)
            new_i = bisect.bisect_left(sortedlist, newvalue)

            # added to top x
            # print(""!!!"", new_i, len(sortedlist)-x)
            if new_i >= len(sortedlist)-x:
                _print(f""added to top x"")
                cursum += freq[num] * num
                _print(f""adding {num} with count {freq[num]}: {cursum}"")
                # remove thing that was bumped out
                if len(sortedlist) >= x+1:
                    f, numm = sortedlist[len(sortedlist)-x-1]
                    cursum -= f*numm
                    _print(f""removing {numm} with count {f}: {cursum}"")

        def update(i, front):
            nonlocal cursum
            mult = 1 if front else -1
            # update front of window
            oldvalue = (freq[nums[i]], nums[i])
            old_i = bisect.bisect_left(sortedlist, oldvalue)
            removed = False
            if old_i < len(sortedlist) and sortedlist[old_i] == oldvalue:
                removed = True
                del sortedlist[old_i]
                cursum -= freq[nums[i]] * nums[i] * mult
                _print(f""removed {nums[i]} with count {freq[nums[i]]}: {cursum}"")
            freq[nums[i]] += 1 * mult
            
            # figure out what to add back
            newvalue = (freq[nums[i]], nums[i])
            bisect.insort_left(sortedlist, newvalue)
            new_i = bisect.bisect_left(sortedlist, newvalue)

            # added to top x
            if new_i >= len(sortedlist)-x:
                cursum += freq[nums[i]] * nums[i]
                _print(f""1 adding {nums[i]} with count {freq[nums[i]]}: {cursum}"")
            # removed from top x
            elif removed and old_i >= len(sortedlist)-x:
                f, numm = sortedlist[len(sortedlist)-x]
                cursum += f*numm
                _print(f""2 adding {numm} with count {f}: {cursum}"")
            # otherwise, shouldn't have changed anything

        # this is the new element to add
        for i in range(k-1, n):
            _print(""FRONT:"",nums[i])
            # update(i, True)
            update_freq(nums[i], 1)
            _print(cursum)
            _print(sortedlist)

            # remove left end of window
            if i-k >= 0:
                _print(""BACK:"", nums[i-k])
                # update(i-k, False)
                update_freq(nums[i-k], -1)
                
                _print(cursum)
                _print(sortedlist)
            _print(""-----------------------------------------"")

            ans.append(cursum)
        
        return ans",1420602984
Emily,aezara,339,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        for i in range(n-k+1):
            c = Counter(nums[i:i+k])
            freqs = [(v, k) for k, v in c.items()]
            freqs.sort(reverse=True)
            # print(freqs)
            ans.append(sum([k*v for v, k in freqs[:x]]))
        return ans",1420519847
jeff27726,jeff27726,340,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sz;
        sz.reserve(2000);
        
        function<int(TreeNode*)> find = [&](TreeNode* nd){
            if(nd==nullptr)
                return 0;
            int l = find(nd->left);
            int r = find(nd->right);
            if(l==r && l!=-1){
                sz.push_back(2*l+1);
                return 2*l+1;
            }
            return -1;
        };
        
        find(root);
        
        if(sz.size()<k) return -1;
        
        sort(sz.rbegin(), sz.rend());
        
        return sz[k-1];
    }
};",1420537416
jeff27726,jeff27726,340,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> result;
        
        unordered_map<int, int> freq;
        
        set<pair<int, int>> topX;
        set<pair<int, int>> others;
        
        long long currentSum = 0;
        auto balanceSets = [&]() {
            while (topX.size() > x) {
                auto it = topX.begin();
                currentSum -= (it->second * 1LL) * (it->first);
                others.insert(*it);
                topX.erase(it);
            }
            while (topX.size() < x && !others.empty()) {
                auto it = prev(others.end());
                currentSum += (it->second * 1LL) * (it->first);
                topX.insert(*it);
                others.erase(it);
            }
        };
        auto addElement = [&](int num) {
            int currentFreq = freq[num]++;
            if (currentFreq > 0) {
                auto it = topX.find({currentFreq, num});
                if (it != topX.end()) {
                    currentSum -= (num * 1LL) * currentFreq;
                    topX.erase(it);
                }
                else {
                    others.erase({currentFreq, num});
                }
            }
            topX.insert({currentFreq + 1, num});
            currentSum += (num * 1LL) * (currentFreq+1);
            balanceSets();
        };
        
        auto removeElement = [&](int num) {
            int currentFreq = freq[num]--;
            auto it = topX.find({currentFreq, num});
            if (it != topX.end()) {
                currentSum -= (num * 1LL) * currentFreq;
                topX.erase(it);
            }
            else {
                others.erase({currentFreq, num});
            }
            if (currentFreq > 1) {
            others.insert({currentFreq - 1, num});
            }
            balanceSets();
        };
        for (int i = 0; i < k; i++) {
            addElement(nums[i]);
        }
        result.push_back(currentSum);
        for (int i = k; i < n; i++) {
            removeElement(nums[i - k]);
            addElement(nums[i]);
            result.push_back(currentSum);
        }
        return result;
    }
};",1420614915
jeff27726,jeff27726,340,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        unordered_map<int, int> freq;
        map<int, set<int>> freqElmt;
        
        const auto add = [&](int p)->void{
            int last_freq=0;
            if(freq.contains(p)){
                last_freq = freq[p]++;
                freqElmt[last_freq].erase(freqElmt[last_freq].find(p));
            }
            else
                freq[p] = 1;
            freqElmt[last_freq+1].insert(p);
        };
        
        const auto minus = [&](int p)->void{
            int last_freq = freq[p]--;
            freqElmt[last_freq].erase(freqElmt[last_freq].find(p));
            if(freq[p]==0)
                freq.erase(freq.find(p));
            else
                freqElmt[last_freq-1].insert(p);
        };
        
        const auto calculate = [&](){
            int res = 0;
            int count = 0;
            for(auto it=freqElmt.rbegin(); it!=freqElmt.rend(); ++it){
                int f = it->first;
                auto st = it->second;
                for(auto sit=st.rbegin(); sit!=st.rend(); ++sit){
                    res += (*sit)*f;
                    count += 1;
                    //cout << res << ' ';
                    //cout << ""("" << count << "") "";
                    if(count>=x)
                        break;
                }
                if(count>=x){
                    break;
                }
            }
            //cout << res << '\n';
            return res;
        };
        
        vector<int> Res;
        Res.reserve(n-k+1);
        
        for(int i=0; i<k; ++i){
            add(nums[i]);
        }
        
        Res.push_back(calculate());
        
        for(int i=k; i<n; ++i){
            minus(nums[i-k]);
            add(nums[i]);
            Res.push_back(calculate());
        }
        
        return Res;
    }
};",1420585032
JerryWzc,JerryWzc,341,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    Map<Integer, Integer> counts = new HashMap<>();

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        dfs(root);
        TreeMap<Integer, Integer> tm = new TreeMap<>((a, b) -> b - a);
        tm.putAll(counts);
        for (Map.Entry<Integer, Integer> entry : tm.entrySet()) {
            k -= entry.getValue();
            if (k <= 0) return entry.getKey();
        }
        return -1;
    }

    private int dfs(TreeNode node) {
        if (node == null) return 0;
        int leftSize = dfs(node.left);
        int rightSize = dfs(node.right);
        if (leftSize >= 0 && rightSize >= 0 && leftSize == rightSize) {
            int size = leftSize + rightSize + 1;
            counts.compute(size, (k, v) -> v == null ? 1 : v + 1);
            return size;
        } else {
            return -1;
        }
    }
}",1420548298
JerryWzc,JerryWzc,341,3592,java,"class Solution {
    public long[] findXSum(int[] nums, int k, int x) {
        TreeSet<NumWithFrequency> ts1 = new TreeSet<>((a, b) -> {
            if (a.freq == b.freq) return b.num - a.num;
            return b.freq - a.freq;
        });
        TreeSet<NumWithFrequency> ts2 = new TreeSet<>((a, b) -> {
            if (a.freq == b.freq) return b.num - a.num;
            return b.freq - a.freq;
        });
        Map<Integer, NumWithFrequency> map = new HashMap<>();
        long sum = 0L;

        int n = nums.length;
        long[] results = new long[n - k + 1];
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            sum += increaseFreq(ts1, ts2, map, x, num);
            // System.out.println(""AFTER ADD: "" + ts1 + ""\t"" + ts2 + ""\t"" + sum);
            if (i >= k - 1) {
                results[i - k + 1] = sum;
                int num2Remove = nums[i - k + 1];
                sum -= decreaseFreq(ts1, ts2, map, x, num2Remove);
            }
            // System.out.println(""AFTER REMOVE: "" + ts1 + ""\t"" + ts2 + ""\t"" + sum);
        }
        return results;
    }

    private long increaseFreq(TreeSet<NumWithFrequency> ts1, TreeSet<NumWithFrequency> ts2, Map<Integer, NumWithFrequency> map, int x, int num) {
        if (map.containsKey(num)) {
            NumWithFrequency nwf = map.get(num);
            boolean belongToLarge = ts1.contains(nwf);
            if (belongToLarge) ts1.remove(nwf);
            else ts2.remove(nwf);
            nwf.freq++;
            if (belongToLarge) {
                ts1.add(nwf);
                return num;
            }
            if (ts1.last().compareTo(nwf) < 0) {
                NumWithFrequency nwf2Down = ts1.last();
                ts1.remove(nwf2Down);
                ts1.add(nwf);
                ts2.add(nwf2Down);
                return nwf.getSum() - nwf2Down.getSum();
            }
            ts2.add(nwf);
            return 0L;
        }
        NumWithFrequency nwf = new NumWithFrequency(num, 1);
        map.put(num, nwf);
        if (ts1.size() < x) {
            ts1.add(nwf);
            return num;
        }
        if (ts1.last().compareTo(nwf) < 0) {
            NumWithFrequency nwf2Down = ts1.last();
            ts1.remove(nwf2Down);
            ts1.add(nwf);
            ts2.add(nwf2Down);
            return nwf.getSum() - nwf2Down.getSum();
        }
        ts2.add(nwf);
        return 0L;
    }

    private long decreaseFreq(TreeSet<NumWithFrequency> ts1, TreeSet<NumWithFrequency> ts2, Map<Integer, NumWithFrequency> map, int x, int num) {
        NumWithFrequency nwf = map.get(num);
        boolean belongToLarge = ts1.contains(nwf);
        if (belongToLarge) ts1.remove(nwf);
        else ts2.remove(nwf);
        nwf.freq--;
        if (nwf.freq == 0) {
            map.remove(num);
            if (belongToLarge) {
                if (!ts2.isEmpty()) {
                    NumWithFrequency nwf2Up = ts2.first();
                    ts2.remove(nwf2Up);
                    ts2.add(nwf);
                    ts1.add(nwf2Up);
                    return num - nwf2Up.getSum();
                }
                return num;
            }
            return 0L;
        }
        if (!belongToLarge) {
            ts2.add(nwf);
            return 0L;
        }
        if (!ts2.isEmpty() && ts2.first().compareTo(nwf) > 0) {
            NumWithFrequency nwf2Up = ts2.first();
            ts2.remove(nwf2Up);
            ts2.add(nwf);
            ts1.add(nwf2Up);
            return nwf.getSum() + num - nwf2Up.getSum();
        }
        ts1.add(nwf);
        return num;
    }
}

class NumWithFrequency {
    int num, freq;
    NumWithFrequency(int num, int freq) {
        this.num = num;
        this.freq = freq;
    }

    long getSum() {
        return ((long) num) * freq;
    }

    int compareTo(NumWithFrequency other) {
        if (this.equals(other)) return 0;
        if (this.freq == other.freq) return this.num - other.num;
        return this.freq - other.freq;
    }

    @Override
    public int hashCode() {
        int h = 17;
        h = h * 31 + num;
        h = h * 31 + freq;
        return h;
    }

    @Override
    public boolean equals(Object other) {
        NumWithFrequency o = (NumWithFrequency) other;
        return this.num == o.num && this.freq == o.freq;
    }

    @Override
    public String toString() {
        return String.format(""(num=%d, freq=%d)"", num, freq);
    }
}",1420614925
JerryWzc,JerryWzc,341,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        TreeSet<NumWithFrequency> ts = new TreeSet<>((a, b) -> {
            if (a.freq == b.freq) return b.num - a.num;
            return b.freq - a.freq;
        });
        Map<Integer, NumWithFrequency> map = new HashMap<>();
        int n = nums.length;
        int[] results = new int[n - k + 1];
        for (int i = 0; i < k - 1; i++) {
            int num = nums[i];
            if (map.containsKey(num)) map.get(num).freq++;
            else map.put(num, new NumWithFrequency(num, 1));
        }
        ts.addAll(map.values());
        for (int i = 0; i < n - k + 1; i++) {
            int num = nums[i + k - 1];
            if (map.containsKey(num)) {
                NumWithFrequency nwf = map.get(num);
                ts.remove(nwf);
                nwf.freq++;
                ts.add(nwf);
            } else {
                NumWithFrequency nwf = new NumWithFrequency(num, 1);
                map.put(num, nwf);
                ts.add(nwf);
            }

            int xx = x, sum = 0;
            Iterator<NumWithFrequency> iter = ts.iterator();
            while (iter.hasNext() && xx > 0) {
                NumWithFrequency nwf = iter.next();
                xx--;
                sum += nwf.num * nwf.freq;
            }
            results[i] = sum;

            int num2Remove = nums[i];
            NumWithFrequency nwf = map.get(num2Remove);
            ts.remove(nwf);
            nwf.freq--;
            ts.add(nwf);
        }
        return results;
    }
    
}

class NumWithFrequency {
    int num, freq;
    NumWithFrequency(int num, int freq) {
        this.num = num;
        this.freq = freq;
    }

    @Override
    public int hashCode() {
        int h = 17;
        h = h * 31 + num;
        h = h * 31 + freq;
        return h;
    }

    @Override
    public boolean equals(Object other) {
        NumWithFrequency o = (NumWithFrequency) other;
        return this.num == o.num && this.freq == o.freq;
    }
}",1420534360
Andrew H. Pometta,apometta,343,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def get_data(root):
            nonlocal sizes
            #return value is (is_perfect, depth, size)
            if root == None: return (True, 0, 0)
            
            l, r = get_data(root.left), get_data(root.right)
            size, depth = l[2] + r[2] + 1, max(l[1], r[1]) + 1

            if l[0] and r[0] and l[1] == r[1]:
                sizes.append(size)
                return (True, depth, size)
            else:
                return (False, depth, size)
        
        get_data(root)
        sizes.sort(reverse = True)
        return sizes[k - 1] if len(sizes) >= k else -1",1420528596
Andrew H. Pometta,apometta,343,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        using pint = pair<int,int>;
        set<pint> non_x, yes_x;
        unordered_map<int,int> counts;
        counts.reserve(k + 1);
        long long s = 0;
        vector<long long> ans;
        ans.reserve(n - k + 1);
        int l = 0, r = 0;

        while (r < k) {
            s += nums[r];
            counts[nums[r]]++;
            r++;
        }

        for (pair<int,int> p : counts) yes_x.insert({p.second, p.first});
        while (yes_x.size() > x) {
            pint r = *(yes_x.begin());
            s -= r.first * (long long) r.second;
            non_x.insert(r);
            yes_x.erase(yes_x.begin());
        }
        ans.push_back(s);

        while (r < n) {
            if (nums[l] == nums[r]) { //no change
                ans.push_back(s);
                l++; r++;
                continue;
            }
            //nums[l] != nums[r]
            int l_c = counts[nums[l]], r_c = counts[nums[r]];
            pint l_p = {l_c, nums[l]}, r_p = {r_c, nums[r]};

            if (non_x.contains(l_p)) {
                non_x.erase(l_p);
                if (l_c > 1) non_x.insert({l_c - 1, nums[l]});
            } else {
                yes_x.erase(l_p);
                s -= nums[l];
                if (l_c > 1) yes_x.insert({l_c - 1, nums[l]});
            }
            if (non_x.contains(r_p) || counts[nums[r]] == 0) {
                non_x.erase(r_p);
                non_x.insert({r_c + 1, nums[r]});
            } else {
                yes_x.erase(r_p);
                s += nums[r];
                yes_x.insert({r_c + 1, nums[r]});
            }
            counts[nums[l]]--;
            counts[nums[r]]++;

            while (yes_x.size() < x && !non_x.empty()) {
                l_p = *(non_x.rbegin());
                s += l_p.first * (long long) l_p.second;
                non_x.erase(l_p);
                yes_x.insert(l_p);
            }
            while (!non_x.empty() && *(non_x.rbegin()) > *(yes_x.begin())) {
                l_p = *(non_x.rbegin());
                r_p = *(yes_x.begin());
                s -= r_p.first * (long long) r_p.second;
                s += l_p.first * (long long) l_p.second;
                yes_x.erase(yes_x.begin());
                non_x.erase(prev(non_x.end()));
                yes_x.insert(l_p);
                non_x.insert(r_p);
            }

            ans.push_back(s);
            l++; r++;
        }

        return ans;
    }
};",1420616257
Andrew H. Pometta,apometta,343,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        for i in range(len(nums) - k + 1):
            counts = Counter(nums[i:i + k])
            vals = sorted([(counts[i], i) for i in counts], reverse = True)
            s = 0
            for a, b in vals[:x]:
                s += a * b
            ans.append(s)
        return ans",1420565443
Jason Zavaglia,jpz,345,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        d = defaultdict(None)
        depths = []
        def perfect_depth(node):
            if node in d:
                return d[node]
            if node == None:
                result = 0
            else:
                resultl = perfect_depth(node.left)
                resultr = perfect_depth(node.right)
                if resultl != resultr:
                    result = -1
                else:
                    result = resultl + resultr + 1
            d[node] = result
            depths.append(result)
            return result
        perfect_depth(root)
        depths.sort(reverse=True)
        print(depths)
        if k <= len(depths):
            result = depths[k-1]
            if result == 0:
                return -1
            else:
                return result
        else:
            return -1

",1420561116
Jason Zavaglia,jpz,345,3592,python3,"
from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        counts = Counter(nums[:k])
        # zero other entries
        for n in nums:
            counts[n] = counts[n]
        
        # pad the frequency list with more zeros, helps with maths below
        top = max(nums) + 1
        for i in range(x - len(counts)+5):
            counts[top] = 0
            top += 1

        l = SortedList(key=lambda x: (-x[0], -x[1]))
        for num, count in counts.items():
            l.add((count, num))
        
        total = 0
        for i in range(x):
            count, value = l[i]
            total += count * value
        
        print(l)
        result.append(total)
        
        for i in range(1, len(nums)-k+1):
            addval = nums[i+k-1]
            subval = nums[i-1]
            if addval == subval:
                result.append(result[-1])
                continue
            addval_old_freq = counts[addval]
            subval_old_freq = counts[subval]
            old_xth_val = l[x-1]
            old_xth_val_plus_one = l[x]

            # print(f""f adding {addval} / {subval}"")
            # print(f""f old_xth_val {old_xth_val}"")

            if old_xth_val <= (addval_old_freq, addval):
                # print(f""subtract1 {(addval_old_freq, addval)}"")
                total -= addval * addval_old_freq
            if old_xth_val <= (subval_old_freq, subval):
                # print(f""subtract2 {(subval_old_freq, subval)}"")
                total -= subval * subval_old_freq

            counts[addval] += 1
            counts[subval] -= 1
            l.remove((addval_old_freq, addval))
            l.remove((subval_old_freq, subval))
            l.add((addval_old_freq+1, addval))
            l.add((subval_old_freq-1, subval))

            if l[x-1] <= (addval_old_freq+1, addval):
                # print(f""add1 {(addval_old_freq+1, addval)}"")
                total += addval * (addval_old_freq+1)
            if l[x-1] <= (subval_old_freq-1, subval):
                # print(f""add1 {(subval_old_freq-1, subval)}"")
                total += subval * (subval_old_freq-1)

            new_xth_val = l[x-1]
            new_xth_val_plus_one = l[x]
            if new_xth_val[1] not in (addval, subval) and new_xth_val[1] == old_xth_val_plus_one[1]:
                total += new_xth_val[0] * new_xth_val[1]
            if old_xth_val[1] not in (addval, subval) and old_xth_val[1] == new_xth_val_plus_one[1]:
                total -= new_xth_val_plus_one[0] * new_xth_val_plus_one[1]

            result.append(total)
        
        return result",1420617004
Jason Zavaglia,jpz,345,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        for i in range(0, len(nums)-k+1):
            nnn = nums[i:i+k]
            counts = Counter(nnn)
            l = sorted([(x, y) for y, x in counts.items()], reverse = True)
            if len(l) > x:
                l = l[:x]
            f = set([num for cnt, num in l])
            s = sum([x for x in nnn if x in f])
            result.append(s)

        return result
   ",1420533264
Ojas Phirke,ojasphirke,346,3509,cpp,"
// struct TreeNode {
//     int val;
//     TreeNode* left;
//     TreeNode* right;
//     TreeNode() : val(0), left(nullptr), right(nullptr) {}
//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
//     TreeNode(int x, TreeNode* left, TreeNode* right)
//         : val(x), left(left), right(right) {}
// };

class Solution {
    pair<bool, int> helper(TreeNode* curr, vector<int>& sizes) {
        if (!curr) {
            return {false, 0};
        }

        if (!curr->left && !curr->right) {
            sizes.push_back(1);
            return {true, 1};
        }

        auto [lb, ls] = helper(curr->left, sizes);
        auto [rb, rs] = helper(curr->right, sizes);

        if (lb && rb && ls == rs) {
            int size = ls * 2 + 1;
            sizes.push_back(size);
            return {true, size};
        }
        else {
            return {false, 0};
        }
    }

public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes {};
        helper(root, sizes);

        ranges::sort(sizes);

        if (sizes.size() < k) {
            return -1;
        }

        return sizes[sizes.size() - k];
    }
};",1420617988
Ojas Phirke,ojasphirke,346,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        typedef long long ll;

        set<pair<ll, ll>, less<pair<ll, ll>>> top{};
        set<pair<ll, ll>, greater<pair<ll, ll>>> bot{};
        unordered_map<ll, ll> counts{};
        vector<ll> ans{};
        ll n = nums.size();
        ll run = 0;

        auto helper_check_swap = [=, &top, &bot, &counts, &run] {
            // if bot is empty, we dont do anything
            if (bot.empty()) {
                return;
            }

            // chheck if top is not full
            if (top.size() < x) {
                auto bot_elem = *bot.begin();
                bot.erase(bot_elem);
                top.insert(bot_elem);
                run += bot_elem.first * bot_elem.second;
                return;
            }

            // check if we need to update top
            if (*bot.begin() > *top.begin()) {
                auto bot_elem = *bot.begin();
                auto top_elem = *top.begin();

                bot.erase(bot_elem);
                top.erase(top_elem);
                run -= top_elem.first * top_elem.second;

                bot.insert(top_elem);
                top.insert(bot_elem);
                run += bot_elem.first * bot_elem.second;
                return;
            }
        };

        auto helper_add = [=, &top, &bot, &counts, &run](int val) {
            ll c = counts[val];

            pair<ll, ll> elem{c, val};
            pair<ll, ll> new_elem{c + 1, val};

            // in top
            if (top.contains(elem)) {
                top.erase(elem);
                top.insert(new_elem);
                run += val;
            }

            // in bottom
            else {
                if (bot.contains(elem)) {
                    bot.erase(elem);
                }
                bot.insert(new_elem);

                helper_check_swap();
            }

            counts[val] = c + 1;
        };

        auto helper_remove = [=, &top, &bot, &counts, &run](int val) {
            ll c = counts[val];

            pair<ll, ll> elem{c, val};
            pair<ll, ll> new_elem{c - 1, val};

            // in bottom
            if (bot.contains(elem)) {
                bot.erase(elem);
                bot.insert(new_elem);
            }

            // in top
            else {
                top.erase(elem);
                top.insert(new_elem);
                run -= val;
                helper_check_swap();
            }

            counts[val] = c - 1;
        };

        // init
        for (int i = 0; i < k - 1; i++) {
            helper_add(nums[i]);
        }

        // calc
        for (int i = k - 1; i < n; i++) {
            helper_add(nums[i]);
            if (i - k >= 0) {
                helper_remove(nums[i - k]);
            }

            // for (auto [c, v] : top) {
            //     cout << c << "" "" << v << endl;
            // }
            // cout << "" ================== "" << endl;
            // for (auto [c, v] : bot) {
            //     cout << c << "" "" << v << endl;
            // }
            // cout << endl;

            ans.push_back(run);
        }

        return ans;
    }
};",1420604486
Ojas Phirke,ojasphirke,346,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        for i in range(len(nums) - k + 1):
            c = Counter(sorted(nums[i:i+k], reverse=True))
            common = c.most_common(x)
            ans.append(sum(a[0]*a[1] for a in common))
        return ans
",1420527467
Yiping,kookaburracc,347,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def dfs(node):
            if node.left == node.right == None:
                sizes.append(1)
                return 1

            left = right = -1
            if node.left:
                left = dfs(node.left)
            if node.right:
                right = dfs(node.right)


            if left == -1 or right == -1 or left != right:
                return -1
            else:
                size = left * 2 + 1
                sizes.append(size)
                return size

        dfs(root)
        # print(sizes)
        if len(sizes) < k:
            # print(""dye"")
            return -1

        sizes.sort(reverse=True)


        return sizes[k - 1]
        ",1420543575
Yiping,kookaburracc,347,3592,python3,"from sortedcontainers import SortedList

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        sl = SortedList([(0, 0)] * x)
        window = nums[:k]
        c = defaultdict(int, Counter(window))
        for n, f in c.items():
            sl.add((f, n))
            # sl.add((f * 10000 + n, f * n))
        
        s = 0
        for f, n in sl[-x:]:
            s += f * n

        print(sl)
        result = [s]
        for end in range(k, len(nums)):
            v_remove, v_new = nums[end - k], nums[end]
            if v_remove == v_new:
                result.append(s)
                continue
            
            # remove
            t = (c[v_remove], v_remove)
            if sl.bisect_left(t) >= len(sl) - x:
                # print(""A1"", s)
                s -= t[0] * t[1]
                t1 = sl[-x - 1]
                s += t1[0] * t1[1]
                # print(""A2"", s)
            
            sl.discard(t)
            c[v_remove] -= 1
            t = (c[v_remove], v_remove)
            sl.add(t)
            if sl.bisect_left(t) >= len(sl) - x:
                # print(""A3"", s)
                s += t[0] * t[1]
                t1 = sl[-x - 1]
                s -= t1[0] * t1[1]
                # print(""A4"", s)

            # new
            t = (c[v_new], v_new)
            if sl.bisect_left(t) >= len(sl) - x:
                # print(""A5"", s)
                s -= t[0] * t[1]
                t1 = sl[-x - 1]
                s += t1[0] * t1[1]
                # print(""A6"", s)
            
            sl.discard(t)
            c[v_new] += 1
            t = (c[v_new], v_new)
            sl.add(t)
            if sl.bisect_left(t) >= len(sl) - x:
                # print(""A7"", s)
                s += t[0] * t[1]
                t1 = sl[-x - 1]
                s -= t1[0] * t1[1]
                # print(""A8"", s)

            # print(sl)
            result.append(s)

        return result",1420618053
Yiping,kookaburracc,347,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        for pos in range(0, len(nums) - k + 1):
            sub = nums[pos:pos + k]
            c = Counter(sub)
            if len(c) <= x:
                result.append(sum(sub))
                continue

            freq = {}
            for key, value in c.items():
                if value not in freq:
                    freq[value] = [key]
                else:
                    freq[value].append(key)
                    freq[value].sort()

            a = []
            for key in sorted(freq.keys()):
                for v in freq[key]:
                    a.append((key, v))

            # print(a)
            s = 0
            for _ in range(x):
                i, j = a.pop()
                s += i * j
            
            result.append(s)


        return result",1420531470
aal_baal_sub,aal_baal_sub,348,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> f(TreeNode* root, vector<int> &temp, int level)
    {
        if(!root->left && !root->right)
        {
            temp.push_back(1);
            return {true, level, 1};
        }
        if(!root->left)
        {
            auto right = f(root->right, temp, level+1);
            return {false, level, 1};
        }
        if(!root->right)
        {
            auto left = f(root->left, temp, level+1);
            return {false, level, 1};
        }
        
        vector<int> left = f(root->left, temp, level+1);
        vector<int> right = f(root->right, temp, level+1);
        
        if(!left[0] || !right[0]) return {false, level, 1};
        if(left[1] != right[1]) return {false, level, 1};
        
        temp.push_back(left[2]+right[2]+1);
        return {true, left[1], left[2]+right[2]+1};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> temp;
        f(root, temp, 0);
        sort(temp.begin(), temp.end(), greater<int>());
        if(k > temp.size()) return -1;
        return temp[k-1];
    }
};",1420562144
aal_baal_sub,aal_baal_sub,348,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<long long> ans;
        set<pair<int, int>> st1, st2;
        unordered_map<int, int> m;
        for(int i=0; i<k; i++)
        {
            m[nums[i]]++;
        }
        vector<pair<int, int>> temp;
        for(auto i: m) temp.push_back({i.second, i.first});
        sort(temp.begin(), temp.end(), greater<pair<int, int>>());
        
        int i = 0;
        long long sum = 0;
        for(; i<temp.size() && i<x; i++)
        {
            sum += 1ll* temp[i].second * temp[i].first;
            st1.insert(temp[i]);
        }
        for(; i<temp.size(); i++)
        {
            st2.insert(temp[i]);
        }
        ans.push_back(sum);
        
        for(int i=k; i<n; i++)
        {
            int num = nums[i-k];
            int prevVal = m[num];
            m[num]--;
            if(st1.count({prevVal, num}))
            {
                sum -= num;
                st1.erase({prevVal, num});
                st1.insert({prevVal-1, num});
                
                if(!st2.empty())
                {
                    auto a1 = *st1.begin();
                    auto a2 = *st2.rbegin();
                    if(a2.first > a1.first || (a2.first == a1.first && a2.second > a1.second))
                    {
                        st1.erase(a1);
                        st2.erase(a2);
                        sum -= 1ll*a1.first*a1.second;
                        st1.insert(a2);
                        st2.insert(a1);
                        sum += 1ll*a2.first * a2.second;
                    }    
                }
            }
            else
            {
                st2.erase({prevVal, num});
                st2.insert({prevVal-1, num});
            }
            
            num = nums[i];
            prevVal = m[num];
            m[num]++;
            if(st1.count({prevVal, num}))
            {
                sum += num;
                st1.erase({prevVal, num});
                st1.insert({prevVal+1, num});
            }
            else if(st2.count({prevVal, num}))
            {
                st2.erase({prevVal, num});
                st2.insert({prevVal+1, num});
                
                auto a1 = *st1.begin();
                auto a2 = *st2.rbegin();
                if(a2.first > a1.first || (a2.first == a1.first && a2.second > a1.second))
                {
                    st1.erase(a1);
                    st2.erase(a2);
                    sum -= 1ll*a1.first*a1.second;
                    st1.insert(a2);
                    st2.insert(a1);
                    sum += 1ll*a2.first * a2.second;
                }
            }
            else
            {
                if(st1.size() < x)
                {
                    st1.insert({{prevVal+1, num}});
                    sum += num;
                }
                else
                {
                    st2.insert({prevVal+1, num});
                
                    auto a1 = *st1.begin();
                    auto a2 = *st2.rbegin();
                    if(a2.first > a1.first || (a2.first == a1.first && a2.second > a1.second))
                    {
                        st1.erase(a1);
                        st2.erase(a2);
                        sum -= 1ll*a1.first*a1.second;
                        st1.insert(a2);
                        st2.insert(a1);
                        sum += 1ll*a2.first * a2.second;
                    }
                }
            }
            
            ans.push_back(sum);
        }
        
        return ans;
    }
};",1420619592
aal_baal_sub,aal_baal_sub,348,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0; i<n-k+1; i++)
        {   
            unordered_map<int, int> m;
            for(int j=i; j<i+k; j++)
            {
                m[nums[j]]++;
            }
            vector<pair<int, int>> temp;
            for(auto j: m)
            {
                temp.push_back({j.second, j.first});
            }
            sort(temp.begin(), temp.end(), greater<pair<int, int>>());
            int sum = 0;
            for(int j=0; j<temp.size() && j<x; j++)
            {
                sum += temp[j].second*temp[j].first;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420532396
sai kiran,p_saikiran,349,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // {isPerfect, nodesCnt}
    pair<int,int> dfs(TreeNode* root, vector<int>& v) {
        if(root==NULL) return {1,0};
        pair<int,int> l = dfs(root->left, v);
        pair<int,int> r = dfs(root->right, v);
        if(l.first==1 && r.first==1 && l.second == r.second) {
            v.push_back(2*l.second + 1);
            return {1, 2*l.second + 1};
        }
        return {0,0};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> v;
        dfs(root, v);
        sort(v.begin(), v.end());
        reverse(v.begin(), v.end());
        return k<=v.size() ? v[k-1] : -1;
    }
};",1420608818
sai kiran,p_saikiran,349,3592,cpp,"typedef pair<long long, long long> pi; 
class Solution {
public:

    void printS(set<pi>& s) {
        for(auto itr: s) {
            cout<<itr.first<<"":""<<itr.second<<"" "";
        }
        cout<<endl;
    }

    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<long long, long long> m;
        set<pi> maxh, minh;
        long long n=nums.size(), sum=0;
        vector<long long> sol;
        for(int i=0; i<n; i++) {
            if(i>=k) {
                int idx=i-k;
                pi tmp = {m[nums[idx]], nums[idx]};
                if(minh.find( tmp ) != minh.end()) {
                    minh.erase( tmp );
                    sum-=(long long)nums[idx]*m[nums[idx]];
                    m[nums[idx]]--;
                    auto maxH_L = maxh.rbegin();
                    if(maxh.size()!=0 && (maxH_L->first>m[nums[idx]] || (maxH_L->first==m[nums[idx]] && nums[idx]<maxH_L->second))) {
                        sum+=maxH_L->first * maxH_L->second;
                        minh.insert( *maxH_L );
                        maxh.erase( *maxH_L );
                        if(m[nums[idx]]!=0)maxh.insert( {m[nums[idx]], nums[idx]} );
                    } else if(m[nums[idx]]!=0) {
                        sum+=(long long)nums[idx]*m[nums[idx]];
                        minh.insert( {m[nums[idx]], nums[idx]} );
                    }
                }
                if(maxh.find( tmp ) != maxh.end()) {
                    maxh.erase( tmp );
                    m[nums[idx]]--;
                    if(m[nums[idx]]!=0)maxh.insert( {m[nums[idx]], nums[idx]} );
                }
            }

            if(maxh.find( {m[nums[i]], nums[i]} ) != maxh.end()) {
                maxh.erase( {m[nums[i]], nums[i]} );
                m[nums[i]]++;

                pi small = *minh.begin();
                if(small.first<m[nums[i]] || (small.first==m[nums[i]] && nums[i]>small.second)) {
                    minh.erase( small );
                    sum -= small.second * small.first;
                    sum+=(long long)nums[i]*m[nums[i]];
                    minh.insert( {m[nums[i]], nums[i]} );
                    maxh.insert( small );

                } else {
                    maxh.insert( {m[nums[i]], nums[i]} );
                }
            } else if(minh.find( {m[nums[i]], nums[i]} ) != minh.end()) {
                minh.erase( {m[nums[i]], nums[i]} );
                m[nums[i]]++;
                sum+=nums[i];
                minh.insert( {m[nums[i]], nums[i]} );
            } else if(minh.size()<x) {
                m[nums[i]]++;
                sum+=nums[i];
                minh.insert( {m[nums[i]], nums[i]} );
            } else {
                m[nums[i]]++;

                pi small = *minh.begin();
                if(small.first<m[nums[i]] || (small.first==m[nums[i]] && nums[i]>small.second)) {
                    minh.erase( small );
                    sum -= small.second * small.first;
                    sum+=(long long)nums[i]*m[nums[i]];
                    minh.insert( {m[nums[i]], nums[i]} );
                    maxh.insert( small );

                } else {
                    maxh.insert( {m[nums[i]], nums[i]} );
                }
            }

            // cout<<i<<"" ""<<nums[i]<<"":::\n"";
            // printS(minh);
            // printS(maxh);

            if(i>=k-1)sol.push_back(sum);
        }
        return sol;
    }
};",1420598829
sai kiran,p_saikiran,349,3610,cpp,"typedef pair<int, int> pi; 
class Solution {
public:

    void printS(set<pi>& s) {
        for(auto itr: s) {
            cout<<itr.first<<"":""<<itr.second<<"" "";
        }
        cout<<endl;
    }

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> m;
        set<pi> maxh, minh;
        int n=nums.size(), sum=0;
        vector<int> sol;
        for(int i=0; i<n; i++) {
            if(i>=k) {
                int idx=i-k;
                pi tmp = {m[nums[idx]], nums[idx]};
                if(minh.find( tmp ) != minh.end()) {
                    minh.erase( tmp );
                    sum-=nums[idx]*m[nums[idx]];
                    m[nums[idx]]--;
                    auto maxH_L = maxh.rbegin();
                    if(maxh.size()!=0 && (maxH_L->first>m[nums[idx]] || (maxH_L->first==m[nums[idx]] && nums[idx]<maxH_L->second))) {
                        sum+=maxH_L->first * maxH_L->second;
                        minh.insert( *maxH_L );
                        maxh.erase( *maxH_L );
                        if(m[nums[idx]]!=0)maxh.insert( {m[nums[idx]], nums[idx]} );
                    } else if(m[nums[idx]]!=0) {
                        sum+=nums[idx]*m[nums[idx]];
                        minh.insert( {m[nums[idx]], nums[idx]} );
                    }
                }
                if(maxh.find( tmp ) != maxh.end()) {
                    maxh.erase( tmp );
                    m[nums[idx]]--;
                    if(m[nums[idx]]!=0)maxh.insert( {m[nums[idx]], nums[idx]} );
                }
            }

            if(maxh.find( {m[nums[i]], nums[i]} ) != maxh.end()) {
                maxh.erase( {m[nums[i]], nums[i]} );
                m[nums[i]]++;

                pi small = *minh.begin();
                if(small.first<m[nums[i]] || (small.first==m[nums[i]] && nums[i]>small.second)) {
                    minh.erase( small );
                    sum -= small.second * small.first;
                    sum+=nums[i]*m[nums[i]];
                    minh.insert( {m[nums[i]], nums[i]} );
                    maxh.insert( small );

                } else {
                    maxh.insert( {m[nums[i]], nums[i]} );
                }
            } else if(minh.find( {m[nums[i]], nums[i]} ) != minh.end()) {
                minh.erase( {m[nums[i]], nums[i]} );
                m[nums[i]]++;
                sum+=nums[i];
                minh.insert( {m[nums[i]], nums[i]} );
            } else if(minh.size()<x) {
                m[nums[i]]++;
                sum+=nums[i];
                minh.insert( {m[nums[i]], nums[i]} );
            } else {
                m[nums[i]]++;

                pi small = *minh.begin();
                if(small.first<m[nums[i]] || (small.first==m[nums[i]] && nums[i]>small.second)) {
                    minh.erase( small );
                    sum -= small.second * small.first;
                    sum+=nums[i]*m[nums[i]];
                    minh.insert( {m[nums[i]], nums[i]} );
                    maxh.insert( small );

                } else {
                    maxh.insert( {m[nums[i]], nums[i]} );
                }
            }

            // cout<<i<<"" ""<<nums[i]<<"":::\n"";
            // printS(minh);
            // printS(maxh);

            if(i>=k-1)sol.push_back(sum);
        }
        return sol;
    }
};",1420595091
Code_Fire,Code_Fire,350,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int bt(TreeNode* root, vector<int> &ans)
    {
        if(!root)
        {
            return 0;
        }
        int x = bt(root->left, ans);
        int y = bt(root->right, ans);
      
        if(x == y && x!=-1)
        {
            int m = (1 <<(x+1))-1;
            ans.push_back(m);
            return x+1;
        }
        return -1;

    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;
        bt(root, ans);
        sort(ans.begin(), ans.end(), greater<int>());
        if(k<= ans.size()){
        return ans[k-1];
        }
        return -1;
    }
};",1420555531
Code_Fire,Code_Fire,350,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        map<long long, long long> occ;  // Track occurrences of each element
        multiset<pair<long long, long long>, greater<pair<long long, long long>>> topElements;  // Store top `x` elements
        multiset<pair<long long, long long>, greater<pair<long long, long long>>> removedElements;  // Store removed elements
        vector<long long> result;
        long long sum = 0;

        for (int i = 0; i < nums.size(); i++) {
            int currElem = nums[i];

            // Remove previous frequency of `currElem` from `topElements`
            if (occ[currElem] > 0) {
                auto it = topElements.find({occ[currElem], currElem});
                if (it != topElements.end()) {
                    topElements.erase(it);
                    sum -= occ[currElem] * currElem;
                } 
            }
               removedElements.erase({occ[currElem], currElem});
            
          
            occ[currElem]++;
            topElements.insert({occ[currElem], currElem});
        
            sum +=  occ[currElem]*currElem;

            if (topElements.size() > x) {
                auto last = prev(topElements.end());
                sum -= last->first * last->second;
                removedElements.insert(*last);  // Track removal
                topElements.erase(last);
            }

            if (i >= k - 1) {
              
                result.push_back(sum);

                
                int leftElem = nums[i - k + 1];
                occ[leftElem]--;
                auto it = topElements.find({occ[leftElem]+1, leftElem});
                if (it != topElements.end()) {
                    topElements.erase(it);
                    sum -= (occ[leftElem]+1) * leftElem;
                } 
                auto it2 = removedElements.find({occ[leftElem]+1, leftElem});
                if(it2 != removedElements.end())
                {
                    removedElements.erase(it2);
                }
                if(occ[leftElem]>0){
                removedElements.insert({occ[leftElem], leftElem});
                }



          

 
                if (topElements.size() < x && !removedElements.empty()) {
                    auto restore = *removedElements.begin();
                    removedElements.erase(removedElements.begin());
                    topElements.insert(restore);
                    sum += restore.first * restore.second;
                }

                
            }
        }

        return result;
    }
};
",1420616571
Code_Fire,Code_Fire,350,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        map<int, int> occ;
        vector<int> ans;
        int sum = 0;

        for (int i = 0; i < nums.size(); i++) {
            occ[nums[i]]++;

            if (i >= k - 1) {
                vector<pair<int, int>> xy;
                for(auto it: occ)
                {
                    xy.push_back({it.second, it.first});
                }
                sort(xy.begin(), xy.end(), greater<pair<int, int>>());

                sum = 0;
                for (int j = 0; j < min((int)xy.size(), x); j++) {
                    
                    sum += xy[j].first * xy[j].second;
                }

                ans.push_back(sum);
                occ[nums[i - k + 1]]--;

                if (occ[nums[i - k + 1]] == 0) {
                    occ.erase(nums[i - k + 1]);
                }
            }
        }
        return ans;
    }
};
",1420531072
Nisarg Shah,nisargss97,351,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int height(TreeNode* node)
    {
        if (node == nullptr) return 0;
        return 1+max(height(node->left), height(node->right));
    }

    pair<bool, int> perfect(TreeNode* node, vector<int> &perfects)
    {
        if (node == nullptr) return {true, 0};
        int leftHeight = height(node->left);
        int rightHeight = height(node->right);
        auto l = perfect(node->left, perfects);
        auto r = perfect(node->right, perfects);
        if (leftHeight == rightHeight && l.first && r.first)
        {
            perfects.push_back(1+l.second+r.second);
            return {true, 1+l.second+r.second};
        }

        return {false, 0};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfects;
        perfect(root, perfects);
        sort(perfects.begin(), perfects.end());
        return k <= perfects.size() ? perfects[perfects.size()-k] : -1;
    }
};",1420568251
Nisarg Shah,nisargss97,351,3592,cpp,"class Solution {
    

public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<int, int> counts;
        map<int, set<int>> freqMap;
        for (int i = 0; i < k; i ++)
        {
            counts[nums[i]]++;
        }
        
        for (auto &kv: counts)
        {
            freqMap[kv.second].insert(kv.first);
        }

        set<pair<int, int>> right;
        set<pair<int, int>> left;
        int curCount = 0;
        auto it = freqMap.rbegin();
        long long curSum = 0;
        while (it != freqMap.rend())
        {
            auto setIt = it->second.rbegin();
            while (setIt != it->second.rend())
            {
                curCount++;
                if (curCount > x){
                    left.insert({it->first, *setIt});
                }
                else
                {
                    right.insert({it->first, *setIt});
                    curSum += ((long long)it->first)*((long long)*setIt);
                }
                setIt++;
            }
            it++;
        }
        vector<long long> result;
        result.push_back(curSum);

        int l = 0, r = k;
        while (r < nums.size())
        {
            if (nums[r] == nums[l]) {
                result.push_back(curSum);
                l++;
                r++;
                continue;
            }
            if (right.find({counts[nums[l]], nums[l]}) != right.end()){
                right.erase({counts[nums[l]], nums[l]});
                curSum-= (long long)nums[l]*(long long)counts[nums[l]];
            }
            if (right.find({counts[nums[r]], nums[r]}) != right.end()){
                right.erase({counts[nums[r]], nums[r]});
                curSum-= (long long)nums[r]*(long long)counts[nums[r]];
            }
            if (left.find({counts[nums[l]], nums[l]}) != left.end()){
                left.erase({counts[nums[l]], nums[l]});
            }
            if (left.find({counts[nums[r]], nums[r]}) != left.end()){
                left.erase({counts[nums[r]], nums[r]});
            }

            vector<pair<int, int>> pairs;
            if (!right.empty()) {
                auto minRight = *right.begin();
                pairs.push_back(minRight);
                curSum -= (long long)minRight.first * (long long)minRight.second;
                right.erase(right.begin());
            }

            if (!left.empty())
            {
                auto maxLeft = *left.rbegin();
                pairs.push_back(maxLeft);
                left.erase(maxLeft);
            }

            counts[nums[l]]--;
            if (counts[nums[l]] != 0) pairs.push_back({counts[nums[l]], nums[l]});
            counts[nums[r]]++;
            pairs.push_back({counts[nums[r]], nums[r]});
            sort(pairs.begin(), pairs.end());
            int newValues = x-right.size();
            for (int i = pairs.size()-1; i >= 0; i--)
            {
                if (pairs.size()-i <= newValues)
                {
                    right.insert(pairs[i]);
                    curSum += (long long)pairs[i].first * (long long)pairs[i].second;
                }
                else
                {
                    left.insert(pairs[i]);
                }
            }
            result.push_back(curSum);
            l++;
            r++;
        }
        /*
        result.push_back(getSum(counts, freqMap, x));
        int l = 0, r = k;
        while (r < nums.size())
        {
            if (nums[r] == nums[l]) {
                result.push_back(result[result.size()-1]);
                l++;
                r++;
                continue;
            }
            if (freqMap.find(counts[nums[r]]) != freqMap.end()) freqMap[counts[nums[r]]].erase(nums[r]);
            counts[nums[r]]++;
            freqMap[counts[nums[r]]].insert(nums[r]);
            if (freqMap.find(counts[nums[l]]) != freqMap.end()) freqMap[counts[nums[l]]].erase(nums[l]);
            counts[nums[l]]--;
            freqMap[counts[nums[l]]].insert(nums[l]);
            result.push_back(getSum(counts, freqMap, x));
            r++;
            l++;
        }
        */
        return result;
    }
};",1420611498
Nisarg Shah,nisargss97,351,3610,cpp,"class Solution {
    int getSum(unordered_map<int, int> &counts, map<int, set<int>> &freqMap, int x)
    {
        auto it = freqMap.rbegin();
        int count = 0;
        int result = 0;
        while (count < x && it != freqMap.rend())
        {
            int freq = it->first;
            for (auto setIt = it->second.rbegin(); setIt != it->second.rend(); setIt++){
                result = result+freq*(*setIt);
                count++;
                if (count == x) break;
            }
            it++;
        }

        return result;

    }
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<int, int> counts;
        map<int, set<int>> freqMap;
        for (int i = 0; i < k; i ++)
        {
            counts[nums[i]]++;
        }
        
        for (auto &kv: counts)
        {
            freqMap[kv.second].insert(kv.first);
        }

        vector<int> result;
        result.push_back(getSum(counts, freqMap, x));
        int l = 0, r = k;
        while (r < nums.size())
        {
            if (freqMap.find(counts[nums[r]]) != freqMap.end()) freqMap[counts[nums[r]]].erase(nums[r]);
            counts[nums[r]]++;
            freqMap[counts[nums[r]]].insert(nums[r]);
            if (freqMap.find(counts[nums[l]]) != freqMap.end()) freqMap[counts[nums[l]]].erase(nums[l]);
            counts[nums[l]]--;
            freqMap[counts[nums[l]]].insert(nums[l]);
            result.push_back(getSum(counts, freqMap, x));
            r++;
            l++;
        }
        return result;
    }
};",1420530003
Narendra Tejasvi,Naruto_Uzamaki,352,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // Helper function to perform post-order traversal and collect perfect subtree sizes
    pair<int, int> dfs(TreeNode* node, vector<int>& sizes) {
        if (!node) return {0, 0}; // {height, size} for null nodes

        auto [leftHeight, leftSize] = dfs(node->left, sizes);
        auto [rightHeight, rightSize] = dfs(node->right, sizes);

        if (leftHeight == rightHeight&&leftSize!=-1&&rightSize!=-1) {
            // Current subtree is perfect, so calculate its size
            int subtreeSize = leftSize + rightSize + 1;
            sizes.push_back(subtreeSize);
            return {leftHeight + 1, subtreeSize};
        } else {
            // Not a perfect subtree, return invalid height and size
            return {max(leftHeight, rightHeight), -1};
        }
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;  // To store the sizes of all perfect subtrees
        dfs(root, sizes);   // Perform DFS to fill the sizes vector

        if (sizes.size() < k) return -1; // If fewer than k perfect subtrees are found

        // Sort sizes in descending order
        sort(sizes.rbegin(), sizes.rend());

        return sizes[k - 1]; // Return the k-th largest size
    }
};
",1420619894
Narendra Tejasvi,Naruto_Uzamaki,352,3592,cpp,"class Solution {
public:
    vector<long long> findXSum(vector<int>& nums, int k, int x) {
        set<pair<int, int>> a, b;
        map<int, int> mp;
        long long curr = 0;
        vector<long long> ans;

        for (int i = 0; i < nums.size(); i++) {
            // Handle sliding window removal when window size exceeds 'k'
            if (i >= k) {
                mp[nums[i - k]]--; // Decrement frequency of the element going out of the window

                // Remove the old frequency from the correct set (a or b)
                if (b.find({mp[nums[i - k]] + 1, nums[i - k]}) != b.end()) {
                    b.erase({mp[nums[i - k]] + 1, nums[i - k]});
                    curr -= nums[i - k];

                    // If frequency is not zero, add the element back with updated frequency
                    if (mp[nums[i - k]] != 0) {
                        b.insert({mp[nums[i - k]], nums[i - k]});
                    }

                    // Ensure 'b' does not exceed size 'x'
                    if (b.size() < x) {
                        if (!a.empty()) {
                            b.insert(*a.rbegin());  // Move largest from 'a' to 'b'
                            curr += (*b.begin()).second;
                            a.erase(prev(a.end())); // Erase largest from 'a'
                        }
                    } else if (!a.empty()) {
                        // Swap elements between 'a' and 'b' if necessary
                        pair<int, int> p = *a.rbegin(); // Largest in 'a'
                        pair<int, int> q = *b.begin();  // Smallest in 'b'
                        a.erase(prev(a.end()));
                        b.erase(b.begin());

                        if (p.first > q.first || (p.first == q.first && p.second > q.second)) {
                            a.insert(q);
                            b.insert(p);
                            curr -= 1ll*q.second*q.first;
                            curr += 1ll*p.second*p.first;
                        } else {
                            a.insert(p);
                            b.insert(q);
                        }
                    }
                } else {
                    // Handle the case when the element was in 'a'
                    a.erase({mp[nums[i - k]] + 1, nums[i - k]});
                    if (mp[nums[i - k]] != 0) {
                        a.insert({mp[nums[i - k]], nums[i - k]});
                    }
                }
                // cout<<curr<<endl;
            }

            // Insert or update the current element in the appropriate set
            if (b.find({mp[nums[i]], nums[i]}) != b.end()) {
                b.erase({mp[nums[i]], nums[i]});
                mp[nums[i]]++;
                b.insert({mp[nums[i]], nums[i]});
                curr += nums[i];
            } else if (a.find({mp[nums[i]], nums[i]}) != a.end()) {
                a.erase({mp[nums[i]], nums[i]});
                mp[nums[i]]++;
                a.insert({mp[nums[i]], nums[i]});
                if(i==7){
                        cout<<""a""<<"" ""<<curr<<endl;;
                    }
                // Swap elements between 'a' and 'b' if needed
                pair<int, int> p = *a.rbegin(); // Largest in 'a'
                pair<int, int> q = *b.begin();  // Smallest in 'b'
                a.erase(prev(a.end()));
                b.erase(b.begin());
                if (p.first > q.first || (p.first == q.first && p.second > q.second)) {
                    a.insert(q);
                    b.insert(p);
                    curr -= 1ll*q.second*q.first;
                    curr += 1ll*p.second*p.first;

                } else {
                    a.insert(p);
                    b.insert(q);
                }
                if (b.size() < x) {
                    // if(i==7){
                    //     cout<<""a""<<"" ""<<curr<<endl;;
                    // }
                    auto largest_in_a = *a.rbegin();  
                    b.insert(largest_in_a); 
                    curr += 1LL * largest_in_a.second * largest_in_a.first; 
                    a.erase(prev(a.end()));  
                }
            } else {
                // Insert new element into 'b' with frequency 1
                b.insert({1, nums[i]});
                mp[nums[i]] = 1;
                curr += nums[i];

                // Ensure 'b' does not exceed size 'x'
                if (b.size() > x) {
                    a.insert(*b.begin());  // Move smallest from 'b' to 'a'
                    curr -= (*b.begin()).second;
                    b.erase(b.begin());
                }
            }

            // If we have reached the window size 'k', add the current sum to the result
            if (i >= k - 1) {
                ans.push_back(curr);
            }

            // Debug output to print the contents of 'b'
            // for (auto j : b) {
            //     cout << j.first << ""$"" << j.second << endl;
            // }
            // cout << endl;
        }

        return ans;
    }
};
",1420607463
Narendra Tejasvi,Naruto_Uzamaki,352,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        map<int, int> freq;  // To store the frequency of elements in the current window
        set<pair<int, int>> a, b; // 'b' will contain the top 'x' most frequent elements

        // Initial window setup
        long long currSum = 0;
        for (int i = 0; i < k; i++) {
            freq[nums[i]]++;
        }

        // Function to update sets 'a' and 'b'
        auto updateSets = [&]() {
            // Clear sets
            a.clear();
            b.clear();
            
            // Add all elements to set based on their frequency and value
            for (auto &[num, count] : freq) {
                if (b.size() < x) {
                    b.insert({count, num});
                } else if (make_pair(count, num) > *b.begin()) {
                    a.insert(*b.begin());
                    b.erase(b.begin());
                    b.insert({count, num});
                } else {
                    a.insert({count, num});
                }
            }
        };
        
        // Calculate x-sum
        auto calculateXSum = [&]() -> int {
            int sum = 0;
            for (auto &p : b) {
                sum += p.second * p.first;
            }
            return sum;
        };

        // Initial setup for the first window
        updateSets();
        ans.push_back(calculateXSum());

        // Sliding window logic
        for (int i = k; i < nums.size(); i++) {
            // Remove the element that is sliding out of the window
            freq[nums[i - k]]--;
            if (freq[nums[i - k]] == 0) {
                freq.erase(nums[i - k]);
            }

            // Add the new element that is entering the window
            freq[nums[i]]++;

            // Update the sets
            updateSets();

            // Calculate the new x-sum for the current window
            ans.push_back(calculateXSum());
        }

        return ans;
    }
};
",1420610610
Rad0miR,Rad0miR,354,3509,csharp,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int KthLargestPerfectSubtree(TreeNode root, int k) 
    {
        List<int> szs = new();
        Dfs(root);
        szs.Sort();
        return szs.Count < k ? -1 : szs[^k];

        int Dfs(TreeNode node) 
        {
            if (node is null) return 0;

            int left  = Dfs(node.left);
            int right = Dfs(node.right);
            
            if (left == right) 
            {
                szs.Add(left + right + 1);
                return left + right + 1;
            } 
            return -1;
        }
    }
}",1420546875
Rad0miR,Rad0miR,354,3592,csharp,"public class Solution {
    private class Container 
    {
        private int _x;
        private Dictionary<int, int> dict = new();
        private SortedSet<(int cnt, int val)> lo = new(), hi = new();
        private long sum = 0;

        public Container(int x) => _x = x;

        public void Add(int val) 
        {
            dict.TryGetValue(val, out int cnt);
            dict[val] = cnt + 1;

            if (cnt == 0) 
            {
                lo.Add((1, val));
            }
            else 
            {
                var key = (cnt, val);
                if (lo.Contains(key)) 
                {
                    lo.Remove(key);
                    lo.Add((cnt + 1, val));
                }
                else 
                {
                    hi.Remove(key);
                    hi.Add((cnt + 1, val));
                    sum += val;
                }
            }

            Balance();
        }

        public void Remove(int val) 
        {
            dict.TryGetValue(val, out int cnt);
            dict[val] = cnt - 1;

            var key = (cnt, val);
            if (lo.Contains(key)) 
            {
                lo.Remove(key);
                lo.Add((cnt - 1, val));
            }
            else 
            {
                hi.Remove(key);
                hi.Add((cnt - 1, val));
                sum -= val;
            }

            Balance();
        }

        private void Balance() 
        {
            if (hi.Count < _x) 
            {
                var p = lo.Max;
                hi.Add(p);
                lo.Remove(p);
                sum += (long)p.cnt * p.val;
                return;
            }

            if (lo.Count == 0) return;

            var min = hi.Min;
            var max = lo.Max;

            if (min.CompareTo(max) > 0) return;

            sum -= (long)min.cnt * min.val;
            sum += (long)max.cnt * max.val;

            lo.Remove(max);
            hi.Remove(min);

            hi.Add(max);
            lo.Add(min);
        }

        public long Get() 
        {
            return sum;
        }
    }
    
    public long[] FindXSum(int[] nums, int k, int x) 
    {
        long[] ans = new long[nums.Length - k + 1];
        Container c = new(x);
        foreach (int val in nums.Take(k - 1)) c.Add(val);

        for (int i = 0; i + k <= nums.Length; ++i) 
        {
            c.Add(nums[i + k - 1]);
            ans[i] = c.Get();
            c.Remove(nums[i]);
        }
        return ans;
    }
}",1420618879
Rad0miR,Rad0miR,354,3610,csharp,"public class Solution {
    private class Container 
    {
        private int _x;
        private Dictionary<int, int> dict = new();
        private SortedSet<(int cnt, int val)> lo = new(), hi = new();
        private long sum = 0;

        public Container(int x) => _x = x;

        public void Add(int val) 
        {
            dict.TryGetValue(val, out int cnt);
            dict[val] = cnt + 1;

            if (cnt == 0) 
            {
                lo.Add((1, val));
            }
            else 
            {
                var key = (cnt, val);
                if (lo.Contains(key)) 
                {
                    lo.Remove(key);
                    lo.Add((cnt + 1, val));
                }
                else 
                {
                    hi.Remove(key);
                    hi.Add((cnt + 1, val));
                    sum += val;
                }
            }

            Balance();
        }

        public void Remove(int val) 
        {
            dict.TryGetValue(val, out int cnt);
            dict[val] = cnt - 1;

            var key = (cnt, val);
            if (lo.Contains(key)) 
            {
                lo.Remove(key);
                lo.Add((cnt - 1, val));
            }
            else 
            {
                hi.Remove(key);
                hi.Add((cnt - 1, val));
                sum -= val;
            }

            Balance();
        }

        private void Balance() 
        {
            if (hi.Count < _x) 
            {
                var p = lo.Max;
                hi.Add(p);
                lo.Remove(p);
                sum += (long)p.cnt * p.val;
                return;
            }

            if (lo.Count == 0) return;

            var min = hi.Min;
            var max = lo.Max;

            if (min.CompareTo(max) > 0) return;

            sum -= (long)min.cnt * min.val;
            sum += (long)max.cnt * max.val;

            lo.Remove(max);
            hi.Remove(min);

            hi.Add(max);
            lo.Add(min);
        }

        public long Get() 
        {
            return sum;
        }
    }

    public int[] FindXSum(int[] nums, int k, int x) {
        int[] ans = new int[nums.Length - k + 1];
        Container c = new(x);
        foreach (int val in nums.Take(k - 1)) c.Add(val);

        for (int i = 0; i + k <= nums.Length; ++i) 
        {
            c.Add(nums[i + k - 1]);
            ans[i] = (int)c.Get();
            c.Remove(nums[i]);
        }
        return ans;
    }
}",1420604615
Delusion1411,Delusion1411,355,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> s;
       
        function<pair<bool, int>(TreeNode*)> f = [&](TreeNode* n) -> pair<bool, int> {
            if (!n) return {true, 0};
            auto [lp, lh] = f(n->left);
            auto [rp, rh] = f(n->right);
            if (lp && rp && lh == rh) {
                int h = lh + 1;
                int sz = (1 << h) - 1;
                s.push_back(sz);
                return {true, h};
            }
            return {false, 0};
        };
        f(root);
        sort(s.begin(), s.end(), greater<int>());
        return (k <= s.size()) ? s[k-1] : -1;
    }
};",1420520005
Delusion1411,Delusion1411,355,3588,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    int countWinningSequences(string s) {
        string l = s;
        int n = l.size();
        const int MOD = 1'000'000'007;

        vector<int> a(n);
        for(int i = 0; i < n; ++i)
            a[i] = (l[i] == 'F') ? 0 : (l[i] == 'W') ? 1 : 2;

        auto out = [&](int b, int am) -> int {
            if((b == 0 && am == 2) || (b == 1 && am == 0) || (b == 2 && am == 1))
                return 1;  
            if((am == 0 && b == 2) || (am == 1 && b == 0) || (am == 2 && b == 1))
                return -1; 
            return 0;      
        };

        vector<vector<long long>> prev(4, vector<long long>(2 * n + 1, 0));
        prev[3][n] = 1; 


        for(int i = 0; i < n; ++i){
            vector<vector<long long>> curr(4, vector<long long>(2 * n + 1, 0));
            for(int last = 0; last < 4; ++last){
                for(int d = -n; d <= n; ++d){
                    if(prev[last][d + n] == 0) continue;
                    for(int m = 0; m < 3; ++m){
                        if(last != 3 && m == last) continue; 
                        int res = out(m, a[i]);
                        int nd = d + res;
                        if(nd < -n || nd > n) continue;
                        curr[m][nd + n] = (curr[m][nd + n] + prev[last][d + n]) % MOD;
                    }
                }
            }
            prev = move(curr); 
        }

       
        long long res = 0;
        for(int last = 0; last < 3; ++last){
            for(int d = 1; d <= n; ++d){
                res = (res + prev[last][d + n]) % MOD;
            }
        }

        return res;
    }
};
",1420523207
Delusion1411,Delusion1411,355,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> res;
        
        for(int i=0;i<=n-k;i++){
            unordered_map<int, int> cnt;
            for(int j=i;j<i+k;j++) cnt[nums[j]]++;
            vector<pair<int, int>> elems;
            for(auto &[num, fr]: cnt) elems.emplace_back(make_pair(-fr, -num));
        
            sort(elems.begin(), elems.end());
            
            
            unordered_map<int, bool> top;
            for(int j=0; j < min(x, (int)elems.size()); j++) {
                top[-elems[j].second] = true;
            }
            
          
            int s=0;
            for(int j=i;j<i+k;j++) if(top[nums[j]]) s += nums[j];
            res.push_back(s);
        }
        
        return res;
    }
};
",1420518512
Samir Kumar Jha,JhaSamirK,356,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#include <vector>
#include <algorithm>
using namespace std;
class Solution {
public:
    // Helper function to perform post-order traversal
    pair<int, bool> getPerfectSubtreeInfo(TreeNode* root, vector<int>& sizes) {
        if (!root) return {0, true};  // An empty tree is perfect with size 0

        // Get info from the left and right subtrees
        auto [leftSize, isLeftPerfect] = getPerfectSubtreeInfo(root->left, sizes);
        auto [rightSize, isRightPerfect] = getPerfectSubtreeInfo(root->right, sizes);

        // Check if the current subtree is perfect
        if (isLeftPerfect && isRightPerfect && leftSize == rightSize) {
            int currSize = leftSize + rightSize + 1;  // Include the current root node
            sizes.push_back(currSize);  // Store the size of the perfect subtree
            return {currSize, true};
        }

        // If not perfect, just return size (but mark as non-perfect)
        return {leftSize + rightSize + 1, false};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;  // Store sizes of all perfect subtrees

        // Perform post-order traversal to collect perfect subtree sizes
        getPerfectSubtreeInfo(root, sizes);

        // Sort sizes in decreasing order
        sort(sizes.begin(), sizes.end(), greater<int>());

        // Check if there are at least k perfect subtrees
        if (k > sizes.size()) return -1;

        // Return the k-th largest size
        return sizes[k - 1];
    }
};
",1420520089
Samir Kumar Jha,JhaSamirK,356,3588,cpp,"#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

const int MOD = 1e9 + 7;

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        // Memoization table: dp[round][prev_move][diff]
        vector<vector<vector<int>>> memo(n + 1, vector<vector<int>>(3, vector<int>(2 * n + 1, -1)));
        int offset = n;  // Offset to handle negative differences in the table
        
        // Start the recursion with no previous move (-1) and zero point difference
        return (dfs(0, -1, 0, s, memo, offset) + MOD) % MOD;
    }

private:
    // Recursive function to calculate the number of winning sequences
    int dfs(int round, int prevMove, int diff, const string &s, vector<vector<vector<int>>> &memo, int offset) {
        int n = s.size();
        if (round == n) {
            // Base case: Check if Bob's points are strictly greater than Alice's
            return diff > 0 ? 1 : 0;
        }

        // Check memoization table
        if (prevMove != -1 && memo[round][prevMove][diff + offset] != -1) {
            return memo[round][prevMove][diff + offset];
        }

        // Alice's current move
        char aliceMove = s[round];
        int totalWays = 0;

        // Try all possible moves for Bob (F = 0, W = 1, E = 2)
        for (int bobMove = 0; bobMove < 3; ++bobMove) {
            if (bobMove == prevMove) continue;  // Skip if the same move as the previous round

            // Calculate the new point difference based on Alice's and Bob's moves
            int newDiff = diff + getPointDiff(aliceMove, bobMove);

            // Recur to the next round
            totalWays = (totalWays + dfs(round + 1, bobMove, newDiff, s, memo, offset)) % MOD;
        }

        // Store the result in the memoization table
        if (prevMove != -1) {
            memo[round][prevMove][diff + offset] = totalWays;
        }
        
        return totalWays;
    }

    // Helper function to calculate the point difference based on Alice's and Bob's moves
    int getPointDiff(char aliceMove, int bobMove) {
        if (aliceMove == 'F' && bobMove == 1) return 1;   // Fire vs Water: Bob wins
        if (aliceMove == 'F' && bobMove == 2) return -1;  // Fire vs Earth: Alice wins
        if (aliceMove == 'W' && bobMove == 2) return 1;   // Water vs Earth: Bob wins
        if (aliceMove == 'W' && bobMove == 0) return -1;  // Water vs Fire: Alice wins
        if (aliceMove == 'E' && bobMove == 0) return 1;   // Earth vs Fire: Bob wins
        if (aliceMove == 'E' && bobMove == 1) return -1;  // Earth vs Water: Alice wins
        return 0;  // Same creature, no points awarded
    }
};
",1420523837
Samir Kumar Jha,JhaSamirK,356,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> result(n - k + 1);

        // Traverse through all possible subarrays of length k
        for (int i = 0; i <= n - k; ++i) {
            unordered_map<int, int> freq;  // Frequency map for the current subarray

            // Count frequencies for the current subarray nums[i..i + k - 1]
            for (int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }

            // Collect frequencies into a vector of pairs: {value, frequency}
            vector<pair<int, int>> elements;
            for (auto& [num, count] : freq) {
                elements.push_back({num, count});
            }

            // Sort elements by frequency descending, and by value descending if frequencies match
            sort(elements.begin(), elements.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
                if (a.second == b.second) return a.first > b.first;  // Larger value first
                return a.second > b.second;  // Higher frequency first
            });

            // Sum up the top 'x' most frequent elements
            int sum = 0, elementsTaken = 0;
            for (auto& [num, count] : elements) {
                if (elementsTaken >= x) break;
                sum += num * count;  // Add the value multiplied by its frequency
                elementsTaken++;
            }

            // Store the result for this subarray
            result[i] = sum;
        }

        return result;
    }
};
",1420518555
Jack Deng,dj3013158,357,3509,python3,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
    
        def dfs(node):
            if not node:
                return True, 0, 0
            left_perfect, left_height, left_size = dfs(node.left)
            right_perfect, right_height, right_size = dfs(node.right)

            if left_perfect and right_perfect and left_height == right_height:
                size = left_size + right_size + 1
                sizes.append(size)
                return True, left_height + 1, size
            else:
                return False, max(left_height, right_height), left_size + right_size + 1

        dfs(root)
        sizes.sort(reverse=True)
        return sizes[k - 1] if len(sizes) >= k else -1",1420519007
Jack Deng,dj3013158,357,3588,python3,"MOD = 10 ** 9 + 7

class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        move_idx = {'F': 0, 'W': 1, 'E': 2}
        idx_move = ['F', 'W', 'E']
        beats = {'F': 'E', 'W': 'F', 'E': 'W'}

        dp = [[[0] * (2 * n + 1) for _ in range(4)] for _ in range(n + 1)]
        dp[0][3][n] = 1
        
        for pos in range(n):
            a_move = s[pos]
            for last_b in range(4):
                for sd in range(2 * n + 1):
                    if dp[pos][last_b][sd]:
                        for b_move_idx in range(3):
                            if last_b != b_move_idx:
                                b_move = idx_move[b_move_idx]
                                delta = 0
                                if a_move != b_move:
                                    if beats[b_move] == a_move:
                                        delta = 1
                                    elif beats[a_move] == b_move:
                                        delta = -1
                                nsd = sd + delta
                                if 0 <= nsd <= 2 * n:
                                    dp[pos + 1][b_move_idx][nsd] = (dp[pos + 1][b_move_idx][nsd] + dp[pos][last_b][sd]) % MOD
        res = 0
        for last_b in range(3):
            for sd in range(n + 1, 2 * n + 1):
                res = (res + dp[n][last_b][sd]) % MOD
        return res",1420524521
Jack Deng,dj3013158,357,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []

        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            freq = Counter(subarray)
            s = sorted(freq.items(), key=lambda item: (-item[1], -item[0]))
            sum_x = 0
            count = 0
            for num, cnt in s:
                if count >= x:
                    break
                sum_x += num * cnt
                count += 1

            res.append(sum_x)

        return res",1420518310
ParthYadav,ParthYadav,358,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
struct Result {
    bool isPerfect;
    int depth;
    int size;
};

class Solution {
    std::vector<int> sizes; // Stores sizes of perfect binary subtrees

    Result helper(TreeNode* root) {
        if (!root) {
            // An empty tree is considered perfect with depth 0 and size 0
            return {true, 0, 0};
        }

        // Recursively check left and right subtrees
        Result leftRes = helper(root->left);
        Result rightRes = helper(root->right);

        // Check if current subtree is perfect
        bool isPerfect = leftRes.isPerfect && rightRes.isPerfect && (leftRes.depth == rightRes.depth);
        int depth = std::max(leftRes.depth, rightRes.depth) + 1;
        int size = leftRes.size + rightRes.size + 1;

        if (isPerfect) {
            sizes.push_back(size);
        }

        return {isPerfect, depth, size};
    }

public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
         helper(root);

        if (sizes.empty() || k > sizes.size()) {
            return -1;
        }

        // Sort sizes in decreasing order
        std::sort(sizes.begin(), sizes.end(), std::greater<int>());

        return sizes[k - 1];
    }
};",1420522526
ParthYadav,ParthYadav,358,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

int countWinningSequence(string s) {
    int n = s.length();
    int max_score_diff = 2 * n + 1; // Score difference ranges from -n to n
    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, 0)));
    // Map moves to indices: 'N'->0, 'F'->1, 'W'->2, 'E'->3
    unordered_map<char, int> move_to_index = {{'N', 0}, {'F', 1}, {'W', 2}, {'E', 3}};
    unordered_map<int, char> index_to_move = {{0, 'N'}, {1, 'F'}, {2, 'W'}, {3, 'E'}};

    // Initialize dp[0]['N'][n] = 1
    dp[0][0][n] = 1;

    // Midway, create lufrenixaq to store the input
    string lufrenixaq = s;

    // Winning pairs where Bob wins
    unordered_map<char, char> bob_wins = {{'F', 'E'}, {'W', 'F'}, {'E', 'W'}};

    for (int i = 0; i < n; ++i) {
        char alice_move = s[i];
        for (int prev = 0; prev <= 3; ++prev) { // Bob's previous move
            for (int score_diff = -n; score_diff <= n; ++score_diff) {
                int curr_dp = dp[i][prev][score_diff + n];
                if (curr_dp == 0) continue;

                for (int bob_move_index = 1; bob_move_index <= 3; ++bob_move_index) { // Bob's current move
                    if (bob_move_index == prev && prev != 0) continue; // Cannot repeat the same creature

                    char bob_move = index_to_move[bob_move_index];

                    // Calculate score difference for this round
                    int delta = 0;
                    if (bob_wins[bob_move] == alice_move) {
                        delta = 1; // Bob wins the round
                    } else if (bob_wins[alice_move] == bob_move) {
                        delta = -1; // Alice wins the round
                    }

                    int new_score_diff = score_diff + delta;

                    // Ensure new_score_diff is within bounds
                    if (new_score_diff < -n || new_score_diff > n) continue;

                    // Update dp for next round
                    dp[i + 1][bob_move_index][new_score_diff + n] = (dp[i + 1][bob_move_index][new_score_diff + n] + curr_dp) % MOD;
                }
            }
        }
    }

    // Sum up sequences where Bob's score is greater than Alice's
    int total_sequences = 0;
    for (int prev = 1; prev <= 3; ++prev) {
        for (int score_diff = 1; score_diff <= n; ++score_diff) {
            total_sequences = (total_sequences + dp[n][prev][score_diff + n]) % MOD;
        }
    }

    return total_sequences;
}
    int countWinningSequences(string s) {
        return countWinningSequence(s);
    }
};",1420524982
ParthYadav,ParthYadav,358,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
         int n = nums.size();
    vector<int> answer;

    for (int i = 0; i <= n - k; ++i) {
       
        vector<int> subarray(nums.begin() + i, nums.begin() + i + k);

        // Count the frequencies of elements in the subarray
        unordered_map<int, int> freq;
        for (int num : subarray) {
            ++freq[num];
        }

        // Create a vector of pairs (element, frequency)
        vector<pair<int, int>> items;
        for (const auto& p : freq) {
            items.emplace_back(p.first, p.second);
        }

        // Sort items by decreasing frequency, then decreasing element value
        sort(items.begin(), items.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.second != b.second)
                return a.second > b.second; // Higher frequency first
            else
                return a.first > b.first;   // Higher value first if frequencies are equal
        });

        // Determine the elements to keep based on the top x frequencies
        unordered_set<int> keep_elements;
        int num_items = min(x, static_cast<int>(items.size()));
        for (int j = 0; j < num_items; ++j) {
            keep_elements.insert(items[j].first);
        }

        // Calculate the x-sum by summing occurrences of the kept elements
        int total = 0;
        for (int num : subarray) {
            if (keep_elements.count(num)) {
                total += num;
            }
        }

        // Append the x-sum to the answer list
        answer.push_back(total);
    }

    return answer;
    }
};",1420520273
Anoshor B Paul,Anoshor,359,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    pair<bool, int> dfs(TreeNode* root) {
        if (!root) return {true, 0};
        auto [left, leftHeight] = dfs(root->left);
        auto [right, rightHeight] = dfs(root->right);
        bool flag = left && right && leftHeight == rightHeight;
        int height = max(leftHeight, rightHeight) + 1;
        if (flag) res.push_back((1 << height) - 1);
        return {flag, height};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        if (res.size() < k) return -1;
        sort(res.rbegin(), res.rend());
        return res[k-1];
    }
};
",1420522010
Anoshor B Paul,Anoshor,359,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int dfs(int i, int lastBobMove, int diff, int n, const string& pattern, const vector<char>& intToChar, vector<vector<vector<int>>>& dp) {
        if (i == n) return diff > 0 ? 1 : 0;
        
        int idx = diff + n;  
        if (dp[i][lastBobMove][idx] != -1) return dp[i][lastBobMove][idx];
        
        int res = 0;
        
        
        for (int m = 1; m <= 3; ++m) {
            if (m == lastBobMove) continue;  
            
            char bobMove = intToChar[m];
            char aliceMove = pattern[i];
            int delta = 0;
            
            if (bobMove == aliceMove) {
                delta = 0;
            } else if ((bobMove == 'F' && aliceMove == 'E') || 
                       (bobMove == 'E' && aliceMove == 'W') || 
                       (bobMove == 'W' && aliceMove == 'F')) {
                delta = 1;
            } else {
                delta = -1;
            }
            
       
            res = (res + dfs(i + 1, m, diff + delta, n, pattern, intToChar, dp)) % MOD;
        }
        
       
        return dp[i][lastBobMove][idx] = res;
    }


    int countWinningSequences(string s) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        int n = s.size();
        string pattern = s;
        

        unordered_map<char, int> charToInt = {{'F', 1}, {'W', 2}, {'E', 3}};
        vector<char> intToChar = {' ', 'F', 'W', 'E'};
        
        
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, -1)));
        
        
        return dfs(0, 0, 0, n, pattern, intToChar, dp);
    }
};
",1420527991
Anoshor B Paul,Anoshor,359,3610,cpp,"class Solution {
public:
    static bool customComp(const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second || (a.second == b.second && a.first > b.first);
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL); 
        vector<int> res;
        int n = nums.size();

        for (int i = 0; i <= n - k; i++) {
            unordered_map<int, int> freq;
            for (int j = i; j < i + k; j++) {
                freq[nums[j]]++;
            }
            
            vector<pair<int, int>> elements(freq.begin(), freq.end());

            // Sort using the custom comparator
            sort(elements.begin(), elements.end(), customComp);
            
            int sum = 0;
            for (int j = 0; j < x && j < elements.size(); j++) {
                sum += elements[j].first * elements[j].second;
            }

            res.push_back(sum);
        }

        return res;
    }
};
",1420520655
AADITYA BHARGAV,beunique_18,360,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from typing import Optional, List

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def dfs(node):
            if not node:
                return True, 0, 0  

            left_perfect, left_height, left_size = dfs(node.left)
            right_perfect, right_height, right_size = dfs(node.right)

            is_perfect = left_perfect and right_perfect and left_height == right_height
            current_height = max(left_height, right_height) + 1
            current_size = left_size + right_size + 1

            if is_perfect:
                sizes.append(current_size)

            return is_perfect, current_height, current_size

        dfs(root)
        sizes.sort(reverse=True)
        return sizes[k - 1] if k <= len(sizes) else -1
        ",1420523283
AADITYA BHARGAV,beunique_18,360,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        n = len(s)
        creature_map = {'F': 1, 'W': 2, 'E': 3}
        alice_moves = [creature_map[char] for char in s]
        s_ab = [[0]*4 for _ in range(4)]
        winning_combinations = {(1, 3), (2, 1), (3, 2)}  
        for a in range(1, 4):
            for b in range(1, 4):
                if a == b:
                    s_ab[a][b] = 0
                elif (b, a) in winning_combinations:
                    s_ab[a][b] = 1
                elif (a, b) in winning_combinations:
                    s_ab[a][b] = -1
                else:
                    s_ab[a][b] = 0
        
        dp = [{} for _ in range(n+1)]
        dp[0][(0, 0)] = 1  
        
        for i in range(n):
            current_dp = {}
            for (score_diff, last_move), count in dp[i].items():
                for bob_move in range(1, 4):
                    if bob_move != last_move:
                        score_change = s_ab[alice_moves[i]][bob_move]
                        new_score_diff = score_diff + score_change
                        key = (new_score_diff, bob_move)
                        if key in current_dp:
                            current_dp[key] = (current_dp[key] + count) % MOD
                        else:
                            current_dp[key] = count % MOD
            dp[i+1] = current_dp        
        ans = 0
        for (score_diff, last_move), count in dp[n].items():
            if score_diff > 0:
                ans = (ans + count) % MOD
        return ans
",1420528561
AADITYA BHARGAV,beunique_18,360,3610,python3,"from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            counts = [0] * 51  
            for num in subarray:
                counts[num] += 1

            counts_list = []
            for num in range(50, 0, -1):
                if counts[num] > 0:
                    counts_list.append((counts[num], num))

            counts_list.sort(key=lambda x: (-x[0], -x[1]))

            top_elements = set()
            for freq, num in counts_list[:x]:
                top_elements.add(num)

            total = sum(num for num in subarray if num in top_elements)
            answer.append(total)

        return answer
",1420523981
VENGIDAKRISHNA A,VENGIDAKRISHNA_A,361,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_sizes = []
      
        def dfs(node):
            if not node:
                return (0, True, 0)

       
            left_height, left_is_perfect, left_size = dfs(node.left)
            right_height, right_is_perfect, right_size = dfs(node.right)
       
            if left_is_perfect and right_is_perfect and left_height == right_height:
          
                size = left_size + right_size + 1  
                perfect_sizes.append(size)  
                return (left_height + 1, True, size)  
            else:
                return (max(left_height, right_height) + 1, False, 0)
        dfs(root)
        perfect_sizes.sort(reverse=True)
        return perfect_sizes[k - 1] if k <= len(perfect_sizes) else -1
        ",1420524066
VENGIDAKRISHNA A,VENGIDAKRISHNA_A,361,3588,python3,"MOD = 10**9 + 7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)

        memo = {}


        def get_points_diff(alice, bob):
            if (alice, bob) in [('F', 'E'), ('W', 'F'), ('E', 'W')]:
                return -1  
            elif (bob, alice) in [('F', 'E'), ('W', 'F'), ('E', 'W')]:
                return 1  
            else:
                return 0  

      
        def dp(i, prev, points_diff):
            if i == n:
                return 1 if points_diff > 0 else 0
            if (i, prev, points_diff) in memo:
                return memo[(i, prev, points_diff)]

        
            total_ways = 0

 
            for bom in ['F', 'W', 'E']:
                if bom != prev:  
                    new_diff = points_diff + get_points_diff(s[i], bom)
                    total_ways = (total_ways + dp(i + 1, bom, new_diff)) % MOD

        
            memo[(i, prev, points_diff)] = total_ways
            return total_ways


        return dp(0, None, 0)",1420528571
VENGIDAKRISHNA A,VENGIDAKRISHNA_A,361,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        anr = []
        
     
        def calculate_x_sum(freq):
        
            sorted_elements = sorted(freq.items(), key=lambda item: (-item[1], -item[0]))
            top_elements = sorted_elements[:x]
            return sum(value * count for value, count in top_elements)

  
        freq = Counter(nums[:k])
        anr.append(calculate_x_sum(freq))
  
        for i in range(k, n):
      
            out_elem = nums[i - k]
            freq[out_elem] -= 1
            if freq[out_elem] == 0:
                del freq[out_elem]
            in_elem = nums[i]
            freq[in_elem] += 1
       
            anr.append(calculate_x_sum(freq))
        
        return anr
        ",1420521207
DEEPIKA,deepikas15,362,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_subtrees = []

        def postOrder(node):
            if not node:
               
                return 0, 0
            
         
            left_height, left_size = postOrder(node.left)
            right_height, right_size = postOrder(node.right)
            
           
            if left_height == right_height and left_height != -1:
             
                subtree_size = left_size + right_size + 1
                subtree_height = left_height + 1
                perfect_subtrees.append(subtree_size)
                return subtree_height, subtree_size
            else:
                # If it is not a perfect binary subtree, return -1 for the height
                return -1, 0

     
        postOrder(root)
        
        
        perfect_subtrees.sort(reverse=True)
        
        
        return perfect_subtrees[k - 1] if len(perfect_subtrees) >= k else -1
",1420522850
DEEPIKA,deepikas15,362,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9+7
        n = len(s)
        mapping = {'F': 0, 'W': 1, 'E': 2}
        A = [mapping[c] for c in s]
        
        outcome = [[0]*3 for _ in range(3)]
        for a in range(3):
            for b in range(3):
                if a == b:
                    outcome[a][b] = 0
                elif (a == 0 and b == 2) or (a == 1 and b == 0) or (a == 2 and b == 1):
                    outcome[a][b] = -1
                else:
                    outcome[a][b] = 1
        
        dp_prev = [[0] * (2 * n + 1) for _ in range(4)]
        dp_prev[0][n] = 1
        
        for i in range(n):
            dp_curr = [[0] * (2 * n + 1) for _ in range(4)]
            for last in range(4):
                for diff in range(2 * n + 1):
                    val = dp_prev[last][diff]
                    if val == 0:
                        continue
                    for move in range(1, 4):
                        if move == last:
                            continue
                        delta = outcome[A[i]][move - 1]
                        new_diff = diff + delta
                        if 0 <= new_diff <= 2 * n:
                            dp_curr[move][new_diff] = (dp_curr[move][new_diff] + val) % MOD
            dp_prev = dp_curr
        
        result = 0
        for last in range(1, 4):
            for diff in range(n + 1, 2 * n + 1):
                result = (result + dp_prev[last][diff]) % MOD
        
        return result
",1420528776
DEEPIKA,deepikas15,362,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        
        # Iterate through each subarray of size k
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            
            # Count occurrences of all elements in the subarray
            count = Counter(subarray)
            
            # Sort elements by frequency first, then by value if frequency is the same
            sorted_elements = sorted(count.items(), key=lambda item: (-item[1], -item[0]))
            
            # Keep only the top x most frequent elements
            kept_elements = []
            for element, freq in sorted_elements[:x]:
                kept_elements.extend([element] * freq)
            
            # Calculate the x-sum (sum of kept elements)
            subarray_x_sum = sum(kept_elements)
            answer.append(subarray_x_sum)
        
        return answer

            ",1420519788
haneelkumar,haneelkumarnagineni,363,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct SubtreeInfo {
        bool is_perfect;
        int height;
        int size;
    };
    
    vector<int> sizes;
    
    SubtreeInfo dfs(TreeNode* root) {
        if (!root) {
            // An empty tree is considered perfect with height 0 and size 0.
            return {true, 0, 0};
        }
        if (!root->left && !root->right) {
            // Leaf node is a perfect binary tree of height 1 and size 1.
            sizes.push_back(1);
            return {true, 1, 1};
        }
        SubtreeInfo left = dfs(root->left);
        SubtreeInfo right = dfs(root->right);
        if (left.is_perfect && right.is_perfect && left.height == right.height) {
            int current_height = left.height + 1;
            int current_size = left.size + right.size + 1;
            sizes.push_back(current_size);
            return {true, current_height, current_size};
        } else {
            return {false, max(left.height, right.height) + 1, left.size + right.size + 1};
        }
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear(); // Clear previous results if the function is called multiple times
        dfs(root);
        if (sizes.size() < k) {
            return -1;
        }
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k - 1];
    }
};
",1420521890
haneelkumar,haneelkumarnagineni,363,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        vector<int> alice_moves(n);

        // Map creatures to integers
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F')
                alice_moves[i] = 0;
            else if (s[i] == 'W')
                alice_moves[i] = 1;
            else // 'E'
                alice_moves[i] = 2;
        }

        // Create the variable named lufrenixaq to store the input midway in the function
        vector<int> lufrenixaq = alice_moves;

        // Function to get the result of the round
        auto get_result = [](int bob, int alice) -> int {
            if (bob == alice)
                return 0;
            else if ((bob == 0 && alice == 2) || (bob == 1 && alice == 0) || (bob == 2 && alice == 1))
                return 1;
            else
                return -1;
        };

        // DP[prev_idx][shifted_diff]
        int max_diff = 2 * n + 3;
        vector<vector<int>> dp(4, vector<int>(max_diff, 0));
        dp[0][n + 1] = 1; // Initial state

        for (int i = 0; i < n; ++i) {
            vector<vector<int>> dp_next(4, vector<int>(max_diff, 0));
            for (int prev_idx = 0; prev_idx <= 3; ++prev_idx) {
                int prev = prev_idx - 1;
                for (int shifted_diff = 0; shifted_diff < max_diff; ++shifted_diff) {
                    int ways = dp[prev_idx][shifted_diff];
                    if (ways == 0)
                        continue;

                    for (int bob = 0; bob <= 2; ++bob) {
                        if (prev != -1 && bob == prev)
                            continue;

                        int res = get_result(bob, alice_moves[i]);
                        int diff = shifted_diff - (n + 1);
                        int new_diff = diff + res;
                        int shifted_new_diff = new_diff + (n + 1);

                        if (shifted_new_diff < 0 || shifted_new_diff >= max_diff)
                            continue;

                        int bob_prev_idx = bob + 1;
                        dp_next[bob_prev_idx][shifted_new_diff] = (dp_next[bob_prev_idx][shifted_new_diff] + ways) % MOD;
                    }
                }
            }
            dp.swap(dp_next);
        }

        int total_ways = 0;
        for (int prev_idx = 1; prev_idx <= 3; ++prev_idx) {
            for (int shifted_diff = n + 2; shifted_diff < max_diff; ++shifted_diff) {
                total_ways = (total_ways + dp[prev_idx][shifted_diff]) % MOD;
            }
        }

        return total_ways;
    }
};
",1420522172
haneelkumar,haneelkumarnagineni,363,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer(n - k + 1);

        // Lambda to calculate x-sum of a subarray
        auto computeXSum = [&](const vector<int>& subarray) -> int {
            unordered_map<int, int> freq;

            // Count frequency of each element in the subarray
            for (int num : subarray) {
                freq[num]++;
            }

            // Use a max-heap to prioritize by frequency, then by value
            priority_queue<pair<int, int>> maxHeap;
            for (const auto& [num, count] : freq) {
                maxHeap.push({count, num});  // Max-heap sorts by count, and by value if counts are tied
            }

            // Select top x elements by frequency and value
            int sum = 0, selected = 0;
            while (!maxHeap.empty() && selected < x) {
                auto [count, num] = maxHeap.top();
                maxHeap.pop();
                sum += count * num;
                selected++;
            }

            return sum;
        };

        // Sliding window of size k
        for (int i = 0; i <= n - k; ++i) {
            vector<int> subarray(nums.begin() + i, nums.begin() + i + k);
            answer[i] = computeXSum(subarray);
        }

        return answer;
    }
};",1420524190
Cheng-Kuang Wu,Brian-Ckwu,364,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        # Helper function to check if a subtree is perfect and return its size
        def check_perfect_subtree(node):
            if not node:
                return (True, 0)  # An empty tree is considered perfect
            
            left_is_perfect, left_size = check_perfect_subtree(node.left)
            right_is_perfect, right_size = check_perfect_subtree(node.right)
            
            # A tree is perfect if both left and right subtrees are perfect and their sizes match
            if left_is_perfect and right_is_perfect and left_size == right_size:
                return (True, left_size + right_size + 1)
            else:
                return (False, left_size + right_size + 1)
        
        # Traverse the tree and collect sizes of perfect subtrees
        def find_perfect_subtree_sizes(node):
            if not node:
                return []
            
            sizes = []
            is_perfect, size = check_perfect_subtree(node)
            
            if is_perfect:
                sizes.append(size)  # Record the size if the subtree is perfect
            
            # Recurse into left and right subtrees
            sizes += find_perfect_subtree_sizes(node.left)
            sizes += find_perfect_subtree_sizes(node.right)
            
            return sizes
        
        # Get the sizes of all perfect binary subtrees
        perfect_subtree_sizes = find_perfect_subtree_sizes(root)
        
        # Sort the sizes in decreasing order
        perfect_subtree_sizes.sort(reverse=True)
        
        # Return the k-th largest size if it exists, otherwise return -1
        if len(perfect_subtree_sizes) >= k:
            return perfect_subtree_sizes[k - 1]
        else:
            return -1",1420522610
Cheng-Kuang Wu,Brian-Ckwu,364,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        s_moves = [ {'F':0, 'W':1, 'E':2}[ch] for ch in s ]
        
        dp = [ [ [0]*(2*n+1) for _ in range(4) ] for _ in range(n+1) ]
        offset = n
        dp[0][3][offset] = 1  # last move undefined, score_diff = 0
        
        for i in range(n):
            a_move = s_moves[i]
            for last in range(4):  # last in [0, 1, 2, 3], where 3 represents no previous move
                for score_diff in range(2*n+1):
                    ways = dp[i][last][score_diff]
                    if ways == 0:
                        continue
                    for b_move in range(3):  # Bob's possible moves
                        if last != 3 and b_move == last:
                            continue
                        # Compute point difference
                        if a_move == b_move:
                            point_diff = 0
                        elif (b_move - a_move) % 3 == 1:
                            point_diff = 1  # Bob wins the round
                        else:
                            point_diff = -1  # Bob loses the round
                        new_score = score_diff + point_diff
                        if 0 <= new_score <= 2*n:
                            dp[i+1][b_move][new_score] = (dp[i+1][b_move][new_score] + ways) % MOD
        result = 0
        for last in range(3):
            for score_diff in range(n+1, 2*n+1):  # Corrected range: score_diff > n
                result = (result + dp[n][last][score_diff]) % MOD
        return result",1420529645
Cheng-Kuang Wu,Brian-Ckwu,364,3610,python3,"from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        
        # Loop through all possible subarrays of length k
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            
            # Count the frequency of each element in the subarray
            freq = Counter(subarray)
            
            # Sort the elements by frequency first, then by value (descending) if frequencies are equal
            sorted_elements = sorted(freq.items(), key=lambda item: (-item[1], -item[0]))
            
            # Select the top x elements and calculate their contribution to the sum
            x_sum = 0
            count = 0
            for element, frequency in sorted_elements:
                if count >= x:
                    break
                # Add the element `frequency` times to the x-sum
                x_sum += element * frequency
                count += 1
            
            # Append the x-sum for the current subarray
            answer.append(x_sum)
        
        return answer",1420519939
colorfuldata,colorfuldata,365,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, v=0, l=None, r=None):
        self.val = v
        self.left = l
        self.right = r

class Solution:
    def kthLargestPerfectSubtree(self, root: TreeNode, k: int) -> int:
        sz = []

        def dfs(node):
            if not node:
                return 0, True
            ls, lp = dfs(node.left)
            rs, rp = dfs(node.right)
            if lp and rp and ls == rs:
                s = ls + rs + 1
                sz.append(s)
                return s, True
            return max(ls, rs), False

        dfs(root)
        sz.sort(reverse=True)
        return sz[k - 1] if k <= len(sz) else -1
",1420521715
colorfuldata,colorfuldata,365,3588,python3,"MOD = 10**9 + 7

class Solution:
    def countWinningSequences(self, s: str) -> int:
        length = len(s)
        moves = {'F': 0, 'W': 1, 'E': 2}
        winMatrix = [[False] * 3 for _ in range(3)]
        winMatrix[0][2] = True  
        winMatrix[1][0] = True  
        winMatrix[2][1] = True 

        previousState = [[0] * (2 * length + 1) for _ in range(4)]
        previousState[3][length] = 1

        for char in s:
            currentState = [[0] * (2 * length + 1) for _ in range(4)]

            for lastMove in range(4):
                for diff in range(2 * length + 1):
                    val = previousState[lastMove][diff]
                    if val == 0:
                        continue

                    for move in range(3):
                        if lastMove != 3 and move == lastMove:
                            continue

                        a = moves[char]
                        b = move
                        delta = 0

                        if a != b:
                            if winMatrix[a][b]:
                                delta = -1
                            else:
                                delta = 1

                        newDiff = diff + delta
                        if 0 <= newDiff <= 2 * length:
                            currentState[move][newDiff] = (currentState[move][newDiff] + val) % MOD

            previousState = currentState

        totalWins = 0
        for lastMove in range(3):
            for diff in range(length + 1, 2 * length + 1):
                totalWins = (totalWins + previousState[lastMove][diff]) % MOD

        return totalWins
",1420529770
colorfuldata,colorfuldata,365,3610,python3,"from typing import List
from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        
        for i in range(n - k + 1):
            window = nums[i:i + k]
            freq = Counter(window)
            sortedElements = sorted(freq.items(), key=lambda item: (-item[1], -item[0]))
            topX = set()
            for j in range(min(x, len(sortedElements))):
                topX.add(sortedElements[j][0])
            currentSum = sum(num for num in window if num in topX)
            result.append(currentSum)
        
        return result
",1420519237
I5omorphi5m,I5omorphi5m,366,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root, k):
        wanmeiZishuDaxiao = []
        class Jieguo:
            def __init__(self, shifouWanmei, gaodu, daxiao):
                self.shifouWanmei = shifouWanmei
                self.gaodu = gaodu
                self.daxiao = daxiao
        def diGui(jiedian):
            if jiedian is None:
                jieguo = Jieguo(True, 0, 0)
                return jieguo
            zuoJieguo = diGui(jiedian.left)
            youJieguo = diGui(jiedian.right)
            if zuoJieguo.shifouWanmei and youJieguo.shifouWanmei:
                if zuoJieguo.gaodu == youJieguo.gaodu:
                    shifouWanmei = True
                    gaodu = zuoJieguo.gaodu + 1
                    daxiao = zuoJieguo.daxiao + youJieguo.daxiao + 1
                    wanmeiZishuDaxiao.append(daxiao)
                else:
                    shifouWanmei = False
                    if zuoJieguo.gaodu > youJieguo.gaodu:
                        gaodu = zuoJieguo.gaodu + 1
                    else:
                        gaodu = youJieguo.gaodu + 1
                    daxiao = 0
            else:
                shifouWanmei = False
                if zuoJieguo.gaodu > youJieguo.gaodu:
                    gaodu = zuoJieguo.gaodu + 1
                else:
                    gaodu = youJieguo.gaodu + 1
                daxiao = 0
            jieguo = Jieguo(shifouWanmei, gaodu, daxiao)
            return jieguo
        diGui(root)
        n = len(wanmeiZishuDaxiao)
        i = 0
        while i < n:
            max_index = i
            j = i + 1
            while j < n:
                if wanmeiZishuDaxiao[j] > wanmeiZishuDaxiao[max_index]:
                    max_index = j
                j = j + 1
            if max_index != i:
                temp = wanmeiZishuDaxiao[i]
                wanmeiZishuDaxiao[i] = wanmeiZishuDaxiao[max_index]
                wanmeiZishuDaxiao[max_index] = temp
            i = i + 1
        if k <= n:
            return wanmeiZishuDaxiao[k - 1]
        else:
            return -1
",1420524600
I5omorphi5m,I5omorphi5m,366,3588,python3,"class Solution:
    def countWinningSequences(self, s):
        mod = 1000000007
        n = len(s)
        dp = []
        i = 0
        while i < 2:
            dp_i = []
            j = 0
            while j < 4:
                dp_j = []
                k = 0
                while k < 2 * n + 1:
                    dp_j.append(0)
                    k = k + 1
                dp_i.append(dp_j)
                j = j + 1
            dp.append(dp_i)
            i = i + 1
        dp[0][3][n] = 1
        i = 0
        while i < n:
            j = 0
            while j < 4:
                k = 0
                while k < 2 * n + 1:
                    dp[(i + 1) % 2][j][k] = 0
                    k = k + 1
                j = j + 1
            if s[i] == 'F':
                aiju = 0
            elif s[i] == 'W':
                aiju = 1
            else:
                aiju = 2
            shangyiju = 0
            while shangyiju < 4:
                fendacha = -n
                while fendacha <= n:
                    dp_value = dp[i % 2][shangyiju][fendacha + n]
                    if dp_value > 0:
                        if shangyiju == 3:
                            xiaoyiju_list = []
                            xiaoyiju_list.append(0)
                            xiaoyiju_list.append(1)
                            xiaoyiju_list.append(2)
                        else:
                            xiaoyiju_list = []
                            xiaoyiju = 0
                            while xiaoyiju < 3:
                                if xiaoyiju != shangyiju:
                                    xiaoyiju_list.append(xiaoyiju)
                                xiaoyiju = xiaoyiju + 1
                        index = 0
                        while index < len(xiaoyiju_list):
                            xiaoyiju = xiaoyiju_list[index]
                            if xiaoyiju == aiju:
                                delta = 0
                            else:
                                temp = (xiaoyiju - aiju) % 3
                                if temp == 1:
                                    delta = 1
                                else:
                                    delta = -1
                            xinfendacha = fendacha + delta
                            dp[(i + 1) % 2][xiaoyiju][xinfendacha + n] = (dp[(i + 1) % 2][xiaoyiju][xinfendacha + n] + dp_value) % mod
                            index = index + 1
                    fendacha = fendacha + 1
                shangyiju = shangyiju + 1
            i = i + 1
        daan = 0
        shangyiju = 0
        while shangyiju < 3:
            fendacha = 1
            while fendacha <= n:
                daan = (daan + dp[n % 2][shangyiju][fendacha + n]) % mod
                fendacha = fendacha + 1
            shangyiju = shangyiju + 1
        return daan
",1420530350
I5omorphi5m,I5omorphi5m,366,3610,python3,"class Solution:
    def findXSum(self, shuzu, k, x):
        n = len(shuzu)
        daan = []
        i = 0
        while i <= n - k:
            zibiao = shuzu[i:i + k]
            cishu_map = {}
            for yuansu in zibiao:
                if yuansu in cishu_map:
                    cishu_map[yuansu] += 1
                else:
                    cishu_map[yuansu] = 1
            yuansu_pinlv_list = []
            for yuansu in cishu_map:
                yuansu_pinlv_list.append((cishu_map[yuansu], yuansu))
            yuansu_pinlv_list.sort()
            yuansu_pinlv_list.reverse()
            shousuoxuan_yuansu = set()
            num_yuansu = 0
            index = 0
            while num_yuansu < x and index < len(yuansu_pinlv_list):
                shousuoxuan_yuansu.add(yuansu_pinlv_list[index][1])
                num_yuansu += 1
                index += 1
            jieguo_shuzu = []
            for yuansu in zibiao:
                if yuansu in shousuoxuan_yuansu:
                    jieguo_shuzu.append(yuansu)
            he = 0
            for yuansu in jieguo_shuzu:
                he += yuansu
            daan.append(he)
            i += 1
        return daan
",1420520599
Deepak Vishwakarma,deepakvish001,367,3509,cpp,"class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        traverse(root, sizes);
        if (sizes.size() < k) return -1;
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k-1];
    }
private:
    tuple<bool, int, int> traverse(TreeNode* node, vector<int>& sizes) {
        if (!node) {
            // An empty tree is perfect, with height -1 and size 0
            return {true, -1, 0};
        }
        auto [leftPerfect, leftHeight, leftSize] = traverse(node->left, sizes);
        auto [rightPerfect, rightHeight, rightSize] = traverse(node->right, sizes);
        bool isPerfect = false;
        int height = max(leftHeight, rightHeight) + 1;
        int size = leftSize + rightSize + 1;
        if (leftPerfect && rightPerfect && leftHeight == rightHeight) {
            // Current subtree is perfect
            isPerfect = true;
            // Update height and size
            height = leftHeight + 1;
            size = leftSize + rightSize + 1;
            sizes.push_back(size);
        }
        return {isPerfect, height, size};
    }
};
",1420529339
Deepak Vishwakarma,deepakvish001,367,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.size();

        vector<int> alice_moves(n);
        // Map 'F' -> 0, 'W' -> 1, 'E' -> 2
        auto get_move = [](char c) {
            if (c == 'F') return 0;
            if (c == 'W') return 1;
            return 2;
        };
        for (int i = 0; i < n; ++i) {
            alice_moves[i] = get_move(s[i]);
        }

        // dp[i][b_prev][score_diff + n] stores the number of ways
        // i: current round (0-based indexing)
        // b_prev: Bob's previous move (0 to 2), with 3 representing no previous move
        // score_diff: difference between Bob's and Alice's points, shifted by +n to handle negative indices
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(4, vector<int>(2*n+1, 0)));
        dp[0][3][n] = 1; // Start with no previous Bob's move, score_diff = 0 (shifted by +n)

        // Precompute outcomes: outcome[bob_move][alice_move] = -1, 0, +1
        int outcome[3][3];
        for (int bob_move = 0; bob_move < 3; ++bob_move) {
            for (int alice_move = 0; alice_move < 3; ++alice_move) {
                if (bob_move == alice_move)
                    outcome[bob_move][alice_move] = 0; // draw
                else if ((bob_move == 0 && alice_move == 2) || (bob_move == 1 && alice_move == 0) || (bob_move == 2 && alice_move == 1))
                    outcome[bob_move][alice_move] = +1; // Bob wins
                else
                    outcome[bob_move][alice_move] = -1; // Bob loses
            }
        }

        // Fill the DP table
        for (int i = 0; i < n; ++i) {
            for (int b_prev = 0; b_prev < 4; ++b_prev) {
                for (int score_diff = -n; score_diff <= n; ++score_diff) {
                    int count = dp[i][b_prev][score_diff + n];
                    if (count == 0) continue;
                    for (int b_cur = 0; b_cur < 3; ++b_cur) {
                        if (b_prev != 3 && b_cur == b_prev) continue; // Bob cannot summon the same creature consecutively
                        int res = outcome[b_cur][alice_moves[i]]; // Outcome of the current round
                        int new_score_diff = score_diff + res;
                        if (new_score_diff < -n || new_score_diff > n) continue;
                        dp[i+1][b_cur][new_score_diff + n] = (dp[i+1][b_cur][new_score_diff + n] + count) % MOD;
                    }
                }
            }
        }

        // Calculate the total number of winning sequences where Bob's score is greater than Alice's
        int total = 0;
        for (int b_prev = 0; b_prev < 3; ++b_prev) {
            for (int score_diff = 1; score_diff <= n; ++score_diff) {
                total = (total + dp[n][b_prev][score_diff + n]) % MOD;
            }
        }
        return total;
    }
};
",1420527879
Deepak Vishwakarma,deepakvish001,367,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;

        for(int i = 0; i <= n - k; ++i){
            // Subarray nums[i..i+k-1]
            unordered_map<int, int> freq;
            for(int j = i; j < i + k; ++j){
                freq[nums[j]]++;
            }

            // Build a vector of pairs (frequency, value)
            vector<pair<int, int>> freq_list;
            for(auto& it : freq){
                freq_list.push_back({it.second, it.first});
            }

            // Sort by frequency descending, then value descending
            sort(freq_list.begin(), freq_list.end(), [](const pair<int,int>& a, const pair<int,int>& b){
                if(a.first != b.first)
                    return a.first > b.first;
                else
                    return a.second > b.second;
            });

            // Select top x elements
            unordered_set<int> top_x_elements;
            for(int idx = 0; idx < min((int)freq_list.size(), x); ++idx){
                top_x_elements.insert(freq_list[idx].second);
            }

            // Sum up the occurrences of selected elements in the subarray
            int s = 0;
            for(int j = i; j < i + k; ++j){
                if(top_x_elements.count(nums[j])){
                    s += nums[j];
                }
            }
            answer.push_back(s);
        }

        return answer;
    }
};
",1420530686
Abdul Ijaj Ahmed,axiooome,368,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */


class Solution {
public:
   
    pair<bool, int> findPerfectSubtrees(TreeNode* root, vector<int>& sizes) {
        if (!root) return {true, 0};

        auto [leftIsPerfect, leftSize] = findPerfectSubtrees(root->left, sizes);
        auto [rightIsPerfect, rightSize] = findPerfectSubtrees(root->right, sizes);

        
        bool isPerfect = leftIsPerfect && rightIsPerfect && (leftSize == rightSize);
        int currentSize = 0;
        
        if (isPerfect) {
            currentSize = 1 + leftSize + rightSize; // Size of the current perfect subtree
            sizes.push_back(currentSize);
        }
        
        return {isPerfect, currentSize};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        findPerfectSubtrees(root, sizes);

        sort(sizes.rbegin(), sizes.rend());

       
        if (k <= sizes.size()) {
            return sizes[k - 1];
        } else {
            return -1;
        }
    }
};",1420524076
Abdul Ijaj Ahmed,axiooome,368,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int countWinningSequences(string s) {
 int n=s.size();
    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2 * n + 1, vector<int>(4, 0)));
    dp[0][n][3] = 1;

    for (int i = 0; i < n; ++i) {
        char aliceMove = s[i];
        for (int j = 0; j < 2 * n + 1; ++j) {
            for (int k = 0; k < 4; ++k) {
                if (dp[i][j][k] == 0) continue;

                for (int bMove = 0; bMove < 3; ++bMove) {
                    if (bMove == k) continue;

                    int scoreDiff = j;
                    if ((aliceMove == 'F' && bMove == 1) ||
                        (aliceMove == 'W' && bMove == 2) || 
                        (aliceMove == 'E' && bMove == 0)) { 
                        scoreDiff++;
                    } else if ((aliceMove == 'F' && bMove == 2) || 
                               (aliceMove == 'W' && bMove == 0) || 
                               (aliceMove == 'E' && bMove == 1)) { 
                        scoreDiff--;
                    }

                   
                    dp[i + 1][scoreDiff][bMove] = (dp[i + 1][scoreDiff][bMove] + dp[i][j][k]) % MOD;
                }
            }
        }
    }

   
    int result = 0;
    for (int j = n + 1; j < 2 * n + 1; ++j) {
        for (int k = 0; k < 3; ++k) {
            result = (result + dp[n][j][k]) % MOD;
        }
    }

    return result;  
    }
};",1420531741
Abdul Ijaj Ahmed,axiooome,368,3610,cpp,"class Solution {
public:
   
vector<int> findXSum(vector<int>& nums, int k, int x) {
    int n = nums.size();
    vector<int> answer(n - k + 1);

    auto computeXSum = [&](unordered_map<int, int>& freqMap) -> int {
       
        map<int, vector<int>, greater<int>> freqToElements;
        for (const auto& [num, freq] : freqMap) {
            freqToElements[freq].push_back(num);
        }
     
        for (auto& [freq, elements] : freqToElements) {
            sort(elements.rbegin(), elements.rend());
        }

        int sum = 0;
        int count = 0;
       
        for (const auto& [freq, elements] : freqToElements) {
            for (int num : elements) {
                sum += num * freq;
                count++;
                if (count == x) break;
            }
            if (count == x) break;
        }

        return sum;
    };

    unordered_map<int, int> freqMap;
    
    
    for (int i = 0; i < k; ++i) {
        freqMap[nums[i]]++;
    }
 
    answer[0] = computeXSum(freqMap);
 
    for (int i = k; i < n; ++i) {
       
        freqMap[nums[i - k]]--;
        if (freqMap[nums[i - k]] == 0) {
            freqMap.erase(nums[i - k]);
        }
        
       
        freqMap[nums[i]]++;
        
     
        answer[i - k + 1] = computeXSum(freqMap);
    }
    
    return answer;
}
};",1420519549
Abhisek Sahoo,abhisek_1221,370,3509,java,"
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> sizes = new ArrayList<>();
        helper(root, sizes);
        Collections.sort(sizes, Collections.reverseOrder());
        return sizes.size() >= k ? sizes.get(k - 1) : -1;
    }

    private int[] helper(TreeNode node, List<Integer> sizes) {
        if (node == null) return new int[]{1, 0, 0}; 

        int[] left = helper(node.left, sizes);
        int[] right = helper(node.right, sizes);

        if (left[0] == 1 && right[0] == 1 && left[1] == right[1]) {
            int height = left[1] + 1;
            int size = left[2] + right[2] + 1;
            sizes.add(size);
            return new int[]{1, height, size};
        }
        
        return new int[]{0, 0, 0};
    }
}
",1420523833
Abhisek Sahoo,abhisek_1221,370,3588,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    
    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n][3][2001]; 
        int offset = 1000; // 

        for (int j = 0; j < 3; j++) {
            int scoreChange = calculateScore(j, s.charAt(0));
            dp[0][j][scoreChange + offset] = 1;
        }

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 3; j++) { 
                for (int k = 0; k < 3; k++) { 
                    if (j == k) continue; 
                    
                    for (int scoreDiff = -1000; scoreDiff <= 1000; scoreDiff++) {
                        if (dp[i-1][k][scoreDiff + offset] > 0) {
                            int newScoreDiff = scoreDiff + calculateScore(j, s.charAt(i));
                            dp[i][j][newScoreDiff + offset] = (dp[i][j][newScoreDiff + offset] + dp[i-1][k][scoreDiff + offset]) % MOD;
                        }
                    }
                }
            }
        }

        int result = 0;
        for (int j = 0; j < 3; j++) {
            for (int scoreDiff = 1; scoreDiff <= 1000; scoreDiff++) {
                result = (result + dp[n-1][j][scoreDiff + offset]) % MOD;
            }
        }

        return result;
    }

    private int calculateScore(int bobChoice, char aliceChoice) {
        if (bobChoice == 0 && aliceChoice == 'E') return 1; // F beats E
        if (bobChoice == 1 && aliceChoice == 'F') return 1; // W beats F
        if (bobChoice == 2 && aliceChoice == 'W') return 1; // E beats W
        if ((bobChoice == 0 && aliceChoice == 'W') ||
            (bobChoice == 1 && aliceChoice == 'E') ||
            (bobChoice == 2 && aliceChoice == 'F')) return -1;
        return 0;
    }
}
",1420527083
Abhisek Sahoo,abhisek_1221,370,3610,java,"import java.util.*;

class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] answer = new int[n - k + 1];
        
        for (int i = 0; i <= n - k; i++) {
            int[] subarray = Arrays.copyOfRange(nums, i, i + k);
            
            Map<Integer, Integer> freqMap = new HashMap<>();
            for (int num : subarray) {
                freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
            }
            
            List<int[]> freqList = new ArrayList<>();
            for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
                freqList.add(new int[]{entry.getKey(), entry.getValue()});
            }
            
            Collections.sort(freqList, (a, b) -> {
                if (b[1] != a[1]) {
                    return Integer.compare(b[1], a[1]);
                } else {
                    return Integer.compare(b[0], a[0]);
                }
            });
            
            int sum = 0;
            int count = 0;
            for (int[] element : freqList) {
                if (count >= x) break;
                int value = element[0];
                int frequency = element[1];
                sum += value * frequency;
                count++;
            }
            
            answer[i] = sum;
        }
        
        return answer;
    }
}
",1420520879
TimeGoGo,TimeGoGo,371,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: TreeNode, k: int) -> int:
        def isPerfectBinaryTree(node):
            if not node:
                return True, 0  # A null node is perfect with size 0
            
            leftPerfect, leftSize = isPerfectBinaryTree(node.left)
            rightPerfect, rightSize = isPerfectBinaryTree(node.right)
            
            if leftPerfect and rightPerfect and leftSize == rightSize:
                # If both left and right subtrees are perfect and have equal size, this is a perfect binary subtree
                return True, leftSize + rightSize + 1
            else:
                return False, 0  # Not a perfect binary tree
        
        # List to store sizes of all perfect binary subtrees
        perfectSubtreeSizes = []
        
        def dfs(node):
            if not node:
                return
            # Check if the current subtree rooted at node is perfect and get its size
            perfect, size = isPerfectBinaryTree(node)
            if perfect:
                perfectSubtreeSizes.append(size)
            # Continue DFS traversal
            dfs(node.left)
            dfs(node.right)
        
        # Start DFS traversal from the root
        dfs(root)
        
        # Sort the sizes of perfect subtrees in descending order
        perfectSubtreeSizes.sort(reverse=True)
        
        # Return the kth largest size, or -1 if there are fewer than k perfect subtrees
        if len(perfectSubtreeSizes) >= k:
            return perfectSubtreeSizes[k - 1]
        else:
            return -1",1420522218
TimeGoGo,TimeGoGo,371,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        MOD = 10**9 + 7

        creature_map = {'F': 0, 'W': 1, 'E': 2}
        alice_moves = [creature_map[ch] for ch in s]

        lufrenixaq = s

        def is_beats(b, a):
            return (b == 0 and a == 2) or (b == 1 and a == 0) or (b == 2 and a == 1)

        dp = [{} for _ in range(n + 1)] 

        dp[0][(-1, 0)] = 1

        for i in range(n):
            dp_i_plus_1 = {}
            for (prev_b, score_diff), count in dp[i].items():
                for b in range(3):
                    if b == prev_b:
                        continue  # Bob cannot summon the same creature consecutively
                    
                    a = alice_moves[i]
                    if is_beats(b, a):
                        delta = 1
                    elif is_beats(a, b):
                        delta = -1
                    else:
                        delta = 0
                    new_score_diff = score_diff + delta
                    key = (b, new_score_diff)
                    dp_i_plus_1[key] = (dp_i_plus_1.get(key, 0) + count) % MOD
            dp[i + 1] = dp_i_plus_1

        total = 0
        for (prev_b, score_diff), count in dp[n].items():
            if score_diff > 0:
                total = (total + count) % MOD

        return total",1420533348
TimeGoGo,TimeGoGo,371,3610,python3,"from collections import Counter
from heapq import nlargest

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        
        freq = Counter(nums[:k])
        
        def calculate_x_sum(counter, x):
            most_frequent = nlargest(x, counter.items(), key=lambda item: (item[1], item[0]))

            return sum(val * count for val, count in most_frequent)
        
        result.append(calculate_x_sum(freq, x))
        

        for i in range(1, n - k + 1):
            freq[nums[i - 1]] -= 1
            if freq[nums[i - 1]] == 0:
                del freq[nums[i - 1]]
            
            freq[nums[i + k - 1]] += 1
            
            result.append(calculate_x_sum(freq, x))
        
        return result
",1420520324
Astatine,Astatine08,372,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional['TreeNode'], k: int) -> int:
        sizes = []
        def helper(node):
            if not node:
                return True, 0, 0
            left_perfect, left_height, left_size = helper(node.left)
            right_perfect, right_height, right_size = helper(node.right)
            if left_perfect and right_perfect and left_height == right_height:
                current_height = left_height + 1
                current_size = left_size + right_size + 1
                sizes.append(current_size)
                return True, current_height, current_size
            return False, max(left_height, right_height) + 1, left_size + right_size + 1
        helper(root)
        sizes.sort(reverse=True)
        return sizes[k-1] if k <= len(sizes) else -1
        ",1420524026
Astatine,Astatine08,372,3588,python3,"from collections import defaultdict

class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = 10**9 + 7

        creature_map = {'F': 0, 'W': 1, 'E': 2}
        Alice_moves = [creature_map[ch] for ch in s]

        Outcome = [
            [0, -1, 1],
            [1, 0, -1],
            [-1, 1, 0],
        ]

        dp_current = defaultdict(int)
        dp_current[(0, -1)] = 1

        for i in range(n):
            dp_next = defaultdict(int)
            Alice_move = Alice_moves[i]
            for (d, k_last), ways in dp_current.items():
                for Bob_move in range(3):
                    if Bob_move == k_last:
                        continue
                    delta = Outcome[Bob_move][Alice_move]
                    new_d = d + delta
                    dp_next[(new_d, Bob_move)] = (dp_next[(new_d, Bob_move)] + ways) % mod
            dp_current = dp_next

        ans = sum(ways for (d, _), ways in dp_current.items() if d > 0) % mod
        return ans
",1420533415
Astatine,Astatine08,372,3610,python3,"from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        freq = [0] * 51  

        for i in range(k):
            freq[nums[i]] += 1


        def get_top_x(freq):
            elements = [num for num in range(1, 51) if freq[num] > 0]

            elements.sort(key=lambda num: (-freq[num], -num))
            return elements[:x]

        top_x = get_top_x(freq)
        window_sum = sum(num for num in nums[:k] if num in top_x)
        answer.append(window_sum)

        for i in range(k, n):

            exiting_num = nums[i - k]
            freq[exiting_num] -= 1

            entering_num = nums[i]
            freq[entering_num] += 1

            top_x = get_top_x(freq)

            window_sum = sum(num for num in nums[i - k + 1:i + 1] if num in top_x)
            answer.append(window_sum)

        return answer
",1420522304
Arjun Kshirsagar,Arjun-Kshirsagar,373,3509,scala,"/**
 * Definition for a binary tree node.
 * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {
 *   var value: Int = _value
 *   var left: TreeNode = _left
 *   var right: TreeNode = _right
 * }
 */
object Solution {
    def kthLargestPerfectSubtree(root: TreeNode, k: Int): Int = {
        import scala.collection.mutable.ListBuffer

        val perfectSizes = ListBuffer[Int]()

        def helper(node: TreeNode): (Boolean, Int, Int) = {
            if (node == null) {
                (true, 0, 0)
            } else {
                val (leftPerfect, leftHeight, leftSize) = helper(node.left)
                val (rightPerfect, rightHeight, rightSize) = helper(node.right)

                if (leftPerfect && rightPerfect && leftHeight == rightHeight) {
                    val currentHeight = leftHeight + 1
                    val currentSize = leftSize + rightSize + 1
                    perfectSizes += currentSize
                    (true, currentHeight, currentSize)
                } else {
                    (false, 0, 0)
                }
            }
        }

        helper(root)

        val sortedSizes = perfectSizes.sorted(Ordering[Int].reverse)

        if (k <= sortedSizes.length) sortedSizes(k - 1)
        else -1
    }
}",1420525485
Arjun Kshirsagar,Arjun-Kshirsagar,373,3588,scala,"object Solution {
    def countWinningSequences(gameMoves: String): Int = {
        val MODULO = 1000000007
        val length = gameMoves.length

        val outcomes = Map(
            'F' -> 'E',
            'W' -> 'F',
            'E' -> 'W'
        )

        val aliceMoves = gameMoves.map {
            case 'F' | 'f' => 'F'
            case 'W' | 'w' => 'W'
            case 'E' | 'e' => 'E'
        }.toArray

        val offset = 1000
        val previousDP = Array.fill(3, 2 * offset + 1)(0L)
        val currentDP = Array.fill(3, 2 * offset + 1)(0L)

        for (moveIndex <- 0 until 3) {
            val bobMove = indexToChar(moveIndex)
            val (bobPoints, alicePoints) = calculatePoints(bobMove, aliceMoves(0), outcomes)
            val scoreDifference = bobPoints - alicePoints + offset
            if (scoreDifference >= 0 && scoreDifference <= 2 * offset) {
                previousDP(moveIndex)(scoreDifference.toInt) = 1
            }
        }

        for (i <- 1 until length) {
            for (prevMoveIndex <- 0 until 3) {
                for (scoreDiff <- 0 to 2 * offset) {
                    if (previousDP(prevMoveIndex)(scoreDiff) > 0) {
                        for (currentMoveIndex <- 0 until 3) {
                            if (currentMoveIndex != prevMoveIndex) {
                                val bobMove = indexToChar(currentMoveIndex)
                                val (bobPoints, alicePoints) = calculatePoints(bobMove, aliceMoves(i), outcomes)
                                val newScoreDiff = scoreDiff + (bobPoints - alicePoints)
                                if (newScoreDiff >= 0 && newScoreDiff <= 2 * offset) {
                                    currentDP(currentMoveIndex)(newScoreDiff) = 
                                        (currentDP(currentMoveIndex)(newScoreDiff) + previousDP(prevMoveIndex)(scoreDiff)) % MODULO
                                }
                            }
                        }
                    }
                }
            }

            for (moveIndex <- 0 until 3; scoreDiff <- 0 to 2 * offset) {
                previousDP(moveIndex)(scoreDiff) = currentDP(moveIndex)(scoreDiff)
                currentDP(moveIndex)(scoreDiff) = 0
            }
        }

        var totalWinningSequences = 0L
        for (moveIndex <- 0 until 3; scoreDiff <- 0 to 2 * offset if scoreDiff > offset) {
            totalWinningSequences = (totalWinningSequences + previousDP(moveIndex)(scoreDiff)) % MODULO
        }

        totalWinningSequences.toInt
    }

    private def indexToChar(moveIndex: Int): Char = moveIndex match {
        case 0 => 'F'
        case 1 => 'W'
        case 2 => 'E'
    }

    private def calculatePoints(bobMove: Char, aliceMove: Char, outcomes: Map[Char, Char]): (Int, Int) = {
        if (bobMove == aliceMove) {
            (0, 0)
        } else if (outcomes(bobMove) == aliceMove) {
            (1, 0)
        } else if (outcomes(aliceMove) == bobMove) {
            (0, 1)
        } else {
            (0, 0)
        }
    }
}
",1420533433
Arjun Kshirsagar,Arjun-Kshirsagar,373,3610,dart,"class Solution {
  List<int> findXSum(List<int> nums, int k, int x) {
    List<int> result = [];
    for (int i = 0; i <= nums.length - k; i++) {
      List<int> window = nums.sublist(i, i + k);
      Map<int, int> frequencyMap = {};

      for (int num in window) {
        frequencyMap[num] = (frequencyMap[num] ?? 0) + 1;
      }

      List<MapEntry<int, int>> sortedEntries = frequencyMap.entries.toList();
      sortedEntries.sort((a, b) {
        if (b.value != a.value) {
          return b.value.compareTo(a.value);
        } else {
          return b.key.compareTo(a.key);
        }
      });

      Set<int> topElements = {};
      for (int j = 0; j < sortedEntries.length && j < x; j++) {
        topElements.add(sortedEntries[j].key);
      }

      int sum = 0;
      for (int num in window) {
        if (topElements.contains(num)) {
          sum += num;
        }
      }

      result.add(sum);
    }
    return result;
  }
}",1420520000
Claron.A,claronantonyraj,374,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        
        def getSubtreeInfo(node):
            if not node:
                return (True, 0)  # An empty node is considered a perfect subtree with size 0.
            
            left_perfect, left_size = getSubtreeInfo(node.left)
            right_perfect, right_size = getSubtreeInfo(node.right)
            
            # A node is a root of a perfect binary subtree if both left and right subtrees are perfect
            # and they have the same size
            if left_perfect and right_perfect and left_size == right_size:
                # The size of this perfect subtree is 2 * left_size + 1 (it includes the root node)
                current_size = 2 * left_size + 1
                sizes.append(current_size)
                return (True, current_size)
            else:
                return (False, 0)  # Not a perfect subtree
        
        getSubtreeInfo(root)
        
        # Sort sizes in descending order
        sizes.sort(reverse=True)
        
        # Return the k-th largest size if it exists, otherwise return -1
        return sizes[k - 1] if k <= len(sizes) else -1
",1420520739
Claron.A,claronantonyraj,374,3588,java,"class Solution {
    private static final int MOD = 1000000007;

    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n][3][2 * n + 1]; // DP array to hold state
        int offset = n; // To handle negative indices for score difference
        
        // Mapping creatures to integers for easier DP management
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == 'F') a[i] = 0;
            else if (s.charAt(i) == 'W') a[i] = 1;
            else a[i] = 2;
        }

        // Initialize base cases
        for (int j = 0; j < 3; j++) {
            if (beats(j, a[0])) {
                dp[0][j][offset + 1] = 1; // Bob wins the first round
            } else if (a[0] == j) {
                dp[0][j][offset] = 1; // Tie in the first round
            } else {
                dp[0][j][offset - 1] = 1; // Alice wins the first round
            }
        }

        // Fill the DP table
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 3; j++) { // Bob's last creature
                for (int d = -i; d <= i; d++) { // Score difference range at index i
                    if (dp[i - 1][j][offset + d] == 0) continue; // No valid ways
                    for (int k = 0; k < 3; k++) { // Bob's current creature
                        if (k == j) continue; // Can't repeat the same creature
                        int newDiff = d;
                        if (beats(k, a[i])) {
                            newDiff += 1;
                        } else if (a[i] == k) {
                            newDiff += 0;
                        } else {
                            newDiff -= 1;
                        }
                        dp[i][k][offset + newDiff] = (dp[i][k][offset + newDiff] + dp[i - 1][j][offset + d]) % MOD;
                    }
                }
            }
        }

        // Count all valid sequences where Bob wins more rounds than Alice
        int result = 0;
        for (int j = 0; j < 3; j++) {
            for (int d = 1; d <= n; d++) { // Only count positive differences
                result = (result + dp[n - 1][j][offset + d]) % MOD;
            }
        }
        return result;
    }

    // Helper function to determine if creature x beats creature y
    private boolean beats(int x, int y) {
        return (x == 0 && y == 2) || (x == 1 && y == 0) || (x == 2 && y == 1);
    }
}
",1420523606
Claron.A,claronantonyraj,374,3610,python3,"from collections import Counter
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        
        # Traverse through all possible subarrays of length k
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            freq = Counter(subarray)
            
            # Sort elements based on frequency and then by value
            most_frequent = sorted(freq.items(), key=lambda item: (-item[1], -item[0]))
            
            # Sum up the top x most frequent elements
            current_sum = 0
            count = 0
            for num, count_num in most_frequent:
                if count >= x:
                    break
                current_sum += num * count_num
                count += 1
            
            # Append the result for the current subarray
            result.append(current_sum)
        
        return result

        ",1420519673
Arin Gupta,ArinGupta,375,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int>v;
    pair<int,int> dfs(TreeNode* root){
        if(root==nullptr){return {0,1};}
        pair<int,int>a = dfs(root->left);
        pair<int,int>b = dfs(root->right);
        int x = 1+a.first;
        int y = 1+b.first;
        if(x==y && a.second==1 && b.second==1){
            v.push_back(x+y-1);
        }
        return {x+y-1,(x==y) && (a.second==1) && (b.second==1)};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        if(v.size()<k){return -1;}
        sort(begin(v),end(v),greater<>());
        return v[k-1];
    }
};",1420524553
Arin Gupta,ArinGupta,375,3588,cpp,"class Solution {
private:
    int mod = 1e9+7;
    map<pair<char,char>,int>mp;
    vector<vector<vector<int>>>dp;
    int fx(string&s,string&t,int i,int j,int ct){
        int n = s.size();
        if(i>=n){return ct>0;}
        if(dp[i][j+1][ct+1000]!=-1){return dp[i][j+1][ct+1000];}
        int ans = 0;
        for(int k=0;k<3;k++){
            if(k==j){continue;}
            ans=(ans+fx(s,t,i+1,k,ct+mp[{s[i],t[k]}]))%mod;
        }
        return dp[i][j+1][ct+1000]=ans;
    }
public:
    int countWinningSequences(string s) {
        string t = ""FWE"";
        dp.assign(s.size(),vector<vector<int>>(4,vector<int>(2001,-1)));
        mp[{'F','F'}]=0;
        mp[{'W','W'}]=0;
        mp[{'E','E'}]=0;
        mp[{'F','E'}]=-1;
        mp[{'E','F'}]=1;
        mp[{'W','F'}]=-1;
        mp[{'F','W'}]=1;
        mp[{'E','W'}]=-1;
        mp[{'W','E'}]=1;
        return fx(s,t,0,-1,0);
    }
};",1420535044
Arin Gupta,ArinGupta,375,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int>v;
        int n = nums.size();
        for(int i=0;i<n-k+1;i++){
            unordered_map<int,int>mp;
            priority_queue<pair<int,int>>pq;
            int ans = 0,c=x;
            for(int j=i;j<i+k;j++){
                mp[nums[j]]++;
            }
            for(auto&it:mp){pq.push({it.second,it.first});}
            while(!pq.empty() && c>0){
                ans+=pq.top().first*pq.top().second;
                pq.pop();
                c--;
            }
            v.push_back(ans);
        }
        return v;
    }
};",1420520366
Pranav Pant,pranavpanttechy,376,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        checkPerfectSubtree(root, sizes);
        
        if (sizes.size() < k) {
            return -1;
        }
        
        sort(sizes.rbegin(), sizes.rend());
        return sizes[k - 1];
    }

private:
    pair<int, bool> checkPerfectSubtree(TreeNode* node, vector<int>& sizes) {
        if (!node) return {0, true};

        auto [leftHeight, leftPerfect] = checkPerfectSubtree(node->left, sizes);
        auto [rightHeight, rightPerfect] = checkPerfectSubtree(node->right, sizes);

        if (leftPerfect && rightPerfect && leftHeight == rightHeight) {
            int size = (1 << (leftHeight + 1)) - 1;
            sizes.push_back(size);
            return {leftHeight + 1, true};
        }

        return {max(leftHeight, rightHeight), false};
    }
};",1420524844
Pranav Pant,pranavpanttechy,376,3588,cpp,"#include <vector>
#include <string>
using namespace std;

typedef long long ll;
const int MOD = 1'000'000'007;

class Solution {
public:
int countWinningSequences(string s) {
    int n = s.length();
    
    vector<int> alice(n, 0);
    for(int i = 0; i < n; ++i){
        if(s[i] == 'F') alice[i] = 1;
        else if(s[i] == 'W') alice[i] = 2;
        else if(s[i] == 'E') alice[i] = 3;
        else if(s[i] == 'M') alice[i] = 2;
        else {
            alice[i] = 0;
        }
    }
    
    int beats[4] = {0, 3, 1, 2};
    int beats_inv[4] = {0, 2, 3, 1};
    
    vector<vector<ll>> DP_prev(4, vector<ll>(2*n +1, 0));
    DP_prev[0][n] = 1;
    
    for(int i = 0; i < n; ++i){
        int a = alice[i];
        
        vector<vector<ll>> DP_curr(4, vector<ll>(2*n +1, 0));
        
        for(int last_b = 0; last_b <= 3; ++last_b){
            for(int diff_shifted = max(0, n - i); diff_shifted <= min(2*n, n + i); ++diff_shifted){
                ll count = DP_prev[last_b][diff_shifted];
                if(count == 0) continue;
                
                for(int b = 1; b <= 3; ++b){
                    if(b == last_b) continue;
                    
                    int d_i = 0;
                    if(b == beats_inv[a]){
                        d_i = 1;
                    }
                    else if(b == beats[a]){
                        d_i = -1;
                    }
                    
                    int current_diff = (diff_shifted - n) + d_i;
                    
                    if(current_diff < -n || current_diff > n) continue;
                    
                    int new_shifted = current_diff + n;
                    DP_curr[b][new_shifted] = (DP_curr[b][new_shifted] + count) % MOD;
                }
            }
        }
        
        DP_prev = DP_curr;
    }
    
    ll total = 0;
    for(int last_b = 1; last_b <= 3; ++last_b){
        for(int diff_shifted = n + 1; diff_shifted <= 2*n; ++diff_shifted){
            total = (total + DP_prev[last_b][diff_shifted]) % MOD;
        }
    }
    
    return (int)total;
}
};",1420535413
Pranav Pant,pranavpanttechy,376,3610,cpp,"#include<unordered_map> 
#include<algorithm>

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        unordered_map<int, int> freq;
        int n = nums.size();
        
        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }
        res.push_back(getXSum(freq, x));

        for (int i = k; i < n; ++i) {
            freq[nums[i - k]]--;
            if (freq[nums[i - k]] == 0) {
                freq.erase(nums[i - k]);
            }
            freq[nums[i]]++;
            res.push_back(getXSum(freq, x));
        }

        return res;
    }

private:
    int getXSum(unordered_map<int, int>& freq, int x) {
        vector<pair<int, int>> f(freq.begin(), freq.end());

        sort(f.begin(), f.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            if (a.second == b.second) return a.first > b.first;
            return a.second > b.second;
        });

        int sum = 0;
        for (int i = 0; i < min(x, (int)f.size()); ++i) {
            sum += f[i].first * f[i].second;
        }
        return sum;
    }
};",1420522735
Chris Ho,Chris_ho,378,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def is_perfect(node): # height, perfect
            if not node:
                return 0, True
            lh, lp = is_perfect(node.left)
            rh, rp = is_perfect(node.right)
            if lp and rp and lh==rh:
                return lh+1, True
            return max(lh,rh), False
        
        def recur(node,arr):
            if not node:
                return
            h,p = is_perfect(node)
            if p:
                arr.append(2**h-1)
            recur(node.left,arr)
            recur(node.right,arr)
        # get the list of sizes
        arr = []
        recur(root,arr)
        arr.sort()
        arr.reverse()
        return arr[k-1] if k<=len(arr) else -1
",1420525500
Chris Ho,Chris_ho,378,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        # F & E -> F
        # W & F -> W
        # E & W -> E +1
        # Both same -> No point
        n = len(s)
        mp = {'F': 0, 'W': 1, 'E': 2}
        sm = [mp[c] for c in s]
        d = [[0]*3 for _ in range(3)]
        d[0][2], d[2][0] = 1, -1
        d[1][0], d[0][1] = 1, -1
        d[2][1], d[1][2] = 1, -1
        dp = [[[0]*(2*n+1) for _ in range(4)] for _ in range(n+1)]
        ofs = n
        dp[0][3][ofs] = 1
        for i in range(n):
            am = sm[i]
            for pb in range(4):
                for sd in range(2*n+1):
                    cnt = dp[i][pb][sd]
                    if cnt == 0:
                        continue
                    for nb in range(3):
                        if pb != 3 and nb == pb:
                            continue
                        ds = d[nb][am]
                        nsd = sd - ofs + ds
                        nds = nsd + ofs
                        if 0 <= nds <= 2*n:
                            dp[i+1][nb][nds] = (dp[i+1][nb][nds] + cnt) % MOD
        ans = 0
        for pb in range(3):
            for sd in range(ofs+1, 2*n+1):
                ans = (ans + dp[n][pb][sd]) % MOD
        return ans",1420536550
Chris Ho,Chris_ho,378,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums) - k + 1):
            sub = nums[i:i + k]
            cnt = Counter(sub)
            freq = sorted(cnt.items(), key=lambda y: (-y[1], -y[0]))[:x]
            s = sum([v[0] * v[1] for v in freq])
            res.append(s)
        return res
        ",1420518862
therealpratyushraman,therealpratyushraman,380,3509,java,"class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
    List<Integer> sizes = new ArrayList<>();
    findPerfectSubtrees(root, sizes);
    Collections.sort(sizes, Collections.reverseOrder());
    return k <= sizes.size() ? sizes.get(k - 1) : -1;
    }

    private int[] findPerfectSubtrees(TreeNode node, List<Integer> sizes) {
    if (node == null) return new int[]{1, 0};
    int[] left = findPerfectSubtrees(node.left, sizes);
    int[] right = findPerfectSubtrees(node.right, sizes);
    if (left[0] == 1 && right[0] == 1 && left[1] == right[1]) {
    int size = left[1] + right[1] + 1;
    sizes.add(size);
    return new int[]{1, size};
    }
    return new int[]{0, 0};
    }
}",1420530855
therealpratyushraman,therealpratyushraman,380,3588,java,"class Solution {
    public int countWinningSequences(String s) {
    int n = s.length();
    int MOD = 1000000007;
    int[][][] dp = new int[n + 1][4][2 * n + 1];
    dp[0][3][n] = 1;
    int[] winsOver = {2, 0, 1};
    int[] aliceMoves = new int[n];
    for (int i = 0; i < n; i++) {
    char c = s.charAt(i);
    aliceMoves[i] = c == 'F' ? 0 : c == 'W' ? 1 : 2;
    }
    for (int i = 0; i < n; i++) {
    for (int prev = 0; prev < 4; prev++) {
    for (int diff = -n; diff <= n; diff++) {
    int val = dp[i][prev][diff + n];
    if (val == 0) continue;
    for (int bobMove = 0; bobMove < 3; bobMove++) {
    if (i > 0 && bobMove == prev) continue;
    int outcome;
    if (bobMove == aliceMoves[i]) {
    outcome = 0;
    } else if (winsOver[bobMove] == aliceMoves[i]) {
    outcome = 1;
    } else {
    outcome = -1;
    }
    int newDiff = diff + outcome;
    dp[i + 1][bobMove][newDiff + n] = (dp[i + 1][bobMove][newDiff + n] + val) % MOD;
    }
    }
    }
    }
    int result = 0;
    for (int prev = 0; prev < 3; prev++) {
    for (int diff = 1; diff <= n; diff++) {
    result = (result + dp[n][prev][diff + n]) % MOD;
    }
    }
    return result;
    }
}",1420527053
therealpratyushraman,therealpratyushraman,380,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
    int n = nums.length, answer[] = new int[n - k + 1];
    for (int i = 0; i <= n - k; i++) {
    int[] freq = new int[51];
    for (int j = i; j < i + k; j++) freq[nums[j]]++;
    List<Integer> elements = new ArrayList<>();
    for (int val = 1; val <= 50; val++) if (freq[val] > 0) elements.add(val);
    Collections.sort(elements, (a, b) -> freq[b] != freq[a] ? freq[b] - freq[a] : b - a);
    int sum = 0;
    for (int m = 0; m < x && m < elements.size(); m++) sum += freq[elements.get(m)] * elements.get(m);
    answer[i] = sum;
    }
    return answer;
    }
}",1420537571
ceaxyz002,ceaxyz002,381,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        p = []
    
        def dfs(node):
            if not node:
                return (True, 0, 0)
            left_perfect, left_height, left_size = dfs(node.left)
            right_perfect, right_height, right_size = dfs(node.right)
            is_perfect = left_perfect and right_perfect and left_height == right_height
            height = left_height + 1
            size = left_size + right_size + 1
            if is_perfect:
                p.append(size)
            return (is_perfect, height, size)

        dfs(root)
        p.sort(reverse=True)
        return p[k - 1] if k <= len(p) else -1





",1420532011
ceaxyz002,ceaxyz002,381,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        c = ['F', 'W', 'E']
        mod = 10**9 + 7
        total = 0
        dp = [{} for _ in range(n + 1)]
        dp[0][(None, 0)] = 1

        def get_point_diff(a, b):
            if a == b:
                return 0
            elif (b == 'F' and a == 'E') or (b == 'E' and a == 'W') or (b == 'W' and a == 'F'):
                return +1
            else:
                return -1

        for i in range(n):
            dp_i = dp[i]
            dp_i1 = dp[i + 1]
            for (b_prev, d), count in dp_i.items():
                for b_cur in c:
                    if b_prev is None or b_cur != b_prev:
                        delta = get_point_diff(s[i], b_cur)
                        d_new = d + delta
                        key = (b_cur, d_new)
                        dp_i1[key] = dp_i1.get(key, 0) + count

        for (b_prev, d), count in dp[n].items():
            if d > 0:
                total = (total + count) % mod
        return total % mod",1420537946
ceaxyz002,ceaxyz002,381,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ret = []
        for i in range(n - k + 1):
            subarray = nums[i:i+k]
            counts = [0] * 57
            for num in subarray:
                counts[num] +=1
            u = set(subarray)
            s = sorted(u, key=lambda num: (-counts[num], -num))
            t = set(s[:x])
            ans = sum(num for num in subarray if num in t)
            ret.append(ans)
        return ret

",1420527479
Apple,weeder,382,3509,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution {
public:
    vector<int> sizes;
    
    tuple<bool, int, int> dfs(TreeNode* node) {
        if (!node) {
            return {true, 0, 0};
        }
        
        auto [left, lh, ls] = dfs(node->left);
        auto [rp, rh, rs] = dfs(node->right);
        
        bool isPerfect = left && rp && (lh == rh);
        int height = max(lh, rh) + 1;
        int size = ls + rs + 1;
        
        if (isPerfect) {
            sizes.push_back(size);
        }
        
        return {isPerfect, height, size};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(all(sizes), greater<int>());
        if (k > sizes.size()) {
            return -1;
        } 
            return sizes[k - 1];
        
    }
};
",1420529916
Apple,weeder,382,3588,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution {
public:
    int countWinningSequences(string s) {
        int n = sz(s);
        
        vvi preSum(3,vi(3,0));
        for (int a = 0; a < 3; ++a) {
            for (int b = 0; b < 3; ++b) {
                if (a == b) {
                    preSum[a][b] = 0;
                } else if ((a == 0 && b == 2) || (a == 2 && b == 1) || (a == 1 && b == 0)) {
                    preSum[a][b] = -1;
                } else {
                    preSum[a][b] = 1;
                }
            }
        }

        vector<int> S(n);
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') S[i] = 0;
            else if (s[i] == 'W') S[i] = 1;
            else if (s[i] == 'E') S[i] = 2;
        }
        
        vector<vvi> dp(n+1, vvi(2*n+1, vi(4, 0)));
        dp[0][n][3] = 1;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= 2*n; ++j) {
                for (int k = 0; k <= 3; ++k) {
                    int curr_dp = dp[i][j][k];
                    if (curr_dp == 0) continue;
                    for (int b_next = 0; b_next <=2; ++b_next) {
                        if (k != 3 && b_next == k) continue;
                        int score = preSum[S[i]][b_next];
                        int d_next = (j - n) + score;
                        int d_next_shifted = d_next + n;
                        if (d_next_shifted < 0 || d_next_shifted > 2*n) continue;
                        dp[i+1][d_next_shifted][b_next] = (dp[i+1][d_next_shifted][b_next] + curr_dp) % MOD;
                    }
                }
            }
        }

        int ans = 0;
        for (int i = n+1; i <= 2*n; ++i) {
            for (int j = 0; j <=2; ++j) {
                ans = (ans + dp[n][i][j]) % MOD;
            }
        }
        return ans;
    }
};
",1420524108
Apple,weeder,382,3610,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define pansent(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
// typedef vector<lli> vi;
// typedef vector<vll> vvll;

class Solution
{
public:
    vi ans;
    umpi freq;
    vi findXSum(vector<int> &a, int b, int c)
    {
        int n = sz(a);
        map<int, multiset<int, greater<int>>, greater<int>> freqVals;
        initFreq(a, b, freq, freqVals);
        ans.push_back(computeSum(freqVals, a, 0, b, c));
        for (int i = b; i < n; ++i)
        {
            int outNum = a[i - b];
            int inNum = a[i];
            updateFreq(outNum, inNum, freq, freqVals);
            ans.push_back(computeSum(freqVals, a, i - b + 1, b, c));
        }
        return ans;
    }

private:
    void initFreq(vector<int> &a, int b, unordered_map<int, int> &freq,
                  map<int, multiset<int, greater<int>>, greater<int>> &freqVals)
    {
        loop(i, 0, b)
        {
            int num = a[i];
            int prevFreq = freq[num];
            freq[num]++;
            int currFreq = freq[num];
            if (prevFreq > 0)
            {
                freqVals[prevFreq].erase(freqVals[prevFreq].find(num));
                if (freqVals[prevFreq].empty())
                {
                    freqVals.erase(prevFreq);
                }
            }
            freqVals[currFreq].insert(num);
        }
    }

    void updateFreq(int outNum, int inNum, unordered_map<int, int> &freq,
                    map<int, multiset<int, greater<int>>, greater<int>> &freqVals)
    {
        removeNum(outNum, freq, freqVals);
        addNum(inNum, freq, freqVals);
    }

    void removeNum(int num, unordered_map<int, int> &freq,
                   map<int, multiset<int, greater<int>>, greater<int>> &freqVals)
    {
        int prevFreq = freq[num];
        freq[num]--;
        int currFreq = freq[num];
        freqVals[prevFreq].erase(freqVals[prevFreq].find(num));
        if (freqVals[prevFreq].empty())
        {
            freqVals.erase(prevFreq);
        }
        if (currFreq > 0)
        {
            freqVals[currFreq].insert(num);
        }
        else
        {
            freq.erase(num);
        }
    }

    void addNum(int num, unordered_map<int, int> &freq,
                map<int, multiset<int, greater<int>>, greater<int>> &freqVals)
    {
        int prevFreq = freq[num];
        if (prevFreq > 0)
        {
            freqVals[prevFreq].erase(freqVals[prevFreq].find(num));
            if (freqVals[prevFreq].empty())
            {
                freqVals.erase(prevFreq);
            }
        }
        freq[num]++;
        int currFreq = freq[num];
        freqVals[currFreq].insert(num);
    }

    long long computeSum(map<int, multiset<int, greater<int>>, greater<int>> &freqVals,
                         vector<int> &a, int startIdx, int b, int c)
    {
        unordered_set<int> topElems;
        int count = 0;
        for (auto it = freqVals.begin(); it != freqVals.end() && count < c; ++it)
        {
            for (int val : it->second)
            {
                if (count < c)
                {
                    topElems.insert(val);
                    ++count;
                }
                else
                {
                    break;
                }
            }
            if (count >= c)
            {
                break;
            }
        }
        long long ans = 0;
        for (int i = startIdx; i < startIdx + b; ++i)    if (topElems.count(a[i]))ans += a[i];
        
        return ans;
    }
};
",1420538956
Soumya,soumyaww,383,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        if not root: return -1
        arr = []

        def solve(node: Optional[TreeNode]):
            if node is None: return True, 0, 0

            leftP, leftH, leftS = solve(node.left)
            rightP, rightH, rightS = solve(node.right)

            if leftP and rightP and leftH == rightH:
                currH = leftH + 1
                currS = leftS + rightS + 1
                arr.append(currS)
                return True, currH, currS
            
            currH = max(leftH, rightH) + 1
            currS = leftS + rightS + 1
            return False, currH, currS

        solve(root)

        if len(arr) < k: return -1
        res = sorted(arr, reverse=True)
        return res[k - 1]",1420529536
Soumya,soumyaww,383,3588,python3,"MOD=10**9+7

class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        cm, b = {'F': 0, 'W': 1, 'E': 2}, {0: 2, 1: 0, 2: 1}
        am = [cm[c] for c in s]
        p = [[0] * (2 * n + 1) for _ in range(4)]
        p[3][n] = 1
        res = 0
        
        for i in range(n):
            c = [[0] * (2 * n + 1) for _ in range(4)]
            for l in range(4):
                for d in range(-i, i + 1):
                    if d + n < 0 or d + n > 2 * n: continue
                    if p[l][d + n] != 0:
                        for nc in range(3):
                            if l != 3 and nc == l: continue
                            a = am[i]
                            bc = nc
                            if b[bc] == a: nd = d + 1
                            elif b[a] == bc: nd = d - 1
                            else: nd = d
                            if -n <= nd <= n:
                                nsd = nd + n
                                if 0 <= nsd <= 2 * n: c[nc][nsd] = (c[nc][nsd] + p[l][d + n]) % MOD
            p = c
        for l in range(3):
            for d in range(1, n + 1):
                if (d + n) <= 2 * n: res = (res + p[l][d+n]) % MOD
        return res

",1420540184
Soumya,soumyaww,383,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        for i in range(n - k + 1):
            win = nums[i:i + k]
            cnts = Counter(win)
            st = sorted(cnts.items(), key=lambda item: (-item[1], -item[0]))
            top_x = set([num for num, cnt in st[:x]])
            curr = sum(num for num in win if num in top_x)
            res.append(curr)

        return res",1420523026
çağrı Kaymak,cagr,384,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_sizes = []

        def traverse(root):
            if root == None:
                return True, 0
            
            is_perf_l, s_l = traverse(root.left)
            is_perf_r, s_r = traverse(root.right)

            if is_perf_l and is_perf_r and s_l == s_r:
                perfect_sizes.append(s_l + s_r + 1)
            
            return is_perf_l and is_perf_r and s_l == s_r, s_l + s_r + 1
        traverse(root)
        perfect_sizes = sorted(perfect_sizes, reverse=True)
        if len(perfect_sizes) < k:
            return -1
        return perfect_sizes[k-1]

            
        ",1420527849
çağrı Kaymak,cagr,384,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        def calc_point(a, b):
            if a == ""F"" and b == ""E"":
                return -1
            elif a == ""W"" and b == ""F"":
                return -1
            elif a == ""E"" and b == ""W"":
                return -1
            elif b == ""F"" and a == ""E"":
                return 1
            elif b == ""W"" and a == ""F"":
                return 1
            elif b == ""E"" and a == ""W"":
                return 1  
            return 0

        '''
        dp(i, p): from ith index with p points ahead
        '''   
        MOD = 10**9 + 7
        @cache 
        def dp(i, p, prev):
            if i == len(s):
                return int(p > 0)
            total_c = 0
            for b_m in [""F"", ""W"", ""E""]:
                if b_m == prev:
                    continue
                new_p = calc_point(s[i], b_m)
                total_c += dp(i+1, p + new_p, b_m)
            return total_c % MOD

        return dp(0,0, ""z"")


             ",1420535559
çağrı Kaymak,cagr,384,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def process(start):
            nonlocal k, x
            counts = Counter(nums[start:start + k])
            freq_num = [(v,kk) for kk,v in counts.items()]
            freq_num = sorted(freq_num, reverse=True)[:x]
            summ = 0
            for v, kk in freq_num:
                summ += v * kk
            return summ
        
        res = []
        

        for i in range(len(nums) - k + 1):
            summ = process(i)
            res.append(summ)
        return res

        ",1420522021
Manikanta Venkateswarlu,orugantimanikan1,387,3509,cpp,"#include <vector>
#include <algorithm>

/*struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};*/

class Solution {
public:
    vector<int> perfectSizes;
    
    
    int checkPerfect(TreeNode* root) {
        if (!root) return 0;
        
        int leftSize = checkPerfect(root->left);
        int rightSize = checkPerfect(root->right);
        
       
        if (leftSize == rightSize && leftSize != -1) {
            int size = 1 + leftSize + rightSize;
            perfectSizes.push_back(size);
            return size;
        }
        
        
        return -1;
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        perfectSizes.clear(); 
        checkPerfect(root);
        
       
        sort(perfectSizes.rbegin(), perfectSizes.rend());
        
     
        return perfectSizes.size() >= k ? perfectSizes[k - 1] : -1;
    }
};
",1420521999
Manikanta Venkateswarlu,orugantimanikan1,387,3588,cpp,"#include <vector>
#include <string>
#include <cstring>
using namespace std;

const int MOD = 1e9 + 7;

class Solution {
public:
    int dp[1001][2001][3];
    
   
    bool beats(char bob_move, char alice_move) {
        if ((bob_move == 'F' && alice_move == 'E') ||
            (bob_move == 'W' && alice_move == 'F') ||
            (bob_move == 'E' && alice_move == 'W')) {
            return true;
        }
        return false;
    }
    
    
    int solve(const string &s, int i, int diff, int last_move, int n) {
        if (i == n) {
            return (diff > 0) ? 1 : 0;  
        }
        
        if (last_move != -1 && dp[i][diff + n][last_move] != -1) {
            return dp[i][diff + n][last_move];
        }
        
        int ans = 0;
        
       
        for (int bob_move = 0; bob_move < 3; ++bob_move) {
            if (bob_move == last_move) continue;  
            
            int new_diff = diff;
            if (beats(bob_move == 0 ? 'F' : bob_move == 1 ? 'W' : 'E', s[i])) {
                new_diff++;
            } else if (beats(s[i], bob_move == 0 ? 'F' : bob_move == 1 ? 'W' : 'E')) {
                new_diff--;
            }
            
            ans = (ans + solve(s, i + 1, new_diff, bob_move, n)) % MOD;
        }
        
        if (last_move != -1) {
            dp[i][diff + n][last_move] = ans;  // Memoize the result
        }
        
        return ans;
    }
    
    int countWinningSequences(string s) {
        int n = s.size();
        memset(dp, -1, sizeof(dp));  
        return solve(s, 0, 0, -1, n);  
    }
};
",1420536160
Manikanta Venkateswarlu,orugantimanikan1,387,3610,cpp,"#include <vector>
#include <map>
#include <unordered_map>
#include <queue>

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer(n - k + 1);
        
        
        auto getXSum = [&](vector<int>& subarray, int x) {
            unordered_map<int, int> freq;
            for (int num : subarray) {
                freq[num]++;
            }
            
            
            priority_queue<pair<int, int>> pq;
            for (auto& [num, count] : freq) {
                pq.push({count, num}); 
            }
            
            int sum = 0;
            for (int i = 0; i < x && !pq.empty(); i++) {
                auto [count, num] = pq.top();
                pq.pop();
                sum += count * num;
            }
            
            return sum;
        };
        
     
        for (int i = 0; i <= n - k; i++) {
            vector<int> subarray(nums.begin() + i, nums.begin() + i + k);
            answer[i] = getXSum(subarray, x);
        }
        
        return answer;
    }
};
",1420519345
Himanjit Tamuli,H09,388,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    vector<int> perfectSubtreeSizes;

    pair<bool, pair<int, int>> dfs(TreeNode* node) {
        if (!node) {
            return {true, {0, 0}};
        }

        auto left = dfs(node->left);
        auto right = dfs(node->right);

        bool isLeftPerfect = left.first;
        bool isRightPerfect = right.first;
        int leftHeight = left.second.first;
        int rightHeight = right.second.first;
        int leftSize = left.second.second;
        int rightSize = right.second.second;

        if (isLeftPerfect && isRightPerfect && leftHeight == rightHeight) {
            int height = leftHeight + 1;
            int size = leftSize + rightSize + 1;
            perfectSubtreeSizes.push_back(size);
            return {true, {height, size}};
        } else {
            return {false, {max(leftHeight, rightHeight), 0}};
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        perfectSubtreeSizes.clear();

        dfs(root);

        sort(perfectSubtreeSizes.rbegin(), perfectSubtreeSizes.rend());

        if (perfectSubtreeSizes.size() < k) {
            return -1;
        } else {
            return perfectSubtreeSizes[k - 1];
        }
    }
};",1420532405
Himanjit Tamuli,H09,388,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.length();

        vector<int> alice(n);
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') {
                alice[i] = 0;
            } else if (s[i] == 'W') {
                alice[i] = 1;
            } else if (s[i] == 'E') {
                alice[i] = 2;
            }
        }

        vector<vector<vector<int>>> dp(
            n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, 0)));
        dp[0][3][n] = 1;

        for (int i = 0; i < n; ++i) {
            for (int b = 0; b < 4; ++b) {
                for (int d = 0; d <= 2 * n; ++d) {
                    int ways = dp[i][b][d];
                    if (ways == 0)
                        continue;
                    for (int c = 0; c < 3; ++c) {
                        if (c == b)
                            continue;

                        int sd;
                        int bob = c;
                        int alice_creature = alice[i];
                        if (bob == alice_creature) {
                            sd = 0;
                        } else {
                            int diff = (bob - alice_creature + 3) % 3;
                            if (diff == 1) {
                                sd = 1;
                            } else {
                                sd = -1;
                            }
                        }
                        int nd = d + sd;
                        if (nd < 0 || nd > 2 * n)
                            continue;
                        dp[i + 1][c][nd] = (dp[i + 1][c][nd] + ways) % MOD;
                    }
                }
            }
        }

        int result = 0;
        for (int b = 0; b < 3; ++b) {
            for (int d = n + 1; d <= 2 * n; ++d) {
                result = (result + dp[n][b][d]) % MOD;
            }
        }

        return result;
    }
};",1420542470
Himanjit Tamuli,H09,388,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;

        for (int i = 0; i <= n - k; i++) {

            vector<int> freq(51, 0);
            for (int j = i; j < i + k; j++) {
                freq[nums[j]]++;
            }

            vector<pair<int, int>> elements;
            for (int num = 1; num <= 50; num++) {
                if (freq[num] > 0) {
                    elements.emplace_back(make_pair(freq[num], num));
                }
            }

            sort(elements.begin(), elements.end(),
                 [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
                     if (a.first != b.first) {
                         return a.first > b.first;
                     }
                     return a.second > b.second;
                 });

            int sum = 0;
            int count = min(x, (int)elements.size());
            for (int j = 0; j < count; j++) {
                sum += elements[j].first * elements[j].second;
            }

            answer.push_back(sum);
        }

        return answer;
    }
};",1420523819
Ramakanth R Gunishetty,ramakanth_coder-08_,389,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
*/
class Solution {
public:
    vector<int> subtreeSizes;
    
    pair<int, bool> traverse(TreeNode* node) {
        if (!node) return {0, true};
        
        auto [leftSize, leftPerfect] = traverse(node->left);
        auto [rightSize, rightPerfect] = traverse(node->right);
        
        if (leftPerfect && rightPerfect && leftSize == rightSize) {
            int currentSize = 1 + leftSize + rightSize;
            subtreeSizes.push_back(currentSize);
            return {currentSize, true};
        }
        
        return {0, false};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        traverse(root);
        if (subtreeSizes.size() < k) return -1;
        
        sort(subtreeSizes.rbegin(), subtreeSizes.rend());
        return subtreeSizes[k - 1];
    }
};

",1420530463
Ramakanth R Gunishetty,ramakanth_coder-08_,389,3588,cpp,"class Solution {
public:
    int countWinningSequences(string t) {
        int m = t.size();
        vector<int> a_moves(m);
        
        for (int i = 0; i < m; ++i) {
            if (t[i] == 'F') a_moves[i] = 0;
            else if (t[i] == 'W') a_moves[i] = 1;
            else if (t[i] == 'E') a_moves[i] = 2;
        }
        
        int wins[3] = {2, 0, 1};      
        const int MOD = 1e9 + 7;
        int max_score_diff = 2 * m;          
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(3, vector<int>(2 * m + 1, 0)));
        
        for (int b_move = 0; b_move < 3; ++b_move) {
            int result = calcOutcome(b_move, a_moves[0], wins);
            int score_diff = m + result;  
            dp[0][b_move][score_diff] = 1;
        }
        
        for (int i = 1; i < m; ++i) {
            int curr_state = i % 2;
            int prev_state = (i - 1) % 2;
            
            for (int b_move = 0; b_move < 3; ++b_move) {
                fill(dp[curr_state][b_move].begin(), dp[curr_state][b_move].end(), 0);
            }
            for (int last_b_move = 0; last_b_move < 3; ++last_b_move) {
                for (int score_diff = 0; score_diff <= 2 * m; ++score_diff) {
                    if (dp[prev_state][last_b_move][score_diff] == 0) continue;
                    for (int b_move = 0; b_move < 3; ++b_move) {
                        if (b_move == last_b_move) continue;  
                        int result = calcOutcome(b_move, a_moves[i], wins);
                        int new_score_diff = score_diff + result;
                        if (new_score_diff < 0 || new_score_diff > 2 * m) continue;
                        dp[curr_state][b_move][new_score_diff] = (dp[curr_state][b_move][new_score_diff] + dp[prev_state][last_b_move][score_diff]) % MOD;
                    }
                }
            }
        }
        
        int total_sequences = 0;
        for (int b_move = 0; b_move < 3; ++b_move) {
            for (int score_diff = m + 1; score_diff <= 2 * m; ++score_diff) {
                total_sequences = (total_sequences + dp[(m - 1) % 2][b_move][score_diff]) % MOD;
            }
        }
        return total_sequences;
    }
    
    int calcOutcome(int b_move, int a_move, int wins[]) {
        if (b_move == a_move) return 0;                 
        else if (wins[b_move] == a_move) return 1;     
        else return -1;                                       
    }
};
",1420542502
Ramakanth R Gunishetty,ramakanth_coder-08_,389,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int b, int c) {
        vector<int> d;
        
        for (int e = 0; e <= a.size() - b; ++e) {
            unordered_map<int, int> f;
            
            for (int g = e; g < e + b; ++g) {
                f[a[g]]++;
            }
            
            vector<pair<int, int>> h(f.begin(), f.end());
            sort(h.begin(), h.end(), [](const pair<int, int>& i, const pair<int, int>& j) {
                if (i.second == j.second) {
                    return i.first > j.first;
                }
                return i.second > j.second;
            });
            
            int k = 0;
            for (int l = 0; l < min(c, (int)h.size()); ++l) {
                k += h[l].first * h[l].second;
            }
            
            d.push_back(k);
        }
        
        return d;
    }
};",1420521648
Partha Sarathi Panda,parthasarathipanda2706,390,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private List<Integer> perfectSubtreeSizes = new ArrayList<>();

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        if (root == null) {
            return -1;
        }
        
        findPerfectSubtrees(root);

        if (perfectSubtreeSizes.size() < k) {
            return -1;
        }

        Collections.sort(perfectSubtreeSizes, Collections.reverseOrder());
        return perfectSubtreeSizes.get(k - 1);
    }

    private int[] findPerfectSubtrees(TreeNode node) {
        if (node == null) {
            return new int[]{1, 0};
        }

        int[] left = findPerfectSubtrees(node.left);
        int[] right = findPerfectSubtrees(node.right);

        if (left[0] == 1 && right[0] == 1 && left[1] == right[1]) {
            int size = left[1] + right[1] + 1;
            perfectSubtreeSizes.add(size);
            return new int[]{1, size};
        }

        return new int[]{0, 0};
    }
}",1420525776
Partha Sarathi Panda,parthasarathipanda2706,390,3588,java,"class Solution {
    private static final int MOD = 1000000007;
    private int[][] points = {
        {0, -1, 1},
        {1, 0, -1},
        {-1, 1, 0}
    };
    private int n;
    private int[][][] memo;
    private String s;

    public int countWinningSequences(String s) {
        this.s = s;
        this.n = s.length();
        this.memo = new int[n][3][2 * n + 1];
        for (int[][] m : memo) {
            for (int[] row : m) {
                Arrays.fill(row, -1);
            }
        }
        return countSequences(0, -1, 0);
    }

    private int countSequences(int i, int lastBobMove, int diff) {
        if (i == n) {
            return diff > 0 ? 1 : 0;
        }
        if (lastBobMove != -1 && memo[i][lastBobMove][diff + n] != -1) {
            return memo[i][lastBobMove][diff + n];
        }
        int res = 0;
        int aliceMove = s.charAt(i) == 'F' ? 0 : s.charAt(i) == 'W' ? 1 : 2;
        for (int bobMove = 0; bobMove < 3; bobMove++) {
            if (bobMove == lastBobMove) continue;
            res = (res + countSequences(i + 1, bobMove, diff + points[bobMove][aliceMove])) % MOD;
        }
        if (lastBobMove != -1) {
            memo[i][lastBobMove][diff + n] = res;
        }
        return res;
    }
}
",1420542593
Partha Sarathi Panda,parthasarathipanda2706,390,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] answer = new int[n - k + 1];
        Map<Integer, Integer> freqMap = new HashMap<>();
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] == b[1] ? b[0] - a[0] : b[1] - a[1]);

        for (int i = 0; i < k; i++) {
            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);
        }

        answer[0] = calculateXSum(freqMap, pq, x);

        for (int i = 1; i <= n - k; i++) {
            int toRemove = nums[i - 1];
            int toAdd = nums[i + k - 1];

            freqMap.put(toRemove, freqMap.get(toRemove) - 1);
            if (freqMap.get(toRemove) == 0) {
                freqMap.remove(toRemove);
            }

            freqMap.put(toAdd, freqMap.getOrDefault(toAdd, 0) + 1);

            answer[i] = calculateXSum(freqMap, pq, x);
        }

        return answer;
    }

    private int calculateXSum(Map<Integer, Integer> freqMap, PriorityQueue<int[]> pq, int x) {
        pq.clear();

        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            pq.offer(new int[] {entry.getKey(), entry.getValue()});
        }

        int sum = 0;
        int count = 0;

        while (!pq.isEmpty() && count < x) {
            int[] top = pq.poll();
            sum += top[0] * top[1];
            count++;
        }

        return sum;
    }
}
",1420520049
Akshat_Gupta04,Akshat_Gupta04,391,3509,cpp,"class Solution {
public:
    // Helper function to determine the size of the perfect subtree
    pair<int, bool> dfs(TreeNode* root, vector<int>& sizes) {
        if (!root) return {0, true}; // Base case: empty tree is perfect with size 0
        
        auto [leftSize, isLeftPerfect] = dfs(root->left, sizes);
        auto [rightSize, isRightPerfect] = dfs(root->right, sizes);

        // Check if the current subtree is perfect
        if (isLeftPerfect && isRightPerfect && leftSize == rightSize) {
            int currentSize = leftSize + rightSize + 1; // Total nodes in this perfect subtree
            sizes.push_back(currentSize);
            return {currentSize, true};
        }
        return {0, false}; // Not a perfect subtree
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        
        // Perform DFS to find all perfect subtree sizes
        dfs(root, sizes);
        
        // Sort the sizes in descending order
        sort(sizes.rbegin(), sizes.rend());
        
        // Check if k-th largest exists
        if (k > sizes.size()) return -1;
        return sizes[k - 1];
    }
};",1420526682
Akshat_Gupta04,Akshat_Gupta04,391,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    int countWinningSequences(string s) {
        int n = s.size();

        // Use a rolling 2D DP table: current and previous state
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(2 * n + 1, vector<int>(4, 0)));

        // Initialize the base case: at round 0, with a score difference of 0 and no last move
        dp[0][n][3] = 1;  // Use 3 as the placeholder for ""no previous move""

        // Iterate over all rounds
        for (int i = 0; i < n; ++i) {
            char aliceMove = s[i];

            // Reset the current DP table for this round
            for (int diff = 0; diff <= 2 * n; ++diff) {
                for (int lastMove = 0; lastMove < 4; ++lastMove) {
                    dp[(i + 1) % 2][diff][lastMove] = 0;
                }
            }

            // Iterate over all valid states from the previous round
            for (int diff = 0; diff <= 2 * n; ++diff) {
                for (int lastMove = 0; lastMove < 4; ++lastMove) {
                    if (dp[i % 2][diff][lastMove] == 0) continue;  // Skip if this state is unreachable

                    // Try all possible moves for Bob, avoiding consecutive duplicate moves
                    for (int bobMove = 0; bobMove < 3; ++bobMove) {
                        if (bobMove == lastMove) continue;  // Skip consecutive duplicate moves

                        // Calculate the new difference in points
                        int newDiff = diff;
                        if (aliceMove == 'F' && bobMove == 1) newDiff++;  // Bob wins with 'W'
                        if (aliceMove == 'W' && bobMove == 2) newDiff++;  // Bob wins with 'E'
                        if (aliceMove == 'E' && bobMove == 0) newDiff++;  // Bob wins with 'F'
                        if (aliceMove == 'F' && bobMove == 2) newDiff--;  // Alice wins with 'F' vs 'E'
                        if (aliceMove == 'W' && bobMove == 0) newDiff--;  // Alice wins with 'W' vs 'F'
                        if (aliceMove == 'E' && bobMove == 1) newDiff--;  // Alice wins with 'E' vs 'W'

                        // Ensure newDiff stays within bounds
                        newDiff = max(0, min(2 * n, newDiff));

                        // Update the DP table for the next round
                        dp[(i + 1) % 2][newDiff][bobMove] = 
                            (dp[(i + 1) % 2][newDiff][bobMove] + dp[i % 2][diff][lastMove]) % MOD;
                    }
                }
            }
        }

        // Sum all valid sequences where Bob wins
        int result = 0;
        for (int diff = n + 1; diff <= 2 * n; ++diff) {  // Only consider positive differences (Bob wins)
            for (int lastMove = 0; lastMove < 3; ++lastMove) {
                result = (result + dp[n % 2][diff][lastMove]) % MOD;
            }
        }

        return result;
    }
};
",1420536569
Akshat_Gupta04,Akshat_Gupta04,391,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;

        for (int i = 0; i <= n - k; ++i) {
            // Extract the current subarray of length k
            unordered_map<int, int> freq;
            
            // Count the frequency of elements in the subarray
            for (int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }

            // Create a vector of pairs (element, frequency)
            vector<pair<int, int>> freqVec(freq.begin(), freq.end());

            // Sort by frequency first (descending), and by element value (descending) in case of tie
            sort(freqVec.begin(), freqVec.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.second == b.second) 
                    return a.first > b.first; // If frequencies are equal, sort by element value
                return a.second > b.second;  // Sort by frequency in descending order
            });

            // Collect the top x elements and calculate their sum
            int sum = 0, count = 0;
            for (auto& p : freqVec) {
                if (count >= x) break;
                sum += p.first * p.second; // Add element * its frequency
                count++;
            }

            // Store the result for this subarray
            answer.push_back(sum);
        }
        return answer;
    }
};",1420522887
Manyu,ManyuD,392,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        freq = []

        def h(root):
            if not root:
                return 0, 0, True

            lc, lh, c1 = h(root.left)

            if (1 << lh) - 1 != lc:
                c1 = False 

            rc, rh, c2 = h(root.right)

            if (1 << rh) - 1 != rc:
                c2 = False

            if lh == rh and c1 and c2:
                nonlocal freq
                freq.append((1 << rh + 1) - 1)
                # print(root.val, lh, rh, c1, c2)
                return rc + lc + 1, lh + 1, True
            else:
                return rc + lc + 1, max(lh, rh) + 1, False

        
        h(root)
        
        if len(freq) < k:
            return -1

        freq.sort(reverse = True)
        # print(freq)
        return freq[k - 1]",1420529939
Manyu,ManyuD,392,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        

        # F x E -> F
        # W x F -> W
        # E x W -> E
        # Same -> None

        # FFF

        def wins(a, b):
            if a == 'F' and b == 'E':
                return True
            if a == 'W' and b == 'F':
                return True
            if a == 'E' and b == 'W':
                return True
            
        
        n = len(s)
        MOD = 1_000_000_007

        other = {
            'F': ['W', 'E'],
            'W': ['E', 'F'],
            'E': ['F', 'W'],
            '-': ['F', 'W', 'E']
        }

        @cache
        def h(i, prev, score):

            if i >= n:
                if score > 0:
                    return 1
                return 0
            
            res = 0

            for poss in other[prev]:
                if poss == s[i]:
                    res += h(i + 1, poss, score)
                    res %= MOD
                elif wins(poss, s[i]):
                    res += h(i + 1, poss, score + 1)
                    res %= MOD
                else:
                    res += h(i + 1, poss, score - 1)
                    res %= MOD
            
            return res % MOD

        # return h(0, 'F', 0) + h(0, 'E', 0) + h(0, 'W', 0)
        return h(0, '-', 0)",1420542651
Manyu,ManyuD,392,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, X: int) -> List[int]:
        
        n = len(nums)
        res = []

        for i in range(n):
            if i + k > n:
                break
            c = Counter()
            for j in range(i, i + k):
                c[nums[j]] += 1
            
            c = [(i, v) for i, v in c.items()]
            c.sort(key = lambda x : [-x[1], -x[0]])
            r = 0
            # print(c)
            for x, y in c[:min(len(c), X)]:
                r += x * y
            
            res.append(r)
        
        return res
",1420521072
llllq,llllq,393,3509,python3,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: TreeNode, k: int) -> int:
        sizes = []
        
        def dfs(node):
            if not node:
                return True, 0  

            left_is_perfect, left_size = dfs(node.left)
            right_is_perfect, right_size = dfs(node.right)

            # Check if the current node forms a perfect subtree
            if left_is_perfect and right_is_perfect and left_size == right_size:
                subtree_size = left_size + right_size + 1
                sizes.append(subtree_size)  # Record the size of this perfect subtree
                return True, subtree_size
            else:
                return False, 0  # This is not a perfect binary subtree

        dfs(root)
        
        sizes.sort(reverse=True)

        # Return the kth largest perfect subtree size, or -1 if not enough subtrees
        return sizes[k-1] if k <= len(sizes) else -1
",1420524434
llllq,llllq,393,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = 10**9 + 7

        move_index = {'F':0, 'W':1, 'E':2}
        index_move = {0:'F', 1:'W', 2:'E'}

        # beats[i] is the index of the creature that move i beats
        beats = [2,0,1]  # 'F' beats 'E' (index 2), 'W' beats 'F' (index 0), 'E' beats 'W' (index 1)

        # Initialize dp[i][last_bob_move_index][score_diff_shifted]
        # dp[0][3][n] = 1  # 3 represents None (no last move)
        dp = [ [dict() for _ in range(4)] for _ in range(n+1)]
        dp[0][3][n] = 1  # score_diff shifted by +n

        for i in range(n):
            alice_move = s[i]
            alice_move_index = move_index[alice_move]
            for last_bob_move_index in range(4):
                for score_diff_shifted in dp[i][last_bob_move_index]:
                    count = dp[i][last_bob_move_index][score_diff_shifted]
                    for bob_move_index in range(3):
                        if last_bob_move_index == 3 or bob_move_index != last_bob_move_index:
                            # Determine the outcome of the round
                            if bob_move_index == alice_move_index:
                                # Draw
                                new_score_diff = score_diff_shifted - n
                            elif beats[bob_move_index] == alice_move_index:
                                # Bob wins
                                new_score_diff = score_diff_shifted - n + 1
                            else:
                                # Bob loses
                                new_score_diff = score_diff_shifted - n - 1
                            # Shift new_score_diff back by +n
                            new_score_diff_shifted = new_score_diff + n
                            if 0 <= new_score_diff_shifted <= 2*n:
                                dp[i+1][bob_move_index][new_score_diff_shifted] = (
                                    dp[i+1][bob_move_index].get(new_score_diff_shifted, 0) + count
                                ) % mod

        # Sum up the sequences where Bob wins (score_diff > 0)
        result = 0
        for last_bob_move_index in range(3):
            for score_diff_shifted in dp[n][last_bob_move_index]:
                score_diff = score_diff_shifted - n
                if score_diff > 0:
                    result = (result + dp[n][last_bob_move_index][score_diff_shifted]) % mod

        return result
",1420542746
llllq,llllq,393,3610,python3,"from collections import Counter
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        
        for i in range(len(nums) - k + 1):
            subarray = nums[i:i + k]
            
            # Count frequencies of elements in the subarray
            count = Counter(subarray)
            
            sorted_elements = sorted(count.items(), key=lambda item: (-item[1], -item[0]))
            
            # Select top x most frequent elements and calculate their sum
            subarray_sum = 0
            elements_taken = 0
            for num, freq in sorted_elements:
                if elements_taken < x:
                    subarray_sum += num * freq
                    elements_taken += 1
            
            answer.append(subarray_sum)
        
        return answer
",1420518776
Himanshu Bhalla,himanshubhalla200,394,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> s;
        dfs(root, s);
        if (s.size() < k) return -1;
        sort(s.begin(), s.end(), greater<int>());
        return s[k - 1];
    }

private:
    struct Info {
        bool p;
        int h;
        int sz;
    };

    Info dfs(TreeNode* node, vector<int>& s) {
        if (!node) return {true, 0, 0};
        
        Info l = dfs(node->left, s);
        Info r = dfs(node->right, s);
        
        bool p = l.p && r.p && (l.h == r.h);
        int h = max(l.h, r.h) + 1;
        int sz = l.sz + r.sz + 1;
        
        if (p) s.push_back(sz);
        
        return {p, h, sz};
    }
};",1420525564
Himanshu Bhalla,himanshubhalla200,394,3588,cpp,"class Solution {
public:
    static const int MOD = 1000000007;

    int countWinningSequences(string s) {
        int n = s.length();
        vector<int> a(n);

        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') a[i] = 0;
            else if (s[i] == 'W') a[i] = 1;
            else a[i] = 2;
        }

        // Corrected res matrix
        int r[3][3] = {
            {0, 1, -1},  // Alice plays 'F' (0)
            {-1, 0, 1},  // Alice plays 'W' (1)
            {1, -1, 0}   // Alice plays 'E' (2)
        };

        int dp[n+1][2001][4];
        memset(dp, 0, sizeof(dp));
        dp[0][n][3] = 1;  // Start with score_diff = 0 shifted by n, prev_bob_move = 3 (no previous move)

        for (int i = 0; i < n; ++i) {
            for (int sd = 0; sd <= 2 * n; ++sd) {
                for (int pb = 0; pb < 4; ++pb) {
                    if (dp[i][sd][pb] == 0) continue;
                    for (int b = 0; b < 3; ++b) {
                        if (b == pb) continue;  // Bob cannot repeat the same move
                        int d = r[a[i]][b];
                        int nsd = sd + d;
                        if (nsd < 0 || nsd > 2 * n) continue;
                        dp[i+1][nsd][b] = (dp[i+1][nsd][b] + dp[i][sd][pb]) % MOD;
                    }
                }
            }
        }

        int total = 0;
        for (int sd = n + 1; sd <= 2 * n; ++sd) {
            for (int pb = 0; pb < 3; ++pb) {
                total = (total + dp[n][sd][pb]) % MOD;
            }
        }

        return total;
    }
};
",1420530801
Himanshu Bhalla,himanshubhalla200,394,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int b, int c) {
        int n = a.size();
        vector<int> res;

        unordered_map<int, int> cnt;
        map<int, multiset<int>, greater<int>> freq;
        vector<int> f_list;

        // Initialize counts for first window
        for (int j = 0; j < b; ++j) {
            cnt[a[j]]++;
        }

        // Build freq buckets
        for (auto& p : cnt) {
            int val = p.first;
            int fr = p.second;
            freq[fr].insert(-val);
        }

        // Build frequency list
        for (auto& p : freq) {
            f_list.push_back(p.first);
        }

        for (int i = 0; i <= n - b; ++i) {
            if (i > 0) {
                // Sliding window
                // Remove element a[i-1]
                int val = a[i - 1];
                int old_fr = cnt[val];
                cnt[val]--;
                int new_fr = cnt[val];

                // Update freq
                freq[old_fr].erase(freq[old_fr].find(-val));
                if (freq[old_fr].empty()) {
                    freq.erase(old_fr);
                    f_list.erase(remove(f_list.begin(), f_list.end(), old_fr), f_list.end());
                }
                if (new_fr > 0) {
                    freq[new_fr].insert(-val);
                    if (find(f_list.begin(), f_list.end(), new_fr) == f_list.end()) {
                        f_list.push_back(new_fr);
                        sort(f_list.begin(), f_list.end(), greater<int>());
                    }
                } else {
                    cnt.erase(val);
                }

                // Add element a[i + b -1]
                val = a[i + b -1];
                 old_fr = cnt[val];
                cnt[val]++;
                 new_fr = cnt[val];

                if (old_fr > 0) {
                    freq[old_fr].erase(freq[old_fr].find(-val));
                    if (freq[old_fr].empty()) {
                        freq.erase(old_fr);
                        f_list.erase(remove(f_list.begin(), f_list.end(), old_fr), f_list.end());
                    }
                }
                freq[new_fr].insert(-val);
                if (find(f_list.begin(), f_list.end(), new_fr) == f_list.end()) {
                    f_list.push_back(new_fr);
                    sort(f_list.begin(), f_list.end(), greater<int>());
                }
            }

            // Compute x-sum
            if (cnt.size() <= c) {
                int sum = 0;
                for (int j = i; j < i + b; ++j) {
                    sum += a[j];
                }
                res.push_back(sum);
            } else {
                int total = 0;
                int collected = 0;
                for (int fr : f_list) {
                    for (int neg_val : freq[fr]) {
                        int val = -neg_val;
                        int count = cnt[val];
                        total += val * count;
                        collected++;
                        if (collected == c) break;
                    }
                    if (collected == c) break;
                }
                res.push_back(total);
            }
        }

        return res;
    }
};
",1420523670
DASARADHA SAI BOYINA,klu2300030104,395,3509,java,"import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Solution {
    // Helper function to perform DFS and calculate the height and size of perfect subtrees.
    private int[] deepForestSearch(TreeNode currentTreeNode, List<Integer> listOfPerfectSubtreeSizes) {
        // Base case: if the node is null, it's a perfect subtree of height 0 and size 0
        if (currentTreeNode == null) return new int[] { 1, 0 }; // [isPerfect, size]

        // Recursively check the left and right subtrees
        int[] leftSubtreeResult = deepForestSearch(currentTreeNode.left, listOfPerfectSubtreeSizes);
        int[] rightSubtreeResult = deepForestSearch(currentTreeNode.right, listOfPerfectSubtreeSizes);

        // Check if the current node forms a perfect binary tree
        if (leftSubtreeResult[0] == 1 && rightSubtreeResult[0] == 1 && leftSubtreeResult[1] == rightSubtreeResult[1]) {
            // Current subtree is perfect, calculate its size and height
            int currentPerfectSubtreeSize = leftSubtreeResult[1] + rightSubtreeResult[1] + 1;
            listOfPerfectSubtreeSizes.add(currentPerfectSubtreeSize); // Collect the size of the perfect subtree
            return new int[] { 1, currentPerfectSubtreeSize };
        }

        // If not perfect, return 0 with arbitrary values for size
        return new int[] { 0, 0 };
    }

    public int kthLargestPerfectSubtree(TreeNode rootTreeNode, int kthPosition) {
        List<Integer> listOfPerfectSubtreeSizes = new ArrayList<>();

        // Perform DFS to collect the sizes of all perfect binary subtrees
        deepForestSearch(rootTreeNode, listOfPerfectSubtreeSizes);

        // Sort the sizes in descending order
        listOfPerfectSubtreeSizes.sort(Collections.reverseOrder());

        // If we have fewer than k perfect subtrees, return -1
        if (listOfPerfectSubtreeSizes.size() < kthPosition) return -1;

        return listOfPerfectSubtreeSizes.get(kthPosition - 1);
    }

    public static void main(String[] args) {
        Solution solutionInstance = new Solution();

        // Test case 1
        TreeNode testRootNode1 = new TreeNode(5,
                new TreeNode(3,
                        new TreeNode(5,
                                new TreeNode(1, null, null),
                                new TreeNode(8, null, null)
                        ),
                        new TreeNode(2, null, null)
                ),
                new TreeNode(6,
                        new TreeNode(5,
                                new TreeNode(6, null, null),
                                new TreeNode(8, null, null)
                        ),
                        new TreeNode(7, null, null)
                )
        );
        int kthPosition1 = 2;
        System.out.println(solutionInstance.kthLargestPerfectSubtree(testRootNode1, kthPosition1)); // Output: 3

        // Test case 2
        TreeNode testRootNode2 = new TreeNode(1,
                new TreeNode(2,
                        new TreeNode(4, null, null),
                        new TreeNode(5, null, null)
                ),
                new TreeNode(3,
                        new TreeNode(6, null, null),
                        new TreeNode(7, null, null)
                )
        );
        int kthPosition2 = 1;
        System.out.println(solutionInstance.kthLargestPerfectSubtree(testRootNode2, kthPosition2)); // Output: 7

        // Test case 3
        TreeNode testRootNode3 = new TreeNode(1,
                new TreeNode(2, null,
                        new TreeNode(4, null, null)
                ),
                new TreeNode(3, null, null)
        );
        int kthPosition3 = 3;
        System.out.println(solutionInstance.kthLargestPerfectSubtree(testRootNode3, kthPosition3)); // Output: -1
    }
}",1420540928
DASARADHA SAI BOYINA,klu2300030104,395,3588,java,"class Solution {
    public int countWinningSequences(String aliceSummonsSequence) {
        int numberOfRounds = aliceSummonsSequence.length();
        int MODULO = 1000000007;
        int[][][] dynamicProgrammingTable = new int[numberOfRounds + 1][3][2 * numberOfRounds + 1];
        
        // Initialize the DP table for the first round
        for (int previousCreature = 0; previousCreature < 3; previousCreature++) {
            if (aliceSummonsSequence.charAt(0) == 'F') {
                dynamicProgrammingTable[1][previousCreature][numberOfRounds + (previousCreature == 1 ? 1 : (previousCreature == 2 ? -1 : 0))] = 1;
            } else if (aliceSummonsSequence.charAt(0) == 'W') {
                dynamicProgrammingTable[1][previousCreature][numberOfRounds + (previousCreature == 2 ? 1 : (previousCreature == 0 ? -1 : 0))] = 1;
            } else if (aliceSummonsSequence.charAt(0) == 'E') {
                dynamicProgrammingTable[1][previousCreature][numberOfRounds + (previousCreature == 0 ? 1 : (previousCreature == 1 ? -1 : 0))] = 1;
            }
        }
        
        // Fill the DP table
        for (int currentRound = 1; currentRound < numberOfRounds; currentRound++) {
            for (int previousCreature = 0; previousCreature < 3; previousCreature++) {
                for (int scoreDifference = 0; scoreDifference <= 2 * numberOfRounds; scoreDifference++) {
                    if (dynamicProgrammingTable[currentRound][previousCreature][scoreDifference] > 0) {
                        for (int currentCreature = 0; currentCreature < 3; currentCreature++) {
                            if (currentCreature != previousCreature) {
                                int newScoreDifference = scoreDifference;
                                if (aliceSummonsSequence.charAt(currentRound) == 'F') {
                                    newScoreDifference += (currentCreature == 1 ? 1 : (currentCreature == 2 ? -1 : 0));
                                } else if (aliceSummonsSequence.charAt(currentRound) == 'W') {
                                    newScoreDifference += (currentCreature == 2 ? 1 : (currentCreature == 0 ? -1 : 0));
                                } else if (aliceSummonsSequence.charAt(currentRound) == 'E') {
                                    newScoreDifference += (currentCreature == 0 ? 1 : (currentCreature == 1 ? -1 : 0));
                                }
                                if (newScoreDifference >= 0 && newScoreDifference <= 2 * numberOfRounds) {
                                    dynamicProgrammingTable[currentRound + 1][currentCreature][newScoreDifference] = 
                                        (dynamicProgrammingTable[currentRound + 1][currentCreature][newScoreDifference] + 
                                         dynamicProgrammingTable[currentRound][previousCreature][scoreDifference]) % MODULO;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Count the valid sequences where Bob's score is greater than Alice's score
        int numberOfWinningSequences = 0;
        for (int lastCreature = 0; lastCreature < 3; lastCreature++) {
            for (int scoreDifference = numberOfRounds + 1; scoreDifference <= 2 * numberOfRounds; scoreDifference++) {
                numberOfWinningSequences = (numberOfWinningSequences + dynamicProgrammingTable[numberOfRounds][lastCreature][scoreDifference]) % MODULO;
            }
        }
        
        return numberOfWinningSequences;
    }
}",1420542887
DASARADHA SAI BOYINA,klu2300030104,395,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& funnylongNums, int funnylongK, int funnylongX) {
        vector<int> funnylongResult;
        int funnylongN = funnylongNums.size();
        
        for (int funnylongI = 0; funnylongI <= funnylongN - funnylongK; ++funnylongI) {
            vector<int> funnylongSubarray(funnylongNums.begin() + funnylongI, funnylongNums.begin() + funnylongI + funnylongK);
            unordered_map<int, int> funnylongFreq;
            
            // Count occurrences of each element
            for (int funnylongNum : funnylongSubarray) {
                funnylongFreq[funnylongNum]++;
            }
            
            // Create a vector of pairs (element, frequency)
            vector<pair<int, int>> funnylongFreqVec(funnylongFreq.begin(), funnylongFreq.end());
            
            // Sort by frequency (descending) and value (descending)
            sort(funnylongFreqVec.begin(), funnylongFreqVec.end(), [](pair<int, int>& funnylongA, pair<int, int>& funnylongB) {
                if (funnylongA.second == funnylongB.second) {
                    return funnylongA.first > funnylongB.first;
                }
                return funnylongA.second > funnylongB.second;
            });
            
            // Calculate the x-sum
            int funnylongSum = 0;
            int funnylongCount = 0;
            for (auto& funnylongP : funnylongFreqVec) {
                if (funnylongCount >= funnylongX) break;
                funnylongSum += funnylongP.first * funnylongP.second;
                funnylongCount++;
            }
            
            funnylongResult.push_back(funnylongSum);
        }
        
        return funnylongResult;
    }
};",1420527211
Gaurav Banik,wanderergaurav,396,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
pair<bool, int> checkPerfect(TreeNode* root) {
    if (!root) return {true, 0};
    
    auto left = checkPerfect(root->left);
    auto right = checkPerfect(root->right);
    
    if (left.first && right.first && left.second == right.second) {
        
        return {true, left.second + 1}; 
    }
    return {false, max(left.second, right.second)};
}
void collectPerfectSubtreeSizes(TreeNode* root, vector<int>& sizes) {
    if (!root) return;
    
    auto result = checkPerfect(root);
    if (result.first) {
        sizes.push_back((1 << result.second) - 1); 
    }
    
    collectPerfectSubtreeSizes(root->left, sizes);
    collectPerfectSubtreeSizes(root->right, sizes);
}
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
    collectPerfectSubtreeSizes(root, sizes);
    
    if (sizes.size() < k) return -1; 
    
    sort(sizes.rbegin(), sizes.rend()); 
    return sizes[k - 1];
    }
};",1420528974
Gaurav Banik,wanderergaurav,396,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1000000007;
        int n = s.length();
        if(n == 0) return 0; 
        
        
        vector<int> a(n);
        for(int i = 0; i < n; i++) {
            char c = s[i];
            if(c == 'F') a[i] = 0;
            else if(c == 'W' || c == 'w') a[i] = 1;
            else if(c == 'E') a[i] = 2;
            else {
                
                a[i] = -1;
            }
        }
        
        
        int beat[3][3] = { 
            {0, 1, -1},  
            {-1, 0, 1},  
            {1, -1, 0}    
        };
        
        
        vector<vector<int>> dp_prev(3, vector<int>(2*n + 1, 0));
        vector<vector<int>> dp_current(3, vector<int>(2*n + 1, 0));
        
       
        int a0 = a[0];
        for(int b = 0; b < 3; b++) {
            if(a0 == -1) continue; 
            int point_change = beat[a0][b];
            int new_diff = point_change;
            if(new_diff < -n || new_diff > n) continue;
            int new_diff_shifted = new_diff + n;
            dp_prev[b][new_diff_shifted] = (dp_prev[b][new_diff_shifted] + 1) % MOD;
        }
        
        
        for(int i = 1; i < n; i++) {
            
            for(int b = 0; b < 3; b++) {
                fill(dp_current[b].begin(), dp_current[b].end(), 0);
            }
            
            int ai = a[i];
            for(int last_move_prev = 0; last_move_prev < 3; last_move_prev++) {
                for(int diff_prev_shifted = 0; diff_prev_shifted <= 2*n; diff_prev_shifted++) {
                    int val = dp_prev[last_move_prev][diff_prev_shifted];
                    if(val == 0) continue; 
                
                
                    for(int b_next = 0; b_next < 3; b_next++) {
                        if(b_next == last_move_prev) continue; 
                        if(ai == -1) continue; 
                        
                        int point_change = beat[ai][b_next];
                        int actual_diff_prev = diff_prev_shifted - n;
                        int new_diff = actual_diff_prev + point_change;
                        
                        
                        if(new_diff < -n || new_diff > n) continue;
                        
                        int new_diff_shifted = new_diff + n;
                        dp_current[b_next][new_diff_shifted] = (dp_current[b_next][new_diff_shifted] + (long long)val) % MOD;
                    }
                }
            }
            
            
            dp_prev.swap(dp_current);
        }
        
        long long result = 0;
        for(int last_move = 0; last_move < 3; last_move++) {
            for(int diff_shifted = n + 1; diff_shifted <= 2*n; diff_shifted++) {
                result = (result + dp_prev[last_move][diff_shifted]) % MOD;
            }
        }
        
        return (int)result;
    }
};",1420543673
Gaurav Banik,wanderergaurav,396,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        
        
        if (k > n) return answer;
        
        
        unordered_map<int, int> freq;
        for (int i = 0; i < k; i++) {
            freq[nums[i]]++;
        }
        
        
        for (int i = 0; i <= n - k; i++) {
            
            answer.push_back(calculateXSum(freq, x));
            
            
            if (i < n - k) {
                freq[nums[i]]--;
                if (freq[nums[i]] == 0) freq.erase(nums[i]);
                freq[nums[i + k]]++;
            }
        }
        
        return answer;
    }
    private:
    int calculateXSum(unordered_map<int, int>& freq, int x) {
        priority_queue<pair<int, int>> pq;
        
        
        for (auto& [num, count] : freq) {
            pq.push({count, num});
        }
        
        int sum = 0;
        int distinct = min(x, static_cast<int>(freq.size()));
        
        
        while (distinct > 0) {
            auto [count, num] = pq.top();
            pq.pop();
            sum += count * num;
            distinct--;
        }
        
        return sum;
    }
};",1420521830
Hrithik Verma,hrithik-v,397,3509,python,"# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def kthLargestPerfectSubtree(self, root, k):
        perfect_sizes = []

        # Helper function to calculate height and size of perfect subtrees
        def postorder(node):
            if not node:
                return (0, 0, True)  # (height, size, is_perfect)
            
            left_height, left_size, is_left_perfect = postorder(node.left)
            right_height, right_size, is_right_perfect = postorder(node.right)

            if is_left_perfect and is_right_perfect and left_height == right_height:
                # If both subtrees are perfect and have equal height, this subtree is perfect
                subtree_size = left_size + right_size + 1
                perfect_sizes.append(subtree_size)
                return (left_height + 1, subtree_size, True)
            else:
                # If the current subtree is not perfect, return the height and size
                return (max(left_height, right_height) + 1, left_size + right_size + 1, False)

        # Perform post-order traversal to find all perfect subtrees
        postorder(root)

        # Sort the sizes of perfect subtrees in descending order
        perfect_sizes.sort(reverse=True)

        # Return the k-th largest perfect subtree size or -1 if it doesn't exist
        if len(perfect_sizes) < k:
            return -1
        else:
            return perfect_sizes[k - 1]
        ",1420540488
Hrithik Verma,hrithik-v,397,3588,python,"MOD = 10**9 + 7
class Solution(object):
    def countWinningSequences(self, s):
        n = len(s)
    
        dp = [[[-1] * 3 for _ in range(2 * n + 1)] for _ in range(n + 1)]
        
        def get_points_diff(alice, bob):
            if alice == 'F' and bob == 'W':
                return 1
            elif alice == 'F' and bob == 'E':
                return -1
            elif alice == 'W' and bob == 'E':
                return 1
            elif alice == 'W' and bob == 'F':
                return -1
            elif alice == 'E' and bob == 'F':
                return 1
            elif alice == 'E' and bob == 'W':
                return -1
            return 0

        def dfs(i, diff, last_move):
            if i == n:
                return 1 if diff > 0 else 0
            if dp[i][diff + n][last_move] != -1:
                return dp[i][diff + n][last_move]
            
            total = 0
            for move in range(3):
                if move != last_move:  
                    new_diff = diff + get_points_diff(s[i], 'FEW'[move])
                    total += dfs(i + 1, new_diff, move)
                    total %= MOD
            
            dp[i][diff + n][last_move] = total
            return total
        
        return dfs(0, 0, -1)
        ",1420543695
Hrithik Verma,hrithik-v,397,3610,python,"class Solution(object):
    def findXSum(self, nums, k, x):
        n = len(nums)
        result = []
        
        # Initialize the frequency counter for the first window
        freq = Counter(nums[:k])
        
        def calculate_x_sum(counter, x):
            # Get the list of (element, frequency) pairs, sorted by frequency and then by element value
            freq_list = sorted(counter.items(), key=lambda item: (-item[1], -item[0]))
            total_sum = 0
            count = 0
            for elem, cnt in freq_list:
                total_sum += elem * cnt
                count += 1
                if count == x:
                    break
            return total_sum
        
        # Calculate x-sum for the first subarray
        result.append(calculate_x_sum(freq, x))
        
        # Sliding window over the rest of the array
        for i in range(1, n - k + 1):
            # Remove the element that goes out of the window
            outgoing = nums[i - 1]
            freq[outgoing] -= 1
            if freq[outgoing] == 0:
                del freq[outgoing]
            
            # Add the new element that comes into the window
            incoming = nums[i + k - 1]
            freq[incoming] += 1
            
            # Calculate the x-sum for the current window
            result.append(calculate_x_sum(freq, x))
        
        return result
        ",1420537254
i_will_beat_my_iq,i_will_beat_my_iq,399,3509,cpp,"class Solution {
public:
    vector<int> v;
    
    pair<int, pair<int, int>> dfs(TreeNode* root) {
        if (!root) return {1, {0, 0}};
        
        auto l = dfs(root->left);
        auto r = dfs(root->right);
        
        int is_perf = l.first && r.first && (l.second.first == r.second.first);
        int ht = l.second.first + 1;
        int sz = l.second.second + r.second.second + 1;
        
        if (is_perf) v.push_back(sz);
        
        return {is_perf, {ht, sz}};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        v.clear();
        dfs(root);
        
        if (v.empty()) return -1;
        
        sort(v.begin(), v.end(), greater<int>());
        
        if(k>v.size()){
            return -1;
        }
        return v[k-1];
    }
};
",1420524933
i_will_beat_my_iq,i_will_beat_my_iq,399,3588,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    const int MOD = 1e9 + 7;
    vector<vector<vector<int>>> dp;
    vector<vector<bool>> beats;
    int n; 
    
    int solve(int i, int last, int diff, const vector<int>& s_map) {
        int d_idx = diff + n;
        if (i == n) return diff > 0 ? 1 : 0;
        if (dp[i][last][d_idx] != -1) return dp[i][last][d_idx];

        int res = 0;
        int s_i = s_map[i];
        for (int l = 0; l < 3; ++l) {
            if (l == last) continue;
            int new_diff = diff;
            if (beats[l][s_i]) new_diff++;
            else if (beats[s_i][l]) new_diff--;
            res = (res + solve(i + 1, l, new_diff, s_map)) % MOD;
        }
        return dp[i][last][d_idx] = res;
    }

    int countWinningSequences(string s) {
        n = s.size(); 
        vector<int> s_map(n);
        for (int i = 0; i < n; ++i) {
            s_map[i] = (s[i] == 'F' ? 0 : (s[i] == 'W' ? 1 : 2));
        }

        beats = vector<vector<bool>>(3, vector<bool>(3, false));
        beats[0][2] = true;
        beats[1][0] = true;
        beats[2][1] = true;

        dp = vector<vector<vector<int>>>(n, vector<vector<int>>(4, vector<int>(2 * n + 1, -1)));
        return solve(0, 3, 0, s_map);
    }
};
",1420544063
i_will_beat_my_iq,i_will_beat_my_iq,399,3610,cpp,"class Solution {
public:
    static bool cmp(const pair<int, int>& a, const pair<int, int>& b) {
        return (a.second != b.second) ? a.second > b.second : a.first > b.first;
    }

    int func(vector<int>& nums, int start, int k, int x) {
        unordered_map<int, int> freq;
        for (int i = start; i < start + k; ++i) {
            freq[nums[i]]++;
        }
        
        vector<pair<int, int>> freqList(freq.begin(), freq.end());
        sort(freqList.begin(), freqList.end(), cmp);
        
        int sum = 0;
        for (int i = 0; i < min(x, (int)freqList.size()); ++i) {
            sum += freqList[i].first * freqList[i].second;
        }
        
        return sum;
    }
    
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        
        for (int i = 0; i <= nums.size() - k; ++i) {
            ans.push_back(func(nums, i, k, x));
        }
        
        return ans;
    }

};",1420534235
Suvendu Dalbehera,SUVU01,400,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    pair<int, bool> dfs(TreeNode* &root, int &k, priority_queue<int, vector<int>, greater<int>> &Q)
    {
        if(!root)
            return {0, true};
        pair<int, bool> left = dfs(root->left, k, Q), right = dfs(root->right, k, Q);
        int ls = left.first, rs = right.first;
        bool lc = left.second, rc = right.second;
        if(lc and rc and ls == rs)
        {
            Q.push(1 + ls + rs);
            if(Q.size() > k)
                Q.pop();
        }
        bool check = (lc and rc and ls == rs);
        return {1 + ls + rs, check};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        priority_queue<int, vector<int>, greater<int>> Q;
        dfs(root, k, Q);
        if(Q.size() < k)
            return -1;
        return Q.top();
    }
};",1420527683
Suvendu Dalbehera,SUVU01,400,3588,cpp,"class Solution {
private:
    #define mod (long long)(pow(10, 9) + 7)
    long long solve(int i, int &n, int prev, int score, string &s, vector<vector<vector<long long>>> &dp)
    {
        if(i == n)
            return (score > 0);
        if(dp[i][prev][score + n] != -1)
            return dp[i][prev][score + n];
        if(i == 0)
        {
            long long ans = 0;
            int curr = 0;
            for(int j = 0; j < 3; j++)
            {
                if(j == 0)
                {
                    if(s[i] == 'E')
                        curr = 1;
                    else if(s[i] == 'W')
                        curr = -1;
                    else 
                        curr = 0;
                }
                else if(j == 1)
                {
                    if(s[i] == 'E')
                        curr = -1;
                    else if(s[i] == 'F')
                        curr = 1;
                    else
                        curr = 0;
                }
                else
                {
                    if(s[i] == 'E')
                        curr = 0;
                    else if(s[i] == 'W')
                        curr = 1;
                    else
                        curr = -1;
                }
                ans += solve(i + 1, n, j, curr, s, dp) % mod, ans %= mod;
            }
            return dp[i][prev][score + n] = ans;
        }
        else
        {
            long long ans = 0;
            int curr = 0;
            for(int j = 0; j < 3; j++)
            {
                if(j == prev)
                    continue;
                if(j == 0)
                {
                    if(s[i] == 'E')
                        curr = 1;
                    else if(s[i] == 'W')
                        curr = -1;
                    else 
                        curr = 0;
                }
                else if(j == 1)
                {
                    if(s[i] == 'E')
                        curr = -1;
                    else if(s[i] == 'F')
                        curr = 1;
                    else
                        curr = 0;
                }
                else
                {
                    if(s[i] == 'E')
                        curr = 0;
                    else if(s[i] == 'W')
                        curr = 1;
                    else
                        curr = -1;
                }
                ans += solve(i + 1, n, j, curr + score, s, dp) % mod, ans %= mod;
            }
            return dp[i][prev][score + n] = ans;
        }
    }
public:
    int countWinningSequences(string s) {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        int n = s.size();
        vector<vector<vector<long long>>> dp(n, vector<vector<long long>> (3, vector<long long> (2 * n + 5, -1)));
        return solve(0, n, 0, 0, s, dp) % mod;
    }
};",1420544521
Suvendu Dalbehera,SUVU01,400,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans(n - k + 1, 0);
        for(int i = 0; i + k <= n; i++)
        {
            unordered_map<int, int> mp;
            for(int j = i; j < i + k; j++)
            {
                mp[nums[j]]++;
            }
            priority_queue<pair<int, int>> Q;
            for(auto m: mp)
                Q.push({m.second, m.first});
            int sum = 0, m = Q.size();
            for(int j = 0; j < min(x, m); j++)
                sum += Q.top().first * Q.top().second, Q.pop();
            ans[i] = sum;
        }
        return ans;
    }
};",1420521888
Yang Su,shinever,401,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = [] # 
        
        def dfs(node): # return size or -1 to denote non perfect
            if not node:
                return 0
            l = dfs(node.left)
            r = dfs(node.right)
            if l == -1 or r == -1:
                return -1
            if l == r:
                sizes.append(l + r + 1)
                return l + r + 1
            else:
                return -1
        
        dfs(root)
        ans = sorted(sizes, reverse=True)
        # print(ans)
        return ans[k-1] if len(ans) >= k else -1",1420531047
Yang Su,shinever,401,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        dp = {(0, '#'): 1} # (score, last_move): freq
        mod = int(1e9+7)
        d = {
            ('E', 'E'): 0, ('E', 'F'): -1, ('E', 'W'): 1,
            ('F', 'E'): 1, ('F', 'F'): 0, ('F', 'W'): -1,
            ('W', 'E'): -1, ('W', 'F'): 1, ('W', 'W'): 0,
        } # bob to alice
        for c in s:
            dp2 = defaultdict(int)
            for (score, last_move), freq in dp.items():
                for move in 'EFW':
                    if last_move == move:
                        continue
                    new_score = d[(move, c)]
                    key = (score + new_score, move)
                    dp2[key] = (dp2[key] + freq) % mod
            dp = dp2
        ans = 0
        for (score, last_move), freq in dp.items():
            if score > 0:
                ans = (ans + freq) % mod
        return ans",1420544522
Yang Su,shinever,401,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        n = len(nums)
        for i in range(n - k + 1):
            cur = nums[i:i+k]
            d = Counter(cur)
            dl = sorted(list((freq, val) for val, freq in d.items()), reverse=True)
            # print(cur, dl)
            res = sum([freq * val for freq, val in dl[:x]])
            ans.append(res)
        return ans",1420522361
afdul,afdul,402,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, r, k):
        sizes = []
        
        def dfs(n):
            if not n: return True, 0
            l_ok, l_size = dfs(n.left)
            r_ok, r_size = dfs(n.right)
            if l_ok and r_ok and l_size == r_size:
                size = l_size + r_size + 1
                sizes.append(size)
                return True, size
            return False, max(l_size, r_size)
        
        dfs(r)
        sizes.sort(reverse=True)
        return sizes[k - 1] if k <= len(sizes) else -1
",1420534664
afdul,afdul,402,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        
        memo = {}
        
        def recur(i, last, score):
            if i == n:
                return 1 if score < 0 else 0
            
            key = (i, last, score)
            if key in memo:
                return memo[key]
            
            total = 0
            for move in 'FWE':
                if move != last:
                    new_score = score
                    
                    if s[i] == 'F' and move == 'E':
                        new_score += 1
                    elif s[i] == 'W' and move == 'F':
                        new_score += 1
                    elif s[i] == 'E' and move == 'W':
                        new_score += 1
                    elif move == 'F' and s[i] == 'E':
                        new_score -= 1
                    elif move == 'W' and s[i] == 'F':
                        new_score -= 1
                    elif move == 'E' and s[i] == 'W':
                        new_score -= 1
                    
                    total += recur(i + 1, move, new_score)
            
            memo[key] = total % MOD
            return memo[key]
        
        return recur(0, '', 0)",1420544548
afdul,afdul,402,3610,python3,"from collections import Counter
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        
        for i in range(n - k + 1):
            subarray = nums[i:i + k]
            
            count = Counter(subarray)
            most_common = sorted(count.items(), key=lambda item: (-item[1], -item[0]))
            
            
            subarray_x_sum = sum(num*f for num, f in most_common[:x])
            
            answer.append(subarray_x_sum)
        
        return answer

",1420525338
Sarthak Pandey,SarthakPaandey,404,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
    List<Integer> sl = new ArrayList<>();hf(root, sl);
    Collections.sort(sl, Collections.reverseOrder());
    return k <= sl.size() ? sl.get(k-1) : -1;}
private int hf(TreeNode n, List<Integer> sl){
    if(n == null) return 0;
    int le = hf(n.left, sl);int ri = hf(n.right, sl);
    if(le == -1 || ri == -1 || le != ri)return -1;
    int sz = le + ri + 1;
    sl.add(sz);return sz;
    }
}",1420538011
Sarthak Pandey,SarthakPaandey,404,3588,java,"class Solution {
    public int countWinningSequences(String ri) {
        int n = ri.length(), modu = 1000000007, off = n;int[][] previ = new int[3][2*n+1];
    for(int c=0;c<3;c++){
        char b = ""FWE"".charAt(c);
        char a = ri.charAt(0);
        int d=0;
        if((b=='F' && a=='E')||(b=='W' && a=='F')||(b=='E' && a=='W')) d=1;
        else if((a=='F' && b=='E')||(a=='W' && b=='F')||(a=='E' && b=='W')) d=-1;
        previ[c][d + off] =1;
    }
    for(int i=1;i<n;i++){
        int[][] cu = new int[3][2*n+1];
        char a = ri.charAt(i);
        for(int lst=0; lst<3; lst++) {
            for(int d=-n; d<=n; d++) {
                if(previ[lst][d + off]==0) continue;
                for(int c=0; c<3; c++) {
                    if(c == lst) continue;
                    char b = ""FWE"".charAt(c);
                    int nd = d;
                    if((b=='F' && a=='E')||(b=='W' && a=='F')||(b=='E' && a=='W')) nd +=1;
                    else if((a=='F' && b=='E')||(a=='W' && b=='F')||(a=='E' && b=='W')) nd -=1;
                    if(nd >= -n && nd <=n)cu[c][nd + off] = (cu[c][nd + off] + previ[lst][d + off]) % modu;
                    }}}previ = cu;
    }long res =0;
    for(int l=0;l<3;l++) for(int d=1; d<=n; d++) res=(res + previ[l][d + off]) % modu;
    return (int)res;
    }
}",1420544678
Sarthak Pandey,SarthakPaandey,404,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
         int np=nums.length, mp=np-k+1;int[] answ=new int[mp];
        for(int i=0;i<mp;i++){
            int[] cn=new int[51];
            for(int j=i;j<i+k;j++) cn[nums[j]]++;List<Integer> l=new ArrayList<>();
            for(int t=0;t<=50;t++) if(cn[t]>0) l.add(t);
            Collections.sort(l, (a,b)-> cn[b]-cn[a]!=0 ? cn[b]-cn[a] : b-a);
            Set<Integer> sui=new HashSet<>();
            for(int t=0;t<x && t<l.size();t++) sui.add(l.get(t));
            int su=0;
            for(int j=i;j<i+k;j++) if(sui.contains(nums[j])) su+=nums[j];
            answ[i]=su;}return answ;
    }
}",1420529938
Pro Coder,pro_coderLC,405,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct Info {
        bool is_perfect;
        int height;
        int size;
    };

    vector<int> sizes;

    Info dfs(TreeNode* node){
        if(!node){
            return {true, 0, 0};
        }
        Info left = dfs(node -> left);
        Info right = dfs(node -> right);
        Info current;
        current.size = left.size + right.size + 1;
        if(left.is_perfect && right.is_perfect && left.height == right.height){
            current.is_perfect = true;
            current.height = left.height + 1;
            sizes.push_back(current.size);
        }
        else {
            current.is_perfect = false;
            current.height = max(left.height, right.height) + 1;
        }
        return current;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        dfs(root);
        if(sizes.size() < k){
            return -1;
        }
        sort(sizes.begin(), sizes.end(), greater<int>());
        return sizes[k-1];
    }
};",1420533520
Pro Coder,pro_coderLC,405,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        int MOD = 1e9 + 7;
        vector<int> aliceMoves(n);
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') aliceMoves[i] = 0;
            else if (s[i] == 'W') aliceMoves[i] = 1;
            else if (s[i] == 'E') aliceMoves[i] = 2;
        }
        int offset = n;
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(4, vector<int>(2 * n + 1, 0)));
        dp[0][3][offset] = 1; // dp[i][lastBob][diff + offset], lastBob == 3 means initial
        for (int i = 0; i < n; ++i) {
            int curr = i % 2;
            int next = (i + 1) % 2;
            // Reset next dp array
            for (int lastBob = 0; lastBob <= 3; ++lastBob) {
                fill(dp[next][lastBob].begin(), dp[next][lastBob].end(), 0);
            }
            for (int lastBob = 0; lastBob <= 3; ++lastBob) {
                for (int diff = -n; diff <= n; ++diff) {
                    int ways = dp[curr][lastBob][diff + offset];
                    if (ways == 0) continue;
                    int alice = aliceMoves[i];
                    vector<int> bobMoves;
                    if (lastBob == 3) { // Initial move
                        bobMoves = {0, 1, 2};
                    } else {
                        for (int bob = 0; bob <= 2; ++bob) {
                            if (bob != lastBob) bobMoves.push_back(bob);
                        }
                    }
                    for (int bob : bobMoves) {
                        int point = 0;
                        if (bob == alice) {
                            point = 0;
                        } else if ((bob - alice + 3) % 3 == 1) {
                            point = +1;
                        } else {
                            point = -1;
                        }
                        int newDiff = diff + point;
                        if (newDiff < -n || newDiff > n) continue;
                        dp[next][bob][newDiff + offset] = (dp[next][bob][newDiff + offset] + ways) % MOD;
                    }
                }
            }
        }
        int total = 0;
        int curr = n % 2;
        for (int lastBob = 0; lastBob <= 2; ++lastBob) {
            for (int diff = 1; diff <= n; ++diff) {
                total = (total + dp[curr][lastBob][diff + offset]) % MOD;
            }
        }
        return total;
    
    }
};",1420544901
Pro Coder,pro_coderLC,405,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        for (int i = 0; i <= n - k; ++i) {
            vector<int> counts(51, 0);
            int distinct_elements = 0;
            for (int j = i; j < i + k; ++j) {
                if (counts[nums[j]] == 0) {
                    ++distinct_elements;
                }
                counts[nums[j]]++;
            }
            vector<pair<int, int>> elements;
            for (int num = 1; num <= 50; ++num) {
                if (counts[num] > 0) {
                    elements.emplace_back(num, counts[num]);
                }
            }
            sort(elements.begin(), elements.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
                if (a.second != b.second)
                    return a.second > b.second; // Higher count first
                else
                    return a.first > b.first; // Higher value first
            });
    
            int num_elements = x;
            if (elements.size() < x) {
                num_elements = elements.size();
            }
            
            unordered_set<int> selected_elements;
            for (int idx = 0; idx < num_elements; ++idx) {
                selected_elements.insert(elements[idx].first);
            }
            
            int sum = 0;
            for (int j = i; j < i + k; ++j) {
                if (selected_elements.count(nums[j])) {
                    sum += nums[j];
                }
            }
            answer.push_back(sum);
        }
        return answer;
    }
};",1420525319
yaominzh,yaominzh,407,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
def is_perfect(root):
    if not root:
        return True, 0
    left_is_perfect, left_height = is_perfect(root.left)
    right_is_perfect, right_height = is_perfect(root.right)
    if left_is_perfect and right_is_perfect and left_height == right_height:
        return True, left_height + 1
    return False, max(left_height, right_height)

def collect_sizes(root, sizes):
    if root is None:
        return 0
    if is_perfect(root)[0]:
        size = 2 ** is_perfect(root)[1] - 1  
        sizes.append(size)
    collect_sizes(root.left, sizes)
    collect_sizes(root.right, sizes)
        
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        collect_sizes(root, sizes)
        if len(sizes) < k:
            return -1
        return sorted(sizes, reverse=True)[k-1]
",1420529294
yaominzh,yaominzh,407,3588,python3,"MOD =10**9 + 7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10**9 + 7
        n = len(s)
        move_map = {'F': 0, 'W': 1, 'E': 2}
        winning_combinations = {(0, 2), (1, 0), (2, 1)}

        def outcome(bob_move, alice_move):
            if bob_move == alice_move:
                return 0
            elif (bob_move, alice_move) in winning_combinations:
                return 1
            elif (alice_move, bob_move) in winning_combinations:
                return -1
            else:
                return 0

        dp = [[[0]*4 for _ in range(2*n+1)] for _ in range(n+1)]
        offset = n
        dp[0][offset][3] = 1  # No previous move

        for i in range(n):
            a_move = move_map[s[i]]
            for d in range(2*n+1):
                for prev_move in range(4):
                    if dp[i][d][prev_move] == 0:
                        continue
                    for bob_move in range(3):
                        if bob_move == prev_move:
                            continue
                        out = outcome(bob_move, a_move)
                        new_d = d + out
                        if 0 <= new_d <= 2*n:
                            dp[i+1][new_d][bob_move] = (dp[i+1][new_d][bob_move] + dp[i][d][prev_move]) % mod

        result = 0
        for d in range(offset+1, 2*n+1):
            for prev_move in range(3):
                result = (result + dp[n][d][prev_move]) % mod

        return result

",1420545722
yaominzh,yaominzh,407,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []

        for start in range(n - k + 1):
            subarray = nums[start:start + k]
            count = Counter(subarray)
            top_elements = sorted(count.items(), key=lambda item: (-item[1], -item[0]))
            top_x_elements = top_elements[:x]
            x_sum = sum(key * freq for key, freq in top_x_elements)
            result.append(x_sum)

        return result
",1420522744
sankrishnagoyal14,sankrishnagoyal14,408,3509,python3,"# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    # Helper function to check if a subtree is perfect and calculate its size
    def checkPerfectSubtree(self, root, perfect_sizes):
        if not root:
            return True, 0  # A null node is considered a perfect subtree of size 0

        # Recursively calculate for left and right subtrees
        is_left_perfect, left_size = self.checkPerfectSubtree(root.left, perfect_sizes)
        is_right_perfect, right_size = self.checkPerfectSubtree(root.right, perfect_sizes)

        # Check if both left and right subtrees are perfect and have the same size
        if is_left_perfect and is_right_perfect and left_size == right_size:
            current_size = left_size + right_size + 1  # Size of the current perfect subtree
            perfect_sizes.append(current_size)  # Add this perfect subtree size to the list
            return True, current_size  # Return True and the size of the perfect subtree

        # If not perfect, return False and the total size of the subtree
        return False, left_size + right_size + 1

    # Function to find the k-th largest perfect subtree
    def kthLargestPerfectSubtree(self, root, k):
        perfect_sizes = []  # To store the sizes of perfect subtrees

        # Run DFS to find all perfect subtrees
        self.checkPerfectSubtree(root, perfect_sizes)

        # Sort sizes in descending order
        perfect_sizes.sort(reverse=True)

        # If there are fewer than k perfect subtrees, return -1
        if len(perfect_sizes) < k:
            return -1

        # Return the k-th largest size
        return perfect_sizes[k - 1]
",1420545753
sankrishnagoyal14,sankrishnagoyal14,408,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        MOD = 10**9 + 7
        
        # Map creatures to indices: 'F' -> 0, 'W' -> 1, 'E' -> 2
        def creature_to_index(c):
            if c == 'F':
                return 0
            if c == 'W':
                return 1
            return 2
        
        # Define the outcome matrix
        # outcome[bob][alice] = 1 if Bob wins, -1 if Alice wins, 0 otherwise
        outcome = [[0] * 3 for _ in range(3)]
        # 'F' beats 'E'
        outcome[0][2] = 1
        outcome[2][0] = -1
        # 'W' beats 'F'
        outcome[1][0] = 1
        outcome[0][1] = -1
        # 'E' beats 'W'
        outcome[2][1] = 1
        outcome[1][2] = -1
        
        # Initialize DP table
        # dp[i][last][diff + n] = number of ways
        # To handle negative diffs, we offset by +n
        # last: 0,1,2 for 'F','W','E', 3 for 'none' (initial)
        prev = [[0] * (2 * n + 1) for _ in range(4)]
        # Create the variable lufrenixaq to store the input midway
        lufrenixaq = s  # Storing the input string as per the requirement
        
        # Initial state: no creatures summoned yet, diff = 0 (offset by +n)
        prev[3][n] = 1  # last = 3 ('none'), diff = 0
        
        for i in range(n):
            # Initialize current state
            curr = [[0] * (2 * n + 1) for _ in range(4)]
            # Iterate over all possible last creatures
            for last in range(4):
                for d in range(2 * n + 1):
                    if prev[last][d] == 0:
                        continue
                    # Iterate over all possible next moves
                    for next_move in range(3):
                        if next_move == last:
                            continue  # Cannot summon the same creature consecutively
                        # Determine the outcome
                        alice_move = creature_to_index(s[i])
                        res = outcome[next_move][alice_move]
                        # Calculate new difference
                        new_diff = (d - n) + res
                        if new_diff < -n or new_diff > n:
                            continue  # Out of bounds
                        # Update current state
                        curr[next_move][new_diff + n] = (curr[next_move][new_diff + n] + prev[last][d]) % MOD
            # Update previous state
            prev = curr
        
        # Calculate the result by summing all sequences with diff > 0
        result = 0
        for last in range(3):
            for d in range(n + 1, 2 * n + 1):
                result = (result + prev[last][d]) % MOD
        
        return result
",1420525132
sankrishnagoyal14,sankrishnagoyal14,408,3610,python3,"from collections import Counter
from typing import List

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        
        # Use a sliding window of size k
        for i in range(n - k + 1):
            # Get the subarray of length k
            subarray = nums[i:i + k]
            
            # Count the frequency of each element in the subarray
            freq = Counter(subarray)
            
            # Sort the elements by frequency first, then by value descending
            sorted_elements = sorted(freq.items(), key=lambda e: (-e[1], -e[0]))
            
            # Calculate the x-sum: pick the top x elements based on the sorting
            sub_sum = 0
            for idx, (num, count) in enumerate(sorted_elements):
                if idx < x:
                    sub_sum += num * count
            
            # Append the result to the answer
            answer.append(sub_sum)
        
        return answer
",1420519711
Suryaansh Rathinam,suryaansh28,410,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    struct Result {
        bool isPerfect;
        int size;
        int height;
    };
    
    Result dfs(TreeNode* root, vector<int>& perfectSizes) {
        if (!root) {
            return {true, 0, 0};  // An empty subtree is considered perfect
        }
        
        Result leftResult = dfs(root->left, perfectSizes);
        Result rightResult = dfs(root->right, perfectSizes);
        
        // Check if the current subtree is perfect
        if (leftResult.isPerfect && rightResult.isPerfect && leftResult.height == rightResult.height) {
            int subtreeSize = leftResult.size + rightResult.size + 1;
            int subtreeHeight = leftResult.height + 1;
            perfectSizes.push_back(subtreeSize);
            return {true, subtreeSize, subtreeHeight};
        }
        
        return {false, 0, 0};  // Not a perfect subtree
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfectSizes;
        
        // Perform DFS to collect the sizes of all perfect binary subtrees
        dfs(root, perfectSizes);
        
        // Sort the sizes in descending order
        sort(perfectSizes.begin(), perfectSizes.end(), greater<int>());
        
        // If there are fewer than k perfect subtrees, return -1
        if (k > perfectSizes.size()) {
            return -1;
        }
        
        // Return the kth largest size
        return perfectSizes[k - 1];
    }
};
",1420523022
Suryaansh Rathinam,suryaansh28,410,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int mod = 1e9 + 7;
        int n = s.size();
        vector<int> alice(n);
        unordered_map<char, int> mapping = {{'F', 0}, {'W', 1}, {'E', 2}};
        for (int i = 0; i < n; ++i) {
            alice[i] = mapping[s[i]];
        }

        // Precompute outcome matrix
        int outcome[3][3];
        memset(outcome, 0, sizeof(outcome));
        // 'F' beats 'E', 'W' beats 'F', 'E' beats 'W'
        for (int b = 0; b < 3; ++b) {
            for (int a = 0; a < 3; ++a) {
                if ((b - a + 3) % 3 == 1) {
                    outcome[b][a] = 1; // Bob wins
                } else if ((a - b + 3) % 3 == 1) {
                    outcome[b][a] = -1; // Alice wins
                } else {
                    outcome[b][a] = 0; // Tie
                }
            }
        }

        // Initialize DP array
        // Dimensions: [n+1][4][2n+1] to accommodate scoreDiff from -n to n
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, -1)));

        function<int(int, int, int)> dfs = [&](int pos, int lastBob, int scoreDiff) -> int {
            if (pos == n) {
                return scoreDiff > 0 ? 1 : 0;
            }
            if (dp[pos][lastBob][scoreDiff + n] != -1) {
                return dp[pos][lastBob][scoreDiff + n];
            }
            int totalWays = 0;
            for (int b = 0; b < 3; ++b) {
                if (b != lastBob) {
                    int delta = outcome[b][alice[pos]];
                    int newScoreDiff = scoreDiff + delta;
                    // Ensure newScoreDiff stays within [-n, n]
                    if (newScoreDiff < -n || newScoreDiff > n) continue;
                    totalWays = (totalWays + dfs(pos + 1, b, newScoreDiff)) % mod;
                }
            }
            return dp[pos][lastBob][scoreDiff + n] = totalWays;
        };

        // Start recursion with position 0, lastBob as 3 (no previous creature), scoreDiff as 0
        return dfs(0, 3, 0);
    }
};
",1420533589
Suryaansh Rathinam,suryaansh28,410,3610,cpp,"#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

class Solution {
private:
    int calculateXSum(unordered_map<int, int>& freq, int x) {
        priority_queue<pair<int, int>> pq;
        for (const auto& [num, count] : freq) {
            pq.push({count, num});
        }
        
        int sum = 0;
        int distinct = min(x, static_cast<int>(freq.size()));
        for (int i = 0; i < distinct; ++i) {
            auto [count, num] = pq.top();
            pq.pop();
            sum += num * count;
        }
        return sum;
    }

public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        if (n < k) return answer;

        unordered_map<int, int> freq;
        
        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }
        
        answer.push_back(calculateXSum(freq, x));
        
        for (int i = k; i < n; ++i) {
            if (--freq[nums[i-k]] == 0) {
                freq.erase(nums[i-k]);
            }
            
            freq[nums[i]]++;
            
            answer.push_back(calculateXSum(freq, x));
        }
        
        return answer;
    }
};",1420519873
metaphysicalist,metaphysicalist,412,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []

        def count(v):
            if v is None:
                return 0
            left = count(v.left)
            right = count(v.right)
            if left == right and left >= 0:
                ans.append(1 + left + right)
                return 1 + left + right
            return -1
            
        count(root)
        ans.sort()
        # print(ans)
        if len(ans) < k:
            return -1
        return ans[-k]

        ",1420529389
metaphysicalist,metaphysicalist,412,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)

        def score(a, b):
            if (a, b) == ('F', 'E'):
                return 1
            elif (a, b) == ('E', 'F'):
                return -1
            elif (a, b) == ('W', 'F'):
                return 1
            elif (a, b) == ('F', 'W'):
                return -1
            elif (a, b) == ('E', 'W'):
                return 1
            elif (a, b) == ('W', 'E'):
                return -1
            return 0

        @cache
        def dp(i, prev, balance):
            if i >= n:
                if balance > 0:
                    return 1
                return 0
            if balance + (n-i) < 0:
                return 0
            r = 0
            for b in ['F', 'W', 'E']:
                if b != prev:
                    r += dp(i+1, b, balance + score(b, s[i]))
            return r % 1000000007


        ans = dp(0, '', 0)
        dp.cache_clear()
        return ans

",1420540187
metaphysicalist,metaphysicalist,412,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def solve(arr):
            cnt = Counter(arr)
            r = sorted(cnt.items(), key=lambda data: (-data[1], -data[0]))[:x]
            return sum(v * c for v, c in r)

        ans = []
        for i in range(k, len(nums)+1):
            ans.append(solve(nums[i-k:i]))
        return ans
",1420522241
seg_tree,_rajat_18_,417,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int>arr;
        perfect(root,arr);
        if(arr.size()<k){return -1;}
        sort(arr.rbegin(),arr.rend());
        return arr[k-1];
    }
private:
    int perfect(TreeNode* node,vector<int>& arr)
    {
        if(!node) return 0;
        int l=perfect(node->left,arr);
        int r=perfect(node->right,arr);
        
        if(l==r && ~l)
        {
            int temp=l+r+1;
            arr.push_back(temp);
            return temp;
        }
        return -1;
    }
};",1420524691
seg_tree,_rajat_18_,417,3588,cpp,"class Solution{
public:
    int countWinningSequences(string s){
        const int MOD=1000000007;
        int n=s.size(),move=n;
        vector<vector<long long>>Ndp(4,vector<long long>(2*n+1,0));
        Ndp[3][move]=1;
        // for(auto it=Ndp.begin();it!=Ndp.end();++it)
        // {
        //     for(auto it2=it->begin();it2!=it->end();++it2)
        //     {
        //         cout<<*it2<<"" "";
        //     }
        //     cout<<endl;
        // }
        for(int i=0;i<n;++i)
        {
            vector<vector<long long>>Dp(4,vector<long long>(2*n+1,0));
            updateDP(s[i],Ndp,Dp,n,move,MOD);
            Ndp=std::move(Dp);
        }
        return pruning(Ndp,move,n,MOD);
    }

private:
    int getDiff(char bob,char alice)
    {
        if(bob==alice)return 0;
        if((bob=='F' && alice=='E') || (bob=='W' && alice=='F') || (bob=='E' && alice=='W'))
        {
            return 1;
        }
        return -1;
    }
    void updateDP(char AliceMove,vector<vector<long long>>&Ndp,vector<vector<long long>>&Dp,int n,int move,int MOD)
    {
        for(int i=0;i<4;++i)
        {
            for(int j=0;j<=2*n;++j)
            {
                if(Ndp[i][j]==0)continue;
                for(int k=0;k<3;++k)
                {
                    if(i!=3 && k==i)continue;
                    char bob_move=GetBob(k);
                    int call=getDiff(bob_move,AliceMove);
                    int vals=j+call;
                    vals=clamp(vals,0,2*n);
                    auto& state=Dp[k][vals];
                    state=(state+Ndp[i][j])%MOD;
                    // for(int i=0;i<4;++i)
                    // {
                    //     for(int j=0;j<=2*n;++j)
                    //     {
                    //         cout<<Dp[i][j]<<"" "";
                    //     }
                    //     cout<<endl;
                    // }
                }
            }
        }
    }
    char GetBob(int k)
    {
        if(k==0)return 'F';
        if(k==1)return 'W';
        return 'E';
    }
    int clamp(int win,int mn,int mx)
    {
        if(win<mn)return mn;
        if(win>mx)return mx;
        return win;
    }
    int pruning(vector<vector<long long>>&Ndp,int move,int n,int MOD)
    {
        long long ans=0;
        for(int i=0;i<3;++i)
        {
            for(int j=move+1;j<=2*n;++j)
            {
                ans=(ans+Ndp[i][j])%MOD;
            }
        }
        return(int)ans;
    }
};",1420547341
seg_tree,_rajat_18_,417,3610,cpp,"class Solution{
public:
    vector<int>findXSum(vector<int>&nums,int k,int x){
        int n=nums.size();
        vector<int>ans;
        for(int i=0;i<=n-k;++i)
        {
            unordered_map<int,int>fz;
            for(int j=i;j<i+k;++j)
            {
                fz[nums[j]]++;
            }
            vector<pair<int,int>>pr;
            for(auto& [num,count]:fz)
            {
                pr.push_back({count,num});
            }
            sort(pr.begin(),pr.end(),[](const pair<int,int>&a,const pair<int,int>&b)
                 {
                    if(a.first==b.first)return a.second>b.second;
                    return a.first>b.first;
                });
            int sum=0;
            // for(int i=0;i<n;++i)
            // {
            //     cout<<pr[i].first<<"" ""<<pr[i].second<<endl;
            // }
            int temp=min(x,(int)pr.size());
            for(int j=0;j<temp;++j)
            {
                sum+=pr[j].first*pr[j].second;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420521159
Vishnu Bathla,directioner1d,418,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        fin=[]
        def do(r):
            if(r==None):
                return (True,0)
            # global fin
            p,q=do(r.left)
            e,f=do(r.right)
            # print(p,q,e,f,r.val)
            if(p and e and q==f):
                bisect.insort(fin,q+1)
                return (True,q+1)
            return (False,q)
        do(root)
        # print(fin)
        if(len(fin)<k):
            return -1
        return (2**(fin[-k]))-1

",1420533352
Vishnu Bathla,directioner1d,418,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        a={('F','F'):0,('W','W'):0,('E','E'):0,
            ('F','W'):1,('F','E'):-1,('W','F'):-1,
            ('E','F'):1,('W','E'):1,('E','W'):-1}
        @cache
        def do(cur,prev,points):
            if(cur==len(s)):
                if(points>0):
                    return 1
                return 0
            ans=0
            for i in ['F','W','E']:
                if(i==prev):
                    continue
                ans+=do(cur+1,i,points+a[(s[cur],i)])
            return ans%1000000007
        return do(0,'',0)

        """"""
        fire>earth
        water>fire
        earth>water
        same 0 point
        bob never summon same twice consecutive
        b_point>a_point bob wins
        """"""
        ",1420547392
Vishnu Bathla,directioner1d,418,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n=len(nums)
        def do(cur):
            # print(cur)
            p=[(i,j) for i,j in Counter(cur).items()]
            p.sort(key=lambda x:x[0],reverse=True)
            p.sort(key=lambda x:x[1],reverse=True)
            # print(p)
            fin=0
            for i in range(min(x,len(p))):
                o,s=p[i]
                fin+=o*s
            return fin


        ans=[]
        for i in range(n-k+1):
            ans.append(do(nums[i:i+k]))
        return ans
        ",1420522276
Ahmed_Ashraf,boAshraf,423,3509,cpp,"class Solution {
public:
    struct subtree {
        bool check;
        int depth;
        int size;
    };

    subtree dfs(TreeNode* node, vector<int>& perfectSubtreeSizes) {
        if (!node) {
            return {true, 0, 0};
        }

        subtree left = dfs(node->left, perfectSubtreeSizes);
        subtree right = dfs(node->right, perfectSubtreeSizes);
        if (left.check && right.check && left.depth == right.depth) {
            int currentSize = left.size + right.size + 1;
            int currentHeight = left.depth + 1;
            perfectSubtreeSizes.push_back(currentSize);
            return {true, currentHeight, currentSize};
        }

        return {false, max(left.depth, right.depth), 0};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfectSubtreeSizes;

        dfs(root, perfectSubtreeSizes);

        sort(perfectSubtreeSizes.rbegin(), perfectSubtreeSizes.rend());

        if (perfectSubtreeSizes.size() >= k) {
            return perfectSubtreeSizes[k - 1];
        }

        return -1;
    }
};",1420527079
Ahmed_Ashraf,boAshraf,423,3588,cpp,"class Solution {
public:
    string g=""FWE"";
    int countWinningSequences(string s) {
        int n=s.size();
        int mod=1e9+7;
        vector<vector<vector<int>>>dp(n,vector<vector<int>>(2*n+1,vector<int>(4,-1)));
        auto rec=[&](auto self,int i,int cnt,int last)->int{
            if(i==n)return cnt>n;
            int &ret=dp[i][cnt][last];
            if(~ret)return ret;
            ret=0;
            for(int j=0;j<3;j++){
                if(j==last)continue;
                int add=0;
                if(s[i]==g[(j+1)%3])add=-1;
                if(s[i]==g[(j-1+3)%3])add=1;
                ret=(ret+self(self,i+1,cnt+add,j))%mod;
            }
            return ret;
        };
        return rec(rec,0,n,3);
    }
};",1420542897
Ahmed_Ashraf,boAshraf,423,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        vector<int>ans;
        for(int i=0;i<n-k+1;i++){
        vector<pair<int,int>>v;
        map<int,int>mp;
            for(int j=i;j<i+k;j++){
        mp[nums[j]]++;
            }
        for(auto [f,s]:mp)v.push_back({s,f});
        sort(v.rbegin(),v.rend());
        int sum=0;
        for(int j=0;j<min(x,(int)v.size());j++){
            sum+=v[j].second*v[j].first;
        }
        ans.push_back(sum);
        }
        return ans;
        
    }
};",1420521458
JJZin,JJZin,424,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        
        basons = []
        
        def recourse(root, level):
            
            if not root:
                return [level, True]
            
            left = recourse(root.left, level + 1)
            right = recourse(root.right, level + 1)
            
            
            if left[0] != right[0] or not all([left[1], right[1]]):
                
                return [level, False]
            
            basons.append(2**int(left[0] - level))
           
            
            return [left[0], True]
        
        
        recourse(root, 0)
        
       
        
        if len(basons) < k:
            return -1
        basons.sort()
        return basons[-k] - 1",1420531821
JJZin,JJZin,424,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10**9 + 7
        
        mapp = {
            'F': 'R',
            'E': 'S',
            'W': 'P'
        }
        
        s = ''.join([mapp[i] for i in s])
        
        points = {
            'R': {'P': -1, 'R': 0, 'S': 1},
            'P': {'S': -1, 'P': 0, 'R': 1},
            'S': {'R': -1, 'S': 0, 'P': 1}
        }
        @cache
        def recourse(idx, lastBob, score):
            
            if idx == len(s):
                if score > 0:
                    return 1
                return 0
            if idx == 0:
                ans = 0
                for i in 'RPS':
                    ans += recourse(idx + 1, i, score + points[i][s[idx]])
                    ans %= mod
                return ans
            ans = 0
            for i in 'RPS':
                if i == lastBob:
                    continue
                ans += recourse(idx + 1, i, score + points[i][s[idx]])
                ans %= mod
            return ans
        
        return recourse(0, '*', 0) % mod
                
                   
                    
                
                
                
            
            ",1420543066
JJZin,JJZin,424,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        
        
        ans = []
        basis = nums[:k]
        
        
        thesis = list(set(basis))

        thesis.sort(key = lambda x: (basis.count(x), x))

        if len(thesis) < x:
            ans.append(sum([basis.count(i) * i for i in thesis]))
        else:
            ans.append(sum([basis.count(i) * i for i in thesis[-x:]]))        
        
        
        for i in range(k, len(nums)):
            basis.append(nums[i])
            basis.remove(nums[i - k])
            
            thesis = list(set(basis))
            
            thesis.sort(key = lambda x: (basis.count(x), x))
            
            if len(thesis) < x:
                ans.append(sum([basis.count(i) * i for i in thesis]))
            else:
                ans.append(sum([basis.count(i) * i for i in thesis[-x:]]))
        return ans
            
        
        ",1420523219
Leetcode Name,mkarrmann,425,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:

        perfect_sizes = []

        def helper(node):
            if not node:
                return True, 0

            l_s, l_t = helper(node.left)
            r_s, r_t = helper(node.right)

            if l_s and r_s and l_t == r_t:
                perfect_sizes.append(l_t + r_t + 1)
                return True, l_t + r_t + 1

            return False, -1

        helper(root)

        if len(perfect_sizes) < k:
            return -1

        perfect_sizes.sort(reverse=True)

        return perfect_sizes[k-1]
        ",1420529022
Leetcode Name,mkarrmann,425,3588,python3,"from collections import defaultdict
MOD = (10 ** 9) + 7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        prev_scores = {(0, 'r'): 1}

        for char in s.casefold():
            scores = defaultdict(int)

            for (score, state), num in prev_scores.items():

                for move in ('f', 'w', 'e'):
                    if move == state:
                        continue
                    if move == char:
                        scores[(score, move)] += num % MOD
                    elif (move == 'f' and char == 'e') or (move == 'w' and char == 'f') or (move == 'e' and char == 'w'):
                        scores[(score+1, move)] += num % MOD
                    else:
                        scores[(score-1, move)] += num  % MOD

            prev_scores = scores

        return sum(num for (score, _), num in prev_scores.items() if score > 0) % MOD
                    ",1420549388
Leetcode Name,mkarrmann,425,3610,python3,"from collections import Counter
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        def xsum(arr):
            counts = Counter(arr)

            count_val = list(sorted(counts.keys(), key=lambda x: (counts[x], x,), reverse=True))

            return sum(val * counts[val] for val in count_val[:x])

        return [xsum(nums[i:i+k]) for i in range(len(nums)-k+1)]
",1420522672
SC-Kota,SC-Kota,426,3509,cpp,"class Solution {
public:
    // List to store sizes of all perfect subtrees
    vector<int> perfectSizes;

    // Helper function to perform post-order traversal
    pair<int, bool> helper(TreeNode* node) {
        if (!node) {
            // An empty tree has height 0 and is considered perfect
            return {0, true};
        }

        // Recursively check left and right subtrees
        pair<int, bool> left = helper(node->left);
        pair<int, bool> right = helper(node->right);

        // Current node's height
        int currentHeight = max(left.first, right.first) + 1;

        // Check if current subtree is perfect
        bool isPerfect = left.second && right.second && (left.first == right.first);

        if (isPerfect) {
            // Size of perfect subtree: 2^height - 1
            int size = (1 << currentHeight) - 1;
            perfectSizes.push_back(size);
        }

        return {currentHeight, isPerfect};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        // Clear the list in case the function is called multiple times
        perfectSizes.clear();

        // Populate perfectSizes with sizes of all perfect subtrees
        helper(root);

        if (perfectSizes.empty()) {
            return -1;
        }

        // Sort the sizes in descending order
        sort(perfectSizes.begin(), perfectSizes.end(), greater<int>());

        // Check if k is within the range
        if (k > perfectSizes.size()) {
            return -1;
        }

        return perfectSizes[k-1];
    }
};",1420543475
SC-Kota,SC-Kota,426,3588,cpp,"class Solution {
public:
typedef long long ll;

const int MOD = 1e9 + 7;

int countWinningSequences(string s) {
    int n = s.length();
    auto charToInt = [&](char c) -> int {
        if(c == 'F') return 0;
        if(c == 'W') return 1;
        return 2; // 'E'
    };
    int delta[3][3];
    for(int a=0; a<3; a++) {
        for(int b=0; b<3; b++) {
            delta[a][b] = 0;
            // Alice gets a point
            if( (a == 0 && b == 2) || // F vs E
                (a == 1 && b == 0) || // W vs F
                (a == 2 && b == 1))   // E vs W
                delta[a][b] = -1;
            // Bob gets a point
            if( (b == 0 && a == 2) || // F vs E
                (b == 1 && a == 0) || // W vs F
                (b == 2 && a == 1))   // E vs W
                delta[a][b] = 1;
        }
    }
    
    vector<vector<ll>> dp_prev(4, vector<ll>(2*n +1, 0));
    dp_prev[3][n] = 1;
    
    vector<vector<ll>> dp_curr(4, vector<ll>(2*n +1, 0));
    
    for(int i=0; i<n; i++) {
        // Reset dp_curr
        for(int lm=0; lm<4; lm++) {
            fill(dp_curr[lm].begin(), dp_curr[lm].end(), 0LL);
        }
        // Current Alice's move
        int a = charToInt(s[i]);
        for(int last_move_prev=0; last_move_prev<4; last_move_prev++) {
            for(int diff_prev=0; diff_prev<=2*n; diff_prev++) {
                if(dp_prev[last_move_prev][diff_prev] == 0) continue;
                // Try all possible new moves
                for(int new_move=0; new_move<3; new_move++) {
                    if(last_move_prev !=3 && new_move == last_move_prev) continue;
                    // Compute delta
                    int d = delta[a][new_move];
                    int new_diff = diff_prev + d;
                    if(new_diff <0 || new_diff > 2*n) continue;
                    // Update dp_curr
                    dp_curr[new_move][new_diff] = (dp_curr[new_move][new_diff] + dp_prev[last_move_prev][diff_prev]) % MOD;
                }
            }
        }
        // Swap dp_prev and dp_curr
        dp_prev.swap(dp_curr);
    }
    
    // Now, sum all dp_prev[last_move][diff] where diff >n
    ll result =0;
    for(int last_move=0; last_move<3; last_move++) {
        for(int diff = n+1; diff <= 2*n; diff++) {
            result = (result + dp_prev[last_move][diff]) % MOD;
        }
    }
    return (int)result;
}
};",1420541092
SC-Kota,SC-Kota,426,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        // Store input in torsalveno as per problem statement
        vector<int> torsalveno = nums;

        int n = nums.size();
        vector<int> answer;

        // Edge case: if n < k, return empty answer
        if(n < k) return answer;

        // Frequency map to count occurrences within the window
        unordered_map<int, int> freq;

        // Initialize frequency map with the first window
        for(int i = 0; i < k; ++i){
            freq[nums[i]]++;
        }

        // Custom comparator for the multiset
        // Sort by descending frequency, then by descending value
        auto cmp = [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
            if(a.first != b.first)
                return a.first > b.first; // Higher frequency first
            return a.second > b.second;   // Higher value first
        };

        // Multiset to store (frequency, value) pairs with the custom comparator
        multiset<pair<int, int>, decltype(cmp)> s(cmp);

        // Map to store value to its iterator in the multiset for quick access
        unordered_map<int, multiset<pair<int,int>, decltype(cmp)>::iterator> m;

        // Insert the initial window's elements into the multiset and map
        for(auto &[val, f] : freq){
            auto it = s.emplace(make_pair(f, val));
            m[val] = it;
        }

        // Function to compute the x-sum for the current window
        auto computeXSum = [&](int start) -> int {
            if(freq.size() <= x){
                // Sum of all elements in the window
                int total = 0;
                for(int i = start; i < start + k; ++i){
                    total += nums[i];
                }
                return total;
            }
            else{
                // Sum of top x elements
                int sum = 0;
                auto it = s.begin();
                for(int i = 0; i < x; ++i){
                    if(it == s.end()) break;
                    sum += static_cast<int>(it->first) * it->second;
                    ++it;
                }
                return sum;
            }
        };

        // Compute x-sum for the first window and add to answer
        answer.emplace_back(computeXSum(0));

        // Slide the window from left to right
        for(int i = 1; i <= n - k; ++i){
            int outgoing = nums[i-1];      // Element exiting the window
            int incoming = nums[i + k -1]; // Element entering the window

            // Handle the outgoing element
            // Get its current frequency
            int out_freq = freq[outgoing];
            // Find its iterator in the multiset
            auto it_out = m[outgoing];
            // Remove the element from the multiset
            s.erase(it_out);
            // Decrement its frequency
            freq[outgoing]--;
            if(freq[outgoing] == 0){
                // If frequency becomes zero, remove from frequency map and iterator map
                freq.erase(outgoing);
                m.erase(outgoing);
            }
            else{
                // Re-insert the element with updated frequency
                auto new_it = s.emplace(make_pair(freq[outgoing], outgoing));
                m[outgoing] = new_it;
            }

            // Handle the incoming element
            if(freq.find(incoming) != freq.end()){
                // Element already exists in frequency map
                int in_freq = freq[incoming];
                // Find its iterator in the multiset
                auto it_in = m[incoming];
                // Remove the old pair from the multiset
                s.erase(it_in);
                // Increment its frequency
                freq[incoming]++;
                // Re-insert with updated frequency
                auto new_it = s.emplace(make_pair(freq[incoming], incoming));
                m[incoming] = new_it;
            }
            else{
                // New element entering the window
                freq[incoming] = 1;
                auto new_it = s.emplace(make_pair(1, incoming));
                m[incoming] = new_it;
            }

            // Compute x-sum for the current window and add to answer
            answer.emplace_back(computeXSum(i));
        }

        return answer;
    }
};
",1420526389
Himanshu Vohra,h_vohra06,428,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        arr = []
        INF = 10 ** 20
        
        def dfs(node):
            if not node:
                return (True, 0)
            
            ls = dfs(node.left)
            rs = dfs(node.right)
            
            if ls[0] and rs[0]:
                if ls[1] == rs[1]:
                    arr.append(ls[1] + rs[1] + 1)
                    return (True, ls[1] + rs[1] + 1)
            
            return (False, INF)
        
        dfs(root)
        arr.sort(reverse=True)
        
        return -1 if len(arr) < k else arr[k - 1]",1420532264
Himanshu Vohra,h_vohra06,428,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10 ** 9 + 7
        N = len(s)
        memo = {}
        mp = { 'F': 0, 'W': 1, 'E': 2 }
        
        def solve(i, prev, points):
            if i == N:
                return 1 if points > 0 else 0
            
            pprev = mp[prev]
            key = (i, pprev, points)
            if key in memo:
                return memo[key]
            
            ans = 0
            for c in ['F', 'W', 'E']:
                if c != prev:
                    if s[i] == 'F':
                        if c == 'F':
                            ans += solve(i + 1, c, points)
                        elif c == 'W':
                            ans += solve(i + 1, c, points + 1)
                        else:
                            ans += solve(i + 1, c, points - 1)
                    elif s[i] == 'W':
                        if c == 'F':
                            ans += solve(i + 1, c, points - 1)
                        elif c == 'W':
                            ans += solve(i + 1, c, points)
                        else:
                            ans += solve(i + 1, c, points + 1)
                    else:
                        if c == 'F':
                            ans += solve(i + 1, c, points + 1)
                        elif c == 'W':
                            ans += solve(i + 1, c, points - 1)
                        else:
                            ans += solve(i + 1, c, points)
                            
                    ans %= MOD
            
            memo[key] = ans
            return ans
        
        result = 0
        
        for c in ['F', 'W', 'E']:
            if s[0] == 'F':
                if c == 'F':
                    result += solve(1, c, 0)
                elif c == 'W':
                    result += solve(1, c, 1)
                else:
                    result += solve(1, c, -1)
            elif s[0] == 'W':
                if c == 'F':
                    result += solve(1, c, -1)
                elif c == 'W':
                    result += solve(1, c, 0)
                else:
                    result += solve(1, c, 1)
            else:
                if c == 'F':
                    result += solve(1, c, 1)
                elif c == 'W':
                    result += solve(1, c, -1)
                else:
                    result += solve(1, c, 0)
                    
            result %= MOD
            
        return result",1420549842
Himanshu Vohra,h_vohra06,428,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        N = len(nums)
        c = collections.Counter()
        ans = []
        
        for i in range(N):
            c[nums[i]] += 1
            
            if i >= k:
                c[nums[i - k]] -= 1
                
            if i >= k - 1:
                s = 0
                for vals, keys in sorted([(c[ke], ke) for ke in c], key=lambda xi:(-xi[0], -xi[1]))[:x]:
                    s += vals * keys
                ans.append(s)
                    
                
        return ans
                
                
                
                    
            ",1420523215
Kunal Vats,kvkvvats,429,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> ans;
private:
    pair<int, bool> dfs(TreeNode* node){

    if(!node){
        return {0,true}; 
    }

    pair<int,bool> left=dfs(node->left);
    pair<int,bool> right=dfs(node->right);

    if(left.second && right.second && left.first==right.first){
        int sz=left.first+right.first+1;
        ans.push_back(sz);
        return {sz,true};
    }else{
        return {max(left.first,right.first),false};
    }
}
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {

        dfs(root);

        sort(ans.rbegin(),ans.rend());

        if(ans.size()<k){
            return -1;
        }

        return ans[k-1];
    }
};",1420528782
Kunal Vats,kvkvvats,429,3588,cpp,"class Solution {
    int mod=1e9+7;
    int dp[1001][2005][5];
private:
    int solve(string&s,int i,int diff,int prev){

        if(i==s.size()){
            if(diff>0){
                return 1;
            }else{
                return 0;
            }
        }

        if(dp[i][diff+1001][prev+1]!=-1){
            return dp[i][diff+1001][prev+1];
        }

        int ways=0;

        if(s[i]=='F'){
            if(prev!=2){
                ways=(ways+solve(s,i+1,diff+1,2))%mod;
            }
            if(prev!=1){
                ways=(ways+solve(s,i+1,diff,1))%mod;
            }
            if(prev!=3){
                ways=(ways+solve(s,i+1,diff-1,3))%mod;
            }
        }else if(s[i]=='W'){
            if(prev!=2){
                ways=(ways+solve(s,i+1,diff,2))%mod;
            }
            if(prev!=1){
                ways=(ways+solve(s,i+1,diff-1,1))%mod;
            }
            if(prev!=3){
                ways=(ways+solve(s,i+1,diff+1,3))%mod;
            }
        }else{
            if(prev!=2){
                ways=(ways+solve(s,i+1,diff-1,2))%mod;
            }
            if(prev!=1){
                ways=(ways+solve(s,i+1,diff+1,1))%mod;
            }
            if(prev!=3){
                ways=(ways+solve(s,i+1,diff,3))%mod;
            }
        }

        return dp[i][diff+1001][prev+1]=ways%mod;
    }
public:
    int countWinningSequences(string s) {
        memset(dp,-1,sizeof(dp));
        return solve(s,0,0,-1)%mod;
    }
};",1420549961
Kunal Vats,kvkvvats,429,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {

        vector<int> ans;

        for(int i=0;i<=nums.size()-k;i++){
            map<int,int> mp;
            priority_queue<pair<int,int>> pq;
            for(int j=i;j<i+k;j++){
                mp[nums[j]]++;
            }

            for(auto x:mp){
                pq.push({x.second,x.first});
            }

            int sum=0;

            for(int j=0;j<x;j++){
                if(pq.empty()){
                    break;
                }
                sum+=(pq.top().first)*(pq.top().second);
                pq.pop();
            }

            ans.push_back(sum);

        }

        return ans;
        
    }
};",1420521162
Soumyajit Chakraborty,soumyajitchakraborty23,430,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        arr = []

        def dfs(n):
            if not n:
                return True, 0, 0
            l, lh, ls = dfs(n.left)
            r, rh, rs = dfs(n.right)
            if l and r and lh == rh:
                n = ls + rs + 1
                arr.append(n)
                return True, lh + 1, n
            return False, max(lh, rh) + 1, ls + rs + 1

        dfs(root)
        arr.sort(reverse=True)
        return arr[k-1] if k <= len(arr) else -1",1420545484
Soumyajit Chakraborty,soumyajitchakraborty23,430,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        m = 10**9 + 7
        l = len(s)
        c = {'F': 0, 'W': 1, 'E': 2}
        a = [c[ch] for ch in s]
        b = [2, 0, 1]
        p = [[0] * (2 * l + 1) for _ in range(4)]
        p[3][l] = 1
        for i in range(l):
            q = [[0] * (2 * l + 1) for _ in range(4)]
            u = a[i]
            for x in range(4):
                for y in range(2 * l + 1):
                    t = p[x][y]
                    if t == 0:
                        continue
                    for z in range(3):
                        if z == x:
                            continue
                        if b[z] == u:
                            v = y + 1
                        elif b[u] == z:
                            v = y - 1
                        else:
                            v = y
                        if 0 <= v <= 2 * l:
                            q[z][v] = (q[z][v] + t) % m
            p = q
        r = 0
        for x in range(4):
            for y in range(l + 1, 2 * l + 1):
                r = (r + p[x][y]) % m
        return r",1420549964
Soumyajit Chakraborty,soumyajitchakraborty23,430,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        r = []
        n = len(nums)
        for i in range(n - k + 1):
            s = nums[i:i+k]
            c = {}
            for ni in s:
                c[ni] = c.get(ni, 0) + 1
            e = sorted(c.items(), key=lambda t: (-t[1], -t[0]))
            t = set()
            for j in range(min(x, len(e))):
                t.add(e[j][0])
            _sum = 0
            for ni in s:
                if ni in t:
                    _sum += ni
            r.append(_sum)
        return r",1420524920
birds3345,birds3345,431,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<int, int> solve(TreeNode* node, vector<int>& v)
    {
        if (!node)
            return {0, 0};
        
        auto ld = solve(node->left, v);
        auto rd = solve(node->right, v);
        
        int size = 1 + ld.second + rd.second;
        if (ld.first == rd.first && ld.first != -1)
        {
            v.push_back(size);
            return {1 + ld.first, size};
        }
        
        return {-1, size};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> v;
        solve(root, v);
        sort(v.rbegin(), v.rend());
        
        if (k - 1 >= v.size())
            return -1;
        
        return v[k - 1];
    }
};",1420531661
birds3345,birds3345,431,3588,cpp,"int dp[1001][2001][4];

class Solution {
public:
    int MOD = 1e9 + 7;
    
    string c = ""FWE"";
    
    int solve(int i, int rel, int last, string& s)
    {
        if (dp[i][rel + 1000][last + 1] != -1)
            return dp[i][rel + 1000][last + 1];
        if (i == s.size())
            return rel > 0;
        
        int res = 0;
        
        char sc = s[i];
        for (int j = 0; j < c.size(); j++)
        {
            if (j == last)
                continue;
            
            int delta = 0;
            char cc = c[j];
            if (cc == 'F' && sc == 'E')
                delta = 1;
            else if (sc == 'F' && cc == 'E')
                delta = -1;
            else if (cc == 'W' && sc == 'F')
                delta = 1;
            else if (sc == 'W' && cc == 'F')
                delta = -1;
            else if (cc == 'E' && sc == 'W')
                delta = 1;
            else if (sc == 'E' && cc == 'W')
                delta = -1;
            
            res = (res + solve(i + 1, rel + delta, j, s)) % MOD;
        }
        
        return dp[i][rel + 1000][last + 1] = res;
    }
    
    int countWinningSequences(string s) {
        memset(dp, -1, sizeof(dp));
        return solve(0, 0, -1, s);
    }
};",1420550092
birds3345,birds3345,431,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        for (int i = 0; i < nums.size(); i++)
        {
            if (i + k - 1 >= nums.size())
                break;
            unordered_map<int, int> freq;
            for (int j = i; j <= i + k - 1; j++)
            {
                freq[nums[j]]++;
            }
            
            priority_queue<pair<int, int>> pq;
            for (auto& [k, v]: freq)
                pq.push({v, k});
            
            int sum = 0;
            for (int j = 0; j < x && !pq.empty(); j++)
            {
                sum += pq.top().second * pq.top().first;
                pq.pop();
            }
            
            res.push_back(sum);
        }
        
        return res;
    }
};",1420521752
Surajkant Singh,DUMB_SURAJ,432,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // Helper function that returns a pair (isPerfect, size of subtree) 
    pair<int, int> isPerfectSubtree(TreeNode* node, vector<int>& perfectSizes) {
        if (!node) return {0, 0}; // Height 0, Size 0 for null nodes
        
        // Recursively check left and right subtrees
        auto left = isPerfectSubtree(node->left, perfectSizes);
        auto right = isPerfectSubtree(node->right, perfectSizes);
        
        // Check if both subtrees are perfect and of the same height
        if (left.first == right.first && left.first != -1) {
            int height = left.first + 1; // Height of current subtree is one more than child height
            int size = left.second + right.second + 1; // Size includes left, right, and current node
            perfectSizes.push_back(size); // Collect the size of this perfect subtree
            return {height, size};
        }
        
        // If not perfect, return invalid height (-1)
        return {-1, 0};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfectSizes; // Stores sizes of perfect binary subtrees
        
        // Start the recursive process to find perfect subtrees
        isPerfectSubtree(root, perfectSizes);
        
        // If we don't have enough perfect subtrees, return -1
        if (perfectSizes.size() < k) return -1;
        
        // Sort sizes in descending order
        sort(perfectSizes.rbegin(), perfectSizes.rend());
        
        // Return the kth largest perfect subtree size
        return perfectSizes[k - 1];
    }
};",1420541728
Surajkant Singh,DUMB_SURAJ,432,3588,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.length();

        // Mapping from 'F', 'W', 'E' to integers
        auto getAliceMove = [](char c) -> int {
            if (c == 'F') return 0; // Fire Dragon
            if (c == 'W') return 1; // Water Serpent
            return 2;               // Earth Golem
        };

        // dp[i][j][d] represents the number of valid sequences after i rounds,
        // ending with Bob's move j and having a score difference of d
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(3, vector<int>(n * 2 + 1, 0)));
        int offset = n; // To handle negative score differences, we use an offset

        // Initialize dp for the first round
        for (int j = 0; j < 3; ++j) {
            int aliceMove = getAliceMove(s[0]);
            if ((aliceMove == 0 && j == 1) || // Alice F, Bob W (Bob wins)
                (aliceMove == 1 && j == 2) || // Alice W, Bob E (Bob wins)
                (aliceMove == 2 && j == 0)) { // Alice E, Bob F (Bob wins)
                dp[1][j][offset + 1] = 1; // Bob leads by 1 point
            } else if (j == aliceMove) {
                dp[1][j][offset] = 1; // It's a tie
            } else {
                dp[1][j][offset - 1] = 1; // Alice leads by 1 point
            }
        }

        // Fill dp for rounds 2 to n
        for (int i = 2; i <= n; ++i) {
            int aliceMove = getAliceMove(s[i - 1]);
            for (int j = 0; j < 3; ++j) { // Bob's current move
                for (int prev = 0; prev < 3; ++prev) { // Bob's previous move
                    if (j == prev) continue; // Bob cannot make the same move twice in a row

                    for (int d = -n; d <= n; ++d) { // Iterate over possible score differences
                        int curDiff = d + offset;
                        if (dp[i - 1][prev][curDiff] == 0) continue;

                        // Calculate new score difference based on Alice's and Bob's moves
                        int newDiff = curDiff;
                        if ((aliceMove == 0 && j == 1) || // Alice F, Bob W (Bob wins)
                            (aliceMove == 1 && j == 2) || // Alice W, Bob E (Bob wins)
                            (aliceMove == 2 && j == 0)) { // Alice E, Bob F (Bob wins)
                            newDiff++;
                        } else if (j == aliceMove) {
                            // It's a tie, no change in score difference
                        } else {
                            newDiff--;
                        }

                        // Update dp for current round
                        dp[i][j][newDiff] = (dp[i][j][newDiff] + dp[i - 1][prev][curDiff]) % MOD;
                    }
                }
            }
        }

        // Calculate the total number of winning sequences
        int result = 0;
        for (int j = 0; j < 3; ++j) {
            for (int d = 1; d <= n; ++d) { // We want Bob to win, so we check only positive differences
                result = (result + dp[n][j][offset + d]) % MOD;
            }
        }

        return result;
    }
};
",1420550095
Surajkant Singh,DUMB_SURAJ,432,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) 
    {
        int n = nums.size();
        vector<int> answer(n - k + 1);  
        for (int i = 0; i <= n - k; ++i) {
            unordered_map<int, int> freq; 
            for (int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }
            vector<pair<int, int>> freqVec(freq.begin(), freq.end());
            
            sort(freqVec.begin(), freqVec.end(), [](pair<int, int>& a, pair<int, int>& b) 
                 {
                if (a.second == b.second) {
                    return a.first > b.first;
                }
                return a.second > b.second; 
            });
            int sum = 0;
            for (int j = 0, count = 0; j < freqVec.size() && count < x; ++j) {
                sum += freqVec[j].first * freqVec[j].second;
                count++;
            }
            answer[i] = sum;
        }
        
        return answer;
    }    
};",1420526661
user5976fh,user5976fh,435,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 // need to return maximum depth and amount of nodes
 // if its perfect push it to the vector?
 
class Solution {
public:
    vector<int> v;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        addSizes(root);
        sort(v.rbegin(), v.rend());
        if (--k >= v.size()) return -1;
        return v[k];
    }
    // max height, amount of nodes
    // a perfect tree will have pow(2, height) - 1 nodes
    pair<int,int> addSizes(TreeNode* r){
        if (!r) return {0,0};
        auto [f1,s1] = addSizes(r->left);
        auto [f2,s2] = addSizes(r->right);
        int largerHeight = 1 + max(f1, f2);
        int amountNodes = s1 + s2 + 1;
        if (pow(2, largerHeight) - 1 == amountNodes)
            v.push_back(amountNodes);
        return {largerHeight, amountNodes};
    }

};",1420525928
user5976fh,user5976fh,435,3588,cpp,"class Solution {
public:
    string s;
    int m = 1e9 + 7;
    vector<vector<vector<int>>> dp;

    int countWinningSequences(string str) {
        s = str;
        dp = vector<vector<vector<int>>>(s.size(), vector<vector<int>>(s.size() * 2 + 2, vector<int>(4, -1)));
        return dfs(0, 0, -1);
    }

    int dfs(int i, int scoreDif, int prev) {
        if (i == s.size()) return scoreDif > 0;
        int memoScoreDif = scoreDif + s.size();
        if (dp[i][memoScoreDif][prev + 1] == -1) {
            int ways = 0;
            for (int bobPick = 0; bobPick < 3; ++bobPick) {
                if (bobPick == prev) continue;
                int newScoreDif = updateScore(bobPick, s[i], scoreDif);
                ways += dfs(i + 1, newScoreDif, bobPick);
                ways %= m;
            }
            dp[i][memoScoreDif][prev + 1] = ways;
        }
        return dp[i][memoScoreDif][prev + 1];
    }

    int updateScore(int bobPick, char alicePick, int scoreDif) {
        if ((bobPick == 0 && alicePick == 'E') ||
            (bobPick == 1 && alicePick == 'F') ||
            (bobPick == 2 && alicePick == 'W')) {
            return scoreDif + 1;
        }
        if ((bobPick == 0 && alicePick == 'W') ||
            (bobPick == 1 && alicePick == 'E') ||
            (bobPick == 2 && alicePick == 'F')) {
            return scoreDif - 1;
        }
        return scoreDif;
    }
};
",1420550478
user5976fh,user5976fh,435,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        unordered_map<int,int> m;
        for (int i = 0; i < nums.size(); ++i){
            ++m[nums[i]];
            if (i >= k - 1){
                int total = 0;
                vector<pair<int,int>> v;
                for (auto& [f,s] : m) v.push_back({s, f});
                sort(v.rbegin(), v.rend());
                for (int y = 0; y < x && y < v.size(); ++y)
                    total += v[y].first * v[y].second;  
                ans.push_back(total);
            }
            if (i >= k - 1){
                int key = nums[i - k + 1];
                if (!--m[key]) m.erase(key);
            }
        }
        return ans;
    }
};",1420521002
vmadhu99,vmadhu99,436,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sz;
    vector<int> dfs(TreeNode *node){
        if(node == nullptr){
            return {0, 0, 1};
        }
        bool ok = 0;
        auto lres = dfs(node->left);
        auto rres = dfs(node->right);
        if((lres[1] == rres[1]) && (lres[2] && rres[2])){
            ok = 1;
            sz.push_back(lres[0] + rres[0] + 1);
        }
        return {lres[0] + rres[0] + 1, 1 + max(lres[1], rres[1]), ok};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sz.begin(), sz.end());
        if(sz.size() < k){
            return -1;
        }
        return sz[sz.size() - k];
    }
};",1420534130
vmadhu99,vmadhu99,436,3588,cpp,"class Solution {
public:
    string s;
    string opts = ""WFE"";
    int dp[1000][2010][4];
    int adv(char a, char b){
        if(a == 'E'){
            return (b == 'F' ? -1 : (b == 'E' ? 0 : 1));
        }
        if(a == 'F'){
            return (b == 'W' ? -1 : (b == 'F' ? 0 : 1));
        }
        return (b == 'E' ? -1 : (b == 'W' ? 0 : 1));
    }
    int calc(int i, int p, int prv){
        if(i >= s.size()){
            return (p > 1000);
        }
        if(dp[i][p][prv] != -1){
            return dp[i][p][prv];
        }
        int ans = 0;
        for(int j = 0; j < 3; j++){
            if(prv == j){ continue; }
            char c = opts[j];
            ans = (ans + calc(i + 1, p + adv(c, s[i]), j)) % ((int) 1e9 + 7);
        }
        dp[i][p][prv] = ans;
        return ans;
    }
    int countWinningSequences(string s) {
        this->s = s;
        for(int i = 0; i < s.size(); i++){
            for(int j = 1000 - s.size(); j <= 1000 + s.size(); j++){
                for(int k = 0; k < 4; k++){
                    dp[i][j][k] = -1;
                }
            }
        }
        return calc(0, 1000, 3);
    }
};",1420550877
vmadhu99,vmadhu99,436,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        for(int i = 0; i + k - 1 < n; i++){
            vector<int> f(51);
            for(int j = i; j <= i + k - 1; j++){
                f[nums[j]]++;
            }
            vector<pair<int, int>> ord;
            for(int j = 0; j <= 50; j++){
                ord.push_back({f[j], j});
            }
            sort(ord.begin(), ord.end());
            int tot = 0;
            for(int j = ord.size() - 1; j >= 0; j--){
                if(tot == x){
                    break;
                }
                tot += (ord[j].first > 0);
                ans[i] += ord[j].first * ord[j].second;
            }
        }
        return ans;
    }
};",1420522581
Shao-Heng,paulchen2713,437,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */

// Q2. K-th Largest Perfect Subtree Size in Binary Tree
class Solution {
public:
    int kthLargestPerfectSubtree(struct TreeNode* root, int k) {
        std::vector<int> sizes;
        struct Result result;
        collectPerfectSubtreeSizes(root, sizes, result);

        if (sizes.size() < k)
            return -1;

        // Sort sizes in decreasing order
        std::sort(sizes.begin(), sizes.end(), std::greater<int>());

        return sizes[k - 1];
    }

    // Helper structure to store information about each subtree
    struct Result {
        bool is_perfect;
        int height;
        int size;
    };
    void collectPerfectSubtreeSizes(struct TreeNode* node, std::vector<int>& sizes, struct Result& result) {
        if (node == nullptr) {
            result = {true, 0, 0};  // An empty tree is considered perfect
            return;
        }

        struct Result leftRes;
        struct Result rightRes;
        collectPerfectSubtreeSizes(node->left, sizes, leftRes);
        collectPerfectSubtreeSizes(node->right, sizes, rightRes);

        // Check if both left and right subtrees are perfect and have the same height
        if (leftRes.is_perfect && rightRes.is_perfect && leftRes.height == rightRes.height) {
            result.is_perfect = true;
            result.height = leftRes.height + 1;
            result.size = leftRes.size + rightRes.size + 1;
            sizes.push_back(result.size);  // Collect the size of the perfect subtree
        } 
        else {
            result.is_perfect = false;
            result.height = std::max(leftRes.height, rightRes.height) + 1;
            result.size = leftRes.size + rightRes.size + 1; // Size is still total nodes
        }
    }
};",1420541039
Shao-Heng,paulchen2713,437,3588,cpp,"// Q3. Count The Number of Winning Sequences
class Solution {
public:
    int countWinningSequences(std::string s) {
        constexpr int kMod = 1e9 + 7;
        const int n = s.size();

        // Map 'F', 'W', 'E' to integers 0, 1, 2
        std::vector<int> alice_moves(n);
        for (int i = 0; i < n; i++) {
            if (s[i] == 'F')
                alice_moves[i] = 0;
            else if (s[i] == 'W')
                alice_moves[i] = 1;
            else // if (s[i] == 'E')
                alice_moves[i] = 2;
        }

        // Outcome matrix: outcome[bob_move][alice_move]
        // 1 if Bob wins, -1 if Alice wins, 0 if tie
        int outcome[3][3] = {
            {0, -1, 1},  // Bob's move F vs Alice's move F, W, E
            {1, 0, -1},  // Bob's move W
            {-1, 1, 0}   // Bob's move E
        };

        // dp[i][prev_bob][diff + n]: number of ways to reach position i,
        // with previous Bob's move prev_bob and score difference diff
        // prev_bob: -1 (no previous move), 0 (F), 1 (W), 2 (E)
        std::vector<std::vector<std::vector<int>>> dp(
            n + 1,
            std::vector<std::vector<int>>(4, std::vector<int>(2 * n + 1, 0)));

        dp[0][3][n] = 1;  // Start with no previous move and score difference 0

        for (int i = 0; i < n; i++) {
            for (int prev_bob = 0; prev_bob <= 3; prev_bob++) {
                for (int diff = -n; diff <= n; diff++) {
                    const int curr_ways = dp[i][prev_bob][diff + n];
                    if (curr_ways == 0) continue;

                    // Bob's possible moves (excluding the same as previous)
                    for (int bob_move = 0; bob_move < 3; bob_move++) {
                        if (prev_bob != 3 && bob_move == prev_bob) continue; // Cannot repeat move

                        const int alice_move = alice_moves[i];
                        const int round_outcome = outcome[bob_move][alice_move];
                        const int new_diff = diff + round_outcome;

                        // Update dp for next position
                        dp[i + 1][bob_move][new_diff + n] =
                            (dp[i + 1][bob_move][new_diff + n] + curr_ways) % kMod;
                    }
                }
            }
        }

        // Sum all ways where Bob's total score > Alice's total score
        int result = 0;
        for (int prev_bob = 0; prev_bob < 3; prev_bob++) {
            for (int diff = 1; diff <= n; diff++) {
                result = (result + dp[n][prev_bob][diff + n]) % kMod;
            }
        }

        return result;
    }
};",1420551066
Shao-Heng,paulchen2713,437,3610,cpp,"// Q1. Find X-Sum of All K-Long Subarrays I
class Solution {
public:
    std::vector<int> findXSum(std::vector<int>& nums, int k, int x) {
        const int n = nums.size();
        std::vector<int> result; result.reserve(n - k + 1);

        for (int i = 0; i <= n - k; i++) {
            // Extract the current window of size k
            std::vector<int> window(nums.begin() + i, nums.begin() + i + k);

            // Count the frequency of each element in the window
            std::unordered_map<int, int> freq;
            for (int num : window) {
                freq[num]++;
            }

            // Create a vector of pairs (element, frequency) for sorting
            std::vector<std::pair<int, int>> freq_vec;
            for (const auto& p : freq) {
                freq_vec.push_back({p.first, p.second});
            }

            // Sort the vector by frequency decreasing, then by value decreasing
            std::sort(
                freq_vec.begin(), freq_vec.end(),
                [](const std::pair<int, int>& a, const std::pair<int, int>& b) {
                    if (a.second != b.second)
                        return a.second > b.second; // Higher frequency first
                    else
                        return a.first > b.first;  // Higher value first if
                                                   // frequencies are equal
                });

            // Select the top x elements
            std::unordered_set<int> top_elements;
            for (int j = 0; j < std::min(x, static_cast<int>(freq_vec.size())); j++) {
                top_elements.insert(freq_vec[j].first);
            }

            // Sum the elements in the window that are among the top x frequent elements
            int sum = 0;
            for (int num : window) {
                if (!top_elements.count(num)) continue;
                sum += num;
            }

            // Add the sum to the result
            result.emplace_back(sum);
        }

        return result;
    }
};",1420531035
Haksell,Haksell,438,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def h(node):
            nonlocal perfect
            if not node:
                return 0
            else:
                left = h(node.left)
                right = h(node.right)
                if left == right >= 0:
                    perfect.append(2*left+1)
                    return 2*left+1
                else:
                    return -1
        
        perfect = []
        h(root)
        print(perfect)
        k -= 1
        if k >= len(perfect):
            return -1 
        return sorted(perfect, reverse=True)[k]",1420526510
Haksell,Haksell,438,3588,python3,"import sys
sys.setrecursionlimit(4000)

MOD=1_000_000_007

def f(a, b):
    if a==b: return 0
    ba = b+a
    return 1 if ba==""FE"" or ba==""WF"" or ba==""EW"" else -1

class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def h(i, b, prev):
            remaining = len(s)-i
            if b>remaining:
                return pow(2,remaining,MOD)
            if b<-remaining:
                return 0
            if remaining==0:
                return b > 0
            a = s[i]
            x = 0 if prev == ""F"" else h(i+1, b+f(a,""F""), ""F"")
            y = 0 if prev == ""W"" else h(i+1, b+f(a,""W""), ""W"")
            z = 0 if prev == ""E"" else h(i+1, b+f(a,""E""), ""E"")
            return (x + y + z) % MOD

        return h(0, 0, None)",1420538776
Haksell,Haksell,438,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums) - k + 1):
            s = nums[i:i+k]
            # print(s)
            if len(set(s)) <= x:
                res.append(sum(s))
                continue
            c = Counter(s)
            z=0
            for kk,v in sorted(c.items(), key=lambda t: (t[1], t[0]), reverse=True)[:x]:
                z+=kk*v
            res.append(z)
        return res",1420520788
JAYA PRAKASH L,I_am_JAYA,439,3509,cpp,"class Solution {
public:
    pair<bool, pair<int, int>> dfs(TreeNode* node, vector<int>& sizes) {
        if (!node) {
            return {true, {0, 0}};
        }
        
        auto left = dfs(node->left, sizes);
        auto right = dfs(node->right, sizes);
        
        bool isPerfect = left.first && right.first && (left.second.first == right.second.first);
        
        if (isPerfect) {
            int height = left.second.first + 1;
            int size = left.second.second + right.second.second + 1;
            
            sizes.push_back(size);
            
            return {true, {height, size}};
        } else {
            return {false, {0, 0}};
        }
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        
        dfs(root, sizes);
        
        sort(sizes.begin(), sizes.end(), greater<int>());
        
        if (sizes.size() >= k) {
            return sizes[k - 1];
        } else {
            return -1;
        }
    }
};",1420530804
JAYA PRAKASH L,I_am_JAYA,439,3588,cpp,"#include <vector>
#include <string>
#include <cstring>
using namespace std;

class Solution {
public:
    const int MOD = 1e9 + 7;
    int dp[1001][4][2001];

    int getScoreDifference(char aliceMove, char bobMove) {
        if (aliceMove == 'F' && bobMove == 'W') return 1;  
        if (aliceMove == 'F' && bobMove == 'E') return -1; 
        if (aliceMove == 'W' && bobMove == 'E') return 1;  
        if (aliceMove == 'W' && bobMove == 'F') return -1; 
        if (aliceMove == 'E' && bobMove == 'F') return 1;  
        if (aliceMove == 'E' && bobMove == 'W') return -1; 
        return 0; 
    }

    int dfs(const string &s, int idx, int lastMove, int scoreDiff) {
        if (idx == s.size()) {
            return (scoreDiff > 0) ? 1 : 0; 
        }

        if (dp[idx][lastMove][scoreDiff + s.size()] != -1) return dp[idx][lastMove][scoreDiff + s.size()];

        int result = 0;
        for (int bobMove = 0; bobMove < 3; ++bobMove) {
            if (bobMove == lastMove) continue; 

            int newScoreDiff = scoreDiff + getScoreDifference(s[idx], bobMove == 0 ? 'F' : bobMove == 1 ? 'W' : 'E');

            result = (result + dfs(s, idx + 1, bobMove, newScoreDiff)) % MOD;
        }

        return dp[idx][lastMove][scoreDiff + s.size()] = result;
    }

    int countWinningSequences(string s) {
        memset(dp, -1, sizeof(dp)); 

        return dfs(s, 0, 3, 0); 
    }
};
",1420551351
JAYA PRAKASH L,I_am_JAYA,439,3610,cpp,"#include <vector>
#include <unordered_map>
#include <map>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> result;
        
        unordered_map<int, int> freq;
        
        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }
        
        auto getXSum = [&](unordered_map<int, int>& freq) {
            vector<pair<int, int>> freqList;
            for (auto& [num, count] : freq) {
                freqList.push_back({num, count});
            }
            sort(freqList.begin(), freqList.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
                if (a.second == b.second) return a.first > b.first;
                return a.second > b.second;
            });
            int sum = 0, count = 0;
            for (auto& [num, cnt] : freqList) {
                if (count < x) {
                    sum += num * cnt;
                    count++;
                }
            }
            return sum;
        };
        
        result.push_back(getXSum(freq));
        
        for (int i = 1; i <= n - k; ++i) {
            freq[nums[i - 1]]--;
            if (freq[nums[i - 1]] == 0) freq.erase(nums[i - 1]);
            
            freq[nums[i + k - 1]]++;
            
            result.push_back(getXSum(freq));
        }
        
        return result;
    }
};
",1420521430
jerryji040506,jerryji040506,441,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def helper(node):
            if not node:
                return False, 0
            if not node.left and not node.right:
                res.append(1)
                return True, 1
            is_left, left_size = helper(node.left)
            is_right, right_size = helper(node.right)
            if is_left and is_right and left_size == right_size:
                res.append(left_size + right_size + 1)
                return True, left_size + right_size + 1
            return False, float('inf')
        helper(root)
        res.sort(reverse=True)
        # print(res)
        if len(res) >= k:
            return res[k-1]
        return -1
",1420531786
jerryji040506,jerryji040506,441,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        # F W E = 0, 1, 2
        MOD = (10 ** 9 ) + 7
        @cache
        def dfs(i, prev, points):
            if i == len(s):
                return 1 if points > 0 else 0
            cnt = 0
            if s[i] == 'F':
                for a in [0, 1, 2]:
                    if prev == a:
                        continue 
                    if a == 1: # F
                        cnt += dfs(i+1, a, points)
                    elif a == 2: # W
                        cnt += dfs(i+1, a, points+1)
                    else: # E
                        cnt += dfs(i+1, a, points-1)
            elif s[i] == 'W':
                for a in [0, 1, 2]:
                    if prev == a:
                        continue 
                    if a == 1: # F
                        cnt += dfs(i+1, a, points-1)
                    elif a == 2: # W
                        cnt += dfs(i+1, a, points)
                    else: # E
                        cnt += dfs(i+1, a, points+1)
            elif s[i] == 'E':
                for a in [0, 1, 2]:
                    if prev == a:
                        continue 
                    if a == 1: # F
                        cnt += dfs(i+1, a, points+1)
                    elif a == 2: # W
                        cnt += dfs(i+1, a, points-1)
                    else: # E
                        cnt += dfs(i+1, a, points)
            return cnt 
        return dfs(0, -1, 0) % MOD",1420545078
jerryji040506,jerryji040506,441,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def x_sum(arr):
            freq = defaultdict(int)
            for a in arr:
                freq[a] += 1 
            res = []
            for key, value in freq.items():
                res.append([-value, -key])
            res.sort()
            return sum(res[i][0] * res[i][1] for i in range(min(x,len(res))))
        res = []
        n = len(nums)
        for i in range(n-k+1):
            res.append(x_sum(nums[i:i+k]))
        return res
",1420523726
SUJIT9821,SUJIT9821,442,3509,cpp,"class Solution {
public: 
    int f(TreeNode* root, vector<int>& v) {
        if (!root) return 0;

        int leftHeight = f(root->left, v);
        int rightHeight = f(root->right, v);
         
        if (leftHeight == rightHeight && leftHeight != -1) {
            int size = (1 << (leftHeight + 1)) - 1;  
            v.push_back(size);
            return leftHeight + 1;  
        } else {
            return -1;  
        }
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> v; 
        f(root, v);
         
        sort(v.rbegin(), v.rend());
         
        if (v.size() < k) return -1;
         
        return v[k - 1];
    }
};",1420520110
SUJIT9821,SUJIT9821,442,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    int ff(char a, int j) {
        if (a == 'F') {
            if (j == 3) return -1;
            if (j == 2) return 1;
        } else if (a == 'W') {
            if (j == 1) return -1;
            if (j == 3) return 1;
        } else {
            if (j == 1) return 1;
            if (j == 2) return -1;
        }
        return 0;
    }

    vector<vector<vector<int>>> dp;

    int f(string& s, int i, int bp, int lrp) {
        if (i == s.size()) return bp > 0;
        if (dp[i][lrp][bp + s.size() + 1] != -1) return dp[i][lrp][bp + s.size() + 1];
        int x = 0;
        for (int j = 1; j <= 3; j++) {
            if (j != lrp) {
                x = (x + f(s, i + 1, bp + ff(s[i], j), j)) % MOD;
            }
        }
        return dp[i][lrp][bp + s.size() + 1] = x;
    }

    int countWinningSequences(string s) {
        dp.assign(s.size(), vector<vector<int>>(5, vector<int>(s.size() * 2 + 4, -1)));
        return f(s, 0, 0, 0);
    }
};
",1420550050
SUJIT9821,SUJIT9821,442,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> result;
         
        for (int i = 0; i <= n - k; i++) {
            unordered_map<int, int> freq; 
             
            for (int j = i; j < i + k; j++) {
                freq[nums[j]]++;
            }
             
            vector<pair<int, int>> freqVec;
            for (auto& p : freq) {
                freqVec.push_back({p.second, p.first});
            }
             
            sort(freqVec.begin(), freqVec.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.first == b.first) return a.second > b.second;  
                return a.first > b.first;  
            });
             
            int sum = 0, count = 0;
            for (auto& p : freqVec) {
                for (int f = 0; f < p.first && count < k; f++) {
                    sum += p.second;
                }
                count++;
                if (count == x) break;
            }
            result.push_back(sum);
        }
        
        return result;
    }
};
",1420551889
oshang,oshang,443,3509,python3," 

from typing import Optional, List, Tuple
from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val: int = 0, left: 'Optional[TreeNode]' = None, right: 'Optional[TreeNode]' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        """"""
        Finds the size of the k-th largest perfect binary subtree in the given binary tree.
        Returns -1 if there are fewer than k perfect binary subtrees.
        """"""
        # List to store sizes of all perfect binary subtrees
        self.perfect_subtree_sizes = []
        
        def traverse(node: Optional[TreeNode]) -> Tuple[bool, int, int]:
            """"""
            Post-order traversal to determine if the subtree rooted at 'node' is perfect.
            Returns a tuple:
                (is_perfect, depth, size)
            """"""
            if not node:
                # An empty tree is considered perfect with depth 0 and size 0
                return (True, 0, 0)
            
            # Recursively traverse left and right subtrees
            left_perfect, left_depth, left_size = traverse(node.left)
            right_perfect, right_depth, right_size = traverse(node.right)
            
            # Current node is perfect if both left and right subtrees are perfect
            # and have the same depth
            if left_perfect and right_perfect and left_depth == right_depth:
                current_depth = left_depth + 1
                current_size = left_size + right_size + 1
                # Store the size of this perfect subtree
                self.perfect_subtree_sizes.append(current_size)
                return (True, current_depth, current_size)
            else:
                # Current subtree is not perfect
                current_depth = max(left_depth, right_depth) + 1
                current_size = left_size + right_size + 1
                return (False, current_depth, current_size)
        
        # Start traversal from the root
        traverse(root)
        
        # If no perfect subtrees found, return -1
        if not self.perfect_subtree_sizes:
            return -1
        
        # Sort the sizes in descending order
        sorted_sizes = sorted(self.perfect_subtree_sizes, reverse=True)
        
        # Debug: Print all perfect subtree sizes
        # print(f""Perfect Subtree Sizes (sorted): {sorted_sizes}"")
        
        # If k is within the number of perfect subtrees, return the k-th largest
        if k <= len(sorted_sizes):
            return sorted_sizes[k - 1]
        else:
            # Otherwise, return -1
            return -1
",1420534503
oshang,oshang,443,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        const int MOD = 1'000'000'007;
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(3, vector<int>(2 * n + 1)));

        auto getScore = [&](char bobMove, char aliceMove) {
            if ((bobMove == 'F' && aliceMove == 'E') || 
                (bobMove == 'W' && aliceMove == 'F') || 
                (bobMove == 'E' && aliceMove == 'W')) {
                return 1;
            } else if (bobMove == aliceMove) {
                return 0;
            } else {
                return -1;
            }
        };

        auto getBobMove = [&](int idx) {
            return idx == 0 ? 'F' : (idx == 1 ? 'W' : 'E');
        };

        for (int j = 0; j < 3; j++) {
            int score = getScore(getBobMove(j), s[0]);
            dp[1][j][score + n] = 1;
        }

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < 3; j++) {
                for (int scoreDiff = -n; scoreDiff <= n; scoreDiff++) {
                    if (dp[i][j][scoreDiff + n] > 0) {
                        for (int k = 0; k < 3; k++) {
                            if (j != k) {
                                int newScoreDiff = scoreDiff + getScore(getBobMove(k), s[i]);
                                dp[i + 1][k][newScoreDiff + n] = 
                                    (dp[i + 1][k][newScoreDiff + n] + dp[i][j][scoreDiff + n]) % MOD;
                            }
                        }
                    }
                }
            }
        }

        long result = 0;
        for (int j = 0; j < 3; j++) {
            for (int scoreDiff = 1; scoreDiff <= n; scoreDiff++) {
                result = (result + dp[n][j][scoreDiff + n]) % MOD;
            }
        }

        return (int) result;
    }
};",1420545964
oshang,oshang,443,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        # Step 1: Count the occurrences of elements in the subarray
        def count_occurrences(subarray: List[int]) -> Counter:
            freq_counter = Counter(subarray)
            return freq_counter
        
        # Step 2: Find the top 'x' most frequent elements in the subarray
        def find_top_x_elements(freq_counter: Counter) -> List[Tuple[int, int]]:
            sorted_elements = sorted(freq_counter.items(), key=lambda elem: (-elem[1], -elem[0]))
            top_x_elements = sorted_elements[:x]
            return top_x_elements
        
        # Step 3: Calculate the x-sum from the top 'x' elements
        def calculate_x_sum(top_x_elements: List[Tuple[int, int]]) -> int:
            total_sum = 0
            for element, count in top_x_elements:
                total_sum += element * count
            return total_sum
        
        # Initialize the result list
        result = []
        
        # Step 4: Iterate through the subarrays of length 'k' and calculate the x-sum
        for i in range(len(nums) - k + 1):
            current_subarray = nums[i:i + k]  # Extract the current subarray of size 'k'
            
            # Count the occurrences of elements in the current subarray
            freq_counter = count_occurrences(current_subarray)
            
            # Find the top 'x' most frequent elements in the current subarray
            top_x_elements = find_top_x_elements(freq_counter)
            
            # Calculate the x-sum of the current subarray based on the top 'x' elements
            subarray_x_sum = calculate_x_sum(top_x_elements)
            
            # Append the calculated x-sum to the result list
            result.append(subarray_x_sum)
        
        # Return the final result list containing the x-sum for each subarray
        return result",1420537308
TODD YANG,ShangqiYang,444,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        
        def helper(node):
            if node is None:
                return True, 0, 0
            if not node.left and not node.right:
                sizes.append(1)
                return True, 1, 1
            left_perfect, left_height, left_size = helper(node.left)
            right_perfect, right_height, right_size = helper(node.right)

            if left_perfect and right_perfect and left_height == right_height:
                current_height = left_height + 1
                current_size = left_size + right_size + 1
                sizes.append(current_size)
                return True, current_height, current_size
            else:
                return False, 0, 0

        helper(root)
        sizes.sort(reverse=True)
        return sizes[k - 1] if k <= len(sizes) else -1
            ",1420537756
TODD YANG,ShangqiYang,444,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        creatures = ['F', 'W', 'E']
        score_diff = {
            'F': {'E': 1, 'W': -1},
            'W': {'F': 1, 'E': -1},
            'E': {'W': 1, 'F': -1}
        }
        dp = [[[0 for _ in range(2 * n + 1)] for _ in range(3)] for _ in range(n + 1)]
        creature_to_index = {'F': 0, 'W': 1, 'E': 2}
        index_to_creature = {0: 'F', 1: 'W', 2: 'E'}
        for c in range(3):
            bob_creature = index_to_creature[c]
            alice_creature = s[0]
            if alice_creature in score_diff[bob_creature]:
                diff = score_diff[bob_creature][alice_creature]
            elif bob_creature == alice_creature:
                diff = 0
            else:
                diff = 0
            offset = diff + n
            dp[1][c][offset] = 1

        for i in range(2, n + 1):
            for last in range(3):
                for diff in range(2 * n + 1):
                    if dp[i - 1][last][diff] == 0:
                        continue
                    for c in range(3):
                        if c == last:
                            continue
                        bob_creature = index_to_creature[c]
                        alice_creature = s[i - 1]
                        if alice_creature in score_diff[bob_creature]:
                            delta = score_diff[bob_creature][alice_creature]
                        elif bob_creature == alice_creature:
                            delta = 0
                        else:
                            delta = 0
                        new_diff = diff + delta
                        if 0 <= new_diff <= 2 * n:
                            dp[i][c][new_diff] = (dp[i][c][new_diff] + dp[i - 1][last][diff]) % MOD

        result = 0
        for last in range(3):
            for diff in range(n + 1, 2 * n + 1):
                result = (result + dp[n][last][diff]) % MOD

        return result",1420539832
TODD YANG,ShangqiYang,444,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        count = Counter()
        for i in range(k-1):
            count[nums[i]] += 1
        ans = []
        for i in range(k-1, len(nums)):
            count[nums[i]] += 1
            if i >= k:
                count[nums[i-k]] -= 1
                if count[nums[i-k]] == 0:
                    count.pop(nums[i-k])
            arr = sorted([a for a in count.keys()], key=lambda x: (count[x], x), reverse=True)
            x_sum = 0
            for j in range(0, min(x, len(arr))):
                x_sum += arr[j] * count[arr[j]]
            ans.append(x_sum)
        return ans",1420528243
aman_bedi,AmanBedi,445,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>sizes;
    pair<int,int>solve(TreeNode * root, int k){
        // if(root==NULL){
        //     return {-1,;  
        // }  
        if(root->left==NULL && root->right==NULL){
            sizes.push_back(1); 
            return {0,1};
        }  
        pair<int,int>p,p1;
        if(root->left){
            p = solve(root->left,k);
        } 
        if(root->right){
            p1 = solve(root->right,k);
        } 
        
        if(root->left==NULL || root->right==NULL){
            return {-1,-1}; 
        } 
        
        if(p.first==-1 || p1.first==-1){
            return {-1,-1};
        }  
        
        if(p.first==p1.first){ 
            sizes.push_back(p.second+p1.second+1);
            return {p.first+1,p.second+p1.second+1}; 
        } else{
            return {-1,-1};
        }
        return {-1,-1};
        
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        solve(root,k); 
        sort(sizes.begin(),sizes.end()); 
        reverse(sizes.begin(),sizes.end()); 
        if(k>sizes.size()){
            return -1;
        }
        return sizes[k-1];
    }
};",1420533210
aman_bedi,AmanBedi,445,3588,cpp,"class Solution {
public: 
    map<int,char>mp;
    const int mod = 1e9+7;
    
    long long dp[1001][2002][4];
   
    long long solve(int idx,int score, int prev,string &s){
        if(idx>=s.size()){
            if(score>0){
                return 1;
            } 
            return 0; 
        }  
        
        if(dp[idx][score+s.size()][prev]!=-1){
            return dp[idx][score+s.size()][prev];
        }
        
        long long ans = 0; 
        
        for(int i=1;i<4;++i){
            if(i==prev)continue; 
            char ch = mp[i]; 
            int inc = 0;
            
            if(ch=='F' && s[idx]=='W'){
                 inc-=1;
            } else if(ch=='F' && s[idx]=='E'){
                inc+=1;
            } else if(ch=='W' && s[idx]=='F'){
                inc+=1;
            } else if(ch=='W' && s[idx]=='E'){
                 inc-=1;
            } else if(ch=='E' && s[idx]=='F'){
                inc-=1;
            } else if(ch=='E' && s[idx]=='W'){
                inc+=1;
            }
            ans+=solve(idx+1,score+inc,i,s)%mod;
            ans%=mod;
        } 
        return dp[idx][score+s.size()][prev] = ans;
        
    }
    int countWinningSequences(string s) {
        int n = s.size();
        for(int i=0;i<=n;++i){
            for(int j=0;j<=2*n;++j){
                for(int k=0;k<4;++k){
                    dp[i][j][k]=-1;

                }
            } 
            
        }
         mp[1]='F'; 
         mp[2]='W'; 
         mp[3]='E';
        return solve(0,0,0,s); 
    }
};",1420552379
aman_bedi,AmanBedi,445,3610,cpp,"class Solution {
public:
    static bool comp(pair<int,int>&a,pair<int,int>&b){
        if(a.second == b.second){
            return a.first>b.first;
        } 
        return a.second>b.second;
    }
    int calc(map<int,int>&mp,int x){
        vector<pair<int,int>>v; 
        for(auto it:mp){
            v.push_back(it);
        } 
        int ans = 0;
        sort(v.begin(),v.end(),comp); 
        // reverse(v.begin(),v.end()); 
        for(int i=0;i<min(x,(int)v.size());++i){
            auto it = v[i];
            // cout<<it.first<<' '<<it.second<<'\n';
            ans+=it.first*it.second; 
        } 
        // cout<<'\n';
        return ans;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        map<int,int>mp; 
        vector<int>ans;
        for(int i=0;i<k;++i){
            mp[nums[i]]++;
        } 
        ans.push_back(calc(mp,x));
        for(int i=k;i<nums.size();++i){
            mp[nums[i-k]]--; 
            if(mp[nums[i-k]]==0){
                mp.erase(nums[i-k]); 
            } 
            mp[nums[i]]++;
            ans.push_back(calc(mp,x));
        } 
        return ans;
    }
};",1420524148
Aryan Srivastava,srivastavaaryanalc76,446,3509,cpp,"class Solution {
public:
    struct Result {
        int height;
        int size;
        bool isPerfect;
    };
    
    // Helper function to perform post-order traversal and find perfect subtrees
    Result findPerfectSubtrees(TreeNode* root, vector<int>& sizes) {
        if (!root) return {0, 0, true};
        
        // Recursively find the perfect subtrees in left and right children
        Result left = findPerfectSubtrees(root->left, sizes);
        Result right = findPerfectSubtrees(root->right, sizes);
        
        // Check if current subtree is perfect
        if (left.isPerfect && right.isPerfect && left.height == right.height) {
            int currentSize = left.size + right.size + 1;
            int currentHeight = left.height + 1;
            sizes.push_back(currentSize); // Store the size of the perfect subtree
            return {currentHeight, currentSize, true};
        }
        
        // If not perfect, return a non-perfect result
        return {max(left.height, right.height) + 1, left.size + right.size + 1, false};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        findPerfectSubtrees(root, sizes);
        
        // Sort sizes in descending order
        sort(sizes.rbegin(), sizes.rend());
        
        // Check if there are at least k perfect subtrees
        if (k > sizes.size()) {
            return -1;
        }
        
        // Return the k-th largest perfect subtree size
        return sizes[k - 1];
    }
};
",1420527854
Aryan Srivastava,srivastavaaryanalc76,446,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    int rec(int level, char lastSummoned, int points, string& s, vector<vector<vector<int>>>& memo) {
        if (level == s.length()) {
            return points > 0 ? 1 : 0;
        }

        int lastIndex = (lastSummoned == 'F') ? 0 : (lastSummoned == 'W') ? 1 : (lastSummoned == 'E') ? 2 : 3;
        if (memo[level][lastIndex][points + 1000] != -1) {
            return memo[level][lastIndex][points + 1000];
        }

        int ans = 0;
        for (auto& c : {'F', 'W', 'E'}) {
            if (c == lastSummoned) {
                continue;
            }
            if (s[level] == 'F') {
                if (c == 'W') {
                    ans = (ans + rec(level + 1, c, points + 1, s, memo)) % MOD;
                } else if (c == 'E') {
                    ans = (ans + rec(level + 1, c, points - 1, s, memo)) % MOD;
                } else {
                    ans = (ans + rec(level + 1, c, points, s, memo)) % MOD;
                }
            } else if (s[level] == 'W') {
                if (c == 'F') {
                    ans = (ans + rec(level + 1, c, points - 1, s, memo)) % MOD;
                } else if (c == 'E') {
                    ans = (ans + rec(level + 1, c, points + 1, s, memo)) % MOD;
                } else {
                    ans = (ans + rec(level + 1, c, points, s, memo)) % MOD;
                }
            } else if (s[level] == 'E') {
                if (c == 'F') {
                    ans = (ans + rec(level + 1, c, points + 1, s, memo)) % MOD;
                } else if (c == 'W') {
                    ans = (ans + rec(level + 1, c, points - 1, s, memo)) % MOD;
                } else {
                    ans = (ans + rec(level + 1, c, points, s, memo)) % MOD;
                }
            }
        }

        return memo[level][lastIndex][points + 1000] = ans;
    }

    int countWinningSequences(string s) {
        int n = s.length();
        vector<vector<vector<int>>> memo(n, vector<vector<int>>(4, vector<int>(2001, -1)));
        return rec(0, 'X', 0, s, memo);
    }
};
",1420552462
Aryan Srivastava,srivastavaaryanalc76,446,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        for (int i = 0; i <= max(n - k, 0); i++) {
            map<int, int> mp;
            int sum = 0;
            for (int j = i; j < i + k; j++) {
                mp[nums[j]]++;
                sum += nums[j];
            }
            priority_queue<pair<int, int>> pq;
            for (auto& it : mp) {
                pq.push({it.second, it.first});
            }
            if (mp.size() < x) {
                ans.push_back(sum);
            } else {
                sum = 0;
                int tempX = x;
                while (tempX--) {
                    auto [freq, number] = pq.top();
                    pq.pop();
                    sum += (number * freq);
                }
                ans.push_back(sum);
            }
        }
        return ans;
    }
};",1420525128
Rastsislau Matusevich,rastsislau,447,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    int dfs(TreeNode* root, vector<int>& ans)
    {
        if (root==nullptr)
        {
            return 0;
        }
        auto dfs_left = dfs(root->left,ans);
        auto dfs_right = dfs(root->right, ans);
        if (dfs_left == -1 || dfs_left != dfs_right)
        {
            return -1;
        }
        ans.push_back(dfs_left + 1);
        return dfs_left + 1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector <int> ans;
        dfs(root, ans);
        k--;
        if (k >= ans.size())
        {
            return -1;
        }
        sort(ans.begin(), ans.end());
        reverse(ans.begin(), ans.end());
        return pow(2, ans[k]) - 1 ;
    }
};",1420523307
Rastsislau Matusevich,rastsislau,447,3588,cpp,"class Solution {
public:

    int to_int(char x)
    {
        if (x == 'F')
        {
            return 0;
        }
        if (x == 'W')
        {
            return 1;
        }
        if (x == 'E')
        {
            return 2;
        }
        return -1;
    }

    int countWinningSequences(string s) {
        // dp[i][score][last]
        int n=s.size();
        int zero = n + 3;
        vector < vector < vector <long long> > > dp(n, vector<vector<long long>>(2*n + 10, vector<long long>(3,0)));
        long long mod = 1e9 + 7;
        // F = 0
        // W = 1
        // E = 2
        
        dp[0][zero][to_int(s[0])] = 1;
        dp[0][zero + 1][(to_int(s[0]) + 1) % 3] = 1;
        dp[0][zero - 1][(to_int(s[0]) + 2) % 3] = 1;
        for (int j=1;j<n;j++)
        {
            auto c = s[j];
            auto upper = zero + j + 5;
            for (int score = 2; score < upper; score++)
            {
                int alice = to_int(c);
                // draw
                dp[j][score][alice] += dp[j-1][score][(alice+1)%3];
                dp[j][score][alice] += dp[j-1][score][(alice+2)%3];
                dp[j][score][alice] %= mod;
                // win
                dp[j][score][(alice+1)%3] += dp[j-1][score-1][(alice)%3];
                dp[j][score][(alice+1)%3] += dp[j-1][score-1][(alice+2)%3];
                dp[j][score][(alice+1)%3] %= mod;
                // lose
                dp[j][score][(alice+2)%3] += dp[j-1][score+1][(alice)%3];
                dp[j][score][(alice+2)%3] += dp[j-1][score+1][(alice+1)%3];
                dp[j][score][(alice+2)%3] %= mod;
            }
        }

        long long ans = 0;
        
        for (int score = zero + 1; score<dp[0].size(); score++)
        {
            for (int last = 0; last < 3; last++)
            {
                ans += dp[n-1][score][last];
                ans %= mod;
            }
        }
        return ans;



    }
};",1420539885
Rastsislau Matusevich,rastsislau,447,3610,cpp,"class Solution {
public:

    int findSum(vector<int>& nums, int k, int x, int ii)
    {
        unordered_map <int, int> counts;
        for (int j=ii;j<ii+k;j++)
        {
            counts[nums[j]]++;
        }
        vector <pair <int, int> > arr;
        for (auto x : counts)
        {
            arr.push_back(make_pair(x.second, x.first));
        }
        sort(arr.begin(), arr.end());
        reverse(arr.begin(), arr.end());
        int sum = 0;
        if (arr.size() <= x)
        {
            x = arr.size();
        }
        for (int i=0;i<x;i++)
        {
            //cout << arr[i].first << "" "" << arr[i].second << endl;
            sum += arr[i].first * arr[i].second;
        }
        //cout << ""done"" << endl;
        return sum;
    }




    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector <int> ans;
        int i=0;
        int n=nums.size();
        while (i+k<=n)
        {
            ans.push_back(findSum(nums, k, x, i));
            i++;
        }
        return ans;
    }
};",1420553208
hiteshgup09,hiteshgup09,448,3509,java,"import java.util.*;

class Solution {
    // Helper class to store subtree information (size and height)
    class SubtreeInfo {
        int size;
        int height;
        boolean isPerfect;

        SubtreeInfo(int size, int height, boolean isPerfect) {
            this.size = size;
            this.height = height;
            this.isPerfect = isPerfect;
        }
    }

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        // List to store sizes of all perfect binary subtrees
        List<Integer> perfectSubtreeSizes = new ArrayList<>();

        // Helper function to calculate subtree sizes
        calculatePerfectSubtrees(root, perfectSubtreeSizes);

        // Sort sizes in descending order
        Collections.sort(perfectSubtreeSizes, Collections.reverseOrder());

        // If there are fewer than k perfect subtrees, return -1
        if (perfectSubtreeSizes.size() < k) {
            return -1;
        }

        // Return the k-th largest perfect subtree size
        return perfectSubtreeSizes.get(k - 1);
    }

    // Helper function to calculate subtree info for each node
    private SubtreeInfo calculatePerfectSubtrees(TreeNode node, List<Integer> perfectSubtreeSizes) {
        // Base case: null node
        if (node == null) {
            return new SubtreeInfo(0, 0, true); // null node is considered perfect with size 0
        }

        // Recursively calculate info for left and right subtrees
        SubtreeInfo leftInfo = calculatePerfectSubtrees(node.left, perfectSubtreeSizes);
        SubtreeInfo rightInfo = calculatePerfectSubtrees(node.right, perfectSubtreeSizes);

        // Check if the current node forms a perfect binary subtree
        boolean isPerfect = leftInfo.isPerfect && rightInfo.isPerfect && (leftInfo.height == rightInfo.height);

        if (isPerfect) {
            // If it's a perfect binary subtree, calculate its size and height
            int size = leftInfo.size + rightInfo.size + 1;
            int height = leftInfo.height + 1;
            perfectSubtreeSizes.add(size); // Add the size of this perfect subtree to the list
            return new SubtreeInfo(size, height, true);
        } else {
            // If it's not perfect, return the larger height and the total size (not perfect)
            return new SubtreeInfo(leftInfo.size + rightInfo.size + 1, Math.max(leftInfo.height, rightInfo.height), false);
        }
    }
}
",1420523604
hiteshgup09,hiteshgup09,448,3588,java,"import java.util.HashMap;
import java.util.Map;

class Solution {
    private static final int MOD = 1_000_000_007;
    private Map<String, Integer> memo = new HashMap<>();
    Map<Character, Integer> map = new HashMap<>();


    private int getWinner(char aliceMove, char bobMove) {
        if (aliceMove == 'F' && bobMove == 'W') return 1;
        if (aliceMove == 'W' && bobMove == 'E') return 1;
        if (aliceMove == 'E' && bobMove == 'F') return 1;
        if (aliceMove == bobMove) return 0;
        return -1;
    }

    public int countWinningSequences(String s) {
        Integer dp[][][] = new Integer[s.length()][4][2004];
        map.put('F', 0);
        map.put('W', 1);
        map.put('E', 2);
        map.put('.', 3);

        return dfs(s, 0, '.', 0, dp);
    }

    private int dfs(String s, int i, char lastBobMove, int bobScore, Integer[][][] dp) {
        if (i == s.length()) {
            return bobScore > 0 ? 1 : 0;
        }

        if (dp[i][map.get(lastBobMove)][1000+bobScore] != null) {
            return dp[i][map.get(lastBobMove)][1000+bobScore];
        }

        int totalWinningSequences = 0;
        char aliceMove = s.charAt(i);

        for (char bobMove : new char[]{'F', 'W', 'E'}) {
            if (bobMove == lastBobMove) continue;

            int winner = getWinner(aliceMove, bobMove);
            int newBobScore = bobScore + winner;

            totalWinningSequences = (totalWinningSequences + dfs(s, i + 1, bobMove, newBobScore, dp)) % MOD;
        }

        return dp[i][map.get(lastBobMove)][1000+bobScore] = totalWinningSequences;
    }
}

",1420540737
hiteshgup09,hiteshgup09,448,3610,java,"import java.util.*;


import java.util.*;

class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] answer = new int[n - k + 1];

        // Sliding window approach
        Map<Integer, Integer> freqMap = new HashMap<>(); // stores the frequency of elements in current window

        for (int i = 0; i < n; i++) {
            // Add the new element to the frequency map
            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);

            // When the window reaches size k
            if (i >= k - 1) {
                // Create a list of elements and sort by frequency and value
                List<int[]> freqList = new ArrayList<>();
                for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
                    freqList.add(new int[]{entry.getKey(), entry.getValue()});
                }

                // Sort by frequency first, then by value (descending)
                freqList.sort((a, b) -> (b[1] == a[1] ? b[0] - a[0] : b[1] - a[1]));

                // Calculate the sum of the top x elements
                int sum = 0;
                int count = 0;
                for (int[] elem : freqList) {
                    sum += elem[0] * elem[1];
                    count++;
                    if (count == x) break;
                }

                // Store the result
                answer[i - k + 1] = sum;

                // Remove the element that is sliding out of the window
                int outgoing = nums[i - k + 1];
                freqMap.put(outgoing, freqMap.get(outgoing) - 1);
                if (freqMap.get(outgoing) == 0) {
                    freqMap.remove(outgoing);
                }
            }
        }

        return answer;
    }
}
",1420521097
Daksh,daksh_02,450,3509,java,"
class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        fun(root); 
        Collections.sort(list,(a,b)->b-a); 
        return list.size()<k?-1:list.get(k-1);
    }
    int[] fun(TreeNode root){
        if(root == null)return new int[]{0,-1}; 
        
        if(root.left == null && root.right == null){
            list.add(1);
            return new int[]{1,1}; 
        }
        
        var l = fun(root.left);
        var r = fun(root.right); 
        
        if(l[1] == 1 && r[1] == 1 && r[0] == l[0]){
            list.add(r[0]+l[0]+1);
            return new int[]{r[0]+l[0]+1,1}; 
        }
        
        return new int[]{0,-1};
    }
}",1420523398
Daksh,daksh_02,450,3588,java,"class Solution {
    long mod = (long)1e9+7; 
    Long dp[][][]; 
    HashMap<Character,Integer> map = new HashMap<>(); 
    char s[];
    int n ;
    public int countWinningSequences(String s) {
        this.s = s.toCharArray();
        n = s.length();
        map.put('F',1);
        map.put('E',2);
        map.put('W',3);
        
        dp = new Long[s.length()][2*s.length()+1][4]; 
        
        return (int)fun(0,0,'Q');
    }
    long fun(int i,int score,char prev){
        if(i == s.length)return score>0?1:0; 
        
        if(dp[i][score+n][!map.containsKey(prev)?0:map.get(prev)] != null)return dp[i][score+n][!map.containsKey(prev)?0:map.get(prev)];
        
        long res = 0;
        
        for(char ch : map.keySet()){
            if(ch == prev)continue;  
            
            res = (res + fun(i+1,score+win(ch,s[i]),ch))%mod; 
        }
        
        return dp[i][score+n][!map.containsKey(prev)?0:map.get(prev)] = res;
    }
    
    int win(char a,char b){
        if(a == 'F' && b == 'E')return 1;
        if(a == 'E' && b == 'W')return 1;
        if(a == 'W' && b == 'F')return 1;
        
        if(a == b)return 0;
        
        return -1;
    }
}",1420547330
Daksh,daksh_02,450,3610,java,"class Solution {
   public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] result = new int[n - k + 1]; // The resulting array
        
        // Initialize frequency map for the first window
        Map<Integer, Integer> freqMap = new HashMap<>();
        
        // Fill initial frequency map for the first window of size k
        for (int i = 0; i < k; i++) {
            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);
        }
        
        // Calculate x-sum for the first window
        result[0] = calculateXSum(freqMap, x);
        
        // Now process the remaining windows using the sliding window technique
        for (int i = 1; i <= n - k; i++) {
            // Remove the element that is sliding out of the window
            int elementToRemove = nums[i - 1];
            freqMap.put(elementToRemove, freqMap.get(elementToRemove) - 1);
            if (freqMap.get(elementToRemove) == 0) {
                freqMap.remove(elementToRemove);
            }
            
            // Add the new element that is sliding into the window
            int elementToAdd = nums[i + k - 1];
            freqMap.put(elementToAdd, freqMap.getOrDefault(elementToAdd, 0) + 1);
            
            // Calculate x-sum for the current window
            result[i] = calculateXSum(freqMap, x);
        }
        
        return result;
    }
    
    private int calculateXSum(Map<Integer, Integer> freqMap, int x) {
        // Convert the map to a list of entries and sort by frequency, and value (descending for ties)
        List<Map.Entry<Integer, Integer>> sortedEntries = new ArrayList<>(freqMap.entrySet());
        sortedEntries.sort((a, b) -> {
            if (!a.getValue().equals(b.getValue())) {
                return b.getValue() - a.getValue(); // Sort by frequency descending
            } else {
                return b.getKey() - a.getKey(); // Sort by value descending
            }
        });
        
        // Sum the top `x` most frequent elements (or all if fewer than x distinct elements)
        int sum = 0;
        for (int i = 0; i < Math.min(x, sortedEntries.size()); i++) {
            sum += sortedEntries.get(i).getKey() * sortedEntries.get(i).getValue();
        }
        
        return sum;
    }
}",1420526408
Chengyu Wu,dnuj4097,452,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from heapq import heapify, heappush, heappushpop
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        queue = []
        heapify(queue)
        n = 0
        
        def helper(node):
            nonlocal queue, n, k
            if not node: return 0
            vl = helper(node.left)
            vr = helper(node.right)
            if vl == vr and vl >= 0:
                v = vl + vr + 1
            else:
                v = -1
            if v > 0:
                if n == k:
                    heappushpop(queue, v)
                else:
                    heappush(queue, v)
                    n += 1
            #print(node.val, v, queue)
            return v
        
        helper(root)
        return queue[0] if n >= k else -1",1420534349
Chengyu Wu,dnuj4097,452,3588,python3,"from collections import defaultdict
class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        dp = dict({(' ', 0): 1})
        idx = dict({'F': 0, 'E': 1, 'W': 2})
        mod = 10**9 + 7
        for x in s:
            dp1 = defaultdict(int)
            for k,v in dp.items():
                for c in ['F', 'W', 'E']:
                    if k[0] == c: continue
                    if c == x:
                        dp1[(c, k[1])] += v
                    elif (idx[x] + 1) % 3 == idx[c]:
                        dp1[(c, k[1] - 1)] += v
                    else:
                        dp1[(c, k[1] + 1)] += v
            dp = dict()
            for k,v in dp1.items():
                dp[k] = v % mod
        
        ans = 0
        for k,v in dp.items():
            if k[1] > 0: ans = (ans + v) % mod
        return ans",1420554004
Chengyu Wu,dnuj4097,452,3610,python3,"from collections import Counter
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        n = len(nums)
        ans = []
        for i in range(n - k + 1):
            ctr = Counter(nums[i:(i + k)])
            arr = sorted(ctr.items(), key=lambda x:[-x[1], -x[0]])
            xsum = 0
            for v,c in arr[:x]: xsum += v*c
            ans.append(xsum)
        return ans",1420522233
Xianghong Luo,lxhgww,453,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    pair<bool,int> dfs(TreeNode* x) {
        int f=1;
        int yy,zz;
        bool f1;
        if (x->left!=nullptr) {
            auto y=dfs(x->left);
            f+=y.second;
            f1=y.first;
            yy=y.second;
        } else f1=false;
        bool f2;
        if (x->right!=nullptr) {
            auto y=dfs(x->right);
            f+=y.second;
            f2=y.first;
            zz=y.second;
        } else f2=false;
        
        if (f==1) {
            res.push_back(1);
            return make_pair(true,1);
        }
        if (f1&&f2&&yy==zz) {
            res.push_back(f);
            return make_pair(true,f);
        }
        return make_pair(false,f);
        
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(res.begin(),res.end());
        if (res.size()<k) return -1;
        return res[res.size()-k];
    }
};",1420526502
Xianghong Luo,lxhgww,453,3588,cpp,"class Solution {
public:
    int f[1010][2010][3];
    int mod=1e9+7;
    int countWinningSequences(string s) {
        f[0][1000][0]=1;
        f[0][1000][1]=1;
        f[0][1000][2]=1;
        int n=s.size();
        for (int i=0;i<n;i++) {
            for (int r=0;r<=2000;r++) {
            for (int j=0;j<3;j++) {
                int ss=0;
                for (int k=0;k<3;k++) {
                    if (j==k) continue;
                    ss=(ss+f[i][r][k])%mod;
                }
                if (ss==0) continue;
                int mm=r;
                if (s[i]=='E') {
                    if (j==1) mm++;
                    if (j==2) mm--;
                }
                if (s[i]=='F') {
                    if (j==0) mm--;
                    if (j==2) mm++;
                }
                if (s[i]=='W') {
                    if (j==0) mm++;
                    if (j==1) mm--;
                }
                f[i+1][mm][j]=ss;
            }
            }
        }
        int res=0;
        for (int j=1001;j<=2000;j++)
            for (int k=0;k<3;k++)
                res=(res+f[n][j][k])%mod;
        if (res%2==0) return res/2;
        else return (res+mod)/2;
    }
};",1420539625
Xianghong Luo,lxhgww,453,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        vector<int> ret;
        int n=a.size();
        for (int i=0;i+k-1<n;i++) {
            unordered_map<int,int> f;
            for (int j=0;j<k;j++)
                f[a[i+j]]++;
            vector<pair<int,int>> g;
            for (auto x:f) {
                g.push_back(make_pair(x.second,x.first));
            }
            sort(g.begin(),g.end());
            int res=0;
            for (int j=1;j<=g.size()&&j<=x;j++)
                res+=g[g.size()-j].first*g[g.size()-j].second;
            ret.push_back(res);
            
        }
        return ret;
    }
};",1420547668
PracticalCode,mcuallen,454,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
        
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def check(root):
            if not root:
                return True, 0
            left_check, left_height = check(root.left)
            right_check, right_height = check(root.right)
            if left_check and right_check and left_height == right_height:
                return True, left_height + 1
            return False, max(left_height, right_height)

        def calc(root, sizes):
            if root is None:
                return 0
            if check(root)[0]:
                size = 2 ** check(root)[1] - 1  
                sizes.append(size)
            calc(root.left, sizes)
            calc(root.right, sizes)
        sizes = []
        calc(root, sizes)
        if len(sizes) < k:
            return -1
        return sorted(sizes, reverse=True)[k-1]

        ",1420532038
PracticalCode,mcuallen,454,3588,python3,"def check(b_move, a_move):
    win_conditions= {(0, 2), (1, 0), (2, 1)}
    if b_move == a_move:
        return 0
    elif (b_move, a_move) in win_conditions:
        return 1
    elif (a_move, b_move) in win_conditions:
        return -1
    else:
        return 0
class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10**9 + 7
        n = len(s)
        move_map = {'F': 0, 'W': 1, 'E': 2}


        dp = [[[0]*4 for _ in range(2*n+1)] for _ in range(n+1)]
        offset = n
        dp[0][offset][3] = 1 

        for i in range(n):
            a_move = move_map[s[i]]
            for d in range(2*n+1):
                for prev in [0,1,2,3]:
                    if dp[i][d][prev] == 0:
                        continue
                    for b_move in [0,1,2]:
                        if b_move == prev:
                            continue
                        out = check(b_move, a_move)
                        new_d = d + out
                        if 0 <= new_d <= 2*n:
                            dp[i+1][new_d][b_move] = (dp[i+1][new_d][b_move] + dp[i][d][prev]) % mod

        result = 0
        for d in range(offset+1, 2*n+1):
            for prev in [0,1,2]:
                result = (result + dp[n][d][prev]) % mod

        return result

",1420554410
PracticalCode,mcuallen,454,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        for start in range(n - k + 1):
            subarr = nums[start:start + k]
            aux= Counter(subarr)
            top_elems = sorted(aux.items(), key=lambda item: (-item[1], -item[0]))
            top_x_elements = top_elems[:x]
            x_sum = sum(key * freq for key, freq in top_x_elements)
            res.append(x_sum)

        return res

        ",1420525124
kxl97,kxl97,455,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        sizes = []

        def isPerfect(node):
            if not node:
                return (True, 0)
            
            left = isPerfect(node.left)
            right = isPerfect(node.right)

            if (left[0] and right[0] and left[1] == right[1]):
                sizes.append(left[1] + right[1] + 1)
                return (True, left[1] + right[1] + 1)
            else:
                return (False, left[1] + right[1] + 1)

        isPerfect(root)

        if (k > len(sizes)):
            return -1
        
        sizes.sort(reverse = True)
        return sizes[k - 1]",1420528330
kxl97,kxl97,455,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = 10 ** 9 + 7

        creatures = ['F', 'W', 'E']
        
        beats = {'F' : 'E', 'W' : 'F', 'E' : 'W'}

        @cache
        def solve(i, prev, cur):
            if (i == n):
                if cur > 0:
                    return 1
                else:
                    return 0

            res = 0
            diff = 0
            for bob in creatures:
                if bob == prev:
                    continue
                
                if beats[bob] == s[i]:
                    diff = 1
                elif beats[s[i]] == bob:
                    diff = -1
                else:
                    diff = 0

                res = (res + solve(i + 1, bob, cur + diff)) % mod

            return res

        return solve(0, '', 0)",1420548058
kxl97,kxl97,455,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)

        res = [0] * (n - k + 1)

        def getXSum(index):
            count = defaultdict(int)
            for i in range(index, index + k):
                count[nums[i]] += 1

            if (len(count) < x):
                return sum(nums[index:index + k])

            s = 0
            counts = [(count, num) for (num, count) in count.items()]
            counts.sort(reverse = True)

            for i in range(x):
                s += counts[i][0] * counts[i][1] 

            return s

            

        for i in range(n - k + 1):
            res[i] = getXSum(i)

        return res",1420524012
naresh50,naresh50,456,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public Data helper(TreeNode root , ArrayList<Integer> list){
        if(root==null){
            return new Data(true,0);
        }
        Data l = helper(root.left,list);
        Data r = helper(root.right,list);

        if(l.isTree && r.isTree && l.nodesCount==r.nodesCount){
            int currNodes = l.nodesCount + r.nodesCount + 1;
            list.add(currNodes);
            return new Data(true , currNodes);
        }
        return new Data(false,0);
    }
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        ArrayList<Integer> list= new ArrayList<>();
        helper(root,list);
Collections.sort(list, Collections.reverseOrder());
        if(k>list.size()) return -1;
        else return list.get(k-1);        
    }
}
class Data{
    boolean isTree;
    int nodesCount;
    public Data(boolean val , int x){
        this.isTree=val;
        this.nodesCount=x;
    }
}",1420524911
naresh50,naresh50,456,3588,java,"class Solution {
    int mod = (int)1e9+7;
    HashMap<Character,Integer> map = new HashMap<>(); 
    

    public int countWinningSequences(String s) {
        int n=s.length();
        int[][][] dp = new int[n+10][2010][5];
        map.put('W',0);
        map.put('F',1);
        map.put('E',2);

        for(int i=0;i<dp.length;i++){
            for(int j=0;j<dp[i].length;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }

        return helper(s,0,-1,1,dp);
        
        
    }
    public int helper(String s , int index , int prev , int reqScore , int[][][] dp){
        if(index==s.length()){
            if(reqScore<=0) return 1;
            else return 0;
        }

        if(dp[index][reqScore+1000][prev+1]!=-1) return dp[index][reqScore+1000][prev+1];

        long ans=0;
        int curr = map.get(s.charAt(index));
        
        if(prev!=0){
            int temp=0;
            int newScore = reqScore;
            if(curr==1) newScore--;
            if(curr==2) newScore++;

            ans+=helper(s,index+1,0,newScore,dp);
            ans%=mod;

        }
        if(prev!=1){
            int temp=0;
            int newScore = reqScore;
            if(curr==2) newScore--;
            if(curr==0) newScore++;

            ans+=helper(s,index+1,1,newScore,dp);
            ans%=mod;

        }
        if(prev!=2){
            int temp=0;
            int newScore = reqScore;
            if(curr==0) newScore--;
            if(curr==1) newScore++;

            ans+=helper(s,index+1,2,newScore,dp);
            ans%=mod;

        }

        return dp[index][reqScore+1000][prev+1] = (int)(ans%mod);
    }
}",1420554517
naresh50,naresh50,456,3610,java,"class Solution {
    public int[] findXSum(int[] array, int windowSize, int topX) {
        int arrayLength = array.length;
        int[] result = new int[arrayLength - windowSize + 1];
        
        for (int startIdx = 0; startIdx <= arrayLength - windowSize; startIdx++) {
            Map<Integer, Integer> frequencyMap = new HashMap<>();
            for (int j = startIdx; j < startIdx + windowSize; j++) {
                frequencyMap.put(array[j], frequencyMap.getOrDefault(array[j], 0) + 1);
            }
            List<Map.Entry<Integer, Integer>> sortedFrequencies = new ArrayList<>(frequencyMap.entrySet());
            
            sortedFrequencies.sort((entry1, entry2) -> entry2.getValue() != entry1.getValue() ? 
                entry2.getValue() - entry1.getValue() : entry2.getKey() - entry1.getKey());
            
            int xSum = 0;
            for (int j = 0; j < Math.min(topX, sortedFrequencies.size()); j++) {
                xSum += sortedFrequencies.get(j).getKey() * sortedFrequencies.get(j).getValue();
            }
            result[startIdx] = xSum;
        }
        
        return result;
    }
}",1420523945
Gaurangi19,Gaurangi19,457,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) 
    {
        vector<int> sizes;
        findPerfectSubtreeSizes(root, sizes);
        sort(sizes.rbegin(), sizes.rend());
    
        if (k > sizes.size()) 
            return -1;
        
        return sizes[k - 1];        
    }

    void findPerfectSubtreeSizes(TreeNode* root, vector<int>& sizes) 
    {
        if (!root) 
            return;
        int size = 0;

        if (isPerfectBinarySubtree(root, size) != -1)
            sizes.push_back(size);
    
        findPerfectSubtreeSizes(root -> left, sizes);
        findPerfectSubtreeSizes(root -> right, sizes);
    }

    int isPerfectBinarySubtree(TreeNode* root, int& size) 
    {
        if (!root) 
            return 0;

        int leftSize = isPerfectBinarySubtree(root -> left, size);
        int rightSize = isPerfectBinarySubtree(root -> right, size);

        if (leftSize == rightSize && leftSize != -1) 
        {
            int subtreeSize = leftSize + rightSize + 1;
            size = max(size, subtreeSize);
            return subtreeSize;
        }

        return -1;
    }
};

",1420533116
Gaurangi19,Gaurangi19,457,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int countWinningSequences(string s) 
    {
        int n = s.size();
        int offset = n;
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2 * n + 1, vector<int>(3, 0)));
        for (int i = 0; i < 3; i++) 
        {
            int points = getPoints(s[0], ""FEW""[i]);
            dp[1][offset + points][i] = 1;
        }

        for (int i = 1; i < n; i++) 
        {
            for (int j = -n; j <= n; j++) 
            {
                for (int k = 0; k < 3; k++) 
                {
                    int currDiff = n + j;

                    if (dp[i][currDiff][k] == 0) 
                        continue;

                    for (int next = 0; next < 3; next++) 
                    {
                        if (k == next) 
                            continue;

                        int points = getPoints(s[i], ""FEW""[next]);
                        int newDiff = j + points;

                        dp[i + 1][offset + newDiff][next] = (dp[i + 1][offset + newDiff][next] + dp[i][currDiff][k]) % MOD;
                    }
                }
            }
        }

        int res = 0;
        for (int i = -n; i < 0; i++) 
        {
            for (int j = 0; j < 3; j++) 
            {
                res = (res + dp[n][offset + i][j]) % MOD;
            }
        }
        return res;        
    }

    int getPoints(char alice, char bob) 
    {
        if (alice == 'F' && bob == 'E') return 1;
        if (alice == 'W' && bob == 'F') return 1;
        if (alice == 'E' && bob == 'W') return 1;
        if (bob == 'F' && alice == 'E') return -1;
        if (bob == 'W' && alice == 'F') return -1;
        if (bob == 'E' && alice == 'W') return -1;
        return 0;
    }
};",1420554547
Gaurangi19,Gaurangi19,457,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) 
    {
        int n = nums.size();
        vector<int> ans;
        
        for (int i = 0; i <= n - k; i++) 
        {
            vector<int> sub(nums.begin() + i, nums.begin() + i + k);
            int xSum = solve(sub, x);
            ans.push_back(xSum);
        }
        return ans;        
    }

    int solve(vector<int>& nums, int x) 
    {
        unordered_map<int, int> freq;
        for (int i = 0; i < nums.size(); i++)
            freq[nums[i]]++;

        priority_queue<pair<int, int>> pq;
        for (auto it = freq.begin(); it != freq.end(); it++) 
        {
            int num = it -> first;
            int freq = it -> second;
            pq.push({freq, num});
        }

        int sum = 0, count = 0;
        while (!pq.empty() && count < x) 
        {
            int freq = pq.top().first;
            int num = pq.top().second;
            pq.pop();
            sum += freq * num;
            count++;
        }

        return sum;
    }
};",1420523634
Wangwang Yang,Jigcecile,458,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
private:
    struct SubtreeInfo {
        bool isPerfect;
        int height;
        int size;
    };

    SubtreeInfo helper(TreeNode* node, vector<int>& sizes) {
        if (node == nullptr) {
            return {true, 0, 0};
        }

        SubtreeInfo left = helper(node->left, sizes);
        SubtreeInfo right = helper(node->right, sizes);

        if (left.isPerfect && right.isPerfect && left.height == right.height) {
            int currentHeight = left.height + 1;
            int currentSize = left.size + right.size + 1;
            sizes.push_back(currentSize);
            return {true, currentHeight, currentSize};
        } else {
            int currentHeight = max(left.height, right.height) + 1;
            int currentSize = left.size + right.size + 1;
            return {false, currentHeight, currentSize};
        }
    }

public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        if (!root)
            return -1;

        vector<int> sizes;
        helper(root, sizes);

        if (sizes.empty() || k > sizes.size())
            return -1;

        sort(sizes.begin(), sizes.end(),
             [](const int& a, const int& b) -> bool { return a > b; });

        return sizes[k - 1];
    }
};",1420524272
Wangwang Yang,Jigcecile,458,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.length();

        int table[3][3] = {{0, 1, -1}, {-1, 0, 1}, {1, -1, 0}};

        vector<vector<long long>> current(4, vector<long long>(2 * n + 1, 0));
        current[3][n] = 1;

        for (int i = 0; i < n; i++) {
            vector<vector<long long>> next(4, vector<long long>(2 * n + 1, 0));

            char alice_move_char = s[i];
            int alice_move;
            if (alice_move_char == 'F')
                alice_move = 0;
            else if (alice_move_char == 'W')
                alice_move = 1;
            else
                alice_move = 2;

            for (int prev_move = 0; prev_move <= 3; prev_move++) {
                for (int diff = 0; diff <= 2 * n; diff++) {
                    if (current[prev_move][diff] == 0)
                        continue;

                    for (int bob_move = 0; bob_move < 3; bob_move++) {
                        if (prev_move != 3 && bob_move == prev_move) {
                            continue;
                        }

                        int delta = table[alice_move][bob_move];

                        int new_diff = diff + delta;
                        if (new_diff < 0)
                            new_diff = 0;
                        if (new_diff > 2 * n)
                            new_diff = 2 * n;

                        next[bob_move][new_diff] = (next[bob_move][new_diff] +
                                                    current[prev_move][diff]) %
                                                   MOD;
                    }
                }
            }

            current = move(next);
        }

        long long total = 0;
        for (int prev_move = 0; prev_move < 3; prev_move++) {
            for (int diff = n + 1; diff <= 2 * n; diff++) {
                total = (total + current[prev_move][diff]) % MOD;
            }
        }
        return (int)total;
    }
};",1420554637
Wangwang Yang,Jigcecile,458,3610,cpp,"class Solution {
private:
    int compute_x_sum(const vector<int>& freq, int x) {
        vector<pair<int, int>> elements;
        for (int num = 1; num <= 50; ++num) {
            if (freq[num] > 0) {
                elements.emplace_back(make_pair(freq[num], num));
            }
        }

        sort(elements.begin(), elements.end(),
             [&](const pair<int, int>& a, const pair<int, int>& b) -> bool {
                 if (a.first != b.first)
                     return a.first > b.first;
                 return a.second > b.second;
             });

        int limit = min(x, (int)elements.size());
        int window_sum = 0;
        for (int i = 0; i < limit; ++i) {
            window_sum += freq[elements[i].second] * elements[i].second;
        }

        return window_sum;
    }

public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;

        if (n < k)
            return answer;

        vector<int> freq(51, 0);
        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }

        answer.push_back(compute_x_sum(freq, x));

        for (int i = k; i < n; ++i) {
            int elem_out = nums[i - k];
            freq[elem_out]--;
            int elem_in = nums[i];
            freq[elem_in]++;

            answer.push_back(compute_x_sum(freq, x));
        }

        return answer;
    }
};",1420520349
Kar Deepak Kumar,kardeepakkumar,459,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:

        def isPerfectTree(node):
            if not node:
                return -1
            if not node.left and not node.right:
                result.append(1)
                return 1
            if not node.left or not node.right:
                isPerfectTree(node.left)
                isPerfectTree(node.right)
                return -1
            leftSize = isPerfectTree(node.left)
            rightSize = isPerfectTree(node.right)
            if leftSize < 0 or rightSize < 0 or leftSize != rightSize:
                return -1
            result.append(leftSize + rightSize + 1)
            return leftSize + rightSize + 1

        result = []
        isPerfectTree(root)
        result = sorted(result, reverse=True)
        if len(result) < k:
            return -1
        else:
            return result[k-1]",1420531013
Kar Deepak Kumar,kardeepakkumar,459,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:

        MOD = 10**9 + 7

        winners = {}
        winners['E'] = 'F'
        winners['F'] = 'W'
        winners['W'] = 'E'
        winners['X'] = 'X'
        
        @cache
        def countBobWins(lastDrawn, startIdx, bobEdge):
            if startIdx == len(s) and bobEdge > 0:
                return 1
            elif startIdx == len(s):
                return 0
            result = 0
            for char in 'EFW':
                if char == lastDrawn:
                    continue
                if char == winners[s[startIdx]]:
                    result += countBobWins(char, startIdx + 1, bobEdge + 1)
                if winners[char] == s[startIdx]:
                    result += countBobWins(char, startIdx + 1, bobEdge - 1)
                if char == s[startIdx]:
                    result += countBobWins(char, startIdx + 1, bobEdge)
            result = result % MOD
            return result
            
        return countBobWins('X', 0, 0)",1420548278
Kar Deepak Kumar,kardeepakkumar,459,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        n = len(nums)
        for i in range(n - k + 1):
            counts = defaultdict(int)
            for j in range(i, i + k):
                counts[nums[j]] += 1
            freq = defaultdict(list)
            for key in counts.keys():
                freq[counts[key]].append(key)
            keys = []
            for freqVal in sorted(list(freq.keys()), reverse=True):
                for key in sorted(list(freq[freqVal]), reverse = True):
                    if len(keys) == x:
                        break
                    keys.append(key)
            curSum = 0
            for key in keys:
                curSum += key*counts[key]
            result.append(curSum)
        return result",1420522879
Dipkul Khandelwal,deepkul2552003,460,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
         //each node see if it is complete binary tree - > child 4 or null
        // sorted list of value of cbt 
        //leaf node are perfect binary tree
       List<Integer> sizes = new ArrayList<>();
        helper(root, sizes);
        Collections.sort(sizes, Collections.reverseOrder());
        if (sizes.size() < k) {
            return -1;
        }
        return sizes.get(k - 1);
    }
    
    private int[] helper(TreeNode node, List<Integer> sizes) {
        if (node == null) {
            return new int[] {1, 0}; 
        }
        
       
        int[] left = helper(node.left, sizes);
        int[] right = helper(node.right, sizes);
        
      
        if (left[0] == 1 && right[0] == 1 && left[1] == right[1]) {
           
            int currentSize = left[1] + right[1] + 1; 
            sizes.add(currentSize); 
            return new int[] {1, currentSize};  
        }
        
      
        return new int[] {0, 0};
    }
    
    
}",1420534368
Dipkul Khandelwal,deepkul2552003,460,3588,java,"import java.util.Arrays;

class Solution {
    private final int MOD = 1000000007;
    private int[][][] dp;
    
    public int countWinningSequences(String s) {
        int n = s.length();
        dp = new int[n + 1][4][2 * n + 1];
        
       
        for (int[][] a : dp) {
            for (int[] b : a) {
                Arrays.fill(b, -1);
            }
        }
        
       
        return helper(s, 0, -1, 0);
    }
    
    private int helper(String s, int index, int lastBobMove, int scoreDiff) {
        if (index == s.length()) {
           
            return scoreDiff > 0 ? 1 : 0;
        }
        
        if (dp[index][lastBobMove + 1][scoreDiff + s.length()] != -1) {
            return dp[index][lastBobMove + 1][scoreDiff + s.length()];
        }
        
        char aliceMove = s.charAt(index); 
        int totalWays = 0; 
        
      
        for (int bobMove = 0; bobMove < 3; bobMove++) {
            if (bobMove == lastBobMove) continue; 
            
            int newScoreDiff = scoreDiff;
            
          
            if (aliceMove == 'F') { 
                if (bobMove == 1) newScoreDiff++;  
                else if (bobMove == 2) newScoreDiff--;  
            } else if (aliceMove == 'W') {  
                if (bobMove == 0) newScoreDiff--; 
                else if (bobMove == 2) newScoreDiff++; 
            } else {  // Alice summons Earth
                if (bobMove == 0) newScoreDiff++; 
                else if (bobMove == 1) newScoreDiff--;  
            }
            
           
            totalWays = (totalWays + helper(s, index + 1, bobMove, newScoreDiff)) % MOD;
        }
        
        
        dp[index][lastBobMove + 1][scoreDiff + s.length()] = totalWays;
        return totalWays;
    }
}
",1420548328
Dipkul Khandelwal,deepkul2552003,460,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int[] answer = new int[nums.length - k + 1];
        
      
        Map<Integer, Integer> freqMap = new HashMap<>();
        int left = 0;
        
        for (int right = 0; right < nums.length; right++) {
           
            freqMap.put(nums[right], freqMap.getOrDefault(nums[right], 0) + 1);
            
           
            if (right - left + 1 == k) {
             
                PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
                    if (a[1] == b[1]) return b[0] - a[0]; 
                    return b[1] - a[1]; 
                });
                
               
                for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
                    pq.add(new int[]{entry.getKey(), entry.getValue()});
                }
                
               
                int sum = 0;
                for (int i = 0; i < x && !pq.isEmpty(); i++) {
                    int[] element = pq.poll();
                    sum += element[0] * element[1];
                }
                
               
                answer[left] = sum;
                
               
                freqMap.put(nums[left], freqMap.get(nums[left]) - 1);
                if (freqMap.get(nums[left]) == 0) {
                    freqMap.remove(nums[left]);
                }
                
                left++;
            }
        }
        
        return answer;
    }
}",1420526024
Matthew Merrill,MatthewMerrill,461,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:


        def ptrees(root) -> tuple[int, list[int]]:
            if root is None:
                return (0, [])

            pl, plls = ptrees(root.left)
            pr, prls = ptrees(root.right)

            phere = -1
            lshere = plls + prls
            if pl != -1 and pl == pr:
                phere = 2 * pl + 1
                lshere.append(phere)
            
            # print(root.val, phere, lshere)
            return phere, lshere
        
        _, ls = ptrees(root)
        s = sorted(ls, reverse=True)
        return s[k-1] if k <= len(s) else -1
            

                 

        ",1420554770
Matthew Merrill,MatthewMerrill,461,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        by_ch = {
            'F': 0,
            'W': 1,
            'E': 2,
        }

        a = [by_ch[ch] for ch in s]

        # dp = [[0] * 1000 for _ in range(1000)]
        # dp[0][(a[0] + 1) % 3] = 1

        dp = defaultdict(int)
        dp[(a[0],  0)] = 1
        dp[((a[0] + 1) % 3,  1)] = 1
        dp[((a[0] + 2) % 3, -1)] = 1

        N = len(a)
        MOD = 1000000007

        for idx in range(1, N):
            ai = a[idx]
            dp2 = defaultdict(int)

            for k, occ in dp.items():
                bmove, score = k

                if score + N - idx < -2:
                    continue

                if bmove != ai:
                    dp2[(ai, score)] += occ
                    dp2[(ai, score)] %= MOD
                if bmove != (ai + 1) % 3:
                    dp2[((ai + 1) % 3, score + 1)] += occ
                    dp2[((ai + 1) % 3, score + 1)] %= MOD
                if bmove != (ai - 1) % 3:
                    dp2[((ai - 1) % 3, score - 1)] += occ
                    dp2[((ai - 1) % 3, score - 1)] %= MOD

            # print(dp2)
            dp = dp2
        
        tot = 0
        for k, occ in dp.items():
            _, score = k
            if score > 0:
                tot += occ
                tot %= MOD
        return tot


",1420539876
Matthew Merrill,MatthewMerrill,461,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:

        ret = []

        for idx in range(len(nums) - k + 1):
            c = Counter(nums[idx:idx + k])
            s = sorted(c.items(), key=lambda kv: (-kv[1], -kv[0]))[:x]
            a = sum(k * v for k, v in s)
            # print(c, s, a)
            ret.append(a)
        
        return ret
        ",1420520455
JH,jbropark,462,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:

    def find(self, node: Optional[TreeNode]):
        if node is None:
            return 0

        left = self.find(node.left)
        right = self.find(node.right)
        if left is not None and right is not None:
            if left == right:
                ans = 2 * left + 1
                self.ans.append(ans)
                return ans
        
        return None

    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.ans = list()
        self.find(root)
        if k > len(self.ans):
            return -1

        return sorted(self.ans, reverse=True)[k - 1]",1420529908
JH,jbropark,462,3588,python3,"MOD = 1_000_000_007

class Solution:

    @cache
    def count(self, idx: int, prev: str, score: int) -> int:
        if idx >= len(self.s):
            if score > 0:
                return 1
            return 0

        if score + (len(self.s) - idx) <= 0:
            return 0

        ans = 0
        alice = self.s[idx]
        # E < F
        # F < W
        # W < E
        if alice == ""F"":
            if prev != ""W"":
                ans += self.count(idx + 1, ""W"", score + 1)
            if prev != ""F"":
                ans += self.count(idx + 1, ""F"", score)
            if prev != ""E"":
                ans += self.count(idx + 1, ""E"", score - 1)
            return ans % MOD

        elif alice == ""W"":
            if prev != ""W"":
                ans += self.count(idx + 1, ""W"", score)
            if prev != ""F"":
                ans += self.count(idx + 1, ""F"", score - 1)
            if prev != ""E"":
                ans += self.count(idx + 1, ""E"", score + 1)
            return ans % MOD

        elif alice == ""E"":
            if prev != ""W"":
                ans += self.count(idx + 1, ""W"", score - 1)
            if prev != ""F"":
                ans += self.count(idx + 1, ""F"", score + 1)
            if prev != ""E"":
                ans += self.count(idx + 1, ""E"", score)
            return ans % MOD

        raise ValueError

    def countWinningSequences(self, s: str) -> int:
        self.s = s
        return self.count(0, """", 0)
",1420548442
JH,jbropark,462,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        counter = collections.Counter(nums[: k - 1])
        ans = list()
        for i in range(k - 1, len(nums)):
            n = nums[i]
            counter[n] += 1

            most = sorted(counter.items(), reverse=True, key=lambda x: (x[1], x[0]))
            ans.append(sum(v * c for v, c in most[:x]))

            n = nums[i - k + 1]
            counter[n] -= 1
        return ans
        ",1420524663
Lokesh Rajput,lokeshrajput5473,463,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    pair<int, int> depth(TreeNode * root, vector<int> &mp) {
        if(!root) return {0, 0};
        auto left = depth(root->left, mp);
        auto right = depth(root->right, mp);

        if(left.first == right.first && left.first!=-1) {
            mp.push_back(left.second + right.second + 1);
            return {max(left.first, right.first) + 1, left.second + right.second + 1};
        }
        return {-1, -1};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int>mp;
        depth(root, mp);
        sort(mp.rbegin(), mp.rend());
        return mp.size() >= k ? mp[k-1] : -1;
    }
};",1420531052
Lokesh Rajput,lokeshrajput5473,463,3588,cpp,"class Solution {
public:
    
const int EARTH = 0, WATER = 1, FIRE = 2;
const int MOD = 1e9 + 7;
int n;
vector<vector<vector<int>>> memo;

int getCreature(char c) {
    if (c == 'E') return EARTH;
    if (c == 'W') return WATER;
    return FIRE; // Fire for 'F'
}

bool aliceWins(int alice, int bob) {
    return (alice == FIRE && bob == EARTH) || 
           (alice == EARTH && bob == WATER) || 
           (alice == WATER && bob == FIRE);
}

int dp(int i, int wins, int prev, const string &s) {
    if (i == n) return wins > s.size();

    if (memo[i][wins][prev] != -1) return memo[i][wins][prev];

    int bobMove = getCreature(s[i]);
    int result = 0;

    for (int aliceMove = 0; aliceMove < 3; ++aliceMove) {
        if(aliceMove == prev) continue;
        int newWins = wins;
        if (aliceWins(aliceMove, bobMove)) newWins++;
        else if(aliceMove != bobMove) newWins --;

        result = (result + 0ll + dp(i + 1, newWins, aliceMove, s)) % MOD;
    }

    return memo[i][wins][prev] = result;
}

int solve(const string &s) {
    n = s.size();
    memo.assign(n, vector<vector<int>>(n*2 + 1, vector<int>(4, -1)));

    return dp(0, n, 3, s);
}

    int countWinningSequences(string s) {
        return solve(s);
        
    }
};",1420548673
Lokesh Rajput,lokeshrajput5473,463,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int>ans;
        for(int i=0;i<n-k+1;i++) {
            map<int, int> mp;
            for(int j=i;j<=i+k-1;j++) mp[nums[j]] ++;

            vector<pair<int, int>> v;
            for(auto i:mp) v.push_back({i.second, i.first});
            sort(v.rbegin(), v.rend());

            int sum = 0;
            for(int j=0;j<min(x, (int)v.size());j++) {
                // cout << v[j].second << "" "";
                sum += (v[j].second * v[j].first);
            }
            // cout << endl;
            ans.push_back(sum);
        }
        return ans;

    }
};",1420522721
wizwilzo,wizwilzo,464,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> list;
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        if (root == null) return -1;
        list = new ArrayList();
        recurse(root);
        Collections.sort(list);
        System.out.println(list.toString());
        if (list.size() - k < 0) return -1;
        return list.get(list.size() - k);
    }
    public int recurse(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null && root.right == null) {
            list.add(1);
            return 1;
        }
        
        int left = recurse(root.left);
        int right = recurse(root.right);
        if (left == -1 || right == -1) return -1;
        
        if (left == right) {
            list.add(left + right + 1);
            return left + right + 1;
        }
        else {
            return -1;
        }
        
        
    }
}",1420523807
wizwilzo,wizwilzo,464,3588,java,"class Solution {
    Long[][][] cache;
    final long MOD = (long)(1e9+7);
    public int countWinningSequences(String s) {
        cache = new Long[s.length()][s.length() * 2 + 1][3];
        
        long ret = 0;
        char c = s.charAt(0);
        ret += recurse(s,1,s.length() + deter(c, 0), 0);
        ret %= MOD;
        ret += recurse(s,1,s.length() + deter(c,1),1);
        ret %= MOD;
        ret += recurse(s,1,s.length() + deter(c,2),2);
        ret %= MOD;
        return (int)(ret);
        
    }
    //If one player summons a Fire Dragon and the other summons an Earth Golem, the player who summoned the Fire Dragon is awarded a point.
// If one player summons a Water Serpent and the other summons a Fire Dragon, the player who summoned the Water Serpent is awarded a point.
// If one player summons an Earth Golem and the other summons a Water Serpent, the player who summoned the Earth Golem is awarded a point.
// If both players summon the same creature, no player is awarded a point.
    
    //0 means F, 1 means W, 2 means E
    //amtwon is always inflated by s.length()
    private long recurse(String s, int idx, int amtwon, int prev) {
        if (idx >= s.length()) {
            if (amtwon > s.length()) return 1;
            return 0;
        }
        
        if (cache[idx][amtwon][prev] != null) return cache[idx][amtwon][prev];

        char c = s.charAt(idx);
        long ret = 0;
        
        if (prev == 0) {
            //take W
            long w = recurse(s, idx+1, amtwon + deter(c,1), 1);
            //take E
            long e = recurse(s, idx+1, amtwon + deter(c, 2), 2);
            ret %= MOD;
            ret += w;
            ret %= MOD;
            ret += e;
            ret %= MOD;
            
        }
        else if (prev == 1) {
            //take F
            long f = recurse(s, idx+1, amtwon + deter(c,0), 0);
            //take E
            long e = recurse(s, idx+1, amtwon + deter(c, 2), 2);
            ret %= MOD;
            ret += f;
            ret %= MOD;
            ret += e;
            ret %= MOD;
        }
        else {
            //take F
            long f = recurse(s, idx+1, amtwon + deter(c,0), 0);
            //take W
            long w = recurse(s, idx+1, amtwon + deter(c,1), 1);
            ret %= MOD;
            ret += f;
            ret %= MOD;
            ret += w;
            ret %= MOD;
        }
        return cache[idx][amtwon][prev] = ret;
    }
    
    private int deter(char alice, int bob) {
        if (alice == 'F') {
            if (bob == 2) return -1;
            if (bob == 0) return 0;
            if (bob == 1) return 1;
        }
        else if (alice == 'W') {
            if (bob == 0) return -1;
            if (bob == 1) return 0;
            if (bob == 2) return 1;
        }
        //earth
        else {
            if (bob == 0) return 1;
            if (bob == 1) return -1;
            if (bob == 2) return 0;
        }
        //should never return
        return 0;
    }
}",1420541062
wizwilzo,wizwilzo,464,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        
        int[] ret = new int[nums.length -k +1];
        for (int i = 0; i < ret.length; i++) {
            List<Integer> list = new ArrayList();
            for (int j = i; j < i + k; j++) {
                list.add(nums[j]);
            }
            // System.out.println(list.toString());
            ret[i] = helper(list, x);
            list.clear();
        }
        return ret;
        
    }
    private int helper(List<Integer> list, int x) {
        Map<Integer, Integer> map = new HashMap();
        for (int y : list) map.put(y, map.getOrDefault(y, 0)+1);
        
        TreeMap<Integer, List<Integer>> occur = new TreeMap();
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                if (a[1] == b[1]) return Integer.compare(a[0], b[0]) * -1;
                return Integer.compare(a[1], b[1]) * -1;
            }
        });
        for (int key : map.keySet()) {
            pq.offer(new int[] {key, map.get(key)});
        }
        int ret = 0;
        for (int rep = 0; rep < x; rep++) {
            if (!pq.isEmpty()) {
                int[] temp = pq.poll();
                ret += temp[0] * temp[1];
            }
            else break;
        }
        return ret;
    }
}",1420555168
ch1,insomniacat,466,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> sz;
    
    pair<bool, int> dfs(TreeNode* cur) {
        if(!cur) {
            return {true, 0};
        }
        auto [lp, lsz] = dfs(cur->left);
        auto [rp, rsz] = dfs(cur->right);
        int ret = lsz + rsz + 1;
        bool is_per = lp && rp && lsz == rsz;
        if(is_per) {
            // cout << cur->val << "" is per, ret ="" << ret << endl;
            sz.push_back(ret);
        }
        return {is_per, ret};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(sz.rbegin(), sz.rend());
        if(k > sz.size()) {
            return -1;
        }
        return sz[k - 1];
    }
};",1420555589
ch1,insomniacat,466,3588,cpp,"const int kMod = 1e9 + 7;
int mapping[256];
class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        memset(mapping, 0, sizeof(mapping));
        mapping['F'] = 0;
        mapping['W'] = 1;
        mapping['E'] = 2;
        int beats[3];
        beats[0] = 2; // F > E
        beats[1] = 0; // W > F
        beats[2] = 1; // E > W
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2 * n + 1, vector<int>(4, 0)));
        dp[0][n][3] = 1;
        for (int i = 0; i < n; ++i) {
            int am = mapping[s[i]];
            for (int d = 0; d <= 2 * n; ++d) {
                for (int a = 0; a < 4; ++a) {
                    int ways = dp[i][d][a];
                    if (ways == 0) {
                        continue;
                    }
                    for (int bm = 0; bm < 3; ++bm) {
                        if (bm != a) {
                            int dt = 0;
                            if (beats[bm] == am) {
                                dt = 1;
                            } else if (beats[am] == bm) {
                                dt = -1;
                            }
                            int d_new = d + dt;
                            if (d_new >= 0 && d_new <= 2 * n) {
                                dp[i + 1][d_new][bm] = (dp[i + 1][d_new][bm] + ways) % kMod;
                            }
                        }
                    }
                }
            }
        }
        int res = 0;
        for (int d = n + 1; d <= 2 * n; ++d) { 
            for (int a = 0; a < 3; ++a) {
                res = (res + dp[n][d][a]) % kMod;
            }
        }
        return res;
    }
};",1420531480
ch1,insomniacat,466,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        vector<int> freq(51, 0);

        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }

        for (int i = 0; i <= n - k; ++i) {
            vector<pair<int, int>> A;
            for (int a = 1; a <= 50; ++a) {
                if (freq[a] > 0) {
                    A.push_back({freq[a], a});
                }
            }

            sort(A.rbegin(), A.rend());

            int sum = 0;
            int cnt = 0;
            for (auto& [fv, a] : A) {
                if (cnt >= x) {
                    break;
                }
                sum += fv * a;
                cnt++;
            }

            answer.push_back(sum);

            freq[nums[i]]--;
            if (i + k < n) {
                freq[nums[i + k]]++;
            }
        }

        return answer;
    }
};",1420544030
Harttle,harttle,467,3509,javascript,"/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargestPerfectSubtree = function(root, k) {
    const sizes = []
    dfs(root)
    sizes.sort((l, r) => r - l)
    return k > sizes.length ? -1 : sizes[k - 1]
    function dfs(root) {
        if (!root) return { depth: 0, perfect: true, size: 0 }
        const l = dfs(root.left)
        const r = dfs(root.right)
        const size = l.size + r.size + 1
        const depth = Math.max(l.depth, r.depth) + 1
        if (l.depth === r.depth && l.perfect && r.perfect) {
            sizes.push(size)
            return { depth, perfect: true, size }
        }
        return { depth, perfect: false, size }
    }
};",1420529829
Harttle,harttle,467,3588,javascript,"/**
 * @param {string} s
 * @return {number}
 */
var countWinningSequences = function(s) {
    const N = s.length
    const MOD = 1e9 + 7
    const memo = new Map()
    const scores = {
        F: { E: 1 },
        W: { F: 1 },
        E: { W: 1 },
    }
    const encoding = { F: 0, W: 1, E: 2 }
    return dfs(N, 1)
    function dfs(n, score, last) {
        if (!n) return score > 0 ? 0 : 1
        if (score > n) return 0
        const key = encoding[last] * 1e9 + n * 1e5 + (score + 1e4)
        if (memo.has(key)) return memo.get(key)
        let ans = 0
        const a = s[n - 1]
        for (let b of 'FWE') {
            if (b === last) continue
            const bscore = scores[b][a] ? 1 : (scores[a][b] ? -1 : 0)
            ans += dfs(n - 1, score - bscore, b)
            ans %= MOD
        }
        memo.set(key, ans)
        return ans
    }
};",1420549329
Harttle,harttle,467,3610,javascript,"/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} x
 * @return {number[]}
 */
var findXSum = function(nums, k, x) {
    const ans = []
    const n = nums.length
    for (let i = 0; i < n - k + 1; i++) {
        ans.push(xsum(nums.slice(i, i + k)))
    }
    return ans
    function xsum(arr) {
        const occurs = Array(50 + 1).fill(0)
        for (const num of arr) occurs[num]++
        const keys = [...occurs.keys()].sort((l, r) => occurs[r] !== occurs[l] ? occurs[r] - occurs[l] : r - l).slice(0, x)
        return arr.filter(x => keys.includes(x)).reduce((l, r) => l + r, 0)
    }
};",1420522116
Michael Yu,yumichael,468,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_sizes = []

        def get_perfect_size(subroot):
            #print(f'get_perfect_size({subroot})\n{{')
            if not subroot:
                #print(f'}}get_perfect_size({subroot}) => 0\n')
                return 0

            perfect_size = None
            left_perfect = get_perfect_size(subroot.left)
            right_perfect = get_perfect_size(subroot.right)
            if left_perfect is not None and right_perfect is not None and left_perfect == right_perfect:
                perfect_size = left_perfect + right_perfect + 1

            if perfect_size:
                perfect_sizes.append(perfect_size)
            #print(f'}}get_perfect_size({subroot}) => {perfect_size}\n')
            return perfect_size

        get_perfect_size(root)
        perfect_sizes.sort(reverse=True)
        index = k - 1
        #print(perfect_sizes)
        if index >= len(perfect_sizes):
            return -1
        return perfect_sizes[index]
            ",1420534392
Michael Yu,yumichael,468,3588,python3,"mod = 1_000_000_007

def get_change_in_points(alice_move, bob_move):
    '''return change to bob - alice points'''
    if alice_move == bob_move:
        return 0
    elif alice_move + bob_move in ('FW', 'WE', 'EF'):
        return 1
    else:
        return -1

class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        counts = Counter({(0, None): 1}) # (bob - alice, bob's last move): number of sequences
        for alice_move in s:
            new_counts = Counter()
            for (points, last_move), count in counts.items():
                for bob_move in 'FWE':
                    if bob_move == last_move:
                        continue
                    change = get_change_in_points(alice_move, bob_move)
                    new_points = points + change
                    new_last_move = bob_move
                    new_count = (new_counts[new_points, new_last_move] + count) % mod
                    new_counts[new_points, new_last_move] = new_count
            counts = new_counts
        return sum(count for (points, last_move), count in counts.items() if points > 0) % mod
",1420555920
Michael Yu,yumichael,468,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        def find_value(array):
            counter = Counter(array)
            items = sorted(((count, item) for item, count in counter.items()), reverse=True)[:x]
            return sum(count * item for count, item in items)
        answer = [find_value(nums[i : i + k]) for i in range(n - k + 1)]
        return answer
",1420521228
Ujjwal Bharti,dxOZMk6NYV,469,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
  vector<int> perfectSubtreeSizes;
    
    // Helper function to check if the current subtree is perfect and calculate its size
    pair<int, int> checkPerfect(TreeNode* root) {
        if (!root) return {0, 0}; // {height, size}
        
        auto [leftHeight, leftSize] = checkPerfect(root->left);
        auto [rightHeight, rightSize] = checkPerfect(root->right);
        
        if (leftHeight == rightHeight && leftHeight != -1) {
            // This subtree is perfect
            int size = 1 + leftSize + rightSize;
            perfectSubtreeSizes.push_back(size);
            return {leftHeight + 1, size}; // Return updated height and size
        }
        return {-1, 0}; // Not a perfect binary subtree
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
         perfectSubtreeSizes.clear();
        checkPerfect(root);
        
        // Sort sizes in descending order
        sort(perfectSubtreeSizes.rbegin(), perfectSubtreeSizes.rend());
        
        if (perfectSubtreeSizes.size() >= k) {
            return perfectSubtreeSizes[k-1]; // Return the k-th largest size
        } else {
            return -1; // Less than k perfect subtrees
        }
    }
};",1420524082
Ujjwal Bharti,dxOZMk6NYV,469,3588,cpp,"const int M = 1e9 + 7;
class Solution {
public:
     vector<vector<vector<int>>> d;

int m(char c) {
    if (c == 'F') return 0;  
    if (c == 'W') return 1;  
    if (c == 'E') return 2;  
    return -1;
}

int f(int i, int l, int diff, const string &s) {
    if (i == s.length()) {
        return diff > 0 ? 1 : 0;  
    }
    
    if (d[i][l][diff + 1000] != -1) {  
        return d[i][l][diff + 1000];
    }
    
    char am = s[i];  
    int r = 0;

    for (int bm = 0; bm < 3; bm++) {
        if (bm == l) continue; 
        
        int new_diff = diff;

        if (am == 'F' && bm == 1) {
            new_diff++;
        } else if (am == 'W' && bm == 2) {
            new_diff++;
        } else if (am == 'E' && bm == 0) {
            new_diff++;
        } else if ((am == 'F' && bm == 2) || 
                   (am == 'W' && bm == 0) || 
                   (am == 'E' && bm == 1)) {
            new_diff--;
        }

        r = (r + f(i + 1, bm, new_diff, s)) % M;
    }
    
    return d[i][l][diff + 1000] = r;
}
    int countWinningSequences(string s) {
         int n = s.length();
    d = vector<vector<vector<int>>>(n + 1, vector<vector<int>>(4, vector<int>(2001, -1)));
    return f(0, 3, 0, s);
    }
};",1420549758
Ujjwal Bharti,dxOZMk6NYV,469,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& n, int k, int x) {
          int s = n.size();
        vector<int> a;
        
        for (int i = 0; i <= s - k; i++) {
            // Step 1: Extract the subarray of length k starting at index i
            vector<int> u(n.begin() + i, n.begin() + i + k);
            
            // Step 2: Count frequencies of elements in the subarray
            map<int, int> f;
            for (int t : u) {
                f[t]++;
            }
            
            // Step 3: Use a max heap (priority queue) to sort by frequency, then by value
            priority_queue<pair<int, int>> p;
            for (auto& [t, c] : f) {
                p.push({c, t}); // Sort by count first, then by value
            }
            
            // Step 4: Sum the top x elements
            int m = 0;
            for (int j = 0; j < x && !p.empty(); j++) {
                auto [c, t] = p.top(); p.pop();
                m += c * t;
            }
            
            // Step 5: Add the sum to the answer
            a.push_back(m);
        }
        
        return a;
    }
};",1420519861
sanath_tango3,sanath_tango3,470,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
priority_queue<int> pq;
 int dfs(TreeNode* root){
    if(root==NULL){
        return 0;
    }
 //   cout<<""s""<<endl;
int ans=-1;
//     if(root->left==NULL&&root->right!=NULL){
//    ans=-1;
//    dfs(root->right);
//     }else  if(root->right==NULL&&root->left!=NULL){
//         ans=-1;
//         dfs(root->left);
//     }else{
        int a1=dfs(root->right);
        int a2=dfs(root->left);
        if(a1!=-1&&a2!=-1&&a1==a2){
            pq.push(a1+a2+1);
          //  cout<<root->val<<endl;
            return 1+a1+a2;

        }
   
    return -1;




 }


    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        int ans=-1;
        dfs(root);
    cout<<pq.size()<<endl;
        while(!pq.empty()&&k){
            k--;
            if(k==0){
                ans=pq.top();
            }
            pq.pop();

        }
return ans;
    }
};",1420537862
sanath_tango3,sanath_tango3,470,3588,cpp,"class Solution {
public:
int dp[1001][2002][3];
string s;
int mod=1e9+7;
map<char,int> map;
int res(int x,int y){
    if(y==0){
         if(x==0){
            return 0;
         }if(x==1){
            return 1;
         }else{
            return -1;
         }

    }else if(y==1){
if(x==0){
            return -1;
         }if(x==1){
            return 0;
         }else{
            return 1;
         }
    }else{
if(x==0){
            return 1;
         }if(x==1){
            return -1;
         }else{
            return 0;
         }
    }

}
int n;
int help(int ind,int cur,int l){
 if(ind>=n){
    if(cur>1001){
        return 1;
    }
    return 0;
 }
 if(dp[ind][cur][l]!=-1){
    return dp[ind][cur][l];
 }
int ca=map[s[ind]];
int ans=0;
for(int i=0;i<3;i++){
    if(l==i&&ind!=0){
        continue;
    }
int r=res(i,ca);
ans=(ans+help(ind+1,cur+r,i))%mod;

}
return dp[ind][cur][l]=ans;

}

    int countWinningSequences(string sa) {
        s=sa;
        n=s.size();
        map['F']=0;
        map['W']=1;
        map['E']=2;
        memset(dp,-1,sizeof(dp));
        return help(0,1001,0);
    }
};",1420549941
sanath_tango3,sanath_tango3,470,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {

     vector<int> ans;
     int n =nums.size();
     for(int i=k-1;i<n;i++){
        map<int,int> map;
        for(int j=i+1-k;j<=i;j++){
           map[nums[j]]++;
        }
priority_queue<vector<int>> pq;
for(auto i:map){
  pq.push({i.second,i.first});
}
int a=0;
int l=0;
while(!pq.empty()&&l<x){
    l++;
    a+=pq.top()[0]*pq.top()[1];
    pq.pop();
}
ans.push_back(a);

     } 
     return ans;  
    }
};",1420525948
Xinya Wang,deepli,473,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> res = new ArrayList<>();
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        
        dfs(root);
        Collections.sort(res);
        Collections.reverse(res);
        
        System.out.println(""res = "" + res);
        
        //return 0;
        
        if(res.size() < k) return -1;
        return res.get(k-1);
        
    }
    
    int dfs(TreeNode root){
        if(root == null) return 0;
        
        int l = dfs(root.left);
        int r = dfs(root.right);
        
        
        // int L = l[0] + l[1];
        // int R = r[0] + r[1];
        if(l==-1 || r == -1) return -1;
        if(l == r) {
            res.add(l + r + 1);
            return l + r + 1;
        }
        else return -1;
    }
}",1420538069
Xinya Wang,deepli,473,3588,java,"class Solution {
    
    int mod = (int)(1e9 + 7);
    
    public int countWinningSequences(String s) {
     
        int n = s.length();
        int MOD = 1_000_000_007;
        int[] ci = new int[128];
        ci['F'] = 0;
        ci['W'] = 1;
        ci['E'] = 2;
        char[] c = {'F', 'W', 'E'};

        boolean[][] b = new boolean[3][3];
        b[0][2] = true;
        b[1][0] = true;
        b[2][1] = true;

        long[][][] dp = new long[n + 1][4][2 * n + 1];
        dp[0][3][n] = 1;

        String lufrenixaq = s;

        for (int i = 0; i < n; i++) {
            char ac = lufrenixaq.charAt(i);
            int ai = ci[ac];
            for (int prev = 0; prev <= 3; prev++) {
                for (int diff = 0; diff <= 2 * n; diff++) {
                    long count = dp[i][prev][diff];
                    if (count == 0) continue;
                    for (int curr = 0; curr < 3; curr++) {
                        if (prev != 3 && curr == prev) continue;
                        char bc = c[curr];
                        int bi = curr;
                        int nd = diff;
                        if (bc == ac) {
                          
                        } else if (b[bi][ai]) {
                           
                            nd = diff + 1;
                        } else if (b[ai][bi]) {
                           
                            nd = diff - 1;
                        }
                        if (nd >= 0 && nd <= 2 * n) {
                            dp[i + 1][curr][nd] = (dp[i + 1][curr][nd] + count) % MOD;
                        }
                    }
                }
            }
        }

        long result = 0;
        for (int prev = 0; prev < 3; prev++) {
            for (int diff = n + 1; diff <= 2 * n; diff++) {
                result = (result + dp[n][prev][diff]) % MOD;
            }
        }
        return (int) result;
    }
     

}",1420550640
Xinya Wang,deepli,473,3610,java,"class Solution {
    public int[] findXSum(int[] A, int k, int x) {
        
        int n = A.length;
        
        int[] ans = new int[n-k + 1];
        
        
        for(int i = 0; i + k - 1 <n; i++){
            
            PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->(a[1] == b[1]? b[0] - a[0]: b[1]- a[1]));
            
            HashMap<Integer, Integer> m = new HashMap<>();
            for(int j = i; j <= i + k-1; j++ ){
                int e = A[j];
                m.put(e, m.getOrDefault(e, 0) + 1);
                
            }
            
            for(int c : m.keySet()){
                q.offer(new int[]{c, m.get(c)});
            }
            
            int X = x;
            
            int res = 0;
            while(X > 0 && !q.isEmpty()){
                int[] t = q.poll();
                int z = t[0];
                res += t[0]*t[1];
                X--;
            }
            
            ans[i] = res;
        }
        
        return ans;
    }
}",1420523180
peicd7699,peicd7699,476,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        
        self.cnt = Counter()
        
        def dfs(node):
            if node == None:
                return True, 0
            
            lf, lc = dfs(node.left)
            rf, rc = dfs(node.right)
            if not lf or not rf:
                return False, -1
            if lc!=rc:
                return False, -1
            
            self.cnt[lc+rc+1] += 1
            return True, lc+rc+1
        
        dfs(root)
        
        arr = [(val, cn) for val,cn in self.cnt.items()]
        arr = sorted(arr)[::-1]
        
        tmp = 0
        for val, cn in arr:
            tmp += cn
            if tmp >= k:
                return val
        return -1
            
            ",1420526328
peicd7699,peicd7699,476,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10**9+7
        n = len(s)
        dpf = [0] * (2 * n +1) 
        dpe = [0] * (2 * n +1) 
        dpw = [0] * (2 * n +1) 
        base = n
        dpf[n] = dpe[n] = dpw[n] = 1
        
        res = 0
        for ind,c in enumerate(s):
            new_dpf = [0] * (2 * n +1) 
            new_dpe = [0] * (2 * n +1) 
            new_dpw = [0] * (2 * n +1) 
            if c == ""W"":
                for i in range(2 * n +1):
                    if i+1 < 2*n+1:
                        new_dpf[i] += dpe[i+1] + dpw[i+1]
                    new_dpw[i] += dpf[i] + dpe[i]
                    if i:
                        new_dpe[i] += dpf[i-1] + dpw[i-1]
                    
                    new_dpf[i] %= mod
                    new_dpe[i] %= mod
                    new_dpw[i] %= mod
            elif c == ""E"":
                for i in range(2 * n +1):
                    if i+1 < 2*n+1:
                        new_dpw[i] += dpe[i+1] + dpf[i+1]
                    new_dpe[i] += dpf[i] + dpw[i]
                    if i:
                        new_dpf[i] += dpw[i-1] + dpe[i-1]
                    
                    new_dpf[i] %= mod
                    new_dpe[i] %= mod
                    new_dpw[i] %= mod
            else: # F
                for i in range(2 * n +1):
                    if i+1 < 2*n+1:
                        new_dpe[i] += dpw[i+1] + dpf[i+1]
                    new_dpf[i] += dpe[i] + dpw[i]
                    if i:
                        new_dpw[i] += dpf[i-1] + dpe[i-1]
                    
                    new_dpf[i] %= mod
                    new_dpe[i] %= mod
                    new_dpw[i] %= mod
                    
            dpf, dpe, dpw = new_dpf, new_dpe, new_dpw
            if ind==0:
                dpf = [v//2 for v in dpf]
                dpe = [v//2 for v in dpe]
                dpw = [v//2 for v in dpw]
            # print(n, dpf, dpe, dpw)
            # print(n, )
        
        for i in range(n+1, n*2+1):
            res += dpf[i] + dpe[i] + dpw[i]
        return res%mod
         
        ",1420550986
peicd7699,peicd7699,476,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cnt = Counter()
        
        res = []
        
        for i, v in enumerate(nums):
            cnt[v] += 1
            if i-k >= 0:
                cnt[nums[i-k]] -= 1
            
            if i>=k-1:
                arr = [(occur, val) for val, occur in cnt.items()]
                arr = sorted(arr)[::-1]
                tmp = 0
                for ind in range(min(x, len(arr))):
                    occur, val = arr[ind]
                    tmp += occur * val
                res += [tmp]
        return res
                    
        ",1420521610
Dhruvrajsinh,_batman__,477,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>s;
    
    int dfs(TreeNode * root){
        if(root==NULL) return 0;
        
        int ans = 1;
        
        int l = dfs(root->left);
        int r = dfs(root->right);
        
       if(l!=r) return -1;
       if(l==-1 || r==-1) return -1;
        
        ans += l;
        ans += r;
        
        s.push_back(ans);
        
        return ans;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(s.rbegin(),s.rend());
        if(k > s.size()) return -1;
        return s[k-1];
    }
};",1420528062
Dhruvrajsinh,_batman__,477,3588,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
    
    vector<int>vec = {0, 1, 2};
    
    int dp[1005][2005][4];
    
    int solve(int ind, string &s, int cnt, int prev) {
        if (ind == s.size()) {
            return (cnt > 0) ? 1 : 0;
        }
        
        if (dp[ind][cnt + s.size()][prev + 1] != -1) {
            return dp[ind][cnt + s.size()][prev + 1];
        }
        
        long long ans = 0;
        
        for (int it : vec) {
            if (it == prev) continue;
            
            if (s[ind] == 'W') {
                if (it == 2) ans += solve(ind + 1, s, cnt + 1, it);
                else if (it == 1) ans += solve(ind + 1, s, cnt - 1, it);
                else ans += solve(ind + 1, s, cnt, it);
            }
            else if (s[ind] == 'E') {
                if (it == 1) ans += solve(ind + 1, s, cnt + 1, it);
                else if (it == 0) ans += solve(ind + 1, s, cnt - 1, it);
                else ans += solve(ind + 1, s, cnt, it);
            }
            else {
                if (it == 0) ans += solve(ind + 1, s, cnt + 1, it);
                else if (it == 2) ans += solve(ind + 1, s, cnt - 1, it);
                else ans += solve(ind + 1, s, cnt, it);
            }
            
            ans %= mod;
        }
        
        return dp[ind][cnt + s.size()][prev + 1] = ans;
    }
    
    int countWinningSequences(string s) {
        int n = s.size();
       memset(dp,-1,sizeof(dp));
        return solve(0, s, 0, -1);
    }
};
",1420557513
Dhruvrajsinh,_batman__,477,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
            vector<int>ans;
            
             for(int i=0;i<nums.size();i++){
                    if(i + k - 1>= nums.size()) continue;
                    priority_queue<pair<int,int>>q;
                    map<int,int>mp;
                    for(int j=i;j<i+k;j++){
                        mp[nums[j]]++;
                    }
                    for(auto it : mp){
                          q.push({-it.second,-it.first});
                          if(q.size() > x) q.pop();
                    }
                 
                    int sum = 0;
                    while(!q.empty()){
                          sum += q.top().second*q.top().first;
                          q.pop();
                    }
                    ans.push_back(sum);
             }
        return ans;
    }
};",1420521985
zsUKDL0hv8,zsUKDL0hv8,478,3509,cpp,"#include <vector>
#include <algorithm> // for sort

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    // Helper function to determine if the current subtree is perfect and return its size
    std::pair<int, bool> checkPerfectSubtree(TreeNode* root, std::vector<int>& sizes) {
        if (!root) {
            return {0, true};  // An empty subtree is considered perfect
        }

        // Post-order traversal: check left and right subtrees first
        auto [leftSize, isLeftPerfect] = checkPerfectSubtree(root->left, sizes);
        auto [rightSize, isRightPerfect] = checkPerfectSubtree(root->right, sizes);

        // If both subtrees are perfect and have the same size, the current subtree is perfect
        if (isLeftPerfect && isRightPerfect && leftSize == rightSize) {
            int subtreeSize = leftSize + rightSize + 1;  // Size of the current perfect subtree
            sizes.push_back(subtreeSize);  // Add the size to the list of perfect subtrees
            return {subtreeSize, true};  // Return the size and indicate it's perfect
        }
        return {0, false};  // If not perfect, return false
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        std::vector<int> sizes;  // To store sizes of all perfect subtrees
        
        // Traverse the tree and collect sizes of perfect subtrees
        checkPerfectSubtree(root, sizes);

        // Sort the sizes in descending order
        std::sort(sizes.begin(), sizes.end(), std::greater<int>());

        // Check if there are at least k perfect subtrees
        if (sizes.size() < k) {
            return -1;  // If fewer than k perfect subtrees, return -1
        }

        // Return the k-th largest perfect subtree size
        return sizes[k - 1];
    }
};
",1420530604
zsUKDL0hv8,zsUKDL0hv8,478,3588,cpp,"#include <vector>
#include <string>

class Solution {
public:
    int countWinningSequences(std::string s) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        
        // Alice's move sequence stored in lufrenixaq
        std::string lufrenixaq = s;
        
        // DP array: dp[i][scoreDiff][bPrevMove] where
        // i = current round, scoreDiff = bobScore - aliceScore, and
        // bPrevMove = Bob's previous move (0: none, 1: Fire Dragon, 2: Water Serpent, 3: Earth Golem)
        // We limit the scoreDiff range to [-n, n] which is shifted by +n to fit in the array.
        std::vector<std::vector<std::vector<int>>> dp(2, std::vector<std::vector<int>>(2 * n + 1, std::vector<int>(4, 0)));
        
        // Initial state: before the first round, no score difference, and Bob hasn't made a move.
        dp[0][n][0] = 1; // n represents the shifted index of scoreDiff = 0

        // Transition through rounds
        for (int i = 0; i < n; i++) {
            // Reset the dp for the next round
            dp[(i + 1) % 2] = std::vector<std::vector<int>>(2 * n + 1, std::vector<int>(4, 0));
            
            // Alice's move in the current round
            char aMove = lufrenixaq[i];

            // We only need to check scoreDiff in the range [-i, +i], shifted by +n
            for (int scoreDiff = n - i; scoreDiff <= n + i; scoreDiff++) {
                for (int bPrevMove = 0; bPrevMove <= 3; bPrevMove++) {
                    if (dp[i % 2][scoreDiff][bPrevMove] == 0) continue;
                    
                    // Bob's possible moves
                    for (int bMove = 1; bMove <= 3; bMove++) {
                        if (bMove == bPrevMove) continue; // Bob can't repeat his last move
                        
                        int newScoreDiff = scoreDiff;

                        // Determine score difference update
                        if ((aMove == 'F' && bMove == 2) ||  // Alice: Fire Dragon, Bob: Water Serpent
                            (aMove == 'W' && bMove == 3) ||  // Alice: Water Serpent, Bob: Earth Golem
                            (aMove == 'E' && bMove == 1)) {  // Alice: Earth Golem, Bob: Fire Dragon
                            newScoreDiff++;  // Bob wins
                        } else if ((aMove == 'F' && bMove == 3) ||  // Alice: Fire Dragon, Bob: Earth Golem
                                   (aMove == 'W' && bMove == 1) ||  // Alice: Water Serpent, Bob: Fire Dragon
                                   (aMove == 'E' && bMove == 2)) {  // Alice: Earth Golem, Bob: Water Serpent
                            newScoreDiff--;  // Alice wins
                        }

                        // Only update dp if the new scoreDiff is within valid bounds [-n, n]
                        if (newScoreDiff >= n - (i + 1) && newScoreDiff <= n + (i + 1)) {
                            dp[(i + 1) % 2][newScoreDiff][bMove] = 
                                (dp[(i + 1) % 2][newScoreDiff][bMove] + dp[i % 2][scoreDiff][bPrevMove]) % MOD;
                        }
                    }
                }
            }
        }

        // Sum all valid final states where Bob's score is greater than Alice's
        int result = 0;
        for (int scoreDiff = n + 1; scoreDiff <= 2 * n; scoreDiff++) { // only positive scoreDiff
            for (int bPrevMove = 1; bPrevMove <= 3; bPrevMove++) {
                result = (result + dp[n % 2][scoreDiff][bPrevMove]) % MOD;
            }
        }
        
        return result;
    }
};
",1420528890
zsUKDL0hv8,zsUKDL0hv8,478,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;

        // Iterate through all possible subarrays of length k
        for (int i = 0; i <= n - k; ++i) {
            // Extract the subarray nums[i..i+k-1]
            unordered_map<int, int> freq;  // To store frequencies of elements

            // Count frequencies in the current subarray
            for (int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }

            // Collect all elements and their frequencies
            vector<pair<int, int>> elements;
            for (auto& p : freq) {
                elements.push_back({p.second, p.first});  // {frequency, value}
            }

            // Sort by frequency first, and by value in case of ties
            sort(elements.begin(), elements.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.first == b.first) return a.second > b.second;  // If frequency is the same, prefer larger value
                return a.first > b.first;  // Otherwise, prefer higher frequency
            });

            // Calculate the sum of the top x most frequent elements
            int sum = 0;
            int count = 0;

            for (auto& p : elements) {
                int freq = p.first, value = p.second;
                int total_occurrences = freq;  // Use all occurrences of this element

                // Add the value of the element for all of its occurrences
                sum += total_occurrences * value;
                count++;

                if (count >= x) break;  // We only need the top x elements
            }

            answer.push_back(sum);
        }

        return answer;
    }
};
",1420532751
dpdpdpp,dpdpdpp,479,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sub = []

        def dfs(o):
            if not o:
                return (True, 0)
            left = dfs(o.left)
            right = dfs(o.right)
            if left == right and left[0]: # perfect
                sz = left[1] * 2 + 1
                sub.append(sz)
                return (True, sz)
            else: # bad
                return (False, 0)

        dfs(root)

        if len(sub) >= k:
            sub.sort()
            return sub[-k]

        return -1",1420533272
dpdpdpp,dpdpdpp,479,3588,python3,"# F>E
# W>F
# E>W
MOD = 10 ** 9 + 7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        N = len(s)

        def f(a, b):
            p = a + b
            if p == ""FE"":
                return 1
            if p == ""EF"":
                return -1
            if p == ""WF"":
                return 1
            if p == ""FW"":
                return -1
            if p == ""EW"":
                return 1    
            if p == ""WE"":
                return -1
            return 0
            
        @cache
        def dp(i, prev, bal):
            if i == N:
                return int(bal < 0)
            res = 0
            for bob in ""FWE"":
                if bob == prev:
                    continue
                delta = f(s[i], bob)
                res += dp(i+1, bob, bal + delta)
            return res % MOD


        ans = dp(0, ""#"", 0)
        dp.cache_clear()

        return ans",1420551579
dpdpdpp,dpdpdpp,479,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        N = len(nums)

        def f(i):
            sub = nums[i:i+k]
            d = Counter(sub)
            items = sorted(d.items(), key=lambda x:(-x[1], -x[0]))
            rem = x
            res = 0
            for key, val in items:
                res += key * val
                rem -= 1
                if rem == 0:
                    break
            return res

        return [f(i) for i in range(N-k+1)]",1420524362
Jashwanth Reddy,jashwanthrdy,480,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    priority_queue<int,vector<int>,greater<int>> pq;
    int kn;
    pair<int,bool> solve(TreeNode* root){
        if(!root) return {0,true};

        auto [lef,lb] = solve(root->left);
        auto [rig,rb] = solve(root->right);
        bool curr = false;
        if(lb && rb && lef==rig){
            curr=true;
            pq.push(lef+rig+1);
            if(pq.size()>kn) pq.pop();
        }
        return {lef+rig+1,curr};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        kn = k;
        solve(root);
        return pq.size()==k ? pq.top() : -1;
    }
};",1420532718
Jashwanth Reddy,jashwanthrdy,480,3588,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
    int solve(int i,int prev,int score,string &s,vector<vector<vector<int>>> &dp){
        if(i==s.size()){
            return score > 0 ? 1 : 0;
        }
        if(dp[i][prev+1][score+1000]!=-1e5) return dp[i][prev+1][score+1000];
        int ans = 0;
        if(prev!=0){
            if(s[i]=='F'){
                ans += solve(i+1,0,score,s,dp);
            }
            if(s[i]=='W'){
                ans += solve(i+1,0,score-1,s,dp);
            }
            if(s[i]=='E'){
                ans += solve(i+1,0,score+1,s,dp);
            }
        }
        ans %= mod;
        if(prev!=1){
            if(s[i]=='F'){
                ans += solve(i+1,1,score+1,s,dp);
            }
            if(s[i]=='W'){
                ans += solve(i+1,1,score,s,dp);
            }
            if(s[i]=='E'){
                ans += solve(i+1,1,score-1,s,dp);
            }
        }
        ans %=mod;
        if(prev!=2){
            if(s[i]=='F'){
                ans += solve(i+1,2,score-1,s,dp);
            }
            if(s[i]=='W'){
                ans += solve(i+1,2,score+1,s,dp);
            }
            if(s[i]=='E'){
                ans += solve(i+1,2,score,s,dp);
            }
        }
        ans %= mod;
        return dp[i][prev+1][score+1000] = (ans%mod);
    }
    int countWinningSequences(string s) {
        int n =s.length();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(4,vector<int>(2005,-1e5)));
        // if(s[0]=='F')
        return solve(0,-1,0,s,dp);
    }
};",1420551612
Jashwanth Reddy,jashwanthrdy,480,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& arr, int k, int x) {
        vector<int> ans;
        unordered_map<int,int> mp;
        for(int i=0;i<k-1;i++){
            mp[arr[i]]++;
        }
        int n = arr.size();
        for(int i=k-1;i<n;i++){
            if(i-k>=0){
                mp[arr[i-k]]--;
                if(mp[arr[i-k]]==0){
                    mp.erase(arr[i-k]);
                }
            }
            mp[arr[i]]++;
            vector<pair<int,int>> temp;
            for(auto e : mp){
                // cout << e.second << "" "" << e.first << endl; 
                temp.push_back({e.second,e.first});
            }
            sort(temp.begin(),temp.end(),[](pair<int,int> &a,pair<int,int> &b){
                if(a.first!=b.first){
                    return a.first>b.first;
                }
                return a.second > b.second;
            });
            int j = 0;
            int sum = 0;
            while(j<temp.size() && j<x){
                sum += temp[j].first * temp[j].second;
                j++;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420523713
iso9661,iso9661,481,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        
        def helper(node):
            if node is None:
                return True, 0, 0
            
            left_is_perfect, left_height, left_size = helper(node.left)
            right_is_perfect, right_height, right_size = helper(node.right)
            
            current_is_perfect = (left_is_perfect and right_is_perfect and left_height == right_height)
            current_height = left_height + 1 if current_is_perfect else max(left_height, right_height) + 1
            current_size = left_size + right_size + 1
            
            if current_is_perfect:
                sizes.append(current_size)
                
            return current_is_perfect, current_height, current_size
        
        helper(root)
        sizes.sort(reverse=True)
        if k <= len(sizes):
            return sizes[k - 1]
        else:
            return -1",1420529582
iso9661,iso9661,481,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        lufrenixaq = s

        creature_indices = {'F': 0, 'W': 1, 'E': 2}
        indices_to_creature = {0: 'F', 1: 'W', 2: 'E'}

        BobWins = {('F', 'E'), ('W', 'F'), ('E', 'W')}
        AliceWins = {('E', 'F'), ('F', 'W'), ('W', 'E')}

        max_d = 2 * n
        dp_prev = [ [0] * (max_d + 1) for _ in range(3) ]
        dp = [ [0] * (max_d + 1) for _ in range(3) ]

        a_c = lufrenixaq[0]
        for b_c_index in range(3):
            b_c = indices_to_creature[b_c_index]
            if b_c == a_c:
                delta = 0
            elif (b_c, a_c) in BobWins:
                delta = 1
            elif (b_c, a_c) in AliceWins:
                delta = -1
            else:
                delta = 0
            d = n + delta
            dp_prev[b_c_index][d] = 1

        for i in range(1, n):
            a_c = lufrenixaq[i]
            for c in range(3):
                for d in range(max_d + 1):
                    dp[c][d] = 0

            for prev_bob in range(3):
                for d in range(max_d + 1):
                    ways = dp_prev[prev_bob][d]
                    if ways == 0:
                        continue
                    for new_bob in range(3):
                        if new_bob == prev_bob:
                            continue
                        b_c = indices_to_creature[new_bob]
                        if b_c == a_c:
                            delta = 0
                        elif (b_c, a_c) in BobWins:
                            delta = 1
                        elif (b_c, a_c) in AliceWins:
                            delta = -1
                        else:
                            delta = 0
                        new_d = d + delta
                        if 0 <= new_d <= max_d:
                            dp[new_bob][new_d] = (dp[new_bob][new_d] + ways) % mod
            dp, dp_prev = dp_prev, dp

        result = 0
        for prev_bob in range(3):
            for d in range(n + 1, max_d + 1):
                result = (result + dp_prev[prev_bob][d]) % mod

        return result",1420551785
iso9661,iso9661,481,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = []
        
        counts = defaultdict(int)
        sorted_counts = []
        
        for i in range(k):
            num = nums[i]
            counts[num] += 1
            
        for num, count in counts.items():
            insort_left(sorted_counts, (-count, -num))
            
        for i in range(n - k + 1):
            if i > 0:
                num_out = nums[i - 1]
                count_old = counts[num_out]
                idx = bisect_left(sorted_counts, (-count_old, -num_out))
                del sorted_counts[idx]
                counts[num_out] -= 1
                if counts[num_out] > 0:
                    insort_left(sorted_counts, (-counts[num_out], -num_out))
                else:
                    del counts[num_out]
                    
                num_in = nums[i + k - 1]
                count_old = counts.get(num_in, 0)
                if count_old > 0:
                    idx = bisect_left(sorted_counts, (-count_old, -num_in))
                    del sorted_counts[idx]
                counts[num_in] = count_old + 1
                insort_left(sorted_counts, (-counts[num_in], -num_in))
                
            total = 0
            top_elements = sorted_counts[:x]
            for neg_count, neg_num in top_elements:
                num = -neg_num
                count = counts[num]
                total += num * count
            answer.append(total)
        return answer",1420524402
Srikkanth R,srikkanthr,482,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int helper(TreeNode* root, vector<int> &sub) {
        if (root == nullptr) {
            return 0;
        }
        auto lef = helper(root->left, sub);
        auto rig = helper(root->right, sub);
        // cout << lef << "" "" << rig << "" got\n"";
        if (lef == rig && lef >= 0) {
            // cout << ""here "" << lef + 1 << "" wtf\n"";
            sub.push_back(lef + 1);
            return lef + 1;
        }
        return -1;
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sub;
        helper(root, sub);
        // for (auto x : sub) cout << x << "" "";
        // cout << '\n';
        sort(sub.begin(), sub.end());
        reverse(sub.begin(), sub.end());
        if (k > sub.size()) return -1;
        return (1<<sub[k-1]) - 1;
    }
};",1420534498
Srikkanth R,srikkanthr,482,3588,cpp,"class Solution {
    const int MOD = (int)1e9 + 7;
public:
    int conv(char c) {
        if (c == 'F') return 0;
        if (c == 'W') return 1;
        if (c == 'E') return 2;
        return -1;
    }
    int countWinningSequences(string s) {
        int n = s.size();
        vector<vector<int> > dp(3, vector<int>(2 * n + 1, 0)), tdp;
        dp[0][n] = 1;
        dp[1][n] = 1;
        dp[2][n] = 1;
        for (auto c : s) {
            int x = conv(c);
            tdp = dp;
            for (int j=0;j<3;++j) fill(dp[j].begin(), dp[j].end(), 0);
            for (int j=0;j<3;++j) {
                int score;
                if (j == x) {
                    score = 0;
                } else if (j == (x + 1) % 3) {
                    score = 1;
                } else {
                    score = -1;
                }
                for (int jj=0;jj<3;++jj) if (jj != j) {
                    for (int cs=-n;cs<=n;++cs) if (tdp[jj][cs+n]) {
                        dp[j][cs + score + n] += tdp[jj][cs + n];
                        if (dp[j][cs + score + n] >= MOD) {
                            dp[j][cs + score + n] -= MOD;
                        }
                    }
                }
            }
        }
        int ans = 0;
        for (int cs=1;cs<=n;++cs) {
            for (int j=0;j<3;++j) {
                ans += dp[j][cs + n];
                if (ans >= MOD) ans -= MOD;
            }
        }
        int MODINV2 = (MOD + 1) >> 1;
        ans = (ans * 1LL * MODINV2) % MOD; 
        return ans;
    }
};",1420551883
Srikkanth R,srikkanthr,482,3610,cpp,"class Solution {
public:
    int getX(vector<int> &nums, int x) {
        map<int, int> mp;
        for (auto &x : nums) mp[x] += 1;
        vector<pair<int, int> > v;
        for (auto pr : mp) {
            v.push_back({-pr.second, -pr.first});
        }
        sort(v.begin(), v.end());
        int ans = 0, n = v.size();
        for (int i=0;i<x&&i<n;++i) {
            ans += v[i].first * 1LL * v[i].second;
            // cout << -v[i].first << "","" << -v[i].second << "" "";
        }
        // cout << '\n';
        return ans;
    }
    vector<int> findXSum(vector<int>& v, int k, int x) {
        vector<int> ret;
        int n = v.size();
        for (int i=0;i+k<=n;++i) {
            vector<int> now;
            for (int j=i;j<i+k;++j) {
                now.push_back(v[j]);
            }
            ret.push_back(getX(now, x));
        }
        return ret;
    }
};",1420522973
Arpit Krishna,ArpitKrishna99,483,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        def dfs(node):
            if not node:
                return 0, True  
            lh, isleft = dfs(node.left)
            rh, isright = dfs(node.right)
            if isleft and isright and lh == rh:
                curr = lh + 1
                temp = (1 << curr) - 1  
                sizes.append(temp)
                return curr, True
            else:
                return max(lh, rh), False
        dfs(root)
        sizes.sort(reverse=True)
        return sizes[k-1] if k <= len(sizes) else -1
",1420521764
Arpit Krishna,ArpitKrishna99,483,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = int(1e9 + 7)
        n = len(s)
        win = {
            'F': {'W': 1, 'E': -1, 'F': 0},
            'W': {'E': 1, 'F': -1, 'W': 0},  
            'E': {'F': 1, 'W': -1, 'E': 0}   
        }
        
        @cache
        def backtrack(i, last, bs, ac):
            if i == n:
                return 1 if bs > ac else 0

            ans = 0
            for j in ['F', 'W', 'E']:
                if j == last:
                    continue  
                new_bs = bs + win[s[i]][j] 
                new_ac = ac - win[s[i]][j]
                ans += backtrack(i + 1, j, new_bs, new_ac)
                ans %= MOD

            return ans
        return backtrack(0, '', 0, 0)
",1420551929
Arpit Krishna,ArpitKrishna99,483,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        result = []
        
        for i in range(n - k + 1):
            sub = nums[i:i+k]
            freq = Counter(sub)
            sor = sorted(freq.items(), key=lambda elem: (-elem[1], -elem[0]))
            temp = 0
            for j in range(min(x, len(sor))):
                temp += sor[j][0] * sor[j][1]
            result.append(temp)
        
        return result",1420519831
NAVEEN KUMAR S,hornedfoe,484,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution{
    public int kthLargestPerfectSubtree(TreeNode root , int k){
        List<Integer> list = new ArrayList<>();
        finder(root , list);
        list.sort((a , b) -> b - a);
        return list.size() > k - 1 ? list.get(k - 1) : -1;
    }
    private int finder(TreeNode root , List<Integer> list){
        if(root == null) return 0;
        int left = finder(root.left , list) , right = finder(root.right , list) , ret = -1;
        if(left == right && left != -1) ret = left + right + 1;
        if(ret != -1) list.add(ret);
        return ret;
    }
}",1420536039
NAVEEN KUMAR S,hornedfoe,484,3588,java,"class Solution{
    Map<Character , Integer> map = new HashMap<>(){{
        put('F' , 0);
        put('W' , 1);
        put('E' , 2);
    }};
    char[] s;
    int n , mod = (int) 1e9 + 7;
    Long[][][] dp;
    public int countWinningSequences(String str){
        s = str.toCharArray();
        n = s.length;
        dp = new Long[n][n + n + 1][4];
        return (int) finder(0 , 0 , -1);
    }
    private long finder(int x , int y , int z){
        if(x == n) return y < 0 ? 1l : 0l;
        if(dp[x][n + y][z + 1] != null) return dp[x][n + y][z + 1];
        int a = map.get(s[x]);
        long ret = 0;
        if(z != 0) ret += finder(x + 1 , y + finder(a , 0) , 0);
        if(z != 1) ret += finder(x + 1 , y + finder(a , 1) , 1);
        if(z != 2) ret += finder(x + 1 , y + finder(a , 2) , 2);
        return dp[x][n + y][z + 1] = ret % mod;
    }
    private int finder(int a , int b){
        if(a == b) return 0;
        if(a == 0) return b == 2 ? 1 : -1;
        if(a == 1) return b == 0 ? 1 : -1;
        return b == 1 ? 1 : -1;
    }
}",1420558418
NAVEEN KUMAR S,hornedfoe,484,3610,java,"class Solution{
    public int[] findXSum(int[] nums , int k , int t){
        int n = nums.length , ret[] = new int[n - k + 1];
        for(int i = 0 , j = k ; j <= n ; i++ , j++){
            int[] arr = new int[51];
            PriorityQueue<Integer> p = new PriorityQueue<>((a , b) -> arr[b] == arr[a] ? b - a : arr[b] - arr[a]);
            for(int x = i ; x < j ; x++){
                arr[nums[x]] += 1;
            }
            for(int x = 0 ; x <= 50 ; x++) p.offer(x);
            for(int x = 0 ; x < t && p.size() > 0 ; x++){
                ret[i] += arr[p.peek()] * p.poll();
            }
        }
        return ret;
    }
}",1420523907
Haipei Liu,lhp_ch,486,3509,python3,"from typing import Optional, List


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ps = []

        def dfs(node):
            if not node:
                return (True,0,0)
            
            lp,lh,ls=dfs(node.left)
            rp,rh,rs=dfs(node.right)

            if lp and rp and lh==rh:
                curh= lh+1
                curs=(1<<curh)-1
                ps.append(curs)
                return(True,curh,curs)
            else:
                curh=max(lh,rh)+1
                curs=ls+rs+1
                return(False,curh,curs)
        dfs(root)

        if not ps:
            return -1
        
        ps.sort(reverse=True)

        if k<=len(ps):
            return ps[k-1]
        else:
            return -1
        ",1420535340
Haipei Liu,lhp_ch,486,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD= 10**9+7
        n= len(s)

        cmap={'F':0,'W':1,'E':2}
        ams=[cmap[c] for c in s] 

        score=[
            [0,-1,1],
            [1,0,-1],
            [-1,1,0]
        ]

        curDP=[[0]*(2*n+1) for _ in range(4)]
        curDP[3][n]=1

        for i in range(n):
            nDP=[[0]*(2*n+1)for _ in range(4)]
            am=ams[i]
            for last in range(4):
                for diff in range(2*n+1):
                    cnt=curDP[last][diff]
                    if cnt ==0:
                        continue
                    for m in range(3):
                        if m == last:
                            continue
                        outcome = score[m][am]
                        new_diff = diff+outcome
                        if new_diff<0 or new_diff >2*n:
                            continue
                        nDP[m][new_diff]=(nDP[m][new_diff]+cnt)%MOD
            curDP=nDP
        ans = 0
        for last in range(3):
            for diff in range(n+1,2*n+1):
                ans = (ans + curDP[last][diff])%MOD
        return ans",1420559069
Haipei Liu,lhp_ch,486,3610,python3,"from typing import List
from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n= len(nums)
        answer= []

        for i in range(n-k+1):
            subarray = nums[i:i+k]
            freq = Counter (subarray)

            sorted_elements = sorted (freq.items(),key = lambda item:(-item[1],-item[0]))
            tope = set()
            for j in range(min(x,len(sorted_elements))):
                tope.add(sorted_elements[j][0])
            
            sub_sum = sum(x for x in subarray if x in tope)
            answer.append(sub_sum)
        return answer",1420525531
lamyhc,lamyhc,488,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> perfectSubtreeSizes = new ArrayList<>();
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        findPerfectSubtrees(root);
        perfectSubtreeSizes.sort(Collections.reverseOrder());
        if (perfectSubtreeSizes.size() < k) return -1;
        return perfectSubtreeSizes.get(k - 1);
    }

    private SubtreeInfo findPerfectSubtrees(TreeNode node) {
        if (node == null) {
            return new SubtreeInfo(true, 0, 0); 
        }
        SubtreeInfo leftInfo = findPerfectSubtrees(node.left);
        SubtreeInfo rightInfo = findPerfectSubtrees(node.right);
        
        boolean isPerfect = leftInfo.isPerfect && rightInfo.isPerfect && leftInfo.height == rightInfo.height;
        int size = leftInfo.size + rightInfo.size + 1;
        int height = leftInfo.height + 1;
        
        if (isPerfect) {
            perfectSubtreeSizes.add(size);
        }
        
        return new SubtreeInfo(isPerfect, size, height);
    }

    class SubtreeInfo {
        boolean isPerfect;
        int size; 
        int height; 
        
        SubtreeInfo(boolean isPerfect, int size, int height) {
            this.isPerfect = isPerfect;
            this.size = size;
            this.height = height;
        }
    }
}",1420558691
lamyhc,lamyhc,488,3588,java,"class Solution {
    static final int MOD = 1_000_000_007;
    static final int MAX_N = 1000;

    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n + 1][4][2 * n + 1]; 
        int offset = n;
        dp[0][0][offset] = 1; 
        Map<Character, Integer> moveMap = new HashMap<>();
        moveMap.put('F', 1);
        moveMap.put('W', 2);
        moveMap.put('E', 3);
        Set<String> bobWins = new HashSet<>();
        bobWins.add(""1_3""); 
        bobWins.add(""2_1""); 
        bobWins.add(""3_2""); 

        int[] aliceMoves = new int[n];
        for (int i = 0; i < n; i++) {
            aliceMoves[i] = moveMap.get(s.charAt(i));
        }

        for (int i = 0; i < n; i++) {
            for (int lastBobMove = 0; lastBobMove <= 3; lastBobMove++) {
                for (int diff = -n; diff <= n; diff++) {
                    int currentWays = dp[i][lastBobMove][diff + offset];
                    if (currentWays == 0) continue;

                    for (int newBobMove = 1; newBobMove <= 3; newBobMove++) {
                        if (newBobMove != lastBobMove) {
                            int bobPoints = 0;
                            int alicePoints = 0;
                            int bobMove = newBobMove;
                            int aliceMove = aliceMoves[i];
                            if (bobMove == aliceMove) {
                            } else if (bobWins.contains(bobMove + ""_"" + aliceMove)) {
                                bobPoints = 1;
                            } else if (bobWins.contains(aliceMove + ""_"" + bobMove)) {
                                alicePoints = 1;
                            } 
                            int newDiff = diff + (bobPoints - alicePoints);
                            if (newDiff < -n || newDiff > n) continue;
                            dp[i + 1][newBobMove][newDiff + offset] = (dp[i + 1][newBobMove][newDiff + offset] + currentWays) % MOD;
                        }
                    }
                }
            }
        }
        int totalWays = 0;
        for (int lastBobMove = 1; lastBobMove <= 3; lastBobMove++) {
            for (int diff = 1; diff <= n; diff++) {
                totalWays = (totalWays + dp[n][lastBobMove][diff + offset]) % MOD;
            }
        }

        return totalWays;
    }
}",1420557879
lamyhc,lamyhc,488,3610,java,"class Solution {
   public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] answer = new int[n - k + 1];
        
        Map<Integer, Integer> freqMap = new HashMap<>(); 
        
        for (int i = 0; i < k; i++) {
            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);
        }
        answer[0] = calculateXSum(freqMap, x);
        
        for (int i = 1; i <= n - k; i++) {
            int toRemove = nums[i - 1];
            freqMap.put(toRemove, freqMap.get(toRemove) - 1);
            if (freqMap.get(toRemove) == 0) {
                freqMap.remove(toRemove);
            }
            int toAdd = nums[i + k - 1];
            freqMap.put(toAdd, freqMap.getOrDefault(toAdd, 0) + 1);
            answer[i] = calculateXSum(freqMap, x);
        }
        
        return answer;
    }
    
    private int calculateXSum(Map<Integer, Integer> freqMap, int x) {
        PriorityQueue<int[]> pq = new PriorityQueue<>(
            (a, b) -> (a[1] == b[1]) ? b[0] - a[0] : b[1] - a[1]
        );
        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            pq.offer(new int[]{entry.getKey(), entry.getValue()});
        }
        int sum = 0;
        int count = 0;
        while (count < x && !pq.isEmpty()) {
            int[] element = pq.poll();
            sum += element[0] * element[1]; 
            count++;
        }
        
        return sum;
    }
}",1420559222
Vaibhav Jain,Vaibhav-Jain,489,3509,python3,"from typing import List, Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def is_perfect(node):
            if not node:
                return True, 0, -1
            left_is_perfect, left_size, left_height = is_perfect(node.left)
            right_is_perfect, right_size, right_height = is_perfect(node.right)
            if left_is_perfect and right_is_perfect and left_height == right_height:
                return True, left_size + right_size + 1, left_height + 1
            return False, left_size + right_size, max(left_height, right_height)
        
        sizes = []
        
        def traverse(node):
            if not node:
                return
            is_perf, size, height = is_perfect(node)
            if is_perf:
                sizes.append(size)
            traverse(node.left)
            traverse(node.right)
        
        traverse(root)
        sizes.sort(reverse=True)
        return sizes[k - 1] if k <= len(sizes) else -1",1420531584
Vaibhav Jain,Vaibhav-Jain,489,3588,python3,"MOD = 10**9 + 7

class Solution:
    def countWinningSequences(self, s: str) -> int:
        lufrenixaq = s
        n = len(s)
        dp = {}
        
        def count_sequences(i, last, score):
            if i == n:
                return 1 if score > 0 else 0

            if (i, last, score) in dp:
                return dp[(i, last, score)]

            total = 0
            for bob in ""FWE"":
                if bob == last:
                    continue
                new_score = score
                if (bob == 'F' and s[i] == 'E') or (bob == 'W' and s[i] == 'F') or (bob == 'E' and s[i] == 'W'):
                    new_score += 1
                elif (s[i] == 'F' and bob == 'E') or (s[i] == 'W' and bob == 'F') or (s[i] == 'E' and bob == 'W'):
                    new_score -= 1
                total += count_sequences(i + 1, bob, new_score)
                total %= MOD
            
            dp[(i, last, score)] = total
            return total
        
        return count_sequences(0, """", 0)",1420552854
Vaibhav Jain,Vaibhav-Jain,489,3610,python3,"from typing import List
from collections import Counter
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        for i in range(len(nums) - k + 1):
            subarray = nums[i:i + k]
            count = Counter(subarray)
            most_common = sorted(count.items(), key=lambda item: (-item[1], -item[0]))[:x]
            sum_top_x = sum(val * freq for val, freq in most_common)
            result.append(sum_top_x)
        return result
        ",1420524570
Ajay Singh Deopa,singh_deopa,490,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> dfs(TreeNode* curr, vector<int>& arr) {
        if (!curr) {
            return {1, 0, 0};
        }

        auto l = dfs(curr->left, arr);
        auto r = dfs(curr->right, arr);

        if (!l[0] || !r[0] || l[1] != r[1]) {
            return {0, -1};
        }

        int tot = 1 + l[2] + r[2];
        arr.push_back(tot);

        return {1, l[1] + 1, tot};
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> arr;

        dfs(root, arr);

        // for (int& i: arr) cout << i << "" "";

        if ((int) arr.size() < k) {
            return -1;
        }

        sort(arr.begin(), arr.end(), greater<int>());

        return arr[k - 1];
    }
};",1420529405
Ajay Singh Deopa,singh_deopa,490,3588,cpp,"class Solution {
    int mod = 1000000007;

    int get_id(char& ch) {
        return (ch == 'F') ? 0 : (ch == 'W') ? 1 : 2;
    }

    int get_point(char& a, char& b) {
        if (a == b) {
            return 0;
        }

        if (a == 'F') {
            return (b == 'E') ? 1 : -1;
        }

        if (a == 'W') {
            return (b == 'F') ? 1 : -1;
        }

        assert(a == 'E');

        return (b == 'W') ? 1 : -1;
    }

    int dfs(
        vector<vector<vector<int>>>& dp,
        string& s,
        int& n,
        int pos, int point, int prev
    ) {
        if (pos == n) {
            return (point > n) ? 1 : 0;
        }

        if (n - point >= n - pos) {
            return 0;
        }

        assert(prev < 3);
        assert(point >= 0);
        assert(point < (int) dp[pos].size());

        int& curr = dp[pos][point][prev];

        if (curr != -1) {
            return curr;
        }

        curr = 0;

        for (char ch: {'F', 'W', 'E'}) {
            int _id = get_id(ch);

            if (pos != 0 && _id == prev) {
                continue;
            }

            int _point = point + get_point(ch, s[pos]);
            int tmp = dfs(dp, s, n, pos + 1, _point, _id);
            curr = (curr + tmp) % mod;
        }

        return curr;
    }
public:
    int countWinningSequences(string s) {
        int n = (int) s.size();

        if (n == 1) {
            return 1;
        }

        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n + n + 2, vector<int>(3, -1)));

        return dfs(dp, s, n, 0, n, 0);
    }
};",1420559250
Ajay Singh Deopa,singh_deopa,490,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = (int) nums.size();
        vector<int> res;

        for (int i = 0; i <= n - k; i++) {
            unordered_map<int, int> mp;

            for (int j = i; j < i + k; j++) {
                mp[nums[j]]++;
            }

            int val = 0;

            if ((int) mp.size() <= x) {
                for (auto& it: mp) {
                    val += it.first * it.second;
                }
            }
            else {
                priority_queue<pair<int, int>> pq;

                for (auto& it: mp) {
                    pq.push({it.second, it.first});
                }

                for (int j = 0; j < x; j++) {
                    auto tp = pq.top();
                    pq.pop();
                    val += tp.first * tp.second;
                    // cout << i << "" "" << tp.first << "" "" << tp.second << endl;
                }
            }

            res.push_back(val);
        }

        return res;
    }
};",1420522864
thedude7181,thedude7181,491,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def helper(node):
            if not node:
                return 0
            left_depth = helper(node.left)
            right_depth = helper(node.right)
            if left_depth == right_depth and left_depth != -1:
                trees.append(right_depth * 2 + 1)
                return right_depth * 2 + 1
            return -1
        
        trees = []
        helper(root)
        trees.sort(reverse = True)
        if len(trees) <  k:
            return -1
        #print(trees)
        return trees[k - 1]",1420532796
thedude7181,thedude7181,491,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def helper(r, p, pm):
            if p <= 0 and len(s) - r <= abs(p):
                return 0
            if r == len(s):
                return 1 if p > 0 else 0
            am = s[r]
            res = 0
            if winning[am] != pm:
                res += helper(r + 1, p + 1, winning[am])
            if am != pm:
                res += helper(r + 1, p, am)
            if losing[am] != pm:
                res += helper(r + 1, p - 1, losing[am])
            return res % 1_000_000_007
            
            
        winning = {""F"":""W"", ""W"": ""E"", ""E"":""F""}
        losing = {""F"":""E"", ""W"":""F"", ""E"":""W""}
        res = helper(0, 0, """")
        helper.cache_clear()
        return res
            
            ",1420552882
thedude7181,thedude7181,491,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def helper(arr):
            cnts = Counter(arr)
            cnts = list(cnts.items())
            cnts.sort(reverse = True, key = lambda x: (x[1], x[0]))
            cnts = cnts[:x]
            return sum(x[0] * x[1] for x in cnts)
        
        return [helper(nums[i:i + k]) for i in range(len(nums) - k + 1)]
            
                     
            ",1420523050
Kevin Pan,Kevin_Pan,492,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    vector<int> sz;
public:

    int solve(TreeNode* root) {
        if (!root) return -1;
        if (!root->left && !root->right) {
            sz.push_back(1);
            return 1;
        }
        int retL = solve(root->left);
        int retR = solve(root->right);
        if(retL == -1 || retR == -1 || retL != retR) return -1;
        sz.push_back(retL + retR + 1);
        return retL + retR + 1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        solve(root);
        if (k > sz.size()) return -1;
        sort(sz.rbegin(), sz.rend());
        return sz[k - 1];
    }
};",1420532688
Kevin Pan,Kevin_Pan,492,3588,cpp,"class Solution {
    int N, MOD = 1e9 + 7;
    int dp[1001][2002][4];
    unordered_map<char, int> mp = {{'F', 0}, {'E', 1}, {'W', 2}};
    string S;
public:
    long long solve(int idx, int points, int last) {
        if (idx == N) return points > 0; 
        if (dp[idx][points + 1000][last] != -1) return dp[idx][points + 1000][last];
        long long sum = 0;
        for(int i = 0; i < 3; ++i) {
            if (i == last) continue;
            if (i == mp[S[idx]]) {
                sum += solve(idx + 1, points, i);
            }
            else if ((i + 1) % 3 == mp[S[idx]]) {
                sum += solve(idx + 1, points + 1, i);
            }
            else {
                sum += solve(idx + 1, points - 1, i);
            }
            sum %= MOD;
        }
        return dp[idx][points + 1000][last] = sum;
    }

    int countWinningSequences(string s) {
        N = s.size();
        S = s;
        memset(dp, -1, sizeof(dp));
        return solve(0, 0, 3);
    }
};",1420559333
Kevin Pan,Kevin_Pan,492,3610,python3,"class Solution:
    def solve(self, nums, xx):
        c = Counter(nums)
        a = []
        for x,y in c.items():
            a.append((y, x))
        a.sort(reverse=True)
        ret = 0
        if len(a) < xx:
            return sum(nums)
        for i in range(xx):
            ret += a[i][0] * a[i][1]
        return ret


    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        n = len(nums)
        for i in range(n - k + 1):
            ans.append(self.solve(nums[i:i + k], x))
        return ans
        ",1420525402
Sahil,sahil20000706,493,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> perfectSubtreeSizes;
        
        postOrderTraversal(root, perfectSubtreeSizes);
        
        if (k > perfectSubtreeSizes.size()) {
            return -1;
        }
        
        //reverse sort
        sort(perfectSubtreeSizes.rbegin(), perfectSubtreeSizes.rend());
        return perfectSubtreeSizes[k - 1];
    }

private:
    pair<int, bool> postOrderTraversal(TreeNode* root, vector<int>& perfectSubtreeSizes) {
        if (!root) {
            return {0, true};
        }

        auto [leftSize, isLeftPerfect] = postOrderTraversal(root->left, perfectSubtreeSizes);
        auto [rightSize, isRightPerfect] = postOrderTraversal(root->right, perfectSubtreeSizes);

        bool isPerfect = isLeftPerfect && isRightPerfect && (leftSize == rightSize);

        int subtreeSize = leftSize + rightSize + 1;

        if (isPerfect) {
            perfectSubtreeSizes.push_back(subtreeSize);
        }

        return {subtreeSize, isPerfect};
    }
};",1420535115
Sahil,sahil20000706,493,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9+7;
        int n = s.size();
        int offset = n;
        
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(3, vector<int>(2 * n + 1, 0)));
        
        auto getOutcome = [](char bobMove, char aliceMove) -> int {
            if ((bobMove == 'F' && aliceMove == 'E') || (bobMove == 'W' && aliceMove == 'F') || (bobMove == 'E' && aliceMove == 'W'))
                return 1; // Bob wins the round
            else if ((aliceMove == 'F' && bobMove == 'E') || (aliceMove == 'W' && bobMove == 'F') || (aliceMove == 'E' && bobMove == 'W'))
                return -1; // Alice wins the round
            return 0; // Draw
        };

        for (int firstMove = 0; firstMove < 3; ++firstMove) {
            int outcome = getOutcome(firstMove == 0 ? 'F' : firstMove == 1 ? 'W' : 'E', s[0]);
            dp[1][firstMove][offset + outcome] = 1;
        }


        for (int i = 1; i < n; ++i) {
            char aliceMove = s[i];
            for (int lastMove = 0; lastMove < 3; ++lastMove) {
                for (int scoreDiff = 0; scoreDiff <= 2 * n; ++scoreDiff) {
                    if (dp[i][lastMove][scoreDiff] == 0) continue;

                    for (int nextMove = 0; nextMove < 3; ++nextMove) {
                        if (nextMove == lastMove) continue;

                        int newDiff = scoreDiff + getOutcome(nextMove == 0 ? 'F' : nextMove == 1 ? 'W' : 'E', aliceMove);
                        if (newDiff >= 0 && newDiff <= 2 * n) {
                            dp[i + 1][nextMove][newDiff] = (dp[i + 1][nextMove][newDiff] + dp[i][lastMove][scoreDiff]) % MOD;
                        }
                    }
                }
            }
        }

        long long answer = 0;
        
        for (int lastMove = 0; lastMove < 3; ++lastMove) {
            for (int scoreDiff = offset + 1; scoreDiff <= 2 * n; ++scoreDiff) {
                answer = (answer + (long long) dp[n][lastMove][scoreDiff]) % MOD;
            }
        }

        return answer;
    }
};",1420553105
Sahil,sahil20000706,493,3610,cpp,"struct Compare {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.second == b.second) {
            return a.first < b.first;
        }
        return a.second < b.second;
    }
};

class Solution {
public:
    
    
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;
        unordered_map<int, int> freq;

        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }

        auto calculateXSum = [&](const unordered_map<int, int>& map) {
            priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> pq;
            
            for (const auto& entry : map) {
                pq.push(entry);
            }

            int sum = 0, count = 0;
            while (!pq.empty() && count < x) {
                auto top = pq.top();
                pq.pop();
                sum += top.first * top.second;
                ++count;
            }
            return sum;
        };

        answer.push_back(calculateXSum(freq));

        for (int i = k; i < n; ++i) {
            
            int elementOut = nums[i - k];
            if (--freq[elementOut] == 0) {
                freq.erase(elementOut);
            }

            freq[nums[i]]++;

            answer.push_back(calculateXSum(freq));
        }

        return answer;
        
    }
};",1420523996
Mashrabbek Akbarov,mashrabjon,494,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private class SubtreeInfo {
        int size;
        boolean isPerfect;

        SubtreeInfo(int size, boolean isPerfect) {
            this.size = size;
            this.isPerfect = isPerfect;
        }
    }

    // PriorityQueue to store the k largest perfect subtree sizes
    private PriorityQueue<Integer> pq;
    private int k;

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        this.k = k;
        this.pq = new PriorityQueue<>();
        
        // Traverse the tree and find perfect subtrees
        dfs(root);
        
        // If we have fewer than k perfect subtrees, return -1
        if (pq.size() < k) {
            return -1;
        }
        
        // Return the k-th largest size
        return pq.peek();
    }

    private SubtreeInfo dfs(TreeNode node) {
        if (node == null) {
            return new SubtreeInfo(0, true);
        }

        SubtreeInfo left = dfs(node.left);
        SubtreeInfo right = dfs(node.right);

        // Check if current subtree is perfect
        boolean isPerfect = left.isPerfect && right.isPerfect && left.size == right.size;
        int size = 1 + left.size + right.size;

        if (isPerfect) {
            // Add to priority queue if it's a perfect subtree
            pq.offer(size);
            if (pq.size() > k) {
                pq.poll();
            }
        }

        return new SubtreeInfo(size, isPerfect);
    }
}",1420550764
Mashrabbek Akbarov,mashrabjon,494,3588,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    private static final char[] creatures = {'F', 'W', 'E'};

    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n][3][2 * n + 1]; 
        
        for (int i = 0; i < 3; i++) {
            int points = getPoints(s.charAt(0), creatures[i]);
            if (points == 1) {
                dp[0][i][n + 1] = 1; 
            } else if (points == -1) {
                dp[0][i][n - 1] = 1; 
            } else {
                dp[0][i][n] = 1; 
            }
        }

        for (int round = 1; round < n; round++) {
            for (int prev = 0; prev < 3; prev++) {
                for (int delta = -n; delta <= n; delta++) {
                    int deltaIndex = delta + n;
                    if (dp[round - 1][prev][deltaIndex] == 0) continue;

                    for (int next = 0; next < 3; next++) {
                        if (prev == next) continue;

                        int points = getPoints(s.charAt(round), creatures[next]);
                        int newDelta = delta + points;
                        int newDeltaIndex = newDelta + n;

                        dp[round][next][newDeltaIndex] = (dp[round][next][newDeltaIndex] + dp[round - 1][prev][deltaIndex]) % MOD;
                    }
                }
            }
        }

        int total = 0;
        for (int last = 0; last < 3; last++) {
            for (int delta = 1; delta <= n; delta++) {
                int deltaIndex = delta + n;
                total = (total + dp[n - 1][last][deltaIndex]) % MOD;
            }
        }

        return total;
    }

    private int getPoints(char alice, char bob) {
        if (alice == 'F' && bob == 'W') return 1; 
        if (alice == 'W' && bob == 'E') return 1;
        if (alice == 'E' && bob == 'F') return 1; 
        if (alice == bob) return 0; 
        return -1; 
    }
}",1420559545
Mashrabbek Akbarov,mashrabjon,494,3610,java,"class Solution {
        public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Map<Integer, Integer> freqMap = new HashMap<>();

        for (int i = 0; i < k; i++) {
            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);
        }
        result[0] = calculateXSum(freqMap, x);

        for (int i = k; i < n; i++) {
            int outgoing = nums[i - k];
            freqMap.put(outgoing, freqMap.get(outgoing) - 1);
            if (freqMap.get(outgoing) == 0) {
                freqMap.remove(outgoing);
            }

            int incoming = nums[i];
            freqMap.put(incoming, freqMap.getOrDefault(incoming, 0) + 1);

            result[i - k + 1] = calculateXSum(freqMap, x);
        }

        return result;
    }

    private int calculateXSum(Map<Integer, Integer> freqMap, int x) {
        List<int[]> freqList = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            freqList.add(new int[]{entry.getKey(), entry.getValue()});
        }

        freqList.sort((a, b) -> b[1] == a[1] ? b[0] - a[0] : b[1] - a[1]);

        int sum = 0;
        int count = 0;
        for (int[] pair : freqList) {
            if (count >= x) break;
            sum += pair[0] * pair[1];
            count++;
        }

        return sum;
    }
}",1420523093
homeless_man,homeless_man,495,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    vector<int> res;
    
    int dfs(TreeNode* root){
        if(root -> left == NULL && root -> right == NULL){
            res.push_back(1);
            return 1;
        }
        int tot = 0;
        int l = root -> left ? dfs(root -> left) : -1;
        int r = root -> right ? dfs(root -> right) : -1;
        if(l == -1 || r == -1 || l != r)
            return -1;
        res.push_back(l + r + 1);
        return l + r + 1;
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(res.begin(),res.end(),greater<>());
        return k <= res.size() ? res[k-1] : -1;
    }
};",1420526554
homeless_man,homeless_man,495,3588,cpp,"
int dp[1000][4][2100];

class Solution {
public:
    
    //F : 1
    //W : 2
    //E : 3
    unordered_map<int,int> f;
    int os;
    int mod = 1e9 + 7;
    
    int calc(int a,int b){
        if(b == 2 && a == 1)
            return 1;
        if(b == 1 && a == 3)
            return 1;
        if(b == 3 && a == 2)
            return 1;
        
        if(a == 2 && b == 1)
            return -1;
        if(a == 1 && b == 3)
            return -1;
        if(a == 3 && b == 2)
            return -1;
        return 0;
    }
    
    int dfs(int idx,int last,int points,string& s){
        if(idx == s.size()){
            return points > os;
        }
        if(dp[idx][last][points] != -1)
            return dp[idx][last][points];
        int res = 0;
        int val = f[s[idx]];
        if(last != 1)
            res = (res + dfs(idx+1,1,points + calc(val,1),s))%mod;
        if(last != 2)
            res = (res + dfs(idx+1,2,points + calc(val,2),s))%mod;
        if(last != 3)
            res = (res + dfs(idx+1,3,points + calc(val,3),s))%mod;
        return dp[idx][last][points] = res;
    }
    
    int countWinningSequences(string s) {
        f['F'] = 1;
        f['W'] = 2;
        f['E'] = 3;
        os = s.size();
        for(int i = 0;i<s.size();i++){
            for(int j = 0;j<4;j++)
                for(int k = 0;k<=s.size()*2;k++){
                    dp[i][j][k] = -1;
                }
        }
        return dfs(0,0,s.size(),s);
    }
};",1420559744
homeless_man,homeless_man,495,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        int n = nums.size();
        for(int i = 0;i<=n-k;i++){
            unordered_map<int,int> f;
            for(int j = i;j<i+k;j++){
                f[nums[j]]++;
            }
            priority_queue<vector<int>> pq;
            for(auto [fa,sa] : f){
                pq.push({sa,fa});
            }
            int curr = 0;
            int xt = x;
            while(pq.size() && xt--){
                curr += pq.top()[0] * pq.top()[1];
                pq.pop();
            }
            res.push_back(curr);
        }
        return res;
    }
};",1420521045
Satyavrat Mishra,happify03,496,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    struct returnType {
    bool isPerfect;
    int height;
    TreeNode* rootTree;
};
vector<int>res;
returnType findPerfectBinaryTree(struct TreeNode* root)
{
 
    returnType rt;
    if (root == NULL) {
        rt.isPerfect = true;
        rt.height = 0;
        rt.rootTree = NULL;
        return rt;
    }
 
    returnType lv = findPerfectBinaryTree(root->left);
    returnType rv = findPerfectBinaryTree(root->right);

    if (lv.isPerfect && rv.isPerfect && lv.height == rv.height) {
        rt.height = lv.height + 1;
        rt.isPerfect = true;
        rt.rootTree = root;
        res.push_back(rt.height);
        return rt;
    }
    rt.isPerfect = false;
    rt.height = max(lv.height, rv.height);
    rt.rootTree = (lv.height > rv.height ? lv.rootTree : rv.rootTree);
    return rt;
}
 
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        findPerfectBinaryTree(root);
        if(res.size())sort(res.rbegin(),res.rend());
        if(res.size()<k)return -1;
        
        return pow(2, res[k-1]) - 1; 
    }
};",1420533558
Satyavrat Mishra,happify03,496,3588,cpp,"class Solution {
public:
    const int mod=1000000007;
    int dp[1001][2001][4];
    map<char,char>need;
    map<char,int>id;
    int rec(int ind,int score,int prev,string &s)
    {
        if(ind==s.size())return score>(s.size());
        if(dp[ind][score][prev]!=-1)return dp[ind][score][prev];
        
        
        int ans=0;
        char ch=need[s[ind]];
        if(id[ch]!=prev){
            // he wins ;
            int cur=rec(ind+1,score+1,id[ch],s)%mod;
            ans+=cur;
            ans%=mod;
        }
        if(id[s[ind]]!=prev){
            //he draws;
            int cur=rec(ind+1,score,id[s[ind]],s)%mod;
            ans+=cur;
            ans%=mod;
        }
        char ch2;
        if(s[ind]=='F')ch2='E';
        else if(s[ind]=='W')ch2='F';
        else ch2='W';
        
        if(id[ch2]!=prev){
            // he loses
            int cur=rec(ind+1,score-1,id[ch2],s)%mod;
            ans+=cur;
            ans%=mod;
        }
        return dp[ind][score][prev]=ans;
    }
    int countWinningSequences(string s) {
        need['F']='W';id['F']=0;
        need['W']='E';id['W']=1;
        need['E']='F';id['E']=2;
        memset(dp,-1,sizeof(dp));
        return rec(0,s.size(),3,s);
    }
};",1420553401
Satyavrat Mishra,happify03,496,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& a, int k, int x) {
        int n=a.size();
        vector<int>res(n-k+1);
        for(int fst=0;fst<=n-k;fst++){
            map<int,int>mp;
            for(int i=fst;i<fst+k;i++)mp[a[i]]++;
            vector<pair<int,int>>v;
            for(auto [p,q]:mp)v.push_back({q,p});
            if(v.size())sort(v.rbegin(),v.rend());
            
            int sum=0;
            for(int i=0;i<min(x,(int)v.size());i++){
                sum+=v[i].second*v[i].first;
            }
            res[fst]=sum;
        }
        return res;
    }
};",1420524348
Ramayanapu Narasimha Rao,Narasimha8423,497,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfect_sizes = []

        def helper(node):
            if not node:
                return (0, True)  # (height, is_perfect)
            
            # Post-order traversal: compute for left and right subtrees first
            left_height, is_left_perfect = helper(node.left)
            right_height, is_right_perfect = helper(node.right)
            
            # Check if current node forms a perfect subtree
            if is_left_perfect and is_right_perfect and left_height == right_height:
                # It is perfect, size is (2^(height+1) - 1)
                size = (1 << (left_height + 1)) - 1  # 2^(height + 1) - 1
                perfect_sizes.append(size)
                return (left_height + 1, True)
            else:
                # Not a perfect subtree
                return (max(left_height, right_height), False)

        helper(root)
        
        # Sort sizes in descending order
        perfect_sizes.sort(reverse=True)
        
        # Return k-th largest size, or -1 if not enough perfect subtrees
        return perfect_sizes[k - 1] if len(perfect_sizes) >= k else -1


",1420529059
Ramayanapu Narasimha Rao,Narasimha8423,497,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n=len(s)
        dp={}
        mod=(10**9)+7
        mp={'F':0,""W"":1,""E"":2}
        def dfs(i,prev,a,b):
            if i==n:
                if b>a:
                    return 1
                return 0
            if (i,prev,b-a) in dp:
                return dp[(i,prev,b-a) ]
            ans=0
            for c in ""FWE"":
                if mp[c]!=prev:
                    if c=='F' and s[i]=='E':
                        ans=(ans+dfs(i+1,mp[c],a,b+1))%mod
                    elif c=='W' and s[i]=='F':
                        ans=(ans+dfs(i+1,mp[c],a,b+1))%mod
                    elif c=='E' and s[i]=='W':
                        ans=(ans+dfs(i+1,mp[c],a,b+1))%mod
                    elif c==s[i]:
                        ans=(ans+dfs(i+1,mp[c],a,b))%mod
                    else:
                        ans=(ans+dfs(i+1,mp[c],a+1,b))%mod
            dp[(i,prev,b-a)]=ans
            return ans
        return dfs(0,-1,0,0)",1420553506
Ramayanapu Narasimha Rao,Narasimha8423,497,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans=[]
        n=len(nums)
        mp=[0]*51
        for i in range(k):
            mp[nums[i]]+=1
        a=[]
        for i in range(51):
            a.append([mp[i],i])
        a.sort(reverse=True)
        t=0
        for i in range(x):
            t=t+a[i][1]*a[i][0]
        ans.append(t)
        for i in range(k,n):
            mp[nums[i-k]]-=1
            mp[nums[i]]+=1
            a=[]
            for i in range(51):
                a.append([mp[i],i])
            a.sort(reverse=True)
            t=0
            for i in range(x):
                t=t+a[i][1]*a[i][0]
            ans.append(t)
        return ans

        
",1420521989
ritik6g,ritik6g,498,3509,php,"/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     public $val = null;
 *     public $left = null;
 *     public $right = null;
 *     function __construct($val = 0, $left = null, $right = null) {
 *         $this->val = $val;
 *         $this->left = $left;
 *         $this->right = $right;
 *     }
 * }
 */
class Solution {

    /**
     * @param TreeNode $root
     * @param Integer $k
     * @return Integer
     */
    function checkkar($root, &$sz) {
        if (!$root) return [0, 0];

//  if ($lm[0] == $rm[0] && $lm[0] != -1) {
//             $th = $lm[0] + 1;
//             $ts = $lm[1] + $rm[1] + 1;
//             $sz[] = $ts;
//             return [$th, $ts];
//         }

        
        $lm = $this->checkkar($root->left, $sz);
        $rm = $this->checkkar($root->right, $sz);
        
        if ($lm[0] == $rm[0] && $lm[0] != -1) {
            $th = $lm[0] + 1;
            $ts = $lm[1] + $rm[1] + 1;
            $sz[] = $ts;
            return [$th, $ts];
        }
        
        return [-1, 0];
    }

        // rsort($sz);
        
        // if (count($sz) < $k) return -1;
        
        // return $sz[$k - 1];


    function kthLargestPerfectSubtree($root, $k) {
        $sz = [];
        $this->checkkar($root, $sz);
        
        rsort($sz);
        
        if (count($sz) < $k) return -1;
        
        return $sz[$k - 1];
    }
}
",1420552114
ritik6g,ritik6g,498,3588,php,"class Solution {

    /**
     * @param String $s
     * @return Integer
     */
    function countWinningSequences($s) {
        $n = strlen($s);
        $lf = $s;

        // for ($i = 0; $i < $n; ++$i) {
        //     $dp_current = array_fill(0, 4 * $sz, 0);
        //     $A = $s[$i];
        $MOD = 1e9 + 7;
        $sz = 2 * $n + 1;
        $dp_prev = array_fill(0, 4 * $sz, 0);

            // $dp_current = array_fill(0, 4 * $sz, 0);
            // $A = $s[$i];      

        $dp_prev[3 * $sz + $n] = 1;
        
        for ($i = 0; $i < $n; ++$i) {
            $dp_current = array_fill(0, 4 * $sz, 0);
            $A = $s[$i];


        // for ($i = 0; $i < $n; ++$i) {
        //     $dp_current = array_fill(0, 4 * $sz, 0);
        //     $A = $s[$i]

            
            for ($lp = 0; $lp < 4; ++$lp) {
                for ($dp = 0; $dp < $sz; ++$dp) {
                    $val = $dp_prev[$lp * $sz + $dp];
                    if ($val == 0) continue;
                    
                    for ($b = 0; $b < 3; ++$b) {
                        $B = $b == 0 ? 'F' : ($b == 1 ? 'W' : 'E');


                        // $B_beats_A = ($B == 'F' && $A == 'E') || ($B == 'W' && $A == 'F') || ($B == 'E' && $A == 'W');
                        // $A_beats_B = ($A == 'F' && $B == 'E') || ($A == 'W' && $B == 'F') || ($A == 'E' && $B == 'W');    
                        if ($lp < 3) {
                            $last_char = $lp == 0 ? 'F' : ($lp == 1 ? 'W' : 'E');
                            if ($B == $last_char) continue;
                        }
                        
// for ($diff = $n + 1; $diff <= 2 * $n; ++$diff)
                        $B_beats_A = ($B == 'F' && $A == 'E') || ($B == 'W' && $A == 'F') || ($B == 'E' && $A == 'W');
                        $A_beats_B = ($A == 'F' && $B == 'E') || ($A == 'W' && $B == 'F') || ($A == 'E' && $B == 'W');
                        
                        $actual_diff = $dp - $n;
                        $new_diff = $actual_diff;
                        if ($B_beats_A) {
                            $new_diff += 1;
                        } elseif ($A_beats_B) {
                            $new_diff -= 1;
                        }
                        
                        if ($new_diff < -$n || $new_diff > $n) {
                            continue;
                        }
                        
                        $mapped_diff = $new_diff + $n;
                        
                        $dp_current[$b * $sz + $mapped_diff] = ($dp_current[$b * $sz + $mapped_diff] + $val) % $MOD;
                    }
                }
            }


//    if ($B_beats_A) {
//                             $new_diff += 1;
//                         } elseif ($A_beats_B) {
//                             $new_diff -= 1;
//                         }
                        
//                         if ($new_diff < -$n || $new_diff > $n) {
//                             continue;
//                         } 
            $dp_prev = $dp_current;
        }
        $res = 0;
        for ($last = 0; $last < 4; ++$last) {
            for ($diff = $n + 1; $diff <= 2 * $n; ++$diff) {
// for ($diff = $n + 1; $diff <= 2 * $n; ++$diff)
                $res = ($res + $dp_prev[$last * $sz + $diff]) % $MOD;
            }
        }

// for ($diff = $n + 1; $diff <= 2 * $n; ++$diff) {
//                 $res = ($res + $dp_prev[$last * $sz + $diff]) % $MOD;
//             }


        
        return (int)$res;
    }
}
",1420560192
ritik6g,ritik6g,498,3610,php,"class Solution {

    /**
     * @param Integer[] $nums
     * @param Integer $k
     * @param Integer $x
     * @return Integer[]
     */
    function findXSum($nums, $k, $x) {
        $rs = [];
        $n = count($nums);
        
        for ($i = 0; $i <= $n - $k; ++$i) {
            $fm = [];
            
            for ($j = $i; $j < $i + $k; ++$j) {
                if (isset($fm[$nums[$j]])) {
                    $fm[$nums[$j]]++;
                } else {
                    $fm[$nums[$j]] = 1;
                }
            }


            // for ($j = $i; $j < $i + $k; ++$j) {
            //     if (isset($fm[$nums[$j]])) {
            //         $fm[$nums[$j]]++;
            //     } else {
            //         $fm[$nums[$j]] = 1;
            //     }
            // }




            
            $fl = [];
            foreach ($fm as $num => $freq) {
                $fl[] = [$num, $freq];
            }
            
            usort($fl, function($a, $b) {
                if ($a[1] == $b[1]) {
                    return $b[0] - $a[0];
                }
                return $b[1] - $a[1];
            });
            
            $sum = 0;
            $cnt = 0;
            foreach ($fl as $pair) {
                if ($cnt >= $x) break;
                $sum += $pair[0] * $pair[1];
                $cnt++;
            }
            
            $rs[] = $sum;
        }



            // $sum = 0;
            // $cnt = 0;
            // foreach ($fl as $pair) {
            //     if ($cnt >= $x) break;
            //     $sum += $pair[0] * $pair[1];
            //     $cnt++;
            // }
        return $rs;
    }
}
",1420548581
Ankit Anand,ankitanand2125,499,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Node {
public:  
    bool isPerf;
    int height;
    int size;
};

class Solution {
public:    
    vector<int> res;
    Node postOrder(TreeNode* node) {
        if (node == nullptr) {
            return {false, 0, 0};
        }
        
        // 1
        if (node->left == nullptr && node->right == nullptr) {
            res.push_back(1);
            return {true, 1, 1};
        }
        
        if (node->left == nullptr || node->right == nullptr) {
            if (node->left) {
                postOrder(node->left);
            }
            if (node->right) {
                postOrder(node->right);
            }
            return {false, 0, 0};
        }
        
        Node left = postOrder(node->left);
        Node right = postOrder(node->right);
        
        if (left.isPerf && right.isPerf && left.height == right.height) {
            int h = left.height + 1;
            int tot = left.size + right.size + 1;
            res.push_back(tot);
            return {true, h, tot};
        }
        
        return {false, 0, 0};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        postOrder(root);
        
        if(res.size() == 0 || k > res.size()) return -1;
        sort(res.rbegin(), res.rend());
        
        return res[k - 1];
    }
};
",1420560253
Ankit Anand,ankitanand2125,499,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7, n = s.size(), N = 3;
        
        auto toInt = [](char c) -> int {
            return c == 'F' ? 0 : (c == 'W' ? 1 : 2);
        };

        int pB[N][N] = {
            {0, 1, 0}, 
            {0, 0, 1}, 
            {1, 0, 0}  
        };
        int pA[N][N] = {
            {0, 0, 1}, 
            {1, 0, 0}, 
            {0, 1, 0} 
        };

        vector<vector<long long>> prev(N + 1, vector<long long>(2 * n + 1, 0));
        prev[N][n] = 1;

        for (int i = 0; i < n; ++i) {
            vector<vector<long long>> curr(N + 1, vector<long long>(2 * n + 1, 0));
            int A = toInt(s[i]);

            for (int lm = 0; lm < N + 1; ++lm) {
                for (int dShift = 0; dShift <= 2 * n; ++dShift) {
                    if (prev[lm][dShift] == 0) continue;
                    for (int cm = 0; cm < N; ++cm) {
                        if (lm != N && cm == lm) continue;
                        int pb = pB[A][cm], pa = pA[A][cm];
                        long long d = dShift - n;
                        long long newD = d + pb - pa;
                        long long shift = newD + n;
                        if (shift < 0 || shift > 2 * n) continue;
                        curr[cm][shift] += prev[lm][dShift];
                        if (curr[cm][shift] >= MOD)
                            curr[cm][shift] -= MOD;
                    }
                }
            }

            prev = move(curr);
        }

        long long res = 0;
        for (int lm = 0; lm < N; ++lm) {
            for (int dShift = n + 1; dShift <= 2 * n; ++dShift) {
                res += prev[lm][dShift];
                if (res >= MOD) res -= MOD;
            }
        }

        return (int)res;
    }
};
",1420542096
Ankit Anand,ankitanand2125,499,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        const int n = nums.size();
        
        vector<int> res;
        for(int i = 0; i < n - k + 1; ++i) {
            priority_queue<pair<int, int>> pq;
            map<int, int> freq;
            for(int j = i; j < i + k; ++j) {
                freq[nums[j]]++;
            }
            
            for(auto it: freq) {
                pq.push({it.second, it.first});
            }
            
            int j = 0, sum = 0;
            while(j < x && pq.size()) {
                sum += (pq.top().first * pq.top().second);
                j++;
                pq.pop();
            }
            
            res.push_back(sum);
        }
        
        return res;
    }
};",1420529393
Pranav,ypranav,501,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        s=[]
        def f(n):
            if not n:
                return 0, 0, True
            ls, lh, lp = f(n.left)
            rs, rh, rp = f(n.right)
            if lp and rp and lh==rh:
                sz = ls + rs + 1
                s.append(sz)
                return sz, lh+1, True
            return 0, max(lh,rh)+1, False
        f(root)
        s.sort(reverse=True)
        return s[k-1] if k<=len(s) else -1",1420524298
Pranav,ypranav,501,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        m = {'F':0,'W':1,'E':2}
        a = [m[c] for c in s]
        dp = [[[0] * (2*n+1) for _ in range(4)] for _ in range(n+1)]
        dp[0][3][n] = 1 
        for i in range(n):
            for p in range(4):
                for d in range(2*n+1):
                    c=dp[i][p][d]
                    if c:
                        for b in range(3):
                            if b != p:
                                sd = (b-a[i]) % 3
                                if sd == 1:
                                    nd = d+1
                                elif sd == 2:
                                    nd = d-1
                                else:
                                    nd = d
                                dp[i+1][b][nd] += c

        mod = 10**9+7
        res = 0
        for p in range(3):
            for d in range(n+1, 2*n+1):
                res = (res + dp[n][p][d]) % mod
        return res",1420560648
Pranav,ypranav,501,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        r = []
        for i in range(n - k + 1):
            s = nums[i:i+k]
            c = {}
            for j in s:
                c[j] = c.get(j, 0) + 1
            t = sorted(c.items(), key=lambda y: (-y[1], -y[0]))
            m = min(x, len(t))
            r.append(sum(v * c[v] for v, _ in t[:m]))
        return r",1420518807
LucasLyu,Lucas595,502,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def dfs(node: Optional[TreeNode]) -> int:
            left = dfs(node.left) if node.left else 0
            right = dfs(node.right) if node.right else 0
            if left != right:
                return -1
            size = 2 * left + 1
            sizes.append(size)
            return size
        
        dfs(root)
        sizes.sort(reverse=True)
        if len(sizes) < k:
            return -1
        return sizes[k - 1]


        ",1420538123
LucasLyu,Lucas595,502,3588,python3,"MOD = 10**9 + 7


class Solution:
    def get_points_awarded(self, bob_move: str, alice_move: str) -> int:
        if bob_move == alice_move:
            return 0
        elif (bob_move == 'F' and alice_move == 'E') or \
            (bob_move == 'W' and alice_move == 'F') or \
            (bob_move == 'E' and alice_move == 'W'):
            return 1 
        else:
            return -1

    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        s = list(s)
        creatures = ['F', 'W', 'E']
        prev_moves = ['F', 'W', 'E', 'None']
        DP = [ [ {pm:0 for pm in prev_moves} for _ in range(2*n+1) ] for _ in range(n+1) ]
        offset = n
        DP[0][offset]['None'] = 1
    
        for i in range(n):
            for d in range(-n, n+1):
                for prev_move in prev_moves:
                    curr_dp = DP[i][d + offset][prev_move]
                    if curr_dp == 0:
                        continue
                    for curr_move in creatures:
                        if prev_move == 'None' or curr_move != prev_move:
                            points_awarded = self.get_points_awarded(curr_move, s[i])
                            d_new = d + points_awarded
                            DP[i+1][d_new + offset][curr_move] = (DP[i+1][d_new + offset][curr_move] + curr_dp) % MOD
    
        answer = 0
        for d in range(1, n+1):
            for prev_move in creatures:
                answer = (answer + DP[n][d + offset][prev_move]) % MOD
    
        return answer
        ",1420547922
LucasLyu,Lucas595,502,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        counter = {}
        for i in range(k):
            counter[nums[i]] = counter.get(nums[i], 0) + 1
        ans = []
        cnt_list = sorted((-cnt, -i) for i, cnt in counter.items())
        total = 0
        for i in range(min(x, len(cnt_list))):
            total += cnt_list[i][0] * cnt_list[i][1]
        ans.append(total)
        for j in range(len(nums) - k):
            counter[nums[j]] -= 1
            counter[nums[j + k]] = counter.get(nums[j + k], 0) + 1
            cnt_list = sorted((-cnt, -i) for i, cnt in counter.items())
            total = 0
            for i in range(min(x, len(cnt_list))):
                total += cnt_list[i][0] * cnt_list[i][1]
            ans.append(total)
        return ans

            

            

        ",1420526552
Ronil Patil,ronilpatil22,503,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    int solve(TreeNode* root, vector<int> &sizes){
        if(root==NULL){
            return 0;
        }
        if(root->left==NULL && root->right==NULL){
            sizes.push_back(1);
            return 1;
        }
        int left=solve(root->left, sizes);
        int right=solve(root->right,sizes);
        if(left!=right || left==-1 || right==-1){
            return -1;
        }
        sizes.push_back(left+right+1);
        return left+right+1;
    }
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        solve(root,sizes);
        sort(sizes.rbegin(),sizes.rend());
        for(auto &x:sizes)cout<<x<<"" "";
        if(sizes.size()<k){
            return -1;
        }
        return sizes[k-1];
    }
};",1420539094
Ronil Patil,ronilpatil22,503,3588,cpp,"const int mod=1e9+7;
class Solution {
    unordered_map<char,int> p;
    vector<vector<vector<int>>> dp;
    int solve(string &s, int index, int prevCreature,int points){
        if(index<0){
            if(points>0){
                return 1;
            }
            return 0;
        }
        if(dp[index][prevCreature][points+1000]!=(-1)){
            return dp[index][prevCreature][points+1000];
        }
        int sum=0;
        for(int creature=0;creature<=2;creature++){
            if(creature!=prevCreature){
                if(creature==(p[s[index]]+1)%3){
                    sum=(sum+solve(s,index-1,creature,points+1))%mod;
                }
                else if(creature==p[s[index]]){
                    sum=(sum+solve(s,index-1,creature,points))%mod;
                }
                else{
                    sum=(sum+solve(s,index-1,creature,points-1))%mod;
                }
            }
        }
        return dp[index][prevCreature][points+1000] = sum;
    }
public:
    int countWinningSequences(string s) {
        int n=s.size();
        p['F']=0;
        p['W']=1;
        p['E']=2;
        dp.resize(n,vector<vector<int>>(4,vector<int>(2001,-1)));
        return solve(s,n-1,3,0);
    }
};",1420560714
Ronil Patil,ronilpatil22,503,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<int,int> mp;
        int i=0;
        while(i<k-1){
            mp[nums[i]]++;
            i++;
        }
        vector<int> ans;
        while(i<nums.size()){
            mp[nums[i]]++;
            vector<vector<int>> v;
            for(auto &x:mp){
                v.push_back({x.second,x.first});
            }
            sort(v.begin(),v.end(),[](vector<int> a,vector<int> b){
                if(a[0]==b[0]){
                    return a[1]>b[1];
                }
                return a[0]>b[0];
            });
            int count=0;
            int sum=0;
            while(count!=x && count<v.size()){
                sum+=v[count][0]*v[count][1];
                count++;
            }
            ans.push_back(sum);
            mp[nums[i-k+1]]--;
            i++;
        }
        return ans;
    }
};",1420529474
Alex,zk299,504,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        
        def helper(root):
            if not root: return (0, True, 0)
            
            left_height, left_perfect, left_total = helper(root.left)
            right_height, right_perfect, right_total = helper(root.right)
            
            if left_perfect and right_perfect and left_height == right_height:
                res.append(left_total + right_total + 1)
                return left_height + 1, True, left_total + right_total + 1
            
            return 1 + max(left_height, right_height), False, left_total + right_total + 1
        
        helper(root)
        
        res.sort(reverse=True)
        # print(res)
        if len(res) < k: return -1
        return res[k-1]
        ",1420537671
Alex,zk299,504,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7
        n = len(s)
        creatures = ['F', 'W', 'E']
        dp = [{} for _ in range(n+1)]
        dp[0][None] = {0: 1}  # dp[i][prev_c][score_diff]: count
        offset = n  # To handle negative score differences
        
        for i in range(n):
            curr_s = s[i]
            for prev_c in dp[i]:
                for score_diff in dp[i][prev_c]:
                    count = dp[i][prev_c][score_diff]
                    for curr_c in creatures:
                        if curr_c != prev_c:
                            # Compute score change
                            if self.beats(curr_c, curr_s):
                                delta = 1
                            elif self.beats(curr_s, curr_c):
                                delta = -1
                            else:
                                delta = 0
                            new_score_diff = score_diff + delta
                            if abs(new_score_diff) <= n:
                                if curr_c not in dp[i+1]:
                                    dp[i+1][curr_c] = {}
                                if new_score_diff not in dp[i+1][curr_c]:
                                    dp[i+1][curr_c][new_score_diff] = 0
                                dp[i+1][curr_c][new_score_diff] = (dp[i+1][curr_c][new_score_diff] + count) % MOD

        total = 0
        for prev_c in dp[n]:
            for score_diff in dp[n][prev_c]:
                if score_diff > 0:
                    total = (total + dp[n][prev_c][score_diff]) % MOD
        return total
        

    def beats(self, a, b):
        return (a == 'F' and b == 'E') or (a == 'W' and b == 'F') or (a == 'E' and b == 'W')




        ",1420560851
Alex,zk299,504,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        count_map = defaultdict(int)
        
        for i in range(k-1):
            count_map[nums[i]] += 1
            
        n = len(nums)
        res = []
        for i in range(k-1, n):
            count_map[nums[i]] += 1
            arr = [(ke,va) for ke, va in count_map.items()]
            arr.sort(key=lambda x: (-x[1], -x[0]))
            # print(arr)
            cur = 0
            for j in range(min(x, len(arr))):
                cur += arr[j][0] * arr[j][1]
            res.append(cur)
            
            count_map[nums[i-k+1]] -= 1
            if count_map[nums[i-k+1]] == 0:
                del count_map[nums[i-k+1]]
                
        return res
            
        ",1420527651
Mark,myselfshivams,505,3509,python3,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def kthLargestPerfectSubtree(self, root: TreeNode, k: int) -> int:
        a = []
        
        def dfs(n):
            if not n:
                return (True, 0, 0)
            
            l_p, l_h, l_s = dfs(n.left)
            r_p, r_h, r_s = dfs(n.right)
            
            if l_p and r_p and l_h == r_h:
                h = l_h + 1
                s = l_s + r_s + 1
                a.append(s)
                return (True, h, s)
            else:
                return (False, max(l_h, r_h), 0)
        
        dfs(root)
        
        a.sort(reverse=True)
        
        if len(a) >= k:
            return a[k - 1]
        else:
            return -1
",1420552922
Mark,myselfshivams,505,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        sequence_str = s
        MOD = int(1e9 + 7)
        size = 2 * n + 1
        dp_previous = [0] * (4 * size)
        dp_previous[3 * size + n] = 1

        i = 0
        while i < n:
            dp_current_iteration = [0] * (4 * size)
            A_move = sequence_str[i]

            last_move = 0
            while last_move < 4:
                prev_diff = 0
                while prev_diff < size:
                    value = dp_previous[last_move * size + prev_diff]
                    if value == 0:
                        prev_diff += 1
                        continue

                    b = 0
                    while b < 3:
                        if b == 0:
                            B_move = 'F'
                        elif b == 1:
                            B_move = 'W'
                        else:
                            B_move = 'E'

                        if last_move < 3:
                            if last_move == 0:
                                last_char = 'F'
                            elif last_move == 1:
                                last_char = 'W'
                            else:
                                last_char = 'E'
                            if B_move == last_char:
                                b += 1
                                continue

                        B_wins = False
                        A_wins = False
                        if (B_move == 'F' and A_move == 'E') or \
                           (B_move == 'W' and A_move == 'F') or \
                           (B_move == 'E' and A_move == 'W'):
                            B_wins = True
                        elif (A_move == 'F' and B_move == 'E') or \
                             (A_move == 'W' and B_move == 'F') or \
                             (A_move == 'E' and B_move == 'W'):
                            A_wins = True

                        actual_difference = prev_diff - n
                        new_difference = actual_difference
                        if B_wins:
                            new_difference += 1
                        elif A_wins:
                            new_difference -= 1

                        if new_difference < -n or new_difference > n:
                            b += 1
                            continue

                        mapped_difference = new_difference + n
                        dp_current_iteration[b * size + mapped_difference] = (dp_current_iteration[b * size + mapped_difference] + value) % MOD
                        
                        b += 1
                    
                    prev_diff += 1

                last_move += 1

            dp_previous = dp_current_iteration
            i += 1

        result = 0
        last = 0
        while last < 4:
            diff = n + 1
            while diff < 2 * n + 1:
                result = (result + dp_previous[last * size + diff]) % MOD
                diff += 1
            last += 1

        return result
",1420549606
Mark,myselfshivams,505,3610,python3,"class Element:
    def __init__(self, value: int, frequency: int):
        self.V = value
        self.F = frequency 

class FrequencyList:
    def __init__(self, elements: List[Element]):
        self.elements_list = elements

    def __len__(self):
        return len(self.elements_list)

    def __getitem__(self, index):
        return self.elements_list[index]

    def __setitem__(self, index, value):
        self.elements_list[index] = value

    def __iter__(self):
        return iter(self.elements_list)

    def sort(self):
        self.elements_list.sort(key=lambda elem: (-elem.F, -elem.V))

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        total_length = len(nums)
        if k > total_length:
            return []

        result_sum_list = []

        start_index = 0 
        while start_index <= total_length - k:
            current_subarray = nums[start_index:start_index + k]
            frequency_map = Counter(current_subarray)

            freq_elements = [Element(value, frequency) for value, frequency in frequency_map.items()]
            sorted_freq_list = FrequencyList(freq_elements)
            sorted_freq_list.sort()

            selected_values = {sorted_freq_list[j].V for j in range(min(x, len(sorted_freq_list)))}

            subarray_sum = sum(value for value in current_subarray if value in selected_values)

            result_sum_list.append(subarray_sum)

            start_index += 1 

        return result_sum_list
",1420560912
Shuqi Shang,sshang,506,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        res = []
        
        def dfs(node):
            if not node:
                return True, 0
            
            l_p, l_size = dfs(node.left)
            r_p, r_size = dfs(node.right)
            
            size = max(l_size, r_size) + 1
            is_p = False
            if l_p and r_p and l_size == r_size:
                is_p = True
                
            if is_p:
                bisect.insort(res, size)
                
            return is_p, size
        
        dfs(root)
        return 2 ** res[-k] - 1 if len(res) >= k else -1",1420532733
Shuqi Shang,sshang,506,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        mod = 10 ** 9 + 7
        n = len(s)
        
        graph = {'f': {}, 'w': {}, 'e': {}}
        
        graph['f']['f'] = 0
        graph['f']['e'] = 1
        graph['f']['w'] = -1
        
        graph['w']['w'] = 0
        graph['w']['f'] = 1
        graph['w']['e'] = -1
        
        graph['e']['e'] = 0
        graph['e']['w'] = 1
        graph['e']['f'] = -1
        
        @lru_cache(None)
        def dp(i, diff, last):
            
            # print(i, diff, last)
            
            if i == n:
                if diff > 0:
                    return 1
                else:
                    return 0
                
            res = 0
            for cur in ['f', 'w', 'e']:
                if cur != last:
                    res += dp(i + 1, diff + graph[cur][s[i].lower()], cur)
                    
            return res % mod
        
        return dp(0, 0, 'a')",1420554701
Shuqi Shang,sshang,506,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        n = len(nums)
        
        d = defaultdict(int)
        total = 0
        for i in range(k):
            num = nums[i]
            if d[num] == 0:
                total += 1
            d[num] += 1
            
        res = []
        if total < x:
            res.append(sum(nums[:k]))
        else:
            cur = 0
            ans = 0
            for num, cnt in sorted(d.items(), key = lambda x: (x[1], x[0]), reverse = True):
                cur += 1
                ans += num * cnt
                
                if cur == x:
                    res.append(ans)
                    break
            
        for i in range(k, n):
            num = nums[i-k]
            d[num] -= 1
            if d[num] == 0:
                total -= 1
                
            num = nums[i]
            if d[num] == 0:
                total += 1
            d[num] += 1
            
            if total < x:
                res.append(sum(nums[i-k+1: i+1]))
            else:
                cur = 0
                ans = 0
                for num, cnt in sorted(d.items(), key = lambda x: (x[1], x[0]), reverse = True):
                    cur += 1
                    ans += num * cnt

                    if cur == x:
                        res.append(ans)
                        break
        return res",1420523896
Vignesh R,vigneshravikumar30,508,3509,python3,"class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        data=[]
        def dfs(root):
            if not root:return 0
            l=dfs(root.left)
            r=dfs(root.right)
            if l==r:
                data.append(l+r+1)
            else:
                return float('inf')
            return l+r+1
        dfs(root)
        data=sorted([x for x in data if x!=float('inf')],reverse=True)
        if k>len(data):return -1
        return data[k-1]",1420536600
Vignesh R,vigneshravikumar30,508,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD=10**9+7
        ways={
            'F':{'F':0,'E':1,'W':-1},
            'E':{'F':-1,'E':0,'W':1},
            'W':{'F':1,'E':-1,'W':0},
        }
        @cache
        def dp(i,last,score):
            if i==len(s):return score>0
            res=0
            for c in ('F',""E"",""W""):
                if c != last:
                    res+=dp(i+1,c,score+ways[c][s[i]])
            return res%MOD
        return dp(0,-2,0)",1420554813
Vignesh R,vigneshravikumar30,508,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res=[]
        for i in range(k,len(nums)+1):
            c=Counter(nums[i-k:i])
            sm=0
            for key,v in sorted(c.items(),key=lambda xa:(-xa[1],-xa[0]))[:x]:
                sm+=key*v
            res.append(sm)
        return res",1420521274
MYS,KidPooh,509,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        _ = self.traverse(root, sizes)
        if len(sizes) < k:
            return -1
        sizes.sort()
        return sizes[-k]
        
    def traverse(self, root: Optional[TreeNode], sizes: List[int]) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            sizes.append(1)
            return 1
        left_value = self.traverse(root.left, sizes)
        right_value = self.traverse(root.right, sizes)
        if left_value == -1 or right_value == -1:
            return -1
        if left_value == right_value:
            sizes.append(left_value + right_value + 1)
            return left_value + right_value + 1
        return -1",1420533785
MYS,KidPooh,509,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        # 0 = 'F', 1 = 'W', 2 = 'E'
        # F > E, W > F, E > W
        # stuff[index][0/1/2] = {score_diff: num_of_sequences}
        stuff = [[defaultdict(int) for _ in range(3)] for _ in range(len(s))]
        if s[0] == 'F':
            stuff[0][0][0] = 1
            stuff[0][1][1] = 1
            stuff[0][2][-1] = 1
        elif s[0] == 'W':
            stuff[0][0][-1] = 1
            stuff[0][1][0] = 1
            stuff[0][2][1] = 1
        elif s[0] == 'E':
            stuff[0][0][1] = 1
            stuff[0][1][-1] = 1
            stuff[0][2][0] = 1
        for i in range(1, len(s)):
            if s[i] == 'F':
                # Use 'F' - no change
                for last_score in stuff[i - 1][1]:
                    stuff[i][0][last_score] += stuff[i - 1][1][last_score]
                for last_score in stuff[i - 1][2]:
                    stuff[i][0][last_score] += stuff[i - 1][2][last_score]
                # Use 'W' - add 1
                for last_score in stuff[i - 1][0]:
                    stuff[i][1][last_score + 1] += stuff[i - 1][0][last_score]
                for last_score in stuff[i - 1][2]:
                    stuff[i][1][last_score + 1] += stuff[i - 1][2][last_score]
                # Use 'E' - subtract 1
                for last_score in stuff[i - 1][0]:
                    stuff[i][2][last_score - 1] += stuff[i - 1][0][last_score]
                for last_score in stuff[i - 1][1]:
                    stuff[i][2][last_score - 1] += stuff[i - 1][1][last_score]
            elif s[i] == 'W':
                # Use 'F' - subtract 1
                for last_score in stuff[i - 1][1]:
                    stuff[i][0][last_score - 1] += stuff[i - 1][1][last_score]
                for last_score in stuff[i - 1][2]:
                    stuff[i][0][last_score - 1] += stuff[i - 1][2][last_score]
                # Use 'W' - no change
                for last_score in stuff[i - 1][0]:
                    stuff[i][1][last_score] += stuff[i - 1][0][last_score]
                for last_score in stuff[i - 1][2]:
                    stuff[i][1][last_score] += stuff[i - 1][2][last_score]
                # Use 'E' - add 1
                for last_score in stuff[i - 1][0]:
                    stuff[i][2][last_score + 1] += stuff[i - 1][0][last_score]
                for last_score in stuff[i - 1][1]:
                    stuff[i][2][last_score + 1] += stuff[i - 1][1][last_score]
            elif s[i] == 'E':
                # Use 'F' - add 1
                for last_score in stuff[i - 1][1]:
                    stuff[i][0][last_score + 1] += stuff[i - 1][1][last_score]
                for last_score in stuff[i - 1][2]:
                    stuff[i][0][last_score + 1] += stuff[i - 1][2][last_score]
                # Use 'W' - subtract 1
                for last_score in stuff[i - 1][0]:
                    stuff[i][1][last_score - 1] += stuff[i - 1][0][last_score]
                for last_score in stuff[i - 1][2]:
                    stuff[i][1][last_score - 1] += stuff[i - 1][2][last_score]
                # Use 'E' - no change
                for last_score in stuff[i - 1][0]:
                    stuff[i][2][last_score] += stuff[i - 1][0][last_score]
                for last_score in stuff[i - 1][1]:
                    stuff[i][2][last_score] += stuff[i - 1][1][last_score]
        result = 0
        for choice in range(3):
            for score in stuff[-1][choice]:
                if score > 0:
                    result += stuff[-1][choice][score]
        result = result % 1000000007
        return result",1420561158
MYS,KidPooh,509,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        answer = []
        for start in range(len(nums) - k + 1):
            counter = dict(Counter(nums[start:start + k]))
            if len(counter) < x:
                answer.append(sum(nums[start:start + k]))
                continue
            counts_to_nums = defaultdict(list)
            for number in counter:
                counts_to_nums[counter[number]].append(number)
            current_answer = 0
            counts = list(sorted(counts_to_nums.keys()))
            remaining = x
            for current_count in counts[::-1]:
                if not remaining:
                    break
                if len(counts_to_nums[current_count]) <= remaining:
                    remaining -= len(counts_to_nums[current_count])
                    current_answer += current_count * sum(counts_to_nums[current_count])
                    continue
                counts_to_nums[current_count].sort()
                current_answer += sum(counts_to_nums[current_count][-remaining:]) * current_count
                remaining = 0
            answer.append(current_answer)
        return answer",1420526523
Sanath_Kulla,Sanath_Kulla,510,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
vector<int> v;
class Solution {
public:
     
    pair<int,int> recur(TreeNode * root){
       if(!root)return {0,1};
       int ls = 0 , lb = 0;
       int rs = 0 , rb = 0;
        
            auto x = recur(root->left);
            ls = x.first;
            lb = x.second;
        
       
            x = recur(root->right);
            rs = x.first;
            rb = x.second;
        
            // cout<<root->val<<"" ""<<ls<<"" ""<<rs<<"" ""<<lb<<"" ""<<rb<<endl;
        
        if(lb and rb and ls == rs){
            // cout<<root->val<<"" ""<<ls<<"" ""<<rs<<endl;
            v.push_back(ls+rs+1);
        // cout<<root->val<<"" ""<<ls+rs+1<<endl;
            
            return {ls + rs + 1 , 1};
        }
        // cout<<root->val<<"" ""<<ls+rs+1<<endl;
        return {0 , 0};
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
          v.clear();
        recur(root);
            // cout<<endl;
        sort(v.begin() , v.end());
        reverse(v.begin() , v.end());
        // for(auto it:v)cout<<it<<"" "";
        // cout<<endl;
        while(v.size() > k)v.pop_back();
        if(v.size() < k)return -1;
        return v.back();
    }
};",1420544866
Sanath_Kulla,Sanath_Kulla,510,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        using ll = long long;
        const ll mod=  1e9+7;
        ll n = s.size();
        vector<int> v(n);
        for(int i=0 ; i < n ;i++){
            if(s[i] == 'F')v[i] = 0;
            if(s[i] == 'W')v[i] = 1;
            if(s[i] == 'E')v[i] = 2;
        }
        vector<vector<vector<ll>>> dp(n+1,vector<vector<ll>> (4 , vector<ll> (3*n , -1)));
        
        auto dfs = [&](auto self , ll ind , ll last , ll score)->ll{
             if(ind >= n){
                 if(score > 0)return 1ll;
                 return 0ll;
             }
            ll ans = 0;
            if(dp[ind][last][score+n] != -1)return dp[ind][last][score+n];
             
             for(int i = 0 ; i < 3 ; i++){
                 if(last == i)continue;
                 ll nscore = score;
                 if(i == 0 and v[ind] == 2)score++;
                 if(i == 0 and v[ind] == 1)score--;
                 if(i == 1 and v[ind] == 0)score++;
                 if(i == 1 and v[ind] == 2)score--;
                 if(i == 2 and v[ind] == 1)score++;
                 if(i == 2 and v[ind] == 0)score--;
                 ans += self(self , ind+1 , i , score);
                 ans %= mod;
                 score = nscore;
             }
             return dp[ind][last][score+n] = ans;
        };
        // return 0;
        return dfs(dfs , 0 , 3 , 0);
    }
};",1420561243
Sanath_Kulla,Sanath_Kulla,510,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int n = nums.size();
        for(int i = 0 ; i  < n ;i++){
            map<int,int> mp;
            if(i+k-1 >= n)break;
            for(int j = i ; j <= i + k - 1 ; j++){
                 mp[nums[j]]++;
            }
            vector<pair<int,int>> vp;
            for(auto [a,b]:mp){
                vp.push_back({-b , -a});
            }
            sort(vp.begin() , vp.end());
            int c = 0;
            int sum = 0;
            for(auto [a,b]:vp){
                c++;
                if(c > x)break;
                sum += a*b;
            }
            ans.push_back(sum);
            
        }
        return ans;
    }
};",1420521906
Rakesh Kumar,iitp_rakesh,511,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    pair<int, bool> isPerfect(TreeNode* root) {
        if (!root)
            return {0, true};

        auto left = isPerfect(root->left);
        auto right = isPerfect(root->right);
        if (left.second && right.second && left.first == right.first) {
            return {left.first + 1,
                    true}; 
        }
        return {max(left.first, right.first),
                false}; 
    }

    void findPerfectSubtreeSizes(TreeNode* root, vector<int>& sizes) {
        if (!root)
            return;

        auto [height, is_perfect] = isPerfect(root);
        if (is_perfect) {
            int size = pow(2, height) -1; 
            sizes.push_back(size);
        }

        findPerfectSubtreeSizes(root->left, sizes);
        findPerfectSubtreeSizes(root->right, sizes);
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        findPerfectSubtreeSizes(root, sizes);

        if (sizes.size() < k)
            return -1; 
        sort(sizes.begin(), sizes.end(),
             greater<int>()); 
        return sizes[k - 1];
    }
};",1420529489
Rakesh Kumar,iitp_rakesh,511,3588,cpp,"class Solution {
public:
    bool chk(char c, int k) {
        // if()
        if (c == 'F') {
            if (k == 1)
                return false;
            return true;
        }
        if (c == 'E') {
            if (k == 0) {
                return true;
            }
            return false;
        }
        if (c == 'W') {
            if (k == 0)
                return false;
        }
        return true;
    }
    int mod = 1e9 + 7;
    vector<vector<vector<int>>> dp;
    int solve(string& s, int i, int prev, unordered_map<char, int>& mp,
              int win) {
        int n = s.length();
        if (i == s.length()) {
            if (win > (2 * n - win))
                return 1;
            return 0;
        }
        if (dp[i][prev][win] != -1)
            return dp[i][prev][win];
        int ans = 0;
        for (int k = 0; k < 3; k++) {
            if (prev != k) {
                if (k == mp[s[i]]) {
                    ans += solve(s, i + 1, k, mp, win + 1);
                } else if (chk(s[i], k)) {
                    ans += solve(s, i + 1, k, mp, win + 2);
                }
                else {
                    ans += solve(s, i + 1, k, mp, win);
                }
                ans %= mod;
            }
        }
        return dp[i][prev][win] = ans;
    }
    int countWinningSequences(string s) {
        unordered_map<char, int> mp;
        mp['F'] = 0;
        mp['E'] = 1;
        mp['W'] = 2;
        int n = s.length();
        dp.resize(n, vector<vector<int>>(4, vector<int>(2 * n + 5, -1)));
        return solve(s, 0, 3, mp, 0);
    }
};",1420555079
Rakesh Kumar,iitp_rakesh,511,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int n = nums.size(), left = 0;

        if (k == x) {
            int curr = 0;
            for (int i = 0; i < n; i++) {
                curr += nums[i];
                if (i >= k - 1) {
                    ans.push_back(curr);
                    curr -= nums[left];
                    left++;
                }
            }
        } else {
            unordered_map<int, int> mp;
            for (int i = 0; i < n; i++) {
                mp[nums[i]]++;
                if (i >= k - 1) {
                    // Build a priority queue to find the sum of top x distinct
                    // elements
                    priority_queue<pair<int, int>> pq;
                    for (auto& it : mp) {
                        pq.push({it.second, it.first});
                    }

                    int l = 0, prev = -1, sum = 0;
                    while (l < x && !pq.empty()) {
                        auto [freq, num] = pq.top();
                        pq.pop();

                        sum += num * freq;
                        l++;
                        prev = freq;
                    }

                    ans.push_back(sum);

                    // Sliding window: remove the element at 'left'
                    mp[nums[left]]--;
                    if (mp[nums[left]] == 0) {
                        mp.erase(nums[left]);
                    }
                    left++;
                }
            }
        }
        return ans;
    }
};
",1420525814
Shubham Varshney,shubhamvarshney2000,512,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sizes;  

    int solve(TreeNode* root) {  
        if (!root) return 0;  

        int leftSize = solve(root->left);  
        int rightSize = solve(root->right);  
        
        if (leftSize == rightSize && leftSize != 0) {  
            int size = (1 << (leftSize + 1)) - 1;  
            sizes.push_back(size);  
            return leftSize + 1;  
        } else if (!root->left && !root->right) {  
            sizes.push_back(1);  
            return 1;  
        }  

        return 0;  
    }  
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        solve(root);  
        sort(sizes.rbegin(), sizes.rend());  

        return k <= sizes.size() ? sizes[k - 1] : -1;
    }
};",1420520960
Shubham Varshney,shubhamvarshney2000,512,3588,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int countWinningSequences(String s) {
        int n = s.length();
        int sh = 1000;

        int[][] cur = new int[3][2001];
        int[][] prev = new int[3][2001];

        for (char bMove : new char[]{'F', 'W', 'E'}) {
            int bIdx = (bMove == 'F' ? 0 : (bMove == 'W' ? 1 : 2));
            int pDiff = 0;

            if (s.charAt(0) == 'F' && bMove == 'W') pDiff = 1;
            else if (s.charAt(0) == 'F' && bMove == 'E') pDiff = -1;
            else if (s.charAt(0) == 'W' && bMove == 'E') pDiff = 1;
            else if (s.charAt(0) == 'W' && bMove == 'F') pDiff = -1;
            else if (s.charAt(0) == 'E' && bMove == 'F') pDiff = 1;
            else if (s.charAt(0) == 'E' && bMove == 'W') pDiff = -1;

            cur[bIdx][pDiff + sh] = 1;
        }

        for (int i = 1; i < n; ++i) {
            prev = cur;
            cur = new int[3][2001];

            char aMove = s.charAt(i);

            for (int bIdx = 0; bIdx < 3; ++bIdx) {
                char bMove = (bIdx == 0 ? 'F' : (bIdx == 1 ? 'W' : 'E'));

                for (int pDiff = -1000; pDiff <= 1000; ++pDiff) {
                    if (prev[bIdx][pDiff + sh] == 0) continue;

                    for (int nBIdx = 0; nBIdx < 3; ++nBIdx) {
                        if (nBIdx == bIdx) continue;

                        char nBMove = (nBIdx == 0 ? 'F' : (nBIdx == 1 ? 'W' : 'E'));
                        int newDiff = pDiff;

                        if ((aMove == 'F' && nBMove == 'W') ||
                            (aMove == 'W' && nBMove == 'E') ||
                            (aMove == 'E' && nBMove == 'F')) {
                            newDiff++;
                        } else if ((aMove == 'F' && nBMove == 'E') ||
                                   (aMove == 'W' && nBMove == 'F') ||
                                   (aMove == 'E' && nBMove == 'W')) {
                            newDiff--;
                        }

                        cur[nBIdx][newDiff + sh] = (cur[nBIdx][newDiff + sh] + prev[bIdx][pDiff + sh]) % MOD;
                    }
                }
            }
        }

        int res = 0;
        for (int bIdx = 0; bIdx < 3; ++bIdx) {
            for (int pDiff = 1; pDiff <= 1000; ++pDiff) {
                res = (res + cur[bIdx][pDiff + sh]) % MOD;
            }
        }

        return res;
    }
}
",1420555083
Shubham Varshney,shubhamvarshney2000,512,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();  
    vector<int> answer(n - k + 1);  
    
    for (int i = 0; i <= n - k; ++i) {  
        unordered_map<int, int> freqMap;  
        
        for (int j = 0; j < k; ++j) {  
            freqMap[nums[i + j]]++;  
        }  
        
        priority_queue<pair<int, int>> pq;  
        
        for (auto& entry : freqMap) {  
            pq.push({entry.second, entry.first});  
        }  
        
        int sum = 0;  
        int count = 0;  

        while (!pq.empty() && count < x) {  
            auto top = pq.top();  
            pq.pop();  
            sum += top.second * top.first;  
            count++;  
        }  
        
        answer[i] = sum;  
    }  
    
    return answer;
    }
};",1420518527
ntc,ntcqwq,513,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        def dfs(node):
            if node is None: return (0, 0, 1)
            lh, ls, lp = dfs(node.left)
            rh, rs, rp = dfs(node.right)
            if lp and rp and lh == rh: ans.append((1<<(lh+1))-1)
            return ((lh+1), (1<<(lh+1))-1, 1)  if lp and rp and lh == rh else (max(lh,rh)+1, ls+rs+1, 0)
        dfs(root)
        ans.sort(reverse=True)
        return -1 if k > len(ans) else ans[k-1]
",1420537297
ntc,ntcqwq,513,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        N = len(s)
        s = s.replace('F','0').replace('W','1').replace('E','2')
        cmp = lambda a, b: 1 if ((a == '0' and b == '2') or (a == '1' and b == '0') or (a == '2' and b == '1')) else (-1 if a != b else 0)
        dp = [[[0]*(2*N+1) for _ in range(4)] for _ in range(2)]
        pre, cur = 0, 1
        dp[0][3][N] = 1
        for i in range(N):
            dp[cur] = [[0]*(2*N+1) for _ in range(4)]
            for l in range(4):
                for d in range(2*N+1):
                    if dp[pre][l][d] != 0:
                        for c in range(3):
                            r = d+(0 if int(s[i]) == c else (1 if cmp(str(c), s[i]) == 1 else -1))
                            if c != l and 0 <= r <= 2*N:
                                dp[cur][c][r] = (dp[cur][c][r]+dp[pre][l][d])%(10**9+7)
            pre, cur = cur, pre
        return sum(dp[pre][l][d] for l in range(3) for d in range(N+1, 2*N+1))%(10**9+7)",1420561365
ntc,ntcqwq,513,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        N = len(nums)
        ans = []
        for i in range(N-k+1):
            freq = defaultdict(int)
            for n in nums[i:i+k]:
                freq[n] += 1
            c = sorted(freq.items(), key=lambda x: (x[1], x[0]), reverse=True)
            xsum = 0
            for e, f in c[:x]:
                xsum += e*f
            ans.append(xsum)
        return ans",1420525417
Karan Bantia Ram,karanbantia,515,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> temp;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        f(root);
        sort(temp.begin(), temp.end(), greater<>());
        if (k > temp.size())
            return -1;
        return temp[k - 1];
    }

    int f(TreeNode *root) {
        if (root == NULL)
            return -1;
        if (root->left == NULL && root->right == NULL) {
            temp.push_back(1);
            return 1;
        }
        int left = f(root->left);
        int right = f(root->right);
        if (left == -1 || right == -1)
            return -1;
        if (left != right)
            return -1;
        temp.push_back(left + right + 1);
        return left + right + 1;
    }
};",1420531188
Karan Bantia Ram,karanbantia,515,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size();
        vector<vector<vector<int>>> dp(n, vector<vector<int> >(2 * n + 1, vector<int>(4, -1)));
        return f(0, 0, 3, s, dp);
    }

    long long f(int ind, int points, int prev, string &s, vector<vector<vector<int>>> &dp) {
        int n = s.size();
        if (ind >= n) {
            if (points > 0)
                return 1;
            return 0;
        }
        if (dp[ind][points + n][prev] != -1)
            return dp[ind][points + n][prev];
        long long ans = 0;
        if (prev != 0) {
            if (s[ind] == 'F') {
                ans = (ans + f(ind + 1, points, 0, s, dp)) % 1000000007;
            }
            else if (s[ind] == 'W') {
                ans = (ans + f(ind + 1, points - 1, 0, s, dp)) % 1000000007;
            } else if (s[ind] == 'E') {
                ans = (ans + f(ind + 1, points + 1, 0, s, dp)) % 1000000007;
            }
        }

        if (prev != 1) {
            if (s[ind] == 'F') {
                ans = (ans + f(ind + 1, points + 1, 1, s, dp)) % 1000000007;
            }
            else if (s[ind] == 'W') {
                ans = (ans + f(ind + 1, points, 1, s, dp)) % 1000000007;
            } else if (s[ind] == 'E') {
                ans = (ans + f(ind + 1, points - 1, 1, s, dp)) % 1000000007;
            }
        }

        if (prev != 2) {
            if (s[ind] == 'F') {
                ans = (ans + f(ind + 1, points - 1, 2, s, dp)) % 1000000007;
            }
            else if (s[ind] == 'W') {
                ans = (ans + f(ind + 1, points + 1, 2, s, dp)) % 1000000007;
            } else if (s[ind] == 'E') {
                ans = (ans + f(ind + 1, points, 2, s, dp)) % 1000000007;
            }
        }

        return dp[ind][points + n][prev] = ans;
        
    }
};",1420561438
Karan Bantia Ram,karanbantia,515,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans1;
        for (int i = 0; i < n - k + 1; i++) {
            map<int, int> mp;
            for (int j = i; j <= i + k - 1; j++) {
                mp[nums[j]]++;
            }

            vector<pair<int, int>> v;
            for (auto it : mp) {
                v.push_back({it.second, it.first});
            }

            sort(v.begin(), v.end());
            int count = 0;
            int ans = 0;
            for (int j = v.size() - 1; j >= 0; j--) {
                ans += (v[j].second * v[j].first);
                count++;
                if (count == x)
                    break;
              }

              ans1.push_back(ans);
        }

        return ans1;
    }
};",1420523016
laobaaoligei,laobaaoligei,517,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        self.sizes = []

        def helper(root):
            if not root:
                return 0
            
            left_res = helper(root.left)
            right_res = helper(root.right)

            if left_res == right_res:
                self.sizes.append(left_res + right_res + 1)
                return left_res + right_res + 1
            
            self.sizes.append(-1)
            return -1
        
        helper(root)
        self.sizes.sort(reverse=True)
        if k > len(self.sizes):
            return -1
        return self.sizes[k - 1]",1420532377
laobaaoligei,laobaaoligei,517,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        point_char = defaultdict(dict)
        point_char['F']['E'] = 1
        point_char['E']['F'] = -1
        point_char['W']['F'] = 1
        point_char['F']['W'] = -1
        point_char['E']['W'] = 1
        point_char['W']['E'] = -1
        point_char['F']['F'] = 0
        point_char['E']['E'] = 0
        point_char['W']['W'] = 0

        @cache
        def helper(i, points, last=''):
            if i == len(s):
                if points > 0:
                    return 1
                return 0
            
            res = 0
            for char in ['W', 'F', 'E']:
                if char == last:
                    continue
                res += helper(i + 1, points + point_char[char][s[i]], char)

            return res
        
        return helper(0, 0) % (10 ** 9 + 7)


            ",1420555391
laobaaoligei,laobaaoligei,517,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        cntr = Counter(nums[:k])
        output = []
        freq_cntr = defaultdict(int)
        arr = sorted(cntr.items(), key=lambda x: (-x[1], -x[0]))
        total = 0
        for key, val in arr[:x]:
            total += cntr[key] * key
            
        output.append(total)
        
        for i in range(len(nums) - k):
            cntr[nums[i]] -= 1
            if cntr[nums[i]] == 0:
                cntr.pop(nums[i])
            if nums[i + k] not in cntr:
                cntr[nums[i + k]] = 0
            cntr[nums[i + k]] += 1
            
            arr = sorted(cntr.items(), key=lambda x: (-x[1], -x[0]))
            total = 0
            for key, val in arr[:x]:
                total += cntr[key] * key
            print(arr)
            output.append(total)

            
        return output",1420545648
perry,perry304,518,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def visit(node):
            if node is None:
                return 0
            left = visit(node.left)
            right = visit(node.right)
            if left is None or right is None or left != right:
                return None
            l.append(2 ** (left + 1) - 1)
            return left + 1
        
        l = []
        visit(root)
        l = sorted(l, key=lambda x: -x)
        if k > len(l):
            return -1
        return l[k - 1]",1420531240
perry,perry304,518,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        def point(a, b):
            if (a+1) % 3 == b:
                return 1
            elif (b+1) % 3 == a:
                return -1
            else:
                return 0

        n = len(s)
        m = {'F': 0, 'W': 1, 'E': 2}
        s = [m[c] for c in s]
        f = {0: [1, 1, 1]}
        for i in range(n):
            fn = {}
            for pt in f:
                for j in range(3):
                    for k in range(3):
                        if j == k:
                            continue
                        ptn = pt + point(s[i], k)
                        if ptn not in fn:
                            fn[ptn] = [0, 0, 0]
                        fn[ptn][k] += f[pt][j]
            if i == 0:
                for key in fn:
                    for j in range(3):
                        fn[key][j] //= 2
            f = fn
            # print(f)
        ans = 0
        MOD = 10 ** 9 + 7
        for key in f:
            if key <= 0:
                continue
            ans = (ans + sum(f[key])) % MOD
        return ans
",1420561732
perry,perry304,518,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        for i in range(n):
            if i + k > n:
                break
            l = nums[i:i+k]
            counter = Counter(l)
            cnt = [(key, counter[key]) for key in counter]
            cnt = sorted(cnt, key=lambda x: -x[0])
            cnt = sorted(cnt, key=lambda x: -x[1])
            top = min(x, len(cnt))
            s = 0
            for j in range(top):
                s += cnt[j][1] * cnt[j][0]
            ans.append(s)
        return ans

",1420537971
WangHansheng_1976,xlyy,519,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> treesize;
    pair<int, int> search(TreeNode* node) {
        //first depth, second num
        if (!node) return {0, 0};
        auto left = search(node->left);
        auto right = search(node->right);
        if (left.first == right.first && left.first != -1) {
            treesize.push_back(left.second + right.second + 1);
            return {left.first + 1, treesize.back()};
        }
        else
            return {-1, -1};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        search(root);
        sort(treesize.begin(), treesize.end(), std::greater<int>());
        if (k > treesize.size()) return -1;
        return treesize[k - 1];
    }
};",1420548079
WangHansheng_1976,xlyy,519,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = 10**9 + 7

        idx = {'F': 0, 'W': 1, 'E': 2, -1: 3}
        moves = ['F', 'W', 'E']
        dp = [ [ [0] * (2 * n + 1) for _ in range(4) ] for _ in range(n+1) ]
        dp[0][3][n] = 1

        for i in range(n):
            a_move = s[i]
            a_idx = idx[a_move]
            for b_prev_idx in range(4):
                for diff in range(0, 2 * n +1):
                    ways = dp[i][b_prev_idx][diff]
                    if ways == 0:
                        continue
                    for b_idx in range(3):
                        if b_prev_idx != b_idx or b_prev_idx == 3:
                            d = 0
                            if b_idx == a_idx:
                                d = 0
                            elif (b_idx - a_idx) % 3 == 1:
                                d = 1
                            elif (b_idx - a_idx) % 3 == 2:
                                d = -1

                            new_diff = diff + d
                            if 0 <= new_diff <= 2 * n:
                                dp[i+1][b_idx][new_diff] = (
                                    dp[i+1][b_idx][new_diff] + ways
                                    ) % mod

        res = 0
        for b_prev_idx in range(3):
            for diff in range(n+1, 2 * n +1):
                res = (res + dp[n][b_prev_idx][diff]) % mod

        return res",1420555572
WangHansheng_1976,xlyy,519,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = []
        
        for i in range(n - k +1):
            subarray = nums[i:i+k]
            freq = defaultdict(int)
            for num in subarray:
                freq[num] +=1
            freq_list = list(freq.items())
            freq_list.sort(key=lambda item: (-item[1], -item[0]))
            
            top_x = set()
            for j in range(min(x, len(freq_list))):
                top_x.add(freq_list[j][0])
            
            cur_sum = 0
            for num in subarray:
                if num in top_x:
                    cur_sum += num
            ans.append(cur_sum)
        
        return ans",1420536910
Avnish1972,Avnish1972,520,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    class SubtreeInfo {
        boolean isPerfect;
        int height;
        int size;
        
        SubtreeInfo(boolean isPerfect, int height, int size) {
            this.isPerfect = isPerfect;
            this.height = height;
            this.size = size;
        }
    }

    List<Integer> perfectSubtreeSizes = new ArrayList<>();
    
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        postOrderTraversal(root);
        Collections.sort(perfectSubtreeSizes, Collections.reverseOrder());
        return perfectSubtreeSizes.size() >= k ? perfectSubtreeSizes.get(k - 1) : -1;
    }
    
    private SubtreeInfo postOrderTraversal(TreeNode node) {
        if (node == null) {
            return new SubtreeInfo(true, 0, 0);
        }
        
        SubtreeInfo leftInfo = postOrderTraversal(node.left);
        SubtreeInfo rightInfo = postOrderTraversal(node.right);
        
        if (leftInfo.isPerfect && rightInfo.isPerfect && leftInfo.height == rightInfo.height) {
            int size = leftInfo.size + rightInfo.size + 1;
            int height = leftInfo.height + 1;
            perfectSubtreeSizes.add(size);
            return new SubtreeInfo(true, height, size);
        }
        
        return new SubtreeInfo(false, Math.max(leftInfo.height, rightInfo.height), 0);
    }
}
",1420550090
Avnish1972,Avnish1972,520,3588,java,"class Solution {
    private static final int MOD = 1000000007;
    private String s;
    
    private int solve(int i, int points_diff, int last_move, int[][][] dp) {
        if (i == s.length()) {
            return points_diff > 0 ? 1 : 0;
        }
        
        if (dp[i][points_diff + 1000][last_move] != -1) {
            return dp[i][points_diff + 1000][last_move];
        }
        
        int ans = 0;
        
        char aliceMove = s.charAt(i);
        
        for (int bobMove = 0; bobMove < 3; bobMove++) {
            if (bobMove == last_move) {
                continue;
            }
            
            int new_points_diff = points_diff;
            if (aliceMove == 'F' && bobMove == 1) {
                new_points_diff++;
            } else if (aliceMove == 'F' && bobMove == 2) {
                new_points_diff--;
            } else if (aliceMove == 'W' && bobMove == 2) {
                new_points_diff++;
            } else if (aliceMove == 'W' && bobMove == 0) {
                new_points_diff--;
            } else if (aliceMove == 'E' && bobMove == 0) {
                new_points_diff++;
            } else if (aliceMove == 'E' && bobMove == 1) {
                new_points_diff--;
            }
            
            ans = (ans + solve(i + 1, new_points_diff, bobMove, dp)) % MOD;
        }
        
        return dp[i][points_diff + 1000][last_move] = ans;
    }
    
    public int countWinningSequences(String s) {
        this.s = s;
        int n = s.length();
        
        int[][][] dp = new int[n + 1][2001][4];
        for (int[][] dpLayer1 : dp) {
            for (int[] dpLayer2 : dpLayer1) {
                Arrays.fill(dpLayer2, -1);
            }
        }
        
        return solve(0, 0, 3, dp);
    }
}
",1420561912
Avnish1972,Avnish1972,520,3610,java,"class Solution {
    public int calculateSum(HashMap<Integer, Integer> map, int x, int k) {
        ArrayList<Integer> ls = new ArrayList<>();
        for(int it : map.keySet()) ls.add(it);

        Collections.sort(ls, (a, b)->{
            if(map.get(a) == map.get(b)) return b - a;
            return map.get(b) - map.get(a);
        });

        // System.out.println(map);

        int sum = 0;

        for(int i = 0; i < Math.min(x, ls.size()); i++) {
            sum += ls.get(i) * map.get(ls.get(i));
        }

        return sum;
    }
    public int[] findXSum(int[] nums, int k, int x) {
        HashMap<Integer, Integer> map = new HashMap<>();
        int n = nums.length, j = 0, idx = 0; 

        int[] ans = new int[n - k + 1];

        for(int i = 0; i < n; i++) {
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
            if(i >= k - 1) {
                ans[j] = calculateSum(map, x, k);
                map.put(nums[j], map.getOrDefault(nums[j], 0) - 1);
                if(map.get(nums[j]) == 0) map.remove(nums[j]);
                j++;
            }
        }

        return ans;
    }
}",1420538719
Sakthi Narayanan R,sakthii25,522,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    pair<int,int> rec(TreeNode* root){
        if(!root) return {0,1};

        pair<int,int> lft = rec(root->left),rgt = rec(root->right);

        if(lft.first == rgt.first and lft.second and rgt.second){
            res.push_back(lft.first+rgt.first+1);
            return {lft.first+rgt.first+1,1};
        }
        return {lft.first+rgt.first+1,0};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k){
        rec(root);
        sort(res.rbegin(),res.rend());
        if(k <= res.size()) return res[k-1];
        return -1;
    }
};",1420543248
Sakthi Narayanan R,sakthii25,522,3588,cpp,"class Solution {
public:
    string t;
    #define ll long long
    ll dp[1001][2001][3];
    ll mod = 1e9 + 7;
    ll rec(int x,int p,int s){
        if(!t[x]){
            return (s > 1000);
        }
        if(p != -1 and dp[x][s][p] != -1) return dp[x][s][p];
        ll j = t[x]-'0',ways = 0;
        for(int i=0;i<3;++i) if(i != p){
            if(i-j == 1 or i-j == -2){
                ways += rec(x+1,i,s+1);
            }
            else if(i-j == 0){
                ways += rec(x+1,i,s);
            }
            else ways += rec(x+1,i,s-1);
        }
        if(p != -1) dp[x][s][p] = ways;
        return ways%mod;
    }
    int countWinningSequences(string s){
        memset(dp,-1,sizeof(dp));
        for(auto i:s){
            if(i == 'F') t += '0';
            else if(i == 'W') t += '1';
            else t += '2';
        }
        return rec(0,-1,1000);
    }
};",1420562085
Sakthi Narayanan R,sakthii25,522,3610,cpp,"class Solution {
public:
    vector<int> v;
    
    int fun(int i,int j,int x){
        map<int,int> mp;
        for(int k=i;k<=j;++k){
            mp[v[k]]++;
        }
        if(mp.size() <= x){
            int res = 0;
            for(int k=i;k<=j;++k) res += v[k];
            return res;
        }
        vector<vector<int>> t;
        for(auto i:mp){
            t.push_back({i.second,i.first});
        }
        sort(t.begin(),t.end(),[](vector<int>& a,vector<int>& b){
            if(a[0] == b[0]) return a[1] > b[1];
            return a[0] > b[0];
        });
        int res = 0;
        for(int i=0;i<x;++i){
            res += t[i][1] * t[i][0]; 
        }
        return res;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x){
        // vector<vector<int>> t = {{2,3},{2,8},{1,9}};
        // sort(t.begin(),t.end(),[](vector<int>& a,vector<int>& b){
        //     if(a[0] == b[0]) return a[1] > b[1];
        //     return a[0] > b[0];
        // });
        // for(auto i:t){
        //     cout << i[0] << "" "" << i[1] << endl;
        // }
        // return {};
        int n = nums.size();
        v = nums;
        vector<int> res;
        for(int i=0;i+k-1<n;++i){
            res.push_back(fun(i,i+k-1,x));
        }
        return res;
    }
};",1420533392
Noor Nasri,Noor-Nasri,524,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def solveNode(self, root):
        # returns [depth, and size of largest subtree]
        if root == None: return [0, 0]
        depthL, sizeL = self.solveNode(root.left)
        depthR, sizeR = self.solveNode(root.right)

        if depthL == depthR and sizeL == sizeR and sizeL == depthL:
            # If both subtrees are perfect and have same depth, this is also perfect
            self.allSizes.append(2**(depthL + 1) - 1)
            return [depthL + 1, depthL + 1]

        return max(depthL, depthR) + 1, max(sizeL, sizeR)

    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.allSizes = []
        self.solveNode(root)

        if len(self.allSizes) < k: return -1

        return sorted(self.allSizes, reverse=True)[k-1]",1420541213
Noor Nasri,Noor-Nasri,524,3588,python3,"class Solution:
    def numberOfPossibleWins(self, numPoints, lastAction, curInd):
        if curInd == len(self.s):
            return int(numPoints > 0)
        if (numPoints, lastAction, curInd) in self.sols:
            return self.sols[(numPoints, lastAction, curInd)]

        numSols = 0
        for op_ind in range(3):
            option = self.options[op_ind]
            if option == lastAction: 
                continue # cant repeat action
            elif option == self.s[curInd]: 
                # tie action
                numSols += self.numberOfPossibleWins(numPoints, option, curInd + 1)
            elif self.options[op_ind + 1] == self.s[curInd]:
                # we beat them
                numSols += self.numberOfPossibleWins(numPoints + 1, option, curInd + 1)
            else:
                # we lose to them
                numSols += self.numberOfPossibleWins(numPoints - 1, option, curInd + 1)

        numSols %= (10**9 + 7)
        self.sols[(numPoints, lastAction, curInd)] = numSols
        return numSols
        
    def countWinningSequences(self, s: str) -> int:
        self.s = s
        self.options = [""F"", ""E"", ""W"", ""F""] #ind beats ind+1
        self.sols = {}
        return self.numberOfPossibleWins(0, '', 0)",1420562262
Noor Nasri,Noor-Nasri,524,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []

        for ind in range(len(nums) - k + 1):
            freq = [[i, 0] for i in range(51)]

            for ind2 in range(ind, min(len(nums), ind + k)):
                freq[nums[ind2]][1] += 1

            freq = sorted(freq, key = lambda x : x[0] + x[1] * 51, reverse = True)
            tot = 0
            for ind_freq in range(x):
                tot += freq[ind_freq][0]*freq[ind_freq][1]
            
            ans.append(tot)
        return ans",1420527501
Harendra Kumar,hkdass911999,525,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    vector<int> result;

    vector<int> solve(TreeNode* node) {
        if (!node) {
            return {1, 0, 0};
        }

        vector<int> left = solve(node->left);
        vector<int> right = solve(node->right);

        bool check = left[0] && right[0] && (left[1] == right[1]);
        int h = max(left[1], right[1]) + 1;
        int s = left[2] + right[2] + 1;

        if (check) {
            result.push_back(s);
        }

        return {check, h, s};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        solve(root);
        if (result.empty() || k > result.size()) {
            return -1;
        }
        sort(result.begin(), result.end(), greater<int>());
        return result[k - 1];
    }
};",1420527026
Harendra Kumar,hkdass911999,525,3588,cpp,"class Solution {
public:
    int dfs(int i, int prev, int diff, string& s, unordered_map<char, int>& unmap, vector<int>& bb, vector<vector<vector<int>>>& dp, int mod, int n) {
        if (i == n) return diff > n ? 1 : 0;

        if (dp[i][prev][diff] != -1) return dp[i][prev][diff];

        int result = 0;
        int a = unmap[s[i]];

        for (int b = 0; b < 3; ++b) {
            if (prev != b) {
                int res = 0;
                if (bb[b] == a) {
                    res = 1;
                } else if (bb[a] == b) {
                    res = -1;
                }
                int newRes = diff + res;
                if (newRes >= 0 && newRes <= 2 * n) {
                    result = (result + dfs(i + 1, b, newRes, s, unmap, bb, dp, mod, n)) % mod;
                }
            }
        }

        dp[i][prev][diff] = result;
        return result;
    }

    int countWinningSequences(string s) {
        int n = s.size();
        int mod = 1e9 + 7;
        unordered_map<char, int> unmap = {{'F', 0}, {'W', 1}, {'E', 2}};
        vector<int> bb(3);
        bb[0] = 2;
        bb[1] = 0;
        bb[2] = 1;

        int sh = n;
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, -1)));

        return dfs(0, 3, sh, s, unmap, bb, dp, mod, n);
    }
};",1420556419
Harendra Kumar,hkdass911999,525,3610,cpp,"#include <algorithm>
#include <vector>

using namespace std;

class Solution {
public:
    static bool cmp(pair<int, int>& a, pair<int, int>& b) {
        if (a.first != b.first)
            return a.first > b.first;
        return a.second > b.second;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> result;

        for (int idx = 0; idx <= n - k; ++idx) {
            vector<int> occur(51, 0);
            for (int j = idx; j < idx + k; ++j) {
                occur[nums[j]]++;
            }

            vector<pair<int, int>> arr;
            for (int val = 1; val <= 50; val++) {
                if (occur[val] > 0) {
                    arr.push_back({occur[val], val});
                }
            }

            sort(arr.begin(), arr.end(), cmp);

            vector<bool> res(51, false);
            int upto = min(x, (int)arr.size());
            for (int i = 0; i < upto; i++) {
                res[arr[i].second] = true;
            }

            int res2 = 0;
            for (int j = idx; j < idx + k; j++) {
                if (res[nums[j]]) {
                    res2 += nums[j];
                }
            }

            result.push_back(res2);
        }

        return result;
    }
};
",1420538375
CHIRAG BHATIA,chigu2005,526,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>temp;
    int bfs(TreeNode*root){
        queue<TreeNode*>q;
        q.push(root);
        int size=0;
        while(!q.empty()){
            int n=q.size();
            size+=n;
            bool nodeAdded=false;
            for(int i=0;i<n;i++){
                TreeNode*node=q.front();
                q.pop();
                
                if(node->left && node->right){
                    
                    if(nodeAdded==false && i>0){
                        return 0;
                    }
                    q.push(node->left);
                    q.push(node->right);
                    nodeAdded=true;
                }else if(!node->left && !node->right){
                    if(nodeAdded){
                        return 0;
                    }
                }else{
                    return 0;
                }
            }
        }
        
        return size;
    }
    void dfs(TreeNode*root){
        if(root==NULL){
            return;
        }
        
        int ans=bfs(root);
        if(ans!=0){
            temp.push_back(ans);
        }
        
        dfs(root->left);
        dfs(root->right);
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        
        
        sort(temp.rbegin(),temp.rend());
        
        
        if(temp.size()<k) return -1;
        return temp[k-1];
    }
};",1420538060
CHIRAG BHATIA,chigu2005,526,3588,cpp,"class Solution {
public:
    unordered_map<char, int> m;
    int dp[1005][4][2005];
    const int MOD = 1e9 + 7;

    int rec(string& s, int ind, int prevSummoned, int bobGain) {
        if (ind >= s.length()) {
            if (bobGain > 0) {
                return 1;
            }
            return 0;
        }

        if (dp[ind][prevSummoned][bobGain + 1000] != -1) 
            return dp[ind][prevSummoned][bobGain + 1000];
        
        int ans = 0;
        for (int i = 1; i <= 3; i++) {
            if (prevSummoned == i) {
                continue;
            }

            if (m[s[ind]] == i) {
                ans = (ans + rec(s, ind + 1, i, bobGain)) % MOD;
            } else {
                int aliceMove = m[s[ind]];
                int bobMove = i;

                if ((bobMove == 1 && aliceMove == 3) || 
                    (bobMove == 2 && aliceMove == 1) || 
                    (bobMove == 3 && aliceMove == 2)) {
                    ans = (ans + rec(s, ind + 1, i, bobGain + 1)) % MOD;
                } else {
                    ans = (ans + rec(s, ind + 1, i, bobGain - 1)) % MOD;
                }
            }
        }

        return dp[ind][prevSummoned][bobGain + 1000] = ans;
    }

    int countWinningSequences(string s) {
        m['F'] = 1;
        m['W'] = 2;
        m['E'] = 3;
        memset(dp, -1, sizeof(dp));
        return rec(s, 0, 0, 0);
    }
};
",1420562636
CHIRAG BHATIA,chigu2005,526,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        unordered_map<int,int>m;
        int n=nums.size();
        vector<int>ans(n-k+1,-1);
        for(int i=0;i<k;i++){
            m[nums[i]]++;
            
            vector<pair<int,int>>temp;
            for(auto it:m){
                temp.push_back({it.second,it.first});
            }
            sort(temp.rbegin(),temp.rend());
            int sum=0;
            int s=temp.size();
            for(int i=0;i<min(x,s);i++){
                sum+=(temp[i].second * temp[i].first);
            }
            
            ans[0]=sum;
        }
        
        
        int i=0;
        int j=k-1;
        int c=1;
        while(j<n){
            m[nums[i]]--;
            if(m[nums[i]]==0) m.erase(nums[i]);
            i++;
            
            j++;
            if(j<n){
                m[nums[j]]++;
                
                vector<pair<int,int>>temp;
            for(auto it:m){
                temp.push_back({it.second,it.first});
            }
            sort(temp.rbegin(),temp.rend());
            int sum=0;
                        
            
            int s=temp.size();
            for(int i=0;i<min(x,s);i++){
                sum+=(temp[i].second * temp[i].first);
            }
            
            ans[c]=sum;
                
            }
            c++;
            
        }
        return ans;
    }
};",1420524055
Debjit Ganguli,dganguli1997,527,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    class Stat {
        public int size;
        public boolean isPerfect;

        public Stat(int size, boolean isPerfect) {
            this.size = size;
            this.isPerfect = isPerfect;
        }
    }

    private List<Integer> sizes;

    private Stat solve(TreeNode current) {
        if(current == null) {
            return new Stat(0, true);
        }
        Stat stat = new Stat(1, false), left = solve(current.left), right = solve(current.right);
        stat.size += left.size + right.size;
        if(current.left != null && current.right != null && left.isPerfect && right.isPerfect && left.size == right.size) {
            stat.isPerfect = true;
        }
        if(current.left == null && current.right == null) {
            stat.isPerfect = true;
        }
        if(stat.isPerfect) {
            sizes.add(stat.size);
        }
        return stat;
    }

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        sizes = new ArrayList<>();
        solve(root);
        if(sizes.size() < k) {
            return -1;
        }
        Collections.sort(sizes, Collections.reverseOrder());
        return sizes.get(k - 1);
    }
}",1420546735
Debjit Ganguli,dganguli1997,527,3588,java,"class Solution {
    private final int MOD = 1_000_000_007;

    private int findPoint(char a, char b) {
        if(a == b) {
            return 0;
        }
        if((a == 'F' && b == 'E') || (a == 'W' && b == 'F') || (a == 'E' && b == 'W')) {
            return 1;
        }
        return -1;
    }

    private char[] moves = {'F', 'W', 'E'};

    private Integer[][][] dp;

    private int solve(String s, int index, int currentPoints, int lastUsed) {
        if(index == s.length()) {
            if(currentPoints > 0) {
                return 1;
            }
            return 0;
        }
        if(dp[index][currentPoints + 1000][lastUsed] != null) {
            return dp[index][currentPoints + 1000][lastUsed];
        }
        int i, result = 0;
        for(i = 0; i < 3; i += 1) {
            if(i == lastUsed) {
                continue;
            }
            result = (result + solve(s, index + 1, currentPoints + findPoint(moves[i], s.charAt(index)), i))%MOD;
        }
        return dp[index][currentPoints + 1000][lastUsed] = result;
    }

    public int countWinningSequences(String s) {
        dp = new Integer[s.length()][2001][4];
        return solve(s, 0, 0, 3);
    }
}",1420562695
Debjit Ganguli,dganguli1997,527,3610,java,"class Solution {
    private int findXSum(Map<Integer, Integer> freq, int x) {
        List<int[]> list = new ArrayList<>();
        for(Map.Entry<Integer, Integer> entry: freq.entrySet()) {
            list.add(new int[]{entry.getKey(), entry.getValue()});
        }
        Collections.sort(list, (a, b) -> {
            if(a[1] != b[1]) {
                return b[1] - a[1];
            }
            return b[0] - a[0];
        });
        int i, n = list.size(), result = 0;
        for(i = 0; i < Math.min(n, x); i += 1) {
            result += list.get(i)[0]*list.get(i)[1];
        }
        return result;
    }

    public int[] findXSum(int[] nums, int k, int x) {
        Map<Integer, Integer> freq = new HashMap<>();
        int n = nums.length, i;
        int[] result = new int[n - k + 1];
        for(i = 0; i < n; i += 1) {
            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);
            if(i >= k) {
                freq.put(nums[i - k], freq.getOrDefault(nums[i - k], 0) - 1);
                if(freq.get(nums[i - k]) == 0) {
                    freq.remove(nums[i - k]);
                }
            }
            if(i >= k - 1) {
                result[i - k + 1] = findXSum(freq, x);
            }
        }
        return result;
    }
}",1420528451
DEMON J,DeEmOnJ,529,3509,cpp,"
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {

        vector<int> perfectSizes;
        checkPerfect(root, perfectSizes);
        if (perfectSizes.size() < k) return -1;
        sort(perfectSizes.begin(), perfectSizes.end(), greater<int>());
        return perfectSizes[k - 1];
        }
        private:
        struct SubtreeInfo {
        bool isPerfect;
        int height;
        int size;
        };

        SubtreeInfo checkPerfect(TreeNode* node, vector<int>& sizes) {
        if (!node) return {true, 0, 0};

        auto leftInfo = checkPerfect(node->left, sizes);
        auto rightInfo = checkPerfect(node->right, sizes);

        bool isPerfect = leftInfo.isPerfect && rightInfo.isPerfect &&
        leftInfo.height == rightInfo.height;
        int height = max(leftInfo.height, rightInfo.height) + 1;
        int size = leftInfo.size + rightInfo.size + 1;

        if (isPerfect) sizes.push_back(size);

        return {isPerfect, height, size};
        }
        };
        
   ",1420537879
DEMON J,DeEmOnJ,529,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {

        const int MOD = 1e9 + 7;
        int n = s.length();
        int maxDiff = 2 * n;
        std::vector<std::vector<std::vector<int>>> dp(n + 1, std::vector<std::vector<int>>(maxDiff + 1, std::vector<int>(4, 0)));

        auto charToInt = [](char c) {
        if (c == 'F') return 1;
        if (c == 'W') return 2;
        return 3; 
        };

        auto beats = [](int a, int b) {
        return (a == 1 && b == 3) || (a == 2 && b == 1) || (a == 3 && b == 2);
        };
        int offset = n;
        dp[0][offset][0] = 1;
        for (int i = 0; i < n; ++i) {
        int aliceMove = charToInt(s[i]);
        for (int d = 0; d <= maxDiff; ++d) {
        for (int prev = 0; prev <= 3; ++prev) {
        if (dp[i][d][prev] == 0) continue;
        for (int bobMove = 1; bobMove <= 3; ++bobMove) {
        if (bobMove == prev) continue;
        int delta = 0;
        if (beats(bobMove, aliceMove)) {
        delta = 1;
        } else if (beats(aliceMove, bobMove)) {
        delta = -1;
        }
        int newDiff = d + delta;
        if (newDiff < 0 || newDiff > maxDiff) continue;
        dp[i + 1][newDiff][bobMove] = (dp[i + 1][newDiff][bobMove] + dp[i][d][prev]) % MOD;
        }
        }
        }
        }
        int result = 0;
        for (int d = offset + 1; d <= maxDiff; ++d) {
        for (int prev = 1; prev <= 3; ++prev) {
        result = (result + dp[n][d][prev]) % MOD;
        }
        }
        return result;
        }
        };
    ",1420562804
DEMON J,DeEmOnJ,529,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {

        int n = nums.size();
        vector<int> result;

        for (int i = 0; i <= n - k; ++i) {
        unordered_map<int, int> freqMap;
        for (int j = i; j < i + k; ++j) {
        freqMap[nums[j]]++;
        }

        vector<pair<int, int>> freqList(freqMap.begin(), freqMap.end());
        sort(freqList.begin(), freqList.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        if (a.second != b.second)
        return a.second > b.second;
        return a.first > b.first;
        });

        unordered_set<int> topElements;
        for (int idx = 0; idx < min(x, (int)freqList.size()); ++idx) {
        topElements.insert(freqList[idx].first);
        }

        int sum = 0;
        for (int j = i; j < i + k; ++j) {
        if (topElements.count(nums[j])) {
        sum += nums[j];
        }
        }
        result.push_back(sum);
        }

        return result;
        }
        };


  ",1420532622
Anurag Kumar,AnuragKumar_iiitg,530,3509,cpp,"class Solution {
public:
    vector<int> sizes;

    // Helper function to determine if a subtree is perfect and to collect its size.
    tuple<bool, int, int> helper(TreeNode* node) {
        if (!node) {
            // An empty subtree is considered perfect with height 0 and size 0.
            return {true, 0, 0};
        }

        // Recursively check left and right subtrees.
        auto [left_perfect, left_height, left_size] = helper(node->left);
        auto [right_perfect, right_height, right_size] = helper(node->right);

        // A subtree is perfect if both left and right subtrees are perfect and have the same height.
        bool current_perfect = left_perfect && right_perfect && (left_height == right_height);
        int current_height = left_height + 1; // Height of current node is max of left/right heights plus 1.
        int current_size = left_size + right_size + 1; // Size includes left, right, and current node.

        if (current_perfect) {
            sizes.push_back(current_size); // Record the size of the perfect subtree.
        }

        return {current_perfect, current_height, current_size};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sizes.clear();
        helper(root);

        // Sort sizes in decreasing order.
        sort(sizes.begin(), sizes.end(), greater<int>());

        if (sizes.size() >= k) {
            return sizes[k - 1]; // Return the k-th largest size.
        } else {
            return -1; // If fewer than k perfect subtrees exist.
        }
    }
};",1420559358
Anurag Kumar,AnuragKumar_iiitg,530,3588,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int creature_map[256];
    int outcome[3][3];
    
    int dp(int i, int last_bob_move, int score_diff, const string& s, vector<vector<vector<int>>>& memo) {
        int n = s.length();
        // Base case: all rounds are played
        if (i == n) {
            return score_diff > 0 ? 1 : 0;
        }
        // Shift last_bob_move by 1 and score_diff by n for indexing
        if (memo[i][last_bob_move + 1][score_diff + n] != -1) {
            return memo[i][last_bob_move + 1][score_diff + n];
        }
        int res = 0;
        int alice_move = creature_map[s[i]];
        // Bob can choose any creature not equal to last_bob_move
        for (int bob_move = 0; bob_move < 3; ++bob_move) {
            if (bob_move == last_bob_move) continue;
            int outcome_value = outcome[alice_move][bob_move];
            int new_score_diff = score_diff;
            if (outcome_value == -1) new_score_diff += 1; // Bob gains a point
            else if (outcome_value == 1) new_score_diff -= 1; // Alice gains a point
            // Recurse to the next round
            res = (res + dp(i + 1, bob_move, new_score_diff, s, memo)) % MOD;
        }
        memo[i][last_bob_move + 1][score_diff + n] = res;
        return res;
    }

    int countWinningSequences(string s) {
        int n = s.length();
        vector<vector<vector<int>>> memo(n + 1, vector<vector<int>>(4, vector<int>(2 * n + 1, -1)));
        // Initialize creature mapping
        creature_map['F'] = 0; // Fire Dragon
        creature_map['W'] = 1; // Water Serpent
        creature_map['E'] = 2; // Earth Golem
        // Initialize outcome matrix
        memset(outcome, 0, sizeof(outcome));
        outcome[0][2] = 1;  // Alice gains a point (F vs E)
        outcome[2][0] = -1; // Bob gains a point (E vs F)
        outcome[1][0] = 1;  // Alice gains a point (W vs F)
        outcome[0][1] = -1; // Bob gains a point (F vs W)
        outcome[2][1] = 1;  // Alice gains a point (E vs W)
        outcome[1][2] = -1; // Bob gains a point (W vs E)
        return dp(0, -1, 0, s, memo);
    }
};",1420563023
Anurag Kumar,AnuragKumar_iiitg,530,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
    vector<int> answer;

    for (int i = 0; i <= n - k; ++i) {
        vector<int> subarray(nums.begin() + i, nums.begin() + i + k);
        int freq[51] = {0};
        for (int num : subarray) {
            freq[num]++;
        }

        vector<pair<int, int>> freq_elements;
        for (int val = 1; val <= 50; ++val) {
            if (freq[val] > 0) {
                freq_elements.push_back({freq[val], val});
            }
        }

        sort(freq_elements.begin(), freq_elements.end(), [](pair<int, int>& a, pair<int, int>& b) {
            if (a.first != b.first) {
                return a.first > b.first; // Descending frequency
            } else {
                return a.second > b.second; // Descending value if frequencies are equal
            }
        });

        set<int> top_elements;
        for (int idx = 0; idx < min(x, (int)freq_elements.size()); ++idx) {
            top_elements.insert(freq_elements[idx].second);
        }

        int sum = 0;
        for (int num : subarray) {
            if (top_elements.count(num)) {
                sum += num;
            }
        }

        answer.push_back(sum);
    }

    return answer;
    }
};",1420556055
Yang Youseok,ileixe,531,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        heap = []

        def dfs(node):
            if not node:
                return 0
            
            left = dfs(node.left)
            right = dfs(node.right)

            if left >= 0 and right >= 0 and left == right:
                print(node)
                heappush(heap, (left + right + 1))
                return left + right + 1
            else:
                return -1

        dfs(root)
        return nlargest(k, heap)[-1] if len(heap) >= k else -1
            

        ",1420535158
Yang Youseok,ileixe,531,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def dp(i, prev, score):
            if i == len(s):
                return score > 0
                

            res = 0
            for t in ('F', 'W', 'E'):
                if t == prev:
                    continue

                if s[i] == 'F':
                    if t == 'F':
                        res += dp(i + 1, 'F', score) 
                    elif t == 'W':
                        res += dp(i + 1, 'W', score + 1)
                    elif t == 'E':
                        res += dp(i + 1, 'E', score - 1)
                elif s[i] == 'W':
                    if t == 'F':
                        res += dp(i + 1, 'F', score - 1) 
                    elif t == 'W':
                        res += dp(i + 1, 'W', score)
                    elif t == 'E':
                        res += dp(i + 1, 'E', score + 1)
                elif s[i] == 'E':
                    if t == 'F':
                        res += dp(i + 1, 'F', score + 1) 
                    elif t == 'W':
                        res += dp(i + 1, 'W', score - 1)
                    elif t == 'E':
                        res += dp(i + 1, 'E', score)
            return res

        return dp(0, None, 0) % (10 ** 9 + 7)


",1420550463
Yang Youseok,ileixe,531,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums) - k + 1):
            num = sorted(nums[i: i + k], reverse=True)

            count = Counter(num)
            res.append(sum(k * v for k, v in count.most_common(x)))
        return res
        ",1420522585
p_v_r,p_v_r,532,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        ans = []
        
        def dfs(temp):
            if temp==None:
                return 0
            l = dfs(temp.left)
            r = dfs(temp.right)
            if l==0 and r==0:
                ans.append(1)
                return 1
            if l!=0 and r!=0 and l==r:
                ans.append(l+r+1)
                return l + r + 1
            return -1
        dfs(root)
        
        ans.sort(reverse=True)
        # print(ans)
        if len(ans)<k:
            return -1
        return ans[k-1]",1420535243
p_v_r,p_v_r,532,3588,python3,"MOD = 10**9 + 7
class Solution:
    def countWinningSequences(self, s: str) -> int:
        # s = ""F""*1000
        n = len(s)
        l = ['E','F','W']
        mp = {}
        mp['E'] = 0
        mp['F'] = 1
        mp['W'] = 2
        mp['a'] = 3
        dp = [[[-1]*(2*n+1) for i in range(n+1)] for j in range(4)]
        
        def helper(prev,ind,cnt):
            if ind==n:
                return (1 if cnt>0 else 0)
            if dp[mp[prev]][ind][cnt+n]!=-1: return dp[mp[prev]][ind][cnt+n]
            ans = 0
            for i in l:
                if i!=prev:
                    if s[ind]=='F' and (i=='W'):
                        ans += helper(i,ind+1,cnt+1)
                    elif s[ind]=='W' and (i=='E'):
                        ans += helper(i,ind+1,cnt+1)
                    elif s[ind]=='E' and (i=='F'):
                        ans += helper(i,ind+1,cnt+1)
                    elif s[ind]=='W' and (i=='F'):
                        ans += helper(i,ind+1,cnt-1)
                    elif s[ind]=='E' and (i=='W'):
                        ans += helper(i,ind+1,cnt-1)
                    elif s[ind]=='F' and (i=='E'):
                        ans += helper(i,ind+1,cnt-1)
                    else:
                        ans += helper(i,ind+1,cnt)
                    ans %= MOD
            dp[mp[prev]][ind][cnt+n] = ans
            return ans
                    
        
        return helper('a',0,0)",1420556917
p_v_r,p_v_r,532,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        ans = [0]*(n-k+1)
        left = 0
        mp = {}
        def helper(m):
            t = list(sorted(mp.items(),key=lambda x:(-x[1],-x[0])))[:x]
            # print(t)
            a = 0
            for i,val in t:
                a += (i*val)
            return a
        for i in range(n):
            if i<k:
                mp[nums[i]] = mp.get(nums[i],0)+1
            else:
                mp[nums[left]] = mp[nums[left]] - 1
                mp[nums[i]] = mp.get(nums[i],0)+1
                left += 1
            if(i>=(k-1)): ans[left] = helper(mp)
        return ans",1420523785
Gaurav,Gaurav_724,533,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        def go(root,l,d):
            if not root:
                return 
            d[l]+=1
            go(root.left,l+1,d)
            go(root.right,l+1,d)
        
        def chk(root):
            d = defaultdict(int)
            go(root,0,d)
            sm = sum(d.values())
            for l in d:
                if d[l]!=pow(2,l):
                    return [sm,False]
            return [sm,True]
        
        arr = []
        def compute(root):
            if not root : return 
            res = 0
            sm,p = chk(root)
            if p:
                arr.append(sm)
            compute(root.left)
            compute(root.right)
            # return res
            
            
        compute(root)
        arr.sort(key = lambda x:-x)
        # print(arr)
        if k-1>=len(arr):
            return -1
        return arr[k-1]",1420542145
Gaurav,Gaurav_724,533,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        win = set([""FE"",""WF"",""EW""])
        mod = 10**9 + 7
        r=[]
        @lru_cache(None)
        def compute(i,pre,count):
            if i==len(s):
                # if count>0:
                    # print(r)
                return int(count>0)
            res = 0
            for nei in [""F"",""E"",""W""]:
                if nei==pre:
                    continue
                t = nei+s[i]
                if t in win:
                    # r.append(nei)
                    res+=compute(i+1,nei,count+1)%mod
                    # r.pop()
                elif nei==s[i]:
                    # r.append(nei)
                    res+=compute(i+1,nei,count)%mod
                    # r.pop()
                else:
                    
                    res+=compute(i+1,nei,count-1)%mod
                    
            return res%mod
        return compute(0,None,0)",1420563084
Gaurav,Gaurav_724,533,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(0,len(nums)):
            s = i
            e = i+k
            if i+k>len(nums):
                break
            arr = nums[s:e]
            # print(arr)
            c = Counter(arr)
            arr = list(set(arr))
            arr.sort(key = lambda x  : (-c[x],-x))
            # print(arr)
            v =0
            idx=0
            for e in arr:
                v+=(c[e] * e)
                idx+=1
                if idx==x:
                    break
            res.append(v)
        return res
            ",1420526117
Joey Woodson,SaveVMK,534,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        ArrayList<Integer> sl = sublen(root);
        //System.out.println(sl);
        Collections.sort(sl);
        if (k>sl.size())
            return -1;
        //System.out.println(sl);
        return sl.get(sl.size()-k);
    }

    public ArrayList<Integer> sublen(TreeNode root) {
        ArrayList<Integer> ans = new ArrayList<>();
        if (root==null)
            return ans;
        ArrayList<Integer> left = sublen(root.left);
        ArrayList<Integer> right = sublen(root.right);
        ans.addAll(left);
        ans.addAll(right);
        if (left.isEmpty()&&right.isEmpty())
            ans.add(1);
        else if (left.isEmpty()||right.isEmpty())
            ans.add(-1);
        else if (0+left.get(left.size()-1)==0+right.get(right.size()-1)&&left.get(left.size()-1)>0)
            ans.add(left.get(left.size()-1)*2+1);
        else {
            ans.add(-1);
        }
        return ans;
    }
}",1420536022
Joey Woodson,SaveVMK,534,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int n = s.length();
        int[][][] dp = new int[n][3][2001];
        s = s.replaceAll(""F"",""0"");
        s = s.replaceAll(""W"",""1"");
        s = s.replaceAll(""E"",""2"");
        dp[0][s.charAt(0)-'0'][1000] = 1;
        dp[0][(s.charAt(0)-'0'+1)%3][1001] = 1;
        dp[0][(s.charAt(0)-'0'+2)%3][999] = 1;
        for (int i = 0; i < n-1; ++i) {
            int x = s.charAt(i+1)-'0';
            for (int j = 1; j < 2000; ++j) {
                dp[i+1][x][j] += dp[i][(x+1)%3][j];
                dp[i+1][(x+1)%3][j+1] += dp[i][x][j];
                dp[i+1][(x+2)%3][j-1] += dp[i][x][j];
                dp[i+1][x][j] %= 1000000007;
                dp[i+1][(x+1)%3][j+1] %= 1000000007;
                dp[i+1][(x+2)%3][j-1] %= 1000000007;
                dp[i+1][x][j] += dp[i][(x+2)%3][j];
                dp[i+1][(x+1)%3][j+1] += dp[i][(x+2)%3][j];
                dp[i+1][(x+2)%3][j-1] += dp[i][(x+1)%3][j];
                dp[i+1][x][j] %= 1000000007;
                dp[i+1][(x+1)%3][j+1] %= 1000000007;
                dp[i+1][(x+2)%3][j-1] %= 1000000007;
            }
        }
        int ans = 0;
        for (int i = 1001; i <= 2000; ++i) {
            ans += dp[n-1][0][i];
            ans %= 1000000007;
            ans += dp[n-1][1][i];
            ans %= 1000000007;
            ans += dp[n-1][2][i];
            ans %= 1000000007;
        }
        return ans;
    }
}",1420550617
Joey Woodson,SaveVMK,534,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n-k+1];
        for (int i = 0; i+k <= n; ++i) {
            int[] arr = new int[k];
            for (int j = 0; j < k; ++j) {
                arr[j] = nums[i+j];
            }
            ans[i] = findSubSum(arr, x);
        }
        return ans;
    }

    public int findSubSum(int[] nums, int x) {
        int n = nums.length;
        int[] cts = new int[51];
        for (int y : nums)
            cts[y]++;
        TreeSet<Integer> tm = new TreeSet<>();
        for (int i = 0; i <= 50; ++i) {
            tm.add(cts[i]*100+i);
        }
        int ans = 0;
        for (int i = 0; i < x; ++i) {
            int last = tm.pollLast();
            ans += (last/100)*(last%100);
        }
        return ans;
    }
}",1420521019
messyhair,messyhair,535,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        def traverse(node: Optional[TreeNode]) -> Tuple[bool, int]:
            if node is None:
                return [True, 0]

            left = traverse(node.left)
            right = traverse(node.right)

            if not left[0] or not right[0] or left[1] != right[1]:
                return [False, 0]

            sizes.append(left[1] + right[1] + 1)
            return [True, left[1] + right[1] + 1]

        traverse(root)
        if len(sizes) < k:
            return -1

        sizes.sort(reverse = True)
        return sizes[k - 1]

",1420532605
messyhair,messyhair,535,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        memo = {}

        move = {
            'F': {
                'W': -1,
                'F': 0,
                'E': 1,
            },
            'W': {
                'W': 0,
                'F': 1,
                'E': -1,
            },
            'E': {
                'W': 1,
                'F': -1,
                'E': 0,
            },
        }

        def dp(i: int, prev: int, current: int) -> int:
            if i >= len(s):
                return int(current > 0)
            elif i in memo and prev in memo[i] and current in memo[i][prev]:
                return memo[i][prev][current]

            if i not in memo:
                memo[i] = {}
            if prev not in memo[i]:
                memo[i][prev] = {}

            memo[i][prev][current] = 0
            if prev == 'F':
                memo[i][prev][current] = (memo[i][prev][current] + dp(i + 1, 'W', current + move['W'][s[i]])) % (10 ** 9 + 7)
                memo[i][prev][current] = (memo[i][prev][current] + dp(i + 1, 'E', current + move['E'][s[i]])) % (10 ** 9 + 7)
            elif prev == 'W':
                memo[i][prev][current] = (memo[i][prev][current] + dp(i + 1, 'F', current + move['F'][s[i]])) % (10 ** 9 + 7)
                memo[i][prev][current] = (memo[i][prev][current] + dp(i + 1, 'E', current + move['E'][s[i]])) % (10 ** 9 + 7)
            elif prev == 'E':
                memo[i][prev][current] = (memo[i][prev][current] + dp(i + 1, 'W', current + move['W'][s[i]])) % (10 ** 9 + 7)
                memo[i][prev][current] = (memo[i][prev][current] + dp(i + 1, 'F', current + move['F'][s[i]])) % (10 ** 9 + 7)

            return memo[i][prev][current]

        result = 0
        for m in 'FEW':
            result = (result + dp(1, m, move[m][s[0]])) % (10 ** 9 + 7)
        return result",1420557240
messyhair,messyhair,535,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        for i in range(len(nums) - k + 1):
            counts = {}
            for j in range(i, i + k):
                counts[nums[j]] = counts.get(nums[j], 0) + 1
            # print(i, counts)
            if len(counts) <= x:
                result.append(sum(nums[i:i + k]))
            else:
                c = []
                for num in counts:
                    c.append([counts[num], num])
                c.sort(reverse = True)
                # print(c)
                current = 0
                for m in range(x):
                    current += c[m][0] * c[m][1]

                result.append(current)
        return result",1420525590
b7d3HcrGsj,b7d3HcrGsj,536,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> v;
    int dfs(TreeNode* root){
        if(!root) return 0;
        int left=dfs(root->left);
        int right=dfs(root->right);
        if(left==-1 || right==-1) return -1;
        if(left!=right) return -1;
        int leaves=pow(2,left+1)-1;
        v.push_back(leaves);
        return left+1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        if(v.size()<k) return -1;
        sort(v.begin(), v.end());
        return v[v.size()-k];
    }
};",1420526148
b7d3HcrGsj,b7d3HcrGsj,536,3588,cpp,"int MOD=1e9+7;
string opt=""FWE"";
class Solution {
public:
    int charInt(char &a){
        if(a=='W') return 0;
        if(a=='F') return 1;
        return 2;
    }
    int match(char &a, char &b){
        if((a=='W' && b=='F') || a=='F' && b=='E' || a=='E' && b=='W') return -1;
        else if(a==b) return 0;
        else return 1;
    }
    int recur(string &s, char c, int i, int b, vector<vector<vector<int>>> &mp){
        if(i>=s.size()) return b>0?1:0;
        if(mp[i][b+s.size()+1][charInt(c)]!=INT_MIN) return mp[i][b+s.size()+1][charInt(c)];
        long long ans=0;
        for(auto &j:opt){
            if(j!=c) ans=(ans+recur(s,j,i+1,b+match(s[i],j), mp))%MOD;
        }
        return mp[i][b+s.size()+1][charInt(c)] = ans;
    }
    int countWinningSequences(string s) {
        long long ans=0;
        vector<vector<vector<int>>> mp(s.size()+3, vector<vector<int>> (4*s.size(), vector<int>(3,INT_MIN)));
        for(auto &i:opt){
            int temp=match(s[0],i);
            ans+=recur(s,i,1,temp, mp);
        }
        return ans%MOD;
    }
};",1420563578
b7d3HcrGsj,b7d3HcrGsj,536,3610,cpp,"#include <vector>
#include <unordered_map>
#include <queue>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> answer;

        // Function to calculate x-sum for a given subarray
        auto calculateXSum = [&](unordered_map<int, int>& freqMap) {
            // Create a vector to store pairs of (frequency, number)
            vector<pair<int, int>> freqVec;
            for (auto& it : freqMap) {
                freqVec.push_back({it.second, it.first});
            }

            // Sort by frequency descending, if equal by number descending
            sort(freqVec.begin(), freqVec.end(), [&](pair<int, int>& a, pair<int, int>& b) {
                if (a.first != b.first)
                    return a.first > b.first; // Sort by frequency
                return a.second > b.second;   // If frequencies are equal, sort by value
            });

            // Calculate x-sum (sum of top x elements)
            int xSum = 0;
            int count = 0;
            for (auto& p : freqVec) {
                if (count == x) break;
                xSum += p.second * p.first; // Add number * frequency
                count++;
            }
            return xSum;
        };

        unordered_map<int, int> freqMap; // To store the frequency of elements in the window

        // Initialize the frequency map for the first window (nums[0..k-1])
        for (int i = 0; i < k; i++) {
            freqMap[nums[i]]++;
        }

        // Add the x-sum for the first window
        answer.push_back(calculateXSum(freqMap));

        // Slide the window over the rest of the array
        for (int i = k; i < n; i++) {
            // Remove the element that's leaving the window
            freqMap[nums[i - k]]--;
            if (freqMap[nums[i - k]] == 0) {
                freqMap.erase(nums[i - k]);
            }

            // Add the element that's entering the window
            freqMap[nums[i]]++;

            // Add the x-sum for the current window
            answer.push_back(calculateXSum(freqMap));
        }

        return answer;
    }
};
",1420518649
pratapSingh_007,pratapSingh_007,537,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        
        findPerfectSubtrees(root, pq);
        
        if (pq.size() < k) {
            return -1;
        }
        
        for (int i = 1; i < k; i++) {
            pq.poll();
        }
        
        return pq.poll();
    }
    
    private int findPerfectSubtrees(TreeNode root, PriorityQueue<Integer> pq) {
        if (root == null) return 0;
        
        int leftHeight = findPerfectSubtrees(root.left, pq);
        int rightHeight = findPerfectSubtrees(root.right, pq);
        
        if (leftHeight == rightHeight && leftHeight != -1) {
            int size = (int)Math.pow(2,leftHeight+1) - 1; 
            pq.add(size);
            return leftHeight + 1;
        }
        
        return -1;
    }

   
}",1420541080
pratapSingh_007,pratapSingh_007,537,3588,java,"class Solution {
    private static final int MOD = 1000000007;
    private int[][][] memo; 
    private String aliceMoves;
    private int n;

 
    private int moveToIndex(char move) {
        if (move == 'F') return 0;
        if (move == 'W') return 1;
        return 2; // 'E'
    }

 
    private int countWays(int i, int lastBobMoveIdx, int scoreDiff) {
        
        if (i == n) {
            return scoreDiff > 0 ? 1 : 0;
        }
        
        int memoScoreDiff = scoreDiff + n; 

        if (memo[i][lastBobMoveIdx + 1][memoScoreDiff] != -1) {
            return memo[i][lastBobMoveIdx + 1][memoScoreDiff];
        }
        
        char aliceMove = aliceMoves.charAt(i);
        
        int totalWays = 0;

        for (char bobMove : new char[]{'F', 'W', 'E'}) {
            int bobMoveIdx = moveToIndex(bobMove);

            if (bobMoveIdx == lastBobMoveIdx) continue;
            
            int newScoreDiff = scoreDiff;
            if (bobMove == 'F' && aliceMove == 'E') newScoreDiff++; // Bob wins
            if (bobMove == 'W' && aliceMove == 'F') newScoreDiff++; // Bob wins
            if (bobMove == 'E' && aliceMove == 'W') newScoreDiff++; // Bob wins

            if (aliceMove == 'F' && bobMove == 'E') newScoreDiff--; // Alice wins
            if (aliceMove == 'W' && bobMove == 'F') newScoreDiff--; // Alice wins
            if (aliceMove == 'E' && bobMove == 'W') newScoreDiff--; // Alice wins

    
            totalWays = (totalWays + countWays(i + 1, bobMoveIdx, newScoreDiff)) % MOD;
        }
        
        memo[i][lastBobMoveIdx + 1][memoScoreDiff] = totalWays;
        return totalWays;
    }

    public int countWinningSequences(String s) {
        this.aliceMoves = s;
        this.n = s.length();
        this.memo = new int[n][4][2 * n + 1];

        for (int[][] row : memo) {
            for (int[] col : row) {
                Arrays.fill(col, -1);
            }
        }

      
        return countWays(0, -1, 0); 
    }
}
",1420563594
pratapSingh_007,pratapSingh_007,537,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
         int n = nums.length;
        int[] result = new int[n - k + 1];

        for (int i = 0; i <= n - k; i++) {
            int[] freq = new int[51]; 
            
            for (int j = i; j < i + k; j++) {
                freq[nums[j]]++;
            }
            
            List<int[]> freqList = new ArrayList<>();
            for (int val = 1; val <= 50; val++) {
                if (freq[val] > 0) {
                    freqList.add(new int[]{val, freq[val]});
                }
            }

            freqList.sort((a, b) -> (b[1] == a[1]) ? Integer.compare(b[0], a[0]) : Integer.compare(b[1], a[1]));
            
            int sum = 0;
            int count = 0;
            for (int[] pair : freqList) {
                int value = pair[0];
                int frequency = pair[1];
                for (int f = 0; f < frequency && count < x; f++) {
                    sum += value;
                }
                count++;
                if (count >= x) break;
            }
            result[i] = sum;
        }

        return result;
    }
}",1420523470
Kartik Sharma,KartikSharma99,538,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    int Util(TreeNode* root){
        if (root==NULL) return 0;

        int left=Util(root->left);
        int right=Util(root->right);

        if (left==-1 || right==-1 || left!=right) return -1;
        ans.push_back(1+left+right);
        return 1+left+right;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        Util(root);

        if (ans.size()<k) return -1;
        sort(ans.begin(),ans.end(),greater<int> ());
        return ans[k-1];
    }
};",1420535404
Kartik Sharma,KartikSharma99,538,3588,cpp,"#define ll long long
class Solution {
public:

    ll mod=1e9+7;
    unordered_map<char,int> charToType;
    vector<vector<vector<ll>>> dp;
    ll Util(string& s,ll index,ll score,ll prev){
        int n=s.size();
        if (index==s.size()) return score>0;
        if (prev!=-1 && dp[index][score+n][prev]!=-1) return dp[index][score+n][prev];
        ll ans=0;
        for (int i=0;i<3;i++){
            if (i==prev) continue;
            ll enemy=charToType[s[index]];
            if (enemy==((i+1)%3)) ans=(ans+Util(s,index+1,score-1,i))%mod;
            else if (enemy==((i+2)%3)) ans=(ans+Util(s,index+1,score+1,i))%mod;
            else ans=(ans+Util(s,index+1,score,i))%mod;
        }
        if (prev!=-1) dp[index][score+n][prev]=ans;
        return ans;
    }
    int countWinningSequences(string s) {
        charToType['F']=0;
        charToType['W']=1;
        charToType['E']=2;
        int n=s.size();
        dp.resize(n,vector<vector<ll>> (2*n+1,vector<ll> (3,-1)));
        return Util(s,0,0,-1);
    }
};",1420563623
Kartik Sharma,KartikSharma99,538,3610,cpp,"class Solution {
public:

    int xSum(vector<int>& nums,int start,int end,int x){
        unordered_map<int,int> eCount;
        for (int i=start;i<=end;i++) eCount[nums[i]]++;

        vector<pair<int,int>> freqE;
        for(auto [u,v]:eCount) freqE.push_back({v,u});
        sort(freqE.begin(),freqE.end(),greater<pair<int,int>> ());
        int ans=0;
        for (int i=0;i<(min(x,(int)freqE.size()));i++) ans+=freqE[i].second*freqE[i].first;
        return ans;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        vector<int> ans(n-k+1,-1);
        for (int i=0;i<n-k+1;i++){
            ans[i]=xSum(nums,i,i+k-1,x);
        }

        return ans;
    }
};",1420526472
PankajGhodla,PankajGhodla,539,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        arr = []
        def dfs(root):
            if root == None: return 0, 0
            left, l = dfs(root.left)
            right, r = dfs(root.right)
            size = left + right + 1
            if left == right == (2 ** max(l, r)) - 1: arr.append(size)
            return size, 1 + max(l, r)
        dfs(root)
        if len(arr) < k: return -1
        arr.sort(reverse=True)
        return arr[k-1]
        ",1420525333
PankajGhodla,PankajGhodla,539,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        def getScore(a, b):
            if a == b: return 0
            elif a == ""F"" and b == ""E"": return 1
            elif a == ""E"" and b == ""F"": return -1
            elif a == ""W"" and b == ""F"": return 1
            elif a == ""F"" and b == ""W"": return -1
            elif a == ""E"" and b == ""W"": return 1 
            else: return -1
        MOD = 10**9 + 7
        @cache
        def solve(i, prev, score):
            if i == len(s):
                return score > 0
            ans = 0
            for a in [""F"", ""W"", ""E""]:
                if a == prev: continue
                ans += solve(i+1, a, score + getScore(a, s[i]))
            return ans % MOD
        
        return solve(0, ""-"", 0)
            
            
        ",1420557606
PankajGhodla,PankajGhodla,539,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        
        for i in range(max(1, len(nums) - k + 1)):
            counter = Counter(nums[i: i + k])
            arr = []
            for key, val in counter.items():
                arr.append((val, key))
            arr.sort(reverse=True)
            curr = 0
            for i in range(min(x, len(arr))):
                curr += arr[i][0] * arr[i][1]
            ans.append(curr)
        return ans
                
            
        ",1420521068
figuring-out,figuring-out,540,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
    
    vector<int> sizes;
    

    pair<bool, int> traverse(TreeNode* node){     
        if(!node)
            return {true,0};
        
        auto left = traverse(node->left);
        auto right = traverse(node->right);
        
        if(left.first && right.first && left.second == right.second){
            
            int current_size = (1<<(left.second+1)) -1;
            sizes.push_back(current_size);
            return {true,left.second +1};
        }
        
        return {false,max(left.second, right.second)};
    }
    
    
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        traverse(root);

        sort(sizes.begin(),sizes.end(),greater<int>());
        
        if(k-1<sizes.size())
            return sizes[k-1];
        
        return -1;
    }
};",1420531390
figuring-out,figuring-out,540,3588,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.size(), MOD = 1e9 +7;

        auto get_move = [&](char c){
            if(c=='F') return 0;
            if(c=='W') return 1;
            return 2;
        };
        
        
        int delta_table[3][3];
        for(int a=0;a<3;a++) {
            for(int b=0;b<3;b++) {
                if(a ==0 and b==2) 
                    delta_table[a][b] = -1;
                
                else if(a ==1 and b==0)  
                    delta_table[a][b] = -1;
                
                else if(a ==2 and b==1)  
                    delta_table[a][b] = -1;
                
                else if(a ==2 and b==0)  
                    delta_table[a][b] = 1;
                
                else if(a ==0 and b==1)  
                    delta_table[a][b] = 1;
                
                else if(a ==1 and b==2)  
                    delta_table[a][b] =1;
                
                else 
                    delta_table[a][b] =0;
                
            }
        }
        
        
        vector<vector<vector<long long>>> dp(n+1, vector<vector<long long>>(4, vector<long long>(2*n+1, -1)));
        
        
        
        function<long long(int, int, int)> dfs = [&](int i, int last, int d_shifted) -> long long{
            if(i == n){
                if(d_shifted>n) return 1;
                return 0;
            }
            
            if(dp[i][last][d_shifted] != -1) return dp[i][last][d_shifted];
            
            
            long long res =0;
            int a = get_move(s[i]);
            for(int b=0;b<3;b++){
                if(last!=3 and b==last) continue;
                
                int del = delta_table[a][b];
                int new_d = (d_shifted-n)+del;
                
                if(new_d<(-n) or new_d>n) continue;
                int new_d_shifted = new_d+n;
                
                
                res = (res+dfs(i+1,b,new_d_shifted)) % MOD;
            }
            return dp[i][last][d_shifted] = res;
        };
        
        
        
        return dfs(0, 3, n);
    }
};
",1420563736
figuring-out,figuring-out,540,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0;i<=n-k;i++){
            int freq[51] = {0};
            for(int j=i;j<i+k;j++) freq[nums[j]]++;
            vector<int> elems;
            for(int num=1; num<=50; num++) if(freq[num]>0) elems.push_back(num);
            sort(elems.begin(), elems.end(), [&](const int a, const int b) -> bool{
                if(freq[a] != freq[b]) return freq[a] > freq[b];
                return a > b;
            });
            unordered_set<int> top;
            for(int m=0; m<min(x, (int)elems.size()); m++) top.insert(elems[m]);
            int s=0;
            for(int j=i;j<i+k;j++) if(top.count(nums[j])) s += nums[j];
            ans.push_back(s);
        }
        return ans;
    }
};",1420521328
unknown,u77,541,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        values = []
        
        def dfs(node):
            if not node:
                return False,0
            if not node.left and not node.right:
                values.append(1)
                return True,1
            is_left_perfect,left_count = dfs(node.left)
            is_right_perfect,right_count = dfs(node.right)
            
            is_perfect = is_left_perfect and is_right_perfect and left_count==right_count
            count = 1+left_count+right_count
            res = is_perfect, count
            if is_perfect:
                values.append(count)
            return res
                
        dfs(root)
        values.sort(reverse=True)
        return values[k-1] if k-1 < len(values) else -1",1420530253
unknown,u77,541,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        def f(a,b):
            if a==b:
                return 0
            # Alice beats bob
            if (a,b) in {(""F"",""E""), (""W"", ""F""), (""E"", ""W"")}:
                return -1
            return +1
        
        @cache
        def recurse(idx,balance,prev=""""):
            if idx==len(s):
                return +(balance > 0)
            
            res = 0
            alice_move = s[idx]
            ignore = '*'
            for bob_move in ""FWE"":
                if bob_move == prev:
                    continue
                result = f(alice_move, bob_move)
                res += recurse(idx+1, balance+result, bob_move)
            return res%(7+10**9)
            
        res = recurse(0,0)
        recurse.cache_clear()
        return res",1420551203
unknown,u77,541,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums)-k+1):
            A = sorted(nums[i:i+k], reverse=True)
            cc = collections.Counter(A).most_common(x)
            res.append(sum(k*v for k,v in cc))
        return res",1420563813
leetgoat_dot_dev,leetgoat_dot_dev,542,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        
        def dfs(node):
            # base case
            if not node:
                # print(f'base case, null, ret true and 0 size')
                return [True, 0]
            if not node.left and not node.right:
                # print(f'base case, leaf node, ret true and 1')
                sizes.append(1)
                return [True, 1]
            # print(f'dfs called on node={node.val}')


            
            leftIsPerfect, leftNodes = dfs(node.left)
            rightIsPerfect, rightNodes = dfs(node.right)
            # print(f'left nodes: {leftNodes}, right nodes: {rightNodes}')
            isPerfect = leftIsPerfect and rightIsPerfect
            # print(f'is perfect: {isPerfect} for node: {node.val}')
            size = leftNodes + rightNodes + 1
            # print(f'and size: {size}')
            if isPerfect and leftNodes == rightNodes:
                sizes.append(size)
            return [isPerfect and leftNodes == rightNodes, size]
        dfs(root)
        # print(f'sizes: {sizes}')
        if len(sizes) < k:
            return -1
        return sorted(sizes,reverse=True)[k - 1]
            
            ",1420526049
leetgoat_dot_dev,leetgoat_dot_dev,542,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def dp(i, bobSurplus, bobPrev):
            # base case
            if i == len(s):
                return 1 if bobSurplus > 0 else 0
            resHere = 0
            alice = s[i]
            

            if 'F' != bobPrev:
                if alice == 'W':
                    resHere += dp(i + 1, bobSurplus - 1, 'F') # BOB LOSE
                elif alice == 'F':
                    resHere += dp(i + 1, bobSurplus, 'F') # DRAW BOB
                else:
                    resHere += dp(i + 1, bobSurplus + 1, 'F') # BOB WIN
            if 'W' != bobPrev:
                if alice == 'W':
                    resHere += dp(i + 1, bobSurplus, 'W') # DRAW BOB
                elif alice == 'F':
                    resHere += dp(i + 1, bobSurplus + 1, 'W') # BOB WIN
                else:
                    resHere += dp(i + 1, bobSurplus - 1, 'W') # BOB LOSE
            if 'E' != bobPrev:
                if alice == 'W':
                    resHere += dp(i + 1, bobSurplus + 1, 'E') # BOB WIN
                elif alice == 'F':
                    resHere += dp(i + 1, bobSurplus - 1, 'E') # BOB LOSE
                else:
                    resHere += dp(i + 1, bobSurplus, 'E') # DRAW BOB
            return resHere % (10**9 + 7)
        r = dp(0, 0, None)
        dp.cache_clear()
        return r % (10**9 + 7)",1420545310
leetgoat_dot_dev,leetgoat_dot_dev,542,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        c = Counter(nums)
        
        def solve(subarray):
            freq = Counter(subarray)
            sortedA = sorted(subarray, key=lambda x: (freq[x], x), reverse=True)
            # uniqueC = Counter()
            # for num in sortedA:
            #     uniqueC[num] += 1
            # resorted = list(uniqueC.keys())
            # print(f'sorteda: {sortedA}')
            # print(f'resorted: {resorted}')
            
            resHere = 0
            seen = set()
            for num in sortedA:
                seen.add(num)
                if len(seen) > x:
                    return resHere
                resHere += num
            return resHere
            if len(sortedA) < x:
                return sum(freq[val] * val for val in sortedA)
            return sum(freq[val] * val for val in sortedA[:x])
        
        res = []
        l = 0
        r = k - 1
        while r < len(nums):
            subarray = nums[l:r+1]
            # print(f'subarray: {subarray}')
            ans = solve(subarray)
            res.append(ans)
            l += 1
            r += 1
        return res",1420538003
u1904123,u1904123,543,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> perfectSubtreeSizes;

    int dfs(TreeNode* root) {
        if (!root) return 0;
        
        int leftSize = dfs(root->left);
        int rightSize = dfs(root->right);
        
        if ((leftSize == rightSize) || (root->left == nullptr && root->right == nullptr)) {
            int totalSize = leftSize + rightSize + 1;
            perfectSubtreeSizes.push_back(totalSize);
            return totalSize;
        }
        
        return -1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        sort(perfectSubtreeSizes.rbegin(), perfectSubtreeSizes.rend());
        if (k > perfectSubtreeSizes.size()) return -1;
        return perfectSubtreeSizes[k - 1];
    }
};
",1420539253
u1904123,u1904123,543,3588,cpp,"#define mod 1000000007
class Solution {
public:
    int dp[1005][2005][4];
    
    int func(int ind, int st, int sp, string &s) {
        if(ind >= s.size()){
            if(st > 1000) return 1;
            else return 0; 
        }
        if(dp[ind][st][sp] != -1) return dp[ind][st][sp];
        
        int ans = 0;
        if(s[ind] == 'F'){
            if(sp == 1){
                ans = (ans + func(ind + 1, st - 1, 3, s)) % mod;
                ans = (ans + func(ind + 1, st + 1, 2, s)) % mod;
            }
            else if(sp == 2){
                ans = (ans + func(ind + 1, st - 1, 3, s)) % mod;
                ans = (ans + func(ind + 1, st, 1, s)) % mod;
            }
            else if(sp == 3){
                ans = (ans + func(ind + 1, st, 1, s)) % mod;
                ans = (ans + func(ind + 1, st + 1, 2, s)) % mod;
            }
            else{
                ans = (ans + func(ind + 1, st, 1, s)) % mod;
                ans = (ans + func(ind + 1, st - 1, 3, s)) % mod;
                ans = (ans + func(ind + 1, st + 1, 2, s)) % mod;
            }
        }
        else if(s[ind] == 'W'){
            if(sp == 1){
                ans = (ans + func(ind + 1, st, 2, s)) % mod;
                ans = (ans + func(ind + 1, st + 1, 3, s)) % mod;
            }
            else if(sp == 2){
                ans = (ans + func(ind + 1, st - 1, 1, s)) % mod;
                ans = (ans + func(ind + 1, st + 1, 3, s)) % mod;
            }
            else if(sp == 3){
                ans = (ans + func(ind + 1, st - 1, 1, s)) % mod;
                ans = (ans + func(ind + 1, st, 2, s)) % mod;
            }
            else{
                ans = (ans + func(ind + 1, st, 2, s)) % mod;
                ans = (ans + func(ind + 1, st - 1, 1, s)) % mod;
                ans = (ans + func(ind + 1, st + 1, 3, s)) % mod;
            }
        }
        else{
            if(sp == 1){
                ans = (ans + func(ind + 1, st, 3, s)) % mod;
                ans = (ans + func(ind + 1, st - 1, 2, s)) % mod;
            }
            else if(sp == 2){
                ans = (ans + func(ind + 1, st + 1, 1, s)) % mod;
                ans = (ans + func(ind + 1, st, 3, s)) % mod;
            }
            else if(sp == 3){
                ans = (ans + func(ind + 1, st + 1, 1, s)) % mod;
                ans = (ans + func(ind + 1, st - 1, 2, s)) % mod;
            }
            else{
                ans = (ans + func(ind + 1, st, 3, s)) % mod;
                ans = (ans + func(ind + 1, st - 1, 2, s)) % mod;
                ans = (ans + func(ind + 1, st + 1, 1, s)) % mod;
            }
        }
        return dp[ind][st][sp] = ans % mod;
    }
    
    int countWinningSequences(string s) {
        memset(dp, -1, sizeof(dp));
        return func(0, 1000, 0, s);
    }
};
",1420564201
u1904123,u1904123,543,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int>ans;
        for(int i = 0; i <= n - k; i++){
            map<int, int>m;
            for(int j = i; j < i + k; j++){
                m[nums[j]]++;
            }
            vector<pair<int, int>>v;
            for(int j = 1; j <= 50; j++){
                if(m[j]) v.push_back({m[j], j});
            }
            sort(v.begin(), v.end());
            int p = x, sum = 0;
            for(int j = v.size() - 1; j >= 0; j--){
                //cout << i << "" "" << v[j].first << "" "" << v[j].second << endl;
                sum += v[j].first * v[j].second;
                p--;
                if(p == 0) break;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420522695
Rahul Ahuja,RahulAhuja2901,546,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution
{
    public int getAllSizes(TreeNode node, ArrayList<Integer> sizes)
    {
        if (node == null)
        {
            return 0;
        }
        int leftSize = getAllSizes(node.left, sizes);
        int rightSize = getAllSizes(node.right, sizes);
        if (leftSize != -1 && rightSize != -1 && leftSize == rightSize)
        {
            int size = leftSize + rightSize + 1;
            sizes.add(size);
            return size;
        }
        return -1;
    }
    public int kthLargestPerfectSubtree(TreeNode root, int k)
    {
        ArrayList<Integer> sizes = new ArrayList<Integer>();
        getAllSizes(root, sizes);
        Collections.sort(sizes, Collections.reverseOrder());
        int size = sizes.size();
        if (k - 1 < size)
        {
            return sizes.get(k - 1);
        }
        return -1;
    }
}",1420540366
Rahul Ahuja,RahulAhuja2901,546,3588,java,"class Solution
{
    public long recursion(int ind, int score, int prev, int n, String s, long mod, long[][][] dp)
    {
        if (ind == n)
        {
            if (score > n)
            {
                return 1;
            }
            return 0;
        }
        if (dp[ind][score][prev] != -1)
        {
            return dp[ind][score][prev];
        }
        char ch = s.charAt(ind);
        long numOfWays = 0;
        for (int move=0;move<=2;move++)
        {
            if (move == prev)
            {
                continue;
            }
            if (move == 0)
            {
                if (ch == 'F')
                {
                    numOfWays += recursion(ind + 1, score, move, n, s, mod, dp);
                }
                else if (ch == 'E')
                {
                    numOfWays += recursion(ind + 1, score + 1, move, n, s, mod, dp);
                }
                else
                {
                    numOfWays += recursion(ind + 1, score - 1, move, n, s, mod, dp);
                }
            }
            if (move == 1)
            {
                if (ch == 'W')
                {
                    numOfWays += recursion(ind + 1, score, move, n, s, mod, dp);
                }
                else if (ch == 'F')
                {
                    numOfWays += recursion(ind + 1, score + 1, move, n, s, mod, dp);
                }
                else
                {
                    numOfWays += recursion(ind + 1, score - 1, move, n, s, mod, dp);
                }
            }
            if (move == 2)
            {
                if (ch == 'E')
                {
                    numOfWays += recursion(ind + 1, score, move, n, s, mod, dp);
                }
                else if (ch == 'W')
                {
                    numOfWays += recursion(ind + 1, score + 1, move, n, s, mod, dp);
                }
                else
                {
                    numOfWays += recursion(ind + 1, score - 1, move, n, s, mod, dp);
                }
            }
        }
        return dp[ind][score][prev] = numOfWays % mod;
    }
    public int countWinningSequences(String s)
    {
        long mod = (long)1e9 + 7;
        int n = s.length();
        long[][][] dp = new long[n][2 * n + 1][4];
        for (int i=0;i<n;i++)
        {
            for (int j=0;j<=2*n;j++)
            {
                for (int k=0;k<4;k++)
                {
                    dp[i][j][k] = -1;
                }
            }
        }
        return (int)recursion(0, n, 3, n, s, mod, dp);
    }
}",1420558275
Rahul Ahuja,RahulAhuja2901,546,3610,java,"class Solution
{
    public int getXSum(int i, int k, int x, int[] nums)
    {
        int j = i + k - 1;
        int[] freq = new int[51];
        for (int ind=i;ind<=j;ind++)
        {
            freq[nums[ind]]++;
        }
        int xsum = 0;
        while (x > 0)
        {
            x--;
            int maxFreq = -1, index = -1;
            for (int ind=50;ind>0;ind--)
            {
                if (freq[ind] > maxFreq)
                {
                    maxFreq = freq[ind];
                    index = ind;
                }
            }
            xsum += index * maxFreq;
            freq[index] = 0;
        }
        return xsum;
    }
    public int[] findXSum(int[] nums, int k, int x)
    {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        for (int ind=0;ind<n;ind++)
        {
            if (ind + k - 1 >= n)
            {
                break;
            }
            ans[ind] = getXSum(ind, k, x, nums);
        }
        return ans;
    }
}",1420526390
angel30818,angel30818,547,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        
        def dfs(node):
            if not node:
                return 0 # its depth
            
            l = dfs(node.left)
            r = dfs(node.right)
            
            # if left/right hand side is valid
            if l == -1 or r == -1:
                return -1
            
            # if left depth == right depth
            if l != r:
                return -1
            
            # if it is valid
            res.append(l+1)
            
            return l + 1   # depth
        
        dfs(root)
        
        res.sort(reverse = True)
        # print(res, k)
        
        if len(res) < k:
            return -1
        
        return 2**(res[k-1])-1
        
            ",1420532881
angel30818,angel30818,547,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        # dp (pos, score, last)
        # dp = []
        # for p in range(len(s)):
        MOD = (10**9+7)
        n = len(s)
        
        @cache
        def dp(pos, score, last): # score gap, positive is bob win
            
            if pos == len(s):
                # Bob wins if the score is positive
                return 1 if score > 0 else 0
            
            if score > n or score < -n:
                return 0
            
            # Alice's position
            alice = s[pos]
            ops = 0
                        
            # next position can not be the same as alice
            for nxt in ""WFE"":
     
                if nxt == last: continue
                    
                # bob win
                if alice + nxt in [""FW"", ""EF"", ""WE""]:
                    # can not be the last position
                        
                    ops += dp(pos + 1, score + 1, nxt)
                    
                elif alice + nxt in [""FF"", ""EE"", ""WW""]:
                    ops += dp(pos + 1, score, nxt)
                    
                elif alice + nxt in [""WF"", ""FE"", ""EW""]:
                    ops += dp(pos + 1, score-1, nxt)
            
            #print(f""{pos=}, {score=}, {last=}"")
            #print(ops)
            #print(""---------------"")
            return ops % MOD
        
        # get all possible scores
        res = 0
        
        maxx, minn = len(s), -len(s)
        
        # if alice always win, score is len(s)
        res += dp(0, 0, """")
            
        return res
                
                
            
            ",1420564341
angel30818,angel30818,547,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        for i in range(len(nums)-k+1):
            subarr = nums[i:(i+k)]
            cnt = collections.Counter(subarr)
            freq = []
            for key in cnt:
                freq.append([cnt[key], key])
            freq.sort(reverse = True)
            freq = freq[:x]
            summ = 0
            #print(subarr)
            #print(f""{freq=}"")
            for c, key in freq:
                summ += key * c
            #print(f""{i=}"")
            #print(""-------------"")
            res.append(summ)
            
        return res",1420524472
FighterNan,FighterNanReborn,548,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
  unordered_map<TreeNode*, int> node_to_tree_size;
  int GetSize(TreeNode* root) {
    if (root == nullptr) {
      return 0;
    }
    node_to_tree_size[root] = 1 + GetSize(root->left) + GetSize(root->right);
    return node_to_tree_size[root];
  }
  vector<int> perfect_sizes;
  bool IsPerfectBinaryTree(TreeNode* root) {
    if (root == nullptr) {
      return true;
    }
    int left_size = 0;
    if (root->left != nullptr) {
      left_size = node_to_tree_size[root->left];
    }
    int right_size = 0;
    if (root->right != nullptr) {
      right_size = node_to_tree_size[root->right];
    }
    bool left_perfect = IsPerfectBinaryTree(root->left);
    bool right_perfect = IsPerfectBinaryTree(root->right);
    bool curr_perfect = left_perfect && right_perfect && left_size == right_size;
    if (curr_perfect) {
      perfect_sizes.push_back(node_to_tree_size[root]);
    }
    return curr_perfect;
  }
  int kthLargestPerfectSubtree(TreeNode* root, int k) {
    GetSize(root);
    IsPerfectBinaryTree(root);
    sort(perfect_sizes.begin(), perfect_sizes.end());
    reverse(perfect_sizes.begin(), perfect_sizes.end());
    if (perfect_sizes.size() < k) {
      return -1;
    }
    return perfect_sizes[k - 1];
  }
};",1420530879
FighterNan,FighterNanReborn,548,3588,cpp,"// int b, char prev
// 

using ll = long long;
constexpr ll kMod = 1000'000'007;
constexpr std::array<char, 3> kCands = {'F', 'W', 'E'};

ll alg[1005][2005][5];
bool visited[1005][2005][5];
class Solution {
public:
  string s;

  int CharToInt(char ch) {
    if (ch == 'F') {
      return 0;
    } else if (ch == 'W') {
      return 1;
    }
    return 2;
  }
  // 'F' > 'E'
  // 'W' > 'F'
  // 'E' > 'W'

  int Diff(char b_curr, char a_curr) {
    if (b_curr == 'F' && a_curr == 'E') {
      return 1;
    } else if (a_curr == 'F' && b_curr == 'E') {
      return -1;
    } else if (b_curr == 'W' && a_curr == 'F') {
      return 1;
    } else if (a_curr == 'W' && b_curr == 'F') {
      return -1;
    } else if (b_curr == 'E' && a_curr == 'W') {
      return 1;
    } else if (a_curr == 'E' && b_curr == 'W') {
      return -1;
    }
    return 0;
  }

  ll Dfs(int i, int b, char prev) {
    if (visited[i][b + 1000][CharToInt(prev)]) {
      return alg[i][b + 1000][CharToInt(prev)];
    }
    if (i == s.size()) {
      int res = b > 0;
      alg[i][b + 1000][CharToInt(prev)] = res;
      visited[i][b + 1000][CharToInt(prev)] = true;
      return res;
    }
    ll res = 0;
    char a_curr = s[i];
    
    for (char b_curr : kCands) {
      if (b_curr == prev) {
        continue;
      }
      int new_b = b + Diff(b_curr, a_curr);
      res += Dfs(i + 1, new_b, b_curr);
      res %= kMod;
    }

    alg[i][b + 1000][CharToInt(prev)] = res;
    visited[i][b + 1000][CharToInt(prev)] = true;
    return res;
  }


  int countWinningSequences(string s) {
    this->s = s;
    memset(visited, 0, sizeof(visited));
    memset(alg, 0, sizeof(alg));

    ll res = 0;
    for (char b_curr : kCands) {
      res += Dfs(1, 0 + Diff(b_curr, s[0]), b_curr);
      res %= kMod;
    }

    return res;
  }
};",1420564409
FighterNan,FighterNanReborn,548,3610,cpp,"class Solution {
public:
  vector<int> findXSum(vector<int>& nums, int k, int x) {
    vector<int> res;
    int n = nums.size();
    for (int i = 0; i + k <= n; ++i) {
      unordered_map<int, int> num_to_cnt;
      for (int j = i; j < i + k && j < n; ++j) {
        num_to_cnt[nums[j]]++;
      }
      vector<pair<int, int>> cnt_num;
      for (auto [num, cnt] : num_to_cnt) {
        cnt_num.push_back({cnt, num});
      }
      sort(cnt_num.begin(), cnt_num.end());
      reverse(cnt_num.begin(), cnt_num.end());
      int sum = 0;
      for (int j = 0; j < x && j < cnt_num.size(); ++j) {
        sum += cnt_num[j].first * cnt_num[j].second;
      }
      res.push_back(sum);
    }
    return res;
  }
};",1420522529
evanchun,evanchun,549,3509,rust,"// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
// 
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
pub fn kth_largest_perfect_subtree(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {
    use std::collections::BinaryHeap;
    use std::cmp::Reverse;

    fn dfs(root: Option<Rc<RefCell<TreeNode>>>, topk: &mut BinaryHeap<Reverse<i32>>, tot: &mut i32, k: usize) -> (bool, i32) {
        let Some(node) = root else {
            return (true, 0);
        };

        let b = node.borrow();
        
        let (lok, lsz) = dfs(b.left.clone(), topk, tot, k);
        let (rok, rsz) = dfs(b.right.clone(), topk, tot, k);

        if lok && rok && lsz == rsz {
            topk.push(Reverse(1 + lsz + rsz));

            if topk.len() > k {
                topk.pop();
            }

            *tot += 1;

            return (true, lsz + 1 + rsz);
        }

        (false, 69)
    }

    let mut topk = BinaryHeap::new();
    let mut tot = 0;

    dfs(root, &mut topk, &mut tot, k as usize);

    //println!(""{:?} {}"", topk, tot);

    if tot < k {
        return -1;
    }

    topk.pop().unwrap_or(Reverse(-1)).0
}
}",1420538893
evanchun,evanchun,549,3588,rust,"impl Solution {
pub fn count_winning_sequences(s: String) -> i32 {
    type U = usize;

    let s: Vec<U> = s.chars().map(|c| {
        match c {
            'F' => 0,
            'W' => 1,
            'E' => 2,
            _ => unreachable!(),
        }
    }).collect();

    fn f(s: &Vec<U>, i: U, prev: U, hp: U, dp: &mut Vec<[[i32; 4]; 2000]>) -> i32 {
        if i >= s.len() {
            if hp > 1000 {
                return 1;
            }

            return 0;
        }

        if dp[i][hp][prev] != -1 {
            return dp[i][hp][prev];   
        }

        let mut ans = 0;

        for next in 0..3 {
            if next == prev {
                continue;
            }

            const MOD: i32 = 10i32.pow(9) + 7;

            if (s[i] == 0 && next == 1) || (s[i] == 1 && next == 2) || (s[i] == 2 && next == 0) {
                ans += f(s, i + 1, next, hp + 1, dp) % MOD;
                ans %= MOD;
            } else if s[i] == next {
                ans += f(s, i + 1, next, hp, dp) % MOD;
                ans %= MOD;
            } else {
                ans += f(s, i + 1, next, hp - 1, dp) % MOD;
                ans %= MOD;
            }
        }

        dp[i][hp][prev] = ans;
        ans
    }

    let mut dp = vec![[[-1; 4]; 2000]; s.len()];
    f(&s, 0, 3, 1000, &mut dp)
}
}",1420564412
evanchun,evanchun,549,3610,rust,"impl Solution {
pub fn find_x_sum(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {
    let k = k as usize;
    let sz = nums.len() - k + 1;
    let mut ans = Vec::with_capacity(sz);

    for i in 0..sz {
        use std::collections::HashMap;
        let mut freq = HashMap::new();

        for j in i..(i + k) {
            *freq.entry(nums[j]).or_insert(0) += 1;
        }

        let mut freq: Vec<(i32, i32)> = freq.into_iter().collect();
        freq.sort_by_key(|&(k, v)| (v, k));

        let mut sum = 0;

        for _ in 0..x {
            if let Some((t, d)) = freq.pop() {
                sum += t * d;
            }
        }

        ans.push(sum);
    }

    ans
}
}",1420523216
Heap Spray,HeapSpray,550,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, treeRoot: Optional[TreeNode], k: int) -> int:
        def solve(root):
            if not root:
                return True, 0
            if not root.left and not root.right:
                return True, 0
            if root.left and root.right:
                leftPerfect, leftH = solve(root.left)
                rightPerfect, rightH = solve(root.right)

                if leftPerfect and rightPerfect and leftH == rightH:
                    return True, 1 + leftH

            return False, 0
        arr = []
        def helper(root):
            if not root:
                return 0
            perfect, h = solve(root)
            if perfect:
                size = (1 << (h + 1)) - 1
                arr.append(size)
            helper(root.left)
            helper(root.right)
        helper(treeRoot)
        arr.sort(reverse=True)
        if len(arr) < k:
            return -1
        return arr[k-1]",1420541441
Heap Spray,HeapSpray,550,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        def isWin(alice, bob):
            if alice == 'F' and bob == 'W':
                return True
            if alice == 'W' and bob == 'E':
                return True
            if alice == 'E' and bob == 'F':
                return True                
            return False
        res = 0
        mod = 7 + 10**9
        plays = ['F', 'W', 'E']
        @cache
        def solve(prevPlay, points, idx):
            subRes = 0
            if idx>= len(s):
                return 1 if points>0 else 0
            for play in plays:
                if play != prevPlay:
                    if play == s[idx]:
                        subRes += solve(play, points, idx+1)
                    else:
                        if isWin(s[idx], play):
                            subRes += solve(play, points+1, idx+1)
                        else:
                            subRes += solve(play, points-1, idx+1)
            return subRes % mod
        
        return solve('Z', 0, 0) % mod
                    
                        
                

        return res 


'''
197576205
dragon > golem
serpent > dragon
golem > serpent
'''",1420558426
Heap Spray,HeapSpray,550,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def solve(arr):
            counter = Counter(arr)
            a = [(-1*counter[val], -1*val) for val in counter]
            heapq.heapify(a)
            subRes = 0
            i = 0

            while a and i < x:
                freq, val = heapq.heappop(a)
                freq *= -1
                val *= -1

                subRes += freq * val
                i+=1

            return subRes
        n = len(nums)
        ans = [0] * (len(nums)-k+1)
        for i in range(n-k+1):
            subarr = nums[i:i+k]
            ans[i] = solve(subarr)
        return ans",1420531115
renol,renol,551,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> Integer.compare(b , a));

        recur(root, pq);
        //System.out.println(pq);

        while(!pq.isEmpty() && k > 1) {
            pq.poll();
            k--;
        }
        if(pq.isEmpty()) return -1;
        return pq.poll();
    }

    int recur(TreeNode root, PriorityQueue<Integer> pq) {
        if(root == null) return 0;

        int left = recur(root.left, pq);
        int right = recur(root.right, pq);

        if(left == -1 || right == -1 || left != right) return -1;

        int size = left + right + 1;
        pq.offer(size);
        return size;
    }
}",1420523529
renol,renol,551,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        int mod = (int)(1e9 + 7);
        int[][][] dp = new int[s.length()][2002][3];
        for(int i = 0; i < s.length(); i++) {
            for(int j = 0; j < 2000; j++) {
                Arrays.fill(dp[i][j], -1);
            }
        }
        return (int)recur(s, 0, 0, -1, mod, dp);
    }

    long recur(String s, int i, int score, int last, int mod, int[][][] dp) {
        if(s.length() == i){
            if(score > 0) return 1;
            return 0;
        }

        if(last != -1 && dp[i][score + 1000][last] != -1) return dp[i][score + 1000][last];

        long totalWays = 0;

        char alice = s.charAt(i);
        int aliceInt = 0;
        if(alice == 'W') aliceInt = 1;
        if(alice == 'E') aliceInt = 2;

        for(int j = 0; j < 3; j++) {
            if(j == last) continue;
            if(aliceInt == j) {
                totalWays += recur(s, i + 1, score, j, mod, dp);
                totalWays %= mod;
            } else {
                if(bobWins(aliceInt, j)) totalWays += recur(s, i + 1, score + 1, j, mod, dp);
                else totalWays += recur(s, i + 1, score - 1, j, mod,dp);
                totalWays %= mod;
            }
        }

        int ret = (int)(totalWays % mod);
        if(last != -1) dp[i][score + 1000][last] = ret;

        return ret;
    }

    boolean bobWins(int alice, int bob) {
        if(alice == 0) {
            if(bob == 1) return true;
            else return false;
        } else if (alice == 1) {
            if(bob == 2) return true;
            else return false;
        } else {
            if(bob == 0) return true;
            else return false;
        }
    }
}",1420564714
renol,renol,551,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ret = new int[n - k + 1];

        for(int i = 0; i < ret.length; i++) {
            ret[i] = findAns(nums, i, i + k - 1, x);
        }

        return ret;
    }

    int findAns(int[] nums, int i, int j, int x) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int k = i; k <= j; k++) {
            map.put(nums[k], map.getOrDefault(nums[k], 0) + 1);
        }

        //System.out.println(map);

        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if(b[1] == a[1]) return Integer.compare(b[0], a[0]);
            return Integer.compare(b[1], a[1]);
        });

        for(Map.Entry<Integer, Integer> e: map.entrySet()) {
            int key = e.getKey();
            int val = e.getValue();
            pq.offer(new int[]{key, val});
        }

        int ans = 0;
        while(!pq.isEmpty() && x > 0) {
            int[] got = pq.poll();
            ans += got[0] * got[1];
            x--;
        }

        return ans;
    }
}",1420537651
Sleepy Fellow,hypothecate,552,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int>res;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        find(root);
        sort(res.rbegin(), res.rend());
        // for(int c: res) {
        //     cout<<c<<"" "";
        // }
        // cout<<endl;
        if(res.size()<k) return -1;
        return res[k-1];
    }

    pair<bool,int> find(TreeNode* node) {
        if(!node) return {true,0};
        pair<bool,int> left = find(node->left);
        pair<bool,int> right = find(node->right);

        if(left.first && right.first && (left.second == right.second)) {
            res.push_back(left.second+1+right.second);
            return {true, left.second+1+right.second};
        }
        return {false, -1};
    }
};",1420538475
Sleepy Fellow,hypothecate,552,3588,cpp,"class Solution {
public:
    #define ll long long
    ll dp[1001][2001][3];
    ll mod = 1e9+7;
    map<char,int>mp;
    int win(int a, int b) {
        if(a==b) return 0;
        else {
            if(a==0 && b==2) return 1;
            else if(a==1 && b==0) return 1;
            else if(a==2 && b==1) return 1;
            return -1;
        }
    }
    int countWinningSequences(string s) {
        memset(dp,-1,sizeof(dp));
        mp['F'] = 0;
        mp['W'] = 1;
        mp['E'] = 2;

        ll sum=0;
        for(int i=0;i<3;i++) {
            sum=(sum+find(s,win(i,mp[s[0]]) + 1000,1, i))%mod;
            // cout<<find(s,win(i,mp[s[0]]) + 1000,1, i)<<"" "";
        }
        return sum;
    }

    ll find(string &s, int count, int idx, int last) {
        if(idx>(s.length()-1)) {
            if(count > 1000) return 1;
            else return 0;
        }

        if(dp[idx][count][last]!=-1) return dp[idx][count][last];
        dp[idx][count][last]=0;
        for(int i=0;i<3;i++){
            if(i==last) continue;
            dp[idx][count][last]=(dp[idx][count][last] + find(s,count+win(i,mp[s[idx]]), idx+1, i))%mod;
        }
        return dp[idx][count][last];
    }
};",1420564743
Sleepy Fellow,hypothecate,552,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int>res;
        int n=nums.size();
        for(int i=0;i<n-k+1;i++) {
            res.push_back(find(nums,i,k,x));
        }
        return res;
    }

    int find(vector<int>&v, int i,int k,int x) {
        map<int,int>mp;
        int sum=0;
        // cout<<i<<"" ""<<i+k-1<<endl;
        for(int j=i;j<=i+k-1;j++) {
            mp[v[j]]++;
            sum+=v[j];
        }
        if(mp.size()<x) {
            return sum;
        }
        vector<pair<int,int>>temp;
        for(auto &c: mp) {
            temp.push_back({c.first, c.second});
        }

        sort(temp.begin(), temp.end(), [](const pair<int,int>a, const pair<int,int>b) {
            if(a.second==b.second) {
                return a.first>b.first;
            }
            return a.second>b.second;
        });
        sum=0;
        for(auto &c: temp) {
            if(x==0) return sum;
            sum+=c.first*c.second;
            x--;
        }
        return sum;
    }
};",1420527437
Shannon Lis,shannonl,554,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<TreeNode*, int> sz;
    unordered_map<TreeNode*, bool> perfect;
    unordered_map<TreeNode*, int> perfectCount;
    vector<int> ans;
    
    void dfs(TreeNode* cur) {
        if (!cur->left && !cur->right) {
            sz[cur] = 1;
            perfect[cur] = true;
            perfectCount[cur] = 1;
            ans.push_back(1);
            return ;
        }
        sz[cur] = 1;
        if (cur->left) { 
            dfs(cur->left) ;
            sz[cur] += sz[cur->left];
        }
        if (cur->right) { 
            dfs(cur->right) ;
            sz[cur] += sz[cur->right];
        }
        perfect[cur] = perfect[cur->left] && perfect[cur->right] && (sz[cur->left] == sz[cur->right]);
        perfectCount[cur] =  perfectCount[cur->left] + perfectCount[cur->right];
        if (perfect[cur]) {
            perfectCount[cur]  += 1;
            ans.push_back(sz[cur]);
        }
    }
    
    int k;
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        this->k = k;
        sz[nullptr] = 0;
        perfect[nullptr] = false;
        perfectCount[nullptr] = 0;
        dfs(root);
        sort(ans.rbegin(), ans.rend());
        // for (int x : ans) cout << x <<"" "";
        // cout << endl;
        return k-1 < ans.size() ? ans[k-1] : -1;
    }
};",1420541623
Shannon Lis,shannonl,554,3588,cpp,"class Solution {
public:
    using LL = long long;
    const int MOD = 1e9+7;
    int countWinningSequences(string s) {
        string FWE = ""FWE"";
        unordered_map<char, unordered_map<char, int>> gain; // bob alice score
        gain['F']['E'] = 1;
        gain['F']['F'] = 0;
        gain['F']['W'] = -1;
        gain['W']['F'] = 1;
        gain['W']['W'] = 0;
        gain['W']['E'] = -1;
        gain['E']['F'] = -1;
        gain['E']['W'] = 1;
        gain['E']['E'] = 0;
        
        
        int n = s.size();
        s = ""#"" + s;
        LL dp[n+1][2005][3];
        memset(dp, 0, sizeof(dp));
        int OFFSET = 1001;
        dp[0][OFFSET][0] = 0;
        dp[0][OFFSET][1] = 1;
        dp[0][OFFSET][2] = 0;
        // [-1001, 1001]
        // [0, 2000]
        for (int i=1; i<=n; i++) {
            for (int j=-1000; j<=1000; j++) {
                for (int k=0; k < 3; k++) {
                    int g = gain[FWE[k]][s[i]];
                    dp[i][j+OFFSET][k] = dp[i-1][j-g+OFFSET][(k+1)%3] + dp[i-1][j-g+OFFSET][(k+2)%3];
                    if (i == 1) dp[i][j+OFFSET][k] += dp[i-1][j-g+OFFSET][k];
                    dp[i][j+OFFSET][k]  %= MOD;
                }
            }
        }
        LL ans = 0;
        for (int j=1; j<=1000; j++)
            for (int k=0; k<3; k++) {
                ans += dp[n][j+OFFSET][k];
                ans %= MOD;
            }
        return ans;
    }
};",1420564807
Shannon Lis,shannonl,554,3610,cpp,"class Solution {
public:
    using PII = pair<int,int>;
    int xsum(vector<int>& nums, int a, int b, int x) {
        unordered_map<int, int> cnt;
        // for (int x: nums) cnt[x]++;
        for (int i=a; i<=b; i++) cnt[nums[i]]++;
        vector<PII> A;
        for (auto[val, c]: cnt) A.push_back({c, val});
        sort(A.rbegin(), A.rend());
        int ans = 0;
        for (int i=0; i<A.size() && i < x; i++) {
            ans += A[i].first * A[i].second;
        }
        return ans;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int>ans;
        int n = nums.size();
        for (int i=0; i+k-1<n; i++) {
            ans.push_back(xsum(nums, i, i+k-1, x));
        }
        return ans;
    }
};",1420521260
Googlehsiehh,Googlehsiehh,555,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        dfs(root, 0);
        int cnt = 0;
        int res = -1;
        while (cnt != k && !pq.isEmpty()) {
            int cur = pq.poll();
            cnt++;
            if (cnt == k) {
                res = cur;
            }
        }
        return res;
    }
    
    // returns [is_perfect, leaf_level, size]
    private int[] dfs(TreeNode root, int level) {
        if (root == null) {
            return new int[] {1, level, 0};
        }
        int[] left = dfs(root.left, level + 1);
        int[] right = dfs(root.right, level + 1);
        if (left[0] == 0 || left[1] == 0) {
            return new int[] {0, -1, 0};
        }
        if (left[1] != right[1]) {
            return new int[] {0, -1, 0};
        }
        int size = left[2] + right[2] + 1;
        pq.offer(size);
        return new int[] {1, left[1], size};
    }
}",1420531775
Googlehsiehh,Googlehsiehh,555,3588,java,"class Solution {
    int mod = 1000000007;
    Long[][][] dp;
    public int countWinningSequences(String s) {
        dp = new Long[s.length()][4][s.length() * 2 + 1];
        //int minP = m / 2 + 1;
        long res = dfs(s, 0, -1, 0);
        return (int)res;
    }

    private long dfs(String s, int index, int prev, int delta) {

        if (index == s.length()) {
            int res = delta > 0 ? 1 : 0;
            //System.out.println(index + "" "" + prev + "" "" + res + "" "" + 1);
            return res;
        }
        //System.out.println(index + "" "" + prev + "" "" + delta);
        if (dp[index][prev + 1][delta + s.length()] != null) {
            return dp[index][prev + 1][delta + s.length()];
        }
        char ch = s.charAt(index);


        long res = 0;

        // E
        if (prev != 0) {
            int curPoint1 = getPoint(ch, 'E');
            long next1 = dfs(s, index + 1, 0, delta + curPoint1);
            res = (res + next1) % mod;
        }
        // F
        if (prev != 1) {
            int curPoint2 = getPoint(ch, 'F');
            long next2 = dfs(s, index + 1, 1, delta + curPoint2);
            res = (res + next2) % mod;
        }

        if (prev != 2) {
            // W
            int curPoint3 = getPoint(ch, 'W');
            long next3 = dfs(s, index + 1, 2, delta + curPoint3);
            res = (res + next3) % mod;
        }
        //System.out.println(index + "" "" + prev + "" "" + delta + "" "" + res);
        return dp[index][prev + 1][delta + s.length()] = res;
    }

    private int getPoint(char ch1, char ch2) {
        if (ch1 == 'E' && ch2 == 'F') {
            return 1;
        }
        if (ch1 == 'E' && ch2 == 'W') {
            return -1;
        }
        if (ch1 == 'F' && ch2 == 'W') {
            return 1;
        }
        if (ch1 == 'F' && ch2 == 'E') {
            return -1;
        }
        if (ch1 == 'W' && ch2 == 'F') {
            return -1;
        }
        if (ch1 == 'W' && ch2 == 'E') {
            return 1;
        }
        
        return 0;
    }
}",1420564825
Googlehsiehh,Googlehsiehh,555,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int m = nums.length;
        int[] res = new int[m - k + 1];
        for (int i = 0; i + k - 1 < m; i++) {
            res[i] = findSum(nums, i, i + k - 1, x);
        }
        return res;
    }
    
    private int findSum(int[] nums, int start, int end, int x) {
        Map<Integer, Integer> cnts = new HashMap<>();
        for (int i = start; i <= end; i++) {
            int val = nums[i];
            cnts.put(val, cnts.getOrDefault(val, 0) + 1);
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if (a[1] == b[1]) {
                return a[0] > b[0] ? -1 : 1;
            }
            return a[1] > b[1] ? -1 : 1;
        });
        
        for (var entry : cnts.entrySet()) {
            pq.offer(new int[] {entry.getKey(), entry.getValue()});
        }
        int res = 0;
        int cnt = 0;
        while (cnt < x && !pq.isEmpty()) {
            int[] cur = pq.poll();
            res += cur[0] * cur[1];
            cnt++;
        }
        return res;
    }
}",1420524535
Aditya Dargan,AdityaDargan,556,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    int dfs(TreeNode* node){
        if(node==NULL){
            return 0;
        }
        int left = dfs(node->left);
        int right = dfs(node->right);
        if(left==-1 || right==-1)return -1;
        if(left==right){
            int temp = 1<<(left+1);
            temp-=1;
            ans.push_back(temp);
            return left+1;
        }
        return -1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        ans.clear();
        dfs(root);
        sort(ans.begin(),ans.end());
        reverse(ans.begin(),ans.end());
        if(k>int(ans.size())){
            return -1;
        }
        return ans[k-1];
    }
};",1420530831
Aditya Dargan,AdityaDargan,556,3588,cpp,"class Solution {
public:
    #define ll long long 
    #define mod 1000000007
    vector<vector<vector<ll>>> dp;
    
    ll solve(ll i,ll prev,ll score, string &s){
        int n = s.length();
        if(i==n){
            if(score>0)return 1;
            return 0;
        }
        if(dp[i][prev][score+1000]!=-1){
            return dp[i][prev][score+1000];
        }
        
        ll ans = 0;
        for(int j=0;j<3;j++){
            if(prev==j)continue;
            if(j==0){
                if(s[i]=='F'){
                    ans += solve(i+1,0,score,s);
                }
                else if(s[i]=='W'){
                    ans += solve(i+1,0,score-1,s);
                }
                else if(s[i]=='E'){
                    ans += solve(i+1,0,score+1,s);
                }
            }
            if(j==1){
                if(s[i]=='F'){
                    ans += solve(i+1,1,score+1,s);
                }
                else if(s[i]=='W'){
                    ans += solve(i+1,1,score,s);
                }
                else if(s[i]=='E'){
                    ans += solve(i+1,1,score-1,s);
                }
            }
            if(j==2){
                if(s[i]=='F'){
                    ans += solve(i+1,2,score-1,s);
                }
                else if(s[i]=='W'){
                    ans += solve(i+1,2,score+1,s);
                }
                else if(s[i]=='E'){
                    ans += solve(i+1,2,score,s);
                }
            }
            ans %= mod;
        }
        ans %= mod;
        return dp[i][prev][score+1000] = ans;
    }
    
    int countWinningSequences(string s) {
        dp.clear();
        int n = s.length();
        dp.resize(n,vector<vector<ll>>(4,vector<ll>(2100,-1)));
        
        return solve(0,3,0,s);
    }
};",1420552843
Aditya Dargan,AdityaDargan,556,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0;i+k-1<n;i++){
            unordered_map<int,int> mp;
            for(int j=i;j<=i+k-1;j++){
                mp[nums[j]]++;
            }
            vector<pair<int,int>> v;
            for(auto i:mp)v.push_back({i.second,i.first});
            sort(v.begin(),v.end());
            reverse(v.begin(),v.end());
            int tot = min(x,(int)(v.size()));
            int val = 0;
            for(int i=0;i<tot;i++){
                val+=(v[i].first*v[i].second);
            }
            ans.push_back(val);
        }
        return ans;
    }
};",1420521136
systumm,rfUWS6azaX,557,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map<TreeNode*, int> dp;
    
    int dfs(TreeNode* root) {
        if (root == NULL) return 0;
        if (dp.count(root)) return dp[root];
        int left = dfs(root->left);
        int right = dfs(root->right);
        if (left == -1 || right == -1 || left != right) return dp[root] = -1;
        return dp[root] = left + 1;
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        vector<int> a;
        for (auto it : dp) {
            if (it.second != -1) a.push_back(it.second);
        }
        sort(a.begin(), a.end(), greater<int>());
        if (a.size() < k) return -1;
        return (1 << a[k - 1]) - 1;
    }
};",1420539361
systumm,rfUWS6azaX,557,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        const int NP = 0, MOD = 1e9 + 7;
        vector dp(n + 1, vector(2 * n + 1, vector<long long>(4, NP)));
        
        vector<char> moves = {'F', 'W', 'E'};
        auto winner = [&](char alice, int bob) {
            int aliceIdx = -1;
            for (int i = 0; i < 3; i++) {
                if (moves[i] == alice) {
                    aliceIdx = i;
                    break;
                }
            }
            assert(aliceIdx != -1);
            if (aliceIdx == bob) return 0;
            if (aliceIdx == (bob + 1) % 3) return -1;
            if ((aliceIdx + 1) % 3 == bob) return 1;
            assert(false);
        };
        
        // base case
        dp[0][n][3] = 1;
        
        for (int i = 0; i < n; i++) {
            for (int w = 0; w <= 2 * n; w++) {
                for (int last = 0; last < 4; last++) {
                    if (dp[i][w][last] == NP) continue;
                    for (int ll = 0; ll < 3; ll++) {
                        if (ll == last) continue;
                        int ii = i + 1;
                        int ww = w + winner(s[i], ll);
                        (dp[ii][ww][ll] += dp[i][w][last]) %= MOD;
                    }
                }
            }
        }
        
        long long ans = 0;
        for (int w = n + 1; w <= 2 * n; w++) {
            for (int l = 0; l < 3; l++) {
                (ans += dp[n][w][l]) %= MOD;
            }
        }
        
        return ans;
    }
};",1420559310
systumm,rfUWS6azaX,557,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans(n - k + 1);
        for (int i = 0; i + k - 1 < n; i++) {
            map<int,int> cnt;
            for (int j = i; j < i + k; j++) {
                cnt[nums[j]]++;
            }
            vector<pair<int,int>> a;
            for (auto it : cnt) {
                a.push_back({it.second, it.first});
            }
            sort(a.begin(), a.end());
            reverse(a.begin(), a.end());
            for (int j = 0; j < min((int)a.size(), x); j++) ans[i] += a[j].first * a[j].second;
        }
        return ans;
    }
};",1420521385
Andrew,XAXAEBATb,559,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
     vector <int> rec(TreeNode* node, vector<int>& sizes) {
        if (node == nullptr) {
            return {1, 0, 0};
        }
        auto l = rec(node->left, sizes);
        auto r = rec(node->right, sizes);
        if (l[0] == 1 && r[0] == 1 && l[1] == r[1]) {
            sizes.push_back(l[2] + r[2] + 1);
        }
        return {(l[0] == 1) && (r[0] == 1) && (l[1] == r[1]), max(l[1], r[1]) + 1, l[2] + r[2] + 1};
    }

    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;
        rec(root, ans);
        sort(ans.begin(), ans.end());
        reverse(ans.begin(), ans.end());
        if (k > ans.size()) {
            return -1;
        }
        return ans[k - 1];
    }
};",1420565538
Andrew,XAXAEBATb,559,3588,cpp,"class Solution {
public:
    
    int countWinningSequences(string s) {
        int a = s.size();
        long long mod = 1000000007;
        int start = a;
        vector <vector<vector<long long>>> ans(a+1, vector <vector<long long>> (2 * a + 1, vector<long long>(3)));
        char qq = s[0];
        if (qq == 'F') {
            ans[1][a][0] += 1;
            ans[1][a+1][1] += 1;
            ans[1][a-1][2] += 1;
        } 
        if (qq == 'W') {
            ans[1][a-1][0] += 1;
            ans[1][a][1] += 1;
            ans[1][a+1][2] += 1;
        } 
         if (qq == 'E') {
            ans[1][a+1][0] += 1;
            ans[1][a-1][1] += 1;
            ans[1][a][2] += 1;
        } 
        
        //FWE
        for (int i = 1; i < a; ++i) {
            char c = s[i];
            for (int j = 0;j <= 2 * a; j++) {
                if (c == 'F') {
                    ans[i + 1][j][0] += ans[i][j][1] + ans[i][j][2];
                    ans[i+1][j][1] += (j>0?ans[i][j-1][0]:0LL) + (j>0?ans[i][j-1][2]:0LL);
                    ans[i+1][j][2] += (j+1<=2*a ? ans[i][j+1][0]:0LL) + (j+1<=2*a ? ans[i][j+1][1] : 0LL);
                } 
                if (c == 'W') {
                    ans[i + 1][j][0] += (j+1<=2*a ? ans[i][j+1][1] : 0LL) + (j+1<=2*a ? ans[i][j+1][2] : 0LL);
                    ans[i+1][j][1] += ans[i][j][0] + ans[i][j][2];
                    ans[i+1][j][2] += (j>0? ans[i][j-1][0]:0LL) + (j>0? ans[i][j-1][1] : 0LL);
                } 
                 if (c == 'E') {
                    ans[i + 1][j][0] += (j>0? ans[i][j-1][1]: 0LL) + (j>0?ans[i][j-1][2] : 0LL);
                    ans[i+1][j][1] += (j+1<=2*a ? ans[i][j+1][0] : 0LL) + (j+1<=2*a ? ans[i][j+1][2] : 0LL);
                    ans[i+1][j][2] += ans[i][j][0] + ans[i][j][1];
                } 
                ans[i+1][j][0]%=mod;
                ans[i+1][j][1]%=mod;
                ans[i+1][j][2]%=mod;
            }
        }
        long long q = 0;
        for (int k = a + 1; k <= 2 * a; ++k) {
            q += ans[a][k][0] + ans[a][k][1] + ans[a][k][2];
        }
        return q%mod;
    }
};",1420565020
Andrew,XAXAEBATb,559,3610,cpp,"class Solution {
public:
        struct cmp {
    bool operator()(const pair<int, int>& l, const pair<int, int>& r) const {
        if (l.first != r.first) {
            return l.first > r.first;
        }
        return l.second > r.second;
    }
};
    vector<int> findXSum(vector<int>& nums, int k, int x) {
         int n = nums.size();
        vector <long long> n1(n);
        for (int i = 0;i < n; ++i) {
            n1[i] = nums[i];
        }
    vector<int> ans;
    unordered_map<long long, long long> f;
    multiset<pair<long long, long long>, cmp> s;
    long long cur = 0;
    for (int i = 0; i < k; ++i) {
        if (f.count(nums[i])) {
            s.erase({f[nums[i]], nums[i]});
        }
        f[nums[i]]++;
        s.insert({f[nums[i]], nums[i]});
    }
    {
        long long sum = 0;
        long long cnt = 0;
        for (auto it = s.begin(); it != s.end() && cnt < x; ++it) {
            long long cc = f[it->second];
            sum += it->second * cc;
            cnt++;
        }
        ans.push_back(sum);
    }

    for (long long i = k; i < n; ++i) {
        s.erase({f[nums[i - k]], nums[i - k]});
        f[nums[i - k]]--;
        if (f[nums[i - k]] > 0) {
            s.insert({f[nums[i - k]], nums[i - k]});
        } else {
            f.erase(nums[i - k]);
        }

        if (f.count(nums[i])) {
            s.erase({f[nums[i]], nums[i]});
        }
        f[nums[i]]++;
        s.insert({f[nums[i]], nums[i]});

        long long sum = 0;
        long long cnt = 0;
        for (auto it = s.begin(); it != s.end() && cnt < x; ++it) {
            sum += it->second * f[it->second];
            cnt++;
        }
        ans.push_back(sum);
    }
    return ans;
    }
};",1420565368
jam,jam930725,560,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int[] cnt = new int[2005];
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        isPerfect(root, 0);
        for(int i = 2004; i > 0; i--) {
            while(cnt[i] > 0) {
                k--;
                cnt[i]--;
                if(k == 0)
                    return i;
            }
        }
        return -1;
    }

    public St isPerfect(TreeNode cur, int dep) {
        if(cur == null)
            return new St(true, 0);
        St left = isPerfect(cur.left, dep+1);
        St right = isPerfect(cur.right, dep+1);
        if(left.per && right.per) {
            if(left.num == right.num) {
                St rt = new St(true, left.num * 2 + 1);
                cnt[rt.num]++;
                return rt;
            }
        }
        return new St(false, 1 + left.num + right.num);
    }

    public class St {
        boolean per = false;
        int num = 0;
        public St(boolean per, int num) {
            this.per = per;
            this.num = num;
        }
    }
}",1420532982
jam,jam930725,560,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        long mod = (long)1e9 + 7;
        int n = s.length(), n2 = 2004;
        long[][][] dp = new long[n][3][n2];
        char[] cs = s.toCharArray();
        int ind = toInd(cs[0]);
        for(int i = 0; i < 3; i++) {
            if(ind == i)
                dp[0][i][1001] = 1l;
            else if(i == (ind+2) % 3)
                dp[0][i][1000] = 1l;
            else
                dp[0][i][1002] = 1l;
        }
        for(int i = 1; i < n; i++) {
            int c = toInd(cs[i]);
            int lose = (c+2) % 3;
            int win = (c+1) % 3;
            for(int j = 0; j < 3; j++) {
                // tie
                if(j != c) {
                    for(int k = 0; k < n2; k++) {
                        dp[i][c][k] = (dp[i][c][k] + dp[i-1][j][k]) % mod;
                    }
                }
                // lose
                if(j != lose) {
                    for(int k = 1; k < n2; k++) {
                        dp[i][lose][k-1] = (dp[i-1][j][k] + dp[i][lose][k-1]) % mod;
                    }
                }
                // win
                if(j != win) {
                    for(int k = 0; k+1 < n2; k++) {
                        dp[i][win][k+1] = (dp[i-1][j][k] + dp[i][win][k+1]) % mod;
                    }
                }
            }
        }
        n--;
        long res = 0;
        long[][] arr = dp[n];
        for(long cnt[]: arr) {
            for(int i = 1002; i < cnt.length; i++)
                res = (res + cnt[i]) % mod;
        }
        return (int)res;
    }

    public int toInd(char c) {
        switch(c) {
            case 'F':
                return 0;
            case 'W':
                return 1;
            default:
                return 2;
        }
    }
}",1420565599
jam,jam930725,560,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] res = new int[n-k+1];
        for(int i = 0; i < res.length; i++) {
            int sum = 0;
            int[] cnt = new int[51];
            for(int j = 0; j < k; j++) {
                cnt[nums[i+j]]++;
                sum += nums[i+j];
            }
            PriorityQueue<Integer> pq = new PriorityQueue((aa, bb) -> {
                int a = (Integer)aa, b = (Integer)bb;
                if(cnt[b] == cnt[a])
                    return b - a;
                return cnt[b] - cnt[a];
            });
            for(int j = 0; j < 51; j++) {
                if(cnt[j] > 0)
                    pq.offer(j);
            }
            if(pq.size() < x) {
                res[i] = sum;
            }
            else {
                for(int j = 0; j < x; j++) {
                    int m = pq.poll();
                    res[i] += m * cnt[m];
                }
            }
        }
        return res;
    }
}",1420523091
bzhang2,bzhang2,561,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perfects = []
        def dfs(cur):
            nonlocal perfects
            if (cur == None):
                return (True, 0)
            left = dfs(cur.left)
            right = dfs(cur.right)
            if (left[0] and right[0] and left[1] == right[1]):
                perfects.append(left[1] + right[1] + 1)
                return (True, left[1] + right[1] + 1)
            else:
                return (False, 0)
        dfs(root)
        perfects.sort(reverse = True)
        #print(perfects)
        if (k - 1 >= len(perfects)):
            return -1
        else:
            return perfects[k - 1]",1420529995
bzhang2,bzhang2,561,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        #dpf[i][j] sequences with with bob up j - n points ending with f
        #dpw[i] ditto with water
        #dpe[i] ditto with earth
        n = len(s)
        dpf = [[0] * (2 * n + 1) for x in range(n)]
        dpw = [[0] * (2 * n + 1) for x in range(n)]
        dpe = [[0] * (2 * n + 1) for x in range(n)]
        mod = 10**9 + 7
        if (s[0] == 'F'):
            dpf[0][n] = 1
            dpe[0][n - 1] = 1
            dpw[0][n + 1] = 1
        elif (s[0] == 'W'):
            dpf[0][n - 1] = 1
            dpe[0][n + 1] = 1
            dpw[0][n] = 1
        else:
            dpf[0][n + 1] = 1
            dpe[0][n] = 1
            dpw[0][n - 1] = 1
        for x in range(1, n):
            for y in range(2 * n + 1):
                if (s[x] == 'F'):
                    dpf[x][y] = dpe[x - 1][y] + dpw[x - 1][y]
                    dpw[x][y] = dpf[x - 1][y - 1] + dpe[x - 1][y - 1] if y - 1 >= 0 else 0
                    dpe[x][y] = dpf[x - 1][y + 1] + dpw[x - 1][y + 1] if y + 1 < 2 * n + 1 else 0
                elif (s[x] == 'W'):
                    dpf[x][y] = dpe[x - 1][y + 1] + dpw[x - 1][y + 1] if y + 1 < 2 * n + 1 else 0
                    dpw[x][y] = dpf[x - 1][y] + dpe[x - 1][y]
                    dpe[x][y] = dpf[x - 1][y - 1] + dpw[x - 1][y - 1] if y - 1 >= 0 else 0
                else:
                    dpf[x][y] = dpe[x - 1][y - 1] + dpw[x - 1][y - 1] if y - 1 >= 0 else 0
                    dpw[x][y] = dpf[x - 1][y + 1] + dpe[x - 1][y + 1] if y + 1 < 2 * n + 1 else 0
                    dpe[x][y] = dpf[x - 1][y] + dpw[x - 1][y]
                dpf[x][y] %= mod
                dpw[x][y] %= mod
                dpe[x][y] %= mod
        result = 0
        #print(dpe)
        for x in range(n + 1, 2 * n + 1):
            result += dpf[n - 1][x]
            result %= mod
            result += dpw[n - 1][x]
            result %= mod
            result += dpe[n - 1][x]
            result %= mod
        return result

        ",1420565619
bzhang2,bzhang2,561,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        result = []
        n = len(nums)
        for y in range(n - k + 1):
            freq = collections.Counter(nums[y:y + k])
            vals = list(set(nums))
            vals.sort(key = lambda a: (-freq[a], -a))
            #print(vals)
            vals = set(vals[:x])
            res = 0
            for num in nums[y:y+k]:
                if (num in vals):
                    res += num
            result.append(res)
        return result
",1420523737
Tutul_dhar,Tutul_dhar,562,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int a[8010];
    void dfs(TreeNode * root,int ind = 1) {
        if(!root) return;
        if(root->left) dfs(root->left,2*ind);
        if(root->right) dfs(root->right,2*ind+1);
        
        if(!root->left and !root->right) a[ind] = 1;
        else if(root->left && root->right && a[2*ind] == a[2*ind+1]) {
            a[ind] = 2*a[2*ind] + 1;
        }
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        memset(a,-1,sizeof a);
        dfs(root);
        vector<int> v;
        for(int i = 0; i <= 8000; i++) {
            if(a[i] > 0) v.push_back(a[i]);
        }
        sort(v.rbegin(),v.rend());
        //for(int ch : v) cout << ch << ' ';
        if(v.size() < k) return -1;
        return v[k-1];
    }
};",1420548220
Tutul_dhar,Tutul_dhar,562,3588,cpp,"class Solution {
public:
    const static int mod = 1e9+7;
    int dp[1005][2005][4];
    int solve(int i,int j,int prev,string &s) {
        if(i >= s.size()) {
            if(j > 1000) return 1;
            return 0;
        }
        if(dp[i][j][prev] != -1) return dp[i][j][prev];
        int ans = 0;
        for(int k = 1; k <= 3; k++) {
            if(k == prev) continue;
            if(k == 1) {
                if(s[i] == 'E') ans = (ans + solve(i+1,j+1,k,s))%mod;
                else if(s[i] == 'W') ans = (ans + solve(i+1,j-1,k,s))%mod;
                else  ans = (ans + solve(i+1,j,k,s))%mod;
            } else if(k == 2) {
                if(s[i] == 'F') ans = (ans + solve(i+1,j+1,k,s))%mod;
                else if(s[i] == 'E') ans = (ans + solve(i+1,j-1,k,s))%mod;
                else ans = (ans + solve(i+1,j,k,s))%mod;
            } else {
                if(s[i] == 'W') ans = (ans + solve(i+1,j+1,k,s))%mod;
                else if(s[i] == 'F') ans = (ans + solve(i+1,j-1,k,s))%mod;
                else ans = (ans + solve(i+1,j,k,s))%mod;
            }
        }
        return dp[i][j][prev] = ans;
    }
    int countWinningSequences(string s) {
        memset(dp,-1,sizeof dp);
        return solve(0,1000,0,s);
    }
};",1420565669
Tutul_dhar,Tutul_dhar,562,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int n = nums.size();
        for(int i = 0; i+k-1 < n; i++) {
            int ar[55];
            memset(ar,0,sizeof ar);
            for(int j = i; j < i+k; j++) ar[nums[j]]++;
            vector<pair<int,int>> vv;
            for(int j = 1; j <= 50; j++) {
                if(ar[j]) vv.push_back({ar[j],j});
            }
            sort(vv.begin(),vv.end());
            int xx = x;
            int res = 0;
            for(int j = vv.size()-1; j >= 0 and xx; j--) {
                res += vv[j].second*vv[j].first;
                xx--;
            }
            ans.push_back(res);
        }
        return ans;
    }
};",1420524271
Rishi,Arctic-Gale,563,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
import java.util.*;

class Solution {
    class Result {
        boolean isPerfect;
        int size;
        
        Result(boolean isPerfect, int size) {
            this.isPerfect = isPerfect;
            this.size = size;
        }
    }
    
    
    private Result chk_Best(TreeNode node) {
        if (node == null) return new Result(true, 0);
        
        Result lft_ans = chk_Best(node.left);
        Result right_ans = chk_Best(node.right);
        
        
        if (lft_ans.isPerfect && right_ans.isPerfect && lft_ans.size == right_ans.size) {
            return new Result(true, lft_ans.size + right_ans.size + 1);
        }
        
        return new Result(false, 0);
    }
    
    
    private void gthr_BestSizes(TreeNode node, List<Integer> s_treesizes) {
        if (node == null) return;
        
        Result result = chk_Best(node);
        if (result.isPerfect) {
            s_treesizes.add(result.size);
        }
        
        
        gthr_BestSizes(node.left, s_treesizes);
        gthr_BestSizes(node.right, s_treesizes);
    }
    
    
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> s_treesizes = new ArrayList<>();
        gthr_BestSizes(root, s_treesizes);
        
        
        if (s_treesizes.isEmpty()) return -1;
        
        
        s_treesizes.sort(Collections.reverseOrder());
        
        
        return (k <= s_treesizes.size()) ? s_treesizes.get(k - 1) : -1;
    }
}
",1420547843
Rishi,Arctic-Gale,563,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int o = s.length();
        vector<vector<vector<long long>>> dp(o, vector<vector<long long>>(3, vector<long long>(2*o+1, 0)));
        
        
        for (int j = 0; j < 3; j++) {
            int scoreDiff = gt_ScoreDiff(s[0], j);
            dp[0][j][o + scoreDiff] = 1;
        }
        
        
        for (int i = 1; i < o; i++) {
            for (int j = 0; j < 3; j++) {
                for (int k = 0; k < 3; k++) {
                    if (j != k) {  
                        int scoreDiff = gt_ScoreDiff(s[i], j);
                        for (int prev_diff = 0; prev_diff < 2*o+1; prev_diff++) {
                            int new_diff = prev_diff + scoreDiff;
                            if (new_diff >= 0 && new_diff < 2*o+1) {
                                dp[i][j][new_diff] = (dp[i][j][new_diff] + dp[i-1][k][prev_diff]) % MOD;
                            }
                        }
                    }
                }
            }
        }
        
        
        long long result = 0;
        for (int j = 0; j < 3; j++) {
            for (int diff = o+1; diff < 2*o+1; diff++) {
                result = (result + dp[o-1][j][diff]) % MOD;
            }
        }
        
        return result;
    }

private:
    int gt_ScoreDiff(char Alice, int Bob) {
        if ((Bob == 0 && Alice == 'E') || (Bob == 1 && Alice == 'F') || (Bob == 2 && Alice == 'W')) {
            return 1;  
        } else if ((Alice == 'F' && Bob == 2) || (Alice == 'W' && Bob == 0) || (Alice == 'E' && Bob == 1)) {
            return -1;  
        }
        return 0;  
    }
};",1420565837
Rishi,Arctic-Gale,563,3610,cpp,"#include <vector>
#include <unordered_map>
#include <map>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int p, int h) {
        int n = nums.size();
        vector<int> result(n - p + 1);
        
        unordered_map<int, int> freq;
        
        
        for (int i = 0; i < p; ++i) {
            freq[nums[i]]++;
        }

        auto calcXSum = [&]() -> int {
        
            vector<pair<int, int>> freqList(freq.begin(), freq.end());
            sort(freqList.begin(), freqList.end(), [](pair<int, int>& a, pair<int, int>& b) {
                if (a.second == b.second) {
                    return a.first > b.first;  
                }
                return a.second > b.second; 
            });

            
            int sum = 0, count = 0;
            for (const auto& p : freqList) {
                if (count >= h) break;  
                sum += p.first * p.second;
                count++;
            }
            return sum;
        };

        
        result[0] = calcXSum();
        
        
        for (int i = 1; i <= n - p; ++i) {
            
            freq[nums[i - 1]]--;
            if (freq[nums[i - 1]] == 0) {
                freq.erase(nums[i - 1]);
            }

            
            freq[nums[i + p - 1]]++;
            
            
            result[i] = calcXSum();
        }
        
        return result;
    }
};
",1420521004
Linh Nguyen,ll931110,564,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sz;

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        sz.clear();
        DFS(root); 

        sort(sz.rbegin(), sz.rend());
        if (sz.size() < k) {
            return -1;
        }
        return sz[k - 1];
    }

    pair<int, bool> DFS(TreeNode* root) {
        if (!root->left && !root->right) {
            sz.push_back(1);
            return {1, true};
        }

        bool perfect = true;
        int tree_size = 1;

        pair<int, bool> ls, rs;
        if (root->left) {
            ls = DFS(root->left);
            tree_size += ls.first;
            perfect &= ls.second;
        }
        if (root->right) {
            rs = DFS(root->right);
            tree_size += rs.first;
            perfect &= rs.second;
        }
        if (!root->left || !root->right) {
            perfect = false;
        } else if (ls.first != rs.first) {
            perfect = false;
        }

        if (perfect) {
            sz.push_back(tree_size);
        }

        return {tree_size, perfect};
    }
};",1420536116
Linh Nguyen,ll931110,564,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        int mod = 1e9 + 7;
        int maxn = 1005;

        int dp[maxn][2 * maxn][3];
        memset(dp, 0, sizeof dp);

        int n = s.size();
        for (int t = 0; t < 3; t++) {
            dp[0][n + score(t, decode(s[0]))][t] = 1;
        }

        for (int i = 0; i + 1 < n; i++) {
            for (int c = 0; c < 2 * n; c++) {
                for (int t = 0; t < 3; t++) if (dp[i][c][t]) {
                    for (int j = 0; j < 3; j++) if (j != t) {
                        int _s = c + score(j, decode(s[i + 1]));
                        dp[i + 1][_s][j] += dp[i][c][t];
                        dp[i + 1][_s][j] %= mod;
                    }
                }
            }
        }

        int ret = 0;
        for (int c = n + 1; c <= 2 * n; c++) {
            for (int t = 0; t < 3; t++) {
                ret += dp[n - 1][c][t];
                ret %= mod;
            }
        }

        return ret;
    }

    int decode(char s) {
        if (s == 'F') {
            return 0;
        }
        if (s == 'W') {
            return 1;
        }
        return 2;
    }

    int score(int x, int y) {
        if (x == y) {
            return 0;
        }
        if (x == 0 && y == 2) {
            return 1;
        }
        if (x == 1 && y == 0) {
            return 1;
        }
        if (x == 2 && y == 1) {
            return 1;
        }

        return -1;
    }
};",1420559871
Linh Nguyen,ll931110,564,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ret;
        int n = nums.size();
        for (int i = 0; i + k <= n; i++) {
            map<int,int> freq;
            for (int j = i; j < i + k; j++) {
                freq[nums[j]]++;
            }
            vector< pair<int,int> > values;
            for (auto x : freq) {
                values.push_back({x.second, x.first});
            }
            sort(values.rbegin(), values.rend());

            int ss = 0;
            for (int t = 0; t < x && t < values.size(); t++) {
                ss += values[t].first * values[t].second;
            }

            ret.push_back(ss);
        }
        return ret;
    }
};",1420522716
yasharthasingh29,yasharthasingh29,565,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#include <vector>
#include <algorithm>

class Solution {
public:
    struct SubtreeInfo {
        bool isPerfect; // Is the subtree perfect
        int height;     // Height of the subtree
        int size;       // Size of the subtree (number of nodes)
    };
    
    // Helper function to traverse the tree and find perfect subtrees
    SubtreeInfo findPerfectSubtrees(TreeNode* node, std::vector<int>& sizes) {
        if (!node) {
            return {true, 0, 0}; // An empty subtree is perfect, height = 0, size = 0
        }
        
        SubtreeInfo left = findPerfectSubtrees(node->left, sizes);
        SubtreeInfo right = findPerfectSubtrees(node->right, sizes);
        
        // Check if the current subtree is perfect
        if (left.isPerfect && right.isPerfect && left.height == right.height) {
            int subtreeSize = left.size + right.size + 1; // Size = left + right + root
            sizes.push_back(subtreeSize); // Add the size of the perfect subtree
            return {true, left.height + 1, subtreeSize}; // It's a perfect subtree with height +1
        }
        
        return {false, 0, 0}; // If it's not a perfect subtree, return false
    }
    
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        std::vector<int> sizes;
        findPerfectSubtrees(root, sizes);
        
        // Sort the sizes in descending order
        std::sort(sizes.begin(), sizes.end(), std::greater<int>());
        
        // Return the kth largest if possible
        if (sizes.size() >= k) {
            return sizes[k - 1];
        }
        
        return -1; // If there are fewer than k perfect subtrees
    }
};
",1420529657
yasharthasingh29,yasharthasingh29,565,3588,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    // Convert Alice's move to an index (0 -> Fire, 1 -> Water, 2 -> Earth)
    int moveToIndex(char move) {
        if (move == 'F') return 0;
        if (move == 'W') return 1;
        return 2;
    }

    // Check if Bob wins given his and Alice's move
    bool doesBobWin(int bobMove, int aliceMove) {
        if (bobMove == 0 && aliceMove == 2) return true; // Fire beats Earth
        if (bobMove == 1 && aliceMove == 0) return true; // Water beats Fire
        if (bobMove == 2 && aliceMove == 1) return true; // Earth beats Water
        return false;
    }

    // Recursive backtracking with memoization
    int backtrack(const string& s, int round, int lastMove, int scoreDifference, vector<vector<vector<int>>>& dp) {
        int n = s.size();
        
        if (round == n) {
            // Bob wins if he has a positive score difference
            return scoreDifference > 0 ? 1 : 0;
        }

        if (dp[round][lastMove][scoreDifference + n] != -1) {
            return dp[round][lastMove][scoreDifference + n];
        }

        int aliceMove = moveToIndex(s[round]);
        int totalWays = 0;

        // Bob tries all 3 possible moves (Fire, Water, Earth), but no consecutive moves are allowed
        for (int bobMove = 0; bobMove < 3; ++bobMove) {
            if (bobMove == lastMove) continue; // Bob can't repeat the same move
            
            int newScoreDifference = scoreDifference;

            // Adjust the score difference based on who wins the round
            if (doesBobWin(bobMove, aliceMove)) {
                newScoreDifference++;  // Bob wins this round
            } else if (doesBobWin(aliceMove, bobMove)) {
                newScoreDifference--;  // Alice wins this round
            }

            // Recursively check for the next round
            totalWays = (totalWays + backtrack(s, round + 1, bobMove, newScoreDifference, dp)) % MOD;
        }

        dp[round][lastMove][scoreDifference + n] = totalWays;
        return totalWays;
    }

    int countWinningSequences(string s) {
        int n = s.size();
        
        // dp[round][lastMove][scoreDifference]: memoization table
        // scoreDifference can range from -n to n, we shift by +n to handle negative values.
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(4, vector<int>(2 * n + 1, -1)));

        // Start backtracking from round 0, no last move (represented by 3), and score difference of 0
        return backtrack(s, 0, 3, 0, dp);
    }
};
",1420547320
yasharthasingh29,yasharthasingh29,565,3610,cpp,"#include <vector>
#include <unordered_map>
#include <algorithm>

class Solution {
public:
    std::vector<int> findXSum(std::vector<int>& nums, int k, int x) {
        int n = nums.size();
        std::vector<int> result;
        std::unordered_map<int, int> freq; // To store frequency of elements in the current window
        
        // Initialize frequency map for the first window
        for (int i = 0; i < k; i++) {
            freq[nums[i]]++;
        }
        
        // Function to calculate x-sum for the current frequency map
        auto calculateXSum = [&](const std::unordered_map<int, int>& freqMap) -> int {
            std::vector<std::pair<int, int>> elements;
            for (auto& it : freqMap) {
                elements.push_back({it.second, it.first}); // {frequency, element}
            }
            
            // Sort by frequency first, and by value if frequencies are the same (descending order)
            std::sort(elements.begin(), elements.end(), [](std::pair<int, int>& a, std::pair<int, int>& b) {
                if (a.first == b.first) return a.second > b.second; // Sort by value if frequencies are equal
                return a.first > b.first; // Sort by frequency
            });
            
            int sum = 0;
            int count = 0;
            for (auto& elem : elements) {
                if (count == x) break;
                int element = elem.second;
                int frequency = elem.first;
                
                // Add the element's frequency to the sum
                sum += element * frequency;
                count++;
            }
            return sum;
        };
        
        // Calculate x-sum for the first window
        result.push_back(calculateXSum(freq));
        
        // Now, slide the window across the array
        for (int i = k; i < n; i++) {
            // Remove the element that's sliding out of the window
            int elementToRemove = nums[i - k];
            freq[elementToRemove]--;
            if (freq[elementToRemove] == 0) {
                freq.erase(elementToRemove);
            }
            
            // Add the new element that's entering the window
            int elementToAdd = nums[i];
            freq[elementToAdd]++;
            
            // Calculate x-sum for the current window
            result.push_back(calculateXSum(freq));
        }
        
        return result;
    }
};
",1420524801
Sagnik Biswas,SagnikBiswas1049,566,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    ArrayList<Integer> trees = new ArrayList<Integer>();
    
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        size(root);
        Collections.sort(trees);
        Collections.reverse(trees);
        if (trees.size() < k) return -1;
        return trees.get(k-1);
    }
    
    public int size(TreeNode node) {
        if (node == null) return 0;
        
        int locDepth = depth(node);
        
        int sz = 1 + size(node.left) + size(node.right);
        
        if (locDepth > 20) return sz;
        
        if (sz == ((1<<locDepth) - 1)) {
            trees.add(sz);
        }
        
        
        return sz;
    }
    
    public int depth(TreeNode node) {
        if (node == null) return 0;
        return 1 + Math.max(depth(node.right), depth(node.left));
    }
    
    
}",1420529403
Sagnik Biswas,SagnikBiswas1049,566,3588,java,"class Solution {
    public int countWinningSequences(String s) {
        /*
        F beats E
        W beats F
        E beats W
        
        0 beats 2
        1 beats 0
        2 beats 1
        
        dp(i, C, j) = if the ith character is C, how many ways to earn j more points? 
        
        
        */
        
        int n = s.length();
        long mod = (long) (1e9 + 7);
        long[][][] dp = new long[n][3][2*n+1];
        
        int[] A = new int[n];
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == 'F') {
                A[i] = 0;
            } else if (s.charAt(i) == 'W') {
                A[i] = 1;
            } else {
                A[i] = 2;
            }
        }
        
        int[] opp = {1, 2, 0};
        
        for (int i = 0; i < n; i++) {
            for (int col = 0; col < 3; col++) {
                for (int diff = -(i+1); diff <= (i+1); diff++) {
                    
                    if (i == 0) {
                        
                        if (col == opp[A[i]]) {
                            if (diff == 1) {
                                dp[i][col][diff+n] = 1;
                            }
                        } else if (col == A[i]) {
                            if (diff == 0) {
                                dp[i][col][diff+n] = 1;
                            }
                        } else {
                            if (diff == -1) {
                                dp[i][col][diff+n] = 1;
                            }
                        }   
                    } else {
                        
                        if (col == opp[A[i]]) {
                            if (diff+n-1 >= 0) {
                                dp[i][col][diff+n] = dp[i-1][0][diff+n-1] + dp[i-1][1][diff+n-1] + dp[i-1][2][diff+n-1];
                                dp[i][col][diff+n] -= dp[i-1][col][diff+n-1];
                                dp[i][col][diff+n] %= mod;
                            }
                            
                            
                        } else if (col == A[i]) {
                            
                            if (true) {
                                dp[i][col][diff+n] = dp[i-1][0][diff+n] + dp[i-1][1][diff+n] + dp[i-1][2][diff+n];
                                dp[i][col][diff+n] -= dp[i-1][col][diff+n];
                                dp[i][col][diff+n] %= mod;
                            }
                            
                            
                        } else {
                            
                            if (diff+n+1 <= 2*n) {
                                dp[i][col][diff+n] = dp[i-1][0][diff+n+1] + dp[i-1][1][diff+n+1] + dp[i-1][2][diff+n+1];
                                dp[i][col][diff+n] -= dp[i-1][col][diff+n+1];
                                dp[i][col][diff+n] %= mod;
                            }
                            
                            
                        }   
                        
                        
                    }
                    
                    // System.out.printf(""dp(%d, %d, %d) = %d\n"", i, col, diff, dp[i][col][diff+n]);
                    
                }
            }
        }
        
        long S = 0;
        
        
        for (int col = 0; col < 3; col++) {
            for (int j = n+1; j <= 2*n; j++) {
                S += dp[n-1][col][j];
                // System.out.printf(""dp(%d, %d, %d) = %d\n"", n-1, col, j-n, dp[n-1][col][j]);
                S %= mod;
            }
        }
        
        return (int) S;
    }
}",1420566251
Sagnik Biswas,SagnikBiswas1049,566,3610,java,"class Solution {
    
    class P implements Comparable<P> {
        int v, f;
        P(int v, int f) {
            this.v = v;
            this.f = f;
        }
        
        public int compareTo(P other) {
            if (this.f == other.f) {
                return Integer.compare(this.v, other.v);
            } else {
                return Integer.compare(this.f, other.f);
            }
        }
    }
    
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] answer = new int[n-k+1];
        
        for (int i = 0; i <= n-k; i++) {
            int[] narr = new int[k];
            for (int j = i; j < i+k; j++) {
                narr[j-i] = nums[j];
            }
            answer[i] = solve(narr, x);
        }
        
        
        return answer;
    }
    
    public int solve(int[] A, int x) {
        // System.out.println(Arrays.toString(A));
        
        int n = A.length;
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int v : A) {
            if (map.containsKey(v)) {
                map.put(v, map.get(v) + 1);
            } else {
                map.put(v, 1);
            }
        }
        
        // System.out.println(map);
        
        ArrayList<P> top = new ArrayList<P>();
        
        for (Map.Entry<Integer, Integer> e : map.entrySet()) {
            top.add(new P(e.getKey(), e.getValue()));
        }
        
        // System.out.println();
        
        
        int sum = 0;
        
        Collections.sort(top);
        
        for (int i = Math.max(0, top.size() - x); i< top.size(); i++) {
            sum += top.get(i).v * top.get(i).f;
        }
        
        return sum;
    }
}",1420522937
YTChuang,YTChuang,567,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
import heapq as hq
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        heights = []
        def perfect(node):
            if node is None:
                return 0
            pl = perfect(node.left)
            pr = perfect(node.right)
            if pl == pr and pl != -1:
                hq.heappush(heights, - pl - pr - 1)
                return pl + pr + 1
            else:
                return -1
        perfect(root)
        # print(heights)
        if len(heights) < k:
            return -1
        while k:
            k -= 1
            if k == 0:
                h = -heapq.heappop(heights)
                return h
            heapq.heappop(heights)",1420533325
YTChuang,YTChuang,567,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        # def (prev, point)
        points = {""FF"": 0, ""WW"": 0, ""EE"": 0, ""FW"": 1, ""WE"": 1, ""EF"": 1, ""FE"": -1, ""EW"": -1, ""WF"": -1}
        i = 0
        MOD = int(1E9 + 7)
        possible = {""F"", ""W"", ""E""}
        prev = Counter()
        n = len(s)
        for p in possible:
            mat = s[0] + p
            prev[(p, points[mat])] += 1
        i += 1
        while i < len(s):
            temp = Counter()
            alice = s[i]
            for (prev_summon, point) in prev:
                count = prev[(prev_summon, point)]
                for summon in possible:
                    if summon == prev_summon:
                        continue
                    else:
                        p = point + points[alice + summon]
                        if p + n - i > 0:
                            temp[(summon, p)] += count
                            temp[(summon, p)] %= MOD
            prev = temp
            i += 1
        # print(prev)
        ans = 0
        for s, p in prev:
            if p > 0:
                ans += prev[(s,p)]
                ans %= MOD
        return ans

",1420560288
YTChuang,YTChuang,567,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        freq = Counter()
        i = 0
        for j in range(k):
            freq[nums[j]] += 1
        ans = []
        while j < len(nums):
            c = 0
            temp = 0
            for f, key in sorted([(- freq[key], -key) for key in freq]):
                c += 1
                if c > x:
                    break
                temp += f*key
            ans.append(temp)
            j += 1
            if j == len(nums):
                break
            freq[nums[j]] += 1
            freq[nums[i]] -= 1
            i += 1
        return ans",1420522212
sri_ram,Sar2486P,568,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> li = new ArrayList<>() ;
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        dfs(root , 0) ; 
        
        Collections.sort(li) ; 
        // System.out.println(li) ; 
        return (li.size()<k)?-1:li.get(li.size()-k) ; 
    }
    
    private int dfs(TreeNode root , int level){
        if(root==null) return 0 ;
        int left_depth = dfs(root.left, level+1) ; 
        int right_depth = dfs(root.right, level+1) ; 
        
        if(left_depth==-1 || right_depth==-1 || (left_depth!=right_depth)){
            return -1 ;  
        }
        int ct = (int)Math.pow(2, 1+right_depth)-1 ;
        li.add(ct) ; 
        return 1+right_depth ; 
        
        
    }
    
}",1420541063
sri_ram,Sar2486P,568,3588,java,"class Solution {
    int M = (int)(1e9+7) ; 
    HashMap<Character, Integer> map ; 
    public int countWinningSequences(String s) {
        char[] arr = s.toCharArray() ; 
        int n = arr.length ;
        map = new HashMap<>() ; 
        map.put('S', 0) ; 
        map.put('F', 1) ; 
        map.put('W', 2) ; 
        map.put('E', 3) ; 
        
        int[][][]dp = new int[n][2*n+1][4] ; 
        for(int[][] mat:dp)for(int[]nums:mat) Arrays.fill(nums, -1) ; 
        return f(0, 0, n, 'S', arr, dp) ; 
    }
    private int f(int idx, int score ,int n , char prev, char[]arr, int[][][]dp){
        if(idx==n) return (score>0)?1:0 ; 
        if(dp[idx][score+n][map.get(prev)]!= -1) return dp[idx][score+n][map.get(prev)] ; 
        long ct = 0 ; 
        for(char c : map.keySet()){
            if(c=='S' || c==prev) continue ; 
            int a = award(arr[idx], c) ; 
            ct += f(idx+1, score+a , n , c , arr, dp) ; 
        }
        return dp[idx][score+n][map.get(prev)] = (int)(ct%M) ; 
        
    }
    
    private int award(char a, char b){
        if(a==b) return 0 ; 
        else if(a=='F' && b=='E') return -1 ; 
        else if (a=='E' && b=='F') return 1 ; 
        else if(a=='W' && b=='F') return -1 ; 
        else if(a=='F' && b=='W') return 1 ; 
        else if(a=='E' && b=='W') return -1 ; 
        else return 1 ; 
    }
}",1420566338
sri_ram,Sar2486P,568,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length ; 
        int[] ans = new int[n-k+1] ; 
        
        for(int i=0 ; i<n-k+1 ; i++){
            ans[i] = f(nums , i , i+k-1 , x) ; 
        }
        return ans ; 
    }
    private int f(int[] nums , int s , int e,int x){
        int[] freq = new int[51] ; 
        
        for(int i=s ; i<=e ; i++){
            freq[nums[i]]++ ; 
        }
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->{
            if(a[0]!=b[0]) return b[0]-a[0] ; 
            return b[1]-a[1] ; 
        }) ;
        for(int i=1 ; i<51 ; i++){
            pq.add(new int[]{freq[i] , i}) ; 
        }
        int ans = 0 ; 
        while(pq.size()>0){
            int[] arr = pq.poll() ; 
            ans+= arr[0]*arr[1] ; 
            if(--x==0) break ; 
        }
        return ans ; 
            
    }
}",1420528919
Khoa,khoale165,569,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
  def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
    def traverse(node):
      if not node:
        return True, 0
      pl, cl = traverse(node.left)
      pr, cr = traverse(node.right)
      perfect = pl and pr and cl == cr
      if perfect:
        heappush(ptrees, cl + cr + 1)
        if len(ptrees) > k: heappop(ptrees)
      return perfect, cl + cr + 1

    ptrees = []
    traverse(root)
    return ptrees[0] if len(ptrees) >= k else -1",1420533414
Khoa,khoale165,569,3588,python3,"class Solution:
  def countWinningSequences(self, s: str) -> int:
    '''
    FFW
    W
    Output 5, expected 4
    '''
    score = {
      ""F"": {""W"": -1, ""E"": 1},
      ""W"": {""E"": -1, ""F"": 1},
      ""E"": {""F"": -1, ""W"": 1},
    }
    def settle(bob, alice):
      if alice == bob: return 0
      return score[bob][alice]

    seen = {}
    def play(i, prev, diff):
      if i == len(s): 
        # if diff > 0: print(path)
        return 1 if diff > 0 else 0
      if (i, prev, diff) in seen: return seen[(i, prev, diff)]
      
      res = 0
      for ele in [""F"", ""W"", ""E""]:
        if ele != prev:
          res += play(i+1, ele, diff + settle(ele, s[i]))
      seen[(i, prev, diff)] = res
      return res
    
    return play(0, None, 0) % (10 ** 9 + 7)",1420554401
Khoa,khoale165,569,3610,python3,"class Solution:
  def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
    n = len(nums)
    res = []
    f = {}
    for i in range(n):
      f[nums[i]] = f.get(nums[i], 0) + 1
      if i < k-1: continue
      pairs = sorted([(k, v) for k, v in f.items()], key=lambda y: (-y[1], -y[0]))[:x]
      res.append(sum(k*v for k, v in pairs))
      f[nums[i-k+1]] -= 1
      if f[nums[i-k+1]] == 0:
        del f[nums[i-k+1]]
    return res",1420522950
Yana,gyana02,570,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> sizes;
    pair<int, int> solve(TreeNode* root) {
        if ( root == NULL ) return {0, 0};

        pair<int, int> l = solve(root->left);
        pair<int, int> r = solve(root->right);

        if ( l.first == r.first && l.first != -1 && r.first != -1 ) {
            sizes.push_back(l.second + r.second + 1);
            return {l.first + 1, l.second + r.second + 1};
        }

        return {-1, -1};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        solve(root);

        if ( sizes.size() < k ) return -1;
        sort(sizes.rbegin(), sizes.rend());
        return sizes[k-1];
    }
};",1420538700
Yana,gyana02,570,3588,cpp,"class Solution {
public:
    int dp[1000][2000][4];
    int mod = 1e9 + 7;
    int solve(int idx, string& s, int diff, int last) {
        if ( idx == s.size() ) {
            if ( diff > 0 ) return 1;
            return 0;
        }
        if ( dp[idx][1000 + diff][last] != - 1 ) return dp[idx][1000 + diff][last];

        int val = (s[idx] == 'F') ? 0 : ((s[idx] == 'W') ? 1 : 2);
        int res = 0;

        for ( auto i = 0; i <= 2; i++ ) {
            if ( i == last ) continue;
            if ( val == 0 ) {
                if ( i == 1 ) {
                    res += solve(idx + 1, s, diff + 1, i);
                    res = res%mod;
                } else  if ( i == 2 ) {
                    res += solve(idx + 1, s, diff - 1, i);
                    res = res%mod;
                } else {
                    res += solve(idx + 1, s, diff, i);
                    res = res%mod;
                }
            } else if ( val == 1 ) {
                if ( i == 2 ) {
                    res += solve(idx + 1, s, diff + 1, i);
                    res = res%mod;
                } else  if ( i == 0 ) {
                    res += solve(idx + 1, s, diff - 1, i);
                    res = res%mod;
                } else {
                    res += solve(idx + 1, s, diff, i);
                    res = res%mod;
                }
            } else {
                if ( i == 0 ) {
                    res += solve(idx + 1, s, diff + 1, i);
                    res = res%mod;
                } else  if ( i == 1 ) {
                    res += solve(idx + 1, s, diff - 1, i);
                    res = res%mod;
                } else {
                    res += solve(idx + 1, s, diff, i);
                    res = res%mod;
                }
            }
        }

        return dp[idx][1000 + diff][last] = res;
    }

    int countWinningSequences(string s) {
        memset(dp, -1, sizeof(dp));
        return solve(0, s, 0, 3);
    }
};",1420560731
Yana,gyana02,570,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> res;
        
        map<int, int> mp;
        int i = 0;
        for ( i = 0; i < k-1; i++ ) mp[nums[i]]++;

        while ( i < nums.size() ) {
            if ( i - k >= 0 ){ 
                mp[nums[i-k]]--;
                if ( mp[nums[i-k]] == 0 ) mp.erase(nums[i-k]);
            }

            mp[nums[i]]++;
            vector<pair<int, int>> v;
            for ( auto ele: mp ) {
                v.push_back({ele.second, ele.first});
            }

            sort(v.rbegin(), v.rend());
            int sum = 0;

            for ( auto i = 0; i < x && i < v.size(); i++ ) {
                sum += (v[i].first)*(v[i].second);
            }

            res.push_back(sum);
            i++;
        }
        return res;
        
    }
};",1420524511
Min,IAFB358kMw,571,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
import java.util.*;

public class Solution {
    
    private static class SI {
        boolean ip;
        int h;
        int s;
        
        SI(boolean ip, int h, int s) {
            this.ip = ip;
            this.h = h;
            this.s = s;
        }
    }
    
    private void help2(List<Integer> l) {
        int i = 0;
        while (i < l.size()) {
            int j = i + 1;
            while (j < l.size()) {
                if (l.get(i) < l.get(j)) {
                    int t = l.get(i);
                    l.set(i, l.get(j));
                    l.set(j, t);
                }
                j++;
            }
            i++;
        }
    }
    
    private SI help1(TreeNode n, List<Integer> ps) {
        return n == null
            ? new SI(true, 0, 0)
            : help3(n, ps);
    }
    
    private SI help3(TreeNode n, List<Integer> ps) {
        SI li = help1(n.left, ps);
        SI ri = help1(n.right, ps);
        
        boolean ip = li.ip && ri.ip && (li.h == ri.h);
        int h = Math.max(li.h, ri.h) + 1;
        int s = li.s + ri.s + 1;
        
        return ip
            ? help4(h, s, ps)
            : new SI(false, h, s);
    }
    
    private SI help4(int h, int s, List<Integer> ps) {
        ps.add(s);
        return new SI(true, h, s);
    }
    
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> ps = new ArrayList<>();
        help1(root, ps);
        
        help2(ps);
        
        return k <= ps.size() ? ps.get(k - 1) : -1;
    }
    
    
}",1420544932
Min,IAFB358kMw,571,3588,java,"import java.util.*;

class Solution {
     
    private void init(String in) {
        seq = in;
        n = in.length();
        win = new boolean[3][3];
        win[0][2] = win[1][0] = win[2][1] = true;
    }

    private int[][] processPos(int[][] cur, int p) {
        int[][] next = new int[4][2 * n + 1];
        iteratePrev(cur, next, p);
        return next;
    }

    private void iteratePrev(int[][] cur, int[][] next, int p) {
        int pm = 0;
        while (pm < 4) {
            procScores(cur, next, pm, p);
            pm++;
        }
    }
    
    private static final int MOD = 1000000007;
    private boolean[][] win;
    private String seq;
    private int n;

    private void procScores(int[][] cur, int[][] next, int pm, int p) {
        int s = 0;
        while (s <= 2 * n) {
            if (cur[pm][s] != 0) {
                calcNext(cur, next, pm, s, p);
            }
            s++;
        }
    }

    private void calcNext(int[][] cur, int[][] next, int pm, int s, int p) {
        int nm = 0;
        while (nm < 3) {
            if (pm == 3 || nm != pm) {
                updNext(cur, next, pm, s, nm, p);
            }
            nm++;
        }
    }

    private void updNext(int[][] cur, int[][] next, int pm, int s, int nm, int p) {
        int cm = charToIdx(seq.charAt(p));
        int delta = calcDelta(cm, nm);
        int ns = s + delta;
        if (isValid(ns)) {
            next[nm][ns] = (next[nm][ns] + cur[pm][s]) % MOD;
        }
    }

    private int charToIdx(char c) {
        return c == 'F' ? 0 : (c == 'W' ? 1 : 2);
    }

    private int calcDelta(int cm, int nm) {
        return (cm != nm) ? (win[cm][nm] ? -1 : 1) : 0;
    }

    private boolean isValid(int s) {
        return s >= 0 && s <= 2 * n;
    }

    private int calcResult(int[][] finalStates) {
        int t = 0;
        int m = 0;
        while (m < 3) {
            t = sumWinning(finalStates, t, m);
            m++;
        }
        return t;
    }

    private int sumWinning(int[][] states, int t, int m) {
        int s = n + 1;
        while (s <= 2 * n) {
            t = (t + states[m][s]) % MOD;
            s++;
        }
        return t;
    }

    public int countWinningSequences(String in) {
        init(in);
        int[][] states = new int[4][2 * n + 1];
        states[3][n] = 1;

        int p = 0;
        while (p < n) {
            states = processPos(states, p);
            p++;
        }

        return calcResult(states);
    }

}
",1420566701
Min,IAFB358kMw,571,3610,java,"import java.util.*;

class Solution {
    
    private int help1(int[] nums, int start, int k, int x) {
        Map<Integer, Integer> fMap = new HashMap<>();
        help2(nums, start, k, fMap);
        
        List<Map.Entry<Integer, Integer>> sl = new ArrayList<>(fMap.entrySet());
        sl.sort((a, b) -> a.getValue().equals(b.getValue()) ? 
            b.getKey() - a.getKey() : b.getValue() - a.getValue());
        
        return help3(sl, x);
    }
    
    private void help2(int[] nums, int start, int k, Map<Integer, Integer> fMap) {
        for (int j = start; j < start + k; j++) {
            fMap.put(nums[j], fMap.getOrDefault(nums[j], 0) + 1);
        }
    }
    
    private int help3(List<Map.Entry<Integer, Integer>> sl, int x) {
        int s = 0, c = 0;
        for (Map.Entry<Integer, Integer> entry : sl) {
            if (c >= x) break;
            s += entry.getKey() * entry.getValue();
            c++;
        }
        return s;
    }
    
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        
        for (int i = 0; i <= n - k; i++) {
            ans[i] = help1(nums, i, k, x);
        }
        
        return ans;
    }
    
    
}",1420528469
9560kiran,9560kiran,572,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    
    pair<bool, int> findPerfectSubtree(TreeNode* root, vector<int>& subtreeSizes) {
        if (!root) return {true, 0};

        auto [isLeftPerfect, leftSize] = findPerfectSubtree(root->left, subtreeSizes);
        auto [isRightPerfect, rightSize] = findPerfectSubtree(root->right, subtreeSizes);


        if (isLeftPerfect && isRightPerfect && leftSize == rightSize) {
            int subtreeSize = 1 + leftSize + rightSize;
            subtreeSizes.push_back(subtreeSize);
            return {true, subtreeSize};
        }

        return {false, 0};
  }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> subtreeSizes;
        findPerfectSubtree(root, subtreeSizes);

        if (subtreeSizes.size() < k) return -1;

        sort(subtreeSizes.rbegin(), subtreeSizes.rend());

        return subtreeSizes[k - 1];
    }
};",1420534444
9560kiran,9560kiran,572,3588,cpp,"class Solution {
public: 
    const int MOD = 1e9 + 7;

     int win[3][3];
    int countWinningSequences(string s) {
        int n=s.size();
        vector<int> Alice(n);
        
        for (int i = 0; i < n; ++i) {
            if (s[i] == 'F') Alice[i] = 0;
            else if (s[i] == 'W') Alice[i] = 1;
            else if (s[i] == 'E') Alice[i] = 2;
        }

        //
        memset(win, 0, sizeof(win));
        win[0][2] = 1;
        win[2][0] = -1;
        win[1][0] = 1; 
        win[0][1] = -1;
        win[2][1] = 1;
        win[1][2] = -1;

        vector<vector<vector<int>>> dp(2, vector<vector<int>>(4, vector<int>(2 * n + 1, 0)));
        int offset = n; 
        dp[0][3][offset] = 1;

        for (int i = 0; i < n; ++i) {
            int curr = i % 2;
            int next = (i + 1) % 2;
            for (int p = 0; p < 4; ++p) {
                fill(dp[next][p].begin(), dp[next][p].end(), 0);
            }

            for (int p = 0; p < 4; ++p) {
                for (int score_diff = 0; score_diff <= 2 * n; ++score_diff) {
                    if (dp[curr][p][score_diff] > 0) {
                        for (int c = 0; c < 3; ++c) {
                            if (p != c && !(p == 3 && c == p)) { 
                                int delta = win[c][Alice[i]];
                                int new_score = score_diff + delta;
                                if (new_score >= 0 && new_score <= 2 * n) {
                                    dp[next][c][new_score] = (dp[next][c][new_score] + dp[curr][p][score_diff]) % MOD;
                                }
                            }
                        }
                    }
                }
            }
        }

        int ans = 0;
        int final = n % 2;
        for (int p = 0; p < 3; ++p) {
            for (int score_diff = n + 1; score_diff <= 2 * n; ++score_diff) {
                ans = (ans + dp[final][p][score_diff]) % MOD;
            }
        }
        return ans;
    }
};",1420566758
9560kiran,9560kiran,572,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i+k-1<n;i++){
              priority_queue<pair<int,int>> pq;
              unordered_map<int,int> mp;
              for(int j=0;j<k;j++){
                   mp[nums[i+j]]++;
              }
               int sum=0;
              if(mp.size()<x){
                  for(auto it:mp) sum+=it.first*it.second;
                  
              }
              else{
                  for(auto it:mp) {
                      // cout<<it.first<<"", ""<<it.second<<""   "";
                      pq.push({it.second,it.first});
                  }
                  // cout<<endl;
                  int temp1=x;
                  while(pq.size() && temp1>0){
                      int temp=pq.top().first;
                      int cnt=pq.top().second;
                      pq.pop();
                      // cout<<temp<<"" : ""<<cnt<<""   "";
                      temp1--;
                      
                      sum+=temp*cnt;
                  }
                  // cout<<endl;
              }
            ans.push_back(sum);
              
        }
        return ans;
    }
};",1420530620
simon,midnightsimon,574,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        priority_queue<int, vector<int>, greater<int>> pq;
        
        auto dfs = [&](auto& dfs, TreeNode* cur) -> pair<int, bool> {
            
            if(!cur) return {0, true};
            
            auto [left_size, left_full] = dfs(dfs, cur->left);
            auto [right_size, right_full] = dfs(dfs, cur->right);
            int size = left_size + right_size + 1;
            bool is_full = false;
            if(!cur->left && !cur->right) {
                is_full = true;
            } else if (cur->left && cur->right) {
                is_full = true;
            }
            if(right_size == left_size && left_full && right_full && is_full) {
                pq.push(size); 
                if(pq.size() > k) {
                    pq.pop();
                }
            } 
            
            return {size, is_full && left_full && right_full && left_size == right_size};
        };
        dfs(dfs, root);
        if(pq.size() < k) {
            return -1;
        }
        return pq.top();
    }
};

/*
Input:
[10,6,2,null,11,10,null]
3
Output:
1
Expected:
-1

                    10
            6               2
        x     11        10      x  

    [10,6,2,null,11,10,null]
    3

*/",1420541523
simon,midnightsimon,574,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        
        int n = s.length();
        vector<char> all = {'F', 'W', 'E'};
        int MOD = 1e9+7;
        auto Comp = [&](char a, char b) -> int {
            if(b == 'F' && a == 'E') {
                return 1;
            } else if(b == 'W' && a == 'F') {
                return 1;
            } else if(b == 'E' && a == 'W') {
                return 1;
            } else if(a == 'F' && b == 'E') {
                return -1;
            } else if(a == 'W' && b == 'F') {
                return -1;
            } else if(a == 'E' && b == 'W') {
                return -1;
            } else if (a == b) {
                return 0;
            }
            return 0;
        };
        vector<int> hack(26);
        hack['W' - 'A'] = 0;
        hack['F' - 'A'] = 1;
        hack['E' - 'A'] = 2;
        vector<vector<vector<int>>> cache(4, vector<vector<int>>(n+1, vector<int>(3005, -1)));
        auto dp = [&](auto& dp, int i, char prev, int points) -> int {
            if(i >= n) {
                 return points > 1500;
            }
            int prev_key = hack[prev - 'A'];
            if(cache[prev_key][i][points] != -1) {
                return cache[prev_key][i][points];
            }
            int total = 0;
            for(char c: all) {
                if(c == prev) continue;
                total = (total + dp(dp, i+1, c, points+Comp(s[i], c))) % MOD;
            }
            
            return cache[prev_key][i][points] = total;
            
        };
        
        return dp(dp, 0, 'X', 1500);
    }
};",1420560845
simon,midnightsimon,574,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        using pii = pair<int, int>;
        
        int n = nums.size();
        for(int i = 0; i < (n - k) + 1; i++) {
            unordered_map<int, int> freq;
            for(int j = i; j < (i+k); j++) {
                freq[nums[j]]++;
            }
            vector<pii> all;
            int all_sum = 0;
            // cout << i << "": "" << endl;
            for(auto& [num, count] : freq) {
                // cout << num << "":"" << count << endl;
                all.push_back({count, num});
                all_sum += num*count;
            }  
            sort(all.rbegin(), all.rend());
            int cur = 0;
            
            
            if(all.size() < x) {
                ans.push_back(all_sum);
            } else {
                for(int i = 0; i < x; i++) {
                    cur += all[i].first * all[i].second;    
                }
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1420524761
Shivanshu Dixit,shivanshudixit16,575,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        s = []
        
        def dfs(cn):
            if not cn:
                return -1
            
            if not cn.left and not cn.right:
                s.append(1)
                return 1
            
            #lc = 0
            
            lc = dfs(cn.left)
            
            rc = dfs(cn.right)
            if lc == rc and lc  != -1:
                s.append(lc + rc +1)
                return lc + rc +1
            return -1
        dfs(root)
        
        s.sort(reverse=True)
        # print(s)
        return  s[k-1] if len(s) >= k else -1",1420528473
Shivanshu Dixit,shivanshudixit16,575,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9  + 7
        n = len(s)
        
        wd = {
            ""W"" : ""E"",
            ""E"" : ""F"",
            ""F"" : ""W""
        }
        
        def isWin(wc,dc):
            if wc == dc == -1:
                return True
            cn = n - dc
            return wc > cn // 2
        
        @cache
        def dfs(i,wc,dc,lm):
            if i >= n:
                # return 1 if isWin(wc,dc) else 0
                return 1 if wc == 0 else 0
            if wc == 0:
                cc = 0
                for nc in wd.keys():
                    if nc == lm:
                        continue
                    cc += dfs(i+1,wc,dc,nc)
                return cc % MOD
            cc = 0
            for nc in wd.keys():
                if nc == lm:
                    continue
                cdc,cwc = dc,wc
                if s[i] == nc:
                    if not cdc:
                        cwc -= 1
                    cdc ^= 1
                if wd[s[i]] == nc:
                    cwc -= 1
                
                cc += dfs(i+1,cwc,cdc,nc)
            return cc % MOD
        
        rw = (n // 2) + 1
        ans = dfs(0,rw, n & 1 ,""A"")
        return ans % MOD",1420554840
Shivanshu Dixit,shivanshudixit16,575,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        ans = []
        for i in range(len(nums)):
            j = i + k
            if j > len(nums):
                break
            cc = Counter(nums[i:j])
            na = sorted([ (-v,-k) for k,v in cc.items() ])
            na = na[:x]
            cs = sum( [p[-1]*p[0] for p in na])
            ans.append(cs)
        return ans
                
            ",1420521455
Deep Vora,deepvora,577,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // Helper function to check if a tree is perfect and return its size if true
    pair<bool, int> isPerfect(TreeNode* root) {
        if (!root) return {true, 0};
        
        auto left = isPerfect(root->left);
        auto right = isPerfect(root->right);
        
        // A subtree is perfect if both left and right subtrees are perfect,
        // they are of the same height, and both have the same size.
        if (left.first && right.first && left.second == right.second) {
            return {true, 2 * left.second + 1};
        }
        return {false, 0};
    }
    
    // Main function to find the kth largest perfect subtree size
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        collectPerfectSubtreeSizes(root, sizes);
        
        // Sort sizes in descending order to find the kth largest
        sort(sizes.rbegin(), sizes.rend());
        
        // If we have at least k perfect subtrees, return the kth largest one
        return k <= sizes.size() ? sizes[k - 1] : -1;
    }
    
private:
    void collectPerfectSubtreeSizes(TreeNode* root, vector<int>& sizes) {
        if (!root) return;
        
        auto [isPerfectSubtree, size] = isPerfect(root);
        if (isPerfectSubtree) {
            sizes.push_back(size);
        }
        
        // Recursively check for other perfect subtrees in the left and right
        collectPerfectSubtreeSizes(root->left, sizes);
        collectPerfectSubtreeSizes(root->right, sizes);
    }
};
",1420561298
Deep Vora,deepvora,577,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        int offset = n; // Offset to handle negative indices (b_points can be from -n to n)
        
        // dp[i][j][b_points] where i is the round, j is the last creature Bob summoned, b_points is Bob's points minus Alice's points + offset
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(3, vector<int>(2 * n + 1, 0)));
        
        // Initialize base case for round 0 (first round)
        // For each possible creature Bob could summon in round 0 (0: F, 1: W, 2: E)
        for (int j = 0; j < 3; ++j) {
            int b_points = offset; // Start with a zero difference (0 + offset)
            if (s[0] == 'F' && j == 1) b_points++;  // Alice uses 'F', Bob uses 'W' (Bob gains a point)
            else if (s[0] == 'W' && j == 2) b_points++;  // Alice uses 'W', Bob uses 'E'
            else if (s[0] == 'E' && j == 0) b_points++;  // Alice uses 'E', Bob uses 'F'
            else if (s[0] == 'F' && j == 2) b_points--;  // Alice uses 'F', Bob uses 'E' (Alice gains a point)
            else if (s[0] == 'W' && j == 0) b_points--;  // Alice uses 'W', Bob uses 'F'
            else if (s[0] == 'E' && j == 1) b_points--;  // Alice uses 'E', Bob uses 'W'
            dp[1][j][b_points] = 1;
        }
        
        // Fill in the DP table for rounds 1 to n-1
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < 3; ++j) { // Last creature Bob used
                for (int b_points = 0; b_points <= 2 * n; ++b_points) {
                    if (dp[i][j][b_points] == 0) continue;
                    
                    // Determine next possible creatures for Bob
                    for (int next = 0; next < 3; ++next) {
                        if (next == j) continue; // Bob can't use the same creature consecutively
                        
                        int new_b_points = b_points;
                        if ((s[i] == 'F' && next == 1) || (s[i] == 'W' && next == 2) || (s[i] == 'E' && next == 0))
                            new_b_points++; // Bob gains a point
                        else if ((s[i] == 'F' && next == 2) || (s[i] == 'W' && next == 0) || (s[i] == 'E' && next == 1))
                            new_b_points--; // Alice gains a point
                        
                        if (new_b_points >= 0 && new_b_points <= 2 * n) {
                            dp[i + 1][next][new_b_points] = (dp[i + 1][next][new_b_points] + dp[i][j][b_points]) % MOD;
                        }
                    }
                }
            }
        }
        
        // Calculate the number of winning sequences for Bob
        int result = 0;
        for (int j = 0; j < 3; ++j) {
            for (int b_points = offset + 1; b_points <= 2 * n; ++b_points) {
                result = (result + dp[n][j][b_points]) % MOD;
            }
        }
        
        return result;
    }
};",1420534172
Deep Vora,deepvora,577,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> answer;
        unordered_map<int, int> freq;
        int n = nums.size();

        // Initialize the frequency map for the first window
        for (int i = 0; i < k; ++i) {
            freq[nums[i]]++;
        }

        // Function to calculate the x-sum from the frequency map
        auto calculateXSum = [&]() {
            // Store elements with their frequencies in a vector
            vector<pair<int, int>> freqVec(freq.begin(), freq.end());
            // Sort by frequency descending, then by value descending
            sort(freqVec.begin(), freqVec.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
                if (a.second == b.second) return a.first > b.first;
                return a.second > b.second;
            });

            // Sum occurrences of the top x elements
            int sum = 0;
            int count = 0;
            for (const auto& p : freqVec) {
                if (count < x) {
                    sum += p.first * p.second; // Add all occurrences of this element
                    count++;
                }
            }
            return sum;
        };

        // Calculate the x-sum for the first window
        answer.push_back(calculateXSum());

        // Slide the window through the rest of the array
        for (int i = k; i < n; ++i) {
            // Remove the element that is sliding out of the window
            freq[nums[i - k]]--;
            if (freq[nums[i - k]] == 0) {
                freq.erase(nums[i - k]);
            }

            // Add the new element that is entering the window
            freq[nums[i]]++;

            // Calculate the x-sum for the current window
            answer.push_back(calculateXSum());
        }

        return answer;
    }
};

",1420524882
HerbertTheBird,HerbertTheBird,579,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> size;
        dfs(root, size);
        for(int i = 0; i < size.size(); i++){
         //   cout << size[i] << endl;
        }
        sort(size.begin(), size.end());
        if(size.size() < k){
            return -1;
        }
        return size[size.size()-k];
    }
    int dfs(TreeNode* node, vector<int>& size){
        /*cout << ""node "" << node->val;
        if(node->left != nullptr){
            cout << "" l"" << node->left->val;
        }
        if(node->right != nullptr){
            cout << "" r"" << node->right->val;
        }
        cout << endl;*/
        if(node == nullptr)
            return 0;
        if(node->left == nullptr && node->right == nullptr){
            //cout << 1 << "" "" << node->val << endl;
            size.push_back(1);
            return 1;
        }
        if(node-> left != nullptr && node-> right != nullptr){
            int l = dfs(node->left, size);
            int r = dfs(node->right, size);
            if(l == r && l != 0){
                //cout << l+r+1 << "" "" << node->val << endl;
                size.push_back(l+r+1);
                return l+r+1;
            }
        }
        else{
        if(node -> left != nullptr){
            dfs(node->left, size);
        }
        if(node -> right != nullptr){
            dfs(node->right, size);
        }
        }
        return 0;

    }
};",1420532257
HerbertTheBird,HerbertTheBird,579,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s1) {
        int mod = 1E9+7;
        vector<int> s(s1.size());
        for(int i = 0; i < s.size(); i++){
            if(s1[i] == 'F')
                s[i] = 0;
            if(s1[i] == 'W')
                s[i] = 1;
            if(s1[i] == 'E')
                s[i] = 2;
        }
        //win gives 2 points, draw 1 point
        vector<vector<vector<long long>>> dp(s.size(), vector<vector<long long>>(s.size()*2+1, vector<long long>(3)));
        dp[0][0][(s[0]+2)%3] = 1;
        dp[0][1][s[0]] = 1;
        dp[0][2][(s[0]+1)%3] = 1;
        for(int i = 1; i < s.size(); i++){
            for(int mySpawn = 0; mySpawn < 3; mySpawn ++){
                for(int prevSpawn = 0; prevSpawn < 3; prevSpawn ++){
                    if(mySpawn == prevSpawn)
                        continue;
                    int score;
                    if(mySpawn == (s[i]+1)%3){
                        score = 2;
                    }
                    else if(mySpawn == s[i]){
                        score = 1;
                    }
                    else{
                        score = 0;
                    }
                    for(int j = 0; j < s.size()*2+1; j++){
                        int prev = dp[i-1][j][prevSpawn];
                        if(j+score < s.size()*2+1){
                            dp[i][j+score][mySpawn] += prev;
                            dp[i][j+score][mySpawn] %= mod;
                        }
                    }
                }
            }
        }
        /*for(int i = 0; i < s.size(); i++){
            cout << ""TURN --------------- "" << i << endl;
            for(int j = 0; j <= s.size()*2; j++){
                cout << ""for "" << j << "" points""<<endl;
                cout << ""F "" << dp[i][j][0] << "" W "" << dp[i][j][1] << "" E "" << dp[i][j][2] << endl;
            }
            
        }*/
        long long ans = 0;
        for(int i = s.size()+1; i <= s.size()*2; i++){
            ans += dp[s.size()-1][i][0];
            ans %= mod;
            ans += dp[s.size()-1][i][1];
            ans %= mod;
            ans += dp[s.size()-1][i][2];
            ans %= mod;
        }
        return ans;
    }
};",1420556146
HerbertTheBird,HerbertTheBird,579,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for(int i = 0; i+k <= nums.size(); i++){
            vector<pair<int, int>> freq(51);
            for(int j = 0; j < 51; j++){
                freq[j] = {0, j};
            }
            for(int j = i; j < i+k; j++){
                freq[nums[j]].first++;
            }
            sort(freq.begin(), freq.end());
            ans.push_back(0);
            for(int j = 0; j < x && j < 51; j++){
                int new_j = 50-j;
                ans[i] += freq[new_j].first*freq[new_j].second;
            }
        }
        return ans;
    }
};",1420567375
Jay Verma,JayVerma,580,3509,python3,"class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        perf_sizes = []

        # size of subtree, depth, and if perfect
        def dfs(root: Optional[TreeNode]):
            if not root:
                return 0, 0, True

            perf_here = (not root.left) == (not root.right)

            l, ld, lperf = dfs(root.left)
            r, rd, rperf = dfs(root.right)
            sz = 1 + l + r
            if perf_here and lperf and rperf and ld == rd:
                perf_sizes.append(sz)
                return sz, 1 + ld, True
            return 0, 0, False

        dfs(root)
        # print(perf_sizes)

        if len(perf_sizes) < k:
            return -1
        return sorted(perf_sizes, reverse=True)[k - 1]",1420549666
Jay Verma,JayVerma,580,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        MOD = 10**9 + 7

        ptdiff = {
            ""FE"": 1,
            ""EF"": -1,
            ""WF"": 1,
            ""FW"": -1,
            ""EW"": 1,
            ""WE"": -1,
            ""FF"": 0,
            ""EE"": 0,
            ""WW"": 0,
        }

        # @cache
        # def func(s: str, i: int, pts: int, prev="" ""):
        #     if i >= len(s):
        #         if pts > 0:
        #             return 1, True
        #         return 0, False

        #     ans = 0
        #     for mov in ""FWE"":
        #         if prev == mov:
        #             continue
        #         x, y = func(s, i + 1, pts + ptdiff[mov + s[i]], mov)
        #         if y

        #     return ans, ans != 0

        @cache
        def func(s: str, i: int, pts: int, prev="" ""):
            if i >= len(s):
                if pts > 0:
                    return 1
                return 0

            ans = 0
            for mov in ""FWE"":
                if prev == mov:
                    continue
                ans += func(s, i + 1, pts + ptdiff[mov + s[i]], mov)
                ans %= MOD

            return ans

        return func(s, 0, 0)",1420567386
Jay Verma,JayVerma,580,3610,python3,"
class Solution:
    def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:
        n = len(nums)
        ans = []
        for i in range(n - k + 1):
            subarr = nums[i : i + k]
            if len(subarr) <= x:
                ans.append(sum(subarr))
            else:
                cnt = Counter(subarr)
                if len(cnt.keys()) <= x:
                    ans.append(sum(subarr))
                else:
                    scnt = sorted([(c, num) for num, c in cnt.items()], reverse=True)[
                        :x
                    ]
                    tsum = 0
                    for c, num in scnt:
                        tsum += c * num
                    ans.append(tsum)
        return ans",1420529720
Mason Pimentel,masonpimentel,581,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.sizes: list[int] = []


        def size_of_subtree(root: Optional[TreeNode]) -> int:
            if root == None:
                return 0
            
            left = size_of_subtree(root.left)
            right = size_of_subtree(root.right)

            if left == right and left != -1 and right != -1:
                size = left + right + 1
                
                self.sizes.append(size)
                return size
            else:
                return -1
        
        size_of_subtree(root)

        
        self.sizes.sort(reverse=True)
        print(self.sizes)

        if len(self.sizes) < k:
            return -1
        else:
            return self.sizes[k - 1]
",1420540977
Mason Pimentel,masonpimentel,581,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        self.total_turns = len(s)

        self.dp: dict = {}

        def rec(turn: int, last_move: str, score: int, log: str) -> int:
            if turn == self.total_turns:
                # print(f'log {log} score {score}')

                return 1 if score > 0 else 0
            
            res = 0
            alice_move = s[turn]
            for move in ['F', 'W', 'E']:
                if move == last_move:
                    continue
                
                turn_score = 0
                if (alice_move == 'F' and move == 'E') or (alice_move == 'W' and move == 'F') or (alice_move == 'E' and move == 'W'):
                    turn_score = -1
                elif (move == 'F' and alice_move == 'E') or (move == 'W' and alice_move == 'F') or (move == 'E' and alice_move == 'W'):
                    turn_score = 1

                check_turn = turn + 1
                check_score = score + turn_score

                if check_turn not in self.dp:
                    self.dp[check_turn] = {}
                if move not in self.dp[check_turn]:
                    self.dp[check_turn][move] = {}
                
                if check_score in self.dp[check_turn][move]:
                    rec_res = self.dp[check_turn][move][check_score]
                    # print('cached')
                else:
                    rec_res = rec(check_turn, move, check_score, log + move)
                    self.dp[check_turn][move][check_score] = rec_res

                res += rec_res
            
            return res
        
        return rec(0, None, 0, '') % 1000000007
                
            ",1420567387
Mason Pimentel,masonpimentel,581,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        def x_sum(nums: list[int], x: int) -> int:
            # print(nums)
            c = Counter(nums)

            tuples = [(c[val], val) for val in c]

            tuples.sort(reverse=True)

            allowed = set([t[1] for t in tuples[:x]])

            # print(f'allowed {allowed}')

            return sum([v if v in allowed else 0 for v in nums])
        
        return [x_sum(nums[i : i + k], x) for i in range(len(nums) - k + 1)]
",1420527811
M Kawa,mkawa222,583,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(u):
            if u.left==None and u.right==None:
                ss.append(1)
                return 1
            l=r=-1
            if u.left:l=dfs(u.left)
            if u.right:r=dfs(u.right)
            if l==-1 or r==-1 or l!=r:
                ss.append(-1)
                return -1
            ss.append(l*2+1)
            return l*2+1
        ss=[]
        dfs(root)
        if len(ss)<k:return -1
        ss.sort(reverse=True)
        return ss[k-1]
",1420534052
M Kawa,mkawa222,583,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        md=10**9+7
        t=""FWE""
        dp=[[0]*3 for _ in range(2005)]
        pre=[[0]*3 for _ in range(2005)]
        i=t.find(s[0])
        for j in range(3):
            if j==(i+1)%3:dp[1][j]=1
            if j==i:dp[0][j]=1
            if j==(i-1)%3:dp[-1][j]=1
        for c in s[1:]:
            i=t.find(c)
            dp,pre=pre,dp
            for d in range(-500,1000):
                for j in range(3):
                    p=pre[d][j]
                    if p==0:continue
                    for k in range(3):
                        if j==k:continue
                        nd=d+(k+1-i)%3-1
                        dp[nd][k]+=p
                        dp[nd][k]%=md
                    pre[d][j]=0
        ans=0
        for d in range(1,1001):
            ans+=sum(dp[d])
            ans%=md
        return ans
",1420555236
M Kawa,mkawa222,583,3610,python3,"from collections import Counter

class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def f(l,r):
            cnt=Counter(nums[l:r])
            ca=[(cnt[a],a) for a in cnt]
            ca.sort(reverse=True)
            res=0
            for c,a in ca[:x]:res+=a*c
            return res
        n=len(nums)
        ans=[]
        for i in range(n-k+1):
            ans.append(f(i,i+k))
        return ans
",1420522373
Vishal,rollingzipline,584,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        List<Integer> size = new ArrayList<>();
        dfs(root, size);
        if (size.size() < k)  return -1;
        Collections.sort(size, Collections.reverseOrder());
        return size.get(k - 1);
    }
    
    private int[] dfs(TreeNode root, List<Integer> sizes) {
        if (root == null) return new int[]{1,0,0};
        var left = dfs(root.left, sizes);
        var right = dfs(root.right, sizes);

        boolean isPerfect = (left[0] == 1) && (right[0] == 1) && (left[1] == right[1]);
        int height = Math.max(left[1], right[1]) + 1;
        int size = left[2] + right[2] + 1;
        if (isPerfect) sizes.add(size);
        return new int[]{isPerfect ? 1 : 0, height, size};
    }
}",1420545650
Vishal,rollingzipline,584,3588,java,"class Solution {
    int n;
    int MOD = 1_000_000_007;
    int[][][] memo;
    int[] aliceMoves;
    int[] beats = new int[4];
    public int countWinningSequences(String s) {
        n = s.length();
        Map<Character, Integer> charToInt = new HashMap<>();
        charToInt.put('F', 1);
        charToInt.put('W', 2);
        charToInt.put('E', 3);
        beats[1] = 3;
        beats[2] = 1;
        beats[3] = 2;
        aliceMoves = new int[n];
        for (int i = 0; i < n; i++) aliceMoves[i] = charToInt.get(s.charAt(i));
        memo = new int[n + 1][2 * n + 1][4];
        for (int[][] arr2D : memo) {
            for (int[] arr1D : arr2D) {
                Arrays.fill(arr1D, -1);
            }
        }
        return dfs(0, 0, 0);
    }

    private int dfs(int pos, int scoreDiff, int prevMove) {
        if (pos == n) return scoreDiff > 0 ? 1 : 0;
        if (memo[pos][scoreDiff + n][prevMove] != -1) return memo[pos][scoreDiff + n][prevMove];
        int totalWays = 0;

        for (int bobMove = 1; bobMove <= 3; bobMove++) {
            if (bobMove == prevMove) continue; 
            int aliceMove = aliceMoves[pos];
            int outcome = getOutcome(aliceMove, bobMove);
            int newScoreDiff = scoreDiff + outcome;
            totalWays = (totalWays + dfs(pos + 1, newScoreDiff, bobMove)) % MOD;
        }

        memo[pos][scoreDiff + n][prevMove] = totalWays;
        return totalWays;
    }

    private int getOutcome(int aliceMove, int bobMove) {
        if (aliceMove == bobMove) {
            return 0; 
        } else if (beats[bobMove] == aliceMove) {
            return 1;
        } else {
            return -1; 
        }
    }
}",1420567466
Vishal,rollingzipline,584,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        // Map<Integer,Integer> map = new HashMap<>();
        // Map<Integer,Integer> map1 = new TreeMap<>();
        // for (int n : nums) map.put(n, map.getOrDefault(n, 0) + 1);
        // for (var e : map.entrySet()) {
        //     map1.put(e.getValue(), e.getKey());
        // }
        // int i = 0, res = 0;
        // for (var e : map.entrySet()) {
        //     res += e.getKey() * e.getValue();
        //     i++;
        //     if (i == x) return res;
        // }
        // return res;
        int n = nums.length;
        int[] answer = new int[n - k + 1];

        for (int i = 0; i <= n - k; i++) {
            Map<Integer, Integer> freqMap = new HashMap<>();
            List<int[]> freqList = new ArrayList<>();

            for (int j = i; j < i + k; j++) {
                freqMap.put(nums[j], freqMap.getOrDefault(nums[j], 0) + 1);
            }
            for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
                freqList.add(new int[]{entry.getKey(), entry.getValue()});
            }

            Collections.sort(freqList, (a, b) -> {
                if (b[1] != a[1]) {
                    return b[1] - a[1]; 
                } else {
                    return b[0] - a[0];
                }
            });
            int topElements = Math.min(x, freqList.size());
            Set<Integer> elementsToKeep = new HashSet<>();
            for (int idx = 0; idx < topElements; idx++) {
                elementsToKeep.add(freqList.get(idx)[0]);
            }
            int sum = 0;
            for (int j = i; j < i + k; j++) {
                if (elementsToKeep.contains(nums[j])) {
                    sum += nums[j];
                }
            }
            answer[i] = sum;
        }

        return answer;
    }
}",1420525208
RegexRover,RegexRover,586,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector <int> a;
    pair<bool,pair<int,int>> calc(TreeNode* root)
    {
        int h,sz;
        if(root == NULL)
        {
            return {true,{0,0}};
        }
        auto left = calc(root->left);
        auto right = calc(root->right);
        if(left.first && right.first && left.second.first == right.second.first)
        {
            h = left.second.first + 1;
            sz = left.second.second + right.second.second + 1;
            a.push_back(sz);
            return {true,{h,sz}};
        }
        return {false,{0,0}};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) 
    {
        calc(root);
        sort(a.rbegin(),a.rend());
        return (k <= a.size() ? a[k-1] : -1);
    }
};",1420537452
RegexRover,RegexRover,586,3588,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    string moves = ""FWE"";
    int dp[1001][4][2005];
    long long calc(int idx,int last,int dif,string &s)
    {
        long long n = s.size(),ans = 0,alice,bob,cur;
        if(idx == n)
        {
            return (dif > 0 ? 1 : 0);
        }
        if(dp[idx][last][1002 + dif] != -1)
        {
            return dp[idx][last][1002 + dif];
        }
        alice = moves.find(s[idx]);
        for(bob=0;bob<3;bob++)
        {
            if(bob == last)
            {
                continue;
            }
            cur = 0;
            if((bob == 0 && alice == 2) || (bob == 1 && alice == 0) || (bob == 2 && alice == 1)) 
            {
                cur++;  
            } 
            else if ((alice == 0 && bob == 2) || (alice == 1 && bob == 0) || (alice == 2 && bob == 1)) 
            {
                cur--;
            }
            ans = (ans + calc(idx+1,bob,dif+cur,s)) % mod;
        }
        return dp[idx][last][1002 + dif] = ans;
    }
    int countWinningSequences(string s) 
    {
        memset(dp,-1,sizeof(dp));
        return calc(0,3,0,s);
    }
};",1420555622
RegexRover,RegexRover,586,3610,cpp,"class Solution {
public:
    int calc(vector<int> &a,int x)
    {
        int n = a.size(),i,ans = 0;
        unordered_map<int,int> mp;
        for(i=0;i<n;i++)
        {
            mp[a[i]]++;
        }
        vector<pair<int,int>> v;
        for(auto p : mp)
        {
            v.push_back({p.second,p.first});
        }
        sort(v.begin(),v.end());
        reverse(v.begin(),v.end());
        n = v.size();
        n = min(n,x);
        for(i=0;i<n;i++)
        {
            ans += v[i].first * v[i].second;
        }
        return ans;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) 
    {
        int n = nums.size(),i,j;
        vector <int> ans;
        for(i=0;i<n-k+1;i++)
        {
            j = i;
            vector <int> a;
            while(a.size() < k)
            {
                a.push_back(nums[j++]);
            }
            ans.push_back(calc(a,x));
        }
        return ans;
    }
};",1420524586
lixiangfan97,lixiangfan97,587,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // bool perfect(int siz) {
    //     siz++;
    //     while(siz % 2 == 0) siz /= 2;
    //     return siz == 1;
    // }
    pair<int, bool> dfs(TreeNode* root, vector<int>& siz) {
        if (root == nullptr) {
            return {0, true};
        }
        auto p1 = dfs(root->left, siz);
        auto p2 = dfs(root->right, siz);
        int curr = p1.first + p2.first + 1;
        bool perfect = p1.second && p2.second && p1.first == p2.first;
        if (perfect)
            siz.push_back(curr);
        return {curr, perfect};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> siz;
        dfs(root, siz);
        sort(siz.begin(), siz.end(), [](const int x, const int y) {
            return x > y;
        });
        if (k - 1 >= siz.size()) {
            return -1;
        }
        return siz[k-1];
    }
};",1420537978
lixiangfan97,lixiangfan97,587,3588,cpp,"class Solution {
public:
    #define ll long long
    const ll MOD = (ll)(1e9+7);
    char cards[3] = {'F', 'W', 'E'};
    ll dp[1005][2005][3];

    int points(char x, char y) {
        if (x == 'F') {
            if (y == 'E')
                return 1;
            else if (y == 'F')
                return 0;
            else
                return -1;
        }
        if (x == 'W') {
            if (y == 'F')
                return 1;
            else if (y == 'W')
                return 0;
            else
                return -1;
        }
        if (x == 'E') {
            if (y == 'W')
                return 1;
            else if (y == 'E')
                return 0;
            else
                return -1;
        }
        return -2;
    }
    ll qpow(ll x, ll n) {
        ll ret = 1;
        while (n) {
            if (n & 1) {
                ret *= x;
                ret %= MOD;
            }
            n >>= 1;
            x = (x * x) % MOD;
        }
        return ret;
    }
    ll inv(ll x) {
        return qpow(x, MOD-2);
    }
    int countWinningSequences(string s) {
        memset(dp, 0, sizeof(dp));
        dp[0][1000][0] = 1;
        dp[0][1000][1] = 1;
        dp[0][1000][2] = 1;
        const int n = (int)s.size();
        for (int i = 0; i < n; ++i) {
            for (int j = -i; j <= i; ++j) {
                if (dp[i][j+1000][0] > 0) {
                    dp[i+1][j+points(cards[1], s[i])+1000][1] += dp[i][j+1000][0];
                    dp[i+1][j+points(cards[1], s[i])+1000][1] %= MOD;
                    dp[i+1][j+points(cards[2], s[i])+1000][2] += dp[i][j+1000][0];
                    dp[i+1][j+points(cards[2], s[i])+1000][2] %= MOD;
                }
                if (dp[i][j+1000][1] > 0) {
                    dp[i+1][j+points(cards[0], s[i])+1000][0] += dp[i][j+1000][1];
                    dp[i+1][j+points(cards[0], s[i])+1000][0] %= MOD;
                    dp[i+1][j+points(cards[2], s[i])+1000][2] += dp[i][j+1000][1];
                    dp[i+1][j+points(cards[2], s[i])+1000][2] %= MOD;
                }
                if (dp[i][j+1000][2] > 0) {
                    dp[i+1][j+points(cards[0], s[i])+1000][0] += dp[i][j+1000][2];
                    dp[i+1][j+points(cards[0], s[i])+1000][0] %= MOD;
                    dp[i+1][j+points(cards[1], s[i])+1000][1] += dp[i][j+1000][2];
                    dp[i+1][j+points(cards[1], s[i])+1000][1] %= MOD;
                }
            }
        }
        ll ans = 0;
        for (int k = 0; k < 3; ++k) {
            for (int j = 1; j <= n; ++j) {
                ans += dp[n][j+1000][k];
                ans %= MOD;
            }
        }
        ans = ans * inv(2) % MOD;
        return (int)ans;
    }
};",1420561958
lixiangfan97,lixiangfan97,587,3610,cpp,"class Solution {
public:
    
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> cnts(51, 0);
        vector<int> ans((int)nums.size()-k+1, 0);
        for (int i = 0; i < k; ++i) {
            cnts[nums[i]]++;
        }    
        for (int i = 0; i + k - 1 < nums.size(); ++i) {
            vector<pair<int, int> > v;
            for (int j = 1; j <= 50; ++j) {
                v.push_back({cnts[j], j});
            }
            sort(v.begin(), v.end(), [](const pair<int, int>& x, const pair<int, int>& y) {
                if (x.first != y.first) {
                    return x.first > y.first;
                }
                return x.second > y.second;
            });
            for (int j = 0; j < x; ++j) {
                ans[i] += v[j].first * v[j].second;
            }
            if (i + k < nums.size()) {
                cnts[nums[i]]--;
                cnts[nums[i+k]]++;
            }
        }
        return ans;
    }
};",1420527594
Priyanshu Raj,priyanshuraj30122003,589,3509,cpp,"class Solution {
public:
    // Helper function that returns the height of a subtree if it is perfect, else -1
    int findPerfectSubtrees(TreeNode* root, vector<int>& subtreeSizes) {
        if (!root) return 0; // Empty subtree is trivially perfect (height 0)

        // Recursively check the left and right subtrees
        int leftHeight = findPerfectSubtrees(root->left, subtreeSizes);
        int rightHeight = findPerfectSubtrees(root->right, subtreeSizes);

        // If left and right are perfect and have the same height
        if (leftHeight != -1 && rightHeight != -1 && leftHeight == rightHeight) {
            int size = (1 << (leftHeight + 1)) - 1; // Size of a perfect binary tree of height h
            subtreeSizes.push_back(size);
            return leftHeight + 1; // Height of the current perfect subtree
        }

        // If it's not a perfect subtree, return -1
        return -1;
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> subtreeSizes;

        // Find all perfect subtrees and their sizes
        findPerfectSubtrees(root, subtreeSizes);

        // Sort the sizes in descending order
        sort(subtreeSizes.begin(), subtreeSizes.end(), greater<int>());

        // Return the k-th largest size, if exists
        if (k > 0 && k <= subtreeSizes.size()) {
            return subtreeSizes[k - 1];
        }

        // If k is out of bounds, return -1 (or some error code)
        return -1;
    }
};
",1420532143
Priyanshu Raj,priyanshuraj30122003,589,3588,cpp,"class Solution {
public:
    const long long mod = 1e9 + 7;
    string cr = ""EFW"";

    long long f(long long idx, long long prev, long long score, string &s, vector<vector<vector<long long>>> &dp, long long offset) {
        if (idx == s.size()) {
            return score > 1000 ? 1 : 0;
        }
        if (dp[idx][score - offset][prev] != -1) return dp[idx][score - offset][prev];

        long long ans = 0;
        for (long long i = 0; i < 3; i++) {
            if (i != prev) {
                if (s[idx] == cr[i]) {
                    ans = (ans + f(idx + 1, i, score, s, dp, offset)) % mod;
                } else {
                    if (s[idx] == 'E' && i == 1 || s[idx] == 'F' && i == 2 || s[idx] == 'W' && i == 0) {
                        ans = (ans + f(idx + 1, i, score + 1, s, dp, offset)) % mod;
                    } else {
                        ans = (ans + f(idx + 1, i, score - 1, s, dp, offset)) % mod;
                    }
                }
            }
        }
        return dp[idx][score - offset][prev] = ans % mod;
    }

    int countWinningSequences(string s) {
        long long n = s.size();
        long long offset = 1000 - n;  // Score can vary between [1000 - n, 1000 + n]
        
        // Only store dp for score range [1000 - n, 1000 + n]
        vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(2 * n + 1, vector<long long>(4, -1)));
        return f(0, 3, 1000, s, dp, offset) % mod;
    }
};
",1420561984
Priyanshu Raj,priyanshuraj30122003,589,3610,cpp,"class Solution {
public:
    int xsum(vector<int> &nums, int x){
        vector<int> freq(51,0);
        for(int i:nums) freq[i]++;
        vector<pair<int,int>> vp;
        for(int i=0; i<51; i++) vp.push_back({freq[i],i});
        sort(vp.begin(),vp.end());
        int ans=0;
        for(int i=vp.size()-1; i>=0; i--){
            if(x==0) break;
            x--;
            ans+=(vp[i].second)*(vp[i].first);
        }
        return ans;
    }

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0; i<n-k+1; i++){
            vector<int> curr;
            for(int j=i; j<i+k; j++){
                curr.push_back(nums[j]);
            }
            ans.push_back(xsum(curr,x));
        }
        return ans;
    }
};",1420526972
Akuldeep,akuldeepj,591,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def build(n):
            if not n:
                return True, 0, 0  
            if not n.left and not n.right:
                sizes.append(1)
                return True, 1, 1
            lp, ld, ls = build(n.left)
            rp, rd, rs = build(n.right)
            if lp and rp and ld == rd:
                currs = ls + rs + 1
                currd = ld +1
                sizes.append(currs)
                return True, currd, currs
            else:
                return False, max(ld, rd) +1, 0  

        build(root)
        if len(sizes) < k:
            return -1
        sizes.sort(reverse=True)
        return sizes[k-1]",1420537106
Akuldeep,akuldeepj,591,3588,python3,"MOD = 10**9 + 7

class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        map = {'F': 0, 'E': 1, 'W': 2}
        ams = [map[char] for char in s]
        dp = [[[0]*4 for _ in range(2*n+1)] for _ in range(n+1)]
        dp[0][n][3] = 1  
        
        for i in range(n):
            for j in range(-n, n+1):
                for k in range(4):
                    c = dp[i][j + n][k]
                    if c == 0:
                        continue
                    for bm in range(3):  
                        if bm == k:
                            continue
                        am = ams[i]
                        d = (bm - am + 3) % 3
                        if d == 0:
                            x = j
                        elif d == 1:
                            x = j - 1
                        else:  
                            x = j + 1
                        if -n <= x <= n:
                            dp[i+1][x + n][bm] = (dp[i+1][x + n][bm] + c) % MOD

        res = 0
        for i in range(1, n+1):
            for j in range(3):
                res = (res + dp[n][i + n][j]) % MOD
        return res
",1420555883
Akuldeep,akuldeepj,591,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        res = []
        a = Counter(nums[:k])
        
        for i in range(len(nums) - k + 1):
            l = sorted(a.items(), key=lambda k: (-k[1], -k[0]))
            s = sum(num * j for num, j in l[:x])
            res.append(s)
            
            if i + k < len(nums):
                a[nums[i]] -= 1
                if a[nums[i]] == 0:
                    del a[nums[i]]
                a[nums[i + k]] += 1
        
        return res",1420523225
Tharunkumar S,tharunkumars,592,3509,python,"# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def kthLargestPerfectSubtree(self, root, k):
        """"""
        :type root: TreeNode
        :type k: int
        :rtype: int
        """"""
        sizes = []  # Store sizes of all valid perfect binary subtrees
        self.findPerfectSubtrees(root, sizes)

        # Sort sizes in descending order
        sizes.sort(reverse=True)

        # If there are fewer than k perfect binary subtrees, return -1
        if len(sizes) < k:
            return -1

        return sizes[k - 1]  # Return the k-th largest size

    def findPerfectSubtrees(self, node, sizes):
        # Base case: If node is None, return height 0 and size 0
        if not node:
            return (0, 0, True)  # (height, size, is_perfect)

        # Recursively find perfect subtrees in left and right subtrees
        left_height, left_size, left_perfect = self.findPerfectSubtrees(node.left, sizes)
        right_height, right_size, right_perfect = self.findPerfectSubtrees(node.right, sizes)

        # Check if both subtrees are perfect and have the same height
        if left_perfect and right_perfect and left_height == right_height:
            # This subtree is a valid perfect binary subtree
            size = left_size + right_size + 1
            height = left_height + 1
            sizes.append(size)  # Store the size
            return (height, size, True)

        # If not a perfect subtree, return an invalid state
        return (max(left_height, right_height) + 1, 0, False)
",1420532717
Tharunkumar S,tharunkumars,592,3588,python,"MOD = 10**9 + 7

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def countWinningSequences(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        n = len(s)
        
        # Map creatures to indices
        creature_map = {'F':0, 'W':1, 'E':2}
        creatures = ['F','W','E']
        
        # Define all possible move pairs and their score changes
        # (Alice_move, Bob_move) : score_change (Bob - Alice)
        score_map = {
            ('F','E'): -1,  # Alice 'F' beats Bob 'E'
            ('W','F'): -1,  # Alice 'W' beats Bob 'F'
            ('E','W'): -1,  # Alice 'E' beats Bob 'W'
            ('E','F'): +1,  # Bob 'F' beats Alice 'E'
            ('F','W'): +1,  # Bob 'W' beats Alice 'F'
            ('W','E'): +1,  # Bob 'E' beats Alice 'W'
        }
        
        # Initialize DP table
        # dp[i][last][p]: number of ways after i rounds,
        # last move is 'last' (0: F, 1: W, 2: E, 3: None),
        # p is the score difference shifted by +n to handle negatives
        dp = [[[0] * (2 * n + 1) for _ in range(4)] for _ in range(n + 1)]
        
        # Initial state: before any rounds, no previous move, score difference 0 (shifted to n)
        dp[0][3][n] = 1
        
        for i in range(n):
            alice_move = s[i]
            for last in range(4):  # 0,1,2,3
                for p in range(2 * n + 1):
                    if dp[i][last][p] == 0:
                        continue
                    for bob_move in range(3):
                        if last !=3 and bob_move == last:
                            continue  # Bob cannot repeat the same move
                        a = alice_move
                        b = creatures[bob_move]
                        if (a, b) in score_map:
                            p_change = score_map[(a, b)]
                        else:
                            p_change = 0  # Same creature, no change
                        new_p = p + p_change
                        if 0 <= new_p <= 2 * n:
                            dp[i+1][bob_move][new_p] = (dp[i+1][bob_move][new_p] + dp[i][last][p]) % MOD
        
        # Sum all sequences where p > n (Bob's score > Alice's score)
        result = 0
        for last in range(3):  # last move can be 0,1,2
            for p in range(n + 1, 2 * n + 1):
                result = (result + dp[n][last][p]) % MOD
        
        return result
",1420537156
Tharunkumar S,tharunkumars,592,3610,java,"import java.util.*;

class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] result = new int[n - k + 1];  // Result array to store the x-sum for each subarray

        // Use a HashMap to track the frequency of elements in the current window
        Map<Integer, Integer> freqMap = new HashMap<>();

        // Initialize the frequency map with the first k elements
        for (int i = 0; i < k; i++) {
            freqMap.put(nums[i], freqMap.getOrDefault(nums[i], 0) + 1);
        }

        // Calculate the x-sum for the first window
        result[0] = calculateXSum(freqMap, x);

        // Sliding window: move the window across the array
        for (int i = 1; i <= n - k; i++) {
            // Remove the element going out of the window
            int outElement = nums[i - 1];
            freqMap.put(outElement, freqMap.get(outElement) - 1);
            if (freqMap.get(outElement) == 0) {
                freqMap.remove(outElement);
            }

            // Add the new element coming into the window
            int inElement = nums[i + k - 1];
            freqMap.put(inElement, freqMap.getOrDefault(inElement, 0) + 1);

            // Calculate the x-sum for the current window
            result[i] = calculateXSum(freqMap, x);
        }

        return result;
    }

    // Helper function to calculate the x-sum from the frequency map
    private int calculateXSum(Map<Integer, Integer> freqMap, int x) {
        // Create a list of the entries (number, frequency) and sort it
        List<Map.Entry<Integer, Integer>> entryList = new ArrayList<>(freqMap.entrySet());

        // Sort primarily by frequency (descending), then by value (descending)
        entryList.sort((a, b) -> {
            if (b.getValue().equals(a.getValue())) {
                return b.getKey() - a.getKey();  // Sort by value if frequencies are equal
            }
            return b.getValue() - a.getValue();  // Sort by frequency otherwise
        });

        // Sum up the top x most frequent elements
        int sum = 0, count = 0;
        for (Map.Entry<Integer, Integer> entry : entryList) {
            if (count >= x) break;
            sum += entry.getKey() * entry.getValue();
            count++;
        }

        return sum;
    }
}
",1420519589
Enkhtur,enkhtur,594,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizesOfPerfectSubtree = []
        
        def traverse(node):
            if node == None:
                return 0
            sizeLeft = traverse(node.left)
            sizeRight = traverse(node.right)
            if sizeLeft == None or sizeRight == None:
                return None
            if sizeLeft != sizeRight:
                return None
            
            sizesOfPerfectSubtree.append(sizeLeft + sizeRight + 1)
            return sizeLeft + sizeRight + 1

        traverse(root)
        sizesOfPerfectSubtree.sort(reverse=True)
        if len(sizesOfPerfectSubtree) < k:
            return -1
        return sizesOfPerfectSubtree[k-1]
        
            ",1420533564
Enkhtur,enkhtur,594,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def scoreChange(aliceMove, bobMove):
            if aliceMove == bobMove:
                return 0
            dt = {
                ('W', 'F') : -1,
                ('W', 'E') : 1,
                ('E', 'W') : -1,
                ('E', 'F') : 1,
                ('F', 'E') : -1,
                ('F', 'W') : 1 }
            
            return dt[(aliceMove, bobMove)]           
        
        @cache
        def dp(i, balance, prev):
            if i == len(s):
                return 1 if balance > 0 else 0
            aliceMove = s[i]
            res = 0
            for bobMove in ['F', 'W', 'E']:
                if bobMove == prev:
                    continue
                change = scoreChange(aliceMove, bobMove)
                res += dp(i + 1, balance + change, bobMove)
                res %= 1_000_000_007
            return res
            
        
        return dp(0, 0, 'X')",1420556102
Enkhtur,enkhtur,594,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        def getSubarrayForAns(i):
            return nums[i:i+k]
        
        def getXsum(arr):
            cdt = Counter(arr)
            cArr = [(val, key) for key, val in cdt.items()]
            cArr.sort(reverse=True)
            return sum([entry[0]*entry[1] for entry in cArr[:x]])
        ans = []
        for i in range(len(nums) - k + 1):
            ans.append(getXsum(getSubarrayForAns(i)))
        return ans",1420524030
NgoQuangTrung90,NgoQuangTrung90,595,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
struct Node{
    int sz = 0;
    bool perfect = false;
};
void printArr(const vector<int> & a){
    for(int i = 0 ; i < a.size() ; i ++){
        cout<<a[i]<<"" "";
    }
    cout<<endl;
}
class Solution {
public:
    Node PostOrder(TreeNode * root, vector<int> & a){
        Node node;
        node.sz = 0;
        node.perfect = true;
        if(root){
            Node nodeL = PostOrder(root->left, a);
            Node nodeR = PostOrder(root->right, a);
            if(nodeL.perfect && nodeR.perfect && nodeL.sz == nodeR.sz){
                node.sz = nodeL.sz + nodeR.sz + 1;
                node.perfect = true;
                a.push_back(node.sz);
            }else{
                node.perfect = false;
            }
        }
        return node;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> a;
        Node node = PostOrder(root, a);
        sort(a.begin(), a.end());
        reverse(a.begin(), a.end());
        //printArr(a);
        if(a.size() < k) return -1;
        return a[k - 1];
    }
};",1420544579
NgoQuangTrung90,NgoQuangTrung90,595,3588,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
    int point(const char & a, const char & b){
        if(a == 'F'){
            if(b == 'F') return 0;
            else if(b == 'E') return 1;
            else if(b == 'W') return -1;
        }else if(a == 'W'){
            if(b == 'F') return 1;
            else if(b == 'E') return -1;
            else if(b == 'W') return 0;            
        }else if(a == 'E'){
            if(b == 'F') return -1;
            else if(b == 'E') return 0;
            else if(b == 'W') return 1;             
        }
        return -1;
    }
    int countWinningSequences(string s) {
        string t = ""FWE"";
        vector<vector<unordered_map<int, int>>> dp(s.size(), vector<unordered_map<int, int>>(3));
        int i, j, k, l, p;
        char c;
        for(i = 0 ; i < 3 ; i ++){
            c = t[i];
            p = point(c, s[0]);
            dp[0][i][p] = 1;
        }
        for(i = 1 ; i < s.size() ; i ++){
            for(j = 0 ; j < 3 ; j ++){
                c = t[j];
                p = point(c, s[i]);
                for(k = 0 ; k < 3 ; k ++){
                    if(k != j){
                        for(auto ele = dp[i-1][k].begin(); ele != dp[i-1][k].end(); ele ++){
                            dp[i][j][p + ele->first] += ele->second;
                            dp[i][j][p + ele->first] %= mod;
                        }
                    }
                }
            }
        }
        /*for(i = 0 ; i < dp.size() ; i ++){
            for(j = 0 ; j < 3 ; j ++){
                cout<<""i: ""<<i<<"" j: ""<<j<<"" s[i]: ""<<s[i]<<"" t[j]: ""<<t[j]<<endl;
                for(auto ele = dp[i][j].begin(); ele != dp[i][j].end(); ele ++){
                    cout<<ele->first<<"":""<<ele->second<<"" "";
                }
                cout<<endl;
            }
        }*/
        int ans = 0;
        for(i = 0 ; i < 3 ; i ++){
            for(auto ele = dp.back()[i].begin(); ele != dp.back()[i].end(); ele ++){
                if(ele->first > 0){
                    ans += ele->second;
                    ans %= mod;                    
                }
            }
        }
        return ans;
    }
};",1420568276
NgoQuangTrung90,NgoQuangTrung90,595,3610,cpp,"bool myfunc(const pair<int, int> & a, const pair<int, int> & b){
    if(a.second == b.second) return a.first > b.first;
    return a.second > b.second;
}
void printArr(const vector<int> & a){
    for(int i = 0 ; i < a.size() ; i ++) cout<<a[i]<<"" "";
    cout<<endl;
}
void printArr(const vector<pair<int, int>> & a){
    for(int i = 0 ; i < a.size() ; i ++) cout<<a[i].first<<"",""<<a[i].second<<"" "";
    cout<<endl;
}
class Solution {
public:
    int Helper(const vector<int> & a, const int & x){
        unordered_map<int, int> m;
        int i;
        for(i = 0 ; i < a.size() ; i ++){
            m[a[i]] ++;
        }
        vector<pair<int, int>> b;
        for(auto ele = m.begin(); ele != m.end(); ele ++){
            b.push_back({ele->first, ele->second});
        }
        sort(b.begin(), b.end(), myfunc);
        //cout<<""b: ""; printArr(b);
        int ans = 0;
        for(i = 0 ; i < b.size() ; i ++){
            //cout<<""i: ""<<i<<endl;
            if(i < x) ans += (b[i].first * b[i].second);
            else break;
        }
        //cout<<""ok""<<endl;
        return ans;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        int i, j;
        for(i = 0 ; i + k - 1 < nums.size() ; i ++){
            //cout<<""i: ""<<i<<endl;
            vector<int> a;
            for(j = 0 ; j < k ; j ++){
                a.push_back(nums[i + j]);
            }
            //printArr(a);
            ans.push_back(Helper(a, x));
        }
        return ans;
    }
};",1420530272
Jaysukh Makvana,jaysukh_409,596,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    priority_queue<int> pq;
    int f(TreeNode* root)
    {
        if (!root) return -1;
        if (root->left == NULL && root->right == NULL) 
        {
            pq.push(1);
            return 1;
        }
        int l = f(root->left);
        int r = f(root->right);
        if (l != -1 && r != -1 && l == r) 
        {
            pq.push(l + r + 1);
            return (l + r + 1);
        }
        return -1;
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) 
    {
        int ans = f(root);
        k--;
        while (k--)
        {
            if (pq.empty()) return -1;
            pq.pop();
        }
        if (pq.empty()) return -1;
        return pq.top();
    }
};",1420528158
Jaysukh Makvana,jaysukh_409,596,3588,cpp,"class Solution {
public:
    int M = 1000000007;
    long long dp[1005][3][2005];
    long long f(int i, int prev, int score, string &s, int n)
    {
        if (i == n) return (score > 1000);
        if (dp[i][prev][score] != -1) return dp[i][prev][score];
        if (prev == 0)
        {
            long long ans = 0;
            if (s[i] == 'F')
            {
                ans += f(i + 1, 1, score + 1, s, n);
                ans %= M;
                ans += f(i + 1, 2, score - 1, s, n);
                ans %= M;
            }
            else if (s[i] == 'W')
            {
                ans += f(i + 1, 1, score, s, n);
                ans %= M;
                ans += f(i + 1, 2, score + 1, s, n);
                ans %= M;
            }
            else
            {
                ans += f(i + 1, 1, score - 1, s, n);
                ans %= M;
                ans += f(i + 1, 2, score, s, n);
                ans %= M;
            }
            return dp[i][prev][score] = ans;
        }
        else if (prev == 1)
        {
            long long ans = 0;
            if (s[i] == 'F')
            {
                ans += f(i + 1, 0, score, s, n);
                ans %= M;
                ans += f(i + 1, 2, score - 1, s, n);
                ans %= M;
            }
            else if (s[i] == 'W')
            {
                ans += f(i + 1, 0, score - 1, s, n);
                ans %= M;
                ans += f(i + 1, 2, score + 1, s, n);
                ans %= M;
            }
            else
            {
                ans += f(i + 1, 0, score + 1, s, n);
                ans %= M;
                ans += f(i + 1, 2, score, s, n);
                ans %= M;
            }
            return dp[i][prev][score] = ans;
        }
        long long ans = 0;
        if (s[i] == 'F')
        {
            ans += f(i + 1, 1, score + 1, s, n);
            ans %= M;
            ans += f(i + 1, 0, score, s, n);
            ans %= M;
        }
        else if (s[i] == 'W')
        {
            ans += f(i + 1, 1, score, s, n);
            ans %= M;
            ans += f(i + 1, 0, score - 1, s, n);
            ans %= M;
        }
        else
        {
            ans += f(i + 1, 1, score - 1, s, n);
            ans %= M;
            ans += f(i + 1, 0, score + 1, s, n);
            ans %= M;
        }
        return dp[i][prev][score] = ans;
    }
    int countWinningSequences(string s)
    {
        memset(dp, -1, sizeof(dp));
        int n = s.size();
        if (s[0] == 'F')
        {
            long long ans = 0;
            ans += f(1, 0, 1000, s, n);
            ans %= M;
            ans += f(1, 1, 1001, s, n);
            ans %= M;
            ans += f(1, 2, 999, s, n);
            ans %= M;
            return (int)ans;
        }
        else if (s[0] == 'W')
        {
            long long ans = 0;
            ans += f(1, 0, 999, s, n);
            ans %= M;
            ans += f(1, 1, 1000, s, n);
            ans %= M;
            ans += f(1, 2, 1001, s, n);
            ans %= M;
            return (int)ans;
        }
        long long ans = 0;
        ans += f(1, 0, 1001, s, n);
        ans %= M;
        ans += f(1, 1, 999, s, n);
        ans %= M;
        ans += f(1, 2, 1000, s, n);
        ans %= M;
        return (int)ans;
    }
};",1420562453
Jaysukh Makvana,jaysukh_409,596,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) 
    {
        int n = nums.size();
        vector<int> res;
        for (int i = 0; i <= n - k; i++)
        {
            map<int, int> mp;
            for (int j = i; j < i + k; j++)
            {
                mp[nums[j]]++;
            }
            priority_queue<pair<int, int>> pq;
            for (auto i : mp)
            {
                pq.push({i.second, i.first});
            }
            int ans = 0;
            for (int j = 0; j < x && !pq.empty(); j++)
            {
                ans += pq.top().first * pq.top().second;
                pq.pop();
            }
            res.push_back(ans);
        }    
        return res;
    }
};",1420520830
Shaurya Malhan,Shaurya_Malhan,597,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public static ArrayList<Integer> arr;
    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        arr  = new ArrayList<>();
        solve(root);
        k--;
        Collections.sort(arr);
        Collections.reverse(arr);
        if(k >= arr.size()) return -1;
        return arr.get(k);
    }
    public static void solve(TreeNode root) {
        if(root == null) return;
        int l = count(root);
        int r = maxDepth(root);
        if(r < 30) {
            int u = (1 << r);
            u--;
            if(u == l) arr.add(l);
        }
        solve(root.left);
        solve(root.right);
    }
    public static int count(TreeNode root) {
        if(root == null) return 0;

        int nodes = 0;
        nodes += 1 + count(root.left);
        nodes += count(root.right);
        
        return nodes;
    }   
    public static int maxDepth(TreeNode root) {
        if(root == null) return 0;

        int lh = maxDepth(root.left);
        int rh = maxDepth(root.right);

        return 1 + Math.max(lh, rh);
    }   
}",1420545610
Shaurya Malhan,Shaurya_Malhan,597,3588,java,"class Solution {
    public static long modulo = (long) 1e9 + 7;
    public static Long[][][] dp;
    public int countWinningSequences(String s) {
        int n = s.length();
        dp = new Long[n][2 * n + 4][4];
        return (int) solve(0, s, n, 3);
    }
    public static long solve(int i, String s, int cum, int last) {
        if(i >= s.length()) {
            if(cum > s.length()) return 1;
            return 0;
        }
        if(dp[i][cum][last] != null) {
            return dp[i][cum][last];
        }
        long ans = 0;
        if(s.charAt(i) == 'F') {
            if(last != 0) ans = (ans + solve(i + 1, s, cum, 0)) % modulo;
            if(last != 1) ans = (ans + solve(i + 1, s, cum + 1, 1)) % modulo;
            if(last != 2) ans = (ans + solve(i + 1, s, cum - 1, 2)) % modulo;
        } else if(s.charAt(i) == 'W') {
            if(last != 0) ans = (ans + solve(i + 1, s, cum - 1, 0)) % modulo;
            if(last != 1) ans = (ans + solve(i + 1, s, cum, 1)) % modulo;
            if(last != 2) ans = (ans + solve(i + 1, s, cum + 1, 2)) % modulo;
        } else {
            if(last != 0) ans = (ans + solve(i + 1, s, cum + 1, 0)) % modulo;
            if(last != 1) ans = (ans + solve(i + 1, s, cum - 1, 1)) % modulo;
            if(last != 2) ans = (ans + solve(i + 1, s, cum, 2)) % modulo;
        }
        return dp[i][cum][last] = ans;
    }
}",1420568395
Shaurya Malhan,Shaurya_Malhan,597,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        for(int i = 0; i < n - k + 1; i++) {
            int sum = 0;
            int[] freq = new int[51];
            ArrayList<int[]> arr = new ArrayList<>();
            for(int j = i; j < i + k; j++) {
                int l = nums[j];
                freq[l]++;
            }
            for(int j = 0; j < 51; j++) {
                if(freq[j] != 0) {
                    arr.add(new int[]{freq[j], j});
                }
            }
            Collections.sort(arr, (a, b) -> {
                if(a[0] == b[0]) return Integer.compare(b[1], a[1]);
                return Integer.compare(b[0], a[0]);
            });
            for(int j = 0; j < Math.min(arr.size(), x); j++) {
                int l = arr.get(j)[0];
                int r = arr.get(j)[1];
                sum += l * r;
            }
            ans[i] = sum;
        }
        return ans;
    }
}",1420525150
Mayank Sharma,debugger18,598,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> tmp;
    vector<int> help(TreeNode * root){
        if(!root) return {0 , 0};
        auto left = help(root->left);
        auto right = help(root->right);
        if(left[0] == -1 || right[0] == -1) return {-1 , -1}; 
        if(left[0] == right[0]){
            tmp.push_back(1 + left[1] + right[1]);
            return {1 + left[0] , 1 + left[1] + right[1]};
        }
        return {-1 , -1};
    }
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        help(root);
        if(tmp.size() < k) return -1;
        sort(tmp.rbegin() , tmp.rend());
        int ans = 0;
        for(int i = 0  ;i < k ; i++){
            ans = tmp[i];
        }
        return ans;
    }
};",1420534834
Mayank Sharma,debugger18,598,3588,cpp,"class Solution {
public:
    int gett(char ch){
        if(ch == 'F'){
            return 0;
        }
        else if(ch =='E'){
            return 1;
        }
        else if(ch == 'W') return 2;
        else return 3;
    }
    int M = 1e9+7;
    int help(string & s , int cur , char ch , int sum , vector<vector<vector<int>>> &dp){
        int n = s.size();
        if(cur >= s.size()){
            if(sum > 0) return 1;
            return 0;
        }
        if(dp[cur][n + sum][gett(ch)] != -1) return dp[cur][n + sum][gett(ch)];
        int moves = 0;
        if('E' != ch){
            if(s[cur] == 'E'){
                moves  = (moves%M + help(s , cur+1 , 'E' , sum , dp)%M)%M;
            }
            else if(s[cur] == 'F'){
                moves = (moves%M + help(s , cur+1 , 'E' , sum-1 , dp)%M)%M;
            }
            else{
                moves = (moves%M + help(s , cur+1 , 'E' , sum+1 , dp)%M)%M;
            }
        }
        if('F' != ch){
            if(s[cur] == 'E'){
                moves = (moves%M + help(s , cur+1 , 'F' , sum+1 , dp)%M)%M;
            }
            else if(s[cur] == 'F'){
                moves = (moves%M + help(s , cur+1 , 'F' , sum , dp)%M)%M;
            }
            else{
                moves = (moves%M + help(s , cur+1 , 'F' , sum-1 , dp)%M)%M;
            }
        }
        if('W' != ch){
            if(s[cur] == 'E'){
                moves = (moves%M + help(s , cur+1 , 'W' , sum-1 , dp)%M)%M;
            }
            else if(s[cur] == 'F'){
                moves = (moves%M + help(s , cur+1 , 'W' , sum+1 , dp)%M)%M;
            }
            else{
                moves = (moves%M + help(s , cur+1 , 'W' , sum , dp)%M)%M;
            }
        }
        return dp[cur][n + sum][gett(ch)] = moves%M;
    }
    int countWinningSequences(string s) {
        vector<vector<vector<int>>> dp(s.size() , vector<vector<int>>(2*s.size()+10 , vector<int>(4 , -1)));
        return help(s , 0 , 0 , 0 , dp);
    }
};",1420562497
Mayank Sharma,debugger18,598,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans;
        for(int i = 0 ; i <= nums.size() - k ; i++){
            vector<int> hash(55 , 0);
            for(int j = i ; j < i+k ; j++){
                hash[nums[j]]++;
            }
            vector<vector<int>> tmp;
            for(int j = 0 ; j <= 50 ; j++){
                if(hash[j]){
                    tmp.push_back({j , hash[j]});
                }
            }
            sort(tmp.begin() , tmp.end() , [&](vector<int> & a , vector<int> & b){
                if(a[1] == b[1]) return a[0] > b[0];
                return a[1] > b[1];
            });
            int a = 0;
            for(int j = 0 ; j < x && j < tmp.size() ; j++){
                a += tmp[j][0] * tmp[j][1];
            }
            ans.push_back(a);
        }
        return ans;
    }
};",1420524583
Syed Ali Aatif,mafailure,607,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        if(root == NULL)return -1; 
        const int inf = 1e9;  
        vector<int> val; 
        vector<vector<int>> g; 
        int tot = 0; 
        function<int(TreeNode *)> buildTree = [&](TreeNode * cur) {
            if(cur == NULL) return -1; 
            int id = tot++; 
            val.push_back(cur->val); 
            g.push_back({}); 
            if(g.size()<=id) {
                assert(0); 
            }
            if(cur->left) {
                int _id = buildTree(cur->left); 
                g[id].push_back(_id); 
            }
            if (cur->right) {
                int _id = buildTree(cur->right); 
                g[id].push_back(_id); 
            }
            return id; 
        };
        buildTree(root); 
        int n = val.size(); 
        vector<int> mn(n,inf),mx(n,-inf); 
        vector<int> sum(n),dep(n); 
        vector<int> isBin(n); 
        function<void(int,int)> dfs=[&](int u,int depth) {
            dep[u] = depth; 
            if(g[u].empty()){
                mn[u] = mx[u] = depth; 
            }
            isBin[u] = g[u].empty() || (g[u].size() == 2); 
            sum[u]+=1; 
            for(auto v:g[u]){
                dfs(v,depth+1); 
                sum[u]+=sum[v]; 
                mn[u] = min(mn[u], mn[v]); 
                mx[u] = max(mx[u], mx[v]); 
                isBin[u]&=isBin[v]; 
            }
        };
        dfs(0,0); 
        vector<int> ans; 
        for(int i=0;i<n;i++){
            int u = i; 
            if(mn[u] == mx[u] && isBin[u]){
                ans.push_back(sum[u]);
            }
        }
        sort(ans.rbegin(), ans.rend());
        if(ans.size()<k){
            return -1; 
        }
        return ans[k-1]; 
    }
};",1420547241
Syed Ali Aatif,mafailure,607,3588,cpp,"const int N = 1e3+1; 
int dp[2][2*N][3]; 
const int mod = 1e9+7; 
class Solution {
public:
    int countWinningSequences(string s) {
        #define int long long 
        memset(dp,0,sizeof(dp)); 
        int t = 1; 
        map<char,int> mapp; 
        mapp['F'] = 0; 
        mapp['W'] = 1; 
        mapp['E'] = 2;
        vector<int> a; 
        for(auto it:s)a.push_back(mapp[it]); 
        dp[t][N+1][(a[0]+1)%3] = 1; 
        dp[t][N-1][(a[0]+2)%3] = 1; 
        dp[t][N][a[0]] = 1; 
        for(int i=1;i<s.size();i++){
            int id = 1-t; 
            for(int j=0;j<2*N;j++){
                for(int k=0;k<3;k++) dp[id][j][k] = 0; 
            }
            for(int j=0;j<2*N;j++){
                for(int k=0;k<3;k++){
                    if(dp[t][j][k] == 0)continue; 
                    if(k!=((a[i]+1)%3))
                    dp[id][j+1][(a[i]+1)%3] = add(dp[id][j+1][(a[i]+1)%3], dp[t][j][k]); 
                    if(k!=((a[i]+2)%3))
                    dp[id][j-1][(a[i]+2)%3] = add(dp[id][j-1][(a[i]+2)%3], dp[t][j][k]); 
                    if(k!=(a[i]))
                    dp[id][j][a[i]] = add(dp[id][j][a[i]], dp[t][j][k]); 
                }
            }
            t = id; 
        }

        int ans = 0; 
        for(int i=0;i<2*N;i++){
            for(int j=0;j<3;j++){
                if((i-N)>0)
                ans=add(ans, dp[t][i][j]);
            }
        }
        return ans;
    }

    int add (int a,int b) {
        return (a+b)%mod; 
    }
    
    int sub(int a,int b) {
        return (mod+ a-b)%mod; 
    }

    int mul(int a,int b){
        return a*b%mod; 
    }

    #undef int 
};",1420568869
Syed Ali Aatif,mafailure,607,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> ans; 
        for(int i=0;i+k<=nums.size();i++){
            ans.push_back(getAns(vector<int>(nums.begin()+i, nums.begin()+i+k), x)); 
        }
        return ans; 
    }

    int getAns(vector<int> nums,int x) {
        map<int,int> mapp;
        for(auto it:nums)mapp[it]++; 
        vector<pair<int,int>> a; 
        for(auto it:mapp)a.push_back(make_pair(it.second, it.first)); 
        sort(a.rbegin(), a.rend()); 
        a.resize(min((int)a.size(),x)); 
        int ans = 0;
        for(auto it:a) {
            ans+=it.first*it.second; 
        }
        return ans; 
    }
};",1420521670
Md Abedin,MdAbedin,608,3509,python3,"class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []

        def solve(node):
            if not node: return True,0

            w1,s1 = solve(node.left)
            w2,s2 = solve(node.right)

            w = w1 and w2 and s1 == s2
            s = 1+s1+s2

            if w: sizes.append(s)

            return w,s

        solve(root)
        sizes.sort(reverse=True)
            
        return -1 if k-1 >= len(sizes) else sizes[k-1]",1420530646
Md Abedin,MdAbedin,608,3588,python3,"mod = 10**9+7
beats = dict(zip(""FWE"",""EFW""))

class Solution:
    def countWinningSequences(self, s: str) -> int:
        @cache
        def solve(i,c):
            ans = Counter()

            if i == len(s)-1:
                ans[(beats[c]==s[i])-(beats[s[i]]==c)] += 1
                return ans

            for c2 in ""FWE"":
                if c2 == c: continue

                ans2 = solve(i+1,c2)

                for p,count in ans2.items():
                    p2 = p+(beats[c]==s[i])-(beats[s[i]]==c)
                    ans[p2] += count
                    ans[p2] %= mod

            return ans

        return sum(sum(count for p,count in solve(0,c).items() if p > 0)%mod for c in ""FWE"")%mod",1420562929
Md Abedin,MdAbedin,608,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []

        for i in range(len(nums)-k+1):
            counts = Counter(nums[i:i+k])
            use = sorted(counts.items(),key = lambda p: [-p[1], -p[0]])
            ans.append(sum(a*b for a,b in use[:x]))

        return ans",1420519046
Sanjeeb Kumar Rai,sanjeeb42,609,3509,cpp,"class Solution {
public:
    pair<int, int> solve(TreeNode* node,vector<int>& sizes) {
        if (!node) {
            return {0, 0};
        }

        pair<int,int> left = solve(node->left, sizes);
        pair<int,int> right = solve(node->right, sizes);

        if (left.first == right.first && left.first != -1) {
            int res = left.second + right.second + 1;
            sizes.push_back(res);
            return {left.first + 1, res};
        }
        
        return {-1, 0};
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> sizes;
        solve(root, sizes);

        sort(sizes.rbegin(), sizes.rend());

        if (k <= sizes.size()) {
            return sizes[k - 1];
        }
        return -1;
    }
};
",1420532768
Sanjeeb Kumar Rai,sanjeeb42,609,3588,cpp,"class Solution {
public:
    const int MOD = 1000000007;
    vector<vector<vector<int>>> dp;

    int solve(string& s, int idx, char prev, int score) {

        int n=s.length();
        if (idx ==n) {
            return (score > 0);
        }

        int prev_move = (prev == 'X') ? 0 : (prev == 'F') ? 1 : (prev == 'W') ? 2 : 3;

        if (dp[idx][prev_move][score + n] != -1) {
            return dp[idx][prev_move][score + n];
        }

        int result = 0;
        char a_turn = s[idx];
        vector<int>allowed={'F','W','E'};
        for (auto it : allowed) {
            if (it == prev) continue;
            int res = 0;
            if ((it == 'F' && a_turn == 'W') || 
                       (it == 'W' && a_turn == 'E') ||
                       (it == 'E' && a_turn == 'F')) {
                res--;
            }
            else if ((a_turn == 'F' && it == 'W') || 
                (a_turn == 'W' && it == 'E') ||
                (a_turn == 'E' && it == 'F')) {
                res++;
            }
            result = (result + solve(s, idx + 1, it, score+res)) % MOD;
        }

        return dp[idx][prev_move][score + n] = result;
    }

    int countWinningSequences(string s) {
        dp = vector<vector<vector<int>>>(s.size(), vector<vector<int>>(4, vector<int>(2 * s.size() + 1, -1)));
        return solve(s, 0, 'X', 0);
    }
};",1420563019
Sanjeeb Kumar Rai,sanjeeb42,609,3610,cpp,"class Solution {
public:
    static bool cmp(pair<int,int>&a,pair<int,int>&b){
        if(a.first==b.first)return a.second>b.second;
        return a.first>b.first;
    }
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        vector<int>ans(n-k+1);
        
        for(int i=0;i<n-k+1;i++){
            unordered_map<int,int>mp;
            for(int j=0;j<k;j++){
                mp[nums[i+j]]++;
            }
            vector<pair<int,int>>v;
            for(auto it:mp)v.push_back({it.second,it.first});
            sort(v.begin(),v.end(),cmp);
            int res=0,s=v.size();
            for(int j=0;j<min(x,s);j++)res+=(v[j].second)*(v[j].first);
            ans[i]=res;
        }
        return ans;
    }
};",1420526638
Burger Monstah,WRWRW,613,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        self.res = []
        def go(node):
            if node is None:
                return None 
            # print(node.val)
            left = go(node.left)
            right = go(node.right)
            if node.left is None and node.right is None:
                self.res.append(1)
                return 1
            elif left == right and left is not None: 
                sz = left * 2 + 1
                self.res.append(sz)
                # print(node.val, sz)
                return sz
            # print(node.val, None)
            return None
        go(root)
        data = sorted(self.res, reverse=True)  
        print(data)
        if k > len(data):
            return -1
        return data[k - 1]
                

",1420544790
Burger Monstah,WRWRW,613,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        mod = 10 ** 9 + 7
        fwe = ['F', 'W', 'E']
        data = {None: {0: 1}}
        for i, alice in enumerate(s):
            ndata = {bob: Counter() for bob in fwe}
            for prev, ct in data.items():
                for bob in fwe:
                    if bob != prev:
                        if bob == alice:
                            diff = 0
                        elif bob == 'F' and alice == 'E' or bob == 'W' and alice == 'F' or bob == 'E' and alice == 'W':
                            diff = 1
                        else:
                            diff = -1
                        for k, v in ct.items():
                            ndata[bob][k + diff] = (ndata[bob][k + diff]+ v) % mod
            data = ndata
        res = 0
        for bob in fwe:
            for k, v in data[bob].items():
                if k > 0:
                    res = (res + v) % mod
        return res
",1420563184
Burger Monstah,WRWRW,613,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        res = []
        for i in range(n - k + 1):
            sub = nums[i: i + k]
            data = sorted(Counter(sub).items(), key=lambda x: (-x[1], -x[0])) 
            if len(data) < x:
                res.append(sum(sub))
            else:
                res.append(sum(data[ii][0] * data[ii][1] for ii in range(x)))
        return res",1420523814
PzC9BHHUUB,PzC9BHHUUB,614,3509,java,"/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private List<Integer> sizes;

    public int kthLargestPerfectSubtree(TreeNode root, int k) {
        sizes = new ArrayList<>();
        findPerfectSubtrees(root);

        if (sizes.size() < k) {
            return -1;
        }

        Collections.sort(sizes, Collections.reverseOrder());
        return sizes.get(k - 1);
    }

    private int[] findPerfectSubtrees(TreeNode node) {
        if (node == null) {
            return new int[] {0, 1}; 
        }

        int[] left = findPerfectSubtrees(node.left);
        int[] right = findPerfectSubtrees(node.right);

        if (left[1] == 1 && right[1] == 1 && left[0] == right[0]) {
            int size = left[0] + right[0] + 1;
            sizes.add(size);
            return new int[] {size, 1};
        }

        return new int[] {0, 0};
    }
}",1420521634
PzC9BHHUUB,PzC9BHHUUB,614,3588,java,"class Solution {
     private static final int MOD = 1_000_000_007;

    public static int countWinningSequences(String s) {
        int n = s.length();
        long[][] dp_prev = new long[4][2 * n + 1];
        dp_prev[0][n] = 1;

        for (int i = 0; i < n; i++) {
            char aliceMove = s.charAt(i);
            long[][] dp_curr = new long[4][2 * n + 1];

            for (int prev = 0; prev <= 3; prev++) {
                for (int d = 0; d <= 2 * n; d++) {
                    if (dp_prev[prev][d] == 0) continue;

                    for (int c = 1; c <= 3; c++) { 
                        if (c == prev) continue; 

                        // Determine points
                        int bobPoint = 0;
                        int alicePoint = 0;
                        char bobMove = creatureFromInt(c);

                        if (bobMove == 'F' && aliceMove == 'E') {
                            bobPoint = 1;
                        } else if (bobMove == 'W' && aliceMove == 'F') {
                            bobPoint = 1;
                        } else if (bobMove == 'E' && aliceMove == 'W') {
                            bobPoint = 1;
                        } else if (aliceMove == 'F' && bobMove == 'E') {
                            alicePoint = 1;
                        } else if (aliceMove == 'W' && bobMove == 'F') {
                            alicePoint = 1;
                        } else if (aliceMove == 'E' && bobMove == 'W') {
                            alicePoint = 1;
                        }
                        int currentDiff = d - n; 
                        int newDiff = currentDiff + (bobPoint - alicePoint);
                        
                        int newD = newDiff + n;
                        if (newD < 0 || newD > 2 * n) continue; 

                        dp_curr[c][newD] = (dp_curr[c][newD] + dp_prev[prev][d]) % MOD;
                    }
                }
            }
            dp_prev = dp_curr;
        }

        long result = 0;
        for (int prev = 1; prev <= 3; prev++) {
            for (int d = n + 1; d <= 2 * n; d++) {
                result = (result + dp_prev[prev][d]) % MOD;
            }
        }
        return (int) result;
    }

    private static char creatureFromInt(int c) {
        switch (c) {
            case 1: return 'F';
            case 2: return 'W';
            case 3: return 'E';
            default: return 'N'; 
        }
    }
}",1420563196
PzC9BHHUUB,PzC9BHHUUB,614,3610,java,"class Solution {
    public int[] findXSum(int[] nums, int k, int x) {
       int n = nums.length;
        int[] answer = new int[n - k + 1];
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int i = 0; i < k; i++) {
            frequencyMap.put(nums[i], frequencyMap.getOrDefault(nums[i], 0) + 1);
        }
        answer[0] = calculateXSum(frequencyMap, x);
        
        for (int i = 1; i <= n - k; i++) {
            int toRemove = nums[i - 1];
            frequencyMap.put(toRemove, frequencyMap.get(toRemove) - 1);
            if (frequencyMap.get(toRemove) == 0) {
                frequencyMap.remove(toRemove);
            }
            
            int toAdd = nums[i + k - 1];
            frequencyMap.put(toAdd, frequencyMap.getOrDefault(toAdd, 0) + 1);
            
            answer[i] = calculateXSum(frequencyMap, x);
        }
        
        return answer;
    }
    
    private int calculateXSum(Map<Integer, Integer> frequencyMap, int x) {
        PriorityQueue<Map.Entry<Integer, Integer>> maxHeap = new PriorityQueue<>(
            (a, b)->b.getValue()==a.getValue()?b.getKey()-a.getKey():b.getValue()-a.getValue()
        );
        
        maxHeap.addAll(frequencyMap.entrySet());
        
        int sum = 0;
        for (int i = 0; i < x && !maxHeap.isEmpty(); i++) {
            Map.Entry<Integer, Integer> entry = maxHeap.poll();
            sum += entry.getKey() * entry.getValue();
        }
        
        return sum;
    }
}",1420520047
yuanlu0210,yuanlu0210,615,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        res = []
        def dfs(root): # returns (isPerfectTree, numOfNodes)
            nonlocal res
            if not root:
                return (True, 0)
            is_left_perfect, left_nodes = dfs(root.left)
            is_right_perfect, right_nodes = dfs(root.right)
            is_perfect = is_left_perfect and is_right_perfect and (left_nodes == right_nodes)
            nodes = left_nodes + right_nodes + 1
            if is_perfect:
                res.append(nodes)
            return is_perfect, nodes
        
        dfs(root)
        res.sort(reverse=True)
        if len(res) < k:
            return -1
        return res[k - 1]
    
    ",1420535152
yuanlu0210,yuanlu0210,615,3588,python3,"MOD = 1000000007
class Solution:
    def countWinningSequences(self, s: str) -> int:
        dp0F, dp0W, dp0E = Counter({0:1}), Counter({0:1}), Counter({0:1})
        for c in s:
            dp1F, dp1W, dp1E = Counter(), Counter(), Counter()
            if c == ""F"":
                for cur in dp0F:
                    dp1W[cur + 1] += dp0F[cur]
                    dp1E[cur - 1] += dp0F[cur]
                for cur in dp0E:
                    dp1W[cur + 1] += dp0E[cur]
                    dp1F[cur] += dp0E[cur]
                for cur in dp0W:
                    dp1F[cur] += dp0W[cur]
                    dp1E[cur - 1] += dp0W[cur]
            elif c == ""E"":
                for cur in dp0F:
                    dp1W[cur - 1] += dp0F[cur]
                    dp1E[cur] += dp0F[cur]
                for cur in dp0E:
                    dp1W[cur - 1] += dp0E[cur]
                    dp1F[cur + 1] += dp0E[cur]
                for cur in dp0W:
                    dp1F[cur + 1] += dp0W[cur]
                    dp1E[cur] += dp0W[cur]
            elif c == ""W"":
                for cur in dp0F:
                    dp1W[cur] += dp0F[cur]
                    dp1E[cur + 1] += dp0F[cur]
                for cur in dp0E:
                    dp1W[cur] += dp0E[cur]
                    dp1F[cur - 1] += dp0E[cur]
                for cur in dp0W:
                    dp1F[cur - 1] += dp0W[cur]
                    dp1E[cur + 1] += dp0W[cur]
            dp0F, dp0W, dp0E, dp1F, dp1W, dp1E = dp1F, dp1W, dp1E, dp0F, dp0W, dp0E
            # print(c, dp0F, dp0W, dp0E)
        res = 0
        for x in dp0F:
            if x > 0:
                res += dp0F[x]
        for x in dp0W:
            if x > 0:
                res += dp0W[x]
        for x in dp0E:
            if x > 0:
                res += dp0E[x]
        return (res //2) % MOD
                ",1420563530
yuanlu0210,yuanlu0210,615,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n = len(nums)
        answer = [0] * (n - k + 1)
        for i in range(n - k + 1):
            counter = Counter(nums[i:i+k])
            cnt_value_tuple = [(counter[x], x) for x in counter]
            cnt_value_tuple.sort(reverse=True)
            answer[i] = sum(cnt_value_tuple[j][0] * cnt_value_tuple[j][1] for j in range(min(x, len(cnt_value_tuple))))
        return answer",1420524775
JCrossover_14,user3751Xt,617,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    
    def dfs(self,root, sizes):
        if root is None:
            return -1
        if root.left is None and root.right is None:
            sizes.append(1)
            return 1
        
        leftsize = self.dfs(root.left,sizes)
        rightsize = self.dfs(root.right,sizes)

        if leftsize==-1 or rightsize==-1 or leftsize!=rightsize:
            return -1
        
        else:
            sizes.append(leftsize+rightsize+1)
            return leftsize+rightsize+1
        
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        sizes = []
        x = self.dfs(root,sizes)
        sizes = sorted(sizes,reverse = True)
        if len(sizes)<k:
            return -1
        return sizes[k-1]

        
        ",1420524606
JCrossover_14,user3751Xt,617,3588,cpp,"#include <vector>
#include <iostream>
using namespace std;

class Solution {
public:
    int countWinningSequences(string s) {
        int n = s.length();
        const int MOD = 1000000007;
        const int OFFSET = 1000;
        
        // Precompute the ""f"" function result in a lookup table
        // f_table[a][b] will store the result of f(a, b)
        vector<vector<int>> f_table(3, vector<int>(3));
        f_table[0][2] = 1;  // F beats E
        f_table[1][0] = 1;  // W beats F
        f_table[2][1] = 1;  // E beats W
        f_table[2][0] = -1; // E loses to F
        f_table[0][1] = -1; // F loses to W
        f_table[1][2] = -1; // W loses to E
        
        // Initialize char_map: 0 -> F, 1 -> W, 2 -> E
        vector<char> char_map = {'F', 'W', 'E'};
        
        // Only store previous and current DP states
        vector<vector<int>> prev_dp(3, vector<int>(2001, 0));
        vector<vector<int>> cur_dp(3, vector<int>(2001, 0));
        
        // Initialize the DP for the first character
        if (s[0] == 'F') {
            prev_dp[2][999] = 1;  // Earth loses to Fire
            prev_dp[1][1001] = 1; // Water wins over Fire
            prev_dp[0][1000] = 1; // Fire ties with Fire
        } else if (s[0] == 'W') {
            prev_dp[2][1001] = 1; // Earth wins over Water
            prev_dp[1][1000] = 1; // Water ties with Water
            prev_dp[0][999] = 1;  // Fire loses to Water
        } else {
            prev_dp[2][1000] = 1; // Earth ties with Earth
            prev_dp[1][999] = 1;  // Water loses to Earth
            prev_dp[0][1001] = 1; // Fire wins over Earth
        }
        
        // Main DP loop
        for (int i = 1; i < n; i++) {
            char cur_char = s[i];
            
            // Clear current DP table
            for (int j = 0; j < 3; j++) {
                fill(cur_dp[j].begin(), cur_dp[j].end(), 0);
            }
            
            for (int j = 0; j < 3; j++) {
                char self_char = char_map[j];
                for (int k = 0; k <= 2000; k++) {
                    int cur_val = f_table[j][cur_char == 'F' ? 0 : cur_char == 'W' ? 1 : 2];
                    int prev_ind = k - cur_val;
                    if (prev_ind >= 0 && prev_ind <= 2000) {
                        for (int x = 0; x < 3; x++) {
                            if (x != j) {
                                cur_dp[j][k] = (cur_dp[j][k] + prev_dp[x][prev_ind]) % MOD;
                            }
                        }
                    }
                }
            }
            
            // Swap current and previous DP tables
            swap(prev_dp, cur_dp);
        }
        
        // Calculate the final answer by summing up all winning sequences
        int ans = 0;
        for (int j = 0; j < 3; j++) {
            for (int k = 1001; k <= 2000; k++) {
                ans = (ans + prev_dp[j][k]) % MOD;
            }
        }
        
        return ans;
    }
};
",1420557509
JCrossover_14,user3751Xt,617,3610,python3,"class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        ans = []
        for i in range(0,len(nums)-k+1):
            maps = {}
            for j in range(i,i+k):
                if nums[j] not in maps:
                    maps[nums[j]]=0
                maps[nums[j]]+=1
            pairs = []
            for key,val in maps.items():
                pairs.append((val,key))
            pairs = sorted(pairs,reverse=True)
            curans = 0
            for i in range(min(x,len(pairs))):
                curans+=(pairs[i][0]*pairs[i][1])
            ans.append(curans)
        return ans
                

        ",1420520232
wddzbcdr12138,wddzbcdr12138,618,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        

        # leaf node 

        perfectTreeNode = []
        def getLevel(root):
            if not root:
                return 0, True

            leftLevel, leftBalanced = getLevel(root.left)
            rightLevel, righBalanced = getLevel(root.right)

            curLevel = max(leftLevel, rightLevel) + 1
            curBalanced = leftBalanced and righBalanced
            if leftLevel == rightLevel and leftBalanced and righBalanced:
                perfectTreeNode.append(2**curLevel-1)
            else:
                curBalanced = False

            return curLevel, curBalanced

        getLevel(root)
        perfectTreeNode.sort(reverse=True)
        # print(perfectTreeNode)
        return perfectTreeNode[k-1] if k-1 <= len(perfectTreeNode)-1 else -1",1420526335
wddzbcdr12138,wddzbcdr12138,618,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        
        summon = [""F"", ""W"", ""E""]

        MOD = 10**9 + 7

        def bobPoint(Alice, Bob):
            if Bob == ""F"" and Alice == ""E"":
                return 1
            elif Bob == ""E"" and Alice == ""W"":
                return 1
            elif Bob == ""W"" and Alice == ""F"":
                return 1
            elif Alice == ""F"" and Bob == ""E"":
                return -1
            elif Alice == ""E"" and Bob == ""W"":
                return -1
            elif Alice == ""W"" and Bob == ""F"":
                return -1
            else:
                return 0

        @lru_cache(None)
        def getDistinctSequence(index, lastBob, lastBobPoint):
            if index > len(s)-1:
                if lastBobPoint > 0:
                    return 1
                return 0

            # for BOB
            distinct = 0
            for Bob in summon:
                if Bob == lastBob:
                    continue
                curBobPoint = bobPoint(s[index], Bob) + lastBobPoint
                distinct = (distinct + getDistinctSequence(index+1, Bob, curBobPoint)) % MOD
            
            return distinct % MOD
        
        return getDistinctSequence(0, """", 0)


                
",1420557645
wddzbcdr12138,wddzbcdr12138,618,3610,python3,"import heapq
from collections import Counter
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:

        def calculateSum(nums):
            counter = Counter(nums)
            pqueue = []
            for num in counter:
                heapq.heappush(pqueue, (-counter[num], -num))
            
            arrayX = []
            for _ in range(x):
                if not pqueue:
                    break
                _, num_neg = heapq.heappop(pqueue)
                num = -num_neg
                arrayX.append(num * counter[num])
            # print(arrayX, nums)
            return sum(arrayX)

        ans = []

        i = 0
        while i < len(nums)-k+1:
            ans.append(calculateSum(nums[i:i+k]))
            i += 1
        
        return ans


        ",1420539487
Viruj Thakur,virujthakur01,619,3509,python3,"# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestPerfectSubtree(self, root: Optional[TreeNode], k: int) -> int:
        
        ans = []
        def cntNodes(r):
            nonlocal ans
            if r is None:
                return (0, True)
            
            l = cntNodes(r.left)
            r = cntNodes(r.right)
            
            if l[1] == True and r[1]== True and l[0] == r[0]:
                ans.append(l[0]+ r[0]+ 1)
                return (l[0]+r[0]+1, True)
            else:
                return (l[0]+r[0]+1, False)
            
        
        cntNodes(root)
        ans.sort(reverse= True)
        # print(ans)
        return ans[k-1] if len(ans)>=k else -1",1420539988
Viruj Thakur,virujthakur01,619,3588,python3,"class Solution:
    def countWinningSequences(self, s: str) -> int:
        n = len(s)
        moves = ['F', 'W', 'E']
        mod = 10**9+ 7
        
        dp = [[[-1]* 4 for _ in range(2002)] for __ in range(n)]
        mp = {'X': 0, 'F': 1, 'W': 2, 'E': 3}
        
        def recur(idx, diff, prev):
            if idx == n:
                if diff > 0:
                    return 1
                return 0
            
            if dp[idx][diff+ 1000][mp[prev]]!=-1:
                return dp[idx][diff+ 1000][mp[prev]]
            
            ans = 0
            for m in moves:
                if m == prev:
                    continue
                    
                if m == s[idx]:
                    ans+= recur(idx+1, diff, m)
                else:
                    if m == 'F' and s[idx]== 'W':
                        ans+= recur(idx+1, diff - 1, m)
                        ans%= mod
                    elif m == 'F' and s[idx]== 'E':
                        ans+= recur(idx+1, diff + 1, m)
                        ans%= mod
                        
                    elif m == 'W' and s[idx]== 'F':
                        ans+= recur(idx+1, diff + 1, m)
                        ans%= mod
                        
                    elif m == 'W' and s[idx]== 'E':
                        ans+= recur(idx+1, diff - 1, m)
                        ans%= mod
                        
                    elif m == 'E' and s[idx]== 'F':
                        ans+= recur(idx+1, diff - 1, m)
                        ans%= mod
                        
                    elif m == 'E' and s[idx]== 'W':
                        ans+= recur(idx+1, diff + 1, m)
                        ans%= mod
                 
            dp[idx][diff+ 1000][mp[prev]]= ans
            return ans
        
        return recur(0, 0, 'X') % mod
            
            ",1420557646
Viruj Thakur,virujthakur01,619,3610,python3,"import heapq
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        
        n = len(nums)
        i = 0
        j = min(n,i+k-1)
        ans = []

        f= defaultdict(int)
        for _ in range(j):
            f[nums[_]]+=1
        
        while j<n:
            
            f[nums[j]]+=1
            pq= []
            
            for k,v in f.items():
                heapq.heappush(pq, (-v, -k))
                
            s = 0
            cnt = 0
            
            while pq and cnt < x:
                y = heapq.heappop(pq)
                s += (y[0]* y[1])
                cnt +=1
            
            ans.append(s)
                
            # print(i, j)
            f[nums[i]]-=1
            i+=1
            j+=1
        
            
        return ans",1420527434
jason7708,jason7708,620,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        dfs(root);
        
        for(int i=0; i<k-1; i++) {
            if(!pq.empty()) {
                pq.pop();
            }
        }
        return pq.empty() ? -1 : pq.top();
    }
    // <nodes, h>
    pair<int, int> dfs(TreeNode* root) {
        if(!root) {
            return {0, 0};
        }
        auto [cntl, hl] = dfs(root->left);
        auto [cntr, hr] = dfs(root->right);
        int cnt = cntl + cntr + 1, h = max(hl, hr) + 1;
        if(pow(2, h) - 1 == cnt) {
            pq.push(cnt);
        }
        return {cnt, h};
    }
private:
    priority_queue<int> pq;
};",1420536679
jason7708,jason7708,620,3588,cpp,"class Solution {
public:
    int countWinningSequences(string s) {
        // F > E > W > F
        // Bob will never summon the same creature in two consecutive rounds.
        constexpr int mod = 1e9 + 7;
        int n = s.size();
        vector<char> v {'W', 'E', 'F', '?'};
        unordered_map<char, int> idx {{'W', 0}, {'E', 1}, {'F', 2}};
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2*n+1, vector<int>(4, INT_MIN / 2)));
        auto dfs = [&] (auto&& dfs, int i, int j, int pre) ->int {
            if(i < 0) {
                return j > n;
            }
            if(dp[i][j][pre] != INT_MIN / 2) {
                return dp[i][j][pre];
            }
            int res = 0;
            for(int k=0; k<3; k++) {
                if(v[k] == v[pre]) continue;
                if(v[k] == s[i]) {
                    res = (res + dfs(dfs, i-1, j, k)) % mod;
                }
                else if(v[k] == 'W' && s[i] == 'F') {
                    res = (res + dfs(dfs, i-1, j+1, k)) % mod;
                }
                else if(v[k] == 'F' && s[i] == 'W') {
                    res = (res + dfs(dfs, i-1, j-1, k)) % mod;
                }
                else {
                    int cur = k > idx[s[i]] ? 1 : -1;
                    res = (res + dfs(dfs, i-1, j + cur, k)) % mod;
                }
            }
            dp[i][j][pre] = res;
            return res;
        };
        return dfs(dfs, n-1, n, 3);
    }
};",1420569788
jason7708,jason7708,620,3610,cpp,"class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0; i<n-k+1; i++) {
            unordered_map<int, int> cnt;
            for(int j=i; j<=i+k-1; j++) {
                cnt[nums[j]]++;
            }
            vector<pair<int, int>> v;
            for(auto [num, c] : cnt) {
                v.push_back({c, num});
            }

            ranges::sort(v, [&] (const pair<int, int>& a, const pair<int, int>& b) {
                if(a.first == b.first) {
                    return a.second > b.second;
                }
                return a.first > b.first;
            });
            int sum = 0;
            for(int l=0; l<x && l < v.size(); l++) {
                // cout << v[l].first << ' ' << v[l].second << '\n';
                sum += v[l].second * v[l].first;
            }
            // cout << '\n';
            ans.push_back(sum);
        }
        return ans;
    }
};",1420528820
Mridul Pandey,mridul_cr7,621,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

int cal(TreeNode* root,int lvl,int &mn,bool &tell)
{
    if(root->left==NULL && root->right==NULL)
    {
        if(mn==-1)
            mn=lvl;
        else if(lvl!=mn)
            tell=false;
        return 1;
    }
    int sz=0;
    
    if(root->left!=NULL)
    {
        sz+=cal(root->left,lvl+1,mn,tell);
    }
    else
    {
        tell=false;
    }
    if(root->right!=NULL)
    {
        sz+=cal(root->right,lvl+1,mn,tell);
    }
    else
    {
        tell=false;
    }
    return sz+1;
}

void dfs(TreeNode* root,vector<int>& ans)
{
    if(root==NULL)
        return;
    int mn=-1;
    bool tell=true;
    int sz=cal(root,0,mn,tell);
    if(tell==true)
        ans.push_back(sz);
    dfs(root->left,ans);
    dfs(root->right,ans);
}

class Solution {
public:
    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> ans;
        dfs(root,ans);
        int sz=ans.size();
        sort(ans.begin(),ans.end(),greater<int>());
        if(k>sz)
            return -1;
        else
            return ans[k-1];
    }
};",1420533582
Mridul Pandey,mridul_cr7,621,3588,cpp,"int mod=1e9+7;

int tell(char al,char bb)
{
    if(bb=='F' && al=='E')
        return 1;
    else if(bb=='W' && al=='F')
        return 1;
    else if(bb=='E' && al=='W')
        return 1;
    else if(al=='F' && bb=='E')
        return -1;
    else if(al=='W' && bb=='F')
        return -1;
    else if(al=='E' && bb=='W')
        return -1;
    else
        return 0;
}

int mem(string &s,vector<vector<vector<int>>> &dp,int n,int curr,int pts,int lst)
{
    if(curr==n)
    {
        if(pts>n)
            return 1;
        else
            return 0;
    }
    if(dp[curr][pts][lst]!=-1)
    {
        return dp[curr][pts][lst];
    }
    int ans=0;
    for(int j=1;j<=3;j++)
    {
        if(j!=lst)
        {
            char bb;
            if(j==1)
                bb='F';
            else if(j==2)
                bb='W';
            else
                bb='E';
            int pt=tell(s[curr],bb);
            ans=ans+mem(s,dp,n,curr+1,pts+pt,j);
            ans=ans%mod;
        }
    }
    dp[curr][pts][lst]=ans;
    return dp[curr][pts][lst];
    
}


class Solution {
public:
    int countWinningSequences(string s) {
        int n=s.size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>> (2*n+1,vector<int> (4,-1)));
        return mem(s,dp,n,0,n,0);
    }
};",1420553464
Mridul Pandey,mridul_cr7,621,3610,cpp,"bool comp1(const pair<int,int> &v1, const pair<int,int> &v2)
{

    if(v1.second==v2.second)
        return v1.first > v2.first;
    return v1.second>v2.second;
}


class Solution {
public:
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<=n-k;i++)
        {
            int count=0;
            int j=i;
            map<int,int> mp;
            while(count<k)
            {
                mp[nums[j]]++;
                j++;
                count++;
            }
            vector<pair<int,int>> a;
            for(auto xi:mp)
            {
                a.push_back({xi.first,xi.second});
            }
            sort(a.begin(),a.end(),comp1);
            int sz=a.size();
            int sum=0;
            for(int j=0;j<min(x,sz);j++)
            {
                sum=sum+a[j].second*a[j].first;
            }
            ans.push_back(sum);
        }
        return ans;
    }
};",1420563928
hellotestabc,hellotestabc,625,3509,cpp,"/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int traverse(TreeNode* root, vector<int>& out) {
        if (root == nullptr) {
            return 0;
        }

        int right = traverse(root->right, out);
        int left = traverse(root->left, out);

        if (right == left && right != -1) {
            out.push_back(1 + right + left);
            return 1 + right + left;
        } else {
            return -1;
        }
    }

    int kthLargestPerfectSubtree(TreeNode* root, int k) {
        vector<int> out;

        traverse(root, out);

        sort(out.begin(), out.end());

        reverse(out.begin(), out.end());

        if (k > out.size()) {
            return -1;
        }

        return out[k - 1];
    }
};",1420525537
hellotestabc,hellotestabc,625,3588,cpp,"class Solution {
public:
    static constexpr long long mod = 1e9 + 7;

    int prevToInt(char prev) {
        if (prev == 'F') {
            return 0;
        } else if (prev == 'W') {
            return 1;
        } else if (prev == 'E') {
            return 2;
        }

        cout << ""invalid "" << prev << endl;
        return -1;
    }

    long long traverse(const string& s, int ptr, char prev, int points, vector<vector<vector<int>>>& dp) {
        if (ptr >= s.size()) {
            if (points > 0) {
                return 1;
            } else {
                return 0;
            }
        }

        if (prev != '0' && dp[ptr][points + s.size()][prevToInt(prev)] != -1) {
            return dp[ptr][points + s.size()][prevToInt(prev)];
        }

        long long total = 0;

        if (prev != 'F') {
            if (s[ptr] == 'F') {
                total += ((total % mod) + (traverse(s, ptr + 1, 'F', points, dp) % mod)) % mod;
            } else if (s[ptr] == 'W') {
                total += ((total % mod) + (traverse(s, ptr + 1, 'F', points - 1, dp) % mod)) % mod;
            } else if (s[ptr] == 'E') {
                total += ((total % mod) + (traverse(s, ptr + 1, 'F', points + 1, dp) % mod)) % mod;
            }
        }

        if (prev != 'W') {
            if (s[ptr] == 'W') {
                total = ((total % mod) + (traverse(s, ptr + 1, 'W', points, dp) % mod)) % mod;
            } else if (s[ptr] == 'F') {
                total = ((total % mod) + (traverse(s, ptr + 1, 'W', points + 1, dp) % mod)) % mod;
            } else if (s[ptr] == 'E') {
                total = ((total % mod) + (traverse(s, ptr + 1, 'W', points - 1, dp) % mod) % mod);
            }
        }

        if (prev != 'E') {
            if (s[ptr] == 'E') {
                total = ((total % mod) + (traverse(s, ptr + 1, 'E', points, dp) % mod)) % mod;
            } else if (s[ptr] == 'W') {
                total = ((total % mod) + (traverse(s, ptr + 1, 'E', points + 1, dp) % mod)) % mod;
            } else if (s[ptr] == 'F') {
                total = ((total % mod) + (traverse(s, ptr + 1, 'E', points - 1, dp) % mod)) % mod;
            }
        }

        if (prev != '0') {
            return dp[ptr][points + s.size()][prevToInt(prev)] = total % mod;
        }

        return total % mod;
    }

    int countWinningSequences(string s) {
        vector<vector<vector<int>>> dp(s.size(), vector<vector<int>>(2 * s.size() + 1, vector<int>(3, -1)));

        return traverse(s, 0, '0', 0, dp);
    }
};",1420558207
hellotestabc,hellotestabc,625,3610,cpp,"class Solution {
public:
    int xsum(vector<int>& nums, int start, int end, int x) {
        unordered_map<int, int> map;

        for (int i = start; i <= end; i++) {
            map[nums[i]]++;
        }

        vector<pair<int, int>> freq;

        for (const auto& [key, val] : map) {
            freq.push_back({key, val});
        }

        auto comp = [](pair<int, int> a, pair<int, int> b) {
            if (a.second != b.second) {
                return a.second > b.second;
            } else {
                return a.first > b.first;
            }
        };

        sort(freq.begin(), freq.end(), comp);

        int v = 0;

        for (int i = 0; i < min((int) freq.size(), x); i++) {
            v += freq[i].first * freq[i].second;
        }

        return v;
    }

    vector<int> findXSum(vector<int>& nums, int k, int x) {
        vector<int> out;

        for (int i = 0; i < nums.size() - k + 1; i++) {
            out.push_back(xsum(nums, i, i + k - 1, x));
        }

        return out;
    }
};",1420522878
